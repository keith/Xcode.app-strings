N2re16GlobalAllocatorsE
N2re19MallocZoneAllocatorE
N2re13PoolAllocatorE
N2re16AlignedAllocatorE
N2re13BaseAllocatorE
/[R=2
]E7;_
N2re9AllocatorE
N2re16SharedObjectBaseE
N2re15MallocAllocatorE
15ArcSharedObject
N2re12SharedObjectE
@(#)PROGRAM:RENetwork  PROJECT:RENetwork-326.2.0.2
33333ct@N2re14SyncCommitListE
N2re15SyncViewManagerE
N2re13UnicastStreamE
N2re16SharedAppUnicastE
N2re8SyncCastE
N2re20SyncAckedStateBufferE
N2re15MessageStreamerINS_20SyncOwnershipRequestEEE
N2re28UnreliableAckedUnicastStreamE
N2re18LeaderElectionNoneE
N2re14LeaderElectionE
?N2re17SyncObjectManagerE
N2re8internal8CallableIZNS_17SyncObjectManager20reevaluateAllViewersEvE3$_0FvPNS_8SyncViewEEJEEE
N2re8internal8CallableIZNS_17SyncObjectManager11onViewAddedEPNS_15SyncViewManagerEPNS_8SyncViewEE3$_1FvPNS_10SyncViewerEEJEEE
N2re8internal8CallableIZNS_17SyncObjectManager26addPeerStateForParticipantENS_9SharedPtrINS_18SessionParticipantEEEE3$_2FvPNS_8SyncViewEEJEEE
N2re8internal8CallableIZNS_17SyncObjectManager24receiveOwnershipRequestsERNS2_9PeerStateEE3$_3FvRKNS_20SyncOwnershipRequestEEJEEE
N2re11SyncSessionE
N2re8internal12CallableBaseIFvPNS_8SyncViewEEEE
N2re8internal12CallableBaseIFvPNS_10SyncViewerEEEE
N2re8internal12CallableBaseIFvRKNS_20SyncOwnershipRequestEEEE
N2re16MultipeerManagerE
N2re28MultipeerConnectivityServiceE
N12_GLOBAL__N_121ProtocolLayerObserverE
N12_GLOBAL__N_123SyncCustomProtocolLayerE
N12_GLOBAL__N_125CustomProtocolLayerConfigE
N12_GLOBAL__N_111AddressListE
N2re13ProtocolLayerE
N2re14ProtocolHandleE
N2re20SharedAppSyncManagerE
N2re20SharedAppSyncManager9PeerStateE
N2re8internal8CallableIZNS_20SharedAppSyncManager20reevaluateAllViewersEvE3$_0FvPNS_8SyncViewEEJEEE
N2re8internal8CallableIZNS_20SharedAppSyncManager11onViewAddedEPNS_15SyncViewManagerEPNS_8SyncViewEE3$_1FvPNS_10SyncViewerEEJEEE
N2re8internal8CallableIZNS_20SharedAppSyncManager26addPeerStateForParticipantENS_9SharedPtrINS_18SessionParticipantEEEE3$_2FvPNS_8SyncViewEEJEEE
N2re8internal8CallableIZNS_20SharedAppSyncManager24receiveOwnershipRequestsERNS2_9PeerStateEE3$_3FvRKNS_20SyncOwnershipRequestEEJEEE
N2re8internal8CallableIZ38RESyncDiscoveryViewCreateWithAddressesE3$_0FNS_9SharedPtrINS_13ProtocolLayerEEEvEJEEE
N2re8internal12CallableBaseIFNS_9SharedPtrINS_13ProtocolLayerEEEvEEE
N12_GLOBAL__N_121DiscoveryViewObserverE
N12_GLOBAL__N_125DiscoveryIdentityObserverE
N12_GLOBAL__N_118DiscoveryViewProxyE
N12_GLOBAL__N_122DiscoveryIdentityProxyE
N2re13DiscoveryViewE
N2re17DiscoveryIdentityE
N2re12RoutingTableE
N2re19NetworkClockDefaultE
N2re12NetworkClockE
N2re22DynamicPacketBitWriterE
0EN2re15NWProtocolLayerE
N2re16NWProtocolHandleE
N2re15TransportStreamE
N2re14PacketProviderE
N2re10SyncViewerE
N2re8SyncViewE
33333ct@
@(#)PROGRAM:RESync  PROJECT:RESync-326.2.0.2
N2re14SyncSendBufferE
N2re28SyncObjectShortIDManagerImplE
N2re24SyncObjectShortIDManagerE
zD-C
N2re7SessionE
N2re17TransportListenerE
N2re8internal8CallableIZNKS_7Session35findBacklogItemWithConnectionHandleEyPmEUlRKNS2_11BacklogItemEE_FbS6_EJEEE
N2re8internal12CallableBaseIFbRKNS_7Session11BacklogItemEEEE
N2re8internal8CallableIZNS_7Session20discoveryViewDidJoinEPNS_13DiscoveryViewENS_9SharedPtrINS_17DiscoveryIdentityEEEE3$_1FvvEJEEE
N2re8internal8CallableIZNS_7Session21discoveryViewDidLeaveEPNS_13DiscoveryViewENS_9SharedPtrINS_17DiscoveryIdentityEEEE3$_2FvvEJEEE
N2re8internal8CallableIZNKS_7Session27findBacklogItemWithIdentityERKNS_9SharedPtrINS_17DiscoveryIdentityEEEPmEUlRKNS2_11BacklogItemEE_FbSB_EJEEE
N2re8internal12CallableBaseIFvvEEE
N2re21StaticPacketBitWriterE
N2re25SyncSelectiveAckedUnicastE
N2re8internal8CallableIZNS_25SyncSelectiveAckedUnicast4sendERKNS_5SliceINS_10SyncCommitEEERKNS3_INS_9SharedPtrINS_10SyncObjectEEEEEPNS_16SyncObjectViewerERNS_22SyncObjectWriteContextEE3$_1FvRKS4_EJEEE
N2re8internal12CallableBaseIFvRKNS_10SyncCommitEEEE
N2re15MessageStreamerINS_23SyncHistoryResetRequestEEE
N2re26SyncReliableOrderedUnicastE
N12_GLOBAL__N_120SessionObserverProxyE
22RESyncNetSessionConfig
N2re20SyncObjectTypedStoreE
N2re15SyncObjectStoreE
N2re22MultipeerProtocolLayerE
N12_GLOBAL__N_116MCProtocolHandleE
N2re23TransportCommandsQueuedE
N2re17TransportCommandsE
N2re33TransportCommandsThreadedProtocolE
N2re25TransportCommandsDispatchE
N2re10SyncObjectE
N2re10PacketPoolE
N2re18SessionParticipantE
N2re9BitWriterE
N2re16DynamicBitWriterE
N2re18NetworkSyncManagerE
N2re18NetworkSyncServiceE
N2re16SyncObjectViewerE
N12_GLOBAL__N_117SnapshotBitWriterE
N2re26LeaderElectionLowestPeerIDE
N2re9TransportE
N2re21ProtocolLayerListenerE
N2re8internal8CallableIZNS_9Transport6deinitEvE3$_0FvvEJEEE
N2re8internal8CallableIZNS_9Transport6deinitEvE3$_1FvvEJEEE
N2re8internal8CallableIZNS_9Transport6deinitEvE3$_2FvvEJEEE
N2re8internal8CallableIZNS_9Transport18flushNetworkEventsEvE3$_3FvvEJEEE
N2re8internal8CallableIZNS_9Transport17flushOutgoingDataEvE3$_4FvvEJEEE
N2re8internal8CallableIZNS_9Transport7connectERKNS_7AddressEE3$_5FvvEJEEE
N2re8internal8CallableIZZNS_9Transport7connectERKNS_7AddressEENK3$_5clEvEUlvE_FvvEJEEE
N2re8internal8CallableIZNS_9Transport21connectionStateActiveEyRKNS_15ConnectionEventEE3$_6FvvEJEEE
N2re8internal8CallableIZNS_9Transport21connectionStateActiveEyRKNS_15ConnectionEventEE3$_7FvvEJEEE
N2re8internal8CallableIZNS_9Transport21connectionStateActiveEyRKNS_15ConnectionEventEE3$_8FvvEJEEE
N2re8internal8CallableIZNS_9Transport22connectionStateClosingEyRKNS_15ConnectionEventEE3$_9FvvEJEEE
N2re8internal8CallableIZNS_9Transport11onConnectedEPNS_13ProtocolLayerEPNS_14ProtocolHandleERKNS_7AddressEE4$_10FvvEJEEE
N2re8internal8CallableIZNS_9Transport14onDisconnectedEPNS_13ProtocolLayerEPNS_14ProtocolHandleERKNS_7AddressEE4$_11FvvEJEEE
N2re8internal8CallableIZNS_9Transport7onErrorEPNS_13ProtocolLayerEPNS_14ProtocolHandleENS_14TransportErrorEE4$_12FvvEJEEE
N2re8internal8CallableIZNS_9Transport14onUnresponsiveEPNS_13ProtocolLayerEPNS_14ProtocolHandleEE4$_13FvvEJEEE
N2re8internal8CallableIZNS_9Transport12onResponsiveEPNS_13ProtocolLayerEPNS_14ProtocolHandleEE4$_14FvvEJEEE
N2re8internal8CallableIZNS_9Transport14onReceiveAsyncEPNS_13ProtocolLayerEPNS_14ProtocolHandleENS_9ChannelIdEPKvjE4$_15FvvEJEEE
N2re8internal8CallableIZNS_9Transport20setDisconnectTimeoutEjE4$_16FvvEJEEE
N2re8internal8CallableIZNS_9Transport17destroyConnectionEyE4$_17FvvEJEEE
N2re22MultipeerDiscoveryViewE
10MCIdentity
N2re16TcpProtocolLayerE
N2re17TcpProtocolHandleE
N12_GLOBAL__N_124CustomLeaderElectionImplE
N12_GLOBAL__N_120CustomLeaderElectionE
N2re18DebugProtocolLayerE
N2re19DebugProtocolHandleE
N2re20ServiceObserverProxyE
N2re27TransferReportObserverProxyE
N2re18DebugDiscoveryViewE
N2re22DebugDiscoveryIdentityE
N2re18SyncObjectTypeInfoE
N2re17PacketStatsFilterE
SIMD-aligned allocator
profiler.statisticcollection.enable
Thread %p
<unknown>
expected integer, found tag %x
!overflow
setCapacity
assertion failure: cond '!overflow'
assertion failure: cond '%s' (%s:%i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').
removeStableAt
assertion failure: cond '%s' (%s:%i) 
m_blockSize <= std::numeric_limits<uint32_t>::max()
PoolAllocator
assertion failure: cond 'm_blockSize <= std::numeric_limits<uint32_t>::max()'
assertion failure: cond '%s' (%s:%i) Free pool entry %p is corrupted
!hasEntryMemoryBeenStomped(entry)
alloc
assertion failure: cond '!hasEntryMemoryBeenStomped(entry)'
isBlockFull(block)
assertion failure: cond 'isBlockFull(block)'
<UNKNOWN>
assertion failure: cond '%s' (%s:%i) Called free() on pool %s which is not bound to a parent allocator (already destroyed?)
!m_enableAsserts
free
assertion failure: cond '!m_enableAsserts'
assertion failure: cond '%s' (%s:%i) Pool block is invalid. This could mean the memory address was not allocated from this pool, or other corruption. Enable RE_MEMORY_TRACKING to debug
!m_enableAsserts || block->m_magic == blockGuard
assertion failure: cond '!m_enableAsserts || block->m_magic == blockGuard'
m_blocks.size() <= std::numeric_limits<uint32_t>::max()
addPoolBlock
assertion failure: cond 'm_blocks.size() <= std::numeric_limits<uint32_t>::max()'
index <= m_length
assertion failure: cond 'index <= m_length'
assertion failure: cond '%s' (%s:%i) Out of memory.
newBuffer
setCapacity
assertion failure: cond 'newBuffer'
assertion failure: cond '%s' (%s:%i) Index out of range. index = %zu, size = %zu
substr
assertion failure: cond '%s' (%s:%i) offset out of range. offset = %zu, size = %zu
offset < m_length
rfind
assertion failure: cond 'offset < m_length'
com.apple.re
Foundation.Core
enableSignposts
enableHighFrequencyNetworkTracing
com.apple.re
%s.%s
com.apple.re.network.multipeerservice
com.apple.renetwork.multipeerservice
!"Unreachable code"
assertion failure: cond '%s' (%s:%i) Index out of range. index = %zu, size = %zu
operator[]
!overflow
assertion failure: cond '!overflow'
assertion failure: cond '%s' (%s:%i) Size overflow in DynamicOverflowArray<T, N>::setCapacity(). Element size = %zu, capacity = %zu
assertion failure: cond '%s' (%s:%i) DynamicOverflowArray<T, N> is out of memory (tried to allocate %zu bytes from allocator '%s').
index < m_size
assertion failure: cond 'index < m_size'
assertion failure: cond '%s' (%s:%i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu
init
assertion failure: cond '%s' (%s:%i) Out of memory.
m_data
assertion failure: cond 'm_data'
allocBlock
assertion failure: cond '%s' (%s:%i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').
block.elements
assertion failure: cond 'block.elements'
block.allocationCounters
assertion failure: cond 'block.allocationCounters'
assertion failure: cond '%s' (%s:%i) 
m_length + result < m_capacity
vappendf
assertion failure: cond 'm_length + result < m_capacity'
com.apple.re
Foundation.Memory
ArcObject
insert
assertion failure: cond '%s' (%s:%i) Out of memory.
temp
init
assertion failure: cond 'temp'
index < size()
assertion failure: cond 'index < size()'
slice
assertion failure: cond '%s' (%s:%i) Invalid count. index = %zu, count = %zu, array size = %zu
endIndexExclusive <= m_size
assertion failure: cond 'endIndexExclusive <= m_size'
assertion failure: cond '%s' (%s:%i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu
m_data
assertion failure: cond 'm_data'
allocBlock
assertion failure: cond '%s' (%s:%i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').
block.elements
assertion failure: cond 'block.elements'
block.allocationCounters
assertion failure: cond 'block.allocationCounters'
assertion failure: cond '%s' (%s:%i) element isn't in data array
handle
RESyncSessionSendAll
service != __null
commits != __null
RESyncSessionReceive
session != __null
handler != __null
removeStableAt
v16@?0Q8
SendCommit
RecvCommit
assertion failure: cond '%s' (%s:%i) 
packet.capacity() >= kHeaderSize
writeHeader
assertion failure: cond 'packet.capacity() >= kHeaderSize'
!writer.isOverflow()
assertion failure: cond '!writer.isOverflow()'
capacity() >= offset || (offset < 0 && -offset <= (static_cast<uint8_t*>(m_data) - static_cast<uint8_t*>(m_buffer)) )
offsetBy
assertion failure: cond 'capacity() >= offset || (offset < 0 && -offset <= (static_cast<uint8_t*>(m_data) - static_cast<uint8_t*>(m_buffer)) )'
assertion failure: cond '%s' (%s:%i) Index out of range. index = %zu, size = %d.
b < kBitCount
toWordIndex
assertion failure: cond 'b < kBitCount'
nullptr
v24@?0r^v8^v16
removeStableAt
!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator
operator=
assertion failure: cond '!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator'
network.multipeerservice.sessionInitTimeOutMs
network.multipeerservice.sessionHandshakeTimeOutMs
network.multipeerservice.sessionIsLeader
network.multipeerservice.sessionForceAuthorityOverIncomingObjects
network.multipeerservice.sessionShutdownOnVersionMismatch
network.multipeerservice.sessionUseReliableSync
network.multipeerservice.enableThrottling
network.multipeerservice.enableMessageFragmentation
network.multipeerservice.sessionResendPeriodMs
network.multipeerservice.syncPacketSizeLimit
Q16@?0@"NSObject<OS_nw_framer>"8
Q28@?0*8Q16B24
channel
v36@?0@"NSObject<OS_nw_framer>"8@"NSObject<OS_nw_protocol_metadata>"16Q24B32
B16@?0r^v8
i16@?0@"NSObject<OS_nw_framer>"8
re-net-header
Opaque
B32@?0^{RESyncBitReader=}8^v16r^{RESyncObjectContext=}24
B32@?0^{RESyncBitWriter=}8r^v16r^{RESyncObjectContext=}24
B32@?0^{RESyncBitReader=}8^{RESyncBitWriter=}16r^{RESyncObjectReadContext=}24
v32@?0^{RESyncBitReader=}8^{RESyncBitWriter=}16r^{RESyncObjectWriteContext=}24
RESyncProtocolLayerObserverOnCreate
observer != __null
protocolLayerCreate != __null
RESyncProtocolLayerObserverOnDestroy
protocolLayerDestroy != __null
RESyncProtocolLayerObserverOnInit
protocolLayerInit != __null
RESyncProtocolLayerObserverOnInitWithConfig
protocolLayerInitWithConfig != __null
RESyncProtocolLayerObserverOnDeinit
protocolLayerDeinit != __null
RESyncProtocolLayerObserverOnOpen
protocolLayerOpen != __null
RESyncProtocolLayerObserverOnOpenNullable
protocolLayerOpenNullable != __null
RESyncProtocolLayerObserverOnClose
protocolLayerClose != __null
RESyncProtocolLayerObserverOnDisconnect
protocolLayerDisconnect != __null
RESyncProtocolLayerObserverOnSend
protocolLayerSend != __null
RESyncProtocolLayerObserverOnUpdate
protocolLayerUpdate != __null
RESyncProtocolLayerObserverOnWait
protocolLayerWait != __null
RESyncProtocolLayerObserverOnWakeup
protocolLayerWakeup != __null
RESyncProtocolLayerObserverOnLocalAddresses
protocolLayerLocalAddresses != __null
RESyncProtocolLayerObserverOnHostStats
protocolLayerHostStats != __null
RESyncProtocolLayerObserverOnSetDisconnectTimeout
protocolLayerSetDisconnectTimeout != __null
RESyncProtocolLayerObserverOnPreferredPacketSize
protocolLayerPreferredPacketSize != __null
RESyncProtocolLayerObserverOnSetListener
protocolLayerSetListener != __null
RESyncProtocolLayerConfigGetPacketPool
config != __null
RESyncProtocolLayerConfigGetNetworkQueue
RESyncCustomProtocolLayerCreate
Either RESyncProtocolLayerObserverOnInit() or RESyncProtocolLayerObserverOnInitWithConfig() observer implementation is required.
RESyncProtocolLayerObserverOnDeinit() observer implementation is required.
Either RESyncProtocolLayerObserverOnOpen() or RESyncProtocolLayerObserverOnOpenNullable() observer implementation is required.
RESyncProtocolLayerObserverOnClose() observer implementation is required.
RESyncProtocolLayerObserverOnDisconnect() observer implementation is required.
RESyncProtocolLayerObserverOnUpdate() observer implementation is required.
None or both RESyncProtocolLayerObserverOnWait() and RESyncProtocolLayerObserverOnWakeup() observer implementations are required.
RESyncProtocolLayerObserverOnLocalAddresses() observer implementation is required.
RESyncProtocolLayerObserverOnHostStats() observer implementation is required.
RESyncProtocolLayerObserverOnSetDisconnectTimeout() observer implementation is required.
RESyncProtocolLayerObserverOnPreferredPacketSize() observer implementation is required.
RESyncCustomProtocolLayerSetThreadModeDispatchTransport
protocolLayer != __null
RESyncCustomProtocolLayerOnConnected
handle != __null
RESyncCustomProtocolLayerOnDisconnected
RESyncCustomProtocolLayerOnError
RESyncCustomProtocolLayerOnReceiveData
fromHandle != __null
channel < kRESyncChannelIdMaxChannels
RESyncCustomProtocolLayerOnReceiveDataNoAsync
RESyncCustomProtocolLayerOnUnresponsive
RESyncCustomProtocolLayerOnResponsive
RESyncPacketPoolAllocPacket
pool != __null
RESyncPacketPoolFreePacket
packet != __null
RESyncAddressListCreate
addresses != __null || addressesCount == 0
RESyncAddressListCreateWithAddress
address != __null
RESyncAddressListGetAddressAtIndex
addressList != __null
RESyncAddressListGetSize
RESyncPacketGetData
RESyncPacketGetSize
RESyncPacketSetSize
RESyncPacketGetCapacity
RESyncPacketGetDeliveryMethod
RESyncProtocolHandleGetConnection
RESyncProtocolHandleConnectionSetStats
stats != __null
RESyncProtocolHandleConnectionGetStats
RESyncProtocolHandleGetUserData
RESyncProtocolHandleSetUserData
RESyncProtocolHandleQueueDeqeue
channelId < kRESyncChannelIdMaxChannels
type == kRESyncPacketQueueTypeSend || type == kRESyncPacketQueueTypeReceive
RESyncProtocolHandleQueueEnqeue
_packet != __null
RESyncProtocolHandleQueueGetSizeInBytes
RESyncProtocolHandleQueueGetCapacityInBytes
RESyncProtocolHandleQueueGetSize
0.0.0.0
v16@?0@?<B@?C^vIi>8
assertion failure: cond '%s' (%s:%i) Invalid addresses.
addresses != nullptr || addressesCount == 0
RESyncDiscoveryViewCreateWithAddresses
assertion failure: cond 'addresses != nullptr || addressesCount == 0'
assertion failure: cond '%s' (%s:%i) Invalid protocol provided.
protocolLayer != nullptr
assertion failure: cond 'protocolLayer != nullptr'
assertion failure: cond '%s' (%s:%i) Out of memory.
temp
init
assertion failure: cond 'temp'
operator[]
v20@?0i8@"NSObject<OS_nw_error>"12
v8@?0
v16@?0@"NSObject<OS_nw_connection>"8
re-nw-unix-context
re-nw-protocol-listener
fd://
re-nw
v16@?0@"NSObject<OS_nw_error>"8
v36@?0@"NSObject<OS_dispatch_data>"8@"NSObject<OS_nw_content_context>"16B24@"NSObject<OS_nw_error>"28
v16@?0@"NSObject<OS_nw_data_transfer_report>"8
assertion failure: cond '%s' (%s:%i) Implementation required to support update synchronization.
wait
B40@?0@"NSObject<OS_dispatch_data>"8Q16r^v24Q32
!overflow
assertion failure: cond '!overflow'
copy
assertion failure: cond '%s' (%s:%i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu
invalid
waiting
ready
failed
cancelled
unknown
operator[]
removeAt
readDeltaCb
readCb
assertion failure: cond '%s' (%s:%i) Index out of range. fromInclusive = %zu, size = %zu
fromInclusive <= size()
range
assertion failure: cond 'fromInclusive <= size()'
assertion failure: cond '%s' (%s:%i) Index out of range. toExclusive = %zu, size = %zu
toExclusive <= size()
assertion failure: cond 'toExclusive <= size()'
:%hu
destination
ownershipSequence
overrun: attempted to read %zu bytes, only %zu remaining
couldn't grow buffer to %zu bytes (buffer = %p, capacity = %d)
com.apple.re
Network
RESyncCreateSyncObjectWriteContextNoAlloc
bytes != __null
size >= sizeof(re::SyncObjectWriteContext)
RESyncDestroySyncObjectWriteContextNoDealloc
context != __null
RESyncAddSyncObjectWriteContextEntry
entry != __null
RESyncGetSyncObjectWriteContextEntry
RESyncRemoveSyncObjectWriteContextEntry
RESyncObjectWriteContextGetSession
RESyncObjectWriteContextGetDestinationPeerID
RESyncObjectWriteContextSupportsProtocolLevel
RESyncObjectWriteContextIsLocalSession
operator[]
assertion failure: cond '%s' (%s:%i) Array is empty
m_size > 0
last
assertion failure: cond 'm_size > 0'
network.session.maxTotalBandwidthBpsLocal
network.session.maxTotalBandwidthBpsRemote
NetworkUnreliable
NetworkReliable
assertion failure: cond '%s' (%s:%i) Session: Unknown state %d(%s).
stateEvent
assertion failure: cond '%s' (%s:%i) Invalid event %d in state '%s'
stateInit
stateFinished
stateActive
None
Init
Active
Finished
TransitionIn
TransitionOut
Update
DispatchBacklog
StartMigration
ParticipantsUpdate
removeManyStableAt
(new)
(data)
(destroyed)
(ownerChange)
Commit
(Atomic)
(Held)
(Fwd)
ReSendCommit
RESyncNetSessionCreate
configuration != __null
Use RESyncNetSessionConfigurationSetTransportQueue() to configure transport queue.
Use RESyncNetSessionConfigurationSetDiscoveryView() to configure discovery view.
RESyncNetSessionConfigurationSetTransportIsFragmented
RESyncNetSessionPublishBandwidthEvent
bwEvent != __null
removeStableAt
SyncObject
SyncObjectStateHistory
operator[]
removeManyStableAt
privateDelegate
assertion failure: cond '%s' (%s:%i) Unknown new connection requested.
open
assertion failure: cond '!"Unreachable code"'
assertion failure: cond '%s' (%s:%i) Not implemented
wakeup
com.apple.rekit.hello.ack
com.apple.rekit.hello
assertion failure: cond '%s' (%s:%i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu
newData
assertion failure: cond 'newData'
operator[]
com.apple.re.networking.network
assertion failure: cond '%s' (%s:%i) Size overflow in Queue<T>::setCapacity(). Element size = %zu, capacity = %zu
assertion failure: cond '%s' (%s:%i) Queue<T> is out of memory (tried to allocate %zu bytes from allocator '%s').
thread constructor failed
operator[]
removeStableAt
RESyncCreateSyncObjectReadContextNoAlloc
size >= sizeof(SyncObjectReadContext)
RESyncDestroySyncObjectReadContextNoDealloc
RESyncAddSyncObjectReadContextEntry
RESyncGetSyncObjectReadContextEntry
RESyncRemoveSyncObjectReadContextEntry
RESyncObjectReadContextGetSession
RESyncObjectReadContextGetSourcePeerID
RESyncObjectReadContextGetSyncableGuid
RESyncObjectReadContextSupportsProtocolLevel
RESyncObjectReadContextIsLocalSession
PacketPool%s
network.packetpool.minPacketSize
network.packetpool.maxFreePacketSize
network.packetpool.maxFreePacketPoolMemory
allocate
assertion failure: cond '%s' (%s:%i) [Network] Failed to allocate packet buffer of size %u(%u), totalCount=%d, totalBytes=%u, availableCount=%d, availableBytes=%u
false
assertion failure: cond 'false'
assertion failure: cond '%s' (%s:%i) Marker is out of bounds
marker.byteOffset + 4 <= m_dataSize
writeUInt32At
assertion failure: cond 'marker.byteOffset + 4 <= m_dataSize'
undef
assertion failure: cond '%s' (%s:%i) data==null, dataSize==%u, syncObjTypeID: %llu, debugName: %s
!(data == nullptr && dataSize > 0)
writeData
assertion failure: cond '!(data == nullptr && dataSize > 0)'
assertion failure: cond '%s' (%s:%i) Writer is in inconsistent state
m_dataSize >= m_byteOffset
bytesLeft
assertion failure: cond 'm_dataSize >= m_byteOffset'
m_byteOffset < m_dataSize || m_bitOffset == 0
assertion failure: cond 'm_byteOffset < m_dataSize || m_bitOffset == 0'
assertion failure: cond '%s' (%s:%i) 
bytesToCopy <= size()
copyDataTo
assertion failure: cond 'bytesToCopy <= size()'
assertion failure: cond '%s' (%s:%i) memcpy destination data is null, syncObjTypeID: %llu, debugName: %s
m_data != nullptr
operator()
assertion failure: cond 'm_data != nullptr'
object->retainCount() > 0
objectExitedView
assertion failure: cond 'object->retainCount() > 0'
commit.snapshot.size() < ~uint32_t()
writeCommit
assertion failure: cond 'commit.snapshot.size() < ~uint32_t()'
assertion failure: cond '%s' (%s:%i) SyncPacker::writeCtorData data==null && dataSize>0, syncObjTypeID: %llu, debugName: %s
!(data==nullptr && dataSize>0)
writeCtorData
assertion failure: cond '!(data==nullptr && dataSize>0)'
RESyncViewSetUserData
view != __null
RESyncViewGetUserData
RESyncViewGetObjectCount
RESyncViewSetOwnerPeerID
RESyncViewGetOwnerPeerID
RESyncViewSetFromPeerID
RESyncViewGetFromPeerID
RESyncViewEnumerateObjects
cb != __null
network.transport.compressionMethod
assertion failure: cond '%s' (%s:%i) Invalid channel
channel < kChannelIdMaxChannels
receive
assertion failure: cond 'channel < kChannelIdMaxChannels'
assertion failure: cond '%s' (%s:%i) 
*index < m_streams.size()
removeStream
assertion failure: cond '*index < m_streams.size()'
m_index < kHistorySize
measure
assertion failure: cond 'm_index < kHistorySize'
onSend
onReceive
Pending
Closing
capacity() >= offset
offsetTo
assertion failure: cond 'capacity() >= offset'
operator[]
!isInitialized() || m_allocator == other.m_allocator
assertion failure: cond '!isInitialized() || m_allocator == other.m_allocator'
assertion failure: cond '%s' (%s:%i) Size overflow in FixedArray<T>::slice(size_t,size_t). index, %zu, count = %zu, array size = %zu
v16@?0^v8
operator[]
removeAt
deinit
assertion failure: cond '%s' (%s:%i) kevent failed
usb://
/System/Library/PrivateFrameworks/MobileDevice.framework/MobileDevice
USBMuxConnectByPort
assertion failure: cond '%s' (%s:%i) kevent failed %d
disconnect
assertion failure: cond '%s' (%s:%i) IPv6 not supported yet
getAddressFromSocket
connectionAdded
update
assertion failure: cond '%s' (%s:%i) Accept
assertion failure: cond '%s' (%s:%i) Unknown event
assertion failure: cond '%s' (%s:%i) Invalid Connection status
operator[]
debug://%d/%d
debug://*
debug://%d
RESyncServiceObserverOnSessionDidReceiveOwnershipHandoff
sessionDidReceiveOwnershipHandoff != __null
RESyncServiceObserverOnSessionDidReceiveOwnershipChange
sessionDidReceiveOwnershipChange != __null
RESyncServiceStartSyncWithSession
createProtocolLayer
local
operator[]
network.transport.enableLog
network.transport.enableThrottling
network.transport.enableMessageFragmentation
network.syncCommit.enableLog
network.syncObjectStateHistoryBufferSize
network.sharedAppSpecialization
com.apple.re
Foundation.Serialization
expected bool, found tag %x
expected object, found tag %x
overrun in beginDictionary: %zu items, only %zu bytes remaining
expected dictionary, found tag %x
reached end of buffer but expected more dictionary entries
expected data, found tag %x
overrun in data: size = %zu, only %zu bytes left
invalid size when skipping string or data: %zu, only %zu remaining
unexpected tag while skipping: %x
Cache-aligned allocator
TLB-aligned allocator
System allocator
removeAt
base64EncodedStringWithOptions:
.cxx_destruct
handles
T@"<MCSessionPrivateDelegate>",W,N,V_nextDelegate
privateDelegate
T@"NSLock",&,N,V_handlesLock
session
TQ,R
.cxx_construct
dealloc
T#,R
isProxy
T@"MCSession",&,N,V_session
release
T@"NSString",R,C
setHandlesLock:
T^{MultipeerProtocolLayer=^^?{ArcRefCount=(isa_t=^v)}^{Allocator}^{ProtocolLayerListener}{ObjCObject=@}{ObjCObject=@}{Address={DynamicString=^{Allocator}*QQ}}},N,V_protocolLayer
T^{ProtocolLayerListener=^^?},N,V_listener
T{DynamicArray<re::SharedPtr<(anonymous namespace)::MCProtocolHandle>>=^{Allocator}QQI^v},N,V_handles
UTF8String
_handles
_handlesLock
_listener
_nextDelegate
_protocolLayer
_session
addObserver:forKeyPath:options:context:
archivedDataWithRootObject:requiringSecureCoding:error:
arrayWithObjects:count:
autorelease
boolValue
bundleIdentifier
bytes
class
conformsToProtocol:
connectedPeers
count
countByEnumeratingWithState:objects:count:
dataWithBytesNoCopy:length:
dataWithBytesNoCopy:length:freeWhenDone:
debugDescription
description
dictionaryForKey:
disconnect
displayName
doubleValue
floatValue
handlesLock
hash
init
initWithLayer:
initWithSession:protocolLayer:
intValue
isEqual:
isEqualToString:
isKindOfClass:
isMemberOfClass:
layer
length
listener
listenerQueue
listenerState
lock
mainBundle
makeAddressFromPeerID:
myPeerID
nextDelegate
objectAtIndex:
objectForKey:
observeValueForKeyPath:ofObject:change:context:
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
protocolLayer
rangeOfString:options:
readySemaphore
removeObserver:forKeyPath:
respondsToSelector:
retain
retainCount
self
sendData:toPeers:withMode:error:
session:didFinishReceivingResourceWithName:fromPeer:atURL:withError:propagate:
session:didReceiveCertificate:fromPeer:certificateHandler:propagate:
session:didReceiveData:fromPeer:propagate:
session:didReceiveStream:withName:fromPeer:propagate:
session:didStartReceivingResourceWithName:fromPeer:withProgress:propagate:
session:peer:didChangeState:propagate:
setHandles:
setListener:
setNextDelegate:
setPrivateDelegate:
setProtocolLayer:
setSession:
standardUserDefaults
stopListening
stringWithFormat:
stringWithUTF8String:
substringFromIndex:
substringToIndex:
superclass
transportQueue
unlock
unsignedIntValue
unsignedLongLongValue
waitForReady
zone
Session: config override netMaxTotalBandwidthBpsLocal=%llu
Session: config override netMaxTotalBandwidthBpsRemote=%llu
Cannot initialize transport.
No local identity set for session.
Session: initialized (%p) {isLocal=%d, useReliableSync=%d, isRestrictive=%d, resendPeriodMs=%u, syncPacketSizeLimit=%u, syncInboundQueueLimit=%u}
Session: max bandwidth: %llu bps
Session: deinitialized (%p).
Cannot set routing table {isInitialized: %d, routingTable parameter: %p, session routing table:%p}
Stopping Session (%p) with error:%d after flushing transport events
Received SessionMessages::kPeerHello from %s
Error receiving message of type kPeerHello
Error receiving message of type kPeerHello: invalid peerid
Received SessionMessages::kSessionError from %s
Connection error received from ConnectionId(%llu) Error = 0x%X
Received SessionMessages::kRouteRequest
Received SessionMessages::kRouteResponse
Received SessionMessages::kRouteFail
Received unrecognized message type: %d
Aborting transport receive due to packet error: %d
Received corrupt message from '%s'. Packet error: %d, Disconnecting.
Stopping Session (%p) with packet error=kProtocolMismatch
sendSessionError: missing participant for connection!
Session: attempting to send %zu bytes on channel %d when not initialized. Data discarded.
Session: sendData over unsupported channel (%hhu): src(%llu)->dest(%llu)
No route exists for userData from %llu to %llu. Will try to discover route.
Removing %zu Pending Messages due to timeout.
sendRouteRequest: missing session for transport!
sendRouteRequest: missing participant for connection!
No hop specified in route request from %s
Failed to send routing response. src=%llu, dst-%llu, hop=%d
sendRouteResponse: missing session for transport!
sendRouteResponse: missing participant for connection!
receiveRouteResponse: missing session for transport!
receiveRouteResponse: missing participant for connection!
Failed to notify peer about failed route. src=%llu, dst-%llu, hop=%d
sendRouteFail: missing session for transport!
sendRouteFail: missing participant for connection!
Received route failure for PeerID. (%llu)
Routing table is nil
Routing table is nil, returning kInvalidPeerID
Received corrupt message from '%s'. No routing header. Disconnecting.
Received message with unknown route from '%s'. No route exists %llu->%llu.
Sending `Hello` to peer %s, count: %zu
Found backlog item for identity: %s (%s).
No pending connection for identity '%s (%s)'. Will initiate a new one.
Dropping pending connection %s. because its identity '%s (%s)' left.
Deleting participant '%s' for identity '%s (%s)'.
Session: changing state %s->%s
Session: handling event '%s' in state '%s'
Failed to initialize session in %d ms. Session will be terminated.
Remote peer ready with capabilities 0x%x
Invalid peerID
Connection '%s' did not do handshake for %d ms. Disconnecting.
Mismatched AppId, received 0x%X expecting 0x%X
Mismatched protocol, received 0x%X expecting 0x%X
Mismatched component schema, received 0x%llX expecting 0x%llX
Received `Peer Hello` from peer: %llu
removed peanut only pending handshake
Cannot read discovery data. Hello message from %s is corrupt.
Hello message received from %s is corrupt.
User context is bigger than maximum allowed (%u > %zu)
User context data received from %s is corrupt.
Peer %llu already in participant list, ignoring `Hello` from peer: 
User context data received from %s for existing participant is corrupt.
NWProtocolLayer.onConnectionStateChanged for unknown connection
NetworkSyncManager: initialized
NetworkSyncManager: uninitialized
NetworkSyncManager: Not initialized.
NetworkSyncManager: Invalid session object (%p).
NetworkSyncManager: Session already used to sync (%p).
NetworkSyncManager: Starting sync with session (%p).
NetworkSyncManager: Added new session: %p (peerID=%llu)
Failed to init session with provided config.
Sync object without snapshot among snapshot resend entries (id: %llu, type: %llu[%s]).
NetworkSyncManager: session stopped (%p) with error: %d.
Requesting ownership for invalid object. Request is ignored.
Requesting ownership for already owned object '%llu'. Request is ignored.
NetworkSyncManager: session removed (%p).
NetworkSyncManager: session scheduled (%p) for removal.
Failed to parse object %u from commit %llu.
Expected object short id
Snapshot reader (%s:%d): %s
Max bandwidth changed: %llu bps
Max bandwidth exceeded. Current bandwidth: %llu bps, Max bandwidth: %llu bps
Invalid packet data size: 0
Shared App Specialization enabled: %d
syncObjectStateHistoryBufferSize is: %u
SyncCommit log enabled: %d
Transport message fragmentation override enabled: %d
Transport throttling override enabled: %d
Transport log enabled: %d
[DebugLayer error] local=%d remote=%d connection=%d
[DebugLayer disconnected] local=%d remote=%d connection=%d
[DebugLayer connected] local=%d remote=%d connection=%d
[DebugLayer accepted] local=%d remote=%d connection=%d
[DebugLayer disconnect] local=%d remote=%d connection=%d
[DebugLayer close] local=%d remote=%d connection=%d
[DebugLayer connect] local=%d remote=%d connection=%d
Sync object without snapshot while removing from view (id: %llu, type: %llu[%s]).
Sync object without snapshot while adding to view (id: %llu, type: %llu[%s]).
%s %s%s%s Peer=%llu
RESyncGetSyncObjectContextEntry: Couldn't find entry with id=%llu
RESyncRemoveSyncObjectContextEntry: Couldn't find entry with id=%llu
RESyncAddSyncObjectWriteContextEntry: Failed to add entry using id=%llu, possible duplicate!
RESyncGetSyncObjectWriteContextEntry: Couldn't find entry with id=%llu.
RESyncRemoveSyncObjectWriteContextEntry: Couldn't find entry with id=%llu.
SyncObjectShortID %u remapped from [%llu,%llu] to [%llu,%llu]!
! Incoming.ShortId %u is not mapped to [%llu,%llu] (current mapping = [%llu,%llu])!
NWProtocolLayer.onConnectionStateChanged %p prevState=%s newState=%s
NWProtocolLayer.cancelling %p
NWProtocolLayer.removeConnection %p
NWProtocolLayer.addConnection %p
NWProtocolLayer.disconnect %p force=%d
NWProtocolLayer.close %p force=%d
NWProtocolLayer.openConnection file-descriptor=%d
NWProtocolLayer.open address=%s
NWListener.init address=%s port=any
NWListener.init address=%s port=%d
Unable to initialize listener
NWListener.newConnection
NWListener failed error=%s
NWListener.stateChanged state=%s.
NWListener.stopListening
Sync object without snapshot while adding view (id: %llu, type: %llu[%s]).
Sync object without snapshot while removing view (id: %llu, type: %llu[%s]).
Sync object without snapshot while packing ownership broadcasts (id: %llu, type: %llu[%s]).
[Ownership] Adding ownership changes for: %llu
SharedAppSyncManager: session stopped (%p) with error: %d.
SharedAppSyncManager: session started (%p).
%s: %s
Message received on unknown channel %d
Already syncing over another session. Stop it first.
No MCSession object provided.
Failed to initiate RE discovery with MCSession (%s).
[Ownership] Rejected request for locked object %llu (%llu)
[Ownership] Granted request for object %llu (%llu)
[Ownership] No NetworkSyncManager found, ownership request not forwarded.
Emiting congestion event.
[Ownership] Requesting ownership for: %llu
Found %zu orphaned objects. localPeerID=%llu. 
Sync object without snapshot while gathering orphans (id: %llu, type: %llu[%s]).
[Ownership] Corrupt ownership request.
[Ownership] Ownership response for: %llu timed out
Failed to parse ownership requests. Will drop peer.(peerID=%llu, address=%{public}s, identity=%{public}s)
Failed to parse incoming packet. Will drop peer.(peerID=%llu, address=%{public}s, identity=%{public}s)
[Ownership] Received ownership change: %llu
[Ownership] Received ownership handoff for: %llu
[Ownership] Received ownership granted response for: %llu
SyncObjectManager: session stopped (%p) with error: %d.
SyncObjectManager: session started (%p).
Resuming peerID %llu
Pausing peerID %llu.
Peer left syncing. PeerID=%llu. Address='%s'. Identity='%s'.
New peer joined object syncing. PeerID=%llu. Address='%s'. Identity='%s'.
Removing peer state. PeerID=%llu.
Adding new peer state. PeerID=%llu.
UNICAST selective acked
UNICAST reliable
Invalid peerID %llu
Received out of order packet with seqNo=%zu. Ignoring.Current window=[%zu, %zu].(address=%{public}s)
Received duplicate packet with seqNo=%zu. Ignoring.(address=%{public}s)
Corrupt packet received. Will drop.
BindFailure: Object %llu with parent %llu
Failed to parse incoming packet. Will drop peer.(peerID=%llu, address=%{public}s)
Transport is destroyed but trying to receive.
Sending sync data on paused connection to %llx ('%s'): %s
Transport is destroyed but trying to send.
%s: Invalid parameter not satisfying %s.
Please enable defaults using `defaults write -g|<application identifier> com.apple.re.<default name> -<type> <value>`.
assertion failure: Index out of range in %s. index = %zu, maximum = %zu
Index out of range in %s. index = %zu, maximum = %zu
Called free() on pool %s which is not bound to a parent allocator (already destroyed?)
Two nodes claim to be session leaders (%llu and %llu)
Cannot bind peerID %llu with connection for peer %s
Session: stopped (%p) with error: %d
Picked session leader %llu (localPeerID=%llu)
Discovered new peer: %s
Lost peer: %s
%s Id=%llu(v#%u) Parent=%llu %s%s%s%s 
%s %s%s%s Peer=%llu
%s Id=%llu(v#%u) %s%s%s%s 
%s %s%s%s Peer=%llu
Parent already bound for object: %llu, current parent: %llu, attempted new parent: %llu
Received history reset request for object {%llu, %llu}.But the object is not viewed by peer %llu.
Received history reset request for object {%llu, %llu}.But the object does not exist.
Registered sync object type %{private}s:%llu
Adding tombstone entry {guid: %llu, type: %llu, parentId: %llu}
MPC: Received data from a legacy client address=%s
MPC: Closing peer handle=%p force=%d
MPC: Disconnecting peer handle=%p force=%d
MPC: Unsupported channelID=%hhu
MPC: Error sending handshake ack: %s, reason: %s
MPC: Error sending handshake: %s, reason: %s
MPC: Error sending packet: %s.
RESyncAddSyncObjectReadContextEntry: Failed to add entry using id=%llu, possible duplicate!
RESyncGetSyncObjectReadContextEntry: Couldn't find entry with id=%llu.
RESyncRemoveSyncObjectReadContextEntry: Couldn't find entry with id=%llu.
Large packet buffer allocated: %u, totalCount=%d, totalBytes=%u, availableCount=%d, availableBytes=%u
SyncViewer already viewing this View
Sync object without snapshot while removing view from commit (id: %llu, type: %llu[%s]).
Sync object without snapshot while adding view to commit (id: %llu, type: %llu[%s]).
Encountered sync object without snapshot while packing ownership broadcasts! (id: %llu, type: %llu[%s])
NWProtocolLayer: Failed to get string representation of ip(errno=%d).
NWProtocolLayer: Unable to list network adapters(errno=%d).
NWProtocolLayer.onReceiveMessage for unknown connection
NWProtocolLayer.onReceiveMessage %p readClosed
Failed to parse commit header.
Failure reading object in commit
Expected dictionary of entries
Commit doesn't begin with an object header
Sync object without snapshot among sent snapshot entries (id: %llu, type: %llu[%s]).
Invalid session object passed to stopSyncWithSession
Peer %llu became aware of %s Guid=%llu
Peer %llu lost awareness of %s Guid=%llu
Error writing OPACK object data: %s
Could not find latest state for object (id: %llu, type: %llu[%s]).
Invalid transport queue. Should be the same dispatch_queue that transport api will be called on.
Transport preferred packet size: %d
Invalid preferred packet size for transport: %u
Transport throttling enabled: %d
Transport message fragmentation enabled: %d
Unknown thread mode. Defaulting to ThreadWaitAndWake
Attempt to disconnect connection that does not exist. This can happen if connection broke right before this request.
Cannot collect stats for invalid connection {address: %s, channel: %d}
Stats filter triggered event for {destination: %s, channel: %u}
Stats filter returned error for {destination: %s, channel: %u}
Trying to send packet for connection: %s, total available bandwidth: %d bps, time slice: %d ms, slice bandwidth: %llu bits
Enqueueing packet for `%s` (from channel: %d) with size: %u
No more send channels for connection: %s
Cannot cleanup pending queues for invalid handle: nil
Fragment count is not within range %u [%u, %u]. Fragment %u, %u will be discarded.
Fragment index is out of bounds [%u, %u]. Fragment %u, %u will be discarded.
Big packet size is not set. Fragment %u, %u will be discarded.
Outbound message length (%u) exceeds kMaxSupportedMessageSize (%zu), message will be discarded.
Attempt to send data to an invalid channel
Attempt to send data to connection that does not exist
Attempt to send data to connection '%s' that is disconnected
Sending data on paused connection '%s', channel %d
Send queue on connection '%s' has overflowed (%zu bytes), disconnecting
Send queue on connection '%s' is very large (%zu bytes)
Attempt to receive data from connection that does not exist
Attempt to receive data from connection '%s' that is disconnected
Connection(%s->%s) state changed %s->%s
Unexpected event: %d in 'Pending' state.
Unexpected event: %d in 'Active' state.
Unexpected event: %d in 'Closing' state.
onConnected: Invalid handle provided for '%s'!
onDisconnected: Invalid handle provided for '%s'!
queueTransportCommand '%s' OnDisconnected
onUnresponsive: Invalid handle!
onResponsive: Invalid handle!
Transport cannot receive on invalid channel id: %hhu
Inbound message decompressed length (%zu) is not the expected length (%u), message discarded!
Inbound message decompressedLen(%u) exceeds kMaxSupportedMessageSize (%zu), message may be corrupted.
Received data for unbound connection object.
Discarding fragment with invalid size (channel=%u)
Discarding fragment with unreadable header (channel=%u)
Discarding fragment with invalid header values (channel=%u)
Discarding fragment with empty payload (channel=%u)
Message %u on channel %u timed-out waiting for fragment %u.
Create connection(%s->%s)
Trying to destroy invalid connection handle (%llu).
Destroy connection (%s->%s) (%s) bound to protocol handle %p
Failed to register unicast stream. Invalid connection handle.
Failed to register unicast stream. Stream %llu already exists.
Failed to remove unicast stream. Invalid connection handle.
Connection %s does not have stream %llu.
Failed to connect to %s
Connection Stats: address=%s, outbound=%d, inbound=%d, ProtocolConnectionStats: send=%u(%u bytes), recv=%u(%u bytes) <period=%llu ms, %s>
Connection '%s' found in m_addrToConnections but missing from m_connections!
Connection for address '%s' is already destroyed.Check logs for prior connection errors.
Connection was destroyed before error event.
Invalid MCSession.
An error occurred while trying to create an Tcp server host. Invalid bind address: %s
An error occurred while trying to create an Tcp server host. Tcp only supports IPv4. IPv6 requested. (%s)
getaddrinfo failed: %s
bind on port %s failed: %s errno = %s
getsockname: %s : %s
Could not get server socket flags: %s
Could set server socket to be non blocking: %s
kevent failed
listen failed: %s
%s:%u queueing close on handle %p
[ConDebug] Connecting to %s with socket %i from port %i
Could not set TCP_NODELAY %s
Could not set SO_NOSIGPIPE %s
Failed to load usbmux host library: %s
Failed to lookup usbmux connector address: %s
Expected usb://ip:port address: %s
Invalid deviceId or port: %s
USBMuxConnectByPort failed: %s (%s)
Could not get socket flags: %s
Could not set socket to be non blocking: %s
Could not set SO_KEEPALIVE %s
Expected ip:port address: %s
Opening socket failed with %i
Could not get socket flags: %s
Could not set socket to be non blocking: %s
Failed to connect to %s : %s errno = %s
[ConDebug] Closing peer handle(%p) on port %i
Packet %p freed
Closed peer handle(%p) on port %i socket %i
[ConDebug] disconnecting peer(%i) handle(%p) on port %i
getpeername failed: %s errno = %s
send to %i failed: errno = %s
getpeername to %i failed: errno = %s, error = %s
[ConDebug] %p Incoming connection complete  on port(%i) socket(%i) from %s
[ConDebug] %p Outgoing connection complete on port(%i) socket(%i) from %s
[ConDebug] Accepting connection(%s) on port(%i) socket(%i)
getsockopt to %i failed: errno = %s error =%s
getAddressFromSocket to %i failed: errno = %s, error = %s
[ConDebug] Server accepted connection on port(%i) socket(%i) from %s
[ConDebug] Connection Closed on port(%i) socket(%i) reason %i:%s %s
[ConDebug] Connection Closed on port(%i) socket(%i)
kevent failed: %s
Unknown connection closed %i
recv %i failed: errno = %s %s
recv %i failed: errno = %s
kevent failed %s
TcpProtocolLayer: Unable to list network adapters(errno=%d).
TcpProtocolLayer: Failed to get string representation of ip(errno=%d).
Could not set SO_KEEPALIVE %s
Could not set TCP_KEEPALIVE %s
Could not set TCP_KEEPINTVL %s
Could not set TCP_KEEPCNT %s
%s %s%s%s Peer=%llu TTL=%0.2f
Expected object header
Failed to unpack sync object.
Unknown object typeID=%llu. Assuming opaque type.
Cannot find guid for object with id=%d, flags=0x%02X. Skipping update.
Discarding incoming object already in destroyed state, guid=%llu, type=%s(%llu)
Discarding incoming object already tombstoned, guid=%llu, type=%s(%llu)
Discarding incoming object with parent already tombstoned, guid=%llu, type=%s(%llu), parentGuid=%llu
Got object delta update but missing object for it.(guid=%llu, type=%s(%llu))
Got object delta update but missing baseline for it.(guid=%llu, type=%s(%llu))
Failed to parse object state.(guid=%llu, type=%llu(%s), peerID=%llu)
Sync object without snapshot while parsing object (id: %llu, type: %llu[%s]).
Failed to parse object header.
Failed to parse object's ctor-data.(guid=%llu, type=%llu
Cannot parse ctor-data for object %llu.
Baseline would be invalidated by new state! Will read into temp location.
Cannot parse state for syncobject %llu of type %llu(%s), readDeltaCb not available.
Cannot parse state for syncobject %llu of type %llu(%s), readCb not available.
Read buffer is not fully consumed by %s of type %s: %llu
Failed to parse object data.(guid=%llu, peerID=%llu)
Buffer overflowe trying to extract sync object state buffer (len=%u) from packet reader!
NWProtocolDelegate
NWListener
REMultipeerHelper
MCSessionHandler
MCSessionPrivateDelegate
NSObject
c24@0:8@16
#16@0:8
@16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
c16@0:8
c24@0:8#16
c24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
c24@0:8@"Protocol"16
@"NSString"16@0:8
v48@0:8@16@24q32*40
{Address={DynamicString=^{Allocator}*QQ}}24@0:8@16
v48@0:8@16@24@32*40
v56@0:8@16@24@32@40*48
v64@0:8@16@24@32@40@48*56
v56@0:8@16@24@32@?40*48
v48@0:8@"MCSession"16@"MCPeerID"24q32*40
v48@0:8@"MCSession"16@"NSData"24@"MCPeerID"32*40
v56@0:8@"MCSession"16@"NSInputStream"24@"NSString"32@"MCPeerID"40*48
v56@0:8@"MCSession"16@"NSString"24@"MCPeerID"32@"NSProgress"40*48
@24@0:8^v16
v16@0:8
v24@0:8@16
@"NSObject<OS_dispatch_queue>"
@"NSObject<OS_dispatch_semaphore>"
@"NSObject<OS_nw_listener>"
v64@0:8@"MCSession"16@"NSString"24@"MCPeerID"32@"NSURL"40@"NSError"48*56
v56@0:8@"MCSession"16@"NSArray"24@"MCPeerID"32@?<v@?c>40*48
@32@0:8@16^{MultipeerProtocolLayer=^^?{ArcRefCount=(isa_t=^v)}^{Allocator}^{ProtocolLayerListener}{ObjCObject=@}{ObjCObject=@}{Address={DynamicString=^{Allocator}*QQ}}}24
v48@0:8@16@24@32^v40
^{MultipeerProtocolLayer=^^?{ArcRefCount=(isa_t=^v)}^{Allocator}^{ProtocolLayerListener}{ObjCObject=@}{ObjCObject=@}{Address={DynamicString=^{Allocator}*QQ}}}16@0:8
v24@0:8^{MultipeerProtocolLayer=^^?{ArcRefCount=(isa_t=^v)}^{Allocator}^{ProtocolLayerListener}{ObjCObject=@}{ObjCObject=@}{Address={DynamicString=^{Allocator}*QQ}}}16
^{ProtocolLayerListener=^^?}16@0:8
v24@0:8^{ProtocolLayerListener=^^?}16
{DynamicArray<re::SharedPtr<(anonymous namespace)::MCProtocolHandle>>=^{Allocator}QQI^v}16@0:8
v56@0:8{DynamicArray<re::SharedPtr<(anonymous namespace)::MCProtocolHandle>>=^{Allocator}QQI^v}16
^{MultipeerProtocolLayer=^^?{ArcRefCount=(isa_t=^v)}^{Allocator}^{ProtocolLayerListener}{ObjCObject=@}{ObjCObject=@}{Address={DynamicString=^{Allocator}*QQ}}}
^{ProtocolLayerListener=^^?}
@"MCSession"
@"NSLock"
@"<MCSessionPrivateDelegate>"
{DynamicArray<re::SharedPtr<(anonymous namespace)::MCProtocolHandle>>="m_allocator"^{Allocator}"m_capacity"Q"m_size"Q"m_version"I"m_data"^v}
N2re16GlobalAllocatorsE
N2re7SessionE
N2re17TransportListenerE
N2re8internal8CallableIZNKS_7Session35findBacklogItemWithConnectionHandleEyPmEUlRKNS2_11BacklogItemEE_FbS6_EJEEE
N2re13BaseAllocatorE
N2re8internal12CallableBaseIFbRKNS_7Session11BacklogItemEEEE
N2re9AllocatorE
N2re8internal8CallableIZNS_7Session20discoveryViewDidJoinEPNS_13DiscoveryViewENS_9SharedPtrINS_17DiscoveryIdentityEEEE3$_1FvvEJEEE
N2re8internal8CallableIZNS_7Session21discoveryViewDidLeaveEPNS_13DiscoveryViewENS_9SharedPtrINS_17DiscoveryIdentityEEEE3$_2FvvEJEEE
N2re16SharedObjectBaseE
N2re8internal8CallableIZNKS_7Session27findBacklogItemWithIdentityERKNS_9SharedPtrINS_17DiscoveryIdentityEEEPmEUlRKNS2_11BacklogItemEE_FbSB_EJEEE
N2re15MallocAllocatorE
N2re8internal12CallableBaseIFvvEEE
@(#)PROGRAM:RENetwork  PROJECT:RENetwork-326.2.0.2
N2re16NWProtocolHandleE
N2re14SyncCommitListE
N2re15SyncViewManagerE
N2re13UnicastStreamE
N2re16SharedAppUnicastE
N2re8SyncCastE
N2re20SyncAckedStateBufferE
N2re15MessageStreamerINS_20SyncOwnershipRequestEEE
N2re28UnreliableAckedUnicastStreamE
N2re18LeaderElectionNoneE
N2re14LeaderElectionE
@N2re17SyncObjectManagerE
N2re8internal8CallableIZNS_17SyncObjectManager20reevaluateAllViewersEvE3$_0FvPNS_8SyncViewEEJEEE
N2re8internal8CallableIZNS_17SyncObjectManager11onViewAddedEPNS_15SyncViewManagerEPNS_8SyncViewEE3$_1FvPNS_10SyncViewerEEJEEE
N2re8internal8CallableIZNS_17SyncObjectManager26addPeerStateForParticipantENS_9SharedPtrINS_18SessionParticipantEEEE3$_2FvPNS_8SyncViewEEJEEE
N2re8internal8CallableIZNS_17SyncObjectManager24receiveOwnershipRequestsERNS2_9PeerStateEE3$_3FvRKNS_20SyncOwnershipRequestEEJEEE
N2re11SyncSessionE
N2re8internal12CallableBaseIFvPNS_8SyncViewEEEE
N2re8internal12CallableBaseIFvPNS_10SyncViewerEEEE
N2re8internal12CallableBaseIFvRKNS_20SyncOwnershipRequestEEEE
N2re16MultipeerManagerE
N2re28MultipeerConnectivityServiceE
N12_GLOBAL__N_121ProtocolLayerObserverE
N12_GLOBAL__N_123SyncCustomProtocolLayerE
N12_GLOBAL__N_125CustomProtocolLayerConfigE
N12_GLOBAL__N_111AddressListE
N2re13ProtocolLayerE
N2re14ProtocolHandleE
N2re20SharedAppSyncManagerE
N2re20SharedAppSyncManager9PeerStateE
N2re8internal8CallableIZNS_20SharedAppSyncManager20reevaluateAllViewersEvE3$_0FvPNS_8SyncViewEEJEEE
N2re8internal8CallableIZNS_20SharedAppSyncManager11onViewAddedEPNS_15SyncViewManagerEPNS_8SyncViewEE3$_1FvPNS_10SyncViewerEEJEEE
N2re8internal8CallableIZNS_20SharedAppSyncManager26addPeerStateForParticipantENS_9SharedPtrINS_18SessionParticipantEEEE3$_2FvPNS_8SyncViewEEJEEE
N2re8internal8CallableIZNS_20SharedAppSyncManager24receiveOwnershipRequestsERNS2_9PeerStateEE3$_3FvRKNS_20SyncOwnershipRequestEEJEEE
N2re8internal8CallableIZ38RESyncDiscoveryViewCreateWithAddressesE3$_0FNS_9SharedPtrINS_13ProtocolLayerEEEvEJEEE
N2re8internal12CallableBaseIFNS_9SharedPtrINS_13ProtocolLayerEEEvEEE
N12_GLOBAL__N_121DiscoveryViewObserverE
N12_GLOBAL__N_125DiscoveryIdentityObserverE
N12_GLOBAL__N_118DiscoveryViewProxyE
N12_GLOBAL__N_122DiscoveryIdentityProxyE
N2re13DiscoveryViewE
N2re17DiscoveryIdentityE
N2re12RoutingTableE
N2re19NetworkClockDefaultE
N2re12NetworkClockE
N2re22DynamicPacketBitWriterE
@(#)PROGRAM:RESync  PROJECT:RESync-326.2.0.2
33333ct@N2re15TransportStreamE
N2re14PacketProviderE
N2re10SyncViewerE
N2re8SyncViewE
N2re14SyncSendBufferE
N2re28SyncObjectShortIDManagerImplE
N2re24SyncObjectShortIDManagerE
N2re19MallocZoneAllocatorE
N2re13PoolAllocatorE
N2re16AlignedAllocatorE
/[R=2
]E7;_
N2re12SharedObjectE
15ArcSharedObject
?N2re21StaticPacketBitWriterE
N2re25SyncSelectiveAckedUnicastE
N2re8internal8CallableIZNS_25SyncSelectiveAckedUnicast4sendERKNS_5SliceINS_10SyncCommitEEERKNS3_INS_9SharedPtrINS_10SyncObjectEEEEEPNS_16SyncObjectViewerERNS_22SyncObjectWriteContextEE3$_1FvRKS4_EJEEE
N2re8internal12CallableBaseIFvRKNS_10SyncCommitEEEE
N2re15MessageStreamerINS_23SyncHistoryResetRequestEEE
N2re26SyncReliableOrderedUnicastE
N12_GLOBAL__N_120SessionObserverProxyE
22RESyncNetSessionConfig
N2re20SyncObjectTypedStoreE
N2re15SyncObjectStoreE
N2re22MultipeerProtocolLayerE
N12_GLOBAL__N_116MCProtocolHandleE
N2re23TransportCommandsQueuedE
N2re17TransportCommandsE
N2re33TransportCommandsThreadedProtocolE
N2re25TransportCommandsDispatchE
N2re10SyncObjectE
N2re10PacketPoolE
N2re18SessionParticipantE
N2re9BitWriterE
N2re16DynamicBitWriterE
N2re18NetworkSyncManagerE
N2re18NetworkSyncServiceE
N2re16SyncObjectViewerE
N12_GLOBAL__N_117SnapshotBitWriterE
N2re26LeaderElectionLowestPeerIDE
N2re9TransportE
N2re21ProtocolLayerListenerE
N2re8internal8CallableIZNS_9Transport6deinitEvE3$_0FvvEJEEE
N2re8internal8CallableIZNS_9Transport6deinitEvE3$_1FvvEJEEE
N2re8internal8CallableIZNS_9Transport6deinitEvE3$_2FvvEJEEE
N2re8internal8CallableIZNS_9Transport18flushNetworkEventsEvE3$_3FvvEJEEE
N2re8internal8CallableIZNS_9Transport17flushOutgoingDataEvE3$_4FvvEJEEE
N2re8internal8CallableIZNS_9Transport7connectERKNS_7AddressEE3$_5FvvEJEEE
N2re8internal8CallableIZZNS_9Transport7connectERKNS_7AddressEENK3$_5clEvEUlvE_FvvEJEEE
N2re8internal8CallableIZNS_9Transport21connectionStateActiveEyRKNS_15ConnectionEventEE3$_6FvvEJEEE
N2re8internal8CallableIZNS_9Transport21connectionStateActiveEyRKNS_15ConnectionEventEE3$_7FvvEJEEE
N2re8internal8CallableIZNS_9Transport21connectionStateActiveEyRKNS_15ConnectionEventEE3$_8FvvEJEEE
N2re8internal8CallableIZNS_9Transport22connectionStateClosingEyRKNS_15ConnectionEventEE3$_9FvvEJEEE
N2re8internal8CallableIZNS_9Transport11onConnectedEPNS_13ProtocolLayerEPNS_14ProtocolHandleERKNS_7AddressEE4$_10FvvEJEEE
N2re8internal8CallableIZNS_9Transport14onDisconnectedEPNS_13ProtocolLayerEPNS_14ProtocolHandleERKNS_7AddressEE4$_11FvvEJEEE
N2re8internal8CallableIZNS_9Transport7onErrorEPNS_13ProtocolLayerEPNS_14ProtocolHandleENS_14TransportErrorEE4$_12FvvEJEEE
N2re8internal8CallableIZNS_9Transport14onUnresponsiveEPNS_13ProtocolLayerEPNS_14ProtocolHandleEE4$_13FvvEJEEE
N2re8internal8CallableIZNS_9Transport12onResponsiveEPNS_13ProtocolLayerEPNS_14ProtocolHandleEE4$_14FvvEJEEE
N2re8internal8CallableIZNS_9Transport14onReceiveAsyncEPNS_13ProtocolLayerEPNS_14ProtocolHandleENS_9ChannelIdEPKvjE4$_15FvvEJEEE
N2re8internal8CallableIZNS_9Transport20setDisconnectTimeoutEjE4$_16FvvEJEEE
N2re8internal8CallableIZNS_9Transport17destroyConnectionEyE4$_17FvvEJEEE
N2re22MultipeerDiscoveryViewE
10MCIdentity
N2re16TcpProtocolLayerE
N2re17TcpProtocolHandleE
N12_GLOBAL__N_124CustomLeaderElectionImplE
N12_GLOBAL__N_120CustomLeaderElectionE
N2re18DebugProtocolLayerE
N2re19DebugProtocolHandleE
N2re20ServiceObserverProxyE
N2re27TransferReportObserverProxyE
N2re18DebugDiscoveryViewE
N2re22DebugDiscoveryIdentityE
N2re18SyncObjectTypeInfoE
N2re17PacketStatsFilterE
N2re15NWProtocolLayerE
33333ct@
assertion failure: cond '%s' (%s:%i) Invalid addresses.
addresses != nullptr || addressesCount == 0
RESyncDiscoveryViewCreateWithAddresses
assertion failure: cond 'addresses != nullptr || addressesCount == 0'
assertion failure: cond '%s' (%s:%i) Invalid protocol provided.
protocolLayer != nullptr
assertion failure: cond '%s' (%s:%i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu
assertion failure: cond '%s' (%s:%i) Out of memory.
temp
assertion failure: cond '!overflow'
init
assertion failure: cond 'temp'
assertion failure: cond 'newData'
removeStableAt
assertion failure: cond '%s' (%s:%i) 
m_blockSize <= std::numeric_limits<uint32_t>::max()
PoolAllocator
assertion failure: cond 'm_blockSize <= std::numeric_limits<uint32_t>::max()'
assertion failure: cond '%s' (%s:%i) Free pool entry %p is corrupted
!hasEntryMemoryBeenStomped(entry)
alloc
assertion failure: cond '!hasEntryMemoryBeenStomped(entry)'
isBlockFull(block)
assertion failure: cond 'isBlockFull(block)'
<UNKNOWN>
assertion failure: cond '%s' (%s:%i) Called free() on pool %s which is not bound to a parent allocator (already destroyed?)
!m_enableAsserts
free
assertion failure: cond '!m_enableAsserts'
assertion failure: cond '%s' (%s:%i) Pool block is invalid. This could mean the memory address was not allocated from this pool, or other corruption. Enable RE_MEMORY_TRACKING to debug
!m_enableAsserts || block->m_magic == blockGuard
assertion failure: cond '!m_enableAsserts || block->m_magic == blockGuard'
m_blocks.size() <= std::numeric_limits<uint32_t>::max()
addPoolBlock
assertion failure: cond 'm_blocks.size() <= std::numeric_limits<uint32_t>::max()'
index <= m_length
assertion failure: cond 'index <= m_length'
assertion failure: cond '%s' (%s:%i) Out of memory.
newBuffer
setCapacity
assertion failure: cond 'newBuffer'
assertion failure: cond '%s' (%s:%i) Index out of range. index = %zu, size = %zu
substr
assertion failure: cond '%s' (%s:%i) offset out of range. offset = %zu, size = %zu
offset < m_length
rfind
assertion failure: cond 'offset < m_length'
com.apple.re
Foundation.Core
enableSignposts
enableHighFrequencyNetworkTracing
com.apple.re
%s.%s
com.apple.re.network.multipeerservice
com.apple.renetwork.multipeerservice
!"Unreachable code"
assertion failure: cond '!"Unreachable code"'
assertion failure: cond '%s' (%s:%i) Index out of range. index = %zu, size = %zu
operator[]
!overflow
assertion failure: cond '!overflow'
assertion failure: cond '%s' (%s:%i) Size overflow in DynamicOverflowArray<T, N>::setCapacity(). Element size = %zu, capacity = %zu
assertion failure: cond '%s' (%s:%i) DynamicOverflowArray<T, N> is out of memory (tried to allocate %zu bytes from allocator '%s').
index < m_size
assertion failure: cond 'index < m_size'
assertion failure: cond '%s' (%s:%i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu
init
assertion failure: cond '%s' (%s:%i) Out of memory.
m_data
assertion failure: cond 'm_data'
allocBlock
assertion failure: cond '%s' (%s:%i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').
block.elements
assertion failure: cond 'block.elements'
block.allocationCounters
assertion failure: cond 'block.allocationCounters'
assertion failure: cond '%s' (%s:%i) 
m_length + result < m_capacity
vappendf
assertion failure: cond 'm_length + result < m_capacity'
com.apple.re
Foundation.Memory
ArcObject
insert
assertion failure: cond '%s' (%s:%i) Out of memory.
temp
init
assertion failure: cond 'temp'
index < size()
assertion failure: cond 'index < size()'
slice
assertion failure: cond '%s' (%s:%i) Invalid count. index = %zu, count = %zu, array size = %zu
endIndexExclusive <= m_size
assertion failure: cond 'endIndexExclusive <= m_size'
assertion failure: cond '%s' (%s:%i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu
m_data
assertion failure: cond 'm_data'
allocBlock
assertion failure: cond '%s' (%s:%i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').
block.elements
assertion failure: cond 'block.elements'
block.allocationCounters
assertion failure: cond 'block.allocationCounters'
assertion failure: cond '%s' (%s:%i) element isn't in data array
handle
RESyncSessionSendAll
service != __null
commits != __null
RESyncSessionReceive
session != __null
handler != __null
removeStableAt
v16@?0Q8
SendCommit
RecvCommit
assertion failure: cond '%s' (%s:%i) 
packet.capacity() >= kHeaderSize
writeHeader
assertion failure: cond 'packet.capacity() >= kHeaderSize'
!writer.isOverflow()
assertion failure: cond '!writer.isOverflow()'
capacity() >= offset || (offset < 0 && -offset <= (static_cast<uint8_t*>(m_data) - static_cast<uint8_t*>(m_buffer)) )
offsetBy
assertion failure: cond 'capacity() >= offset || (offset < 0 && -offset <= (static_cast<uint8_t*>(m_data) - static_cast<uint8_t*>(m_buffer)) )'
assertion failure: cond '%s' (%s:%i) Index out of range. index = %zu, size = %d.
b < kBitCount
toWordIndex
assertion failure: cond 'b < kBitCount'
nullptr
v24@?0r^v8^v16
removeStableAt
!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator
operator=
assertion failure: cond '!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator'
network.multipeerservice.sessionInitTimeOutMs
network.multipeerservice.sessionHandshakeTimeOutMs
network.multipeerservice.sessionIsLeader
network.multipeerservice.sessionForceAuthorityOverIncomingObjects
network.multipeerservice.sessionShutdownOnVersionMismatch
network.multipeerservice.sessionUseReliableSync
network.multipeerservice.enableThrottling
network.multipeerservice.enableMessageFragmentation
network.multipeerservice.sessionResendPeriodMs
network.multipeerservice.syncPacketSizeLimit
Q16@?0@"NSObject<OS_nw_framer>"8
Q28@?0*8Q16B24
channel
v36@?0@"NSObject<OS_nw_framer>"8@"NSObject<OS_nw_protocol_metadata>"16Q24B32
B16@?0r^v8
i16@?0@"NSObject<OS_nw_framer>"8
re-net-header
Opaque
B32@?0^{RESyncBitReader=}8^v16r^{RESyncObjectContext=}24
B32@?0^{RESyncBitWriter=}8r^v16r^{RESyncObjectContext=}24
B32@?0^{RESyncBitReader=}8^{RESyncBitWriter=}16r^{RESyncObjectReadContext=}24
v32@?0^{RESyncBitReader=}8^{RESyncBitWriter=}16r^{RESyncObjectWriteContext=}24
RESyncProtocolLayerObserverOnCreate
observer != __null
protocolLayerCreate != __null
RESyncProtocolLayerObserverOnDestroy
protocolLayerDestroy != __null
RESyncProtocolLayerObserverOnInit
protocolLayerInit != __null
RESyncProtocolLayerObserverOnInitWithConfig
protocolLayerInitWithConfig != __null
RESyncProtocolLayerObserverOnDeinit
protocolLayerDeinit != __null
RESyncProtocolLayerObserverOnOpen
protocolLayerOpen != __null
RESyncProtocolLayerObserverOnOpenNullable
protocolLayerOpenNullable != __null
RESyncProtocolLayerObserverOnClose
protocolLayerClose != __null
RESyncProtocolLayerObserverOnDisconnect
protocolLayerDisconnect != __null
RESyncProtocolLayerObserverOnSend
protocolLayerSend != __null
RESyncProtocolLayerObserverOnUpdate
protocolLayerUpdate != __null
RESyncProtocolLayerObserverOnWait
protocolLayerWait != __null
RESyncProtocolLayerObserverOnWakeup
protocolLayerWakeup != __null
RESyncProtocolLayerObserverOnLocalAddresses
protocolLayerLocalAddresses != __null
RESyncProtocolLayerObserverOnHostStats
protocolLayerHostStats != __null
RESyncProtocolLayerObserverOnSetDisconnectTimeout
protocolLayerSetDisconnectTimeout != __null
RESyncProtocolLayerObserverOnPreferredPacketSize
protocolLayerPreferredPacketSize != __null
RESyncProtocolLayerObserverOnSetListener
protocolLayerSetListener != __null
RESyncProtocolLayerConfigGetPacketPool
config != __null
RESyncProtocolLayerConfigGetNetworkQueue
RESyncCustomProtocolLayerCreate
Either RESyncProtocolLayerObserverOnInit() or RESyncProtocolLayerObserverOnInitWithConfig() observer implementation is required.
RESyncProtocolLayerObserverOnDeinit() observer implementation is required.
Either RESyncProtocolLayerObserverOnOpen() or RESyncProtocolLayerObserverOnOpenNullable() observer implementation is required.
RESyncProtocolLayerObserverOnClose() observer implementation is required.
RESyncProtocolLayerObserverOnDisconnect() observer implementation is required.
RESyncProtocolLayerObserverOnUpdate() observer implementation is required.
None or both RESyncProtocolLayerObserverOnWait() and RESyncProtocolLayerObserverOnWakeup() observer implementations are required.
RESyncProtocolLayerObserverOnLocalAddresses() observer implementation is required.
RESyncProtocolLayerObserverOnHostStats() observer implementation is required.
RESyncProtocolLayerObserverOnSetDisconnectTimeout() observer implementation is required.
RESyncProtocolLayerObserverOnPreferredPacketSize() observer implementation is required.
RESyncCustomProtocolLayerSetThreadModeDispatchTransport
protocolLayer != __null
RESyncCustomProtocolLayerOnConnected
handle != __null
RESyncCustomProtocolLayerOnDisconnected
RESyncCustomProtocolLayerOnError
RESyncCustomProtocolLayerOnReceiveData
fromHandle != __null
channel < kRESyncChannelIdMaxChannels
RESyncCustomProtocolLayerOnReceiveDataNoAsync
RESyncCustomProtocolLayerOnUnresponsive
RESyncCustomProtocolLayerOnResponsive
RESyncPacketPoolAllocPacket
pool != __null
RESyncPacketPoolFreePacket
packet != __null
RESyncAddressListCreate
addresses != __null || addressesCount == 0
RESyncAddressListCreateWithAddress
address != __null
RESyncAddressListGetAddressAtIndex
addressList != __null
RESyncAddressListGetSize
RESyncPacketGetData
RESyncPacketGetSize
RESyncPacketSetSize
RESyncPacketGetCapacity
RESyncPacketGetDeliveryMethod
RESyncProtocolHandleGetConnection
RESyncProtocolHandleConnectionSetStats
stats != __null
RESyncProtocolHandleConnectionGetStats
RESyncProtocolHandleGetUserData
RESyncProtocolHandleSetUserData
RESyncProtocolHandleQueueDeqeue
channelId < kRESyncChannelIdMaxChannels
type == kRESyncPacketQueueTypeSend || type == kRESyncPacketQueueTypeReceive
RESyncProtocolHandleQueueEnqeue
_packet != __null
RESyncProtocolHandleQueueGetSizeInBytes
RESyncProtocolHandleQueueGetCapacityInBytes
RESyncProtocolHandleQueueGetSize
0.0.0.0
v16@?0@?<B@?C^vIi>8
removeAt
operator[]
System allocator
TLB-aligned allocator
Cache-aligned allocator
SIMD-aligned allocator
assertion failure: cond 'protocolLayer != nullptr'
setCapacity
!overflow
newData
assertion failure: cond '%s' (%s:%i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').
operator[]
!overflow
assertion failure: cond '!overflow'
copy
assertion failure: cond '%s' (%s:%i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu
invalid
waiting
ready
failed
cancelled
unknown
operator[]
removeAt
readDeltaCb
readCb
assertion failure: cond '%s' (%s:%i) Index out of range. fromInclusive = %zu, size = %zu
fromInclusive <= size()
range
assertion failure: cond 'fromInclusive <= size()'
assertion failure: cond '%s' (%s:%i) Index out of range. toExclusive = %zu, size = %zu
toExclusive <= size()
assertion failure: cond 'toExclusive <= size()'
:%hu
destination
ownershipSequence
overrun: attempted to read %zu bytes, only %zu remaining
couldn't grow buffer to %zu bytes (buffer = %p, capacity = %d)
com.apple.re
Network
RESyncCreateSyncObjectWriteContextNoAlloc
bytes != __null
size >= sizeof(re::SyncObjectWriteContext)
RESyncDestroySyncObjectWriteContextNoDealloc
context != __null
RESyncAddSyncObjectWriteContextEntry
entry != __null
RESyncGetSyncObjectWriteContextEntry
RESyncRemoveSyncObjectWriteContextEntry
RESyncObjectWriteContextGetSession
RESyncObjectWriteContextGetDestinationPeerID
RESyncObjectWriteContextSupportsProtocolLevel
RESyncObjectWriteContextIsLocalSession
operator[]
assertion failure: cond '%s' (%s:%i) Array is empty
m_size > 0
last
assertion failure: cond 'm_size > 0'
network.session.maxTotalBandwidthBpsLocal
network.session.maxTotalBandwidthBpsRemote
NetworkUnreliable
NetworkReliable
assertion failure: cond '%s' (%s:%i) Session: Unknown state %d(%s).
stateEvent
assertion failure: cond '%s' (%s:%i) Invalid event %d in state '%s'
stateInit
stateFinished
stateActive
None
Init
Active
Finished
TransitionIn
TransitionOut
Update
DispatchBacklog
StartMigration
ParticipantsUpdate
removeManyStableAt
(new)
(data)
(destroyed)
(ownerChange)
Commit
(Atomic)
(Held)
(Fwd)
ReSendCommit
RESyncNetSessionCreate
configuration != __null
Use RESyncNetSessionConfigurationSetTransportQueue() to configure transport queue.
Use RESyncNetSessionConfigurationSetDiscoveryView() to configure discovery view.
RESyncNetSessionConfigurationSetTransportIsFragmented
RESyncNetSessionPublishBandwidthEvent
bwEvent != __null
removeStableAt
SyncObject
SyncObjectStateHistory
operator[]
removeManyStableAt
privateDelegate
assertion failure: cond '%s' (%s:%i) Unknown new connection requested.
open
assertion failure: cond '%s' (%s:%i) Not implemented
com.apple.rekit.hello.ack
com.apple.rekit.hello
com.apple.re.networking.network
assertion failure: cond '%s' (%s:%i) Size overflow in Queue<T>::setCapacity(). Element size = %zu, capacity = %zu
assertion failure: cond '%s' (%s:%i) Queue<T> is out of memory (tried to allocate %zu bytes from allocator '%s').
thread constructor failed
operator[]
removeStableAt
RESyncCreateSyncObjectReadContextNoAlloc
size >= sizeof(SyncObjectReadContext)
RESyncDestroySyncObjectReadContextNoDealloc
RESyncAddSyncObjectReadContextEntry
RESyncGetSyncObjectReadContextEntry
RESyncRemoveSyncObjectReadContextEntry
RESyncObjectReadContextGetSession
RESyncObjectReadContextGetSourcePeerID
RESyncObjectReadContextGetSyncableGuid
RESyncObjectReadContextSupportsProtocolLevel
RESyncObjectReadContextIsLocalSession
PacketPool%s
network.packetpool.minPacketSize
network.packetpool.maxFreePacketSize
network.packetpool.maxFreePacketPoolMemory
allocate
assertion failure: cond '%s' (%s:%i) [Network] Failed to allocate packet buffer of size %u(%u), totalCount=%d, totalBytes=%u, availableCount=%d, availableBytes=%u
false
assertion failure: cond 'false'
assertion failure: cond '%s' (%s:%i) Marker is out of bounds
marker.byteOffset + 4 <= m_dataSize
writeUInt32At
assertion failure: cond 'marker.byteOffset + 4 <= m_dataSize'
undef
assertion failure: cond '%s' (%s:%i) data==null, dataSize==%u, syncObjTypeID: %llu, debugName: %s
!(data == nullptr && dataSize > 0)
writeData
assertion failure: cond '!(data == nullptr && dataSize > 0)'
assertion failure: cond '%s' (%s:%i) Writer is in inconsistent state
m_dataSize >= m_byteOffset
bytesLeft
assertion failure: cond 'm_dataSize >= m_byteOffset'
m_byteOffset < m_dataSize || m_bitOffset == 0
assertion failure: cond 'm_byteOffset < m_dataSize || m_bitOffset == 0'
assertion failure: cond '%s' (%s:%i) 
bytesToCopy <= size()
copyDataTo
assertion failure: cond 'bytesToCopy <= size()'
assertion failure: cond '%s' (%s:%i) memcpy destination data is null, syncObjTypeID: %llu, debugName: %s
m_data != nullptr
operator()
assertion failure: cond 'm_data != nullptr'
object->retainCount() > 0
objectExitedView
assertion failure: cond 'object->retainCount() > 0'
commit.snapshot.size() < ~uint32_t()
writeCommit
assertion failure: cond 'commit.snapshot.size() < ~uint32_t()'
assertion failure: cond '%s' (%s:%i) SyncPacker::writeCtorData data==null && dataSize>0, syncObjTypeID: %llu, debugName: %s
!(data==nullptr && dataSize>0)
writeCtorData
assertion failure: cond '!(data==nullptr && dataSize>0)'
RESyncViewSetUserData
view != __null
RESyncViewGetUserData
RESyncViewGetObjectCount
RESyncViewSetOwnerPeerID
RESyncViewGetOwnerPeerID
RESyncViewSetFromPeerID
RESyncViewGetFromPeerID
RESyncViewEnumerateObjects
cb != __null
network.transport.compressionMethod
assertion failure: cond '%s' (%s:%i) Invalid channel
channel < kChannelIdMaxChannels
receive
assertion failure: cond 'channel < kChannelIdMaxChannels'
assertion failure: cond '%s' (%s:%i) 
*index < m_streams.size()
removeStream
assertion failure: cond '*index < m_streams.size()'
m_index < kHistorySize
measure
assertion failure: cond 'm_index < kHistorySize'
onSend
onReceive
Pending
Closing
capacity() >= offset
offsetTo
assertion failure: cond 'capacity() >= offset'
!isInitialized() || m_allocator == other.m_allocator
assertion failure: cond '!isInitialized() || m_allocator == other.m_allocator'
assertion failure: cond '%s' (%s:%i) Size overflow in FixedArray<T>::slice(size_t,size_t). index, %zu, count = %zu, array size = %zu
v16@?0^v8
operator[]
removeAt
deinit
assertion failure: cond '%s' (%s:%i) kevent failed
usb://
/System/Library/PrivateFrameworks/MobileDevice.framework/MobileDevice
USBMuxConnectByPort
assertion failure: cond '%s' (%s:%i) kevent failed %d
disconnect
assertion failure: cond '%s' (%s:%i) IPv6 not supported yet
getAddressFromSocket
connectionAdded
update
assertion failure: cond '%s' (%s:%i) Accept
assertion failure: cond '%s' (%s:%i) Unknown event
assertion failure: cond '%s' (%s:%i) Invalid Connection status
operator[]
debug://%d/%d
debug://*
debug://%d
RESyncServiceObserverOnSessionDidReceiveOwnershipHandoff
sessionDidReceiveOwnershipHandoff != __null
RESyncServiceObserverOnSessionDidReceiveOwnershipChange
sessionDidReceiveOwnershipChange != __null
RESyncServiceStartSyncWithSession
createProtocolLayer
local
operator[]
network.transport.enableLog
network.transport.enableThrottling
network.transport.enableMessageFragmentation
network.syncCommit.enableLog
network.syncObjectStateHistoryBufferSize
network.sharedAppSpecialization
com.apple.re
Foundation.Serialization
expected bool, found tag %x
expected object, found tag %x
overrun in beginDictionary: %zu items, only %zu bytes remaining
expected dictionary, found tag %x
reached end of buffer but expected more dictionary entries
expected data, found tag %x
overrun in data: size = %zu, only %zu bytes left
invalid size when skipping string or data: %zu, only %zu remaining
unexpected tag while skipping: %x
expected integer, found tag %x
<unknown>
Thread %p
profiler.statisticcollection.enable
v20@?0i8@"NSObject<OS_nw_error>"12
v8@?0
v16@?0@"NSObject<OS_nw_connection>"8
re-nw-unix-context
re-nw-protocol-listener
fd://
re-nw
v16@?0@"NSObject<OS_nw_error>"8
v36@?0@"NSObject<OS_dispatch_data>"8@"NSObject<OS_nw_content_context>"16B24@"NSObject<OS_nw_error>"28
v16@?0@"NSObject<OS_nw_data_transfer_report>"8
assertion failure: cond '%s' (%s:%i) Implementation required to support update synchronization.
wait
wakeup
B40@?0@"NSObject<OS_dispatch_data>"8Q16r^v24Q32
Called free() on pool %s which is not bound to a parent allocator (already destroyed?)
Index out of range in %s. index = %zu, maximum = %zu
assertion failure: Index out of range in %s. index = %zu, maximum = %zu
Please enable defaults using `defaults write -g|<application identifier> com.apple.re.<default name> -<type> <value>`.
%s: Invalid parameter not satisfying %s.
Transport is destroyed but trying to send.
Sending sync data on paused connection to %llx ('%s'): %s
Transport is destroyed but trying to receive.
Failed to parse incoming packet. Will drop peer.(peerID=%llu, address=%{public}s)
BindFailure: Object %llu with parent %llu
Corrupt packet received. Will drop.
Received duplicate packet with seqNo=%zu. Ignoring.(address=%{public}s)
Received out of order packet with seqNo=%zu. Ignoring.Current window=[%zu, %zu].(address=%{public}s)
Invalid peerID %llu
UNICAST reliable
UNICAST selective acked
Adding new peer state. PeerID=%llu.
Removing peer state. PeerID=%llu.
New peer joined object syncing. PeerID=%llu. Address='%s'. Identity='%s'.
Peer left syncing. PeerID=%llu. Address='%s'. Identity='%s'.
Pausing peerID %llu.
Resuming peerID %llu
SyncObjectManager: session started (%p).
SyncObjectManager: session stopped (%p) with error: %d.
[Ownership] Received ownership granted response for: %llu
[Ownership] Received ownership handoff for: %llu
[Ownership] Received ownership change: %llu
Failed to parse incoming packet. Will drop peer.(peerID=%llu, address=%{public}s, identity=%{public}s)
Failed to parse ownership requests. Will drop peer.(peerID=%llu, address=%{public}s, identity=%{public}s)
[Ownership] Ownership response for: %llu timed out
[Ownership] Corrupt ownership request.
Sync object without snapshot while gathering orphans (id: %llu, type: %llu[%s]).
Found %zu orphaned objects. localPeerID=%llu. 
[Ownership] Requesting ownership for: %llu
Emiting congestion event.
[Ownership] No NetworkSyncManager found, ownership request not forwarded.
[Ownership] Granted request for object %llu (%llu)
[Ownership] Rejected request for locked object %llu (%llu)
Failed to initiate RE discovery with MCSession (%s).
No MCSession object provided.
Already syncing over another session. Stop it first.
Message received on unknown channel %d
%s: %s
SharedAppSyncManager: session started (%p).
SharedAppSyncManager: session stopped (%p) with error: %d.
[Ownership] Adding ownership changes for: %llu
Sync object without snapshot while packing ownership broadcasts (id: %llu, type: %llu[%s]).
Sync object without snapshot while removing view (id: %llu, type: %llu[%s]).
Sync object without snapshot while adding view (id: %llu, type: %llu[%s]).
Encountered sync object without snapshot while packing ownership broadcasts! (id: %llu, type: %llu[%s])
Sync object without snapshot while adding view to commit (id: %llu, type: %llu[%s]).
Sync object without snapshot while removing view from commit (id: %llu, type: %llu[%s]).
SyncViewer already viewing this View
Sync object without snapshot among snapshot resend entries (id: %llu, type: %llu[%s]).
Sync object without snapshot among sent snapshot entries (id: %llu, type: %llu[%s]).
Commit doesn't begin with an object header
Expected dictionary of entries
Failure reading object in commit
Failed to parse commit header.
Failed to parse object %u from commit %llu.
Expected object short id
Expected object header
Failed to unpack sync object.
Unknown object typeID=%llu. Assuming opaque type.
Cannot find guid for object with id=%d, flags=0x%02X. Skipping update.
Discarding incoming object already in destroyed state, guid=%llu, type=%s(%llu)
Discarding incoming object already tombstoned, guid=%llu, type=%s(%llu)
Discarding incoming object with parent already tombstoned, guid=%llu, type=%s(%llu), parentGuid=%llu
Got object delta update but missing object for it.(guid=%llu, type=%s(%llu))
Got object delta update but missing baseline for it.(guid=%llu, type=%s(%llu))
Failed to parse object state.(guid=%llu, type=%llu(%s), peerID=%llu)
Sync object without snapshot while parsing object (id: %llu, type: %llu[%s]).
Failed to parse object header.
Failed to parse object's ctor-data.(guid=%llu, type=%llu
Cannot parse ctor-data for object %llu.
Baseline would be invalidated by new state! Will read into temp location.
Cannot parse state for syncobject %llu of type %llu(%s), readDeltaCb not available.
Cannot parse state for syncobject %llu of type %llu(%s), readCb not available.
Read buffer is not fully consumed by %s of type %s: %llu
Failed to parse object data.(guid=%llu, peerID=%llu)
Buffer overflowe trying to extract sync object state buffer (len=%u) from packet reader!
RESyncGetSyncObjectContextEntry: Couldn't find entry with id=%llu
RESyncRemoveSyncObjectContextEntry: Couldn't find entry with id=%llu
RESyncAddSyncObjectWriteContextEntry: Failed to add entry using id=%llu, possible duplicate!
RESyncGetSyncObjectWriteContextEntry: Couldn't find entry with id=%llu.
RESyncRemoveSyncObjectWriteContextEntry: Couldn't find entry with id=%llu.
SyncObjectShortID %u remapped from [%llu,%llu] to [%llu,%llu]!
! Incoming.ShortId %u is not mapped to [%llu,%llu] (current mapping = [%llu,%llu])!
Session: config override netMaxTotalBandwidthBpsLocal=%llu
Session: config override netMaxTotalBandwidthBpsRemote=%llu
Cannot initialize transport.
No local identity set for session.
Session: initialized (%p) {isLocal=%d, useReliableSync=%d, isRestrictive=%d, resendPeriodMs=%u, syncPacketSizeLimit=%u, syncInboundQueueLimit=%u}
Session: max bandwidth: %llu bps
Session: deinitialized (%p).
Cannot set routing table {isInitialized: %d, routingTable parameter: %p, session routing table:%p}
Stopping Session (%p) with error:%d after flushing transport events
Received SessionMessages::kPeerHello from %s
Error receiving message of type kPeerHello
Error receiving message of type kPeerHello: invalid peerid
Received SessionMessages::kSessionError from %s
Connection error received from ConnectionId(%llu) Error = 0x%X
Received SessionMessages::kRouteRequest
Received SessionMessages::kRouteResponse
Received SessionMessages::kRouteFail
Received unrecognized message type: %d
Aborting transport receive due to packet error: %d
Received corrupt message from '%s'. Packet error: %d, Disconnecting.
Stopping Session (%p) with packet error=kProtocolMismatch
sendSessionError: missing participant for connection!
Session: attempting to send %zu bytes on channel %d when not initialized. Data discarded.
Session: sendData over unsupported channel (%hhu): src(%llu)->dest(%llu)
No route exists for userData from %llu to %llu. Will try to discover route.
Removing %zu Pending Messages due to timeout.
sendRouteRequest: missing session for transport!
sendRouteRequest: missing participant for connection!
No hop specified in route request from %s
Failed to send routing response. src=%llu, dst-%llu, hop=%d
sendRouteResponse: missing session for transport!
sendRouteResponse: missing participant for connection!
receiveRouteResponse: missing session for transport!
receiveRouteResponse: missing participant for connection!
Failed to notify peer about failed route. src=%llu, dst-%llu, hop=%d
sendRouteFail: missing session for transport!
sendRouteFail: missing participant for connection!
Received route failure for PeerID. (%llu)
Routing table is nil
Routing table is nil, returning kInvalidPeerID
Received corrupt message from '%s'. No routing header. Disconnecting.
Received message with unknown route from '%s'. No route exists %llu->%llu.
Sending `Hello` to peer %s, count: %zu
Found backlog item for identity: %s (%s).
No pending connection for identity '%s (%s)'. Will initiate a new one.
Dropping pending connection %s. because its identity '%s (%s)' left.
Deleting participant '%s' for identity '%s (%s)'.
Session: changing state %s->%s
Session: handling event '%s' in state '%s'
Failed to initialize session in %d ms. Session will be terminated.
Remote peer ready with capabilities 0x%x
Invalid peerID
Connection '%s' did not do handshake for %d ms. Disconnecting.
Mismatched AppId, received 0x%X expecting 0x%X
Mismatched protocol, received 0x%X expecting 0x%X
Mismatched component schema, received 0x%llX expecting 0x%llX
Received `Peer Hello` from peer: %llu
removed peanut only pending handshake
Cannot read discovery data. Hello message from %s is corrupt.
Hello message received from %s is corrupt.
User context is bigger than maximum allowed (%u > %zu)
User context data received from %s is corrupt.
Peer %llu already in participant list, ignoring `Hello` from peer: 
User context data received from %s for existing participant is corrupt.
Two nodes claim to be session leaders (%llu and %llu)
Cannot bind peerID %llu with connection for peer %s
Session: stopped (%p) with error: %d
Picked session leader %llu (localPeerID=%llu)
Discovered new peer: %s
Lost peer: %s
%s Id=%llu(v#%u) Parent=%llu %s%s%s%s 
%s %s%s%s Peer=%llu
%s Id=%llu(v#%u) %s%s%s%s 
%s %s%s%s Peer=%llu
Parent already bound for object: %llu, current parent: %llu, attempted new parent: %llu
Received history reset request for object {%llu, %llu}.But the object is not viewed by peer %llu.
Received history reset request for object {%llu, %llu}.But the object does not exist.
Registered sync object type %{private}s:%llu
Adding tombstone entry {guid: %llu, type: %llu, parentId: %llu}
MPC: Received data from a legacy client address=%s
MPC: Closing peer handle=%p force=%d
MPC: Disconnecting peer handle=%p force=%d
MPC: Unsupported channelID=%hhu
MPC: Error sending handshake ack: %s, reason: %s
MPC: Error sending handshake: %s, reason: %s
MPC: Error sending packet: %s.
RESyncAddSyncObjectReadContextEntry: Failed to add entry using id=%llu, possible duplicate!
RESyncGetSyncObjectReadContextEntry: Couldn't find entry with id=%llu.
RESyncRemoveSyncObjectReadContextEntry: Couldn't find entry with id=%llu.
Large packet buffer allocated: %u, totalCount=%d, totalBytes=%u, availableCount=%d, availableBytes=%u
NetworkSyncManager: initialized
NetworkSyncManager: uninitialized
NetworkSyncManager: Not initialized.
NetworkSyncManager: Invalid session object (%p).
NetworkSyncManager: Session already used to sync (%p).
NetworkSyncManager: Starting sync with session (%p).
NetworkSyncManager: Added new session: %p (peerID=%llu)
Failed to init session with provided config.
NetworkSyncManager: session stopped (%p) with error: %d.
Requesting ownership for invalid object. Request is ignored.
Requesting ownership for already owned object '%llu'. Request is ignored.
NetworkSyncManager: session removed (%p).
NetworkSyncManager: session scheduled (%p) for removal.
Invalid session object passed to stopSyncWithSession
Peer %llu became aware of %s Guid=%llu
Peer %llu lost awareness of %s Guid=%llu
Error writing OPACK object data: %s
Could not find latest state for object (id: %llu, type: %llu[%s]).
Invalid transport queue. Should be the same dispatch_queue that transport api will be called on.
Transport preferred packet size: %d
Invalid preferred packet size for transport: %u
Transport throttling enabled: %d
Transport message fragmentation enabled: %d
Unknown thread mode. Defaulting to ThreadWaitAndWake
Attempt to disconnect connection that does not exist. This can happen if connection broke right before this request.
Cannot collect stats for invalid connection {address: %s, channel: %d}
Stats filter triggered event for {destination: %s, channel: %u}
Stats filter returned error for {destination: %s, channel: %u}
Trying to send packet for connection: %s, total available bandwidth: %d bps, time slice: %d ms, slice bandwidth: %llu bits
Enqueueing packet for `%s` (from channel: %d) with size: %u
No more send channels for connection: %s
Cannot cleanup pending queues for invalid handle: nil
Fragment count is not within range %u [%u, %u]. Fragment %u, %u will be discarded.
Fragment index is out of bounds [%u, %u]. Fragment %u, %u will be discarded.
Big packet size is not set. Fragment %u, %u will be discarded.
Outbound message length (%u) exceeds kMaxSupportedMessageSize (%zu), message will be discarded.
Attempt to send data to an invalid channel
Attempt to send data to connection that does not exist
Attempt to send data to connection '%s' that is disconnected
Sending data on paused connection '%s', channel %d
Send queue on connection '%s' has overflowed (%zu bytes), disconnecting
Send queue on connection '%s' is very large (%zu bytes)
Attempt to receive data from connection that does not exist
Attempt to receive data from connection '%s' that is disconnected
Connection(%s->%s) state changed %s->%s
Unexpected event: %d in 'Pending' state.
Unexpected event: %d in 'Active' state.
Unexpected event: %d in 'Closing' state.
onConnected: Invalid handle provided for '%s'!
onDisconnected: Invalid handle provided for '%s'!
queueTransportCommand '%s' OnDisconnected
onUnresponsive: Invalid handle!
onResponsive: Invalid handle!
Transport cannot receive on invalid channel id: %hhu
Inbound message decompressed length (%zu) is not the expected length (%u), message discarded!
Inbound message decompressedLen(%u) exceeds kMaxSupportedMessageSize (%zu), message may be corrupted.
Received data for unbound connection object.
Discarding fragment with invalid size (channel=%u)
Discarding fragment with unreadable header (channel=%u)
Discarding fragment with invalid header values (channel=%u)
Discarding fragment with empty payload (channel=%u)
Message %u on channel %u timed-out waiting for fragment %u.
Create connection(%s->%s)
Trying to destroy invalid connection handle (%llu).
Destroy connection (%s->%s) (%s) bound to protocol handle %p
Failed to register unicast stream. Invalid connection handle.
Failed to register unicast stream. Stream %llu already exists.
Failed to remove unicast stream. Invalid connection handle.
Connection %s does not have stream %llu.
Failed to connect to %s
Connection Stats: address=%s, outbound=%d, inbound=%d, ProtocolConnectionStats: send=%u(%u bytes), recv=%u(%u bytes) <period=%llu ms, %s>
Connection '%s' found in m_addrToConnections but missing from m_connections!
Connection for address '%s' is already destroyed.Check logs for prior connection errors.
Connection was destroyed before error event.
Invalid MCSession.
An error occurred while trying to create an Tcp server host. Invalid bind address: %s
An error occurred while trying to create an Tcp server host. Tcp only supports IPv4. IPv6 requested. (%s)
getaddrinfo failed: %s
bind on port %s failed: %s errno = %s
getsockname: %s : %s
Could not get server socket flags: %s
Could set server socket to be non blocking: %s
kevent failed
listen failed: %s
%s:%u queueing close on handle %p
[ConDebug] Connecting to %s with socket %i from port %i
Could not set TCP_NODELAY %s
Could not set SO_NOSIGPIPE %s
Failed to load usbmux host library: %s
Failed to lookup usbmux connector address: %s
Expected usb://ip:port address: %s
Invalid deviceId or port: %s
USBMuxConnectByPort failed: %s (%s)
Could not get socket flags: %s
Could not set socket to be non blocking: %s
Could not set SO_KEEPALIVE %s
Expected ip:port address: %s
Opening socket failed with %i
Could not get socket flags: %s
Could not set socket to be non blocking: %s
Failed to connect to %s : %s errno = %s
[ConDebug] Closing peer handle(%p) on port %i
Packet %p freed
Closed peer handle(%p) on port %i socket %i
[ConDebug] disconnecting peer(%i) handle(%p) on port %i
getpeername failed: %s errno = %s
send to %i failed: errno = %s
getpeername to %i failed: errno = %s, error = %s
[ConDebug] %p Incoming connection complete  on port(%i) socket(%i) from %s
[ConDebug] %p Outgoing connection complete on port(%i) socket(%i) from %s
[ConDebug] Accepting connection(%s) on port(%i) socket(%i)
getsockopt to %i failed: errno = %s error =%s
getAddressFromSocket to %i failed: errno = %s, error = %s
[ConDebug] Server accepted connection on port(%i) socket(%i) from %s
[ConDebug] Connection Closed on port(%i) socket(%i) reason %i:%s %s
[ConDebug] Connection Closed on port(%i) socket(%i)
kevent failed: %s
Unknown connection closed %i
recv %i failed: errno = %s %s
recv %i failed: errno = %s
kevent failed %s
TcpProtocolLayer: Unable to list network adapters(errno=%d).
TcpProtocolLayer: Failed to get string representation of ip(errno=%d).
Could not set SO_KEEPALIVE %s
Could not set TCP_KEEPALIVE %s
Could not set TCP_KEEPINTVL %s
Could not set TCP_KEEPCNT %s
%s %s%s%s Peer=%llu TTL=%0.2f
%s %s%s%s Peer=%llu
Sync object without snapshot while adding to view (id: %llu, type: %llu[%s]).
Sync object without snapshot while removing from view (id: %llu, type: %llu[%s]).
[DebugLayer connect] local=%d remote=%d connection=%d
[DebugLayer close] local=%d remote=%d connection=%d
[DebugLayer disconnect] local=%d remote=%d connection=%d
[DebugLayer accepted] local=%d remote=%d connection=%d
[DebugLayer connected] local=%d remote=%d connection=%d
[DebugLayer disconnected] local=%d remote=%d connection=%d
[DebugLayer error] local=%d remote=%d connection=%d
Transport log enabled: %d
Transport throttling override enabled: %d
Transport message fragmentation override enabled: %d
SyncCommit log enabled: %d
syncObjectStateHistoryBufferSize is: %u
Shared App Specialization enabled: %d
Invalid packet data size: 0
Max bandwidth exceeded. Current bandwidth: %llu bps, Max bandwidth: %llu bps
Max bandwidth changed: %llu bps
Snapshot reader (%s:%d): %s
NWListener.stopListening
NWListener.stateChanged state=%s.
NWListener failed error=%s
NWListener.newConnection
Unable to initialize listener
NWListener.init address=%s port=%d
NWListener.init address=%s port=any
NWProtocolLayer.open address=%s
NWProtocolLayer.openConnection file-descriptor=%d
NWProtocolLayer.close %p force=%d
NWProtocolLayer.disconnect %p force=%d
NWProtocolLayer.addConnection %p
NWProtocolLayer.removeConnection %p
NWProtocolLayer.cancelling %p
NWProtocolLayer.onConnectionStateChanged %p prevState=%s newState=%s
NWProtocolLayer.onConnectionStateChanged for unknown connection
NWProtocolLayer.onReceiveMessage %p readClosed
NWProtocolLayer.onReceiveMessage for unknown connection
NWProtocolLayer: Unable to list network adapters(errno=%d).
NWProtocolLayer: Failed to get string representation of ip(errno=%d).
base64EncodedStringWithOptions:
.cxx_destruct
handles
T@"<MCSessionPrivateDelegate>",W,N,V_nextDelegate
privateDelegate
T@"NSLock",&,N,V_handlesLock
session
TQ,R
.cxx_construct
dealloc
T#,R
isProxy
T@"MCSession",&,N,V_session
release
T@"NSString",R,C
setHandlesLock:
T^{MultipeerProtocolLayer=^^?{ArcRefCount=(isa_t=^v)}^{Allocator}^{ProtocolLayerListener}{ObjCObject=@}{ObjCObject=@}{Address={DynamicString=^{Allocator}*QQ}}},N,V_protocolLayer
T^{ProtocolLayerListener=^^?},N,V_listener
T{DynamicArray<re::SharedPtr<(anonymous namespace)::MCProtocolHandle>>=^{Allocator}QQI^v},N,V_handles
UTF8String
_handles
_handlesLock
_listener
_nextDelegate
_protocolLayer
_session
addObserver:forKeyPath:options:context:
archivedDataWithRootObject:requiringSecureCoding:error:
arrayWithObjects:count:
autorelease
boolValue
bytes
class
conformsToProtocol:
connectedPeers
countByEnumeratingWithState:objects:count:
dataWithBytesNoCopy:length:
dataWithBytesNoCopy:length:freeWhenDone:
debugDescription
description
dictionaryForKey:
disconnect
displayName
handlesLock
hash
init
initWithLayer:
initWithSession:protocolLayer:
intValue
isEqual:
isEqualToString:
isKindOfClass:
isMemberOfClass:
layer
length
listener
listenerQueue
listenerState
lock
makeAddressFromPeerID:
myPeerID
nextDelegate
objectForKey:
observeValueForKeyPath:ofObject:change:context:
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
protocolLayer
rangeOfString:options:
readySemaphore
removeObserver:forKeyPath:
respondsToSelector:
retain
retainCount
self
sendData:toPeers:withMode:error:
session:didFinishReceivingResourceWithName:fromPeer:atURL:withError:propagate:
session:didReceiveCertificate:fromPeer:certificateHandler:propagate:
session:didReceiveData:fromPeer:propagate:
session:didReceiveStream:withName:fromPeer:propagate:
session:didStartReceivingResourceWithName:fromPeer:withProgress:propagate:
session:peer:didChangeState:propagate:
setHandles:
setListener:
setNextDelegate:
setPrivateDelegate:
setProtocolLayer:
setSession:
standardUserDefaults
stopListening
stringWithFormat:
stringWithUTF8String:
substringFromIndex:
substringToIndex:
superclass
transportQueue
unlock
unsignedIntValue
waitForReady
zone
REMultipeerHelper
MCSessionHandler
MCSessionPrivateDelegate
NSObject
NWProtocolDelegate
NWListener
B24@0:8@16
#16@0:8
@16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
v48@0:8@16@24q32^B40
v48@0:8@16@24@32^B40
v56@0:8@16@24@32@40^B48
v64@0:8@16@24@32@40@48^B56
v56@0:8@16@24@32@?40^B48
v48@0:8@"MCSession"16@"MCPeerID"24q32^B40
v48@0:8@"MCSession"16@"NSData"24@"MCPeerID"32^B40
v56@0:8@"MCSession"16@"NSInputStream"24@"NSString"32@"MCPeerID"40^B48
v56@0:8@"MCSession"16@"NSString"24@"MCPeerID"32@"NSProgress"40^B48
{Address={DynamicString=^{Allocator}*QQ}}24@0:8@16
v64@0:8@"MCSession"16@"NSString"24@"MCPeerID"32@"NSURL"40@"NSError"48^B56
v56@0:8@"MCSession"16@"NSArray"24@"MCPeerID"32@?<v@?B>40^B48
@32@0:8@16^{MultipeerProtocolLayer=^^?{ArcRefCount=(isa_t=^v)}^{Allocator}^{ProtocolLayerListener}{ObjCObject=@}{ObjCObject=@}{Address={DynamicString=^{Allocator}*QQ}}}24
v48@0:8@16@24@32^v40
^{MultipeerProtocolLayer=^^?{ArcRefCount=(isa_t=^v)}^{Allocator}^{ProtocolLayerListener}{ObjCObject=@}{ObjCObject=@}{Address={DynamicString=^{Allocator}*QQ}}}16@0:8
v24@0:8^{MultipeerProtocolLayer=^^?{ArcRefCount=(isa_t=^v)}^{Allocator}^{ProtocolLayerListener}{ObjCObject=@}{ObjCObject=@}{Address={DynamicString=^{Allocator}*QQ}}}16
^{ProtocolLayerListener=^^?}16@0:8
v24@0:8^{ProtocolLayerListener=^^?}16
{DynamicArray<re::SharedPtr<(anonymous namespace)::MCProtocolHandle>>=^{Allocator}QQI^v}16@0:8
v56@0:8{DynamicArray<re::SharedPtr<(anonymous namespace)::MCProtocolHandle>>=^{Allocator}QQI^v}16
^{MultipeerProtocolLayer=^^?{ArcRefCount=(isa_t=^v)}^{Allocator}^{ProtocolLayerListener}{ObjCObject=@}{ObjCObject=@}{Address={DynamicString=^{Allocator}*QQ}}}
^{ProtocolLayerListener=^^?}
@"MCSession"
@"NSLock"
@"<MCSessionPrivateDelegate>"
{DynamicArray<re::SharedPtr<(anonymous namespace)::MCProtocolHandle>>="m_allocator"^{Allocator}"m_capacity"Q"m_size"Q"m_version"I"m_data"^v}
@24@0:8^v16
v16@0:8
v24@0:8@16
@"NSObject<OS_dispatch_queue>"
@"NSObject<OS_dispatch_semaphore>"
@"NSObject<OS_nw_listener>"
