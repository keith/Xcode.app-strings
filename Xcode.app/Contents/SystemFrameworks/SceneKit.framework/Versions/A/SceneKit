@(#)PROGRAM:SceneKit  PROJECT:SceneKit-602
?BxM@
?A.}?
\\CR+
?b]\BR+
!BR+
?rF\AR+
;A9)
!A '
,>I
u^@Jb
?p[M@8g
g&X=b
!!J=
fl(=7
)z =;
?pA6
7R6<<
yj?%
Mh?Z
#=;
xC%]
/A%]
|@%]
/@%]
|?5]
P?%]
/?%]
?hQ;A6
@!@F
g>h]
@>1^
?@%@!:D
?#,*
 {}=
u?|`G
#q<A
?`vo?
lI<U
nj?v
?MMf?
b?0b
~?cC[Cw
B[Bw
!A@
~?op
/[A^
~?lh
~?vl]@\U
L@e4
ywt>n
W'7>
!\!>
n=9{
?o*r?
?^Lo?
JDx<4
y;B<
5h?'
CGv}?
DCGv}?
DBGv}?
AGv}?
DAGv}?g*
@Gv}?QNZBC
@Gv}?Mc BC
@Gv}?/
D@Gv}?
@Gv}?v(
?Wv}?+
?Wv}?
?Wv}?
?hv}?
I Ae
?hv}?
_~_?yv}?
v}?oG
-?!w}?
y}?%x
w}??+
x}?T
=@)>
-AV>
SXI>
~?g|
>k+~?
>S@~?
?MKl
cCw=
K;5=
?sex?X
l? Aq
?6;j?
4f?}
?2td?
|?V4
|?^;
|?AM
+nA@
|?WF
|?:&
X?A|?
-?75|?D4
|?(`[@
.@u:
>hA|?
>-y|?
B[^>
}?m6
0>l$}?,
&>9G}?B
~?[C
=G;~?
=Qg~?
R||=eR
?SYl?
?Igd?
58D@Pz?\
C@Pz?q
B@Pz?
B@Pz?%
A@Pz?
-;A@Pz?
A@Pz?%b
@@Pz?
@@Pz?9
og@PPz?
&;@PPz?
@aPz?
@rPz?
Pz?+
?]Qz?
f?d[z?0v
lz?@
?XVz?
\z?.
?*pz?:wI@
:@s,
-@:"
z??T"@C
}_>I
{?=H
.8S>
<>^K|?
>&8}?
w}?@
j~?%Z
?!g
~?kI
?!;{?
8ho=
?G=t?2
n?Dj
?> l?
g?C9Q
f?hz
Rd?r7
Gx?f
Gx?<
t3@(Hx?
@IHx?
@kHx?^
Hx?3
Ix?k
Lx?r
?%\x?
A*q?e
G<5?DQx?
%?:[x?
cX@m
yx?\
x?K?9@G
>,ay?
>Y3z?
pz?c
tg>[
5^Z>e
M>=H{?
{?6!
=|?gC
|?4f
&~?A
=&m~?
~?F#w?~
?K:n?
?5Ad?;
u?nK
u?jP
RH+A
@#fF
u?za
Bv?{I
w?ZJv?W\
%a?a5v?c
v?%$i@9
<v?\
?J]v?
@xC:
v?eT@
>q<w?Zg
?c^'
%x?k
>lvx?
OZx>
~y?l
y??p
/3\>RHz?
A>2 {?
%\(>T
>#h|?mX
}?%]
~?Xps?
N&n=
?Swi?
Rs?h
jV?B
Rs?Z
BB%^
Ss?i
@.Ss?
AG ^
@PSs?
cyAv
IG?@
"@~Ts?
x}@
Us?y
@S@Z
\{?L
f@:w[
}s?ccT@L
N|A?%
`s2?_
s?h!)@b
@x*P
Ht?3
>`tu?E
>F}v?
>Ww?
y?m7
XVJ>
CU<>w
.>t}{?
=`=~?
m?zq"
`=0f
@k?`
,,8=W
?W]g?
e?UlL
ip?Q
ip?@
ip?u
@]jp?
R@Hkp?n^0Aj
@t|t
?Cpp?28
?Oyp?
p?{ 
p?A+d@W[q
,aU?
A@pCl
5$6?8,q?/3'@v
q?hz
q?dw
?)#r?$
qr?_
>yxs?bJ
?`ZD
t?F
du?p
5]_>
|z?J
Q|?v
|?t}?K
u?ZI
=tD~?
o?y\T
j?tF
?_%g?
?1{e?
cb? 
8m?Y
8m?`WLC
8m?n
A"9m?H
@u9m?
9m?a
@`:m?
;m?s
;m?Z
(@2=m?
>m?W
@-Bm?
?/Qm?
m?p\?@m
n?[|
?9}m
o?((
?SXi
p?*W
>)uq?
?1|4
>zru?
8v?h
w?;8
YR>shy?
>[@|?
u?>y
}?WCr?
l?->E
}X/=V
?8Ke?
r%<n
?RDb?
WICz5
6lxB;
VIB+4
oAt'
~+A7
?(Fj?a
?GVj?pP
?gCj?
aL@jk
<@#J
"@Y5
9?Idk?
?T:l?
?*ow
n?G9
?\tR
?uv2
av?I+
Sw?E
>x?f
9aR>
f11>
L|?l
x?B\
~?${l?v
~?ZJj?
|r=II
?l[h?
J='
e?p_
?B%b?j
f?q&FC
f?;!FB2
f?>{
M*@'
@EKf?
}f?M
f?d>I@
9@oF
[,@U
if?yYg?F\ @
jG?]
Hh?9
?-|i?
?[j?
?9*w
m?]1
n?=c
?FzQ
s?C7
?C86
6u>?
y?1~
y?Q/
"5->
w|?r
=$)}?
q?pa
=/P~?n
l?mTg
?vmc?
t@PA
BA7o
N5@2
@Zeb?1
E@2:
?v7c?<
&ru?K
$:?f
e?]R
ze?|+
f?bg
?;og?
?J)h?
>@jo?
?jL8
Mhr>7
9>%$z?
{?gdt?
q}?,En?
k?Q/x
\=bf
Gc?*
]?t`BL
a_\A
]?$ZcA
F\@C
@K>^?
@Mh^?
MB@HO
5_?<
&@>=
o`?\
M/E?
$?!;c?B
k?jK
?6!-
u?dv
2x?b
E>Yy?
pz?yxw?n
>]O|?
Yk?_
g~?8,i?
~?.Wg?H5,
duk=
rQ-=
?fld?-z
`"^<
a?RI
_Y?{
_Y?=:;C
1B `Y?,
A1`Y?:8;B
LA$cY?
gY?A1;A
g@zrY?
&Z?C~
?gCZ?U3v@
Z?vo>@
,0@v
[#@0
?BZ[?d 
S[~?{
[?h$
W\?~V
O?t]?
ByC?
&8?)
?[^y
j?% 
?g|o
>Zl?Q
>74q?0d
?H67
O |>
e>37w?/
 B<>
v?|(
{?8gp?
y=i:
?>xe?
L8=y
17C0
T?]+7B-
T?O=
hU?i
@V?of:@
W?h^
Z?p]Y?
Ig,?
?! _?
a?of
>]Oh?
uo?y
?w1M
0s><2v?
dx\>
Cz? $s?k
>Va{?
<}?_
`h?L8t
c? 
?->a?Z
9()
O?+X
2B6"
N}Al
O?)}
O?~{
&8}@l
P?{i
nQ?]
E@d\
^R?9
S?R&
AV?l
U?)"
y J?
*?Q1Z?
?5}^?
a?l\
? }c
`s?_B
>u"u?{/~?
gh>"
Q>(Hx??Tv?
l?%t
|?o.j?@
=Sz~?
8f?\TK
d?2r
M= y
^b?(
J?<t
hnID0
hICA
J?Gp{B
J?Qg{A
J?PE
hK?3
R@9^
?(,M?
?_AN?{
4G?|
dY?,F
?OYm
?:ZE
N~[>
az?4/o?
Pl?]
=&R~?5
O!W=<k
E6rE?
cPDGrE?ER
`PCGrE?
BXrE?
w_PB
sE?<
vE?}(
yE?|
A(}E?
`JAk
dF?$Q
`@80
?8.G?
?%xG?
G?aR-@cc
H?nR
?kfI?'i
K?;R
L?u;
N?|`O?
@R?0
i6'?
b? )
>)wg?k
Al?Gq
n?)_
t?T5y?&W!
voe>g
v?6ru?HR
]x?8
>j.{?
S}?G:g?
=R)~?wge?
a%C}
@?'(nB
@?N!nA
Ap>
@[%@?
@y<A?
<B?@
6@5z
?`WC?Y
?{gD?
?VHE?
o~?2ZG?
xCb?
&V?x
\?I
>jKe?z
>t~j?
do?@
q?F"|?it7
<>TTy?
3%>i
j=3N
RcEd
E8e:?
\D8e:?+
\CIe:?
BZe:?Q
e:?1&gB`
B4f:?
AAg:?7
i:?q
k:?3
o:?D.gA
t:?;
|:?l
U{@I
S;?+O
#@p"
>?31
?`;@?l=
?ULA?'J
? zB?
ui?!"E?~S
Q?l!H?M
o/=?
N?OW
TP?Z
>A+`?
>,gk?l?
GD>`
Zz?Q
~?;5c?
?m6b?
_?RI
_\ESX
 bC'
4?!N
4?\*9A
763@&
 @9'6?
PM@.
?|d7?
f8?!u
8?l[
>?pA
bJp?
i@?q
c}'?
'O?9
W?Aa
q?oHw?l@4
J&g>jNv?n
K>}<x?
|m?~
.?XY
.?\E
%p6A
%3AP
.??G
.??D
i/?)
iog@m
K!M@
yy$@\r0?
J1?R
W2?/
5?Bz
d=?;4
S?jKA?O
$?;pN?
tQ?P
e?*o
?-@{
>h"h?Z
>b,k?
p?+lv?
%8>c{y?
4j?*
`e?m
=-|}?
=Dj~?UOb?-]A
?W]_?{i
LkDY
h%kB
SQBY
UQAHm
-A~Q
(?/b
@g))?
s:@l>*?
GS@7
j0?s
1B|?b
LTc?
:?` 
<KD?
?`#U?
X?1C
>f.\?/
_?5$
>o)c?
f?mU~?
r?l>.
=XS}?
=sL~?]
,`?;
FEen
yA9B
"?q"A
@_)#?
zz@)
f=@wI$?7Pa@
JF*@Y
J)?lC
?5+?Ve
?aq,?
h?t%6?M
o??9
/6?&9D?
z$?4
?/PR?9
Y?>{
]?/0
Ph?]Qz?
x?\;i?d
=[$}?
ia?{JN
oAMe
o Ak,
?@cD
2@@L
A#@:
@zo ?f
?o+!?
$?c+
?g'?
PnW?
:?,}@?
W?~5
>W|[?
d{?J
>sLj?
p?9Cq?hA8
9J>K!x?
!f?d
c?jP
|?)#b?
?Mg_?
E^?A
>tD;:
+UtC~:
LtB6;
S:Be
LKtA=I
AA&R
?)]:AO
,Y@2
A@T6
-`.@
?,b ?
}#?J
%?S]
}?X;*?
rq?0
('f?
~s[?,
2?8e
cY?<
>2wa?H
y?O=
>gce?
o>aUu?
>9`{?
c`?g,Z
rSC=M
c\Ap
eyBA
?Sxx@
$@-w
"?>>
`%?y
-(?V
K_? _.?k
uwU?
Q9?v
=?c_
y\0?
?W^N?z6
z}?n
OW?p
y?lC
_?Z)x?
c?@1v?*
8t?+
o?FDA
*u>~
U>;5w?
g7>uXy?^
e?Zb
> ${?
_?F&`
H=J{
^?!w
p]?()
=_wC%
|^wB!
*BBC
n?:
x?9{#?h
E?$c5?rS
GG?(
L|?
z?/j
Jy?D
>dvb?
s?KXk
gj??6q?
8q?K[l?
2V{>w.t?
{d?(
z?wKb?
^?>v
M=%t
?Y) E
?7I~C
xCM1
@~B2
wB{2
?7H~A
CAeR
b@'P
J@sf
i8E@
5%@)Z
p?="?Eh
3nR?*
-6?`
:?nR}?GU
D?%yz?p_
BN?4
S?(*w?fO
>UPe?K
>;Vi?
Sv?;pf?
>8H|?
^?Xtk
>tBs@
W@81
Hj1@
?o~?
ms?y
p$L?DO.?j
Qz?z
Pu?b
q?ZI
>QNh?
8l?_
m?1&M
xze>
2D>%Xx?
|{W=ge
hUwCj
eBEF
ZswB*
PcwA
a5A%
isCA
t\@'
>yW7@
"1@V
$D @D
wk?6r
#s?N
)O?*:r?
j?wI<
|r?q
g?Kw'
i>;qu?
Re?>
)>A-z?rm`?
?^f\?d>
z[?8
O9()
aYDq
#RvD
>Z7YC
aUw@B'
>.:B@
-@3k
D@0g
j0@s
}?:A
l#Z?<
C=Q?
e'?m
#H?hw,?
p?Ec
8.??U
KY6?
T5-?
k<?F
W?\Xo?_^
n?}=
j?HQk?BxT
hn?,Fi?
g?NE*
P}?p
\?i7z
Z?0e
TtDT
v]tC
MtB!
%@/@
?kz?5
?(~?
r?|c
?vnn?
RS?}
$?"6l?
q=J?@M)?B>l?
{8?cF4?
Hm?D
m?x^
?R_V?_|m?
i?TWj?
^q?@Pf?,F-
c?|E
bw?vka?&W
{?5@]?\
[?O?(
d=HQ
?4/[?
Rq?{O
z?B|?
#k?Y5
q?s*
[i?0d
g?d!
?Ich? D
^?LT
Fg?`!
iL?6;&?
Cg?@
DNC?
1?{gh?
1?$|7?S
x(?5c=?!
?bfC?
j?B$
/k?M
?;TO?p[k?
xk?6
z_?m
k?+m
>qVd?
 j?>
PS>(
y?qs^?-
>R}{?
`~?c
Z?AD*
4Cro
GlAPT
4A[B
>S>O@l
Yjp@
>r4"@2
>@S@
>h=l?
e?h$
B#|?YL
gr?6<
h?gb
V?;q
]c?UN
T:<?1(/?j
Gt3?
e?pB
K;?K
`A?%
tc?X
>\!h?-
hb?t
>2V{?=
.Z?3O.
u*kD}x
kC%y
%AR@
DN)@p?
z?,
>o-c?
]?I,
U4j?/
[?('
>vO?
M ?Ii^?
G?tz&?
t_?z
`?]5
c?AJ
E?/5f?R
Ig?g
?k'R?i
{]?k-h?
Y~>Xps?
[Y>$
\?#1
>b,{?W
=kF~?
mY?xE0
o=%>
?)$Y?
TX?Ug59
fD5y
fCcz
v?j.
#]?S
>2!V?-
U?. 
B$k?
Ib?@
4X?+
?H?
??_\*?
v6?P
f7?3
V?||f?
>k?]
>O[o?Fc?
S9>m
{?l]Z?
Psr=
0bD[
Q5bCE
>A`>
oH5@
qW#@-
O?7Q
?&rQ?o
<S?g
B!R?
?`#U?
[?p%
_?Af
B?t\a?
2I? 
c?[C
[?*7e?
PS;>
[?Sw
z?d\Y?1
|?2>X?: 
)~?o
\D76
\C"7
N~.A
M@hu
^@lZ
~;1@<
>34z?
d?%\
vH?k
?tzJ?
4/S?
U?ys
lA?k*_?Q2
H?x
T?,cc?
d?Qkz
^r?F
uw=>}zx?
YW?#
<x=0,
U?M.F9{i
VA9c
y#@r
Tqv@
4Y@:x
@?[#
{?XW
A?IG
?~9G?$
I?zQ
S?PQ
+kK?
?vmO?s
#?_\R?
W?nl
Z?ca
uM?v
`?Xq
c_?[
d?8Nb?(Ig
ta?p]Q
>D0n?
c>:yu?
[?9G
|?_{V?>
E28j>.
.PD28j>
apPC
:j>(
B.=j>
Ej>9
OlPAc
q@[]
y;@u
r?J_
>?UY?
W8?*T
>Zg8?
>Eg9?
;?0G
g|k?
c?Jb
!B?Q
\!\?4
IcT?
1?KW0?n
>?hyZ?
Ga?w
#d?^+a?
k`?v
e>NFu?
/x?^
vU?*
|=h#
T?w,
nIDK U>
pICd"U>
kIBs.U>
A2uW>er[@
[>%\
G`>l
 L@;9c>
?_\z>
o?t~
3?/k
P1?:
3?,+
5?29
Dc?q8
@?s-
-CD?
+O?Qi
.?=IR?
rQ)?cD6?
U?x%
*?5
?EGR?
9^?/
T^?Z
_?R(k
Xm?8
>|}q?%
u?B{Y?4
x?]5W?
q|?{gT?
#|Dg&
Am:B>
@cGC>
jD>[#'@
7_@F`L>$
@>%W>
1k?1
C?6t
>*o'?
'?p}
>+Q*?T
d,?Z
2?[&
H5?e
5`T?
?of@?
?)<D?
nH?D
><?t`%?
9E3?
O?we
O=*?M
l<? 
Z?ip
>Qjc?hu^?Uik
]?P9V
 >{iz?
T?X7
g|?tbS?
R?y]
EG8->
=->Q
:B|G->
]->~O
:AI+.>
2@tb
1>8J
@"U4>
Su@l
2WV@
>9>b
Dm(@
@>Ig
?bhU>
G?qq
? cn>h
>h[)?:
M1o?}<
S?yv
<?<2
@L? 
*?_~3?
1\!?
;;?O
S?v3
cW?(H\?>
w]?b
c?W@]?
>*8h?
AE>K
&">WCz?
>Oy@@
j@36$>|
K>3Q,?
?Dku>x
I*{?2W
cat?q
>"U$?W
+?*o
4?oI
R?kH?tA9?
uYD?H
?I+B?
"?7RF?
8*?V
T?J@
?9)P?nRY?
[?-@k
>v6|?
eP?Z
@D% 
3z\A
Y*@%
@4C@
!u?`
|!>O
J?(c
:?.q
 Z> 
?-!
1l?=G
~#?1\
e?4f
6#_?
$1?.
?(|:?
?d:H?
?$aO?
Z?h\
X?X:?
j>k~t?a
3E>J
>^0|?
}?_DO?
O?u"
?:>N?
*-D&
b^PA,
=x%8@[_
t@DN
>o/q?
>kcX?Pn
>EID?vq
?nn,>
YY>m
?1h>
Vx>kD
JEW?b
-?,~
P?*p
2?kJ
7?Kr
?6\<?
);?K
H63?-])?.UE?
U"?{k8?
P?<J
X?dxl
>wig?TUX?
p?YnU?
aE>
O?>>
lN?G
L?0b
LIBB
=>iIA`
CA,
|,?p"
\>B%
Zy?w
?. 
-\?1#
?^g/?F
`H?j
lA?y
C?B`
M?T6T?
ra?kdW?k
.T?4
'P?FA
>S>|?u"M?
L?B@>
4L?H
FK?I
+Ce6
l,B\8
=Fu,Az5
AOy
{@q9
]4:@i
2L?u
?Nd&>
mb>2
?&nu>
Hkp?
>io?/
o`?1
]Z?ZF
HkT?
TVG?
!Y@?%v
mE?5'
?;9G?
(p?a
F>h]w?@
5|?:\K?
*gA
F]G@
E?Cs
?y=(>Re
?f3G>D
}?Tt
%h?i
bL?!
[?1T?+
S?BxD
@kn>
BO?@
iy=y;
Bmuy=)
@Y@x_u
TAFx{=
~=y;
>RF|
->lv
x?I,
j?`>
`?Di
[?XU
N)W?
?j4!?/
?~T'?
-?Yl
=?8j
RH6?N
8?>]
$G&?j
wA?9
,I?&
[L?;
[?-&R?
>]Ra?
>_@k?*VQ?
hs?J
qG>V
H?tB
G?K;
B['^
Ao.^
@b-^
AR(K=
K=ur.@
~?YR^
S?Tr^
r'@5
>Lkc
>LRi
]}?W
^>_$
]x?C
s?5}
o?@j
2^?B%
I?2Y
*?x(
W0?[
e??'
^G?$
?6!I?
{V?s
(b?^
)p?k(M?L
s?!VK?
}?cAE?J
Q*+BH
9!=~
5<wA
n+Amp"=
/$=^
Z&=S
F~y@
?O@w
>whH
>gDI
>\WL
?O#m=
>>\R
>c'\
{?Z)D>
v?LmY>
zpo?
g?2u
`? `
[?EH
":?t
]o+?
v8?4
u=?rp
I?3QH?z
b?7qN?
L?3P9
B>rjw?u?G?
+4 >J
%D?wh
mB?6[
QA?:
o@VJ/
@0,/
?n1/
?I=D
>]P?
>XtK
Pq?XrU>V
g?rR
c?}x
?{K
O?*6
bK?O<
, ?{
C??H
L8?~
,?p|
1?LU"?
/1?-
B?$BC?
-J?g}F?
!Q?|
Tm?k
gq?~
>Vfz?
=Ed|?
B?,G
0@W'
2?RG
w>A(
?S[*=
-c>n
=&Se>
>3Qd
;p~?
iWy?
;h?6
e?y 
M?5}
\;I?h
vo=?
\6?
*?vl4?
N ?EJ3?g
?RC;?
=?GW
gJ?taD?
>DoQ?
c?K>J?
m?<OH?
q?p{F?0
\>h[u?
9>GTx?
?.v;?
X}<`
X}<6t
3tA{2
<pB]?
<|ds>
&=`t9>
<>_%
I>W`8
<fx?
Xt?YN
Y?((
]oS?a
E?!#
54?U4
q-?SB
<^?%
H?XSY
tY>r
u?9bA?
75>n
z?Mj<?
};?8.c
=1_~?
[Z=Ee
r"<*
I$DB
#<@1
8G? $
@>"&<
f:<b1
!F<bIY>82
?,go<
.=nm!>
(>HR"
<X>K
=zpg>
|Eg?
=Umw>k
b?SA%>7m
Q>IM
M.2?
P,?#
"?-!+?.r
4?V,
[;?,a9?=C
XJ?f2@?
EQ?1
FE?}
h?h=D?L
B?Bv.
su?9
<?vp
1>Pqx?g
z?`x9?
|?tF8?
7?wf
5?9&
tR:D
6)<G
I<RF
E}?*
k#=y
mD=y
+>dw1
d?LP
Q1b?
{;>G
P4W?
-@W?
lCU?
<jT?d
<?d\
)!0?
tD*?
6?'1
=?=I
??n2
>QfW?.
A?dx\
>D5m?
Z=?G
(S>k
|?}v4?
=b1~?}
 1?E
_#'C)
AE/#;
8R>u
%L;s
GI<R
?rk?
&U? 
 :>%>G
PnS?6Y
$T?I
v7S?
Q?29U>.
S?g{
K?0e
6wH?
j.?=
 ? &
&?S!
2?Tq/?
:?14?
B?:>6?
?^JI?
=?sK
Rb?*
(8?MM"
S6?q
3>/jw?
74? 
2?p[
+?=C
rSyC
#:g&,@
@@QY:\
hxw?
8$=N
kGm?%
_=~p~
_\^?
jhS?
N?F_
. =%Z
$^J?r
C=gG
1[J?`:
(eJ?
^*J?
=By?>
>UMP>
*>1xx>j
!L?e
zpK?
/A?5
B/?\Y
2'?H
1?TU
?{0A?6;2?
.9?N
x8?4
f[?>
>7?N
mf?i
>_)k?Z
}>p_o?
zX>W#s?F
7>[av?
,?em
=PS{?
;.VT
t?zl
<O<'
/4o?
;RcB=
T=nl
1?5_
+k3?
p=xC
1??S
8?d[
MI:?
F<?z
,>Ovc>7
KY>?
Z>|B
@?Ab
e??.
98?G
,4?Q
0?EG
"?Id
*?o-
?(G9?
?/N@?
|_?*
.?~tZ
ji?z
1*?'
Z>V~q?.u0?
u?->)?
+|?iR"?F?
Pr@_\z?
?BxM@m
>@,dv?
@(Gq?
?=ae?
?8hC?
?%#3?
?A.}?
r?9B
j?}[
Vh?L
d?fk
h\AX
Pr@d[z?
?5|M@
1@'1t?
?D0R?
?tM?
?w0>?
?#/3?
?5Dy?Q
r?9B
d?;m
?6}\B
k\Ai
@/Pn?
?5~M?
?u"}?p
Cy?T
?3Qh?:"
i\A&
@D2|?
Pr@zRz?
?cDb?
?YnM?
??:y?7
yj?B
?\}\B
@cc~?
@Xs|?
?XSM?
?! 3?
?o/y?
o?GX
?Xuj?
?gEh?|{
If?'
@p&~?
Tr@\>z?
?]NM?
?seH?
?8j-?
u?kG
>h?E
?ud?
?-h\A~
@fN{?
@t~z?
@<ln?
?K>b?
?u[V?
?fg-?
|?I.
?}]r?
vo? 
?M0h?
6f?&
?/md?
@Xuz?
?<k1@
@3lp?
@oEn?
?>"b?
?Qg^?
y?Gs
?!Wj?d
?Z+f?[{
?>Zd?
?'hr@
?<g1@
@/Rp?
?*Re?
?"S^?
?>$H?
?vl8?
xu?M
Hr?3
?[`o?-|
Lj?3
?"m1@Z
?Y3Z?
?-Ar?
?9Bj?
?Fe\A
j1@D
@JDp?
@AGk?
@{kh?
?$%e?
?|D8?
x?Y
d?ys
?Kg\A
@%\|?
>@l>v?
@L8p?
?V~a?
cu?U3
?4,r?!
?}#j?
g?t~
?Lf\A
@-y|?
?>%_@
M@~ow?
?>]a?
?x_=?
?_au?G
?p}l?
j?QN
?S%b?
f\AL
@!V{?
+_@9Dx?
M@cGw?
? }%@
@y"p?
?{hG?
?h^B?
?i8=?
?du'?
a?"r
@nR}?
`r@s
?o/_@
`1@E.t?
?c{%@
?&4Y?
?%g\A
?kf1@+
@1_j?
@HQg?
?<k'?
r?DR
o?(}
ue?b
?,~c?
?he\AI
@lZ}?
@sG{?
_@R+x?
>@p]u?
n1@<
?}y%@O
@B@j?
?P92?
?[`'?
|?>Y
?ZGu?
?zSe?S
?iUc?
ra?RI
?3e\A
@<L{?
^@S>x?
?!#N@
?1x%@y
?(d7?
?z9?
?rMu?B
n?9&
i?_y
Rg?U
?Dh\A
@UK~?
?6u%@'jq?
?&o?
?Hh\A
@=E~?
@0K{?
N@GZv?
?2r1@0
?A+<?
?CV'?
y?$b
Fu?Ho
ii?0
?:i\A
@S<~?
@%=|?
@ZE{?
?@uYt?
?>z1@
?>y%@
@HNf?
?{2_?
?]m}?
?t&y?
?1Eu?
?mVi?y
`?#,
~\B7
h\A5
@hB{?
~%@C
@Efn?
?/1J?
?+Ny?
?kfu?bL
n?,D
?w1i?
f?GX
?}v\C
@j/~?
@{2{?
%@r3p?
?~Qb?
}?hx
?Miy?
n?hw
i?Ym
?~~\C
?]~\B
?9}^@#Ix?
>@>$t?
@ywh?
@Ife?
?dvV?
?N*N?
?e6@?
?Sw1?
1~?K
ju?~r
?<hf?
?Ti\A
@S!~?
M@;Uv?
%@~so?
?Y6;?
?c_6?
?Nc'?
y?1$
n?p%
h?cd
?l>f?
?5]_?
?Kh\A
@wj~?
@[^}?
?Sv^@
v1@w
z?_$
?~pn?`
?ock?
h\A!
?is^@`
?Na1@
@YPl?
?cdY?
?E.D?
?sI1?
Mz?Y
u?O?
?MLk?
?YQc?(
^?r3
|\BL
"At^
@5{|?
q@"9y?
s^@0
?ur%@
@XWi?
?QO??
?Tp,?
?K>n?
?!>h?
e?)#
?)B^?
?@~\C
?F~\B;
"AB?
@}[|?
@tb{?
?+k^@
~M@D
91@} q?
?R`%@
?x`P?
?,.n?[y
h?Ig
?UM`?
?${\B
h\A+
?Pr^@.Sw?
}M@0
?pw>@'ls?
?nM%@
@I-h?
@nme?
@/ob?
?&6_?
?+kG?
?)z,?
Ov?-
n?%]
?+m]?
@R~~?
@;m}?
?Sw^@j
>@S s?
!1@;
?G9%@3
?H2[?
?@1:?
? &1?
?|{#?
Rv?/
d?is
?jg\A
q@1]x?
?e5%@|
?b0S?
?gG>?
?;71?
?+5{?^
v?#2
m?LT
?huj?B
jd?w
|\B?
i\A>
!"A,
@.:}?
@1{y?
^@mpv?
?}x>@
?d"%@
@?9j?
?$^V?
?4L1?
?Bx(?
Ha?8f
;A33
@LO|?
?&8Y?
?B!R?
?HRN?
?;QF?
?1`1?
{?Qk
`?O 
?_z[?
?&p\AN
@C7{?
@p&z?
r@XYw?
@% f?
?t{5?
?px1?
?dsm?
?XYc?>
?Sx`?
?s~\B3
%"Ai
@#g}?
?#2r@
@k'b?
?B]T?
?%<!?
?1\m?
?Bwi?P
/]?g}
?{JZ?
?("A
A|e~?
@xD}?
@=(x?
Lr@%
%@@jk?
?8HP?
~\B7
+"As
AbL~?
@Hp{?
M@$Gr?
!1@G
?BBL?
?`".?
?]Q*?
Oe?%Y
^?+j
?6H\C
@;9w?
>@|`o?
%@@1j?
?J|2?
?Xo|?
v?u
?Hkh?s
?2wa?fJ
?AJX?_
0"AU
@oe}?
?_D_@
$@}ui?
?`>A?
?.=:?
?%>/?
? }+?
?nn ?
q?~6
l?5y
?[x\C
?X:"A
@Gt{?
?.u_@
?[A1@
l?\8
?2p\C
?3 <A
@82w?
?AGN@Dio?
?P:1@
}|?)
v?D5
.g?9|
?5Fc?
2Y?X
?2}\B
?)%<A
?3["A
3%@Y
@T8^?
?JE'?
f?`u
]X?c{
?>0<A.s~?
AY0}?
@%X|?
@tyw?
M%@.
@xFc?
@Ae`?
@BzZ?
?W"T?
?2!>?
?=H;?
?h#/?
?]7%?
x|? ]
Bf?D
b?e7
H^?~
D<Aj/~?
r"AV
@(cx?
?p>?@
?'l%@
@&Vb?
??sJ?
?NDG?
?J{#?
}|?73
?Iiv?
?Crj?/R?
"ANa}?
@N+y?
?J`?@
1@uvf?
@2Xa?
?<j(?
?8/v?S
d??n
z`?Z-
Q?`X
h<AT
Ad>|?
#t@/
N@b-j?
1@AIe?
@%][?
?:>V?
?MLK?
?^fH?
u?ip
?Umo?
qT?SX
?i~\B
]A_&~?
@REy?
`@.8k?
?&4&@
@k`_?
?l|N?
?*tF?
?x(>?
?q9&?
?S?#?
{?k(
?:WdE
?3s[C
?|0]A
AxB{?
@yx?
?t}t@l!l?
?uUO@
@o,\?
?B!J?
?'3b?$
h\BJ
`@$Eh?
}O@;
?^i@@
@KuY?
?`sF?
?oK<?
?;n4?
?k2?
?WB{?
?x%m?
?uXa?S
OX?|
L?i5
.\C~
?fV\B
?Ac]Ac`}?
@:Wx?
O@Wwd?
?G!@
?t)R?
?<KP?
?8eN?
?o~C?
?NC4?
{?&r%?
9`?R~
g[?a
?v3O?
|\BL
?Wj#Aw
@K9w?
tA@'
~4@h
@!@Z?
?2uC?
?rN<?
?H27?
?I0-?
?t(s?A
k?^c#?
M?]5
I?Ul
?hG)E
A7n}?
]A@i|?
?hU=A
@W_q?
?urQ@
?<g??
?9}5?
?TSr?
?]kc?ob$?
O?cD
=Aq=z?
@IHt?
@kdo?
@ Dj?
?Iev@
C@,d^?
?[y!@!
?Yn9?
?40R?;
I?l@
?4~^B
?f0"B
Ak+~?
?aP$A/
@erj?
E@W_]?
-@Wx[?
s#@2
@?6Y?
?%?V?
?SXU?
?O@O?
?]jH?
?9cD?
?1x`?k
DP?M
?r."BS
A}\{?
@-#m?
?eU;@k
?P8W?
?${D?
?[@@?
?(av?:u9?
]X?[
?|FN?
E?U4&?
?|CA?
\B$a
?]OY@*
?Lm3@
@HRZ?
?lAW?
?aPV?
?kGI?
?0fC?
}?2XA?
t?X:??
?zlG?
A&5|?
AhAx?
?H1`A&
?]}?A
?qV%A
@Wzi?
@HPd?
@UN_?
@u[^?
?]jB@9
?BB\?
?@j[?
?=eQ?
r?LqE?
i?x|C?
S?,e=?
N?EJ;?
H?l$9?
?;nD?
?-z;?
?&|!B
A5`x?
?qN%A
A=bh?
?!\r@s
?-]T@
rG@{
;@7R^?
?-@1@
?V~]?
?J%\?
dJ?~9C?
E?XWA?
Au:x?
?Rf%A
@^I^?
i@]P_?
?\qa?
?a3\?
rR?C
?R'L?f-M?
=?TtH?
u8?>
3?V-E?
?gtdB
O@AZ
@6V^?
@R}_?
r@t)b?
?_@V@
R)@U
@)ye?
@;me?
?B'd?
=?%YS?
"/?yxO?
G^Cc
AKYf?
KdAZc`?
,AF}^?
@`ta?
@sHf?
1o@r
F@y=h?
@M/i?
@EHi?
@zSi?
@@Qi?
?cAi?
?l$i?
?P7h?
?X f?
?w.|?
?0.q?C
?r1Z?T
R?F\`?
?(|J?
63?r3\?
?OgyCi
@l&g?
?T9P@
9@I,m?
@xzm?
?4gm?
?P:m?
?5*l?
?H5x?7mj?
?y"`?5
V?CXi?
?G!M?
>?t#h?
`2?JEg?
 "?~
?+l1B.
sC0*m?
?\:iA
A0.q?
?]F+ADPq?
AUgq?
?8fs@_
?Ii'@
av?'
N?p|q?
D?Jyq?
?]66?
?zS1?Doq?
?p}$?
?Adq?
?c`q?
?fff?
?fff?fff?
L>fff?
Mb`?
6<Z(
?Dio
h?)\
x?d]
MbP?
=333?333?333?
fff?
>333?
fff?
fff?
>333?
?fff?333?
MbP?
>333?
>fff?
HAfff?
?ffffff
?fff?fff?fff?
?333333
UUUUUU
_,b?_,b?_,b?
kvz=kvz=kvz=
@333?5
333?
333?
33s?
G &?C
intensities.
77777777
00000000
Ga==
8?Sx
tWxCE
HB33
?33s?333?
@ffffff
IESNA:LM-63-1995IESNA:LM-63-2002
ffffff
333333
$tI,*
]@ffffff
333333
?ffffff
?333333
?333333
?333333
?333333
?ff&?RGBA
VUU
VUU
i\)7.
blnOq
sy2-
i\)7.
blnOq
sy2-
?UUUUUU
>T=t<?Xf?
Q?m7
>|eV?
+?xE`?
|?M2
>~qi>
OV?*
?".
j<F^
g?K"
>G<i>py|?
=?$b
>]Km=
Sq=~7}>K
M:>}
bx?`
> @?
>{1p?
Q?}=_>
ty?*s
s?lx
?)yM?GO{=o
 d=/Pf?
b?f-
>caH?,f
>To)?
1!?&7j>
4m?<l:?%
h?|3
|8>@K
=:#Z>
H?-AF>D4
c;=g
F?Mf
N:?r4
>Kuq>N*B?q
>an_?
>,..>
Ij?mtz?
cU?l
{>;V
?h%=?XT
?mSL>
9$?e
I/>=
j?9}%?
>S}"=x
:b?<1;>
GT?&
?W$&>
AU>6Z
>pyH?
et?=
Z>g&
ld? 
=akf>
rx?Aa
?@/|>
O?;s
H>:y
=?\r
}=?I
>2rN?
<m?!!
%n?VHI>O>E?
M?LOH>
=O\z?
M?3Q
?uUh?
?{Ke?
2?:y
k:>N
O'?L
n?*wz<
Z>]S4?
>~R%?
+:?JC
~?8IC?\
E?l&o?
y!?9DH?%t
>uX?
8>_&
l?3o
?a8W?
:V?#
M?*X
U=6Y
?TR7>
A??0,
?fKb?
N?2Xu?
L'>:>.?@hA?2F
hG>H
J?P9
>E*?
cF?sH
>t}[?
CG=N
&4?S S>k
v9?`
_R?O
z?Qg
<g?}
'?,df?3
m?JE
:==%
>O#->
j?gc
>B{1?
=sIm?
;.Tb?
= $k?
YJ?t
ZQ?1z
((knNff
`>9?
`>9?
8-0?
8-0?
Z&>X
Z&>X
5?33
fff?
?333?
?333?
fff@
US]CQ
^(BM
kZ;&
C3DTransformsArray
transformsArray
transform
identifier
<C3DTransformsArray %p>
C3DFXOutline.plist
Outline-pickedObjects
C3DFXOutlineRetina.plist
C3DFXAuthoring.plist
--OutlineMaterial--
PickedObject.glsl
SCNDefaultIrradiance
_defaultLightingEnvironmentIrradianceTexture.textureType == MTLTextureTypeCube
_defaultLightingEnvironmentIrradianceTexture.pixelFormat == MTLPixelFormatRGBA16Float
SCNDefaultRadiance
_defaultLightingEnvironmentRadianceTexture.textureType == MTLTextureTypeCube
_defaultLightingEnvironmentRadianceTexture.pixelFormat == MTLPixelFormatRGBA16Float
irradianceTexture.textureType == MTLTextureTypeCube
irradianceTexture.pixelFormat == MTLPixelFormatRGBA16Float
radianceTexture.textureType == MTLTextureTypeCube
radianceTexture.pixelFormat == MTLPixelFormatRGBA16Float
compute_diffusePreIntegrated_texture2d
v16@?0@"<MTLCommandBuffer>"8
scn_draw_fullscreen_quad_vertex
cubemap_from_sh
compute_specularPreIntegratedLD_texture2d
compute_specularPreIntegratedLD_texturecube
compute_specularPreIntegratedDFG_diffuseHammon
resource.storageMode == MTLStorageModeManaged
loader
loadedMipMapCount <= desc.mipmapLevelCount
v20@?0C8r*12
compute_cube_from_equi_views
compute_cube_from_equi
compute_equi_from_cube
sourceImage
Unable to find texture for source %@
sliceCount == SCNMTLComputeTextureSliceCount(dstTexture)
_encoder == nil
commandBuffer != nil
srcTexture.width == dstTexture.width
srcTexture.height == dstTexture.height
srcTexture.depth == dstTexture.depth
_encoder != nil
_computePipelineState
firstIndexOfRange == UINT_MAX
keyCount
!isnan(t)
keyIndex == (int)keyCount
valueWrt == kf->_values + (totalValueSize * keyCount)
source
dest
C3DAnimationClusterKeyframes
<C3DAnimationClusterKeyframes %p>
C3DAnimationCluster
<C3DAnimationCluster %p>
object
CFGetTypeID(animation) == C3DKeyframedAnimationGetTypeID()
kf->_keytimes[index+1] >= (float)time
scene
SCNMonitor
SCNKitError : can't load nib named : SCNMonitor
SCNKitTypeInspector
can't load nib named : SCNKitTypeInspector
selection
name
address
type
semantic
childs
error in SCNTypeInspectorView : returned object is not a dictionary
instance
NULL
%@ 0x%p
true
false
[%f, %f]
[%f, %f, %f]
[%f, %f, %f, %f]
identity
[%f, %f, %f, %f][%f, %f, %f, %f][%f, %f, %f, %f][%f, %f, %f, %f]
/[], 
_timesToRepeat
_timesRepeated
_repeatedAction
_forever
_opacityTarget
_opacityTargetReversed
_lastOpacity
_isRelative
v28@?0I8^^{__C3DNode}12^^{__C3DLight}20
type < kC3DLightEffectiveTypeCount
C3DLightGetProbeType(light) == kC3DLightProbeTypeIrradiance
C3DLightGetProbeType(light) == kC3DLightProbeTypeRadiance
C3DLightingSystem
node
light
lightingSpaceMatrix
((rInd > 0) && (rInd <= pipelineData->_runtimeLightsCount)) || (rInd == kDefaultRuntimeIndex)
v36@?0I8^^{__C3DNode}12^^{__C3DLight}20^(?={?=ffff})28
v36@?0I8^^{__C3DNode}12^^{__C3DLight}20^28
v36@?0I8^^{__C3DNode}12^^{__C3DLight}20^{?=ffff}28
lightingSystem
lightNode
shadowInd <= kMaxRuntimeShadows
casterIndex > 0
casterIndex <= kMaxRuntimeShadows
<C3DLightingSystem %p>
triggerOptionsForRealtimeViewer
kSceneSourceAutoLimitMemoryForImages
kSceneSourceInvertMaterialOpacity
kSceneSourceCreateCameraIfAbsent
kSceneSourceForceInProcess
kSceneSourceLoadingFromExternalProcess
kSceneSourceCreateLightIfAbsent
kSceneSourceCreateNormalsIfAbsent
kSceneSourceAdjustInvalidClippingPlanes
kSceneSourceFlattenScene
kSceneSourceSplitMeshesForGLES
kSceneSourceConvertToYUpIfNeeded
kSceneSourceConvertToUnit
kSceneSourceAnimationLoadingMode
keepSeparate
playRepeatedly
playOnce
playUsingSceneTime
kSceneSourceCleanupMeshes
kSceneSourceRemoveConstantAnimations
kSceneSourceRemoveAllLights
kSceneSourceRemoveColorArrays
kSceneSourceInterleaveSources
kSceneSourceDeinterleaveSources
kSceneSourceMakeSourcesCheaper
kSceneSourceSkipConsistencyCheck
kSceneSourceCheckConsistency
kC3DIOSceneSourceWasExportedBySceneKit
kSceneSourceUseSafeMode
kSceneSourceAssetDirectoryURLs
kSceneSourceOverrideAssetURLs
kSceneSourceStrictConformanceKey
kSceneSourceVerboseMode
kSceneSourceFormatHint
kSceneSourceProcessIsSandboxed
kSceneSourceSkipSandboxValidation
kSceneSourceSkipImagePathResolution
contributors
created
modified
up_axis
unit
authoring_tool
author
unitName
unitMeter
com.apple.SceneKit
kEnclosingDirectoryURL
C3DSceneSource
Unknown or missing file
Could not load the scene
The document does not appear to be a valid COLLADA file. Please check that is has not been corrupted.
The document does not appear to be valid. Please re-create it from your original COLLADA assets.
<C3DSceneSource >
org.khronos.collada.digital-asset-exchange
C3DParticleModifier
<C3DParticleModifierRef>
version
radiance
irradiance
slot
GaussianBlurPass-Y
GaussianBlurPass-X
scn_draw_fullscreen_triangle_vertex
bloom_blur_%sfrag_%d
smp_
!texture || [texture conformsToProtocol:@protocol(MTLTexture)]
SCNMTLDeviceSupportsDepthClipMode(_encoder.device)
_ptr != NULL
Bloom
CompositePass
COLOR
DOF-Final
AverageLuminance
enableBloom
enableVignetting
enableColorGrading
enableSaturation
enableContrast
enableColorFringe
enableDebug
enableExposure
enableFrameLuminanceAutoExposure
enableHistogramAutoExposure
enableDepthOfField
DOFSampleCount
enableVR
enableAR
enableGrain
grainIsColored
enableWhiteBalance
scn_draw_fullscreen_triangle_VR_uv_uvNorm_vertex
scn_postprocess
color
trcOther == trc
B108@?0{CGColorConversionIteratorData=Iqqqqqq^^{CGColorTRCData}^^{CGColorMatrixData}^^{CGColorNxMTransformData}}8q84q92^q100
B100@?0{CGColorConversionIteratorData=Iqqqqqq^^{CGColorTRCData}^^{CGColorMatrixData}^^{CGColorNxMTransformData}}8q84q92
count * readStride <= read_length
count * writeStride <= write_length
none
float
bool
char
double
C3DFloat
float2
float3
float4
float4x4
float3x3
color4
short
half
uchar
ushort
int2
int3
int4
ucharn
charn
10a2n
u10a2n
uchar4
char4
uchar4n
char4n
ushort2
ushort3
ushort4
short2
short3
short4
ushortn
ushort2n
ushort3n
ushort4n
short2n
short3n
short4n
half2
half3
half4
type < kC3DBaseTypeCount
unknown type
kC3DBaseTypeUnsignedChar
kC3DBaseTypeUnsignedCharNormalized
kC3DBaseTypeChar
kC3DBaseTypeCharNormalized
kC3DBaseTypeUnsignedShort
kC3DBaseTypeUnsignedShortNormalized
kC3DBaseTypeShort
kC3DBaseTypeShortNormalized
kC3DBaseTypeHalf
kC3DBaseTypeFloat
kC3DBaseTypeInteger
componentCount == 1
bytesPerComponent && componentsCount && floatComponents
_dst
string
v32@?0@8@16*24
hw.optional.sse2
hw.optional.sse3
hw.optional.supplementalsse3
hw.optional.sse4_1
hw.optional.sse4_2
hw.optional.avx1_0
hw.optional.fma
/bin/rm
SCNDisableLinearSpaceRendering
SCNDisableWideGamut
SCNEnableWideGamut
length
(order * order * sizePerCoeff) == length
SKESceneDocument
SKEDocumentSanitizer
v24@?0q8r^v16
sampler1D
sampler2D
sampler3D
samplerCube
vec2
vec3
vec4
ivec2
ivec3
ivec4
mat4
mat44
texture1d
texture2d
texture3d
texturecube
#define %@ %@
SSAORaytracePass
SSAO-DepthNormal
SSAO-MinMaxOffset
SSAOSampleCount
SSAODownSample
SSAOCameraOrtho
SSAOVRRendering
scn_ssao_compute
!geometry->_trackedNodes || !CFSetGetCount(geometry->_trackedNodes)
<%@:%p "%@"
  mesh: %@
  mat%d: %@
serializedData
bindInfos
mesh
overrideMaterial
materials
levelsOfDetail
sceneRef
input
geometry
material
!CFSetContainsValue(geometry->_trackedNodes, node)
geometry->_trackedNodes && CFSetContainsValue(geometry->_trackedNodes, node)
geometry->_trackedNodes
C3DGeometry
path
v16@?0d8
meshElement
elements
channel >= 0 && channel < channelCount
C3DMeshElementGetIndexCountPerPrimitive
indexCount % channelCount == 0
C3DMeshElementGetChannelsDefineSameTopology
C3DMeshElement.c
indicesDataLength > topologyIndicesLength
v32@?0I8^I12I20^B24
CHANNEL %ld/%ld
%4u : %4u %4u %4u
%4u : %4u %4u
%4u : %4u
%2u : [Polygon %4u]
 %4u
C3DMeshElement
<C3DMeshElement %p type:%@ primCount:%d channels:%d indexBytes:%d offset:%d acmr:%f inst:%d dataSize:%d shared:%p>
triangles
triangleStrip
lines
points
polygons
triangleFan
patch
invalid
_C3DMeshElementInitWithPropertyList
doubleSided
linesArray
trianglesArray
pointsArray
trianglesStrip
polygonsArray
indexes
subElementsCount
bytesPerIndex
primitiveNormals
bbox[0]
bbox[1]
__readIndexInBuffer
v16@?0@"MTLRenderPipelineDescriptor"8
Compute SCNGeometryScreenSpaceAdaptiveTessellator tessellation factors
compute_tessellation_factors_screeenspace_adaptive_uint16
compute_tessellation_factors_screeenspace_adaptive_uint32
Compute kC3DGeometryTessellatorTypeConstrainedEdgeLength tessellation factors
compute_tessellation_factors_constrained_edge_uint16
compute_tessellation_factors_constrained_edge_uint32
C3DHitTestResult
result
pointOfView
auth
groupIndex == meshElement->_primitiveGroupCount
ctx->_currentIndicesContent.indicesOffset == 0 && ctx->_currentIndicesContent.indicesStride == 1
__ProcessTriangleRange_Mask_Ind16VrtFloat3CullBack
__ProcessTriangleRange_Ind16VrtFloat3CullBack
boneIndicesSrc
v48@?0I8^I12I20I24I28I32I36^B40
vectorCount == 3
q16@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}8
segment
v24@?0^^{__C3DNode}8q16
<C3DHitTestResult %@ %f,%f,%f>
library
output
sphere
transformedSphere
modelMatrix
normalMatrix
couple1
couple2
%@-splitContainer
splitContainer
vramResource
VRAMResource
sourceChannels
D!=-1 && E!=-1 && F !=-1
B8@?0
B16@?0@?<v@?>8
enginePipeline
positionSource
normalSource
uvSource
v24@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}8q16
v32@?0^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}8c16q20C28
default camera
shortestPosition <= farthestPosition
SceneKit
element
material == elt->material
componentsCount!=0
%@-split%d
oldIndexToNewIndex[sourceIndex]
w == count * indexCountPerPrimitive
w == dataLength
faceVertexCount >= 3
_audioSource
_wait
q16@?0^{__C3DNode=}8
AuthoringPass
DEPTH
scn_clear_z_reversed
scn_clear_z
scn_clear_z_dummy_frag
scn_draw_fullscreen_fragment
debug_probe_vert
debug_probe_frag_cube_array
debug_probe_frag_2d_array
Authoring
allocator
-[SCNMTLBezierCurveDeformer initWithMeshlessGeometry:outputs:deformDataKind:finalDataKind:resourceManager:computeContext:]
SCNMTLBezierCurveDeformer.mm
offset <= UINT16_MAX
deformer_bezier_build_quad_geometry
deformer_bezier_build_info_linear
deformer_bezier_build_info_quadratic
deformer_bezier_build_info_cubic
scn_bezier_curve_data
scn_bezier_curve_controlPoints
C3DList
list
<C3DList %p: head %p, tail %p, %ld objects>
_actions
_mycaction->_animIndex
v16@?0^{__C3DParticleSystemInstance={__CFRuntimeBase=QAQ}^{__C3DParticleEmitter}IIi^{__C3DNode}^{__C3DParticleSystem}^{__C3DParticleManager}^{__C3DScene}d{?=[32^v][21^v][21^v]{__C3DParticleArrayLayout=[32I][32^?]I[21C][21C]}}IIIIIBdf{?=}{?={?=SS}I}^{__CFArray}^{__CFArray}}8
C3DLightGetProbeType(lights[i]) == kC3DLightProbeTypeRadiance
v36@?0I8^^{__C3DNode}12^^{__C3DLight}20^{?={?=[3]}}28
C3DLightGetType(light) == kC3DLightTypeProbe
outData->parameters.probe.index >= 0
shadowMapName
ctx.packedIndices.data[fl - 1] == li
pl != 0
ctx.packedIndices.data[pl - 1] == li
ctx.nextIndex[i] <= newIndicesCount
ctx.nextIndex[i] <= indicesCount
SCNMTLClusterSystem.mm
clusterCellSize == sizeof(simd_ushort2)
__compactLightIndices
count > 0
Omni:%d Spot:%d Indices:%luu
debug_omni_vert
debug_light_frag
debug_spot_vert
debug_cluster_frag
scn_draw_fullscreen_quad_VR_pos_vertex
debug_light_indices_8_buffer_frag
debug_cluster_slices_frag
i < lightRange.y
Texture
Buffer
Invalid
Invalid - wrong value
texture: {
width
height
depth
arrayLength
textureType
storageMode
usage
cpuCacheMode
pixelFormat
mipmapLevelCount
sampleCount
C3D::PassBufferParameter [
] : 
index < _inputCount
index < _outputCount
this != dep
_renderGraph
parent
index < _descriptor.inputCount()
index < _descriptor.outputCount()
outputResource
default
%s%p
passNameCache
com.apple.scenekit
C3DTransformTree
transformTree
hnd != kC3DTransformHandleInvalid
handle.level < transformTree->_levelCount
<C3DTransformTree %p>
handle.index != kC3DTransformIndexInvalid
countToMove >= 0
(handle + offset + countToMove) <= _capacity
startParentHandle < _count
newHandle.level == (parentHandle.level + 1)
firstChild.index != kC3DTransformIndexInvalid
lastChild.index != kC3DTransformIndexInvalid
lastChild.level == firstChild.level
lastChild.index >= firstChild.index
firstChildToRemainAfterDeletion != INT32_MAX
_handles[ node->_transformHandle ].level == l
_handles[ node->_transformHandle ].index >= minIndexToDestroyPerLevel[ l ]
firstHandle.level == lastHandle.level
firstHandle.index <= lastHandle.index
handle.level < _levelCount
v32@?0^{__C3DNode=}8q16^B24
callbacks
point
normal
v16@?0^{__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}8
CFTypeIsC3DEntity(object)
SCNSourceURLForCurrentlyUnarchivedScene
center
(start & kSOALaneMask) == 0
C3DStack
stack
stack->_currentLevel != 0
stack->_elementSize == sizeof(void*)
<C3DStack>
C3D-Standard.metal
#import "scn_metal"
#import "scn_util.h"
#import "scn_standard_lighting.h"
#import "scn_standard_constants.h"
#import "C3D-PBR.metal"
__ExtraVaryingsDecl__
__ShaderModifiersDecl__
__VertexExtraArguments__
__DoGeometryModifier__
__VertexExtraArgumentsPostTessellation__
__DoGeometryModifierPostTessellation__
__FragmentExtraArguments__
__DoSurfaceModifier__
__DoFragmentModifier__
C3D-Lighting.metal
_originalLightingSourceCode
__SurfaceExtraDecl__
__LightModifierExtraDecl__
__DoLightModifier__
range.rangeValue.length > 0
C3D-CommonProfile.metal
#import "scn_tessellation.h"
__TexcoordDecl__
#import "C3D-Lighting.metal"
__OpenSubdivDeclPerGeometry__
__OpenSubdivDeclPerPatchType__
__OpenSubdivDeclShared__
__VertexDoVertexOnlyTexcoord__
__VertexDoLighting__
__VertexDoTexcoord__
__FragmentDoTexcoord__
__LightModifierCopyDecl__
__FragmentDoLighting__
} commonprofile_io;
typedef struct {
_originalSourceCode
%@ %@;
texture
sampler
, device %@ %@
, constant %@& %@
, %@ %@
, %@<float> %@
_lightingContribution.%@=%@;
%@<float> %@;
modifier
v32@?0@"NSString"8@"NSString"16*24
%@%@%@
C3D-OpenSubdiv-Utils.h
C3D-OpenSubdiv-Utils.metal
scn_metal
scn_util.h
scn_standard_lighting.h
scn_standard_constants.h
C3D-PBR.metal
USE_VERTEX_EXTRA_ARGUMENTS
USE_FRAGMENT_EXTRA_ARGUMENTS
USE_SHADER_MODIFIERS
METAL
////////////////////////////////////////////////
// CommonProfile Shader v%d
USE_POSITION
USE_MULTIPLE_RENDERING
USE_VERTEX_AMPLIFICATION
USE_INSTANCING
USE_LAYERED_RENDERING
USE_MULTIPLE_VIEWPORTS_RENDERING
USE_MODIFIER_FRAMEBUFFER_COLOR0
C3D_SUPPORTS_PROGRAMMABLE_BLENDING
USE_CLIP_DISTANCE3
USE_CLIP_DISTANCE_COUNT
USE_CLIP_DISTANCE1
USE_SPECULAR
USE_VIEW
USE_SHININESS
USE_PBR
USE_SHADOWONLY
C3DLightIndexType
C3D_SUPPORT_CUBE_ARRAY
C3D_USE_REFLECTION_PROBES
SCNLightingModelCustom
LIGHTING_MODEL
USE_CLUSTERED_LIGHTING
C3D_USE_TEXTURE_FOR_LIGHT_INDICES
USE_FOG
USE_SSAO
USE_FRESNEL
AVOID_OVERLIGHTING
USE_AMBIENT_LIGHTING
USE_PROBES_LIGHTING
USE_LIGHTING
USE_PER_PIXEL_LIGHTING
USE_MODULATE
USE_PER_VERTEX_LIGHTING
HAS_NORMAL
HAS_VERTEX_COLOR
USE_VERTEX_COLOR
USE_POINT_RENDERING
DISABLE_LINEAR_RENDERING
DISABLE_SPECULAR
USE_MOTIONBLUR
USE_SKINNING
USE_COLOR1_OUTPUT
USE_NORMALS_OUTPUT
USE_REFLECTANCE_ROUGHNESS_OUTPUT
USE_RADIANCE_OUTPUT
USE_OUTLINE
USE_MODELTRANSFORM
USE_AMBIENT_AS_AMBIENTOCCLUSION
USE_TANGENT
USE_BITANGENT
USE_TRANSPARENT
USE_TRANSPARENCY_RGBZERO
USE_PBR_TRANSPARENCY
USE_PBR_LAMBERTIAN_REFLECTION
LOCK_AMBIENT_WITH_DIFFUSE
USE_DOUBLE_SIDED
USE_TRANSPARENCY
USE_NODE_OPACITY
DIFFUSE_PREMULTIPLIED
    float2 %@Texcoord;
    _surface.%@Texcoord = in.texcoord%d;
USE_DISCARD
USE_MODELVIEWTRANSFORM
USE_MODELVIEWPROJECTIONTRANSFORM
float2 bezierCurveUV [[ sample_perspective ]];
, device void const *scn_bezier_curve_data
, device packed_float3 const *scn_bezier_curve_controlPoints
NEED_IN_TEXCOORD0
IS_BEZIER_CURVE
USE_SURFACE_EXTRA_DECL
USE_EXTRA_VARYINGS
USE_OPENSUBDIV
HAS_OR_GENERATES_NORMAL
USE_TESSELLATION
scn_tessellation.h
TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE
TESSELLATION_SMOOTHING_MODE_PHONG
#import
%@%@
%@%@
#if 1 // SHADER_COLLECTION_PREFERS_MONOLITHIC_FILES
#else // SHADER_COLLECTION_PREFERS_MONOLITHIC_FILES
#endif // SHADER_COLLECTION_PREFERS_MONOLITHIC_FILES
#generate "__OpenSubdivDeclShared__.metal"
#generate "__OpenSubdivDeclShared__patchType%d.metal"
USE_REVERSE_Z
DEBUG_PIXEL
USE_ARGUMENT_BUFFERS
v32@?0@"NSValue"8Q16*24
    float clipDistance [[clip_distance]] [%d];
} commonprofile_io_vert;
vertex commonprofile_io
commonprofile_io out;
commonprofile_io_vert out;
vertex commonprofile_io_vert
commonprofile_io in;
commonprofile_io io
commonprofile_io_vert in;
commonprofile_io_vert io
_import/%@
#import "%@"
#generate
-[SCNCommonProfileProgramGeneratorMetal collectShaderForProgram:hashCode:newVertexFunctionName:newFragmentFunctionName:sourceCodeBlock:additionalFileBlock:]
SCNCommonProfileProgramGeneratorMetal.m
 -D%@
 -D%@=%@
 -U%@
_unifdef/%@.h
USE_GEOMETRY_MODIFIER
USE_SURFACE_MODIFIER
USE_FRAGMENT_MODIFIER
USE_LIGHT_MODIFIER
v16@?0^{__CFString=}8
C3DShaderModifierGetEntryPoint(shaderModifier) == entryPoint
v32@?0@"NSString"8@16*24
scn_node.
USE_
, depthcube<float> u_shadowTexture%d
, depth2d_array<float> u_shadowTexture%d
, depth2d<float> u_shadowTexture%d
, texture2d<half> u_goboTexture%d
, sampler u_goboTexture%dSampler
, texture2d<half> u_iesTexture%d
, device packed_float2* u_areaPolygonPositions%d
USE_MULTIPLE_RENDERING * %d + amplificationID
USE_MULTIPLE_RENDERING * %d + in.sliceIndex
USE_MULTIPLE_RENDERING * %d + out.sliceIndex
_lightingContribution.add_directional(scn_lights[%@], u_goboTexture%d, u_goboTexture%dSampler, %s);
_lightingContribution.add_directional(scn_lights[%@], u_shadowTexture%d, %d, %s, u_shadowKernel, %d, %s);
_lightingContribution.add_directional(scn_lights[%@], u_shadowTexture%d, %d);
_lightingContribution.add_directional(scn_lights[%@], u_shadowTexture%d, u_shadowKernel, %d);
_lightingContribution.add_directional(scn_lights[%@], u_shadowTexture%d);
_lightingContribution.add_directional(scn_lights[%@]);
_lightingContribution.add_omni(scn_lights[%@], u_shadowTexture%d, u_shadowKernel, %d);
_lightingContribution.add_omni(scn_lights[%@]);
_lightingContribution.add_spot(scn_lights[%@], u_shadowTexture%d, u_shadowKernel, %d, u_goboTexture%d, u_goboTexture%dSampler);
_lightingContribution.add_spot(scn_lights[%@], u_goboTexture%d, u_goboTexture%dSampler, %s);
_lightingContribution.add_spot(scn_lights[%@], u_shadowTexture%d, u_shadowKernel, %d);
_lightingContribution.add_spot(scn_lights[%@]);
_lightingContribution.add_ies(scn_lights[%@], u_iesTexture%d, u_shadowTexture%d, u_shadowKernel, %d);
_lightingContribution.add_ies(scn_lights[%@], u_iesTexture%d);
_lightingContribution.add_area_rectangle(scn_lights[%@], u_areaLightBakedDataTexture);
_lightingContribution.add_area_polygon(scn_lights[%@], u_areaLightBakedDataTexture, u_areaPolygonPositions%d);
_lightingContribution.add_area_line(scn_lights[%@], u_areaLightBakedDataTexture);
_lightingContribution.add_area_ellipse(scn_lights[%@], u_areaLightBakedDataTexture);
_lightingContribution.add_area_ellipsoid(scn_lights[%@], u_areaLightBakedDataTexture);
float2 _%@Texcoord = (scn_commonprofile.textureTransforms[%d] * float4(_geometry.texcoords[%d], 0., 1.)).xy;
float2 _%@Texcoord = _geometry.texcoords[%d].xy;
out.texcoord%d = (scn_commonprofile.textureTransforms[%d] * float4(_geometry.texcoords[%d], 0., 1.)).xy;
out.texcoord%d = _geometry.texcoords[%d].xy;
USE_TEXCOORD
TEXTURE_TRANSFORM_COUNT
kSCNTexcoordCount
float2 texcoord0;
float2 texcoord1;
float2 texcoord2;
float2 texcoord3;
float2 texcoord4;
float2 texcoord5;
float2 texcoord6;
float2 texcoord7;
NEED_IN_TEXCOORD1
NEED_IN_TEXCOORD2
NEED_IN_TEXCOORD3
NEED_IN_TEXCOORD4
NEED_IN_TEXCOORD5
NEED_IN_TEXCOORD6
NEED_IN_TEXCOORD7
location
initFromPath
relativePath
runtimePath
vertexCount
componentsPerValue
componentsType
valuesCount
data
kGeometrySourceSemanticVertex
kGeometrySourceSemanticNormal
kGeometrySourceSemanticColor
kGeometrySourceSemanticTexcoord
stride
offset
padding
sourceID
sourceTypeID
vertex
position
texcoord
textangent
joints
weights
commonProfile
geometryID
materialsID
facesCount
kAnimationsKey
kBindingsKey
kActionsKey
kLightKey
kDeformerStackKey
kCameraKey
kSplineKey
kConstraints
kParticleSystem
kLightmapInfoKey
kRenderingPriorityKey
kShaderModifiers
kShadableMinimumMTLLanguageVersionKey
kPivotKey
libraryStorage
kMeshKey
rendererDelegate
kFilterKey
geometryElement
geometryElements
geometrySource
genericSource
effect
image
keyframedAnimations
animation
camera
skin
morph
linear
easeIn
easeOut
easeInEaseOut
function
avoidsOverlighting
double sided
cullMode
cullBack
cullFront
constant
lambert
phong
blinn
physicallyBased
shadowOnly
filter
ambientOcclusion
metalness
roughness
emissionColor
ambientColor
diffuseColor
specularColor
reflectiveColor
transparentColor
normalColor
filterColor
emissionImageID
ambientImageID
diffuseImageID
specularImageID
reflectiveImageID
transparentImageID
filterImageID
normalImageID
shininessImageID
emissionTextureSampler
ambientTextureSampler
diffuseTextureSampler
specularTextureSampler
reflectiveTextureSampler
transparentTextureSampler
filterTextureSampler
normalTextureSampler
shininessTextureSampler
emissionUVSet
ambientUVSet
diffuseUVSet
specularUVSet
reflectiveUVSet
transparentUVSet
normalUVSet
filterUVSet
shininessUVSet
ambientOcclusionUVSet
selfIlluminationUVSet
shininess
reflectivity
transparency
indexOfRefraction
fresnelExponent
transparencyMode
A_ONE
RGB_ZERO
minFilter
magFilter
mipFilter
wrapS
wrapT
wrapP
anisotropy
SCNKitErrorDomain
frustumCulling
defaultLight
defaultCamera
probeRendering
debugRendering
rootNode
mirrorNode
kHitTestFirstFoundOnly
kHitTestSearchMode
kHitTestSortResults
kHitTestClipToZRange
kHitTestSkipTransparentNode
kHitTestSkipHiddenNode
kHitTestCategoryBitMask
kHitTestBackFaceCulling
kHitTestBoundingBoxOnly
kHitTestIgnoreChildNodes
kHitTestRootNode
kHitTestAllLayers
kHitTestLayerMask
kHitTestShowDebugInfo
kHitTestResultIgnoreLightArea
kC3DNotificationMeshSourceWillDie
kC3DNotificationMeshElementWillDie
kC3DNotificationImageWillDie
kC3DNotificationImageProxyWillDie
kC3DNotificationProgramWillDie
kC3DNotificationGeometryWillDie
kC3DNotificationMorphWillDie
kC3DNotificationSkinWillDie
kC3DNotificationDeformerStackWillDie
kC3DNotificationDeformerStackDidChange
kC3DNotificationMaterialWillDie
kC3DNotificationMeshWillDie
kC3DNotificationNodeWillDie
kC3DNotificationPassWillDie
kC3DNotificationRasterizerStatesDidDie
kC3DNotificationEngineContextInvalidatePasses
kC3DNotificationEngineContextPassesDidUpdate
kC3DNotificationProfileWillDie
kC3DNotificationEntityAttributeDidChange
kC3DNotificationRendererElementWillDie
kC3DNotificationProgramHashCodeWillDie
kC3DNotificationPrecomputedLightingEnvironmentWillDie
kC3DSceneDidUpdateNotification
opacity
hidden
attributes
matrix
translation
rotation
orientation
scale
eulerAngles
quaternion
pivot
filters
focalDistance
dofIntensity
focalSize
aperture
apertureBladeCount
xFov
yFov
orthographicScale
zFar
projectionTransform
zNear
firstMaterial
selfIlluminationOcclusion
litPerPixel
lockAmbientWithDiffuse
contents
contentsTransform
borderColor
intensity
shadowColor
shadowRadius
gobo
probeEnvironment
attenuationStart
attenuationEnd
attenuationFalloffExponent
spotInnerAngle
spotOuterAngle
spotFalloffExponent
morpher
shaderModifiers
background
environment
customProperty
animations
a_position
a_normal
a_tangent
a_color
a_skinningJoints
a_skinningWeights
a_texCoord0
a_texCoord1
a_texCoord2
a_texCoord3
a_texCoord4
a_texCoord5
a_texCoord6
a_texCoord7
vertexCrease
edgeCrease
meshSource
componentCount <= 4
bse.ptr
tgt.ptr
dlt.ptr
baseSource
intervalList
ind.type == kC3DMeshElementTypeLinesArray
%4d : %3d %3d %3d %3d
%4d : %+.2f %+.2f
%4d : %+.2f %+.2f %+.2f
%4d : %+.2f %+.2f %+.2f %+.2f
type debugging not implemented
C3DMeshSource
<C3DMeshSource %p(%@) data:(%p) mut:%d count:%ld type:%@ divisor:%d mtl:%d offset:%d stride:%d
_C3DMeshSourceInitWithPropertyList
mkSemantic
accessor
C3DFramebufferRegistry
registry
v16@?0^{__C3DRenderTarget={__CFRuntimeBase=QAQ}{?=CCCb1b1b1b1b1b1[4C]}^{__C3DTexture}Iq^vQIII}8
registry->_currentFramebuffer
renderTarget
targetName
retainCount > 0
<C3DFramebufferRegistry>
(null)
nameIndex!=0
manager
animationNode
target
CFGetTypeID(animationNode) != C3DAnimationClusterNodeGetTypeID()
manager->_mute == false
animationManager
manager->_constantStackCount >= 0
stackCount >= animationManager->_constantStackCount
root
rootObject
storage
v32@?0@8Q16*24
SCNBindingValueTransformerKey
c32@?0@8Q16*24
C3DAnimationManager
<C3DAnimationManager %p>
CFDictionaryContainsKey(manager->_targetAddressToStackIndex, (void*)key) == false
animationNode->_target->_semantic != kC3DTypeSemanticNone
modelValueStorage
CFDictionaryContainsKey(manager->_targetAddressToStackIndex, (void*)key) == true
removedIndex
lastIndex
stackItem->_modelValueItem
manager->_applying == false
manager->_applying==false
middle >= 0
controller
controller->_values
controller->_evaluate
controller->_keyCount > 0
C3DKeyframeController
<C3DKeyframeController %p>
keyframeVersion
keyframeType
keyCount == (int)(length/keyStride)
keyframes
keytimes
keytimes-data
values
values-data
timingFunctions
timingFunctions-data
interpolationModes
interpolationModes-data
tensionValues
tensionValues-data
continuityValues
continuityValues-data
biasValues
biasValues-data
inTangents
inTangents-data
outTangents
outTangents-data
count
interpolationMode
calculationMode
CFGetTypeID(value) == CFNumberGetTypeID()
CFGetTypeID(value) == CFBooleanGetTypeID()
0.12
C3D-wireframe
ManipulatorWireframe_vert
ManipulatorWireframe_frag
glInfo->mesh != NULL
authoringEnvironment->_timedRecordingExpirationTime == 0
start != end
C3DMeshElementGetIndicesChannelCount(creaseElement) == 1
C3DAuthoringEnvironmentDrawStats
SCNAuthoringEnvironment.m
rendererContext
SceneKit - Draw Statistics
v32@?0^q8^{CGSize=dd}16^^{?}24
v24@?0{CGSize=dd}8
Animations
Physics
Constraints
Particles
Delegate
Rendering
GL flush
--- ms
%2.1f s
%2.1f ms
BGRA8Unorm_sRGB
BGRA8Unorm
RGBA16Float
RGBA32Float
unknown
$4$ %@  $5$ %@
%dfps
GL %dfps
AuthEnvDraw
u_modelViewProjectionTransform
u_sampler
glInfo->baseVertex == 0
glInfo->baseIndex == 0
C3DManipulatorColorAndTexture
C3DManipulatorColorOnly
C3DManipulatorLightProbe
ManipulatorColorAndTexture_vert
ManipulatorColorAndTexture_frag
ManipulatorColorOnly_vert
ManipulatorColorOnly_frag
ManipulatorLightProbe_vert
ManipulatorLightProbe_frag
glInfo->weakProgram != nil
glInfo->textureImage != nil
glInfo->textureImage == nil
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
Menlo
%2.1fms
Menlo-Bold
%.3gK
%.3gM
%.3gG
_C3DTimingFunctionInitWithPropertyList
timingFunc
C3DTimingFunction
<C3DTimingFunction>
animationStack->_valid == false
animationStack
animationStack->_valid == true
CFGetTypeID(animationNode) == C3DAnimationClusterNodeGetTypeID()
animationCluster->_keyframes->_valueSize[index] == C3DSizeOfBaseType(target->_baseType)
com.apple.scenekit.resourceCPUQueue
FrameConstant
Volatile
background_2D_vertid
background_2D_frag
background_cube_vertid
background_cube_frag
background_video_vertid
background_video_frag
background_2D_multiple_viewports_vertid
background_2D_multiple_viewports_frag
background_cube_multiple_viewports_vertid
background_cube_multiple_viewports_frag
background_2D_layered_vertid
background_2D_layered_frag
background_cube_layered_vertid
background_cube_layered_frag
Clear binding points
v16@?0@"<MTLDrawable>"8
SCNDefaultRadiance.ktx
SCNDefaultIrradiance.ktx
ResourceComputeEncoder
v16@?0@"<MTLBuffer>"8
LightingSet: uploaded count: %d
  LightingSet: uploaded size %d bytes
setMask
element.indexType == MTLIndexTypeUInt32 || element.indexType == MTLIndexTypeUInt16
element.primitiveType == MTLPrimitiveTypeTriangle
SceneKit - Draw scene background
currentPassInstance
SceneKit - Draw video background
!C3DMeshIsVolatile(mesh) || (renderMesh.volatileBuffer != nil)
!programHashCode || C3DProgramHashCodeUseDynamicBatching(programHashCode)
_processingContext.passInstance
engineIterationContext->engineContext == _engineContext
v24@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}8^{__C3DLightRuntimeData=If[4{?=[4]}]^v^{__C3DTextureSampler}^v^{__C3DTextureSampler}}16
dynamicBatchCount < 2
meshElement == NULL
C3DGeometryGetMeshElementCountForDeformerBasedDynamicMesh(geometry) == 1
_cache.metalMeshElement
No registered texture for binding %@ and symbol "%@" in pass or render graph.
Pass: %s (%p)
Render graph: %p
No texture or image provided for binding %@ by sampler %@.
Texture: %@
Image: %@
No sampler found for binding %@ and input %@
No pass storage for binding %@
v24@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}8*16
resourceBinding.bindBlock
_engineContext
SceneKit - Draw wireframe
modelTransform
v36@?0^v8I16@"SCNMTLRenderContext"20I28I32
inverseModelTransform
modelViewTransform
lightIndices
size == C3D_MAX_LIGHTS
inverseModelViewTransform
normalTransform
modelViewProjectionTransform
lastFrameModelTransform
motionBlurIntensity
inverseModelViewProjectionTransform
boundingBox
worldBoundingBox
nodeOpacity
shCoefficients
size == sizeof(coefs)
v24@?0@"SCNMTLResourceBinding"8@"SCNMTLRenderContext"16
Unable to find texture for binding %@ and shadable %@
scn_lights
scn_lights_count
scn_shCoefficients
3 == C3DLightProbesSystemGetSphericalHarmonicsOrder(probesSystem)
scn_commonprofile
scn_pointSize
u_clusterTexture
u_lightIndicesBuffer
u_areaLightBakedDataTexture
u_shadowKernel
v28@?0c8@"SCNMTLResourceBinding"12@"SCNMTLRenderContext"20
Unable to find texture for binding %@ and effect slot %@
u_reflectiveCubeTexture
u_shadowTexture%d
Unable to find IES or gobo texture for binding %@
u_goboTexture%d
u_iesTexture%d
u_iesCubeTexture%d
color%d
position%d
direction%d
right%d
up%d
iesMatrix%d
attenuation%d
spotAttenuation%d
shadowMatrix%d
size <= (sizeof(simd_float4x4) * C3D_MAX_CASCADE_COUNT)
shadowRadius%d
shadowColor%d
goboMatrix%d
projectorColor%d
u_areaPolygonPositions%d
buffer
u_specularDFGDiffuseHammonTexture
u_radianceTexture
u_irradianceTexture
u_reflectionProbeTexture
u_ssaoTexture
SSAO-Final
Unable to find "SSAO-Final" texture in render graph for binding %@
deformers
v32@?0@"SCNBufferBinding"8@"MTLArgument"16@"SCNMTLShaderBindingsGenerator"24
metalMesh.volatileStride != 0
sub.buffer != nil
mtlBuffer != nil
metalMeshElement.indexBuffer == nil
quad_vertex
quad_display_cube_equirectangular
quad_display_texture2D
quad_display_depth2D
quad_display_depth_cube
scn_draw_fullscreen_fragment_sk
scn_draw_fullscreen_gamma_fragment
SpriteKit - NonLinear Encoding
rendererElement
C3DRendererElementIsHidden(rendererElement) != true
theNode==NULL || C3DNodeGetOpacity(theNode) > 0 || (rendererElement->_renderableAttributeKind == kC3DRenderableAttributeKindParticleSystem)
commandBuffer
commandEncoder
HDRAverageLuminancePass
FrameLuminance
fixed_lum
sliding_lum
adaptative_lum
SceneKit-spotShadowDepth-%p
SceneKit-spotShadowDepth
^{__CFString=}16@?0^{__CFString=}8
C3DFXDeferredShadowPass.json
C3DFXForwardShadowPass.json
SceneKit_renderSceneFromLight
SceneKit_applyDeferredShadows
--ShadowMaterial--
lightDepthSampler
cascadeCount
cascadeBlending
debugCascades
isSpotLight
reverseZ
deferredShadow_vert
deferredShadowCascades_frag
deferredShadow_frag
C3D-spotShadow
#define MAX_SAMPLE %d
#define unshareIndex %d
#define SPOT_SHADOW 1
#define USE_PCF 1
C3D-u_lightPos-symbol
C3D-u_lightDir-symbol
C3D-u_lightSpotAtt-symbol
C3D-light_MVP-symbol
C3D-cascadeScale-symbol
C3D-cascadeBias-symbol
C3D-shadowCascadeDebugFactor-symbol
C3D-camera_MVP_i-symbol
C3D-shadowRadius-symbol
C3D-shadowColor-symbol
C3D-shadowKernel-symbol
anim
outputAddress
C3DKeyframedAnimation
<C3DKeyframedAnimation %p>
keyframeController
keyframedAnimation
_allocate
C3DHash.hpp
(new_size & (new_size - 1)) == 0
child
node->_cumulativeCache
animationGroup
animationCluster
C3DAnimationNode
node->_completionItem == NULL
<C3DAnimationNode %p>
C3DAnimationClusterNode
<C3DAnimationClusterNode %p>
SSRRaytracePass
ColorDownSampled
Normals
DepthDownSampled
lobeFootprint
SSRReverseZ
SSRDownSample
SSREnableFog
scn_ssr_raytrace_vert
scn_ssr_raytrace_frag
DownsamplePass
scn_supersampling_vertex
scn_supersampling_fragment
BloomUpSamplePass
scn_bloom_upsample
script
JSContext
elapsedTime
Position
Angle
RotationAxis
Velocity
AngularVelocity
Life
Color
Opacity
Size
Frame
FrameRate
Bounce
Friction
Charge
ContactPoint
ContactNormal
-[SCNParticleSystem setName:]
CFTypeIsC3DEntity(cfObject)
animations.%@.speed
scnp
failed to unarchive particle data at %@ (%@)
-[SCNParticleSystem setParticleGeometries:]
-[SCNParticleSystem setColliderNodes:]
-[SCNParticleSystem setPropertyControllers:]
-[SCNParticleSystem setParticleImage:]
-[SCNParticleSystem _setParticleImagePath:withResolvedPath:]
-[SCNParticleSystem setOrientationDirection:]
orientationDirection
-[SCNParticleSystem setLightEmissionRadiusFactor:]
fixedTimeStep
-[SCNParticleSystem setAffectedByGravity:]
affectedByGravity
-[SCNParticleSystem setAffectedByPhysicsFields:]
-[SCNParticleSystem setBirthDirection:]
-[SCNParticleSystem setBirthLocation:]
-[SCNParticleSystem setBirthRate:]
birthRate
-[SCNParticleSystem setBirthRateVariation:]
birthRateVariation
-[SCNParticleSystem setBlackPassEnabled:]
-[SCNParticleSystem setBlendMode:]
-[SCNParticleSystem setDampingFactor:]
dampingFactor
-[SCNParticleSystem setEmissionDuration:]
emissionDuration
-[SCNParticleSystem setEmissionDurationVariation:]
emissionDurationVariation
-[SCNParticleSystem setEmitterShape:]
-[SCNParticleSystem setFixedTimeStep:]
-[SCNParticleSystem setFresnelExponent:]
-[SCNParticleSystem setIdleDuration:]
idleDuration
-[SCNParticleSystem setIdleDurationVariation:]
idleDurationVariation
-[SCNParticleSystem setImageSequenceAnimationMode:]
-[SCNParticleSystem setImageSequenceColumnCount:]
imageSequenceColumnCount
-[SCNParticleSystem setImageSequenceFrameRate:]
imageSequenceFrameRate
-[SCNParticleSystem setImageSequenceFrameRateVariation:]
imageSequenceFrameRateVariation
-[SCNParticleSystem setImageSequenceInitialFrame:]
imageSequenceInitialFrame
-[SCNParticleSystem setImageSequenceInitialFrameVariation:]
imageSequenceInitialFrameVariation
-[SCNParticleSystem setImageSequenceRowCount:]
imageSequenceRowCount
-[SCNParticleSystem setIsLocal:]
isLocal
-[SCNParticleSystem setLightingEnabled:]
-[SCNParticleSystem setLoops:]
loops
-[SCNParticleSystem setOrientationMode:]
-[SCNParticleSystem setParticleAngle:]
particleAngle
-[SCNParticleSystem setParticleAngleVariation:]
particleAngleVariation
-[SCNParticleSystem setParticleAngularVelocity:]
particleAngularVelocity
-[SCNParticleSystem setParticleAngularVelocityVariation:]
particleAngularVelocityVariation
-[SCNParticleSystem setParticleBounce:]
particleBounce
-[SCNParticleSystem setParticleBounceVariation:]
particleBounceVariation
-[SCNParticleSystem setParticleCharge:]
particleCharge
-[SCNParticleSystem setParticleChargeVariation:]
particleChargeVariation
-[SCNParticleSystem setParticleColor:]
particleColor
-[SCNParticleSystem setParticleDiesOnCollision:]
-[SCNParticleSystem setParticleFriction:]
particleFriction
-[SCNParticleSystem setParticleFrictionVariation:]
particleFrictionVariation
-[SCNParticleSystem setParticleLifeSpan:]
particleLifeSpan
-[SCNParticleSystem setParticleLifeSpanVariation:]
particleLifeSpanVariation
-[SCNParticleSystem setParticleMass:]
particleMass
-[SCNParticleSystem setParticleMassVariation:]
particleMassVariation
-[SCNParticleSystem setParticleSize:]
particleSize
-[SCNParticleSystem setParticleSizeVariation:]
particleSizeVariation
-[SCNParticleSystem setParticleVelocity:]
particleVelocity
-[SCNParticleSystem setParticleVelocityVariation:]
particleVelocityVariation
-[SCNParticleSystem setPhysicsCollisionsEnabled:]
-[SCNParticleSystem setRenderingMode:]
-[SCNParticleSystem setSeed:]
-[SCNParticleSystem setSoftParticlesEnabled:]
-[SCNParticleSystem setSortingMode:]
-[SCNParticleSystem setSpeedFactor:]
speedFactor
-[SCNParticleSystem setSpreadingAngle:]
spreadingAngle
-[SCNParticleSystem setStretchFactor:]
stretchFactor
-[SCNParticleSystem setSystemSpawnedOnCollision:]
-[SCNParticleSystem setSystemSpawnedOnDying:]
-[SCNParticleSystem setSystemSpawnedOnLiving:]
-[SCNParticleSystem setWarmupDuration:]
warmupDuration
-[SCNParticleSystem setWritesToDepthBuffer:]
-[SCNParticleSystem setParticleIntensity:]
particleIntensity
-[SCNParticleSystem setParticleIntensityVariation:]
particleIntensityVariation
-[SCNParticleSystem setParticleColorVariation:]
particleColorVariation
-[SCNParticleSystem setEmittingDirection:]
emittingDirection
-[SCNParticleSystem setAcceleration:]
acceleration
particleImage
referenceName
emitterShape
birthLocation
birthDirection
affectedByPhysicsFields
physicsCollisionsEnabled
lightingEnabled
softParticlesEnabled
particleDiesOnCollision
blackPassEnabled
writesToDepthBuffer
systemSpawnedOnCollision
systemSpawnedOnDying
systemSpawnedOnLiving
seed
blendMode
renderingMode
orientationMode
imageSequenceAnimationMode
particleGeometries
colliderNodes
propertyControllers
sortingMode
image->_sourceType == kC3DImageSourceTypeCatalogTexture
size
MDLMemoryMappedData
missingMaterialImage
image->_bitmapContext==NULL
isAttachment
image->_textureRawData == NULL
C3DImage
<C3DImage %p src:%@ [%fx%f]>
<C3DImage %p src:%p [%fx%f]>
_C3DImageInitWithPropertyList
imageData
imageRelativePath
distantImageURL
file
cgImage
clientImage
bitmap
hasAlpha
SCNRendererOptions
SCNKitError : can't load nib named : SCNRendererOptions
~/%@-snapshot-%d.scn
archiving to %@
c24@?0@"SCNNode"8*16
index < (NSInteger)[cameras count]
untitled
None
%.1f fps
usda
usdc
tiff
v24@?0@"SCNNode"8*16
Scene
[Root node]
<No name>
minificationFilter
magnificationFilter
%f %f %f %f
maxAnisotropy
textureSampler
C3DTextureSampler
<C3DTextureSampler>
_C3DTextureSamplerInitWithPropertyList
nearest
clamp
repeat
clampToBorder
collisionBitMask
results
backfaceCulling
closest
v24@?0@"SCNPhysicsBody"8*16
ccdPenetration
C3DNodeIsHidden(nodeRef) == false
behaviors
gravity
speed
timeStep
_implementDidUpdateContact
_implementDidEndContact
v16@?0r^v8
engineContext
Resource Manager Flush
Environment cube
C3D-EnvMap2D
textureSampler0
u_textureMatrix
C3D-EnvMapCube
u_mvp
u_zfar
C3DEngineContext
context
glContext
context->_pointOfView
Quad
index < C3DRenderingEyeMaxCount
eye < C3DRenderingEyeMaxCount
viewport.z > 0 && viewport.w > 0
engineContext->_viewport[0].z > 0 && engineContext->_viewport[0].w > 0
<C3DEngineContext>
C3DConvexPolyhedron
<C3DConvexPolyhedron %p>
dst.count == src.count
srcType < kC3DBaseTypeCount
i48@?0^{__CVDisplayLink=}8r^{?=IiqQdq{CVSMPTETime=ssIIIssss}QQ}16r^{?=IiqQdq{CVSMPTETime=ssIIIssss}QQ}24Q32^Q40
C3DBezierCurve
v16@?0r^{CGPathElement=i^{CGPoint}}8
v24@?0^S8^16
<C3DBezierCurve:%p (curve segments: %d linear, %d quadratic, %d cubic)>
C3DBezierCurveGeometry
Format: %@ ; Size: %gx%g[%d] ; Texture: <%p> ; [rc:%ld/ts:%ld]
Name: %@ ; %@
-[SCNRenderTarget textureForSliceIndex:]
SCNRenderTarget.m
_sliceTextures != nil
C3DSpanAllocator
span.count > 0
(freeSpan->start.index + freeSpan->count) <= page->capacity
page->freeCapacity
spanSize <= page->freeMaxSpan
span.start.index + span.count <= page->capacity
page->pageIndex == span.start.page
handle.page < allocator->_pageCount
(page->pageIndex == handle.page) && (handle.index < page->capacity)
<C3DSpanAllocator %p>
DrawQuadPass
pointOfCulling.scene
<%@: %p | scene=%@ sceneTime=%f frame=%@ pointOfView=%@>
cgl_ctx
sceneTime
playing
autoenablesDefaultLighting
jitteringEnabled
technique
renderer.%@
C3DRendererElementState
rendererElementState
C3DRendererElementStateBeginProcessing
C3DRendererElementState.c
C3DRendererElementStateEndProcessing
__UpdateMatrixUniforms
CFArrayGetCount(shaderModifiers)
C3DRendererElementStateDrawRendererElement
passInstance
C3DRendererElementStateProcessRendererElement
C3DEngineContextGetRendererContextGL(engineContext)
theNode==NULL || C3DNodeGetOpacity(theNode) > 0 || rendererElement->_renderableAttributeKind == kC3DRenderableAttributeKindParticleSystem
<C3DRendererElementState>
v24@?0^{__CFString=}8^v16
uv_set
programObject
C3DCreateProgram
C3DGLUtils.m
_create_compile_and_attach_shader
renderer
_create_and_compile_shader
%3ld | %@
#version 150
#define attribute in
#define varying out
#define texture2D texture
#version 150
#define varying in
#define gl_FragColor FragColor
#define texture2D texture
out vec4 FragColor;
#version 120
^(\w+):\s[0-9]+:([0-9]+):\s(.+)$
error
frame.scn_record
v16@?0^{__CFDictionary=}8
v16@?0q8
C3DRendererContext
C3DRendererContextSetupCommonPipeline
C3DRendererContextGL.c
C3DRendererContextClear
C3DRendererContextIsEnabled
C3DRendererContextSetEnable
C3DRendererContextResetToDefaultStates
Reset all states
C3DRendererContextSetMatrix4x4UniformAtLocation
C3DRendererContextSetColor4UniformAtLocation
C3DRendererContextSetVector4UniformAtLocation
C3DRendererContextSetVector3UniformAtLocation
C3DRendererContextSetVector2UniformAtLocation
C3DRendererContextSetIntUniformAtLocation
C3DRendererContextSetInt2UniformAtLocation
C3DRendererContextSetInt3UniformAtLocation
C3DRendererContextSetInt4UniformAtLocation
C3DRendererContextSetFloatUniformAtLocation
C3DRendererContextBindProgramObject
C3DRendererContextUnbindProgramObject
effectSlot
C3DRendererContextSetupResidentMeshSourceAtLocation
%02x
program
C3DRendererContextCreateProgramObjectForProgram
C3DRendererContextDeleteProgramObject
bufferObject
C3DRendererContextApplyTextureSampler
_C3DRendererContextComputeInternalSize
_C3DRendererContextComputeRenderBufferInternalSize
C3DRendererContextBindTexture
C3DRendererContextDeleteTexture
C3DRendererContextCreateTextureWithImage
idTexture != 0
C3DCreateTextureFromIOSurface
C3DRendererContextCreateRenderTargetWithDescription
description.sampleCount == C3DFramebufferGetSampleCount(fbo)
C3DRendererContextSetupFramebuffer
_C3DRendererContextBindFramebuffer
C3DRendererContextUnbindFramebuffer
currentFBO->_inUse==true
C3DRendererContextResolveFramebuffer
_C3DRendererContextDeleteRenderBuffer
C3DRendererContextDeleteFramebuffer
C3DRendererContextGetViewport
C3DRendererContextSetViewport
C3DRendererContextSetViewportForExternal2D
C3DRendererContextSetLight
rendererContext->_bindedProgram
lightIndex < C3D_MAX_LIGHTS
*currentTextureUnit <= 7
C3DRendererContextBindCommonProfile
C3DRendererContextUnbindCommonProfile
C3DRendererContextSetFrontFace
C3DRendererContextGetFrontFace
C3DRendererContextSetEnableWriteToDepth
C3DRendererContextSetEnableReadsFromDepth
C3DRendererContextAllocateBufferObject
C3DRendererContextCreateBufferObjectForMeshSource
C3DRendererContextCreateBufferObjectForMeshElement
C3DRendererContextUnbindTexture
C3DRendererContextUnbindTextureUnits
rendererContext->_meshElementsVBOs != NULL
_C3DRendererContextBindTextureGL
_C3DRendererContextUnbindTextureGL
__ReserveAndBindVolatileVBO
C3DRendererContextMapVolatileMesh
C3DRendererContextUnmapVolatileMesh
indicesCount != 0
C3DRendererContextMapVolatileMeshElement
C3DRendererContextUnmapVolatileMeshElement
C3DMeshElementIsVolatile(meshElement)
C3DRendererContextResetVolatileObjects
C3DRendererContextPushGroupMarker
C3DRendererContextPopGroupMarker
<C3DRendererContext>
__FillProgramObjectLocations
nextFreeIndex < bufferCount
_C3DRendererContextCreateTextureWithSize
v24@?0C8^{__CFArray=}12I20
v20@?0I8r*12
C3DRenderContextAttachRenderTargetToFramebuffer
__drawCall
__SetupCommonProfileEffectProperty
C3DRendererContextDeleteVertexArrayObject
C3DBufferObject
<C3DBufferObject vbo:%ld addr:%p lockCount:%d target:%d retainCount:%d>
DOFBlurCoCYPass
DOFCoCBlurred
dof_coc_blurH
!newIndex && !oldIndex
customEnvResource
probeIndex != (uint32_t)kProbeSliceIndexInvalid
i < size()
spec_level.float
FCOLLADA
double_sided
entity
vertex4
kNodeToSIDKey
kMorphingImportKey
kSkinningImportKey
kSkinningUsedGeometriesKey
No data or file to load from
/dev/null
An error occurred while parsing the COLLADA file. Please check that it has not been corrupted.
Failed to retrieve scene from XPC service.
start
nodeToTransformArray
TEXCOORD
materialsSemantic
domUVSetToSource
visibility
renderingOrder
! skeletonURI.isExternalReference()
lookedUp
jointNames
jointNamesAreIDs
SCNDetailedErrorsKey
SCNConsistencyElementTypeErrorKey
SCNConsistencyElementIDErrorKey
This <%s> does not have a <%s> descendant
This <%s> does not have a <%s> attribute
Unable to resolve the URI %s
Unable to find an element with the ID "%s"
(type=
, no ID found)
, no ID found, closest ancestor with ID = 
, ID=
The number of elements in the <%s> tag (%lld) should be %lld.
Offset too large
VERTEX
The %dth <p> element has less than %d vertices
The number of vertices in the %dth <p> element should be a multiple of %d
vertices
POSITION
binding not found for material symbol
vcount
OpenCL
computed_float_array
The stride of this source should at least be %llu
The number of items in this source is %llu but should at least be %llu.
Found %d elements with the same ID "%s"
UseIOStrictMode
source_data
layer
init_from
xs:ID
xs:NCName
library_images
library_effects
library_materials
technique_common
text
extra
library_physics_models
library_physics_scenes
instance_physics_scene
annotate
'sid'
is not a valid value of the atomic type 'xs:NCName'
'url'
is not a valid value of the atomic type 'xs:anyURI'
visual_scene
'id'
'name'
subject
asset
canvas_aspect
SCNConsistencyLineNumberErrorKey
JOINT
INV_BIND_MATRIX
There must be one inverse bind matrix per joint
Cannot find a node with the SID "%s"
A skin must have either a name array or an IDREF array to store its joints.
Circular reference between nodes detected
Invalid node array
Invalid instance node array
create
conditionerBase.cpp
SkinInfo
deindexer_core.cpp
vindex == vnumber
matrix4x4
constant_ambient
constant_diffuse
bump.texture
shininess.texture
shader.use_self_illum_color
ambient_diffuse_lock
extendedLightingModel
invertCulling
avoidsOverLighting
readsFromDepthBuffer
fresnelExponent.float
intensities
The meshes in the document appear to be corrupted.
The document does not have a scene. Please check that it has not been corrupted.
%.1f %.1f %.1f
%FT%T%z
SketchUp
Blender
start_time
end_time
MAX3D
frame_rate
clVertexProgram
vertex_program
%s-%d
animation-%d
INPUT
OUTPUT
IN_TANGENT
OUT_TANGENT
INTERPOLATION
inTangent
outTangent
interpolation
parentGroup
grandParentGroup
ANGLE
ambient.color
diffuse.color
specular.color
emission.color
transparent.color
reflective.color
focal_depth
ALPHA
DOUBLE_SIDED
(0)(0)
(0)(1)
(0)(2)
(1)(0)
(1)(1)
(1)(2)
(2)(0)
(2)(1)
(2)(2)
(3)(0)
(3)(1)
(3)(2)
sample_radius
hotspot_beam
falloff
LINEAR
STEP
BEZIER
unnamed animation #%d
shadow_attributes.type
use_far_attenuation
far_attenuation_end
attenuation_far_end
far_attenuation_start
attenuation_far_start
near_attenuation_start
attenuation_near_start
shadow
enable
spotParameters
outerAngle
falloffExponent
innerAngle
constant_ambient.texture
constant_diffuse.texture
multiply.texture
HANNEL
CHANNEL1
ANNEL
CHANNEL2
NNEL
CHANNEL3
CHANNEL4
CHANNEL5
CHANNEL6
CHANNEL
CHANNEL0
kSceneSourcePreserveOriginalTopology
COLLADA_MeshSource
COLLADA_MeshElement
c3dlibrary
user_properties
lightmap_path
The count element of domVertexWeights does not match the vertex count. Please ensure the document has been checked for consistency
C3DSkinGetJointsCount(skin) == 1
nodes
COLLADASchema
http://www.w3.org/2001/03/xml.xsd
rewriteURI
geometry processing
deindexer
polygons2triangles
No input with the semantic "%s" found
The "count" attribute of the <%s> tag (%llu) should be %llu.
The URI %s should point to a <%s> but points to a <%s>
applyDeindexing
newsource
FloatSourcePair
elementSize == sizeof(double)
commonprofile_frag
commonprofile_vert
standard_frag
standard_vert
standard_post_tessellation_vert
hashcode
trackedResource
USE_%@
USE_%@_COLOR
USE_%@_INTENSITY
USE_%@_TEXTURE_COMPONENT
USE_%@TEXCOORD
USE_%@_CUBEMAP
CFEqual(name, kC3DNotificationProfileWillDie)
SceneKit-CI-nodetree-color-
SceneKit-CI-effect-color-
SceneKit_renderCINodeTree-
SceneKit-CI-nodetree-depth
SceneKit_ApplyCIFilter
SceneKit_renderCIQuad
C3D-CIFilter_middleZ
C3D-CIFilter_extent
SceneKit-CI-nodetree-color
SceneKit-CI-effect-color
SceneKit_renderCINodeTree
C3DFXCIFilterPassMetal.json
C3DFXCIFilterPass.json
NSNumber
CICrop
inputRectangle
C3DTextureGetTargetMode(texture) == GL_TEXTURE_RECTANGLE_EXT
C3D-CIFilter_modelMatrix
I16@?0^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}8
v12@?0I8
C3DGeometryInitSubdivTopologyInfoIfNeeded
C3DGeometryOpenSubdivSupportInternal.cpp
(int32_t)vertexCountPerFaceCurrentIndex == topologyInfo->topologyDescriptor.numFaces
vertIndicesPerFaceCurrentIndex == topologyInfo->totalIndexCount
topologyInfo
C3DMeshElementGetIndicesChannelCount(creasesElement) == 1
currentIndex == topologyInfo->totalIndexCount
overallVertexIndex == topologyInfo->totalIndexCount
subdividedElementIndexForFace < subdividedElementCount
C3DSubdivCreateMesh
faceVertexIndices.size() == 4
indexBufferIndex == indexBufferIndexCount
C3DSubdivSourceSemanticCanBePrimvar(semantic, inputSet, isCPUSubdiv)
level <= _finalLevel
Interpolate
primvarRefiner.h
level>0 && level<=(int)_refiner._refinements.size()
interpFromEdges
refinement.getNumChildVerticesFromFaces() > 0
Vtr::IndexIsValid(cVertOfFace)
interpFromVerts
vMask.AreFaceWeightsForFaceCenters()
assignSmoothMaskForVertex
catmarkScheme.h
vertex.GetNumFaces() == vertex.GetNumEdges()
CombineVertexVertexMasks
scheme.h
this->AreFaceWeightsForFaceCenters() == dst.AreFaceWeightsForFaceCenters()
InterpolateVarying
InterpolateFaceVarying
interpFVarFromEdges
eFaceIndex == i
interpFVarFromVerts
pSibling == cSibling
srcContent.componentCount <= 4
_interpolationMode == kC3DSubdivPrimvarDataInterpolationModeInterpolateVertex
subdividedDataCount == refiner.GetLevel(refiner.GetMaxLevel()).GetNumVertices()
CreateMeshSources
faceVertexCount == 4
Failure in PrimvarRefiner::Limit() -- last level of refinement does not include full topology.
limit
tan1Mask.GetNumFaceWeights() == tan2Mask.GetNumFaceWeights()
tan1Mask.GetNumEdgeWeights() == tan2Mask.GetNumEdgeWeights()
assignSmoothLimitMask
loopScheme.h
valence != 2
C3DFramebuffer
framebuffer
renderTarget->_fboRetainCount > 0
description
description->depthDescription.renderToTexture == false
description->colorsDescription[i].renderToTexture == false
rgba
rgba8
rgba8unorm
rgba8snorm
rgba8s
rgba8uint
rgba8ui
rgba8sint
rgba8i
rgba16
rgba16unorm
rgba16snorm
rgba16s
rgba16uint
rgba16ui
rgba16sint
rgba16i
rgba16float
rgba16f
rgba32
rgba32uint
rgba32ui
rgba32sint
rgba32i
rgba32float
rgba32f
rg8unorm
rg8snorm
rg8s
rg8uint
rg8ui
rg8sint
rg8i
rg16
rg16unorm
rg16snorm
rg16s
rg16uint
rg16ui
rg16sint
rg16i
rg16float
rg16f
rg32
rg32uint
rg32ui
rg32sint
rg32i
rg32float
rg32f
r8unorm
r8snorm
r8uint
r8ui
r8sint
r16unorm
r16snorm
r16s
r16uint
r16ui
r16sint
r16i
r16float
r16f
r32uint
r32ui
r32sint
r32i
r32float
r32f
bgra8unorm
bgra8
depth16unorm
depth16
depth24unorm
depth24
depth32float
depth32f
depth24unorm_stencil8
depth32float_stencil8
stencil8
framebufferColor
r8Unorm
r8Snorm
r8Uint
r8Sint
r16Unorm
r16Snorm
r16Uint
r16Sint
r16Float
r32Uint
r32Sint
r32Float
rg8Unorm
rg8Snorm
rg8Uint
rg8Sint
rg16Unorm
rg16Snorm
rg16Uint
rg16Sint
rg16Float
rg32Uint
rg32Sint
rg32Float
bgra8Unorm
rgba8Unorm
rgba8Snorm
rgba8Uint
rgba8Sint
rgba16Unorm
rgba16Snorm
rgba16Uint
rgba16Sint
rgba16Float
rgba32Uint
rgba32Sint
rgba32Float
depth16Unorm
depth24Unorm
depth32Float
depth24Unorm_stencil8
depth32Float_stencil8
slot%d: %@ 
<C3DFramebuffer %p: color=%@ - depth=%@ color-samples=%d depth-samples=%d renderTargets:%@>
com.apple.scenekit.SCNSceneLoader
unable to load %@
can't launch loader for %@
failed to unarchive data at %@ (%@)
failed to unarchive scene at %@ - unknown decoded object class (%@)
failed to unarchive scene at %@ (%@)
v24@?0@"NSData"8@"NSError"16
u_color
u_transform
commonProfileHashCode
CFGetTypeID(program) == C3DFXMetalProgramGetTypeID()
C3DFXMetalProgram
<C3DFXMetalProgram %p [vertex:`%@` fragment:`%@` macros:%@]>
v24@?0^{__CFString=}8r^v16
SSAODepthNormalPass
--DepthAndNormalMaterial--
#pragma body
_output.color = float4(_surface.normal.xyz, _surface.position.z);
resourceManager
C3DResourceManager
com.apple.scenekit.resourceManagerDeletionQueue
textures
proxy
<C3DResourceManager>
textureProxy
kResourceManagerPendingMeshElementRemoval
kResourceManagerPendingImageRemoval
kResourceManagerPendingImageProxyRemoval
kResourceManagerPendingProgramRemoval
kResourceManagerPendingMeshRemoval
kResourceManagerPendingMeshSourceRemoval
meshSourceData
value
C3DRasterizerStates
states
!scn_mutex_trylock(&s_RasterizerStatesRegistryLock)
CFSetContainsValue(s_RasterizerStatesRegistry, cf)
<C3DRasterizerStates %p> ZRead:%d ZWrite:%d ZFunc:%d cull:%d fill:%d
C3DTexture
<C3DTexture>
C3DImageProxy
imageProxy
imageProxy->_callbacks.getCaptureDeviceInfo
C3DTextureProxy
<C3DImageProxy>
<C3DTextureProxy>
C3DEnginePipeline
attribute
v16@?0^{__C3DEngineContext=}8
notifications._eventType == kC3DNotificationEventType_Node
notifications._eventType == kC3DNotificationEventType_Material
notifications._eventType == kC3DNotificationEventType_Geometry
notifications._eventType == kC3DNotificationEventType_Light
engineIterationContext
name == kC3DNotificationNodeWillDie
pipeline
<C3DEnginePipeline %p>
v28@?0^{__C3DDeformerStack=}8^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}16C24
index < 3
HDRFrameLuminancePass
scn_draw_fullscreen_triangle_VR_uv_vertex
scn_hdr_luminance_frag
*oLength > 0
lifeArray
invLifeSpan
birthTimeArray
invMassArray
sizeArray
bounceArray
frictionArray
chargeArray
colorsArray
rotAxisArray
valueArray
C3DFXGLSLProgramObject
<C3DFXGLSLProgramObject %p>
com.apple.scenekit.jitteringUpdateQueue
_iteration <= C3DJitteringIterationCount
C3DFXProgramDelegate
programDelegate
introspectionDataPtr
<C3DFXProgramDelegate %p>
C3DSubdivisionOsdGPURuntimeData
commandQueue
coarseVertexCount
vertexPatchTable
fvarPatchTables
legacyGregoryPatchTable
patchRangesTable
vertexRefiner
fvarRefiners
skinMorphSubdivIndexToMetalIndexBuffer
synchronizeCoarsePositionsPipeline.functionName
fvarChannelDescriptorsBuffer
fvarChannelsPackedDataBuffer
C3DSubdivisionOsdGPUGetPerPatchTypeSources
C3DGeometryOpenSubdivSupport_Metal.mm
OSD_IS_ADAPTIVE
OSD_PATCH_QUADS
OSD_PATCH_TRIANGLES
OSD_PATCH_REGULAR
CONTROL_POINTS_PER_PATCH
OSD_PATCH_GREGORY
OSD_PATCH_GREGORY_BASIS
OSD_PATCH_GREGORY_BOUNDARY
struct OsdInputVertexType { 
    metal::packed_float3 position; 
    metal::packed_float2 texcoord
    metal::packed_float4 color; 
#define OSD_USER_VARYING_DECLARE                             
float2 texcoord
float4 color; 
#define OSD_USER_VARYING_DECLARE_PACKED                             
metal::packed_float2 texcoord
metal::packed_float4 color; 
#define OSD_USER_VARYING_PER_VERTEX(in, out)                 
out.texcoord
 = in.texcoord
out.color = in.color; 
#define OSD_USER_VARYING_PER_CONTROL_POINT(in, out)          
#define OSD_USER_VARYING_PER_EVAL_POINT(UV, a, b, c, d, out) 
 = mix(mix(a.texcoord
, b.texcoord
, UV.x), mix(c.texcoord
, d.texcoord
, UV.x), UV.y); 
out.color = mix(mix(a.color, b.color, UV.x), mix(c.color, d.color, UV.x), UV.y); 
#define OSD_USER_VARYING_DECLARE_ATTRIBUTE                   
 [[attribute(
)]]; 
float4 color [[attribute(
VERTEX_BUFFER_INDEX
PATCH_INDICES_BUFFER_INDEX
CONTROL_INDICES_BUFFER_INDEX
OSD_PATCHPARAM_BUFFER_INDEX
OSD_PERPATCHVERTEXBEZIER_BUFFER_INDEX
OSD_PERPATCHTESSFACTORS_BUFFER_INDEX
OSD_VALENCE_BUFFER_INDEX
OSD_QUADOFFSET_BUFFER_INDEX
TRANSFORMS_BUFFER_INDEX
TESSELLATION_LEVEL_BUFFER_INDEX
INDICES_BUFFER_INDEX
QUAD_TESSFACTORS_INDEX
OSD_PERPATCHVERTEXGREGORY_BUFFER_INDEX
OSD_PATCH_INDEX_BUFFER_INDEX
OSD_DRAWINDIRECT_BUFFER_INDEX
OSD_KERNELLIMIT_BUFFER_INDEX
OSD_PATCH_ENABLE_SINGLE_CREASE
OSD_FRACTIONAL_EVEN_SPACING
OSD_FRACTIONAL_ODD_SPACING
OSD_MAX_TESS_LEVEL
USE_STAGE_IN
USE_PTVS_FACTORS
USE_PTVS_SHARPNESS
THREADS_PER_THREADGROUP
CONTROL_POINTS_PER_THREAD
VERTEX_CONTROL_POINTS_PER_PATCH
OSD_MAX_VALENCE
OSD_NUM_ELEMENTS
OSD_ENABLE_BACKPATCH_CULL
OSD_USE_PATCH_INDEX_BUFFER
OSD_ENABLE_SCREENSPACE_TESSELLATION
OSD_ENABLE_PATCH_CULL
NEEDS_BARRIER
OSD_FVAR_WIDTH
OSD_FVAR_USES_MULTIPLE_CHANNELS
OSD_FVAR_DATA_BUFFER_INDEX
OSD_FVAR_INDICES_BUFFER_INDEX
OSD_FVAR_PATCHPARAM_BUFFER_INDEX
OSD_FVAR_PATCH_ARRAY_BUFFER_INDEX
OSD_FVAR_CHANNELS_CHANNEL_COUNT_INDEX
OSD_FVAR_CHANNELS_CHANNEL_DESCRIPTORS_INDEX
OSD_FVAR_CHANNELS_PACKED_DATA_BUFFER_INDEX
OSD_FVAR_CHANNELS_PATCH_ARRAY_INDEX_BUFFER_INDEX
OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING
OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING
OSD_COLOR_INTERPOLATION_MODE
OSD_TEXCOORD0_INTERPOLATION_MODE
OSD_TEXCOORD1_INTERPOLATION_MODE
OSD_TEXCOORD2_INTERPOLATION_MODE
OSD_TEXCOORD3_INTERPOLATION_MODE
OSD_TEXCOORD4_INTERPOLATION_MODE
OSD_TEXCOORD5_INTERPOLATION_MODE
OSD_TEXCOORD6_INTERPOLATION_MODE
OSD_TEXCOORD7_INTERPOLATION_MODE
C3D_OPTIMIZE_OPENSUBDIV_STORAGE
geometry->_subdivInfo.subdivisionLevel > 0
v20@?0@"<MTLCommandBuffer>"8B16
osdRuntimeData->skinMorphContext.synchronizeCoarsePositionsPipeline
__C3DSubdivisionOsdGPUHasPatchOfType(osdRuntimeData, c3dPatchType)
C3DSubdivisionOsdGPUDraw
vertexDataBuffer
<C3DSubdivisionOsdGPURuntimeDataRef %p>
Vertex patch table:
  - Patch arrays (%@):
    - %d x %@
  - Data buffer: %p (%@)
  - Patch index buffer: %p (%@)
  - Patch param buffer: %p (%@)
FVar patch table (channel %zu):
Legacy Gregory patch table:
  - Vertex valence buffer: %p (%@)
  - Quad offsets buffer: %p (%@)
  - Vertex stencil table (%d stencils)
    - Sizes buffer: %p (%@)
    - Offsets buffer: %p (%@)
    - Indices buffer: %p (%@)
    - Weights buffer: %p (%@)
  - Vertex evalutor input
    - Src buffer: [offset:%d length:%d stride:%d] %p (%@)
    - Dst buffer: [offset:%d length:%d stride:%d] %p (%@)
v16@?0r^{?={?=@@@@i}{?=@@{BufferDescriptor=iii}{BufferDescriptor=iii}}@}8
Vertex Refiner:
  - Skin/morph indexing table: %p (%@)
Total memory usage: %@
QUADS
TRIANGLES
REGULAR
GREGORY
GREGORY BOUNDARY
GREGORY BASIS
C3DGetPatchTypeDescription
.patchArrays
.dataBufferOffset
.dataBufferCoarseDataSize
.dataBufferFullDataSize
.patchIndexBuffer
.patchParamBuffer
.dataBuffer
.count
.[%d]
.vertexValenceBuffer
.quadOffsetsBuffer
.quadOffsetsBaseGregory
.quadOffsetsBaseGregoryBoundary
.elementCount
.patchArrayCount
.[%d][%d]
.stencilTable
.evaluatorInput
.sizesBuffer
.offsetsBuffer
.indicesBuffer
.weightsBuffer
.numStencils
.srcDesc
.dstDesc
__C3DSubdivisionOsdGPURuntimeDataDecodeEvaluatorInput
srcLength == sizeof(OpenSubdiv::Osd::BufferDescriptor)
dstLength == sizeof(OpenSubdiv::Osd::BufferDescriptor)
 -w 
compute_opensubdiv
C3DPatchTypeFromOsdPatchType
C3D-OpenSubdiv_compute.metal
C3DPatchTypeToOsdPatchType
fvarChannelCount == fvarPrimvarCount
^{__CFData=}8@?0
v24@?0{?=qq}8
%@-%s
Mesh
mesh.h
_refiner
initializeContext
{MTLContext=@@@@}8@?0
mtlBlitContext.computeCommandEncoder
mtlBlitContext.commandBuffer
__C3DSubdivisionOsdGPURuntimeDataEncodeMTLBuffer
encodedLength <= buffer.length
scn_osd_synchronize_coarse_positions_no_argument_buffer
scn_osd_synchronize_indexed_coarse_positions_no_argument_buffer
osdRuntimeData->coarseVertexCount == remappingTableSize
refiner->computeEvaluator
evaluatorDidSucceed
aoCoord
lightmapCoord
kMDLAssetDefaultUSDColorSpace
usdz
SCN_MDLCurrentAssetResolver
While creating SCNSkinner: Could not find SCNNode %@
influenceWeightNumber.floatValue < 1.f
morpher.weights[%d]
SCNSceneKitAssociatedObject
c32@?0@"SCNGeometrySource"8Q16*24
blendShape%d
normal%d
textureCoordinate%d
baseColor
metallic
%@_%d
AO_%@_%@.png
@"NSString"16@?0@"SCNNode"8
v32@?0@"SCNNode"8@"SCNGeometry"16@"NSArray"24
aoTexture
lightmapTexture
/tmp/ModelKit_AO_%@.png
fieldOfView
fstop
MDLAssetLoadingOption getMDLAssetLoadingOptionDefaultUSDColorSpace()
SCNModelIOPrivate.mm
MDLAssetLoadingOptionDefaultUSDColorSpace
void *ModelIOLibrary()
/System/Library/Frameworks/ModelIO.framework/Contents/MacOS/ModelIO
/%@.position
/%@.orientation
/%@.scale
Bad joint path detected for joint: %@
positionAttribute
offset=%d&size=%d
Error: ranges and strings arrays must be of the same size
Error: ranges must be ordered
Error: incorrect ranges : cumulated size larger than the original string
SCNTechniqueView
SCNKitError : can't load nib named : SCNTechniqueView
_surface.emission.rgb = vec3(_surface.emission.a);
_surface.emission.a = 1.0;
_surface.emission.rgb *= vec3(%d.0, %d.0, %d.0);
_surface.emission.a = 1.0;
shader
stage
C3DFXShader
<C3DFXShader %@>
SCNLightingModelConstant
SCNLightingModelLambert
SCNLightingModelPhong
SCNLightingModelBlinn
SCNLightingModelNone
SCNLightingModelShadowOnly
SCNLightingModelPhysicallyBased
SCNLightingModelInvalid
commonProfile->_lightingModel < C3DLightingModelCount && C3DLightingModelCount < 15
C3DEffectCommonProfile
<C3DEffectCommonProfile %p :
 lightingModel:%@
 perPixelLit:%d
 isOpaque:%d
 transparencyMode:%d
Emission
Ambient
Diffuse
Specular
Reflective
Transparent
Filter
Normal
Ambient Occlusion
Self Illumination
Metalness
Roughness
ClearCoat
ClearCoatRoughness
ClearCoatNormal
Displacement
Shininess
Reflectivity
Transparency
Fresnel
[%@] texture:%d xform:%d
_C3DEffectCommonProfileInitWithPropertyList
versionNumber
ambientIntensity
diffuseIntensity
specularIntensity
emissionIntensity
multiplyIntensity
transparentIntensity
normalIntensity
ambientOcclusionIntensity
selfIlluminationIntensity
displacementIntensity
reflectiveIntensity
locksAmbientWithDiffuse
Intensity
imageID < INT_MAX
entryID
lightingModel
imagesCount
typeID == C3DSceneGetTypeID()
C3DEffectSlot
<C3DEffectSlot>
mtltexture
precomputedLightingEnvironment
transforms
uvSet
SCNAction: Run block actions can not be properly encoded, Objective-C blocks do not support NSSecureCoding.
SCNAction: Run block actions can not be properly decoded, Objective-C blocks do not support NSSecureCoding.
threshold
thresholdType
C3DLOD
<C3DLOD>
SSRCompositePass
Radiance
ReflectanceRoughness
scn_ssr_composite_frag
C3DSpline
spline
<C3DSpline %p>
(size_t)CFDataGetLength(data) == stride * C3DSourceAccessorGetCount(accessor)
C3DMeshSourceIsVolatile(source)
BoxBlurPass
box_blur_frag_%d
copy_frag
SSRDownSampleColorDepthPass
BackDepth
scn_ssr_downsample_depth
vertexCount == CFIndex(baseMesh.pointCount())
C3DMorphIsUsingSparseTargets(morph) == true
morpherCompressedData
morpherMetaData
SCNDecodeMorpherUsingAnimCodec
SCNMorpherAnimCodecSupport.mm
morpherMetaData.length >= (2+targetCount)
Mesh.h
index < pointCount()
setPoint
setPolygonSize
j < polygonCount()
setIndex
i < indexCount()
C3DSortSystem
<C3DSortSystem %p>
C3DLightProbesSystem
probesSystem->_probesCapacity
probesSystem->_probesPositions
tetrahedronIndexes
_tetrahedrons[tetraderonIndex].neighbourIndexes[otherTetraderonFaceIndex] == -1
sh_sizeof(shOrder) == (size_t)CFDataGetLength(irradianceSH)
lastIndex != (uint32_t)-1
cacheIndex
sh_sizeof(shOrder) == (size_t)shLength
<C3DLightProbesSystem %p>
tetrahedronIsValid[indexValid]
validTetraCount <= (uint32_t)indexToRecycle
vCount <=2
ManipulatorPass
C3DEdgeArray
edges
edgeCount == edges->_count
index < edges->_count
array
C3DTriangulationInfo
edgeIndexesPerFaceCounter[j] <= 2
info
<C3DEdgeArray>
<C3DTriangulationInfo>
com.apple.sceneKit.forceGL
com.apple.sceneKit.forceMetal
com.apple.sceneKit.showsStatistics
com.apple.sceneKit.enableCameraControl
com.apple.sceneKit.batchMaxCount
com.apple.sceneKit.forceNoAA
com.apple.sceneKit.disableLinearSpaceRendering
com.apple.sceneKit.disableWideGamut
com.apple.sceneKit.enableWideGamut
com.apple.sceneKit.enablePostMorphUnifyNormals
com.apple.sceneKit.enableStandardShadersWithFunctionConstants
com.apple.sceneKit.forceNMOSBehavior
com.apple.sceneKit.forceOS2019Behavior
com.apple.sceneKit.forceOS2018Behavior
com.apple.sceneKit.forceOS2017Behavior
com.apple.sceneKit.forceOS2016Behavior
com.apple.sceneKit.verbose
com.apple.sceneKit.useOneCommandQueuePerDevice
com.apple.sceneKit.disableReverseZ
com.apple.sceneKit.isolateCacheMissShader
C3DMeshElementEditor
MeshElementEditor
editor
<C3DMeshElementEditor>
hash
debugDescription
overrides
ide_
ske_
simd
geometry.materials[%d]
particleSystems[0]
[%d]
SCNReferenceLoadingStack
referenceRoot
<%@: %p url=%@>
referenceURL
loadingPolicy
childNodes
repeatCount
repeatDuration
usesSceneTimeBase
{CATransform3D=dddddddddddddddd}
DOFFinalBlurPass
DofColorCoC
dof_blur
dof_compute_kernel
OutlinePass
COLOR_OUTLINE
outline_vert
outline_frag
DrawBackgroundPass
BACKGROUND
SubdivideMidPoint
VMesh.cpp
end < shifts[a + 1]
preprocess() 
 LOD[
InterpolateNormals
neighbor.a >= 0 && neighbor.a < int32_t(normals.size())
neighbor.b >= 0 && neighbor.b < int32_t(normals.size())
loadBaseMeshFromVectors
pointVec.size() > 0
uvVec.size() == pointCountInVec
normalVec.size() == pointCountInVec
(idxVec.size() % 3) == 0
triangle
VMesh.hpp
InterpolateMidPoint
neighbor.a >= 0 && neighbor.a < int32_t(signal.size())
neighbor.b >= 0 && neighbor.b < int32_t(signal.size())
neighborsStartIndex
neighborsEndIndex
<%@: %p | scene=%@ sceneTime=%f pointOfView=%@>
Jittering is not supported on SCNMetalLayer
animationPlayer
C3DAnimationPlayer
<C3DAnimationPlayer %p>
blendFactor
C3DIndexSet
indexSet 
(no index)
[number of indexes: %lu (in %lu ranges), indexes: (
-%lu
DOFBlurCoCXPass
dof_coc_blurV
%@: %@
objectController.selection%@.%@
selectedValue
vector2
vector3
vector4
matrix4
selectedIndex
%@[%d]
failed to instanciate a %@ with option %@
New %@
failed to instanciate a %@
%@.%@
imageSequence
%@%@
screenSpaceAmbientOcclusion
ssao
{CGPoint=dd}
{CGSize=dd}
{SCNVector3=ddd}
{SCNVector4=dddd}
@"NSString"
@"NSColor"
@"NSArray"
@"SCN
olor
ontent
mage
_C3DAnimationInitWithPropertyList
duration
autoreverses
additive
cumulative
isAnimationClip
removeOnCompletion
sceneTimeBased
fillModeMask
timeOffset
beginTime
fadeInDuration
fadeOutDuration
timingFunction
simpleAnimation
C3DSimpleAnimation
<C3DSimpleAnimation>
baseType
startValue
byValue
endValue
light->_type == kC3DLightTypeIES
projInfoOut
C3DLightAddLightSHContribution
C3DLight.c
C3DLight
<C3DLight %p> Type:%@ CastsShadow(Samples:%d Cascade:%d)
<C3DLight %p> Type:%@
Directional
Omni
Spot
Irradiance
Area[Rectangle]
Area[Polygon]
Area[Line]
Area[Ellipse]
Area[Ellipsoid]
Unknown
attenuationEndDistance
attenuationStartDistance
shadowBias
temperature
shadowCascadeDebugFactor
_C3DLightInitWithPropertyList
property3
property4
castShadow
znear
zfar
shadowSoftenFactor
category
shadowMapSize
directionalExtent
shadowMaxSampleCount
categoryBitMask
Area light - Rectangle
Area light - Polygon
Area Light - Line
Area Light - Ellipse
Area Light - Ellipsoid
area_shape_vert
area_shape_ellipse_frag
halfExtents
area_shape_ellipsoid_frag
sh_eval_direction
sh_math.h
order < kSHMinOrder || order > kSHMaxOrder
sh_accumulate_omni_light
jointDef->bodyA
bodyA
bodyB
infos
C3DCamera
<C3DCamera:%p "%@" custom, [%.3f %.3f %.3f %.3f ; %.3f %.3f %.3f %.3f ; %.3f %.3f %.3f %.3f ; %.3f %.3f %.3f %.3f]>
<C3DCamera:%p "%@" ortho, near:%.3f far:%.3f scale: %.3f>
<C3DCamera:%p "%@" persp, near:%.3f far:%.3f %s-fov:%.3f>
horizontal
vertical
fStop
aspectRatio
sensorHeight
lensShift
postProjectionTransformTranslation
postProjectionTransformScale
averageGray
bloomBlurRadius
bloomIntensity
bloomThreshold
bloomIteration
bloomIterationSpread
colorFringeStrength
colorFringeIntensity
contrast
grainIntensity
grainScale
exposureAdaptationBrighteningSpeedFactor
exposureAdaptationDarkeningSpeedFactor
exposureAdaptationDuration
exposureAdaptationHistogramRangeHighProbability
exposureAdaptationHistogramRangeLowProbability
exposureOffset
focusDistance
focalLength
maximumExposure
minimumExposure
saturation
vignettingIntensity
vignettingPower
whitePoint
screenSpaceAmbientOcclusionIntensity
screenSpaceAmbientOcclusionRadius
screenSpaceAmbientOcclusionBias
screenSpaceAmbientOcclusionDepthThreshold
screenSpaceAmbientOcclusionNormalThreshold
screenSpaceAmbientOcclusionSampleCount
screenSpaceAmbientOcclusionDownSample
whiteBalanceTemperature
whiteBalanceTint
_C3DCameraInitWithPropertyList
ortho
letterbox
fovHorizontal
customProj
autoZRange
xfov
yfov
xMag
bladeCount
dofSampleCount
sensorSize
orthoScale
inputMode
inputScale
inputBias
inputOrigin
inputProperty
SCNCaptureDeviceOutputConsumerOptionContainsAlpha
BloomDownSamplePass
scn_bloom_downsample
FinalPass
lastPassOutputingDepth
mainPassLastPassColorOutputDescriptor
mainDepthDesc
finalPass
dependencyFound
param.name
Vertex
Texcoord
Tangent
ModelViewProjectionTransform
ModelViewTransform
ModelTransform
ViewTransform
ProjectionTransform
NormalTransform
ModelViewProjectionInverseTransform
ModelViewInverseTransform
ModelInverseTransform
ViewInverseTransform
ProjectionInverseTransform
NormalInverseTransform
InverseResolution
SystemTime
COLOR0
COLOR1
COLOR2
COLOR3
attachmentID < fboDesc->colorsDescriptionCount
inputIndex < passOutput.size()
kSkinnerKey
kMorpherKey
subdivisionLevel > 0
child->_nextSibling == NULL
child->_parent == NULL
prevSibling->_parent == node
prevChild
node->_transformHandle != kC3DTransformHandleInvalid
nodeID
attributeName
ancestor
arrayOfNodes
layer < C3D_MAX_LAYERS
C3DNode
<C3DNode:%p "%@"
  geometry: %@
  light: %@
  camera: %@
  skinner: %@
  morpher: %@
_C3DNodeInitWithPropertyList
alpha
isJoint
euler
axisAngle
kC3D
libID!=0
firstChild
nextSibling
skinner
sphereOut
v32@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}8q16^B24
!C3DNodeShouldBePutInCullingSystem(root) || (root->_cullingHandle != kC3DCullingHandleInvalid)
!C3DNodeShouldBePutInCullingSystem(child) || (child->_cullingHandle != kC3DCullingHandleInvalid)
semantic != kC3DMeshSourceSemanticPosition || data->sourcesSemanticInfos[semantic].count == 0
semantic > currentSemantic
data->sourcesSemanticInfos[semantic].index == -1
mesh->_renderableData.sources
mesh->_renderableData.elements
sources
primarySourcesInfo
srcCount == dstCount
sourceIndex < oldSourceCount
(dataKind != kC3DMeshDataKindRenderable) || (channel == kC3DSharedRenderableIndexChannel)
channel != kAutomaticChannelIndex
mesh->_originalData.sourceChannels
sourceIndex != kCFNotFound
mesh->_originalData.elements
C3DMeshGetIndexOfElement
C3DMeshGetElementAtIndex
C3DMeshGetMeshElements
subIDs
C3DSourceAccessorGetSource(accessor) == (C3DGenericSourceRef) primarySource
C3DMesh
<C3DMesh %p "%@"
  element%d: %@
  source %@%d (channel:%d) : %@
  source %@ (channel:%d) : %@
  renderable element%d: %@
  renderable source %@%d: %@
  renderable source %@: %@
_C3DMeshInitWithPropertyList
baseSourceLocators
verticesMask
sourceID <= INT_MAX
C3DGenericSourceIsPrimary(primarySource)
boundingSphere
meshElements
__meshDataForDataKind
sourceIndex < CFArrayGetCount(meshData->sources)
renderableElement
elementCount == CFArrayGetCount(deindexedTriangleElements)
value == sourceInfo.dataVectorCount
overallVertexIndex == (CFIndex)indexCount
sourceCount == CFArrayGetCount(deindexedSources)
elementCount == CFArrayGetCount(deindexedElements)
channelCount == C3DMeshElementGetIndicesChannelCount(rhs.element)
__writeIndexInBuffer
channelCount == 1
__C3DMeshElementCreateRenderablePrimitiveTypeCopy
effectID
fillMode == kC3DFillModeFill || fillMode == kC3DFillModeLines
material->_commonProfile
oBlendColor
C3DMaterial
<C3DMaterial %p : "%@", 
common profile %@
custom %@
_C3DMaterialInitWithPropertyList
__library__
enableWriteInDepthBuffer
enableReadsFromDepthBuffer
fillMode
C3DConstraintSlider
v28@?0f8r^{Triangle=}12r^20
B20@?0^8I16
vertices.type == kC3DBaseTypeVector3
vertexCountPerPolygon >= 3
C3DConstraintAvoidOccluder
positions.type == kC3DBaseTypeVector3
<C3DConstraintAcceleration>
<C3DConstraintAvoidOccluder %p>
_hasFired
nodeConstraints-%p
originator
C3DScene
<C3DScene>
fogColor
fogDensityExponent
fogEndDistance
fogStartDistance
wantsScreenSpaceReflection
screenSpaceReflectionSampleCount
screenSpaceReflectionMaximumDistance
screenSpaceReflectionStride
_C3DSceneInitWithPropertyList
startTime
endTime
frameRate
upAxis
nodeTree
libID < INT_MAX
playbackSpeed
kSCNFreeViewCameraName
<%@: %p '%@'>
<%@: %p>
-[SCNCamera setName:]
-[SCNCamera setScreenSpaceAmbientOcclusionIntensity:]
-[SCNCamera setScreenSpaceAmbientOcclusionRadius:]
-[SCNCamera setScreenSpaceAmbientOcclusionBias:]
-[SCNCamera setScreenSpaceAmbientOcclusionDepthThreshold:]
-[SCNCamera setScreenSpaceAmbientOcclusionNormalThreshold:]
-[SCNCamera setScreenSpaceAmbientOcclusionSampleCount:]
-[SCNCamera setScreenSpaceAmbientOcclusionDownSample:]
-[SCNCamera setAutomaticallyAdjustsZRange:]
-[SCNCamera setAverageGray:]
-[SCNCamera setBloomBlurRadius:]
-[SCNCamera setBloomIntensity:]
-[SCNCamera setBloomThreshold:]
-[SCNCamera setBloomIterationCount:]
-[SCNCamera setBloomIterationSpread:]
-[SCNCamera setCategoryBitMask:]
-[SCNCamera setColorFringeStrength:]
-[SCNCamera setColorFringeIntensity:]
-[SCNCamera setContrast:]
-[SCNCamera setGrainIntensity:]
-[SCNCamera setGrainScale:]
-[SCNCamera setGrainIsColored:]
-[SCNCamera setGrainSlice:]
-[SCNCamera setGrainTexture:]
-[SCNCamera setWhiteBalanceTemperature:]
-[SCNCamera setWhiteBalanceTint:]
-[SCNCamera setExposureAdaptationBrighteningSpeedFactor:]
-[SCNCamera setExposureAdaptationDarkeningSpeedFactor:]
-[SCNCamera setExposureAdaptationDuration:]
-[SCNCamera setExposureAdaptationHistogramRangeHighProbability:]
-[SCNCamera setExposureAdaptationHistogramRangeLowProbability:]
-[SCNCamera setExposureAdaptationMode:]
-[SCNCamera setExposureOffset:]
-[SCNCamera setDofIntensity:]
-[SCNCamera setMaximumExposure:]
-[SCNCamera setMinimumExposure:]
-[SCNCamera setMotionBlurIntensity:]
-[SCNCamera setOrthographicScale:]
-[SCNCamera setSaturation:]
-[SCNCamera setUsesOrthographicProjection:]
-[SCNCamera setVignettingIntensity:]
-[SCNCamera setVignettingPower:]
-[SCNCamera setWantsExposureAdaptation:]
-[SCNCamera setWantsHDR:]
-[SCNCamera setWhitePoint:]
-[SCNCamera setXFov:]
-[SCNCamera setYFov:]
-[SCNCamera setZFar:]
-[SCNCamera setZNear:]
-[SCNCamera setLensShift:]
-[SCNCamera setPostProjectionTransform:]
-[SCNCamera setPostProjectionTransformTranslation:]
-[SCNCamera setPostProjectionTransformScale:]
fabs(_focalLength - focalLength) < 1e-3
_focalLength == 0.f
-[SCNCamera setFieldOfView:]
-[SCNCamera setSensorHeight:]
-[SCNCamera setFocalLength:]
-[SCNCamera setFStop:]
-[SCNCamera setApertureBladeCount:]
-[SCNCamera setFocalBlurSampleCount:]
-[SCNCamera setFocusDistance:]
-[SCNCamera setProjectionTransform:]
usesOrthographicProjection
automaticallyAdjustsZRange
projectionDirection
lensShiftX
lensShiftY
postProjectionTransformTranslationX
postProjectionTransformTranslationY
postProjectionTransformScaleX
postProjectionTransformScaleY
focalBlurSampleCount
exposureAdaptationMode
colorGrading
wantsHDR
wantsExposureAdaptation
focalBlurRadius
{CGRect={CGPoint=dd}{CGSize=dd}}
{?=[4]}
SCNMultisamplingDefaultSampleCount
SKGlobalSharedContextRegistry
C3DRendererContextRetainContext
SCNKitUtils.m
renderContext
C3DRendererContextReleaseContext
SCNLightAttenuationStartKey
SCNLightAttenuationEndKey
SCNLightAttenuationFalloffExponentKey
SCNLightSpotInnerAngleKey
SCNLightSpotOuterAngleKey
SCNLightSpotFalloffExponentKey
SCNLightShadowNearClippingKey
SCNLightShadowFarClippingKey
SCNLightGoboProjectShadows
SCNLightConstantAttenuationKey
SCNLightLinearAttenuationKey
SCNLightQuadraticAttenuationKey
SCNLightFallOffAngleKey
SCNLightFallOffExponentKey
SCNLightHotspotBeamKey
omni
directional
spot
probe
area
<%@: %p '%@' | type=%@>
<%@: %p | type=%@>
-[SCNLight setName:]
-[SCNLight setAttenuationEndDistance:]
-[SCNLight setAttenuationFalloffExponent:]
-[SCNLight setAttenuationStartDistance:]
-[SCNLight setBaked:]
-[SCNLight setCastsShadow:]
-[SCNLight setCategoryBitMask:]
-[SCNLight setColor:]
-[SCNLight setIntensity:]
-[SCNLight setOrthographicScale:]
-[SCNLight setShadowBias:]
-[SCNLight setShadowColor:]
-[SCNLight setShadowMapSize:]
-[SCNLight setShadowRadius:]
-[SCNLight setShadowSampleCount:]
-[SCNLight setSpotFalloffExponent:]
-[SCNLight setSpotInnerAngle:]
-[SCNLight setSpotOuterAngle:]
-[SCNLight setTechnique:]
-[SCNLight setTemperature:]
-[SCNLight setType:]
-[SCNLight setUsesDeferredShadows:]
-[SCNLight setUsesModulatedMode:]
-[SCNLight setZFar:]
-[SCNLight setZNear:]
-[SCNLight setShadowCascadeCount:]
-[SCNLight setAutomaticallyAdjustsShadowProjection:]
-[SCNLight setMaximumShadowDistance:]
-[SCNLight setForcesBackFaceCasters:]
-[SCNLight setSampleDistributedShadowMaps:]
-[SCNLight setShadowCascadeSplittingFactor:]
-[SCNLight set_shadowCascadeDebugFactor:]
usesDeferredShadows
lightCategoryBitMask
spotFallOffExponent
probeType
probeUpdateType
parallaxCorrectionEnabled
probeExtentsX
probeExtentsY
probeExtentsZ
probeOffsetX
probeOffsetY
probeOffsetZ
parallaxOffsetX
parallaxOffsetY
parallaxOffsetZ
parallaxExtentsFactorX
parallaxExtentsFactorY
parallaxExtentsFactorZ
maximumShadowDistance
autoShadowProjection
shadowCascadeCount
shadowCascadeSplittingFactor
forcesBackFaceCasters
sampleDistributedShadowMaps
castsShadow
usesModulatedMode
baked
shouldBakeDirectLighting
shouldBakeIndirectLighting
sphericalHarmonics
scncolor
scnShadowColor
shadowSampleCount
shadowSampleCount2
IESProfileURL
areaType
areaExtentsX
areaExtentsY
areaExtentsZ
areaPolygonVertices
drawsArea
FloorPass
floor
SceneKit-floor-color-
SceneKit-floor-depth-
offsetX
offsetY
mappingChannel
-[SCNMaterial setName:]
<%@: %p
 '%@'
  %@=%@
.color
content
-[SCNMaterial _shadableSetValue:forUndefinedKey:]
shaderModifiers.
customMaterialProperties
customMaterialAttributes
-[SCNMaterial setShaderModifiers:]
-[SCNMaterial copyShaderModifiersAndLanguageVersionFrom:]
-[SCNMaterial setMinimumLanguageVersion:]
-[SCNMaterial setProgram:]
valuesForUndefinedKeys
lightingModelName
shadableHelper
colorBufferWriteMask
GridPass
C3D_grid_vert
C3D_grid_frag
kProjectionTransform
kModelTransform
kViewTransform
kModelViewProjectionTransform
kModelViewTransform
kNormalTransform
kRenderPassName
-[SCNNode setName:]
%s%s {
dump node tree (%@)
------------------------------------------------------
%@%@
<%p>
_affineUpToDate
_transformUpToDate
-[SCNNode _setQuaternion:]
-[SCNNode _setPosition:]
-[SCNNode _setScale:]
-[SCNNode setMovabilityHint:]
-[SCNNode setCastsShadow:]
-[SCNNode setUsesDepthPrePass:]
-[SCNNode setCategoryBitMask:]
-[SCNNode setHidden:]
-[SCNNode setOpacity:]
-[SCNNode setRenderingOrder:]
 pos(%f %f %f)
 rot(%f %f %f %f)
 scale(%f %f %f)
 light=%@
 camera=%@
 geometry=%@
 | no child
 | 1 child
 | %d children
filters.
-[SCNNode setValue:forUndefinedKey:]
_isFocusableOrHasFocusableChild
index < [self._particleSystems count]
system
postMorphingDeformers
postSkinningDeformers
constraints
physicsBody
physicsField
particleSystem
fixedBoundingBoxExtrema[0]
fixedBoundingBoxExtrema[1]
paused
focusBehavior
action-keys
actions
clientAttributes
failed to archive node's client attributes. %@ %@
movabilityHint
depthPrePass
-[SCNNode(SIMD) setSimdPivot:]
-[SCNNode(SIMD) setSimdTransform:]
-[SCNNode(SIMD) setSimdRotation:]
mode <= C3DWrapModeMirror
mode <= kC3DFilterModeLinear
type < kC3DImageCount
cull <= kC3DCullNone
fillMode == kC3DFillModeLines || fillMode == kC3DFillModeFill
blend < kC3DBlendFactorCount
blendOp < kC3DBlendOpCount
func < kC3DComparisonFuncCount
op < kC3DStencilOpCount
format < sizeof(__SCNMTLVertexFormatToC3DBaseTypeArray) / sizeof(__SCNMTLVertexFormatToC3DBaseTypeArray[0])
float2x2
float2x3
float2x4
float3x2
float3x4
float4x2
float4x3
half2x2
half2x3
half2x4
half3x2
half3x3
half3x4
half4x2
half4x3
half4x4
uint
uint2
uint3
uint4
bool2
bool3
bool4
A8Unorm
R8Sint
R8Snorm
R8Uint
R8Unorm
R8Unorm_sRGB
R16Float
R16Sint
R16Snorm
R16Uint
R16Unorm
R32Float
R32Sint
R32Uint
RG8Sint
RG8Snorm
RG8Uint
RG8Unorm
RG8Unorm_sRGB
RG16Float
RG16Sint
RG16Snorm
RG16Uint
RG16Unorm
RG32Float
RG32Sint
RG32Uint
BGR10_XR
BGR10_XR_sRGB
BGRA10_XR
BGRA10_XR_sRGB
BGR10A2Unorm
RGBA8Sint
RGBA8Snorm
RGBA8Uint
RGBA8Unorm
RGBA8Unorm_sRGB
RGB10A2Uint
RGB10A2Unorm
RGBA16Sint
RGBA16Snorm
RGBA16Uint
RGBA16Unorm
RGBA32Sint
RGBA32Uint
Depth16Unorm
Depth32Float
Stencil8
Depth24Unorm_Stencil8
Depth32Float_Stencil8
MTLPixelFormat
MTLStorageModeShared
MTLStorageModeManaged
MTLStorageModePrivate
MTLStorageModeMemoryless
Unkown
MTLCPUCacheModeDefaultCache
MTLCPUCacheModeWriteCombined
MTLTextureType1D
MTLTextureType1DArray
MTLTextureType2D
MTLTextureType2DArray
MTLTextureType2DMultisample
MTLTextureTypeCube
MTLTextureTypeCubeArray
MTLTextureType3D
MTLTextureType2DMultisampleArray
MTLTextureTypeTextureBuffer
shaderRead
shaderWrite
pixelFormatView
MTLTextureUsageShaderRead
MTLTextureUsageShaderWrite
MTLTextureUsageRenderTarget
MTLTextureUsagePixelFormatView
MTLTextureUsageUnknown
mtlBuffer
mtlVertexFormat
byteOrderDefault(Big)
byteOrder16Little
byteOrder32Little
byteOrder16Big
byteOrder32Big
byteOrderUnknown
alphaNone
alphaPremultipliedLast
alphaPremultipliedFirst
alphaLast
alphaFirst
alphaNoneSkipLast
alphaNoneSkipFirst
alphaOnly
alphaUnknown
kSceneStartTimeAttributeKey
kSceneEndTimeAttributeKey
kSceneFrameRateAttributeKey
kSceneUpAxisAttributeKey
scnz
com.apple.scenekit.scene
com.apple.scenekit.scene.zip
com.pixar.universal-scene-description-mobile
public.polygon-file-format
public.geometry-definition-format
public.standard-tesselated-geometry-format
com.pixar.universal-scene-description
%@_textures
%@_texture%d.png
c24@?0^@8@?<c@?@"NSURL"^@>16
c24@?0@"NSURL"8^@16
MDLAsset
sceneDump%d.scn
dumping scene to %@
children[
wr == 0
physicsWorld
userAttributes
sourceURL
SCNLayerTreeDidChange
C3DEngineContextGetRenderContext(engineContext)
-[SCNTextureOffscreenRenderingSource _buildMipmaps:]
SCNTextureSource.m
SKSCNRenderer
C3DBlendStates
renderTargetIndex < states->_targetCount
srcColor
(1 - srcColor)
srcAlpha
(1 - srcAlpha)
dstColor
(1 - dstColor)
dstAlpha
(1 - dstAlpha)
blendColor
(1 - blendColor)
blendAlpha
(1 - blendAlpha)
srcAlphaSat
<C3DBlendStates %p targetCount:%d needsBlendColor:%d
  blend:%s col[(src * %@) %@ (dst * %@)] alpha[(src * %@) %@ (dst * %@)]
  blend:%s col[(src * %@) %@ (dst * %@)]
bindingMode
bindingPointIndicesStride
bindingBarycentricCoordsStride
bindingPointIndicesFormat
bindingBarycentricCoordsFormat
bindingPointIndices
bindingBarycentricCoords
isLegacySingleLayerDeformer
bindingOffsetsOrTransforms
bindingOffsetsOrTransformsLength
bindingInnerLayerInfluences
bindingInnerLayerInfluencesLength
bindingInnerTNBs
bindingOuterTNBs
bindingSpaceVectorsLength
bindingInnerOffsets
bindingOuterOffsets
bindingOffsetsLength
-[SCNGeometryWrapDeformerParameters initWithCoder:]
SCNGeometryWrapDeformer.mm
decodedLength == bindingPointIndicesLength
decodedLength == bindingBarycentricCoordsLength
decodedLength == _bindingData.legacyOffsetsOrTransformsLength
decodedLength == _bindingData.innerLayerInfluencesLength
decodedLength == _bindingData.tnbMatricesLength
decodedLength == _bindingData.offsetsLength
driverTexcoordSource
deformedTexcoordSource
parameters
-[SCNGeometryWrapDeformerInstance initWithNode:drivingNode:deformer:outputs:computeVertexCount:context:]
parameters->_vertexCount == computeVertexCount
v24@?0@"<MTLFunction>"8@"MTLStageInputOutputDescriptor"16
deformer_wrap_legacy_absolute
deformer_wrap_legacy_relative
-[SCNGeometryWrapDeformerInstance initWithNode:innerLayerNode:outerLayerNode:deformer:outputs:computeVertexCount:context:]
deformer_wrap_absolute
deformer_wrap_relative
C3DCoreProfileVertexAttribDivisor
C3DGL_macOS_CoreProfile.c
C3DCoreProfileBlitFramebuffer
C3DCoreProfileBindVertexArray
C3DCoreProfileGenVertexArrays
C3DCoreProfileDeleteVertexArrays
C3DCoreProfileMapBufferRange
C3DCoreProfileFlushMappedBufferRange
C3DCoreProfileUnmapBufferRange
C3DCoreProfileSetPatchControlPointCount
DrawNodesPass
DrawNodeDefault
out0.attachmentType == TextureAttachmentType::Color || out0.attachmentType == TextureAttachmentType::Depth
_cullingContext.scene
visibleElements
*texcoord_io_index < kSCNTexcoordCount
normals
indexRedirection[index] <= index
index>0
indexes[index] < count - weldCount
offset == weldCount
elementDataWrt[index] < count - weldCount
((uint16_t*)elementDataWrt)[index] < count - weldCount
((uint32_t*)elementDataWrt)[index] < count - weldCount
SCNPreferredRenderingAPIKey
SCNPreferredDeviceKey
SCNPreferLowPowerDeviceKey
PrefersOpenGL
PrefersLowPowerGPU
com.apple.sceneKit.preferLowPowerDevice
com.apple.sceneKit.preferRemovableDevice
ibPreferredRenderingAPI
ibWantsMultisampling
temporalAntialiasingEnabled
allowsCameraControl
backgroundColor
ibSceneName
background.contents
kSCNViewObservingContext
com.apple.sceneKit.forceSeparateWorkGroup
SceneKit - SCNView Draw
SCNView::setAsynchronousLoading is deprecated
Can't set an OpenGL context on a Metal-based SCNView
antialiasingMode
NSScreenNumber
vehicle
wheelIndex
suspensionStiffness
suspensionCompression
suspensionDamping
maximumSuspensionTravel
frictionSlip
maximumSuspensionForce
connectionPosition
steeringAxis
axle
radius
suspensionRestLength
isFront
C3DCullingSystem
cullingSystem
handle >= 0 && ((uint32_t)handle < cullingSystem->_handles.size())
<C3DCullingSystem %p>
handle >= 0 && ((uint32_t)handle < _handles.size())
indexToRemove < _count
_currentPass->mainPassUsesSpecificClearColor(NULL)
MainPassCustomPostProcessPass
!line.empty()
IESNA:LM-63-1995
IESNA91
IESNA:LM-63-2002
TILT=NONE
TILT= NONE
TILT =NONE
TILT = NONE
TILT=
TILT =
anglesCount > 0
start != index
end != index - 1
x < anglesNumH
y < anglesNumV
width > 0 && height > 0
channelCount == 1 || channelCount == 4
channelSize == 1 || channelSize == 2 || channelSize == 4
C3DLegacyProfileVertexAttribDivisor
C3DGL_macOS_LegacyProfile.c
C3DLegacyProfileBlitFramebuffer
C3DLegacyProfileBindVertexArray
C3DLegacyProfileGenVertexArrays
C3DLegacyProfileDeleteVertexArrays
C3DLegacyProfileMapBufferRange
C3DLegacyProfileUnmapBufferRange
_lastRatio
_scaleTarget
_scaleTargetReversed
_deltaScale
_isReversed
uniform
#pragma opaque
#pragma transparent
#pragma declaration
#pragma arguments
#pragma varyings
#pragma body
scn_node
scn_frame
<null>
<%@ %@>
_duration
_timingMode
_beginTime
_pausedTime
_isRunning
_finished
SCNActionCacheKey
SCNRendererOffscreenSampleCount
transition pass
[privateRendererOwner isKindOfClass:[SCNView class]] || [privateRendererOwner isKindOfClass:[SCNLayer class]] || [privateRendererOwner isKindOfClass:[SCNMetalLayer class]]
com.apple.scenekit.renderingQueue.%@%p
[(id)context conformsToProtocol:@protocol(MTLDevice)]
<%@ %p: scene = %@, pointOfView = %@, sceneTime = %f, context = %p>
SceneKit - Delete Framebuffer
_renderingAPI == SCNRenderingAPIMetal
_shouldDeleteFramebuffer == NO
_isPrivateRenderer
SceneKit - Create Framebuffer
[pov isPresentationInstance] == 0
camera.xFov
camera.yFov
camera.fieldOfView
camera.orthographicScale
camera.lensShift
camera.postProjectionTransformTranslation
camera.postProjectionTransformScale
camera.
_recordWithoutExecute
_glContext!=NULL
c8@?0
com.apple.scenekit.prepareQueue.%@%p
SCNRenderer.m
We should have an engine context at this stage
No C Scene associated with %@
Metal implementation not done
SpriteKit - Draw Overlay
SceneKit - Flush
_isViewPrivateRenderer
-[SCNRenderer _drawSceneWithLegacyRenderer:]
[_renderContext isKindOfClass:[SCNMTLRenderContext class]]
self.scene
shBuffer.length == ((shOrder * shOrder) * 3 * sizeof(float))
SceneKit - Jitter
-[SCNRenderer _addGPUFrameScheduledHandler:]
-[SCNRenderer _addGPUFrameCompletedHandler:]
-[SCNRenderer _addGPUFramePresentedHandler:]
-[SCNRenderer _discardPendingGPUFrameScheduledHandlers]
-[SCNRenderer _discardPendingGPUFrameCompletedHandlers]
-[SCNRenderer _discardPendingGPUFramePresentedHandlers]
-[SCNRenderer _allowGPUBackgroundExecution]
info->frameBuffer == NULL
info->multisamplingFrameBuffer == NULL
vecSize.x > 0.0 && vecSize.y > 0.0
SCN_ENABLE_COLLECTION
scenekit.fps
scenekit.primcnt
scenekit.frmtime
scenekit.phytime
scenekit.prttime
scenekit.animtime
scenekit.clientTime
scenekit.consttime
scenekit.rendertime
scenekit.cpuidletime
scenekit.cawaittime
scenekit.deviceutil
scenekit.rendererutil
scenekit.tilerutil
IOAccelerator
PerformanceStatistics
__scnPerformanceData
v24@?0{_CSTypeRef=QQ}8
scenekit.shaderCompilationTime
scenekit.shaderGenerationCount
Device Utilization %
Renderer Utilization %
SceneKitShaderCache
com.apple.sceneKit.traceResources
containerPath
commonProfile_
metal
can't create symbolicator for pid
__scnDebuggingInfo
can't find symbol __scnDebuggingInfo
can't mmap memory for symbol __scnDebuggingInfo
can't get mem rangefor symbol __scnDebuggingInfo
failed to read memory for symbol __scnDebuggingInfo
applicationContainerPath not set
_buffer
<%@: %p> "%@"
<state: %@>
FrameBuffer bindings:
Node bindings:
Pass bindings:
Shadable bindings:
Light bindings:
stage < kC3DFXMetalProgramStageCount
_vertexDescriptor
<SCNMTLMesh: %p
buffer[%d] : %@
element[%d] : %@
<SCNMTLMeshElement: %p | type: %d, index buffer: %@ (%d indices), indirect buffer: %@, effective count: %d, offset: %d>
<SCNMTLMeshElement: %p | type: %d, index buffer: %@ (%d indices), effective count: %d, offset: %d>
axisA
axisB
anchorA
anchorB
minLinearLimit
maxLinearLimit
minAngularLimit
maxAngularLimit
motorTargetLinearVelocity
motorMaximumForce
motorTargetAngularVelocity
motorMaximumTorque
_posTarget.x
_posTarget.y
_posTarget.z
_posTargetReversed.x
_posTargetReversed.y
_posTargetReversed.z
_posStart.x
_posStart.y
_posStart.z
entityID
basic
keyframe
group
class
keyPath
animation-players
animation-keys
sourceObject
keyPathSrc
keyPathDst
bindings
/Contents/Resources/
imageNamed
imageNamed://
MDLSkyCubeTexture
imageNamed://%@
turbidity
sunElevation
upperAtmosphereScattering
groundAlbedo
horizonElevation
gamma
exposure
brightness
channelEncoding
dimensions.x
dimensions.y
highDynamicRangeCompression.x
highDynamicRangeCompression.y
groundColor
<%@: %p
    "%@" = "%@"
flatness
deformer_variabletopologysample_any_order
dataKind == kC3DMeshDataKindOriginal
C3DMeshElementGetType(meshElement) == kC3DMeshElementTypeTrianglesArray
deformer_variabletopologysample_any_order_finalize
UInt%d-UInt%d
v32@?0@"SCNGeometryVariableTopologySampleDeformerMeshElementData"8Q16*24
Variable topology sample deformer
SCNAnimationCommitOnCompletion
SCN_CAKeyframeAnimation %p (duration=%f, keyPath:%@)
c3dAnimation
commitsOnCompletion
removedOnCompletion
CAKeyframeAnimation based on CGPath are not supported
CFTypeIsC3DEntity(rootCF)
SCNAnimationAnimatesUsingSceneTimeKey
SCNAnimationFadeInDurationKey
SCNAnimationFadeOutDurationKey
SCNAnimationEventsKey
c3dTimingFunction
_animationEvents == NULL
c3dAnimationType
applyOnCompletion
fillForward
fillBackward
userInfo
failed to archive animation's userinfo. %@ %@
appliedOnCompletion
scna
<%@: %p, keyPath=%@ duration=%f repeatCount=%f>
weight
<SCNAnimationPlayer(%p) animation=%@>
q24@?0@"SCNAnimationEvent"8@"SCNAnimationEvent"16
C3DDeformerStack
<C3DDeformerStack %p>
<C3DDeformerStack %p (geometry: %p)
  morpher: %p
  %@: %p
  skinner: %p
v40@?0Q8@"SCNNode"16Q24*32
geometryMemory
textureMemory
SCNSceneSourceUseModelIOToLoadDAEFiles
kSceneSourceCacheScenesByURLKey
kSceneSourceSceneIndexKey
kSceneSourceForceMorphNormals
SCNSceneSourceLoadTexturesInCPUMemory
kSceneSourceFormat
SCNSceneSourceInputSource
SCNSceneExportDestinationURL
SCNSceneExportUTIKey
SCNSceneExportCompressGeometryElements
SCNSceneExportCompressMorphTargets
SCNSceneExportEmbedImages
SCNSceneExportEmbedReferences
SCNSceneExportPresentationTree
[SCNSceneSource scenesSourceWithURL:] nil URL
<%@: %p | URL='%@'>
The document "%@" could not be opened.
The document data could not be read.
v32@?0f8i12^{__CFError=}16^B24
v36@?0f8q12@"NSError"20*28
@16@?0^v8
bplist
VertexCache
C3DMeshElement_Tools.cpp
cacheSize < kMaxCacheSize
textureCoordinate is deprecated - use textureCoordinateWithMappingChannel instead
<%@: %p <%f,%f,%f> | geometryIndex=%d node=%@ bone=%@>
invalid wrapS value: %d
invalid wrapT value: %d
_contentType != SCNContentTypeLayer && _contentType != SCNContentTypeSKScene
SKScene
SKTexture
GLKTextureInfo
AVPlayer
AVCaptureDevice
-[SCNMaterialProperty setContentsTransform:]
<%@: %p | contents=%@>
<data %p>
parent == _parent
attachment == NULL || [(id) attachment isKindOfClass:[SCNMaterialAttachment class]]
imageArray
skscene
sktexture
textureComponents
attachment
isCommonProfileProperty
propertyType
customSlotName
sRGB
.<>?:/|&^*/+-=%!~
String
a_vertexColor
a_TexTangent
a_diffuseTexcoord
a_ambientTexcoord
a_specularTexcoord
a_emissionTexcoord
a_filterTexcoord
a_transparentTexcoord
a_normalTexcoord
a_lightmapTexcoord
u_cameraPosition
u_nodeOpacity
u_skinningJointMatrices
u_materialShininess
u_ambientColor
u_ambientIntensity
u_ambientTexture
u_ambientTextureMatrix
u_diffuseColor
u_diffuseIntensity
u_diffuseTexture
u_diffuseTextureMatrix
u_specularColor
u_specularIntensity
u_specularTexture
u_specularTextureMatrix
u_emissionColor
u_emissionIntensity
u_emissionTexture
u_emissionTextureMatrix
u_multiplyColor
u_multiplyIntensity
u_multiplyTexture
u_multiplyTextureMatrix
u_transparency
u_transparentColor
u_transparentIntensity
u_transparentTexture
u_transparentTextureMatrix
u_normalTexture
u_normalIntensity
u_normalTextureMatrix
u_shininessTexture
u_shininessTextureMatrix
u_lightmapTexture
u_reflectiveColor
u_reflectiveIntensity
u_reflectiveTexture
u_reflectiveTextureMatrix
u_fresnel
u_ambientLightColor
u_shCoefficients
u_fogColor
u_fogParameters
u_light%d_attenuation
u_light%d_spotAttenuation
u_light%d_color
u_light%d_position
u_light%d_direction
u_light%d_up
u_light%d_right
u_light%d_gobo
u_light%d_goboMatrix
u_light%d_goboIntensity
u_light%d_iesMatrix
u_light%d_iesTex
u_light%d_shadow
u_light%d_shadowMatrix
u_light%d_shadowRadius
u_light%d_shadowColor
u_zRange
u_orientationPreserved
C3DLibrarySubStorage
uniqueID
documentIDRef
documentID
<C3DLibrarySubStorage>
C3DLibrary
<C3DLibrary>
object == lib
library->_storage
entryToSerializedData
lib->_entries
C3DParticleManager
ParticleSystem_MeshElement
C3D-ParticleSystem_Trail
C3D-ParticleSystem
C3D-ParticleSystem_PointSprite
%@%1d%1d%c%c%c%c%c%c%c%c%c%c%c%1dO%1d%c%c
enableLighting
enableColorRamp
enableCubeMap
enableStretch
enableAnimation
enableFog
enableMultipleViewport
enableLayeredRendering
useVertexAmplification
eyeCount
ARMode
animationMode
uberparticle_stereo_vert
uberparticle_vert
uberparticleCube_frag
uberparticle_frag
.vsh
.fsh
#define mediump 
#define ENABLE_LIGHTING
#define ENABLE_COLOR_RAMP
#define ENABLE_CUBE_MAP
#define ENABLE_STRETCH
#define ENABLE_BILLBOARD_VIEW
#define ENABLE_ORIENTATION_FREE
#define ENABLE_BILLBOARD_Y
#define ENABLE_BILLBOARD_SCREEN
#define ENABLE_FOG
#define ENABLE_ANIMATION %d
#define ENABLE_SOFT
BlackPass
viewTransform
u_viewToCubeWorld
u_fresnelExponent
u_lightPosition0
u_lightColor0
u_colorRamp
u_stretchFactor
u_frameSize
u_softParameters
u_invProj
u_depthSampler0
u_projectionTransform
u_textureSampler0
<C3DParticleManagerRef>
cullingContext
CFGetTypeID(instance) == C3DParticleSystemInstanceGetTypeID()
pass
index < technique->_count
symbolName
technique->_parameterStorage == NULL || technique->_parameterStorage->storage == NULL
CFDictionaryGetValue(technique->_parameterStorage->parameters, symbolName) == 0
paramName
count == 1
technique->_isCompiled==false
bundle
metalLibraryName
sequence
passes
symbols
metalLibraryFile
metalVertexShader
metalFragmentShader
clientProgram
inputs
owners
outputs
subtechnique
C3DFXDefault_velocity.plist
C3DFXDefaultPass.plist
C3DFXTechnique
<C3DFXTechnique>
pass %d
plist
targets
sourcePass->_inputCount == dstPass->_inputCount
!dstPass->_customInitializeBlock
!dstPass->_customExecuteBlock
self
kPrimitiveGenerateMappingCoordinates
kPrimitiveVertexTransformation
kPrimitiveWidthSegments
kPrimitiveHeightSegments
kPrimitiveLengthSegments
kPrimitiveChamferSegments
kPrimitiveRotationSegments
kPrimitiveCapSegments
kPrimitiveRingSegments
kPrimitivePipeSegments
kPrimitiveSphereType
kPrimitiveSphereSegments
kPrimitiveTypeSphere
kPrimitiveTypeGeosphere
widthSegmentCount
heightSegmentCount
lengthSegmentCount
chamferSegmentCount
segmentCount
radialSegmentCount
ringSegmentCount
pipeSegmentCount
-[SCNFloor setReflectionResolutionScaleFactor:]
-[SCNFloor setReflectionCategoryBitMask:]
-[SCNFloor setWidth:]
-[SCNFloor setLength:]
-[SCNFloor setReflectionFalloffEnd:]
reflectionFalloffEnd
-[SCNFloor setReflectionFalloffStart:]
reflectionFalloffStart
-[SCNFloor setReflectionSampleCount:]
-[SCNFloor setReflectivity:]
reflectionCategoryBitMask
reflectionResolutionScaleFactor
include
C3DTokenizer.hpp
mpSource
C3DFloor
<C3DFloor>
_C3DFloorInitWithPropertyList
resolutionScaleFactor
reflectionBitMask
indicesCount >= 3
vertexIndex < originalVertexCount
perVertexTriangleCount[vertexIndex] > 0
perVertexTriangleCount[weldedVertexIndex] == 0
unify_u16
unify_u32
v32@?0@"SCNPhysicsVehicleWheel"8Q16*24
wheel
chassisBody
wheels
-[SCNGeometry setName:]
%@: %p '%@'
%@: %p
 | %d elements
<%@>
geometrySourceForSemantic is deprecated - use geometrySourcesForSemantic instead
-[SCNGeometry setBoundingBoxMin:max:]
index < [_materials count]
materials[
q24@?0@8@16
-[SCNGeometry _shadableSetValue:forUndefinedKey:]
-[SCNGeometry setShaderModifiers:]
-[SCNGeometry copyShaderModifiersAndLanguageVersionFrom:]
-[SCNGeometry setMinimumLanguageVersion:]
-[SCNGeometry setProgram:]
subdivisionLevel
wantsAdaptiveSubdivision
edgeCreasesSource
edgeCreasesElement
subdivisionSettings
tessellator
SCNErrorDomain
v16@?0@"NSTimer"8
C3DMeshElementTypeDefinesTopology(meshType)
_layerRoot
_overlayLayerRoot
_lightRoot
_cameraRoot
_particlesRoot
_physicsFieldRoot
_pointsOfViewRoot
Perspective
Bottom
Left
Right
Front
Back
_authoringCamera%s
lightAuth
particlesAuth
cameraAuth
cameraFrustumAuth
cameraNearPlaneAuth
fieldAuth
SCNDebugLightTypeKey
SCNDebugLightSubTypeKey
lightInnerAuth
lightOuterAuth
lightArrowAuth
lightShadowAuth
lightSpotAuth
probeGeometry
lightProbeExtents
scn_probesphere_from_sh_vertex
scn_probesphere_from_sh_fragment
v40@?0@"<SCNBufferStream>"8@"SCNNode"16@"<SCNShadable>"24@"SCNRenderer"32
lightAreaAuth
disabled
oa:%f ia:%f s:%f e:%f
AuthEnvHash
sourceShape
metallib
com.apple.scenekit.device
scenekit
Q8@?0
@"<MTLLibrary>"8@?0
com.apple.scenekit.shader-collection-queue
commonProfile_%@.metal
v16@?0@"NSString"8
v24@?0@"NSString"8@"NSString"16
v24@?0@"NSString"8*16
v24@?0@"<MTLLibrary>"8@"NSError"16
^(.*)$
program_source:([0-9]+):[0-9]+:\s(.+):\s(.+)$
^<program source>:([0-9]+):[0-9]+:\s(.+):\s(.+)$
\[SCN_(\w+)\((\d+)\)\]
Geometry
Surface
Fragment
LightingModel
texture1D
texture2D
textureCube
texture3D
SCNShaderLightDecl.glsl
float __shadow2DProj(sampler2DShadow tex, vec4 coord) {return textureProj( tex, coord );}
float __shadow2DProj(sampler2DShadow tex, vec4 coord) {return shadow2DProj( tex, coord ).x;}
uniform vec4 u_shadowKernel[%d];
SCNShaderSurfaceDecl.glsl
USE_EMISSION_AS_SELFILLUMINATION
    vec2 %@Texcoord;
    _surface.%@Texcoord = v_texcoord%d;
} _surface;
varying vec2 v_texcoord%d;
uniform mat4 u_%@TextureMatrix;
v_texcoord%d = (u_%@TextureMatrix * vec4(_geometry.texcoords[%d], 0., 1.)).xy;
v_texcoord%d = _geometry.texcoords[%d];
NEED_IN_TEXCOORD%d
C3D-UberShader.vsh
SCNShaderGeometryDecl.glsl
struct SCNShaderLightingContribution {vec3 ambient; vec3 diffuse; vec3 specular; vec3 modulate;} _lightingContribution;
u_modelViewTransform
SEPARATE_PROJECTION
u_normalTransform
__DoTexcoord__
#define kSCNTexcoordCount %ld
MAX_BONE_INFLUENCES
__DoLighting__
varying
C3D-UberShader.fsh
u_light%hu
    SCNShaderLight _light;
    _light.intensity = vec4(1.);
uniform vec4 %@_color;
    _light.intensity = %@_color;
uniform vec4 %@_direction;
    _light.direction = %@_direction.xyz;
uniform vec4 %@_position;
    vec3 _D = %@_position.xyz - _surface.position;
    _light.dist = length(_D);
    _light.direction = _D / _light.dist;
    _light.direction = normalize(%@_position.xyz - _surface.position);
    _light.dir = %@_direction.xyz;
//Unsupported
    _light._att = 1.;
uniform vec4 %@_attenuation;
    vec3 _att = %@_attenuation.xyz;
    _light._att *= step(_light.dist, _att.x);
    _light._att *= clamp(_light.dist * _att.x + _att.y, 0.0, 1.0);
    float _dstatt = clamp(_light.dist * _att.x + _att.y, 0.0, 1.0);
    _light._att *= (_dstatt  * _dstatt);
    _light._att *= pow(clamp(_light.dist * _att.x + _att.y, 0.0, 1.0), _att.z);
uniform vec4 %@_spotAttenuation;
    vec3 _spot = %@_spotAttenuation.xyz;
    _light._att *= step(_spot.x, dot(_light.direction, _light.dir));
    _light._att *= clamp(dot(_light.direction, _light.dir) * _spot.x + _spot.y, 0.0, 1.0);
    float _sptatt = clamp(dot(_light.direction, _light.dir) * _spot.x + _spot.y, 0.0, 1.0);
    _light._att *= _sptatt * _sptatt;
    _light._att *= pow(clamp(dot(_light.direction, _light.dir) * _spot.x + _spot.y, 0.0, 1.0), _spot.z);
uniform sampler2DShadow %@_shadow;
uniform mat4 %@_shadowMatrix;
uniform float %@_shadowRadius;
    float _shadowingTerm = 0.0;
    vec4 _lightScreen = (%@_shadowMatrix * vec4(_surface.position, 1.));
    float _filteringSizeFactor = %@_shadowRadius * _lightScreen.w;
    for(int i=0; i < %d; i++){
        _shadowingTerm += __shadow2DProj(%@_shadow, _lightScreen + (u_shadowKernel[i] * _filteringSizeFactor));
    }
    _shadowingTerm /= float(%d);
    float _shadowingTerm = __shadow2DProj(%@_shadow, (%@_shadowMatrix * vec4(_surface.position, 1.)));
uniform vec4 %@_shadowColor;
    _light._att *= (1. - _shadowingTerm * %@_shadowColor.a);
    _light._att *= (1. - _shadowingTerm);
uniform sampler2D %@_gobo;
uniform mat4 %@_goboMatrix;
uniform float %@_goboIntensity;
    _light.intensity *= mix(vec4(1.), texture2DProj(%@_gobo, (%@_goboMatrix * vec4(_surface.position, 1.))), %@_goboIntensity);
    _light.intensity *= %@_goboIntensity * texture2DProj(%@_gobo, (%@_goboMatrix * vec4(_surface.position, 1.)));
modCode
    _lightingContribution.modulate *= _light._att * _light.intensity.rgb;
    _light.intensity.rgb *= _light._att * max(0.0, dot(_surface.normal, _light.direction));
    _lightingContribution.diffuse += _light.intensity.rgb;
    vec3 _R = reflect(-_light.direction, _surface.normal);
    _lightingContribution.specular += pow(max(0.0, dot(_R, _surface.view)), _surface.shininess) * _light.intensity.rgb;
    vec3 _halfVector = normalize(_light.direction + _surface.view);
    _lightingContribution.specular += pow(max(0.0, dot(_surface.normal, _halfVector)), _surface.shininess) * _light.intensity.rgb;
  vec4 %@;
uniform %@ %@;
skinnedMesh
C3DMeshGetSourceWithSemanticAtIndex(skinnedMesh, kC3DMeshSourceSemanticSkinningJoints, 0, kC3DMeshDataKindRenderable)
C3DMeshGetSourceWithSemanticAtIndex(skinnedMesh, kC3DMeshSourceSemanticSkinningWeights, 0, kC3DMeshDataKindRenderable)
joint
needPrepare == false
skinner->_meshIsCPUReady
C3DMeshSourceIsMutable(C3DMeshGetPositionSource(skinnedMesh, kC3DMeshDataKindRenderable))
!C3DMeshGetNormalSource(skinnedMesh, kC3DMeshDataKindRenderable) || C3DMeshSourceIsMutable(C3DMeshGetNormalSource(skinnedMesh, kC3DMeshDataKindRenderable))
calculationMode == kC3DSkinnerCalculationModeGPUComputeKernel || skinner->_meshIsGPUVertexReady
currentPositionSource && currentPositionSource != originalPositionSource
C3DMeshSourceIsMutable(currentPositionSource)
currentNormalSource != originalNormalSource
C3DMeshSourceIsMutable(currentNormalSource)
Loose
_DYN
ownerNode
%@ - Skinned
C3DSkinner
<C3DSkinner %p skeleton:%p jointCount:%d cpuReady:%d gpuReady:%d
  skin:%p skinnedMesh:%p calcMode:%d
  JointBbox[%d] {%f,%f,%f} {%f,%f,%f}
skeletonID
skinID
skeleton
meshCreated
bboxDirty
verticesJointsMatrices[%d]
normalsJointsMatrices[%d]
MBFinalBlurPass
VELOCITY
MB-TileMax
scn_draw_fullscreen_triangle_VR_pos_uv_uvNorm_vertex
scn_motionblur_blur
scn_motionblur_blur_resize
SCNMaterialPropertyTextureProviderHelper could not find texture for %@
scnComputeEncoder->isEncoding()
v16@?0@?<v@?@"<MTLComputeCommandEncoder>">8
scnBlitEncoder->isEncoding()
v16@?0@?<v@?@"<MTLBlitCommandEncoder>">8
v16@?0@?<v@?@"<MTLCommandBuffer>">8
SSAOUpSamplePass
scn_ssao_upsampling
_hide
CIFilterPass
outputTex
CIFilterDrawNodesPass
_allocator
sequence->count + count <= sequence->allocatedCount
skinCompressedData.count == 1
r <= C3DSkinGetWeightsCount(skin)
w == numberOfInfluence * vertexCount
baseGeometry
baseGeometryBindTransform
bones
compressedSkinData
boneWeights
boneIndices
baseGeometryBindTransform-%d
 %f %f %f %f
skin->_inverseBindMatrices
count == dstJoints.count && (!dstWeights.ptr || (count == dstWeights.count))
C3DSkinFillJointWeightsBuffers
C3DSkin
<C3DSkin %p name:%@ joint:%d weight:%d vertexCount:%d
  maxInf:%d morpher:%p
defaultShapeMatrix
inverseBindMatrix
_C3DSkinInitWithPropertyList
jointsCount
maxInfluences
inverseBindMatrices
defaultShapeMatrix
baseMeshID
weightsCount
vertexWeightIndices
jointsForVertexWeights
vertexWeights
maxInfluencesPerVertex
influencingMorpher
vertexWeightIndices[%d]
vertexWeights[%d]
jointsForVertexWeights[%d]
C3DIONSZipFileArchiveHeaderOffset
C3DIONSZipFileArchiveCompressionType
C3DIONSZipFileArchiveCRC
C3DIONSZipFileArchiveCompressedLength
C3DIONSZipFileArchiveUncompressedLength
1.2.12
C3DFXFloorPass.plist
SceneKit_renderMirroredScene
SceneKit_renderFloor
u_floorReflectionColor
SceneKit-floor-color-%p
u_floorReflectionDepth
SceneKit-floor-depth-%p
u_floorNormal
u_floorTangent
u_floorCenter
u_floorExtent
u_floor_viewport
u_floorReflectivity
u_floorFalloffStart
u_floorFalloff
u_floorPlane
u_floorMVP_i
d > 0
FloorGeomImpl.glsl
FloorGeomImpl-metal.h
USE_FALLOFF
USE_FALLOFF_START
FloorImpl.glsl
FloorImpl-metal.h
_C3DSourceAccessorInitWithPropertyList
accessor->_source->_dataIsVolatile
C3DSourceAccessor
<C3DSourceAccessor %lx>
componentsCountPerValue
__allocateChunk
C3DStackAllocator.cpp
chunk
chunk->data
C3DStackAllocator
allocator->_framesCount > 0
C3DStackAllocatorAllocateAligned
allocator->_currentChunck
<C3DStackAllocator>
SSAOBlurPass-Y
SSAOBlurPass-X
scn_ssao_blur_y
scn_ssao_blur_x
<C3DGenericSource %lx>
_C3DGenericSourceInitWithPropertyList
(numberType == kCFNumberFloatType) || (numberType == kCFNumberFloat32Type)
!genericSource->_dataIsVolatile
genericSource->_mtlVertexFormat == 0
genericSource->_dataIsVolatile
C3DSourceAccessorGetSource(accessor) == (C3DGenericSourceRef) genericsource
listener
C3DGenericSource
SCNMaterialData
debug_frag
debug_vert
debug_post_tessellation_vert
debug_isolate_frag
v32@?0@8@"NSMapTable"16*24
C3DMeshSourceIsVolatile(meshSource) != true
attribute != kC3DVertexAttrib_None
[metalMesh.buffers indexOfObject:buf] != NSNotFound
dataSize == buf.length
textureMatrix
Unable to find texture for binding %@ ("%@") and effect slot %@ derived from value %@ (geometry=%@, material=%@)
v32@?0@8@"SCNMTLDeformerStack"16*24
DeferredShadowPass
SceneKit-spotShadowDepth-
enableARMode
deferredShadow_VR_vert
caff
aiff
volume
rate
reverbBlend
positional
shouldStream
C3DResourceCache
resourceCache
cache
resource
<C3DResourceCache 0x%lx>
AnimationGroup
C3DAnimationGroup
<C3DAnimationGroup %p animations:%@>
channels
targetPath
subAnimations
 point(%f %f %f)
 normal(%f %f %f)
 impulse(%f)
 distance:%f
!_node || _body == 0
mass
charge
friction
restitution
rollingFriction
ccdThreshold
physicsShape
damping
angularVelocity
angularDamping
linearRestingThreshold
angularRestingThreshold
velocityFactor
angularVelocityFactor
velocity
ignoreGravity
explicitMomentOfInertia
momentOfInertia
centerOfMassOffset
contactTestBitMask
allowsResting
isDefaultShape
linearSleepingThreshold
angularSleepingThreshold
v40@?0q8q16q24q32
v24@?0d8f16f20
v28@?0f8f12f16f20f24
-[SCNPlane setCornerRadius:]
cornerRadius
-[SCNPlane setCornerSegmentCount:]
cornerSegmentCount
-[SCNPlane setHeight:]
-[SCNPlane setHeightSegmentCount:]
-[SCNPlane setPrimitiveType:]
-[SCNPlane setWidth:]
-[SCNPlane setWidthSegmentCount:]
<%@ | width=%.3f height=%.3f>
primitiveType
-[SCNBox setChamferRadius:]
chamferRadius
-[SCNBox setChamferSegmentCount:]
-[SCNBox setHeight:]
-[SCNBox setHeightSegmentCount:]
-[SCNBox setLength:]
-[SCNBox setLengthSegmentCount:]
-[SCNBox setPrimitiveType:]
-[SCNBox setWidth:]
-[SCNBox setWidthSegmentCount:]
<%@ | width=%.3f height=%.3f length=%.3f chamferRadius=%.3f>
boxwidth
boxheight
boxlength
boxchamferRadius
boxwidthSegmentCount
boxheightSegmentCount
boxlengthSegmentCount
boxchamferSegmentCount
boxprimitiveType
-[SCNPyramid setHeight:]
-[SCNPyramid setHeightSegmentCount:]
-[SCNPyramid setLength:]
-[SCNPyramid setLengthSegmentCount:]
-[SCNPyramid setPrimitiveType:]
-[SCNPyramid setWidth:]
-[SCNPyramid setWidthSegmentCount:]
<%@ | width=%.3f height=%.3f length=%.3f>
pyramidwidth
pyramidheight
pyramidlength
pyramidwidthSegmentCount
pyramidheightSegmentCount
pyramidlengthSegmentCount
pyramidprimitiveType
-[SCNSphere setGeodesic:]
-[SCNSphere setHemispheric:]
-[SCNSphere setPrimitiveType:]
-[SCNSphere setRadialSpan:]
radialSpan
-[SCNSphere setRadius:]
-[SCNSphere setSegmentCount:]
<%@ | radius=%.3f>
sphereradius
sphereradialSpan
spheresegmentCount
sphereprimitiveType
spheregeodesic
spherehemispheric
-[SCNCylinder setHeight:]
-[SCNCylinder setHeightSegmentCount:]
-[SCNCylinder setPrimitiveType:]
-[SCNCylinder setRadialSegmentCount:]
-[SCNCylinder setRadialSpan:]
-[SCNCylinder setRadius:]
<%@ | radius=%.3f height=%.3f>
cylinderradius
cylinderheight
cylinderradialSpan
cylinderheightSegmentCount
cylinderradialSegmentCount
cylinderprimitiveType
-[SCNCone setBottomRadius:]
bottomRadius
-[SCNCone setHeight:]
-[SCNCone setHeightSegmentCount:]
-[SCNCone setPrimitiveType:]
-[SCNCone setRadialSegmentCount:]
-[SCNCone setTopRadius:]
topRadius
<%@ | topRadius=%.3f bottomRadius=%.3f height=%.3f>
conetopRadius
conebottomRadius
coneheight
coneheightSegmentCount
coneradialSegmentCount
coneprimitiveType
-[SCNTube setHeight:]
-[SCNTube setHeightSegmentCount:]
-[SCNTube setInnerRadius:]
innerRadius
-[SCNTube setOuterRadius:]
outerRadius
-[SCNTube setPrimitiveType:]
-[SCNTube setRadialSegmentCount:]
-[SCNTube setRadialSpan:]
<%@ | innerRadius=%.3f outerRadius=%.3f height=%.3f>
tubeinnerRadius
tubeouterRadius
tubeheight
tuberadialSpan
tubeheightSegmentCount
tuberadialSegmentCount
tubeprimitiveType
-[SCNCapsule setCapRadius:]
capRadius
-[SCNCapsule setCapSegmentCount:]
capSegmentCount
-[SCNCapsule setHeight:]
-[SCNCapsule setHeightSegmentCount:]
-[SCNCapsule setPrimitiveType:]
-[SCNCapsule setRadialSegmentCount:]
<%@ | capRadius=%.3f height=%.3f>
capsulecapRadius
capsuleheight
capsuleheightSegmentCount
capsuleradialSegmentCount
capsulecapSegmentCount
capsuleprimitiveType
-[SCNTorus setPipeRadius:]
pipeRadius
-[SCNTorus setPipeSegmentCount:]
-[SCNTorus setPrimitiveType:]
-[SCNTorus setRadialSpan:]
-[SCNTorus setRingRadius:]
ringRadius
-[SCNTorus setRingSegmentCount:]
<%@ | ringRadius=%.3f pipeRadius=%.3f>
torusringRadius
toruspipeRadius
torusradialSpan
torusringSegmentCount
toruspipeSegmentCount
torusprimitiveType
C3DAvoidOccluderConstraintDelegate
objcConstraint
delegate
<C3DAvoidOccluderConstraintDelegate %p>
stats
srcStats && dstStats
_axisRot
_rotX
_rotY
_rotZ
_lastRotX
_lastRotY
_lastRotZ
_isAxisAngle
_isUnitArc
_qRot
SCNSceneGraphSelectedNodeDidChange
SCNKitSceneGraphView
can't load nib named : SCNKitSceneGraphView
Visibility
Bbox
local:%@ (valid:%d)
<inf. box>
<%.2f,%.2f,%.2f %.2f,%.2f,%.2f>
%@-node
[%@]-node
(N/A)
%p %@
OverlayPass
compute_sh%d_from_cubemap_threadgroup_mem
compute_sh%d_from_cubemap
sum_sh%d
-[NSData(SCNExtensions) scn_indexedDataEncodingHighWatermarkWithBytesPerIndex:]
NSData+SCNExtensions.m
-[NSData(SCNExtensions) scn_indexedDataDecodingHighWatermarkWithBytesPerIndex:]
-[NSData(SCNExtensions) scn_indexedDataEncodingDeltaWithBytesPerIndex:]
-[NSData(SCNExtensions) scn_indexedDataDecodingDeltaWithBytesPerIndex:]
Allocate
C3DScratchAllocator.cpp
last_chunk
VMAllocateChunk
!chunk->next
Cube
Equirectangular
DualParaboloid
ConvertCubePass-%sTo%s
scn_draw_fullscreen_cube
scn_draw_fullscreen_cube_no_base
scn_draw_fullscreen_cube_layered
cube
equi
dual
scn_convert_%s_from_%s_frag
SCNPhysicsShapeTypeKey
SCNPhysicsShapeKeepAsCompoundKey
SCNPhysicsShapeScaleKey
SCNPhysicsShapeCollisionMarginKey
convexHull
concaveMesh
v32@?0@"SCNPhysicsShape"8Q16*24
convexDecomposition
transformsCount
transform%d
referenceObject
options
physicsShape[%f,%f,%f]
SCNDefaultPhysicsShape
btTriangleInfoData
btTriangleInfoMapData
hasMesh == (hash != NULL)
parametricgeometry
parametricGeometry
retainCount>0
_C3DParametricGeometryCreateCacheHash_not_thread_safe
C3DParametricGeometry.c
size <= sizeof(C3DParametricGeometryType) + sizeof(C3DParametricGeometryParameters)
C3DParametricGeometry
Pyramid
Cylinder
Cone
Tube
Capsule
Torus
Sphere
Plane
<%@<%@>:%p "%@"
callBacks
retainCount != 0
CompositeARPass
renderWithViewpoints
shouldDelegateARCompositing
scn_postprocess_AR_vertex
scn_postprocess_AR_fragment
C3DDynamicBatchingSystem
dynamicBatchingSystem->_currentBatchInstancesCount == 0
<C3DDynamicBatchingSystem %p>
ScenePass
previousFilterPass
topLevelFilterNode->_hasFilter
!empty()
_bindInput
C3DGLSLProfileInterpreter.c
C3DGLSLGetUniformType
C3DGL.c
mat3
localHash.vertexDescriptorHash
v16@?0@"<MTLFunction>"8
scn_is_inside_bezier_curve
renderPipeline
v24@?0@"<MTLRenderPipelineState>"8@"NSError"16
v32@?0@"<MTLRenderPipelineState>"8@"MTLRenderPipelineReflection"16@"NSError"24
constants == nil || constantsHash != nil
stageDescriptor
needsInputTRC
needsColorMatrix
needsOutputTRC
inputTRC_type
inputTRC_gamma
inputTRC_a
inputTRC_b
inputTRC_c
inputTRC_d
inputTRC_e
inputTRC_f
colorMatrixColumn0
colorMatrixColumn1
colorMatrixColumn2
outputTRC_type
outputTRC_gamma
outputTRC_a
outputTRC_b
outputTRC_c
outputTRC_d
outputTRC_e
outputTRC_f
biPlanarTextureChromaSubsampling
biPlanarTextureYCbCrMatrix
color_matching_kernel_biplanar
color_matching_kernel
vec2(
vec3(
vec4(
type == C3DValueGetType(b)
type == C3DValueGetType(output)
C3DValue
<C3DValue %p - %@ ptr:%p >
!(xSize & (xSize-1))
!(ySize & (ySize-1))
hdr.dwFlags & DDSD_PITCH
hdr.sPixelFormat.dwRGBBitCount == 8
size == xSize * ySize * ddsInfo->_blockBytes
TemporalAA
temporal_aa
arrangedObjects
arrangedObjects.SCNUI_name
insertObject:in%@AtIndex:
removeObjectFrom%@AtIndex:
objectIn%@AtIndex:
object of class %@ doesn't implement %@
SCNUIArrayInspector
%.2f
tessellationFactorScale
maximumEdgeLength
edgeTessellationFactor
insideTessellationFactor
adaptive
screenSpace
tessellationPartitionMode
smoothingMode
<%@: %p, screen space (maximum edge length: %.3f px)>
<%@: %p, local space (maximum edge length: %.3f)>
<%@: %p, uniform (inside: %.3f, edge: %.3f)>
C3DFXSampler
<C3DFXSampler>
preferredExtensions
/System
B24@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}8^B16
nodeFromflattenedMesh
0.10
0.11
kEnclosingFolderURL
kSceneSourceInputLibrary
kC3DIOSerializationExportDelegate
kCreatePropertyListShouldZipOption
kCreatePropertyListShouldKeepReferencesToFilesOption
readerMinimumRequiredVersion
Could not get the data for the serialized property list
Could not zip the serialized property list
zippedData
zipped
meter
kIDKey
kNameKey
C3DEntityInitWithPropertyList
entity-name
entity-ID
_kvc
_cfTypeRegistry == NULL
action
propertyName
C3DEntity
<C3DEntity:%p>
CFGetRetainCount(dict) >= 2
MBTileMaxPass
scn_motionblur_tilemax
C3DEngineNotificationQueue
notificationQueue
queue
<C3DEngineNotificationQueue %p>
_fxPass
CustomPass
C3D-DefaultProgram
CFGetTypeID(program) == C3DFXGLSLProgramGetTypeID()
uniformName
channelIndex < 8
C3DFXGLSLProgram
<C3DFXGLSLProgram %p>
vertexShader
tessellationControlShader
tessellationEvaluationShader
geometryShader
fragmentShader
attributeNamesToIndexes
uniformNamesToIndexes
C3DLightGetCastsShadow(light)
ShadowMapPass
astc
cube_blur_h%d
cube_blur_v%d
CubeBlurPass
SSAOMinMaxOffsetPass
scn_ssao_downsample
channels[i] == channels[0]
C3DMeshGetElementsCount(targetMesh) == 1
morph->_calculationMode == kC3DMorpherCalculationModeAdditive
C3DMorph
<C3DMorph %p "%@"
  calc:%d morphNrm:%d targets:%ld
[%ld] weight:%f %@
_C3DMorphInitWithPropertyList
morphingType
weightsID
targetIDs
weightsData
<unnamed %d>
overallRuntimeTargetIndex == totalMorphTargetCount
dst.componentType == kC3DBaseTypeFloat
C3D-GaussianBlur
#define unshareIndex %d
#define MAX_SAMPLE %d
#define COMPONENT %c
GaussianBlur_vert
GaussianBlur_frag
C3D-blur-radiusH
C3D-blur-radiusV
C3D-blur-offsets
C3D-blur-weights
C3D-blur-samples
_C3DMorpherPrepareMorphedMesh
C3DMorpher
<C3DMorpher %p baseGeom:%p morphedMesh:%p state:%d
  morph:%@
morphID
C3DFXContext
fxContext
fxContext->_currentPassIndex<fxContext->_renderPassCount
technique->_isBeingRendered==false
pass->_drawInstruction != kC3DFXDrawScene
renderContext || rendererContextGL
<C3DFXContext>
%d - %@
 (resolve)
 (%dx)
__C3DEngineContextRenderPassInstance
C3DFXContext.m
rendererContextGL
NoName
fbo == NULL
u_inverseResolution
u_time
C3DFXContextBindFramebufferForPass
rendererGL
store
authoring-overlay
fxContext->_currentColorTarget->_referenceCount>0
fxContext->_currentDepthTarget->_referenceCount>0
enabled
!_node || _field == 0
halfExtent
strength
minimumDistance
active
scope
usesEllipsoidalExtent
exclusive
direction
smoothness
animationSpeed
SceneKit: C3DProgressDebugger fractionCompleted > 1.0
progress == nil || (progress == [NSProgress currentProgress])
progress.fractionCompleted <= 1.0
completedUnits <= units
fractionCompleted
PreFiltered Radiance
failed to load technique from dictionary: %@
-[SCNTechnique setValue:forSymbolNamed:]
valueForSymbol
C3DRendererDelegate
render
<C3DRendererDelegate %p>
C3DNotificationCenter
<C3DNotificationCenter %p>
-[SCNMorpher setName:]
<SCNMorpher %p>
weights[%d]
-[SCNMorpher setWeight:forTargetAtIndex:]
oldTargetsAndInBetweens.count == targetsAndInBetweens.count
_correctivesAndInBetweens.count == correctivesAndInBetweens.count
inBetweenIndex < targetsAndInBetweens.count
inBetweenWeights.count == inBetweenCountValidation
q24@?0@"NSNumber"8@"NSNumber"16
-[SCNMorpher setCalculationMode:]
v32@?0^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}8^{__C3DMeshSource=}16^{__C3DMeshSource=}24
weights[
-[SCNMorpher setValue:forUndefinedKey:]
weightID
useSparseTargets
inBetweenCounts
inBetweenInfluenceWeights
correctives
correctiveDriverCounts
correctiveDriverIndices
correctiveInBetweenCounts
correctiveInBetweenInfluenceWeights
shouldMorphNormals
channelTargetCounts
channelTargetWeights
range.location + range.length <= targets.count
token->sceneRef == scene
DownSampleBloomCoCPass
downsample_2x_bloom
downsample_2x_dof
downsample_2x_bloom_dof
downsample_4x_bloom
downsample_4x_dof
downsample_4x_bloom_dof
SceneKit-CI-effect-depth-
C3D-CIFilter_reverseZ
SceneKit-CI-effect-depth
C3DFXCIFilterPassMetalRenderGraph.json
%@%p
_freeIndices.count > 0
firstFreeIndex != NSNotFound
(offset % _elementSize) == 0
mtlBuffer.offset != NSNotFound
length <= _elementSize
C3DProgramHashCode
textureType < 7
index < C3D_MAX_TEXCOORD
programHashCode->_desc.effectSlotsHash[i] <= ((1 << (kC3DEffectSlotHashIndexMax + 1)) - 1)
com.apple.scenekit.programHashCodeQueue
CFDictionaryContainsKey(s_ProgramHashCodeDictionary, programHashCode->_hashCodeHash)
programHashCode->_hashCodeHash
<C3DProgramHashCode %p : 
SM_Mat,
SM_Geo,
SM(%@),
Aone,
Acst,
opq,
tgt,
lgh,
amb,
prob,
fog,
dynB,
pntR,
Constant
Lambert
Phong
Blinn
ShadowOnly
[%@:
PerPix|
Double|
OverLght|
WrNrm|
Nrmliz|
WriteDepth|
LinDepth|
LockAmb|
TrspA
TrspRGB
TrspSL
TrspDL
[Node:
skn(%d)|
LightMap|
VrtCol|
Tess|
PNTriangles|
Phong|
OSD|
SingleCrease|
ScreenSpace|
PrimvarData=%d|
AmbientOcclusion
SelfIllumination
Tex|
rgb0|
rgb1|
flt0|
texA|
int|
comp|
mat|
(1D)
(2D)
(3D)
(Cube)
[Lighting:
Soft(%d)
JitteringPass
pingPongTex
scn_jittering_color_attachment
scn_jittering_texture
scn_jittering_color_attachment_drawable
scn_jittering_texture_drawable
DOFDownsampleCoCPass
dof_coc_downsample4
RenderRadianceTo%sPass
scn_radiance_%s_%s_frag
MainPass
retainCount >= 0
JSValue
toVector4
toVector3
toTransform3D
valueWithVector3:inContext:
valueWithVector4:inContext:
valueWithTransform3D:inContext:
_SceneKitIsLoaded
SCNLayer
SCNAntialiasingModeMultisampling8X
SCNAntialiasingModeMultisampling16X
SCNMaterialProperty
SCNBoundingBox
SCNBoundingSphere
SCNTransaction
SCNColor
CAMediaTimingFunction
CABasicAnimation
CAAnimationGroup
CAKeyframeAnimation
CALayer
SCNImage
SCNValue
SCNView
SCNMetalLayer
SCNNode
SCNGeometry
SCNPhysicsWorld
SCNPhysicsBody
SCNTransformConstraint
SCNLookAtConstraint
SCNLight
SCNCylinder
SCNGeometryElement
SCNIKConstraint
SCNRenderer
SCNTube
SCNParticleSystem
SCNMorpher
SCNBox
SCNCamera
SCNLevelOfDetail
SCNMaterial
SCNProgram
SCNParticlePropertyController
SCNConstraint
SCNPlane
SCNCone
SCNPhysicsBehavior
SCNPhysicsHingeJoint
SCNPhysicsField
SCNGeometrySource
SCNTorus
SCNScene
SCNPhysicsShape
SCNCapsule
SCNFloor
SCNShape
SCNText
SCNTechnique
SCNPyramid
SCNSceneSource
SCNSphere
SCNPhysicsBallSocketJoint
SCNPhysicsSliderJoint
SCNPhysicsContact
SCNHitTestResult
SCNAnimationEvent
SCNPhysicsVehicle
SCNPhysicsVehicleWheel
SCNAction
SCNActionTimingModeLinear
SCNActionTimingModeEaseIn
SCNActionTimingModeEaseOut
SCNActionTimingModeEaseInEaseOut
SCNEditingLocalSpace
SCNEditingParentSpace
SCNEditingWorldSpace
SCNEditingScreenSpace
SCNManipulatorPositionCenter
SCNManipulatorPositionMin
SCNManipulatorPositionMax
SCNAuthoringDisplayBoundingBoxes
SCNAuthoringDisplayBoundingSpheres
SCNAuthoringDisplayCameraFrustum
SCNAuthoringDisplayLightExtents
SCNAuthoringDisplayCameraPosition
SCNAuthoringDisplayLightPosition
SCNAuthoringDisplayPhysics
SCNAuthoringDisplayPhysicsFields
SCNAuthoringDisplayGrid
SCNAuthoringDisplayLightProbes
SCNAuthoringDisplayWireframe
SCNAuthoringDisplaySkeletons
SCNAuthoringDisplayConstraints
SCNAuthoringDisplayCreases
SCNAuthoringDisplayLightInfluence
SCNAuthoringCameraPerspective
SCNAuthoringCameraTop
SCNAuthoringCameraBottom
SCNAuthoringCameraLeft
SCNAuthoringCameraRight
SCNAuthoringCameraFront
SCNAuthoringCameraBack
SCNCameraProjectionDirectionVertical
SCNCameraProjectionDirectionHorizontal
SCNInteractionModeFly
SCNInteractionModeOrbitTurntable
SCNInteractionModeOrbitAngleMapping
SCNInteractionModeOrbitCenteredArcball
SCNInteractionModeOrbitArcball
SCNInteractionModePan
SCNInteractionModeTruck
SCNCameraFieldOfViewOrientationVertical
SCNCameraFieldOfViewOrientationHorizontal
SCNCameraExposureAdaptationModeFrameLuminance
SCNCameraExposureAdaptationModeHistogramLuminance
SCNCameraFillModeFill
SCNCameraFillModeLetterbox
SCNGeometryPrimitiveTypeTriangles
SCNGeometryPrimitiveTypeTriangleStrip
SCNGeometryPrimitiveTypeLine
SCNGeometryPrimitiveTypePoint
SCNGeometryPrimitiveTypePolygon
SCNTessellationSmoothingModeNone
SCNTessellationSmoothingModePNTriangles
SCNTessellationSmoothingModePhong
SCNSubdivisionBoundaryInterpolationRuleNone
SCNSubdivisionBoundaryInterpolationRuleEdgeOnly
SCNSubdivisionBoundaryInterpolationRuleEdgeAndCorner
SCNSubdivisionFaceVaryingInterpolationRuleLinearNone
SCNSubdivisionFaceVaryingInterpolationRuleLinearCornersOnly
SCNSubdivisionFaceVaryingInterpolationRuleLinearCornersPlus1
SCNSubdivisionFaceVaryingInterpolationRuleLinearCornersPlus2
SCNSubdivisionFaceVaryingInterpolationRuleLinearBoundaries
SCNSubdivisionFaceVaryingInterpolationRuleLinearAll
SCNSubdivisionNormalSmoothingModeCrossTriangle
SCNSubdivisionNormalSmoothingModeCrossQuad
SCNSubdivisionNormalSmoothingModeLimit
SCNHitTestSearchModeClosest
SCNHitTestSearchModeAll
SCNHitTestSearchModeAny
SCNLevelOfDetailThresholdModeWorldSpaceDistance
SCNLevelOfDetailThresholdModeScreenSpaceRadius
SCNShadowModeForward
SCNShadowModeDeferred
SCNShadowModeModulated
SCNMorpherCalculationModeNormalized
SCNMorpherCalculationModeAdditive
SCNMovabilityHintFixed
SCNMovabilityHintMovable
SCNChamferModeBoth
SCNChamferModeFront
SCNChamferModeBack
SCNParticleSortingModeNone
SCNParticleSortingModeProjectedDepth
SCNParticleSortingModeDistance
SCNParticleSortingModeOldestFirst
SCNParticleSortingModeYoungestFirst
SCNParticleBlendModeAdditive
SCNParticleBlendModeSubtract
SCNParticleBlendModeMultiply
SCNParticleBlendModeScreen
SCNParticleBlendModeAlpha
SCNParticleBlendModeReplace
SCNParticleOrientationModeBillboardScreenAligned
SCNParticleOrientationModeBillboardViewAligned
SCNParticleOrientationModeFree
SCNParticleOrientationModeBillboardYAligned
SCNParticleBirthLocationSurface
SCNParticleBirthLocationVolume
SCNParticleBirthLocationVertex
SCNParticleBirthDirectionConstant
SCNParticleBirthDirectionSurfaceNormal
SCNParticleBirthDirectionRandom
SCNParticleImageSequenceAnimationModeRepeat
SCNParticleImageSequenceAnimationModeClamp
SCNParticleImageSequenceAnimationModeAutoReverse
SCNParticleInputModeOverLife
SCNParticleInputModeOverDistance
SCNParticleInputModeOverOtherProperty
SCNParticleModifierStagePreDynamics
SCNParticleModifierStagePostDynamics
SCNParticleModifierStagePreCollision
SCNParticleModifierStagePostCollision
SCNParticleEventBirth
SCNParticleEventDeath
SCNParticleEventCollision
SCNParticleRenderingModeSprite
SCNParticleRenderingModePointSprite
SCNParticleRenderingModeTrail
SCNParticleRenderingModeBeam
SCNParticleRenderingModeGeometry
SCNReferenceLoadingPolicyImmediate
SCNReferenceLoadingPolicyOnDemand
SCNAntialiasingModeNone
SCNAntialiasingModeMultisampling2X
SCNAntialiasingModeMultisampling4X
SCNRenderingAPIMetal
SCNRenderingAPIOpenGLLegacy
SCNRenderingAPIOpenGLCore32
SCNRenderingAPIOpenGLCore41
SCNSceneSourceStatusParsing
SCNSceneSourceStatusValidating
SCNSceneSourceStatusProcessing
SCNSceneSourceStatusComplete
SCNSceneSourceStatusError
SCNCullBack
SCNCullFront
SCNBufferFrequencyPerFrame
SCNBufferFrequencyPerNode
SCNBufferFrequencyPerShadable
SCNFillModeFill
SCNFillModeLines
SCNCullModeBack
SCNCullModeFront
SCNTransparencyModeAOne
SCNTransparencyModeRGBZero
SCNTransparencyModeSingleLayer
SCNTransparencyModeDualLayer
SCNTransparencyModeDefault
SCNBlendModeAlpha
SCNBlendModeAdd
SCNBlendModeSubtract
SCNBlendModeMultiply
SCNBlendModeScreen
SCNBlendModeReplace
SCNBlendModeMax
SCNFilterModeNone
SCNFilterModeNearest
SCNFilterModeLinear
SCNWrapModeClamp
SCNWrapModeRepeat
SCNWrapModeClampToBorder
SCNWrapModeMirror
SCNPhysicsBodyTypeStatic
SCNPhysicsBodyTypeDynamic
SCNPhysicsBodyTypeKinematic
SCNPhysicsFieldScopeInsideExtent
SCNPhysicsFieldScopeOutsideExtent
SCNJS%@JSExport
SCN%@JSExport
%@JSExport
baseMesh
basePositionSource
@"SCNMTLSkinDeformerReadOnlyBuffers"8@?0
needNormal
needTangent
weight_index_size
bone_index_size
skin_var
Int%d_Int%d_%c%c
skin_copy_as_fallback
%c%c
_baseVertexCount == effectiveDstPosCount
effectiveDstPosCount == normalBuffer.length / (3 * sizeof(float))
effectiveDstPosCount <= tangentBuffer.length / (4 * sizeof(float))
bbox %p - min:[%f %f %f] max:[%f %f %f]
bsphere %p - center:[%f %f %f] radius:%f
C3DTransaction
(count == 1)
applyBlock
transaction
<C3DTransaction>
com.apple.scenekit.scnview-renderer
UITrackingRunLoopMode
com.apple.scenekit.main-thread-implicit-transaction-flush
t->childTransactions
child->parentTransaction == t
(count >= 2)
t->pendingAnimationCount>0
MBNeighborMaxPass
scn_motionblur_neighbormax_x
scn_motionblur_neighbormax_y
animationTimingFunction not implemented for Javascript
kGeometrySourceSemanticTangent
kGeometrySourceSemanticVertexCrease
kGeometrySourceSemanticEdgeCrease
kGeometrySourceSemanticBoneWeights
kGeometrySourceSemanticBoneIndices
<%@: %p | semantic=%@ vectors=%d %@x%d>
_geometrySourceWithSource - Conversion failed
_componentType == C3DBaseTypeGetComponentType(_componentType)
_componentCount >= 2 && _componentCount <= 4
halfSource
encodedComponentType == kC3DBaseTypeHalf
compressedSize > 0
cdata
vectorCount
floatComponents
bytesPerComponent
componentType
componentsPerVector
dataOffset
dataStride
colorSpace
decompressedSize == decompressedDataCapacity
<%@: %p | %u x %@, %u channels, %@ indices>
data.length >= (NSUInteger)(primitiveCount * bytesPerIndex)
compressedElementData
elementData
primitiveCount
primitiveRangeLocation
primitiveRangeLength
indicesChannelCount
interleavedIndicesChannels
ptSize
minimumPointScreenSpaceRadius
maximumPointScreenSpaceRadius
pointSize
triangle strip
line
polygon
VendorID
ProductID
MaxInputReportSize
IOHIDManagerOpen failed - %d
setGimbalLockVector is deprecated
Camera
NSScrollWheelMultiplier
kC3DColladaResourcesServiceRequestArgumentsKey
kC3DColladaResourcesServiceReplyArgumentsKey
kC3DColladaResourcesCoordinatorRequestURLKey
kC3DColladaResourcesCoordinatorRequestExtensionKey
kC3DColladaResourcesCoordinatorRequestAssetDirectoryURLsKey
kC3DColladaResourcesCoordinatorRequestImagePathsKey
kC3DColladaResourcesCoordinatorReplyExtensionsKey
SCNFlyCameraControllerForwardKeyCodeKey
SCNFlyCameraControllerBackwardKeyCodeKey
SCNFlyCameraControllerLeftKeyCodeKey
SCNFlyCameraControllerRightKeyCodeKey
com.apple.SceneKit.C3DColladaResourcesCoordinator
v16@?0^v8
An error occurred while locating the resources needed to open this COLLADA file. Please check that it has not been corrupted.
extension
uniform 
uvec2
uvec3
uvec4
mat2
mat2x4
mat3x2
mat3x3
mat4x2
mat3x4
scn_frame.time
u_viewTransform
scn_frame.viewTransform
u_inverseViewTransform
scn_frame.inverseViewTransform
scn_frame.projectionTransform
u_inverseProjectionTransform
scn_frame.inverseProjectionTransform
scn_frame.cameraPosition
scn_frame.viewToCubeWorld
scn_frame.inverseResolution
u_modelTransform
scn_node.modelTransform
u_inverseModelTransform
scn_node.inverseModelTransform
scn_node.modelViewTransform
u_inverseModelViewTransform
scn_node.inverseModelViewTransform
scn_node.normalTransform
scn_node.modelViewProjectionTransform
u_inverseModelViewProjectionTransform
scn_node.inverseModelViewProjectionTransform
u_boundingBox
scn_node.boundingBox
u_worldBoundingBox
scn_node.worldBoundingBox
discard
discard_fragment()
gl_FragCoord
in.fragmentPosition
gl_FragColor
_output.color
gl_FrontFacing
isFrontFacing
filter::linear
texture1DProj
texture1DLod
texture1DProjLod
texture2DLod
textureLod
texture2DProj
texture2DProjLod
texture3DProj
texture3DLod
texture3DProjLod
textureCubeLod
shadow1D
shadow1DProj
shadow1DLod
shadow1DProjLod
shadow2D
shadow2DProj
shadow2DLod
shadow2DProjLod
C3DShaderConverter.mm
ParseUniform
mToken.str() == "uniform"
body
Parse
mpTokenizer == nullptr
#pragma arguments
#pragma body
#pragma declaration
.sample(
Sampler
, level(
, bias(
float2(
float3(
float4(
sampler 
Sampler
http
superclass
niceDescription
presentation
mirror
empty
particleSystems
constaints
empty node
static
dynamic
kinematic
hinge
ballSocket
slider
drag
vortex
linear gravity
radial gravity
noise
turbulence
springField
electricField
magneticField
Shader source
back
front
aOne
zero
single layer
dual layer
shadowonly
physically based
plane
pyramid
cylinder
cone
tube
capsule
torus
Hello!
perspective
wantsDepthOfField
bloomIterationCount
_shadowCascadeDebugFactor
__semanticRegistry == NULL
__semanticRegistry != NULL
[__semanticRegistry objectForKey:semanticName] == nil
[__argumentRegistry objectForKey:argumentName] == nil
vertexBuffer.
osdIndicesBuffer
osdTessellationLevel
osdVertexBuffer
osdFaceVaryingData
osdFaceVaryingIndices
osdFaceVaryingPatchParams
osdFaceVaryingPatchArray
osdFaceVaryingChannelCount
osdFaceVaryingChannelDescriptors
osdFaceVaryingPatchArrayIndex
osdFaceVaryingChannelsPackedData
vertexBuffer
indexBuffer
patchParamBuffer
perPatchVertexBuffer
patchTessBuffer
scn_nodes
scn_frame_multi
bufferBinding.type == argument.type
(SCNArgumentBindingBlock)bufferBinding.bindBlock == block
[bufferBinding isKindOfClass:[SCNMTLPassResourceBinding class]]
(SCNArgumentBindingBlock)bufferBinding.bindBlock == nil
argument.bufferDataType == MTLDataTypeStruct
(NSUInteger)bufferBinding.bufferSize == argument.bufferDataSize
kExportPointOfViewAttribute
SCNExportSceneIdentifier
SCNExportMovieMirrored
SCNExportMovieSupersamplingFactor
SCNExportMovieFrameRate
SCNExportOperation : error not implemented
QTAddImageCodecType
QTMovieRateAttribute
SCNExport.m
SceneKit: Couldn't create pixel buffer
serial assetwriter input queue
v28@?0f8^{__CFError=}12^B20
FillTexturePass
B24@?0^{__C3DShapeBoundary=^{__C3DShapeVertex}IIddddi}8^{__C3DShapeBoundary=^{__C3DShapeVertex}IIddddi}16
v24@?0^{__C3DShapeBoundary=^{__C3DShapeVertex}IIddddi}8^{__C3DShapeBoundary=^{__C3DShapeVertex}IIddddi}16
v24@?0^{__C3DShapeBoundary=^{__C3DShapeVertex}IIddddi}8i16i20
boundaryCount > 1
C3DAppendPointToPath
C3DShapeUtils.c
origin != C3DShapeVertexOriginCurveStart
C3DShapeTriangulation.c
triangulation->triangleCount < triangulation->maxTriangleCount
C3DShapeTriangulationTriangleContainingPoint
C3DLinkIndexFromTriangleToTriangle
C3DVertexNotSharedByTriangles
C3DShapeConnectedComponentTriangulatePseudopolygon
list->count > 1
C3DShapeTriangulationAddEdge
recycledTriangles.count == 0
C3DGlyph
C3DGlyphCreate
C3DGlyph.c
shapeParams.cgPath == NULL
<C3DGlyph '%@' in '%@'>
C3DTextLine
<C3DTextLine>
C3DTextFrame
<C3DTextFrame>
profilePath.points
v28@?0c8I12*16I24
v140@?0{__C3DShapeVertex={CGPoint=dd}{CGPoint=dd}{CGPoint=dd}{CGPoint=dd}dBi}8{CGPoint=dd}88f104{CGPoint=dd}108{CGPoint=dd}124
setToApplyTo.count <= _originalDataCount
_prepareSnapToAlignDataForAxis - unexpected axis
C3DSpokeCreate
C3DShapeStraightSkeleton.c
CGPointEqualToPoint(origin, prev) == false
CGPointEqualToPoint(origin, next) == false
!isnan(spoke.direction.x)
!isnan(spoke.direction.y)
intersectionForSpokeAndSpoke
fabs(CGPointNorm(spoke1->direction) - 1) < epsilon
fabs(CGPointNorm(spoke2->direction) - 1) < epsilon
intersectionForSpokeAndEdge
spoke != edgeStart
spoke != edgeEnd
splitJoinFace
event.type == C3DStraightSkeletonEventSplit
spoke->boundaryOfVerticesIndex != INVALID_INDEX
other->boundaryOfVerticesIndex != INVALID_INDEX
d != INVALID_INDEX
f != INVALID_INDEX
bestSplitEvents
C3DOffsetBuild
newFace.boundaries == NULL
C3DFXJitteringPassFloat.plist
SceneKit_JitterCopyFirstFrame
SceneKit_JitterToEven
SceneKit_JitterToOdd
SceneKit_JitterResolve
Copy_vert
Copy_frag
C3D-Copy
Add_vert
Add_frag
C3D-Add
C3D-jitter-factor-resolve
Mult_vert
Mult_frag
C3D-Mult_float
SSRBlurPass-Y
SSRBlurPass-X
scn_ssr_blur_x
scn_ssr_blur_y
Original mesh has %d triangles, will reach a maximum of %d after %d levels of subdivision
[VDMC] ConfigBuffer%d
[VDMC] TriangleBuffer%d
VMeshAtomicSubdivisionKernel
VMeshUpdateCountersAndArgumentsKernel
VDMC deformer
Error creating the xml writer
utf-8
Error at xmlTextWriterStartDocument
COLLADA
xmlns
http://www.collada.org/2005/11/COLLADASchema
1.4.1
Error at xmlTextWriterEndDocument
contributor
SceneKit Collada Exporter v1.0
Y_UP
Z_UP
X_UP
yyyy-MM-dd'T'HH:mm:ss'Z'
library_animations
library_animation_clips
effect_
%@%d
(%ld)
can't mix euler and axisangle rotations
transform animation not supported
_copyComponentForColor4Address
C3DIOColladaExport.c
offset<4
_copyComponentForMatrixAddress
offset<16
(%zd)(%zd)
_copyComponentForVector3Address
offset<3
_copyComponentForVector4Address
float_array
int_array
Name_array
%s-array
_writeArrayWithWriterFunc
ccpv == 1
_writeArrayWithWriterFunc: unknown array type
#%s-array
TIME
TRANSFORM
_writeAccessor
cpv <= sizeof(XYZWNames) / sizeof(char*)
cpv <= sizeof(RGBANames) / sizeof(char*)
cpv <= sizeof(STPQNames) / sizeof(char*)
cpv <= 1
param
HERMITE
_writeKeyframeAnimation: can't resolve animation path (root)
_writeKeyframeAnimation: can't resolve animation path
channel
%s/%s%s
SID_%d
animation_clip
instance_animation
library_cameras
optics
orthographic
xmag
library_lights
%g %g %g
constant_attenuation
linear_attenuation
quadratic_attenuation
falloff_angle
falloff_exponent
profile
%g %g %g %g
probeParameters
tmpProbe
./no-path-found
instance_effect
#effect_%s
effect_%s
profile_COMMON
common
index_of_refraction
bump
newparam
%s_%s
surface
CUBE
CLAMP
WRAP
BORDER
MIRROR
wrap_s
wrap_t
NONE
NEAREST
minfilter
magfilter
mipfilter
opaque
CHANNEL%d
library_geometries
%s-vertices
NORMAL
tristrips
TEXTANGENT
WEIGHT
#%s-vertices
%ld 
library_controllers
method
NORMALIZED
RELATIVE
%s-targets
IDREF_array
%s-targets-array
#%s-targets-array
MORPH_TARGET
IDREF
#%s-targets
MORPH_WEIGHT
bind_shape_matrix
vertex_weights
%d %ld 
%.7g 
library_visual_scenes
instance_visual_scene
instance_camera
instance_light
lightmap_path=%s
uv_set=%d
translate
rotate
0 0 1 %g
0 1 0 %g
1 0 0 %g
instance_controller
instance_geometry
bind_material
instance_material
symbol
bind_vertex_input
input_semantic
input_set
scratchAllocator
fxPass
draw
ignoreFloors
onlyShadowCasters
onlyMovableNodes
hasConstantAlpha
installViewport
isViewDependant
overridesCustomProgram
layerMask
includeCategoryMask
excludeCategoryMask
viewport
samples
colorStates
clearColor
sceneBackground
clear
depthStates
enableWrite
enableRead
func
stencilStates
behavior
backFaceBehavior
blendStates
inputName
context->pass->_setup==0
@8@?0
C3DFXTechniqueGetPassCount(subTechnique) == 1
fxPass->_inputCount == count
(CFIndex)fxPass->_outputCount <= count
C3DFXPassInput
<C3DFXPassInput %@>
C3DFXPass
<C3DFXPass %@>
nameToInput
draw_scene
draw_node
draw_main_scene
draw_nodes
draw_geometry
draw_quad
metal_custom
draw_none
custom
preDraw
preFX
preToneMap
postFX
cullNone
never
always
equal
notEqual
less
lessEqual
greater
greaterEqual
depthFail
fail
readMask
writeMask
referenceValue
keep
replace
increment
decrement
invert
incrementWrap
decrementWrap
colorSrc
colorDst
alphaSrc
alphaDst
colorOp
alphaOp
oneMinusSrcColor
oneMinusSrcAlpha
oneMinusDstColor
oneMinusDstAlpha
constantColor
oneMinusConstantColor
constantAlpha
oneMinusConstantAlpha
alphaSaturate
substract
reverseSubstract
scaleFactor
mipmapped
%fx%f
texture_rectangle
color0
color1
color2
color3
stencil
format
input->_semantic != kC3DFXSemanticNone
typeTest == input->_baseType
modelViewProjectionInverseTransform
modelViewInverseTransform
modelInverseTransform
viewInverseTransform
projectionInverseTransform
normalInverseTransform
global
persistent
pass->_overridedRendererElementsProgramHashcodes
C3DRenderTarget
<C3DRenderTarget %p - texture:%@ rbo:%d>
C3DFXCopyPass.plist
C3DFXPostProcess_depth.json
C3DFXPostProcess.json
C3DFXDOFPass_deprecated.plist
C3DFXSSAO.json
C3DFXMotionBlur.plist
C3DFXJitteringPass.plist
C3D-Add.vsh
C3D-dof-downSample4x.fsh
C3D-ParticleSystem.fsh
C3D-OutlineRetina.vsh
C3D-Copy.vsh
C3D-EnvMap2D.vsh
C3D-Mult_float.fsh
C3D-GaussianBlurAlpha.vsh
C3D-ParticleSystem_Trail.fsh
C3D-dof-Blur5x5.vsh
C3DManipulatorColorAndTexture.fsh
C3DManipulator.fsh
C3D-CIFilterComposite.fsh
C3DManipulatorColorOnly.fsh
C3D-dof-ComputeNearCoc.vsh
C3DManipulatorLightProbe.vsh
C3D-DefaultProgram.fsh
C3D-IncrementalAverage.vsh
C3D-PickedObjects.fsh
C3D-EnvMapCube.fsh
C3D-OutlineMax.vsh
C3D-BlendAuthoring.fsh
C3D-dof-generateNearCoc.fsh
C3D-spotShadow.fsh
C3D-Outline.vsh
C3D-GaussianBlur.fsh
C3D-WarmupTexture.fsh
C3D-dof-Resolve.fsh
C3D-wireframe.vsh
C3DManipulator.vsh
C3DManipulatorColorAndTexture.vsh
C3D-CIFilterComposite.vsh
C3D-dof-downSample4x.vsh
C3D-ParticleSystem.vsh
C3D-OutlineRetina.fsh
C3D-Add.fsh
C3D-Copy.fsh
C3D-Mult_float.vsh
C3D-EnvMap2D.fsh
C3D-dof-Blur5x5.fsh
C3D-ParticleSystem_Trail.vsh
C3D-GaussianBlurAlpha.fsh
C3D-EnvMapCube.vsh
C3D-PickedObjects.vsh
C3D-BlendAuthoring.vsh
C3D-dof-generateNearCoc.vsh
C3D-OutlineMax.fsh
C3D-GaussianBlur.vsh
C3D-Outline.fsh
C3D-spotShadow.vsh
C3D-wireframe.fsh
C3D-WarmupTexture.vsh
C3D-dof-Resolve.vsh
C3DManipulatorColorOnly.vsh
C3DManipulatorLightProbe.fsh
C3D-dof-ComputeNearCoc.fsh
SCNShaderLightingContribution.glsl
C3D-IncrementalAverage.fsh
C3D-DefaultProgram.vsh
scn_deformer
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_copy</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_copy</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-Copy</string>
<key>clientProgram</key>
<false/>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
</dict>
</dict>
</dict>
</plist>
  "passes" : {
    "SceneKit_renderSceneFromLight" : {
      "outputs" : {
        "depth" : "SceneKit-spotShadowDepth"
      },
      "depthStates" : {
        "clear" : true
      },
      "isViewDependant" : false,
      "samples" : 1,
      "onlyShadowCasters" : true,
      "pointOfView" : "self",
      "ignoreFloors" : true,
      "draw" : "DRAW_SCENE"
    }
  },
  "sequence" : [
    "SceneKit_renderSceneFromLight"
  ],
  "targets" : {
    "SceneKit-spotShadowDepth" : {
      "global" : true,
      "type" : "depth"
    }
  "sequence" : [
                "SceneKit_renderCINodeTree",
                "SceneKit_ApplyCIFilter",
                "SceneKit_renderCIQuad"
                ],
  "targets" : {
    "SceneKit-CI-nodetree-depth" : {
      "type" : "depth"
    },
    "SceneKit-CI-nodetree-color" : {
      "type" : "color",
      "format" : "rgba",
    },
    "SceneKit-CI-effect-color" : {
      "type" : "color",
      "format" : "rgba",
      "usage" : ["shaderWrite", "shaderRead"]
    }
  },
  "symbols" : {
    "C3D-CIFilter_middleZ" : {
      "type" : "float"
    },
    "C3D-CIFilter_extent" : {
      "type" : "vec4"
    }
  },
  "passes" : {
    "SceneKit_renderCIQuad" : {
      "inputs" : {
        "u_color" : {
          "target" : "SceneKit-CI-effect-color",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        },
        "u_middleZ" : "C3D-CIFilter_middleZ",
        "u_extent" : "C3D-CIFilter_extent",
        "u_depth" : {
          "target" : "SceneKit-CI-nodetree-depth",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        }
      },
      "hasConstantAlpha" : false,
      "colorStates" : {
        "clear" : false
      },
      "depthStates" : {
        "clear" : false
      },
      "cullMode" : "none",
      "metalVertexShader" : "scn_filterCompositeVert",
      "metalFragmentShader" : "scn_filterCompositeFrag",
      "draw" : "none",
      "clientProgram" : false,
      "blendStates" : {
        "enable" : true,
        "colorDst" : "oneMinusSrcAlpha",
        "colorSrc" : "one"
      }
    },
    "SceneKit_ApplyCIFilter" : {
      "outputs" : {
        "color" : "SceneKit-CI-effect-color"
      },
      "inputs" : {
        "myInput1" : "SceneKit-CI-nodetree-color"
      },
      "draw" : "CUSTOM"
    },
    "SceneKit_renderCINodeTree" : {
      "draw" : "DRAW_NODE",
      "node" : "self",
      "ignoreFloors" : true,
      "outputs" : {
        "depth" : "SceneKit-CI-nodetree-depth",
        "color" : "SceneKit-CI-nodetree-color"
      },
      "colorStates" : {
        "clear" : true
      },
      "depthStates" : {
        "clear" : true
      },
      
    }
    "sequence" : [ "SceneKit_PostProcess"],
    "passes" : {
        "SceneKit_PostProcess" : {
            "outputs" : {
                "color" : "COLOR"
            },
            "inputs" : {
                "colorBuffer" : "COLOR",
                "depthBuffer" : "DEPTH"
            },
            "draw" : "DRAW_QUAD",
            "clientProgram" : "NO",
            "program" : "C3D-GLSL-UNAVAILABLE",
        }
    },
    "symbols" : {
    },
  "passes" : {
    "SceneKit_renderSceneFromLight" : {
      "outputs" : {
        "depth" : "SceneKit-spotShadowDepth"
      },
      "depthStates" : {
        "clear" : true
      },
      "isViewDependant" : false,
      "samples" : 1,
      "onlyShadowCasters" : true,
      "pointOfView" : "self",
      "ignoreFloors" : true,
      "draw" : "DRAW_SCENE"
    },
    "SceneKit_applyDeferredShadows" : {
      "outputs" : {
        "color" : "COLOR"
      },
      "inputs" : {
          "light_MVP" : "C3D-light_MVP-symbol",
          "viewTransform" : "C3D-camera_view-symbol",
          "depthSampler" : {
          "target" : "DEPTH",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        },
        "u_kernel" : "C3D-shadowKernel-symbol",
        "lightDepthSampler" : {
          "target" : "SceneKit-spotShadowDepth",
          "sampler" : {
            "wrapS" : "clamp",
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest",
            "wrapT" : "clamp"
          }
        },
        "shadowColor" : "C3D-shadowColor-symbol",
        "colorSampler" : "COLOR",
        "camera_MVP_i" : "C3D-camera_MVP_i-symbol",
        "cascadeScale" : "C3D-cascadeScale-symbol",
        "cascadeBias" : "C3D-cascadeBias-symbol",
        "cascadeDebugFactor" : "C3D-shadowCascadeDebugFactor-symbol",
        "u_lightPos" : "C3D-u_lightPos-symbol",
        "u_lightDir" : "C3D-u_lightDir-symbol",
        "shadowRadius" : "C3D-shadowRadius-symbol",
        "u_lightSpotAtt" : "C3D-u_lightSpotAtt-symbol"
      },
      "metalFragmentShader" : "shadowMap_frag",
      "draw" : "DRAW_QUAD",
      "clientProgram" : false,
      "metalVertexShader" : "shadowMap_vert"
    }
  },
  "sequence" : [
    "SceneKit_renderSceneFromLight",
    "SceneKit_applyDeferredShadows"
  ],
  "symbols" : {
    "C3D-u_lightSpotAtt-symbol" : {
      "type" : "vec3"
    },
    "C3D-shadowColor-symbol" : {
      "type" : "vec4"
    },
    "C3D-camera_MVP_i-symbol" : {
      "type" : "mat4"
    },
    "C3D-camera_view-symbol" : {
      "type" : "mat4"
    },
    "C3D-u_lightPos-symbol" : {
      "type" : "vec3"
    },
    "C3D-zMapFactor-symbol" : {
      "type" : "float"
    },
    "C3D-light_MVP-symbol" : {
      "type" : "mat4"
    },
    "C3D-shadowRadius-symbol" : {
      "type" : "float"
    },
    "C3D-shadowCascadeDebugFactor-symbol" : {
      "type" : "float"
    },
    "C3D-shadowKernel-symbol" : {
      "type" : "vec4[128]"
    },
    "C3D-cascadeScale-symbol" : {
      "type" : "vec3[4]"
    },
    "C3D-cascadeBias-symbol" : {
      "type" : "vec3[4]"
    },
    "C3D-u_lightDir-symbol" : {
      "type" : "vec3"
    }
  },
  "targets" : {
    "SceneKit-spotShadowDepth" : {
      "type" : "depth"
    }
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>symbols</key>
<dict>
<key>a_position-symbol</key>
<dict>
<key>semantic</key>
<string>vertex</string>
</dict>
<key>color</key>
<dict>
<key>semantic</key>
<string>none</string>
</dict>
</dict>
<key>sequence</key>
<array>
<string>authoring-overlay</string>
<string>authoringBlend</string>
</array>
<key>targets</key>
<dict>
<key>authoring-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba</string>
</dict>
<key>authoring-depth</key>
<dict>
<key>type</key>
<string>depth</string>
</dict>
</dict>
<key>passes</key>
<dict>
<key>authoring-overlay</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>authoring-color</string>
<key>depth</key>
<string>authoring-depth</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>layerMask</key>
<integer>4</integer>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clearColor</key>
<string>0 0 0 0</string>
<key>clear</key>
<true/>
</dict>
</dict>
<key>authoringBlend</key>
<dict>
<key>clientProgram</key>
<string>NO</string>
<key>program</key>
<string>C3D-BlendAuthoring</string>
<key>metalVertexShader</key>
<string>blendAuthoring_vert</string>
<key>metalFragmentShader</key>
<string>blendAuthoring_frag</string>
<key>inputs</key>
<dict>
<key>authoringColor</key>
<string>authoring-color</string>
<key>sceneColor</key>
<string>COLOR</string>
</dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>depthStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>sceneBackground</string>
</dict>
</dict>
</dict>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>Outline-pickedObjects</string>
<string>Outline-outline</string>
</array>
<key>passes</key>
<dict>
<key>Outline-pickedObjects</key>
<dict>
<key>outputs</key>
<dict>
<key>depth</key>
<string>pickedObjects-depth</string>
<key>color</key>
<string>pickedObjects-color</string>
</dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>u_modelViewProjectionTransform</key>
<string>u_modelViewProjectionTransform-symbol</string>
<key>u_modelTransform</key>
<string>u_modelTransform-symbol</string>
</dict>
<key>draw</key>
<string>DRAW_NODES</string>
<key>samples</key>
<integer>1</integer>
<key>overridesCustomProgram</key>
<true/>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>&quot;0. 0. 0. 1.&quot;</string>
</dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
</dict>
<key>Outline-outline</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>pickedColorBuffer</key>
<string>pickedObjects-color</string>
<key>pickedDepthBuffer</key>
<string>pickedObjects-depth</string>
<key>colorBuffer</key>
<string>COLOR</string>
<key>depthBuffer</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-Outline</string>
<key>clientProgram</key>
<string>NO</string>
<key>metalVertexShader</key>
<string>outline_vert</string>
<key>metalFragmentShader</key>
<string>outline_frag</string>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>a_position-symbol</key>
<dict>
<key>semantic</key>
<string>vertex</string>
</dict>
<key>u_modelViewProjectionTransform-symbol</key>
<dict>
<key>semantic</key>
<string>modelViewProjectionTransform</string>
</dict>
<key>u_modelTransform-symbol</key>
<dict>
<key>semantic</key>
<string>modelTransform</string>
</dict>
<key>color</key>
<dict>
<key>semantic</key>
<string>none</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>pickedObjects-depth</key>
<dict>
<key>type</key>
<string>depth</string>
<key>format</key>
<string>depth24</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
<key>pickedObjects-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>r8</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
</dict>
</dict>
</plist>
    "sequence" : [ "SceneKit_PostProcess"],
    "passes" : {
        "SceneKit_PostProcess" : {
            "outputs" : {
                "color" : "COLOR"
            },
            "inputs" : {
                "colorBuffer" : "COLOR"
            },
            "draw" : "DRAW_QUAD",
            "clientProgram" : "NO",
            "program" : "C3D-GLSL-UNAVAILABLE",
        }
    },
    "symbols" : {
    },
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>Outline-pickedObjects</string>
<string>Outline-outline</string>
<string>Outline-max</string>
</array>
<key>passes</key>
<dict>
<key>Outline-pickedObjects</key>
<dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>u_modelViewProjectionTransform</key>
<string>u_modelViewProjectionTransform-symbol</string>
<key>u_modelTransform</key>
<string>u_modelTransform-symbol</string>
</dict>
<key>outputs</key>
<dict>
<key>depth</key>
<string>pickedObjects-depth</string>
<key>color</key>
<string>pickedObjects-color</string>
</dict>
<key>draw</key>
<string>DRAW_NODES</string>
<key>samples</key>
<integer>1</integer>
<key>overridesCustomProgram</key>
<true/>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>&quot;0. 0. 0. 1.&quot;</string>
</dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
</dict>
<key>Outline-outline</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>outline-color</string>
</dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>pickedColorBuffer</key>
<string>pickedObjects-color</string>
<key>pickedDepthBuffer</key>
<string>pickedObjects-depth</string>
<key>colorBuffer</key>
<string>COLOR</string>
<key>depthBuffer</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-OutlineRetina</string>
<key>clientProgram</key>
<string>NO</string>
<key>metalVertexShader</key>
<string>outlineRetina_vert</string>
<key>metalFragmentShader</key>
<string>outlineRetina_frag</string>
</dict>
<key>Outline-max</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>outlineColorBuffer</key>
<string>outline-color</string>
<key>colorBuffer</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-OutlineMax</string>
<key>clientProgram</key>
<string>NO</string>
<key>metalVertexShader</key>
<string>outlineMax_vert</string>
<key>metalFragmentShader</key>
<string>outlineMax_frag</string>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>a_position-symbol</key>
<dict>
<key>semantic</key>
<string>vertex</string>
</dict>
<key>u_modelViewProjectionTransform-symbol</key>
<dict>
<key>semantic</key>
<string>modelViewProjectionTransform</string>
</dict>
<key>u_modelTransform-symbol</key>
<dict>
<key>semantic</key>
<string>modelTransform</string>
</dict>
<key>color</key>
<dict>
<key>semantic</key>
<string>none</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>outline-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>r8</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
<key>pickedObjects-depth</key>
<dict>
<key>type</key>
<string>depth</string>
<key>format</key>
<string>depth24</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
<key>pickedObjects-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>r8</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
</dict>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_downSample4x</string>
<string>SceneKit_DOF_generateNearCoc</string>
<string>SceneKit_DOF_blurCoc_H</string>
<string>SceneKit_DOF_blurCoc_V</string>
<string>SceneKit_blurColor4x_H</string>
<string>SceneKit_blurColor4x_V</string>
<string>SceneKit_DOF_computeNearCoc</string>
<string>SceneKit_DOF_smallBlur</string>
<string>SceneKit_DOF_resolve</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_downSample4x</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-color-downSample4x</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<string>COLOR</string>
<key>depthSampler</key>
<string>DEPTH</string>
<key>CocScaleBias</key>
<string>C3D-dof-cocScaleBias</string>
<key>u_inversePixelSize</key>
<string>C3D-dof-invertPixelSize</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-downSample4x</string>
<key>clientProgram</key>
<false/>
<key>metalVertexShader</key>
<string>DownSample4x_vert</string>
<key>metalFragmentShader</key>
<string>DownSample4x_frag</string>
</dict>
<key>SceneKit_DOF_generateNearCoc</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-color-nearCoc</string>
</dict>
<key>inputs</key>
<dict>
<key>downSampler</key>
<dict>
<key>target</key>
<string>SceneKit-color-downSample4x</string>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
</dict>
<key>depthSampler</key>
<dict>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
<key>target</key>
<string>DEPTH</string>
</dict>
<key>CocScaleBias</key>
<string>C3D-dof-cocScaleBias</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-generateNearCoc</string>
<key>metalVertexShader</key>
<string>GenerateNearCoc_vert</string>
<key>clientProgram</key>
<false/>
<key>metalFragmentShader</key>
<string>GenerateNearCoc_frag</string>
</dict>
<key>SceneKit_DOF_blurCoc_H</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_DOF_blurCoc_H_output</string>
</dict>
<key>inputs</key>
<dict>
<key>radius</key>
<string>C3D-blur-radiusH</string>
<key>textureSampler0</key>
<string>SceneKit-color-nearCoc</string>
<key>offsets</key>
<string>C3D-blur-offsets</string>
<key>weights</key>
<string>C3D-blur-weights</string>
<key>n_sample</key>
<string>C3D-blur-samples</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_DOF_blurCoc_V</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_DOF_blurCoc_V_output</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>SceneKit_DOF_blurCoc_H_output</string>
<key>radius</key>
<string>C3D-blur-radiusV</string>
<key>offsets</key>
<string>C3D-blur-offsets</string>
<key>weights</key>
<string>C3D-blur-weights</string>
<key>n_sample</key>
<string>C3D-blur-samples</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_blurColor4x_H</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_blurColor4x_H_output</string>
</dict>
<key>inputs</key>
<dict>
<key>radius</key>
<string>C3D-blur-radiusH</string>
<key>textureSampler0</key>
<string>SceneKit-color-downSample4x</string>
<key>offsets</key>
<string>C3D-blur-offsets</string>
<key>weights</key>
<string>C3D-blur-weights</string>
<key>n_sample</key>
<string>C3D-blur-samples</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_blurColor4x_V</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_blurColor4x_V_output</string>
</dict>
<key>inputs</key>
<dict>
<key>radius</key>
<string>C3D-blur-radiusV</string>
<key>textureSampler0</key>
<string>SceneKit_blurColor4x_H_output</string>
<key>offsets</key>
<string>C3D-blur-offsets</string>
<key>weights</key>
<string>C3D-blur-weights</string>
<key>n_sample</key>
<string>C3D-blur-samples</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_DOF_computeNearCoc</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_DOF_computeNearCoc-output</string>
</dict>
<key>inputs</key>
<dict>
<key>downSampler</key>
<dict>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
<key>target</key>
<string>SceneKit-color-nearCoc</string>
</dict>
<key>blurSampler</key>
<dict>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
<key>target</key>
<string>SceneKit_DOF_blurCoc_V_output</string>
</dict>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-ComputeNearCoc</string>
<key>clientProgram</key>
<false/>
<key>metalVertexShader</key>
<string>ComputeNearCoc_vert</string>
<key>metalFragmentShader</key>
<string>ComputeNearCoc_frag</string>
</dict>
<key>SceneKit_DOF_smallBlur</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_DOF_smallBlur-ouput</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<dict>
<key>target</key>
<string>SceneKit_DOF_computeNearCoc-output</string>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
</dict>
<key>u_inversePixelSize</key>
<string>C3D-dof-invertPixelSize</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-Blur5x5</string>
<key>clientProgram</key>
<false/>
<key>metalVertexShader</key>
<string>Blur5x5_vert</string>
<key>metalFragmentShader</key>
<string>Blur5x5_frag</string>
</dict>
<key>SceneKit_DOF_resolve</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<string>COLOR</string>
<key>depthSampler</key>
<string>DEPTH</string>
<key>smallBlurSampler</key>
<string>SceneKit_DOF_smallBlur-ouput</string>
<key>largeBlurSampler</key>
<string>SceneKit_blurColor4x_V_output</string>
<key>CocScaleBias</key>
<string>C3D-dof-cocScaleBias</string>
<key>dofLerpScale</key>
<string>C3D-dof-lerpScale</string>
<key>dofLerpBias</key>
<string>C3D-dof-lerpBias</string>
<key>u_inversePixelSize</key>
<string>C3D-dof-invertPixelSize</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-Resolve</string>
<key>clientProgram</key>
<false/>
<key>metalVertexShader</key>
<string>ResolveDOF_vert</string>
<key>metalFragmentShader</key>
<string>ResolveDOF_frag</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>SceneKit-color-downSample4x</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit-color-nearCoc</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_DOF_blurCoc_H_output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_DOF_blurCoc_V_output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_blurColor4x_H_output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_blurColor4x_V_output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_DOF_computeNearCoc-output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_DOF_smallBlur-ouput</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>C3D-dof-cocScaleBias</key>
<dict>
<key>type</key>
<string>vec3</string>
</dict>
<key>C3D-dof-invertPixelSize</key>
<dict>
<key>type</key>
<string>vec2</string>
</dict>
<key>C3D-dof-lerpScale</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>C3D-dof-lerpBias</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>C3D-blur-radiusV</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>C3D-blur-radiusH</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>C3D-blur-offsets</key>
<dict>
<key>type</key>
<string>vec2[31]</string>
</dict>
<key>C3D-blur-weights</key>
<dict>
<key>type</key>
<string>float[31]</string>
</dict>
<key>C3D-blur-samples</key>
<dict>
<key>type</key>
<string>int</string>
</dict>
</dict>
</dict>
</plist>
    "sequence": [
                 "SceneKit_SSAO_DEPTH",
                 "SceneKit_SSAO"
                 ],
    "passes": {
        "SceneKit_SSAO_DEPTH": {
            "outputs": {
                "depth": "depth-target",
                "color": "ssao-depth"
            },
            "depthStates": {
                "clear": true
            },
            "colorStates": {
                "clear": true,
                "clearColor": "-100000. -100000. -100000. -100000."
            },
            "samples": 1,
            "__clientProgram": "NO",
            "draw": "DRAW_SCENE",
        },
        "SceneKit_SSAO": {
            "outputs": {
                "color": "COLOR"
            },
            "inputs": {
                "color": "COLOR"
            },
            "draw": "DRAW_QUAD",
            "clientProgram": "NO",
            "program": "C3D-GLSL-UNAVAILABLE"
        }
    },
    "symbols": {},
    "targets": {
        "depth-target": {
            "type": "depth",
        },
        "ssao-depth": {
            "format": "rgba16f",
            "type": "color",
            "global": true,
            "mipmapped": true,
            "scaleFactor": 1.0
        }
    }
  "passes" : {
    "SceneKit_ApplyCIFilter" : {
      "outputs" : {
        "color" : "SceneKit-CI-effect-color"
      },
      "inputs" : {
        "myInput1" : "SceneKit-CI-nodetree-color"
      },
      "draw" : "CUSTOM"
    },
    "SceneKit_renderCINodeTree" : {
      "outputs" : {
        "depth" : "SceneKit-CI-nodetree-depth",
        "color" : "SceneKit-CI-nodetree-color"
      },
      "ignoreFloors" : true,
      "draw" : "DRAW_NODE",
      "node" : "self"
    },
    "SceneKit_renderCIQuad" : {
      "inputs" : {
        "u_m" : "C3D-CIFilter_modelMatrix",
        "u_color" : {
          "target" : "SceneKit-CI-effect-color",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        },
        "u_middleZ" : "C3D-CIFilter_middleZ",
        "u_depth" : {
          "target" : "SceneKit-CI-nodetree-depth",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        }
      },
      "hasConstantAlpha" : false,
      "colorStates" : {
        "clear" : false
      },
      "depthStates" : {
        "clear" : false
      },
      "program" : "C3D-CIFilterComposite",
      "draw" : "none",
      "clientProgram" : false,
      "blendStates" : {
        "enable" : true,
        "colorDst" : "oneMinusSrcAlpha",
        "colorSrc" : "one"
      }
    }
  },
  "sequence" : [
    "SceneKit_renderCINodeTree",
    "SceneKit_ApplyCIFilter",
    "SceneKit_renderCIQuad"
  ],
  "symbols" : {
    "C3D-CIFilter_middleZ" : {
      "type" : "float"
    },
    "C3D-CIFilter_modelMatrix" : {
      "type" : "mat4"
    }
  },
  "targets" : {
    "SceneKit-CI-effect-color" : {
      "type" : "color"
    },
    "SceneKit-CI-nodetree-color" : {
      "target" : "texture_rectangle",
      "type" : "color"
    },
    "SceneKit-CI-nodetree-depth" : {
      "type" : "depth"
    }
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>computeVelocity</string>
<string>blur1</string>
<string>blur2</string>
<string>renderMovableNodes</string>
</array>
<key>passes</key>
<dict>
<key>blur1</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<string>COLOR</string>
<key>velocitySampler</key>
<string>VELOCITY</string>
<key>intensity</key>
<string>C3D-MotionBlur-Intensity-symbol</string>
</dict>
<key>program</key>
<string>C3D-GLSL-UNAVAILABLE</string>
<key>clientProgram</key>
<string>NO</string>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>metalFragmentShader</key>
<string>scn_motionblur_blur_6taps</string>
<key>metalVertexShader</key>
<string>scn_motionblur_vert</string>
</dict>
<key>blur2</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<string>COLOR</string>
<key>velocitySampler</key>
<string>VELOCITY</string>
<key>intensity</key>
<string>C3D-MotionBlur-Intensity-symbol</string>
</dict>
<key>program</key>
<string>C3D-GLSL-UNAVAILABLE</string>
<key>clientProgram</key>
<string>NO</string>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>metalFragmentShader</key>
<string>scn_motionblur_blur_12taps</string>
<key>metalVertexShader</key>
<string>scn_motionblur_vert</string>
</dict>
<key>renderMovableNodes</key>
<dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>onlyMovableNodes</key>
<true/>
<key>samples</key>
<integer>1</integer>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>a_position-symbol</key>
<dict>
<key>semantic</key>
<string>vertex</string>
</dict>
<key>C3D-MotionBlur-Intensity-symbol</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>C3D-oldViewProjectionTransform-symbol</key>
<dict>
<key>type</key>
<string>mat4</string>
</dict>
<key>C3D-viewProjectionInverseTransform-symbol</key>
<dict>
<key>type</key>
<string>mat4</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>VELOCITY</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba16f</string>
<key>scaleFactor</key>
<real>0.25</real>
</dict>
<key>blur-target</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
</dict>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_JitterCopyFirstFrame</string>
<string>SceneKit_JitterToEven</string>
<string>SceneKit_JitterToOdd</string>
<string>SceneKit_JitterResolve</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_JitterCopyFirstFrame</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-even</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterToOdd</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-odd</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler1</key>
<string>SceneKit-jitter-even</string>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterToEven</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-even</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler1</key>
<string>SceneKit-jitter-odd</string>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterResolve</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>SceneKit-jitter-odd</string>
<key>factor</key>
<string>C3D-jitter-factor-resolve</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
</dict>
<key>targets</key>
<dict>
<key>SceneKit-jitter-odd</key>
<dict>
<key>type</key>
<string>color</string>
<key>persistent</key>
<true/>
<key>format</key>
<string>rgba32f</string>
</dict>
<key>SceneKit-jitter-even</key>
<dict>
<key>type</key>
<string>color</string>
<key>persistent</key>
<true/>
<key>format</key>
<string>rgba32f</string>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>C3D-jitter-factor-resolve</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
</dict>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_JitterCopyFirstFrame</string>
<string>SceneKit_JitterToEven</string>
<string>SceneKit_JitterToOdd</string>
<string>SceneKit_JitterResolve</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_JitterCopyFirstFrame</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-even</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterToOdd</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-odd</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler1</key>
<string>SceneKit-jitter-even</string>
<key>factor</key>
<string>C3D-jitter-factor</string>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterToEven</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-even</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler1</key>
<string>SceneKit-jitter-odd</string>
<key>textureSampler0</key>
<string>COLOR</string>
<key>factor</key>
<string>C3D-jitter-factor</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterResolve</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>SceneKit-jitter-odd</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>clientProgram</key>
<false/>
</dict>
</dict>
<key>targets</key>
<dict>
<key>SceneKit-jitter-odd</key>
<dict>
<key>type</key>
<string>color</string>
<key>persistent</key>
<true/>
</dict>
<key>SceneKit-jitter-even</key>
<dict>
<key>type</key>
<string>color</string>
<key>persistent</key>
<true/>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>C3D-jitter-factor</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
</dict>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_renderMirroredScene</string>
<string>SceneKit_renderFloor</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_renderMirroredScene</key>
<dict>
<key>outputs</key>
<dict>
<key>depth</key>
<string>SceneKit-Floor-depth</string>
<key>color</key>
<string>SceneKit-Floor-color</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
</dict>
<key>SceneKit_renderFloor</key>
<dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>inputs</key>
<dict>
<key>u_floorReflectionDepth</key>
<string>SceneKit-Floor-depth</string>
<key>u_floorReflectionColor</key>
<string>SceneKit-Floor-color</string>
<key>u_floorNormal</key>
<string>u_floorNormal</string>
<key>u_floorTangent</key>
<string>u_floorTangent</string>
<key>u_floorCenter</key>
<string>u_floorCenter</string>
<key>u_floorExtent</key>
<string>u_floorExtent</string>
<key>u_floorReflectivity</key>
<string>u_floorReflectivity</string>
<key>u_floor_viewport</key>
<string>u_floor_viewport</string>
<key>u_floorMVP_i</key>
<string>u_floorMVP_i</string>
<key>u_floorPlane</key>
<string>u_floorPlane</string>
<key>u_floorFalloff</key>
<string>u_floorFalloff</string>
<key>u_floorFalloffStart</key>
<string>u_floorFalloffStart</string>
</dict>
<key>draw</key>
<string>DRAW_GEOMETRY</string>
<key>installViewport</key>
<false/>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>u_floorNormal</key>
<dict>
<key>type</key>
<string>vec3</string>
</dict>
<key>u_floorTangent</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>u_floorCenter</key>
<dict>
<key>type</key>
<string>vec3</string>
</dict>
<key>u_floorExtent</key>
<dict>
<key>type</key>
<string>vec2</string>
</dict>
<key>u_floor_viewport</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>u_floorReflectivity</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>u_floorMVP_i</key>
<dict>
<key>type</key>
<string>mat4</string>
</dict>
<key>u_floorPlane</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>u_floorFalloff</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>u_floorFalloffStart</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>SceneKit-Floor-depth</key>
<dict>
<key>type</key>
<string>depth</string>
</dict>
<key>SceneKit-Floor-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba</string>
</dict>
</dict>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>targets</key>
<dict>
<key>VELOCITY</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba16f</string>
<key>scaleFactor</key>
<integer>1</integer>
<key>global</key>
<true/>
<key>clearColor</key>
<string>0. 0. 0. 999999999.</string>
</dict>
</dict>
<key>sequence</key>
<array>
<string>SceneKit_renderScene</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_renderScene</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>color1</key>
<string>VELOCITY</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>sceneBackground</string>
</dict>
</dict>
</dict>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_renderScene</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_renderScene</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>layerMask</key>
<integer>3</integer>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>sceneBackground</string>
</dict>
</dict>
</dict>
</dict>
</plist>
  "sequence" : [
                "SceneKit_renderCIQuad"
                ],
  "targets" : {
    "SceneKit-CI-effect-depth" : {
      "type" : "depth"
    },
    "SceneKit-CI-effect-color" : {
      "type" : "color",
      "format" : "rgba",
      "usage" : ["shaderWrite", "shaderRead"]
    }
  },
  "symbols" : {
    "C3D-CIFilter_middleZ" : {
      "type" : "float"
    },
    "C3D-CIFilter_extent" : {
      "type" : "vec4"
    },
    "C3D-CIFilter_reverseZ" : {
        "type" : "float"
    }
  },
  "passes" : {
    "SceneKit_renderCIQuad" : {
      "inputs" : {
        "u_color" : {
          "target" : "SceneKit-CI-effect-color",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        },
        "u_middleZ" : "C3D-CIFilter_middleZ",
        "u_extent" : "C3D-CIFilter_extent",
        "u_reverseZ" : "C3D-CIFilter_reverseZ",
        "u_depth" : {
          "target" : "SceneKit-CI-effect-depth",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        }
      },
      "hasConstantAlpha" : false,
      "colorStates" : {
        "clear" : false
      },
      "depthStates" : {
        "clear" : false
      },
      "cullMode" : "none",
      "metalVertexShader" : "scn_filterCompositeVert",
      "metalFragmentShader" : "scn_filterCompositeFrag",
      "draw" : "none",
      "clientProgram" : false,
      "blendStates" : {
        "enable" : true,
        "colorDst" : "oneMinusSrcAlpha",
        "colorSrc" : "one"
      }
    },
attribute vec3 a_position;
varying vec2 TexCoord;
void main(void)
gl_Position = vec4(a_position, 1.0);
TexCoord = (a_position.xy + 1.0) * 0.5;
uniform vec3 CocScaleBias;
uniform sampler2D colorSampler;
uniform sampler2D depthSampler;
uniform vec2 u_inversePixelSize;
varying vec2 v_tcColor0;
varying vec2 v_tcColor1;
varying vec2 v_tcDepth0;
varying vec2 v_tcDepth1;
varying vec2 v_tcDepth2;
varying vec2 v_tcDepth3;
vec4 saturate(vec4 val)
    return clamp(val, vec4(0.), vec4(1.));
void main (void)
    
    vec4 dofRowDelta = vec4(0., 1., 2., 3.) * u_inversePixelSize.y * 0.25;
    vec2 rowOfs[4];
    rowOfs[0] = dofRowDelta.xx; 
    rowOfs[1] = dofRowDelta.xy;
    rowOfs[2] = dofRowDelta.xz;
    rowOfs[3] = dofRowDelta.xw;
    
    
    vec3 color;
    color  = texture2D( colorSampler, v_tcColor0.xy ).rgb;
    color += texture2D( colorSampler, v_tcColor1.xy ).rgb;
    color += texture2D( colorSampler, v_tcColor0.xy + rowOfs[2] ).rgb;
    color += texture2D( colorSampler, v_tcColor1.xy + rowOfs[2] ).rgb;
    color *= 0.25;
    
    vec4 depth;
    depth[0] = texture2D( depthSampler, v_tcDepth0.xy + rowOfs[0] ).r;
    depth[1] = texture2D( depthSampler, v_tcDepth1.xy + rowOfs[0] ).r;
    depth[2] = texture2D( depthSampler, v_tcDepth2.xy + rowOfs[0] ).r;
    depth[3] = texture2D( depthSampler, v_tcDepth3.xy + rowOfs[0] ).r;
    vec4 coc = abs(depth * CocScaleBias.x + CocScaleBias.y);
    depth[0] = texture2D( depthSampler, v_tcDepth0.xy + rowOfs[1] ).r;
    depth[1] = texture2D( depthSampler, v_tcDepth1.xy + rowOfs[1] ).r;
    depth[2] = texture2D( depthSampler, v_tcDepth2.xy + rowOfs[1] ).r;
    depth[3] = texture2D( depthSampler, v_tcDepth3.xy + rowOfs[1] ).r;
    coc 
 = max(coc, abs(depth * CocScaleBias.x + CocScaleBias.y));
    
    depth[0] = texture2D( depthSampler, v_tcDepth0.xy + rowOfs[2] ).r;
    depth[1] = texture2D( depthSampler, v_tcDepth1.xy + rowOfs[2] ).r;
    depth[2] = texture2D( depthSampler, v_tcDepth2.xy + rowOfs[2] ).r;
    depth[3] = texture2D( depthSampler, v_tcDepth3.xy + rowOfs[2] ).r;
    coc 
 = max(coc, abs(depth * CocScaleBias.x + CocScaleBias.y));
    
    depth[0] = texture2D( depthSampler, v_tcDepth0.xy + rowOfs[3] ).r;
    depth[1] = texture2D( depthSampler, v_tcDepth1.xy + rowOfs[3] ).r;
    depth[2] = texture2D( depthSampler, v_tcDepth2.xy + rowOfs[3] ).r;
    depth[3] = texture2D( depthSampler, v_tcDepth3.xy + rowOfs[3] ).r;
    coc 
 = max(coc, abs(depth * CocScaleBias.x + CocScaleBias.y));
    float maxCoc = max( max( coc.x, coc.y ), max( coc.z, coc.w ) );
    
    
gl_FragColor = vec4(color, maxCoc);
#ifdef ENABLE_CUBE_MAP
uniform samplerCube u_textureSampler0;
uniform float u_fresnelExponent;
varying vec4 v_normal;
#ifdef ENABLE_FOG
uniform vec4 u_fogColor;
#endif
#else 
uniform sampler2D u_textureSampler0;
#endif
varying vec4 v_vertexColor;
#ifdef ENABLE_ANIMATION
varying vec3 v_uv0;
varying vec2 v_uv1;
#else
varying vec2 v_uv0;
#endif
#if __VERSION__ > 120 
#ifndef texture2D
#define texture2D(tex,coord) texture( tex, coord )
#endif
#define textureCube(tex,coord) texture( tex, coord )
#endif
#ifdef ENABLE_SOFT
uniform sampler2D u_depthSampler0;
uniform vec4 u_softParameters; 
uniform mat4 u_invProj; 
varying float v_eyeLinearZ;
float ComputeSoftFactor()
    vec2 normalizedFragCoord = gl_FragCoord.xy * u_softParameters.zw;
float depthValue = texture2D(u_depthSampler0, gl_FragCoord.xy * u_softParameters.zw).x;
    
    vec3 screenPos = vec3(normalizedFragCoord, depthValue);
vec4 viewPos = u_invProj * vec4(screenPos * 2. - 1., 1.);
viewPos /= viewPos.w;
    
    float factor = clamp((v_eyeLinearZ - viewPos.z) * u_softParameters.x ,0. , 1.);
    
    
    
    return factor;
#endif
void main(){
#ifdef ENABLE_CUBE_MAP
    vec2 p = v_uv0 * 2. - 1.;
    float r = dot(p,p); 
    vec4 tex = textureCube(u_textureSampler0, v_normal.xyz) * clamp(9.6 - 10. * r, 0., 1.0);
    
    tex.rgb *= pow(r, u_fresnelExponent);
#else 
#ifdef ENABLE_ANIMATION 
    vec4 tex = mix(texture2D(u_textureSampler0, v_uv0.xy),
                   texture2D(u_textureSampler0, v_uv1.xy), v_uv0.z);
#else
    vec4 tex = texture2D(u_textureSampler0, v_uv0);
#endif 
#endif 
#ifdef ENABLE_SOFT
    tex *= ComputeSoftFactor();
#endif
    
    
#ifdef ENABLE_CUBE_MAP
    gl_FragColor.a = v_vertexColor.a * tex.a; 
#ifdef ENABLE_FOG
    gl_FragColor.rgb = mix(v_vertexColor.rgb + tex.rgb, u_fogColor.rgb, v_normal.a) * gl_FragColor.a; 
#else
    gl_FragColor.rgb = (v_vertexColor.rgb + tex.rgb) * gl_FragColor.a; 
#endif 
#else
    gl_FragColor = v_vertexColor * tex; 
#endif
attribute vec4 a_position;
varying vec2 uv;
void main(void)
    gl_Position = a_position;
    uv = (a_position.xy + 1.0) * 0.5;
attribute vec3 a_position;
varying vec2 TexCoord;
uniform mat4 u_textureMatrix;
void main(void)
gl_Position = vec4(a_position, 1.0);
    TexCoord = (u_textureMatrix * vec4(a_position.xy, 0., 1.)).xy * 0.5 + 0.5;
TexCoord.y = 1.0 - TexCoord.y;
uniform sampler2D textureSampler0;
uniform float factor;
varying vec2 TexCoord;
void main (void)
gl_FragColor =
texture2D(textureSampler0,TexCoord) * factor;
uniform sampler2D u_textureSampler0;
varying vec2 v_uv0;
varying vec4 v_vertexColor;
void main(){
    vec4 tex = texture2D(u_textureSampler0, v_uv0);
    tex.rgb *= tex.a; 
    
    vec4 col = v_vertexColor * tex;
gl_FragColor = vec4(col);
struct SCNShaderGeometry
vec4 position;
vec3 normal;
vec4 tangent;
vec4 color;
vec2 texcoords[8]; 
} _geometry;
attribute vec4 a_position;
uniform vec2 u_inversePixelSize;
varying vec4 v_texCoord;
void main(void)
gl_Position = a_position;
    vec2 tc = (a_position.xy + 1.0) * 0.5;
    vec4 offset = vec4(-0.5, 0.5, -0.5, 0.5);
    v_texCoord = tc.xxyy + offset * u_inversePixelSize.xyxy;
struct SCNShaderLight
vec4 intensity; 
vec3 direction; 
    
    
    float _att;
    vec3 dir; 
    float dist; 
varying vec4 v_vertexColor;
varying vec2 v_texCoord;
uniform sampler2D u_sampler;
void main()
    vec4 mask = texture2D(u_sampler, v_texCoord);
    gl_FragColor = v_vertexColor * mask;
varying vec4 v_vertexColor;
void main()
    gl_FragColor = v_vertexColor;
uniform sampler2D u_color;
uniform sampler2D u_depth;
uniform float     u_middleZ;
varying vec2 TexCoord;
void main (void)
gl_FragColor = texture2D(u_color,TexCoord);
    
#ifndef GL_ES
    gl_FragDepth = texture2D(u_depth,TexCoord).r;
    
    if(gl_FragDepth == 1.0){
        gl_FragDepth = u_middleZ;
    }
#endif
    
    
    
    
attribute vec4 a_position;
varying vec2 v_texCoord;
void main(void)
gl_Position = a_position;
    v_texCoord = (a_position.xy + 1.0) * 0.5;
uniform mat4 u_modelViewProjectionTransform;
attribute vec3 a_position;
void main()
    gl_Position = u_modelViewProjectionTransform * vec4(a_position, 1.);
uniform float u_floorReflectivity;
uniform sampler2D u_floorReflectionColor;
uniform vec4 u_floor_viewport;
#ifdef USE_FALLOFF
uniform mat4 u_floorMVP_i;
uniform vec4 u_floorPlane;
uniform float u_floorFalloff;
#ifdef USE_FALLOFF_START
uniform float u_floorFalloffStart;
#endif
uniform sampler2D u_floorReflectionDepth;
vec3 floorUnprojectPoint(vec3 screenPos)
    vec4 pTmp;
    pTmp.xyz = (2.0 * screenPos.xyz) - 1.0;
    pTmp.w = 1.0;
    pTmp = u_floorMVP_i * pTmp;
    pTmp /= pTmp.w;
    return vec3(pTmp);
#endif 
#pragma body
vec2 normalizedFragCoord = gl_FragCoord.xy * u_floor_viewport.zw;
normalizedFragCoord.xy += 0.2 * _surface._normalTS.xy;
vec4 floorColor = texture2D(u_floorReflectionColor, normalizedFragCoord);
float reflectionFactor = u_floorReflectivity;
#ifdef USE_FALLOFF
float floorDepth = texture2D(u_floorReflectionDepth, normalizedFragCoord).x;
vec3  floorPW = floorUnprojectPoint(vec3(normalizedFragCoord, floorDepth));
float floorDist = - dot(vec4(floorPW.xyz, 1.0), u_floorPlane);
#ifdef USE_FALLOFF_START
floorDist -= u_floorFalloffStart; 
#endif 
reflectionFactor *= 1.0 - clamp(floorDist / u_floorFalloff, 0.0, 1.0);
#endif 
floorColor *= reflectionFactor; 
_output.color.rgb *= (1. - floorColor.a); 
_output.color.rgba += floorColor.rgba; 
void main (void)
gl_FragColor =
vec4(1.0,0.0,1.0,1.0);
float hash(vec2 p)
    p  = fract(p * vec2(443.8975,397.2973));
    p += dot(p.xy, p.yx+19.19);
    return fract(p.x * p.y);
#pragma body
float x = hash(u_modelTransform[3].xy);
_output.color = vec4(x+1./255.);
#ifdef USE_PER_VERTEX_LIGHTING
varying vec3 v_diffuse;
#ifdef USE_SPECULAR
varying vec3 v_specular;
#endif
#endif
#if defined(USE_POSITION) && (USE_POSITION == 2)
varying vec3 v_position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2)
varying vec3 v_normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
varying vec3 v_tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
varying vec3 v_bitangent;
#endif
#ifdef USE_AMBIENT_LIGHTING
uniform vec4 u_ambientLightColor;
#endif
#ifdef USE_DIFFUSE_MAP
uniform sampler2D u_diffuseTexture;
#ifdef USE_DIFFUSE_INTENSITY
uniform float u_diffuseIntensity;
#endif
#elif defined(USE_DIFFUSE_COLOR)
uniform vec4 u_diffuseColor;
#endif
#ifdef USE_NORMAL_MAP
uniform sampler2D u_normalTexture;
#ifdef USE_NORMAL_INTENSITY
uniform float u_normalIntensity;
#endif
#endif
#ifdef USE_SHININESS
uniform float u_materialShininess;
#endif
#ifdef USE_SPECULAR
#ifdef USE_SPECULAR_MAP
uniform sampler2D u_specularTexture;
#ifdef USE_SPECULAR_INTENSITY
uniform float u_specularIntensity;
#endif
#elif defined(USE_SPECULAR_COLOR)
uniform vec4 u_specularColor;
#endif
#endif 
#ifdef USE_AMBIENT_MAP
uniform sampler2D u_ambientTexture;
#ifdef USE_AMBIENT_INTENSITY
uniform float u_ambientIntensity;
#endif
#elif defined(USE_AMBIENT_COLOR)
uniform vec4 u_ambientColor;
#endif
#ifdef USE_REFLECTIVE_MAP
uniform sampler2D u_reflectiveTexture;
#elif defined(USE_REFLECTIVE_COLOR)
uniform vec4 u_reflectiveColor;
#endif
#if defined(USE_REFLECTIVE_CUBEMAP)
uniform samplerCube u_reflectiveTexture;
#endif
#if defined(USE_REFLECTIVE_CUBEMAP)
uniform mat4 u_viewToCubeWorld;
#endif
#ifdef USE_REFLECTIVE_INTENSITY
uniform float u_reflectiveIntensity;
#endif
#ifdef USE_FRESNEL
uniform vec3 u_fresnel; 
#endif
#ifdef USE_EMISSION_MAP
uniform sampler2D u_emissionTexture;
#ifdef USE_EMISSION_INTENSITY
uniform float u_emissionIntensity;
#endif
#elif defined(USE_EMISSION_COLOR)
uniform vec4 u_emissionColor;
#endif
#ifdef USE_MULTIPLY_MAP
uniform sampler2D u_multiplyTexture;
#ifdef USE_MULTIPLY_INTENSITY
uniform float u_multiplyIntensity;
#endif
#elif defined(USE_MULTIPLY_COLOR)
uniform vec4 u_multiplyColor;
#endif
#ifdef USE_TRANSPARENT_MAP
uniform sampler2D u_transparentTexture;
#ifdef USE_TRANSPARENT_INTENSITY
uniform float u_transparentIntensity;
#endif
#elif defined(USE_TRANSPARENT_COLOR)
uniform vec4 u_transparentColor;
#endif
#ifdef USE_VERTEX_COLOR
varying vec4 v_vertexColor;
#endif
#ifdef USE_NODE_OPACITY 
uniform float u_nodeOpacity;
#endif
#ifdef USE_TRANSPARENCY 
uniform float u_transparency;
#endif
#ifdef USE_DOUBLE_SIDED
uniform float u_orientationPreserved;
#endif
#ifdef USE_TIME
uniform float u_time;
#endif
#ifdef USE_FOG
uniform vec4 u_fogColor;
uniform vec3 u_fogParameters; 
#endif
float saturate(float x) {
    return clamp(x, 0., 1.);
vec2 saturate(vec2 x) {
    return clamp(x, vec2(0.), vec2(1.));
vec3 saturate(vec3 x) {
    return clamp(x, vec3(0.), vec3(1.));
vec4 saturate(vec4 x) {
    return clamp(x, vec4(0.), vec4(1.));
vec4 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)
    vec4 color = vec4(0.,0.,0., surface.diffuse.a);
    
    vec3 D = lighting.diffuse;
#ifdef USE_AMBIENT_LIGHTING
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    D += lighting.ambient * surface.ambientOcclusion;
#elif defined(LOCK_AMBIENT_WITH_DIFFUSE)
    D += lighting.ambient;
#endif
#endif 
#ifdef USE_EMISSION_AS_SELFILLUMINATION
    D += surface.emission.rgb;
#endif
    
    
    
    color.rgb = surface.diffuse.rgb * D;
#if 1 
#ifdef USE_SPECULAR
    vec3 S = lighting.specular;
#elif defined(USE_REFLECTIVE)
    vec3 S = vec3(0.);
#endif
#ifdef USE_REFLECTIVE
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    S += surface.reflective.rgb * surface.ambientOcclusion;
#else
    S += surface.reflective.rgb;
#endif
#endif
#ifdef USE_SPECULAR
    S *= surface.specular.rgb;
#endif
#if defined(USE_SPECULAR) || defined(USE_REFLECTIVE)
    color.rgb += S;
#endif
#else
#ifdef USE_SPECULAR
    color.rgb += surface.specular.rgb * lighting.specular;
#endif
#ifdef USE_REFLECTIVE
    color.rgb += surface.reflective.rgb * (lighting.diffuse + lighting.ambient);
#endif
#endif 
#if defined(USE_AMBIENT) && !defined(USE_AMBIENT_AS_AMBIENTOCCLUSION)
    color.rgb += surface.ambient.rgb * lighting.ambient;
#endif
#if defined(USE_EMISSION) && !defined(USE_EMISSION_AS_SELFILLUMINATION)
    color.rgb += surface.emission.rgb;
#endif
#ifdef USE_MULTIPLY
    color.rgb *= surface.multiply.rgb;
#endif
#ifdef USE_MODULATE
    color.rgb *= lighting.modulate;
#endif
    return color;
struct SCNOutput
    vec4 color;
} _output;
void main(void)
#ifdef USE_TEXCOORD
    __DoTexcoord__
#endif
    
    _surface.ambientOcclusion = 1.0;
    
    
#ifdef USE_AMBIENT_MAP
    _surface.ambient = texture2D(u_ambientTexture, _surface.ambientTexcoord);
#ifdef USE_AMBIENT_INTENSITY
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    _surface.ambientOcclusion = mix(1., _surface.ambient.r, u_ambientIntensity);
#else
    _surface.ambient *= u_ambientIntensity;
#endif
#endif
#elif defined(USE_AMBIENT_COLOR)
    _surface.ambient = u_ambientColor;
#elif defined(USE_AMBIENT)
    _surface.ambient = vec4(0.);
#endif
#if defined(USE_AMBIENT) && defined(USE_VERTEX_COLOR)
    _surface.ambient *= v_vertexColor;
#endif
    
    
#ifdef USE_DIFFUSE_MAP
    _surface.diffuse = texture2D(u_diffuseTexture, _surface.diffuseTexcoord);
#ifdef USE_DIFFUSE_INTENSITY
    _surface.diffuse.rgb *= u_diffuseIntensity;
#endif
#elif defined(USE_DIFFUSE_COLOR)
    _surface.diffuse = u_diffuseColor;
#elif defined(USE_DIFFUSE)
    _surface.diffuse = vec4(0.,0.,0.,1.);
#endif
#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)
    _surface.diffuse *= v_vertexColor;
#endif
    
    
#ifdef USE_SPECULAR_MAP
    _surface.specular = texture2D(u_specularTexture, _surface.specularTexcoord);
#ifdef USE_SPECULAR_INTENSITY
    _surface.specular *= u_specularIntensity;
#endif
#elif defined(USE_SPECULAR_COLOR)
    _surface.specular = u_specularColor;
#elif defined(USE_SPECULAR)
    _surface.specular = vec4(0.);
#endif
    
    
#ifdef USE_EMISSION_MAP
    _surface.emission = texture2D(u_emissionTexture, _surface.emissionTexcoord);
#ifdef USE_EMISSION_INTENSITY
    _surface.emission *= u_emissionIntensity;
#endif
#elif defined(USE_EMISSION_COLOR)
    _surface.emission = u_emissionColor;
#elif defined(USE_EMISSION)
    _surface.emission = vec4(0.);
#endif
    
    
#ifdef USE_MULTIPLY_MAP
    _surface.multiply = texture2D(u_multiplyTexture, _surface.multiplyTexcoord);
#ifdef USE_MULTIPLY_INTENSITY
    _surface.multiply = mix(vec4(1.), _surface.multiply, u_multiplyIntensity);
#endif
#elif defined(USE_MULTIPLY_COLOR)
    _surface.multiply = u_multiplyColor;
#elif defined(USE_MULTIPLY)
    _surface.multiply = vec4(1.);
#endif
    
    
#ifdef USE_TRANSPARENT_MAP
    _surface.transparent = texture2D(u_transparentTexture, _surface.transparentTexcoord);
#ifdef USE_TRANSPARENT_INTENSITY
    _surface.transparent *= u_transparentIntensity;
#endif
#elif defined(USE_TRANSPARENT_COLOR)
    _surface.transparent = u_transparentColor;
#elif defined(USE_TRANSPARENT)
    _surface.transparent = vec4(1.);
#endif
    
    
#if (defined USE_NORMAL) && (USE_NORMAL == 2)
#ifdef USE_DOUBLE_SIDED
    _surface.normal = normalize(v_normal.xyz) * u_orientationPreserved * ((float(gl_FrontFacing) * 2.0) - 1.0);
#else
    _surface.normal = normalize(v_normal.xyz);
#endif
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    _surface.tangent = v_tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    _surface.bitangent = v_bitangent;
#endif
#if (defined USE_POSITION) && (USE_POSITION == 2)
    _surface.position = v_position;
#endif
#if (defined USE_VIEW) && (USE_VIEW == 2)
    _surface.view = normalize(-v_position);
#endif
#ifdef USE_NORMAL_MAP
    mat3 ts2vs = mat3(_surface.tangent, _surface.bitangent, _surface.normal);
    _surface._normalTS = texture2D(u_normalTexture, _surface.normalTexcoord).rgb * 2. - 1.;
    
#ifdef USE_NORMAL_INTENSITY
    _surface._normalTS = mix(vec3(0., 0., 1.), _surface._normalTS, u_normalIntensity);
#endif
    
    _surface.normal.rgb = normalize(ts2vs * _surface._normalTS);
#else
    _surface._normalTS = vec3(0., 0., 0.);
#endif
    
    
#ifdef USE_REFLECTIVE_MAP
    vec3 refl = reflect( -_surface.view, _surface.normal );
    float m = 2.0 * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.0)*(refl.z+1.0));
    _surface.reflective = texture2D(u_reflectiveTexture,vec2(vec2(refl.x,-refl.y) / m) + 0.5) ;
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective.rgb *= u_reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_CUBEMAP)
    vec3 refl = reflect( _surface.position, _surface.normal );
    _surface.reflective = textureCube(u_reflectiveTexture, mat3(u_viewToCubeWorld) * refl); 
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective.rgb *= u_reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_COLOR)
    _surface.reflective = u_reflectiveColor;
#elif defined(USE_REFLECTIVE)
    _surface.reflective = vec4(0.);
#endif
#ifdef USE_FRESNEL
    _surface.fresnel = u_fresnel.x + u_fresnel.y * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), u_fresnel.z);
    _surface.reflective *= _surface.fresnel;
#endif
#ifdef USE_SHININESS
    _surface.shininess = u_materialShininess;
#endif
    
    
    
    
#ifdef USE_SURFACE_MODIFIER
__DoSurfaceModifier__
#endif
    
    
    
#ifdef USE_AMBIENT_LIGHTING
    _lightingContribution.ambient = u_ambientLightColor.rgb;
#elif defined(USE_AMBIENT)
    _lightingContribution.ambient = vec3(0.);
#endif
    
#ifdef USE_LIGHTING
#ifdef USE_PER_PIXEL_LIGHTING
    _lightingContribution.diffuse = vec3(0.);
#ifdef USE_MODULATE
    _lightingContribution.modulate = vec3(1.);
#endif
#ifdef USE_SPECULAR
    _lightingContribution.specular = vec3(0.);
#endif
    
    __DoLighting__
    
#else 
    _lightingContribution.diffuse = v_diffuse;
#ifdef USE_SPECULAR
    _lightingContribution.specular = v_specular;
#endif
#endif
    
    
#ifdef AVOID_OVERLIGHTING
    _lightingContribution.diffuse = clamp(_lightingContribution.diffuse, vec3(0.), vec3(1.));
#ifdef USE_SPECULAR
    _lightingContribution.specular = clamp(_lightingContribution.specular, vec3(0.), vec3(1.));
#endif 
#endif 
#else 
    _lightingContribution.diffuse = vec3(1.);
#endif 
    
    
    _output.color = illuminate(_surface, _lightingContribution);
    
#ifdef USE_FOG
    float fogFactor = pow(clamp(length(_surface.position.xyz) * u_fogParameters.x + u_fogParameters.y, 0., u_fogColor.a), u_fogParameters.z);
    _output.color.rgb = mix(_output.color.rgb, u_fogColor.rgb * _output.color.a, fogFactor);
#endif
    
#ifndef DIFFUSE_PREMULTIPLIED
    _output.color.rgb *= _surface.diffuse.a;
#endif
    
#ifdef USE_TRANSPARENT 
    
#ifdef USE_TRANSPARENCY
    _surface.transparent *= u_transparency;
#endif
    
#ifdef USE_TRANSPARENCY_RGBZERO
#ifdef USE_NODE_OPACITY
    _output.color *= u_nodeOpacity;
#endif
    
    _surface.transparent.a = (_surface.transparent.r * 0.212671) + (_surface.transparent.g * 0.715160) + (_surface.transparent.b * 0.072169);
    _output.color *= (vec4(1.) - _surface.transparent);
#else 
    _output.color *= _surface.transparent.a;
#endif
#else
#ifdef USE_TRANSPARENCY 
    _output.color *= u_transparency;
#endif
#endif
    
#ifdef USE_FRAGMENT_MODIFIER
__DoFragmentModifier__
#endif
    
#ifdef USE_DISCARD
    if (_output.color.a == 0.) 
        discard;
#endif
    
    gl_FragColor = _output.color;
uniform mat4 u_modelTransform;
#define MOD2 vec2(443.8975,397.2973)
float hash(vec2 p)
    p  = fract(p * MOD2);
    p += dot(p.xy, p.yx+19.19);
    return fract(p.x * p.y);
void main()
    float x = hash(u_modelTransform[3].xy);
gl_FragColor = vec4(vec3(x+1./255.),1.);
uniform samplerCube textureSampler0;
varying vec3 TexCoord;
#if __VERSION__ > 120 
#define textureCube(tex,coord) texture( tex, coord )
#endif
void main (void)
    
gl_FragColor = textureCube(textureSampler0,TexCoord);
struct SCNShaderSurface
vec3 view; 
vec3 position; 
vec3 normal; 
vec3 tangent; 
vec3 bitangent; 
float shininess;
    float fresnel;
    float ambientOcclusion;
vec3 _normalTS; 
uniform sampler2D sceneColor;
uniform sampler2D authoringColor;
varying vec2 uv;
void main()
    vec4 scene = texture2D(sceneColor, uv);
    vec4 authoring = texture2D(authoringColor, uv);
    
    gl_FragColor = mix(scene, authoring, authoring.a);
uniform sampler2D downSampler;
uniform sampler2D depthSampler;
uniform vec3 CocScaleBias;
varying vec2 v_texCoord;
void main (void)
    vec4 down = texture2D( downSampler, v_texCoord);
    float depth = texture2D( depthSampler, v_texCoord).r;
    float coc = step(0., (depth * CocScaleBias.x + CocScaleBias.y)); 
gl_FragColor = vec4(down.rgb, coc * down.a);
    
    
#ifdef USE_PCF
#ifdef GL_EXT_shadow_samplers 
#extension GL_EXT_shadow_samplers : require
#endif
#endif
#if MAX_SAMPLE > 1
uniform vec4 u_kernel[MAX_SAMPLE];
#endif
uniform vec4 shadowColor;
uniform sampler2D colorSampler;
uniform sampler2D depthSampler;
#ifdef USE_PCF
#ifdef GL_EXT_shadow_samplers 
    uniform sampler2DShadow lightDepthSampler;
    #define __shadow2DProj(tex,coord) shadow2DProjEXT( tex, coord )
#elif __VERSION__ <= 120 
    uniform sampler2DShadow lightDepthSampler;
    #define __shadow2DProj(tex,coord) shadow2DProj( tex, coord ).x
#else 
    uniform sampler2DShadow lightDepthSampler;
    #define __shadow2DProj(tex,coord) textureProj( tex, coord )
#endif
#else 
    uniform sampler2D lightDepthSampler;
    #define __shadow2DProj(tex, coord) clamp(coord.z - texture2DProj(tex, coord).x * coord.w, 0.0, 1.0);
#endif
uniform mat4  camera_MVP_i;
uniform mat4  light_MVP;
uniform vec3  u_lightPos;
uniform vec3  u_lightDir;
uniform vec3  u_lightSpotAtt;
uniform float shadowRadius;
#ifndef TARGET_OS_IPHONE
    #ifdef SPOT_SHADOW
        #define USE_SPOT_ATTENUATION 1
    #else
        #define USE_SPOT_ATTENUATION 0
    #endif
#else
    #define USE_SPOT_ATTENUATION 0
#endif
varying vec2 TexCoord;
vec3 unprojectPoint(vec3 screenPos)
vec4 pTmp;
    pTmp.xyz = (2.0 * screenPos.xyz) - 1.0;
pTmp.w = 1.0;
pTmp = camera_MVP_i * pTmp;
    pTmp /= pTmp.w;
return vec3(pTmp);
void main (void)
    
    vec4 color = texture2D(colorSampler, TexCoord);
    
float depthValue = texture2D(depthSampler, TexCoord).x;
vec3 worldPos = unprojectPoint(vec3(TexCoord, depthValue));
vec4 lightScreen =  light_MVP * vec4(worldPos, 1.0);
    
    
#if USE_SPOT_ATTENUATION
    vec3 lightToFragment = normalize(u_lightPos - worldPos);
    
    
    float att;
    if (u_lightSpotAtt.z == 0.0)
        att = step(u_lightSpotAtt.x, dot(lightToFragment, u_lightDir) + 0.00004);
    else
        att = pow(clamp(dot(lightToFragment, u_lightDir) * u_lightSpotAtt.x + u_lightSpotAtt.y, 0.0, 1.0), u_lightSpotAtt.z);
    
    if (att == 0.) {
        gl_FragColor = color.rgba;
        return;
    }
#endif 
    
    
#if MAX_SAMPLE == 1
    float shadow = __shadow2DProj(lightDepthSampler, lightScreen);
#else
    
    float filteringSizeFactor = shadowRadius * lightScreen.w;
    
    
    float totalAccum = 0.0;
    for(int i=0; i<MAX_SAMPLE; i++){
        totalAccum += __shadow2DProj(lightDepthSampler, lightScreen + (u_kernel[i] * filteringSizeFactor));
    }
    
    float shadow = totalAccum / float(MAX_SAMPLE);
#endif
    
#if !USE_SPOT_ATTENUATION
    shadow *= step(0., lightScreen.w);
#endif
    
    
    
    shadow *= shadowColor.a;
#if USE_SPOT_ATTENUATION
    shadow = shadow * att;
#endif
    
    
    gl_FragColor = mix(color.rgba, vec4(shadowColor.rgb, 1.0),  shadow);
varying vec2 TexCoord;
uniform sampler2D textureSampler0;
uniform vec2 offsets[MAX_SAMPLE];
uniform float weights[MAX_SAMPLE];
uniform int n_sample;
void main (void)
    int i;
    vec4 accum = vec4(0.0);
    for(i=0;i<n_sample;i++){
        accum += texture2D(textureSampler0, TexCoord+offsets[i]) *  weights[i];
    }
gl_FragColor = accum;
#extension GL_ARB_shader_texture_lod : enable
uniform sampler2D textureSampler0;
varying vec2 TexCoord;
void main (void)
gl_FragColor =
texture2DLod(textureSampler0,TexCoord, 0.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 1.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 2.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 3.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 4.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 5.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 6.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 7.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 8.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 9.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 10.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 11.0);    
    gl_FragColor /= 12.0;
uniform sampler2D colorSampler;
uniform sampler2D smallBlurSampler;
uniform sampler2D largeBlurSampler;
uniform sampler2D depthSampler;
uniform vec2 u_inversePixelSize;
uniform vec4 dofLerpScale;
uniform vec4 dofLerpBias;
uniform vec3 CocScaleBias;
varying vec2 v_texCoord;
float saturate(float val)
    return clamp(val, 0., 1.);
vec4 saturate(vec4 val)
    return clamp(val, vec4(0.), vec4(1.));
vec4 tex2Doffset(sampler2D s, vec2 tc, vec2 offset )
  return texture2D( s, tc + offset * u_inversePixelSize );
vec3 GetSmallBlurSample( vec3 unblur, vec2 tc )
    
    
    
    vec3 sum = tex2Doffset( colorSampler, tc, vec2(+0.5, -1.5) ).rgb;
    sum += tex2Doffset( colorSampler, tc, vec2(-1.5, -0.5) ).rgb;
    sum += tex2Doffset( colorSampler, tc, vec2(-0.5, +1.5) ).rgb;
    sum += tex2Doffset( colorSampler, tc, vec2(+1.5, +0.5) ).rgb;
    return (4.0 * sum + unblur) / 17.;
vec4 InterpolateDof( vec3 unblur, vec3 small, vec3 med, vec3 large, float t )
    
    
    
    
    
    
    
    
    vec4 weights = saturate( t * dofLerpScale + dofLerpBias );
    weights.yz = min( weights.yz, 1. - weights.xy );
    
    
    
    
    vec3 color = weights.x * unblur + weights.y * small + weights.z * med + weights.w * large;
    return vec4(color, 1.);
    
    
    
    
#define DEBUG 0
void main (void)
    vec3 unblur = texture2D( colorSampler, v_texCoord ).rgb;
    vec3 small 
= GetSmallBlurSample(unblur, v_texCoord );
    vec4 med 
= texture2D( smallBlurSampler, v_texCoord );
    vec3 large 
= texture2D( largeBlurSampler, v_texCoord ).rgb;
    float nearCoc = med.a;
    float depth = texture2D( depthSampler, v_texCoord ).r;
    
    
    float farCoc = saturate( - (CocScaleBias.x * depth + CocScaleBias.y) );
    float coc;
    
    
    
    
    {
        
        coc = max( nearCoc, farCoc  );
    }
    gl_FragColor = InterpolateDof( unblur, small, med.rgb, large.rgb, coc );
#if DEBUG
    if (v_texCoord.x < 0.15) {
        gl_FragColor = vec4(unblur, 1.);
    } else if (v_texCoord.x < 0.3) {
        gl_FragColor = vec4(small, 1.);
    } else if (v_texCoord.x < 0.45) {
        gl_FragColor = med;
    } else if (v_texCoord.x < 0.6) {
        gl_FragColor = vec4(large, 1.);
        
    } else if (v_texCoord.x < 0.70) {
        gl_FragColor = vec4(nearCoc, nearCoc, nearCoc, 1.);
    } else if (v_texCoord.x < 0.8){
        gl_FragColor = vec4(farCoc, farCoc, farCoc, 1.);
    }
#endif
    
uniform mat4 u_modelViewProjectionTransform;
attribute vec4 a_position;
attribute vec4 a_color;
varying vec3 v_vertexCenter;
void main()
    vec3 pos = a_position.xyz;
    int id = int(a_position.w); 
    gl_Position = (u_modelViewProjectionTransform * vec4(pos, 1.0));
    
    float s = 1.;
    mat3 centers = mat3(vec3(s, 0. ,0.), vec3(0., s, 0.), vec3(0., 0., s));
    v_vertexCenter = centers[id];
  uniform vec3 u_floorNormal;
  uniform vec4 u_floorTangent;
  uniform vec3 u_floorCenter;
  uniform vec2 u_floorExtent;
#pragma body
  vec3 floorBitangent =  normalize(cross(u_floorTangent.xyz, u_floorNormal));
  _geometry.position.xyz = u_floorCenter.xyz + u_floorExtent.x * (_geometry.position.x * u_floorTangent.xyz) + u_floorExtent.y * (_geometry.position.y * floorBitangent);
  _geometry.normal = u_floorNormal;
  _geometry.tangent = u_floorTangent;
  vec2 tc;
  if (u_floorNormal.y != 0.)
    tc = _geometry.position.xz * 0.01;
  else if (u_floorNormal.z != 0.)
    tc = _geometry.position.xy * 0.01;
  else
    tc = _geometry.position.yz * 0.01;
  for (int i = 0; i < kSCNTexcoordCount; ++i)
    _geometry.texcoords[i] = tc;
uniform mat4 u_modelViewProjectionTransform;
uniform mat4 u_transform;
uniform vec4 u_color;
attribute vec3 a_position;
varying vec4 v_vertexColor;
void main()
    gl_Position = u_modelViewProjectionTransform * u_transform * vec4(a_position, 1.);
    v_vertexColor = u_color;
uniform mat4 u_modelViewProjectionTransform;
attribute vec3 a_position;
attribute vec4 a_color;
attribute vec2 a_texCoord0;
varying vec4 v_vertexColor;
varying vec2 v_texCoord;
void main()
    gl_Position = u_modelViewProjectionTransform * vec4(a_position, 1.);
    v_vertexColor = a_color;
    v_texCoord = a_texCoord0;
attribute vec3 a_position;
uniform mat4 u_m;
varying vec2 TexCoord;
void main(void)
gl_Position = u_m * vec4(a_position, 1.0);
TexCoord = (gl_Position.xy + 1.0) * 0.5;
attribute vec4 a_position;
uniform vec2 u_inversePixelSize;
varying vec2 v_tcColor0;
varying vec2 v_tcColor1;
varying vec2 v_tcDepth0;
varying vec2 v_tcDepth1;
varying vec2 v_tcDepth2;
varying vec2 v_tcDepth3;
void main(void)
gl_Position = a_position;
    vec2 tc = (a_position.xy + 1.0) * 0.5;
    v_tcColor0 = tc + vec2( -1.5, -1.5) * u_inversePixelSize * 0.25;
    v_tcColor1 = tc + vec2( +0.5, -1.5) * u_inversePixelSize * 0.25;
    v_tcDepth0 = tc + vec2( -2., -2. ) * u_inversePixelSize * 0.25;
    v_tcDepth1 = tc + vec2( -1., -2. ) * u_inversePixelSize * 0.25;
    v_tcDepth2 = tc + vec2( +0., -2. ) * u_inversePixelSize * 0.25;
    v_tcDepth3 = tc + vec2( +1., -2. ) * u_inversePixelSize * 0.25;
attribute vec2 a_texCoord1; 
attribute vec4 a_position; 
attribute vec3 a_texCoord0; 
attribute vec4 a_color; 
#ifdef ENABLE_STRETCH
attribute vec4 a_texCoord2; 
uniform float u_stretchFactor;
#elif defined(ENABLE_ORIENTATION_FREE)
attribute vec4 a_texCoord2; 
mat3 axisangle_to_matrix(vec4 axis_angle)
float c = cos(axis_angle.w);
    float s = sin(axis_angle.w);
    float t = 1. - c;
    
    mat3 m;
    m[0][0] = c + axis_angle.x * axis_angle.x * t;
    m[1][1] = c + axis_angle.y * axis_angle.y * t;
    m[2][2] = c + axis_angle.z * axis_angle.z * t;
    
float tmp1 = axis_angle.x * axis_angle.y * t;
    float tmp2 = axis_angle.z * s;
    m[1][0] = tmp1 + tmp2;
    m[0][1] = tmp1 - tmp2;
    
    tmp1 = axis_angle.x * axis_angle.z * t;
    tmp2 = axis_angle.y * s;
    m[2][0] = tmp1 - tmp2;
    m[0][2] = tmp1 + tmp2;
    
    tmp1 = axis_angle.y*axis_angle.z*t;
    tmp2 = axis_angle.x*s;
    m[2][1] = tmp1 + tmp2;
    m[1][2] = tmp1 - tmp2;
    return m;
#endif
#ifdef ENABLE_FOG
uniform mediump vec4 u_fogColor;
uniform vec3 u_fogParameters; 
#endif
#ifdef ENABLE_SOFT
varying float v_eyeLinearZ;
#endif
#ifdef ENABLE_CUBE_MAP
uniform mat4 u_viewToCubeWorld;
varying vec4 v_normal;
#endif
#ifdef ENABLE_ANIMATION
#define REPEAT 0
#define CLAMP 1
#define AUTOREVERSE  2
uniform vec4 u_frameSize; 
float __modf(float value, out float intValue)
float fracValue = fract(value);
intValue = value - fracValue;
return fracValue;
vec4 ComputeUVS(vec2 iNormUV, float iFrame)
vec4 outUV;
#if ENABLE_ANIMATION == CLAMP
    
    iFrame = clamp(iFrame, 0., u_frameSize.w - 1.); 
    
    float intFrame;
    float frameFrac = __modf(iFrame, intFrame);
    vec2 frame;
    frame.x = __modf(intFrame * u_frameSize.x, frame.y);
    frame.y *= u_frameSize.y;
    
    outUV.xy = frame + iNormUV * u_frameSize.xy;
    outUV.w = frameFrac;
    outUV.z = ((frame.x + u_frameSize.x) == 1.)?1.:0.; 
#elif ENABLE_ANIMATION == REPEAT
    
    float tmp = iFrame * u_frameSize.x;
    
    vec2 frame;
    frame.y = tmp - fract(tmp);
    frame.x = fract(tmp) * u_frameSize.z;
    
    float frameFrac = fract(frame.x);
    frame.x -= frameFrac;
    
    outUV.xy = (frame + iNormUV) * u_frameSize.xy;
    outUV.w = frameFrac;
    outUV.z = (frame.x == (u_frameSize.z - 1.))?1.:0.; 
#else 
    
    float invFrameCount = u_frameSize.x * u_frameSize.y;
    float normFrame = iFrame * invFrameCount;
    float lastFrame = u_frameSize.w - 1.;
    float frameIndex = fract(normFrame) * u_frameSize.w;
    if (fract(normFrame * 0.5) > 0.5) {
        frameIndex = (lastFrame-frameIndex);
    }
    frameIndex = clamp(frameIndex, 0., lastFrame); 
    
    float tmp = frameIndex * u_frameSize.x;
    
    vec2 frame;
    frame.y = tmp - fract(tmp);
    
    frame.x = fract(tmp) * u_frameSize.z;
    
    float frameFrac = fract(frame.x);
    frame.x -= frameFrac;
    
    outUV.xy = (frame + iNormUV) * u_frameSize.xy;
    
    outUV.w = frameFrac;
    outUV.z = (frame.x == (u_frameSize.z - 1.))?1.:0.; 
#endif
return outUV;
#endif
uniform mat4 viewTransform; 
uniform mat4 u_projectionTransform;
#ifdef ENABLE_LIGHTING
uniform vec3 u_lightPosition0; 
uniform vec4 u_lightColor0;
#endif
#ifdef ENABLE_COLOR_RAMP
uniform sampler2D u_colorRamp;
#endif
#ifdef ENABLE_ANIMATION
varying vec3 v_uv0;
varying vec2 v_uv1;
#else
varying vec2 v_uv0;
#endif
varying vec4 v_vertexColor;
void main()
    
    vec4 viewPos = viewTransform * vec4(a_position.xyz, 1);
#ifdef ENABLE_STRETCH
    
    vec4 viewDir = viewTransform * vec4(a_texCoord2.xyz, 0);
    viewDir *= u_stretchFactor;
    
    
    viewPos.xyz += (a_texCoord1.y > 0.) ? viewDir.xyz : vec3(0.);
    
    
    vec2 u = normalize(viewDir.xy); 
    vec2 r = vec2(-u.y, u.x);
    vec2 off = r * a_texCoord1.x + u * a_texCoord1.y ; 
    viewPos.xy += off * a_texCoord0.y; 
    vec3 N = normalize(vec3(-off.x, -off.y, -2));
    
#else 
    
    
    float sn = sin(a_position.w);
    float cs = cos(a_position.w);
    
    vec2 dir = vec2( a_texCoord1.x * cs - a_texCoord1.y * sn,  a_texCoord1.y * cs + a_texCoord1.x * sn);
    dir *= a_texCoord0.y;
#ifdef ENABLE_ORIENTATION_FREE
    
    
    mat3 vt = mat3(viewTransform[0].xyz, viewTransform[1].xyz, viewTransform[2].xyz);
    mat3 mat = vt * axisangle_to_matrix(a_texCoord2); 
    
#ifdef ENABLE_CUBE_MAP
    vec3 N = mat[0] * dir.x + mat[1] * dir.y + mat[2];
    viewPos.xy += dir;
#else
    vec3 off = mat[0] * dir.x + mat[1] * dir.y;
    viewPos.xyz += off;
#endif
    
    
#elif defined(ENABLE_BILLBOARD_VIEW)
    vec3 u = vec3(0,1,0);
    vec3 r = normalize(cross(u, -viewPos.xyz));
    vec3 off = dir.x * r + dir.y * u;
    viewPos.xyz += off;
    vec3 N = normalize(vec3(-off.x/a_texCoord0.y, -off.y/a_texCoord0.y, -2));
#elif defined(ENABLE_BILLBOARD_Y)
    vec3 u = (viewTransform * vec4(0, 1, 0, 0)).xyz;
    vec3 r = normalize(cross(u, vec3(0,0,1))); 
    vec3 off = dir.x * r + dir.y * u;
    viewPos.xyz += off;
    vec3 N = normalize(vec3(-off.x/a_texCoord0.y, -off.y/a_texCoord0.y, -2));
    
#else 
    viewPos.xy += dir;
    vec3 N = normalize(vec3(-dir.x, -dir.y, -2));
    
#endif 
#endif 
#ifdef ENABLE_CUBE_MAP
#ifdef ENABLE_ORIENTATION_FREE
    v_normal.xyz = N;
#else
    vec3 refl = reflect( viewPos.xyz, N );
    v_normal.xyz = mat3(u_viewToCubeWorld) * refl;
#endif 
#endif
#ifdef ENABLE_COLOR_RAMP
    v_vertexColor = a_color * texture2D(u_colorRamp, a_texCoord0.xx);
#else 
    v_vertexColor = a_color;
#endif
    
#ifndef ENABLE_BLACKPASS
#ifdef ENABLE_LIGHTING
    vec3 L = normalize(viewPos.xyz - u_lightPosition0);
#if defined(ENABLE_ORIENTATION_FREE) && !defined(ENABLE_CUBE_MAP)
    
    
    vec3 N = sign(dot(mat[2], viewPos.xyz)) * mat[2];
    
    float NdotL = dot(N, L);
    vec3 diff = u_lightColor0.rgb * (max(0.0, NdotL) + 0.3 * (1. - abs(NdotL)));
    
    float _shininess = 100.0;
    vec3 halfVector = normalize(L + viewPos.xyz);
    float spec = max(0.0, pow(max(0.0, dot(N, halfVector)), _shininess));
    v_vertexColor.rgb *= diff;
    v_vertexColor.rgb += spec;
#else
    
    vec3 diff = vec3(max(0.0, dot(N, L))) * u_lightColor0.rgb;
    
    
    
    
    
    v_vertexColor.rgb *= diff;
#endif 
#endif 
#endif 
    
#ifdef ENABLE_ANIMATION
    vec4 animUVS = ComputeUVS(a_texCoord1.xy * vec2(0.5, -0.5) + 0.5, a_texCoord0.z);
    v_uv0 = animUVS.xyw;
    v_uv1 = animUVS.xy + u_frameSize.xy * vec2(1.0, animUVS.z);
#else
    v_uv0 = a_texCoord1.xy * vec2(0.5, -0.5) + 0.5;
#endif
    
#ifndef ENABLE_BLACKPASS
    #ifdef ENABLE_FOG
        float fogFactor = pow(clamp(viewPos.z * u_fogParameters.x + u_fogParameters.y, 0.0, u_fogColor.a), u_fogParameters.z);
        #ifdef ENABLE_CUBE_MAP
            v_normal.a = fogFactor;
        #else
            
            v_vertexColor.rgb = mix(v_vertexColor.rgb, u_fogColor.rgb * v_vertexColor.a, fogFactor);
        #endif 
    #endif 
#endif 
#ifdef ENABLE_SOFT
    v_eyeLinearZ = viewPos.z;
#endif
    
    gl_Position = u_projectionTransform * viewPos;
uniform sampler2D colorBuffer;
uniform sampler2D pickedColorBuffer;
uniform sampler2D depthBuffer;
uniform sampler2D pickedDepthBuffer;
uniform vec2 u_inverseResolution;
varying vec2 uv;
void main()
    
    float texels[9];
    texels[0] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, -u_inverseResolution.y)).r;
    texels[1] = texture2D(pickedColorBuffer, uv + vec2(                0., -u_inverseResolution.y)).r;
    texels[2] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, -u_inverseResolution.y)).r;
    
    texels[3] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, 0.)).r;
    
    texels[5] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, 0.)).r;
    
    texels[6] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, u_inverseResolution.y)).r;
    texels[7] = texture2D(pickedColorBuffer, uv + vec2(                0., u_inverseResolution.y)).r;
    texels[8] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, u_inverseResolution.y)).r;
    
    
    
    vec3 a = vec3(texels[0],texels[3],texels[6]);
    vec3 b = vec3(texels[2],texels[5],texels[7]);
    bvec3 tmp = equal(a,b);
    vec3 retLin = mix( vec3(tmp), vec3(not(tmp)), vec3(equal(b,vec3(0.))) );
    
    
    a = vec3(texels[0],texels[1],texels[2]);
    b = vec3(texels[6],texels[7],texels[8]);
    tmp = equal(a,b);
    vec3 retCol = mix( vec3(tmp), vec3(not(tmp)), vec3(equal(b,vec3(0.))) );
    
    
    vec4 last = step(vec4(0.002), vec4(texels[5],texels[7],texels[8], min(retLin.x, retCol.x)) );
    
    
    float x = last.w + 2.*retLin.y + retLin.z - retCol.z - 2.*last.x - last.z;
    float y = last.w + 2.*retCol.y + retCol.z - retLin.z- 2.*last.y - last.z;
    float magnitude = sqrt( x*x + y*y );
    
    
    
    
    float depth = 1.;
    for(int i=-1; i<2; i++)
    for(int j=-1; j<2; j++)
        depth = min(depth, texture2D(pickedDepthBuffer, uv + u_inverseResolution*vec2(i,j)).r);
    
    
    
    if( texture2D(depthBuffer, uv).x < depth-0.0000001 &&  texture2D(pickedColorBuffer, uv).r > 0.  )
        gl_FragColor = vec4(.25);
    else
        gl_FragColor = vec4( min(magnitude/4.,1.) );
    
uniform sampler2D textureSampler0;
uniform sampler2D textureSampler1;
varying vec2 TexCoord;
void main (void)
gl_FragColor = texture2D(textureSampler0,TexCoord) + texture2D(textureSampler1,TexCoord);
uniform sampler2D textureSampler0;
varying vec2 TexCoord;
void main (void)
gl_FragColor =
texture2D(textureSampler0,TexCoord);
uniform sampler2D colorSampler;
varying vec4 v_texCoord;
void main (void)
    
    vec4 color;
    color  = texture2D( colorSampler, v_texCoord.xz );
    color += texture2D( colorSampler, v_texCoord.yz );
    color += texture2D( colorSampler, v_texCoord.xw );
    color += texture2D( colorSampler, v_texCoord.yw );
    color *= 0.25;
    
gl_FragColor = vec4(color);
attribute vec4 a_position;
attribute vec4 a_texCoord0; 
attribute vec4 a_texCoord1; 
attribute vec4 a_color; 
uniform mat4 viewTransform; 
uniform mat4 u_projectionTransform;
varying vec2 v_uv0;
varying vec4 v_vertexColor;
void main()
    
    vec4 viewPos = viewTransform * vec4(a_position.xyz, 1);
    vec2 dir0 = normalize((viewTransform * vec4(normalize(a_texCoord1.xyz), 0)).xy);
    vec2 tangent = vec2(-dir0.y, dir0.x);
    
    viewPos.xy += tangent * a_texCoord0.y * a_texCoord1.w;
    v_vertexColor = a_color;
    v_uv0 = vec2(a_texCoord0.x, a_texCoord1.w * 0.5 + 0.5);
    
    gl_Position = u_projectionTransform * viewPos;
varying vec2 TexCoord;
uniform sampler2D textureSampler0;
uniform vec2  offsets[MAX_SAMPLE];
uniform float weights[MAX_SAMPLE];
uniform int n_sample;
const float alphaThreshold = 0.9;
void main (void)
    int i;
    vec4 accum = vec4(0.0);
    float total = 0.0;
    for(i=0;i<n_sample;i++){
        vec4 c = texture2D(textureSampler0, TexCoord+offsets[i]);
        c.rgb *= c.a;
        accum += c * weights[i];
        total += weights[i] * c.a;
    }
    accum /= total;
gl_FragColor = accum;
attribute vec3 a_position;
uniform mat4 u_mvp;
uniform float u_zfar;
varying vec3 TexCoord;
void main()
gl_Position = (u_mvp * vec4(a_position * u_zfar, 1.)).xyww;
TexCoord = vec3(a_position.x, a_position.y, -a_position.z);
attribute vec4 a_position;
uniform mat4 u_modelViewProjectionTransform;
void main()
    gl_Position = u_modelViewProjectionTransform * a_position;
uniform sampler2D colorBuffer;
uniform sampler2D outlineColorBuffer;
uniform vec2 u_inverseResolution;
varying vec2 uv;
void main()
    float alpha = 0.;
    for(int i=-1; i<2; i++)
    for(int j=-1; j<2; j++)
    {
        alpha += texture2D(outlineColorBuffer, uv+vec2(i,j)*u_inverseResolution).r;
    }
    alpha /= 9.;
    
    
    gl_FragColor = mix( texture2D(colorBuffer, uv), vec4(1.,.6,.2,1.), vec4(min(alpha*2.,1.)) );
uniform sampler2D colorBuffer;
uniform sampler2D pickedColorBuffer;
uniform sampler2D depthBuffer;
uniform sampler2D pickedDepthBuffer;
uniform vec2 u_inverseResolution;
varying vec2 uv;
void main()
    
    float texels[9];
    texels[0] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, -u_inverseResolution.y)).r;
    texels[1] = texture2D(pickedColorBuffer, uv + vec2(                0., -u_inverseResolution.y)).r;
    texels[2] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, -u_inverseResolution.y)).r;
    
    texels[3] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, 0.)).r;
    
    texels[5] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, 0.)).r;
    
    texels[6] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, u_inverseResolution.y)).r;
    texels[7] = texture2D(pickedColorBuffer, uv + vec2(                0., u_inverseResolution.y)).r;
    texels[8] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, u_inverseResolution.y)).r;
    
    
    
    vec3 a = vec3(texels[0],texels[3],texels[6]);
    vec3 b = vec3(texels[2],texels[5],texels[7]);
    bvec3 tmp = equal(a,b);
    vec3 retLin = mix( vec3(tmp), vec3(not(tmp)), vec3(equal(b,vec3(0.))) );
    
    
    a = vec3(texels[0],texels[1],texels[2]);
    b = vec3(texels[6],texels[7],texels[8]);
    tmp = equal(a,b);
    vec3 retCol = mix( vec3(tmp), vec3(not(tmp)), vec3(equal(b,vec3(0.))) );
    
    
    vec4 last = step(vec4(0.002), vec4(texels[5],texels[7],texels[8], min(retLin.x, retCol.x)) );
    
    
    float x = last.w + 2.*retLin.y + retLin.z - retCol.z - 2.*last.x - last.z;
    float y = last.w + 2.*retCol.y + retCol.z - retLin.z- 2.*last.y - last.z;
    float magnitude = sqrt( x*x + y*y );
    
    
    
    
    float depth = 1.;
    for(int i=-2; i<3; i++)
    for(int j=-2; j<3; j++)
        depth = min(depth, texture2D(pickedDepthBuffer, uv + u_inverseResolution*vec2(i,j)).r);
    
    
    
    vec3 outline = vec3(1.,.6,.2);
    if( texture2D(depthBuffer, uv).x < depth-0.0000001 &&  texture2D(pickedColorBuffer, uv).r > 0.  )
        gl_FragColor = mix( texture2D(colorBuffer, uv), vec4(outline,1.), .25);
    else
        gl_FragColor = mix( texture2D(colorBuffer, uv), vec4(outline,1.), min(magnitude/4.,1.) );
#extension GL_OES_standard_derivatives : enable
precision highp float; 
uniform vec4 u_color;
varying vec3 v_vertexCenter;
#if 0
vec3 smooth(vec3 edge0, vec3 edge1, vec3 x);
vec3 smooth(vec3 edge0, vec3 edge1, vec3 x)
    vec3 t = clamp((x - edge0)/(edge1 - edge0), vec3(0.), vec3(1));
    return t * t * (3. - 2. * t);
#endif
void main()
    vec3 d = fwidth(v_vertexCenter);
    vec3 a3 = smoothstep(vec3(0.0), d * 1.5, v_vertexCenter);
    
    float edge =  min(min(a3.x, a3.y), a3.z);
    if (edge >= 1.0)
        discard;
    gl_FragColor = u_color * (1.0 - edge) * 0.95;
uniform mat4 u_modelViewProjectionTransform;
attribute vec3 a_position;
attribute vec4 a_color;
varying vec4 v_vertexColor;
void main()
    gl_Position = u_modelViewProjectionTransform * vec4(a_position, 1.);
    v_vertexColor = a_color;
void main()
    gl_FragColor = vec4(1.,0.,0.,1.);
uniform sampler2D downSampler;
uniform sampler2D blurSampler;
varying vec2 v_texCoord;
void main (void)
    vec4 down = texture2D( downSampler, v_texCoord);
    vec4 blur = texture2D( blurSampler, v_texCoord);
    float coc = max( down.a, 2. * blur.a - down.a );
gl_FragColor = vec4(down.rgb, coc);
    
    
struct SCNShaderLightingContribution
vec3 ambient;
vec3 diffuse;
vec3 specular;
} _lightingContribution;
uniform sampler2D textureSampler0;
uniform sampler2D textureSampler1;
uniform float factor;
varying vec2 TexCoord;
void main (void)
    vec4 newFragment = texture2D(textureSampler0,TexCoord);
    vec4 oldColor = texture2D(textureSampler1,TexCoord);
    
    gl_FragColor = (factor-1.0)*(oldColor/factor) + newFragment/factor;
attribute vec4 a_position;
uniform mat4 u_modelViewProjectionTransform;
void main(void)
gl_Position = u_modelViewProjectionTransform * a_position;
#ifdef USE_SKINNING
uniform vec4 u_skinningJointMatrices[60];
attribute vec4 a_skinningWeights;
attribute vec4 a_skinningJoints;
#endif
attribute vec4 a_position;
#ifdef USE_NORMAL
attribute vec3 a_normal;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
attribute vec4 a_tangent;
#endif
#ifdef NEED_IN_TEXCOORD0
attribute vec2 a_texCoord0;
#endif
#ifdef NEED_IN_TEXCOORD1
attribute vec2 a_texCoord1;
#endif
#ifdef NEED_IN_TEXCOORD2
attribute vec2 a_texCoord2;
#endif
#ifdef NEED_IN_TEXCOORD3
attribute vec2 a_texCoord3;
#endif
#ifdef NEED_IN_TEXCOORD4
attribute vec2 a_texCoord4;
#endif
#ifdef NEED_IN_TEXCOORD5
attribute vec2 a_texCoord5;
#endif
#ifdef NEED_IN_TEXCOORD6
attribute vec2 a_texCoord6;
#endif
#ifdef NEED_IN_TEXCOORD7
attribute vec2 a_texCoord7;
#endif
#ifdef USE_VERTEX_COLOR
attribute vec4 a_color;
varying vec4 v_vertexColor;
#endif
#ifdef USE_PER_VERTEX_LIGHTING
varying vec3 v_diffuse;
#ifdef USE_SPECULAR
varying vec3 v_specular;
#endif
#endif
#if defined(USE_POSITION) || defined(USE_VIEW)
varying vec3 v_position;
#endif
#ifdef USE_NORMAL
varying vec3 v_normal;
#endif
#ifdef USE_TANGENT
varying vec3 v_tangent;
#endif
#ifdef USE_BITANGENT
varying vec3 v_bitangent;
#endif
#if defined(USE_SPECULAR) && defined(USE_PER_VERTEX_LIGHTING)
uniform float u_materialShininess;
#endif
void main(void)
  _geometry.position = a_position;
  #ifdef USE_NORMAL
  _geometry.normal = a_normal;
  #endif
  #if defined(USE_TANGENT) || defined(USE_BITANGENT)
  _geometry.tangent = a_tangent;
  #endif
  #ifdef NEED_IN_TEXCOORD0
  _geometry.texcoords[0] = a_texCoord0;
  #endif
  #ifdef NEED_IN_TEXCOORD1
  _geometry.texcoords[1] = a_texCoord1;
  #endif
  #ifdef NEED_IN_TEXCOORD2
  _geometry.texcoords[2] = a_texCoord2;
  #endif
  #ifdef NEED_IN_TEXCOORD3
  _geometry.texcoords[3] = a_texCoord3;
  #endif
  #ifdef NEED_IN_TEXCOORD4
  _geometry.texcoords[4] = a_texCoord4;
  #endif
  #ifdef NEED_IN_TEXCOORD5
  _geometry.texcoords[5] = a_texCoord5;
  #endif
  #ifdef NEED_IN_TEXCOORD6
  _geometry.texcoords[6] = a_texCoord6;
  #endif
  #ifdef NEED_IN_TEXCOORD7
  _geometry.texcoords[7] = a_texCoord7;
  #endif
#ifdef USE_VERTEX_COLOR
  _geometry.color = a_color;
#endif
  #ifdef USE_SKINNING
    vec3 pos = vec3(0.);
    #ifdef USE_NORMAL
    vec3 nrm = vec3(0.);
    #endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    vec3 tgt = vec3(0.);
    #endif
    for (int i = 0; i < MAX_BONE_INFLUENCES; ++i) {
#if MAX_BONE_INFLUENCES == 1
        float weight = 1.0;
#else
        float weight = a_skinningWeights[i];
        
#endif
      int idx = int(a_skinningJoints[i]) * 3;
      mat4 jointMatrix = mat4(u_skinningJointMatrices[idx], u_skinningJointMatrices[idx+1], u_skinningJointMatrices[idx+2], vec4(0., 0., 0., 1.));
            pos += (_geometry.position * jointMatrix).xyz * weight;
      #ifdef USE_NORMAL
            nrm += _geometry.normal * mat3(jointMatrix) * weight;
      #endif
      #if defined(USE_TANGENT) || defined(USE_BITANGENT)
            tgt += _geometry.tangent.xyz * mat3(jointMatrix) * weight;
      #endif
    }
    
    _geometry.position.xyz = pos;
    #ifdef USE_NORMAL
    _geometry.normal = nrm;
    #endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _geometry.tangent.xyz = tgt;
    #endif
  #endif
  #ifdef USE_GEOMETRY_MODIFIER
__DoGeometryModifier__
  #endif
  #ifdef USE_POSITION
  _surface.position = (u_modelViewTransform * _geometry.position).xyz;
  #endif
  #ifdef USE_NORMAL
  _surface.normal = normalize(mat3(u_normalTransform) * _geometry.normal);
  #endif
  #if defined(USE_TANGENT) || defined(USE_BITANGENT)
  _surface.tangent = normalize(mat3(u_normalTransform) * _geometry.tangent.xyz);
  _surface.bitangent =  cross(_surface.tangent, _surface.normal); 
    
  #endif
  #ifdef USE_VIEW
    _surface.view = normalize(-_surface.position);
  #endif
  #ifdef USE_PER_VERTEX_LIGHTING
  _lightingContribution.diffuse = vec3(0.);
  #ifdef USE_SPECULAR
  _lightingContribution.specular = vec3(0.);
  _surface.shininess = u_materialShininess;
  #endif
__DoLighting__
  v_diffuse = _lightingContribution.diffuse;
  #ifdef USE_SPECULAR
  v_specular = _lightingContribution.specular;
  #endif
  #endif
  #if defined(USE_POSITION) && (USE_POSITION == 2)
  v_position = _surface.position;
  #endif
  #if defined(USE_NORMAL) && (USE_NORMAL == 2)
  v_normal = _surface.normal;
  #endif
  #if defined(USE_TANGENT) && (USE_TANGENT == 2)
  v_tangent = _surface.tangent;
  #endif
  #if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
  v_bitangent = _surface.bitangent;
  #endif
  #ifdef USE_VERTEX_COLOR
  v_vertexColor = _geometry.color;
  #endif
#ifdef USE_TEXCOORD
__DoTexcoord__
#endif
    
  #if defined(SEPARATE_PROJECTION) && SEPARATE_PROJECTION
  gl_Position = u_projectionTransform * vec4(_surface.position, 1.);
  #else
  gl_Position = u_modelViewProjectionTransform * _geometry.position;
  #endif
#ifdef __METAL_VERSION__ 
#define DECLARE_BOOL(a) constant bool a [[ function_constant( __COUNTER__ ) ]];
#define DECLARE_INT(a) constant int a [[ function_constant( 1000 + __COUNTER__ ) ]];
#define DECLARE_UINT(a) constant uint a [[ function_constant( 2000 + __COUNTER__ ) ]];
#define DECLARE_OPT_INT(a) constant int a [[ function_constant( 3000 + __COUNTER__ ) ]];
#define DECLARE_OPT_UINT(a) constant uint a [[ function_constant( 4000 + __COUNTER__ ) ]];
#else
#if !defined(DECLARE_BOOL) || !defined(DECLARE_INT) || !defined(DECLARE_UINT) || !defined(DECLARE_OPT_INT) || !defined(DECLARE_OPT_UINT)
#error Need to declare DECLARE_BOOL and DECLARE_INT macros
#endif
#endif
#define kSCNTexcoordCount 8
DECLARE_BOOL(need_vertex_color)
DECLARE_BOOL(need_position)
DECLARE_BOOL(need_normal)
DECLARE_BOOL(need_tangent)
DECLARE_BOOL(need_texcoord0)
DECLARE_BOOL(need_texcoord1)
DECLARE_BOOL(need_texcoord2)
DECLARE_BOOL(need_texcoord3)
DECLARE_BOOL(need_texcoord4)
DECLARE_BOOL(need_texcoord5)
DECLARE_BOOL(need_texcoord6)
DECLARE_BOOL(need_texcoord7)
DECLARE_BOOL(use_io_vertex_color)
DECLARE_BOOL(use_io_position)
DECLARE_BOOL(use_io_normal)
DECLARE_BOOL(use_io_view)
DECLARE_BOOL(use_ambient)
DECLARE_BOOL(use_diffuse)
DECLARE_BOOL(use_specular)
DECLARE_BOOL(use_emission)
DECLARE_BOOL(use_multiply)
DECLARE_BOOL(use_reflective)
DECLARE_BOOL(use_transparent)
DECLARE_BOOL(use_diffuse_map)
DECLARE_BOOL(use_normal_map)
DECLARE_BOOL(use_transparent_map)
DECLARE_BOOL(use_emission_map)
DECLARE_BOOL(use_ambient_map)
DECLARE_BOOL(use_multiply_map)
DECLARE_BOOL(use_specular_map)
DECLARE_BOOL(use_reflective_map)
DECLARE_BOOL(use_reflectivecube_map)
DECLARE_BOOL(use_roughness_map)
DECLARE_BOOL(use_metalness_map)
DECLARE_OPT_INT(diffuse_texture_component)
DECLARE_OPT_INT(normal_texture_component)
DECLARE_OPT_INT(transparent_texture_component)
DECLARE_OPT_INT(emission_texture_component)
DECLARE_OPT_INT(ambient_texture_component)
DECLARE_OPT_INT(multiply_texture_component)
DECLARE_OPT_INT(specular_texture_component)
DECLARE_OPT_INT(reflective_texture_component)
DECLARE_OPT_INT(roughness_texture_component)
DECLARE_OPT_INT(metalness_texture_component)
DECLARE_BOOL(use_diffuse_intensity)
DECLARE_BOOL(use_normal_intensity)
DECLARE_BOOL(use_transparent_intensity)
DECLARE_BOOL(use_emission_intensity)
DECLARE_BOOL(use_ambient_intensity)
DECLARE_BOOL(use_multiply_intensity)
DECLARE_BOOL(use_specular_intensity)
DECLARE_BOOL(use_reflective_intensity)
DECLARE_BOOL(use_roughness_intensity)
DECLARE_BOOL(use_metalness_intensity)
DECLARE_BOOL(use_fresnel)
DECLARE_BOOL(use_transparency)
DECLARE_BOOL(use_transparency_rgbzero)
DECLARE_INT(diffuse_channel)
DECLARE_INT(normal_channel)
DECLARE_INT(transparent_channel)
DECLARE_INT(emission_channel)
DECLARE_INT(ambient_channel)
DECLARE_INT(multiply_channel)
DECLARE_INT(specular_channel)
DECLARE_INT(roughness_channel)
DECLARE_INT(metalness_channel)
DECLARE_OPT_INT(diffuse_texcoord_io_index)
DECLARE_OPT_INT(normal_texcoord_io_index)
DECLARE_OPT_INT(transparent_texcoord_io_index)
DECLARE_OPT_INT(emission_texcoord_io_index)
DECLARE_OPT_INT(ambient_texcoord_io_index)
DECLARE_OPT_INT(multiply_texcoord_io_index)
DECLARE_OPT_INT(specular_texcoord_io_index)
DECLARE_OPT_INT(roughness_texcoord_io_index)
DECLARE_OPT_INT(metalness_texcoord_io_index)
DECLARE_OPT_INT(diffuse_transform_index)
DECLARE_OPT_INT(normal_transform_index)
DECLARE_OPT_INT(transparent_transform_index)
DECLARE_OPT_INT(emission_transform_index)
DECLARE_OPT_INT(ambient_transform_index)
DECLARE_OPT_INT(multiply_transform_index)
DECLARE_OPT_INT(specular_transform_index)
DECLARE_OPT_INT(roughness_transform_index)
DECLARE_OPT_INT(metalness_transform_index)
DECLARE_BOOL(use_emission_as_selfIllumination)
DECLARE_BOOL(use_ambient_as_ambientOcclusion)
DECLARE_BOOL(use_texture_transforms)
DECLARE_BOOL(use_point_rendering)
DECLARE_BOOL(diffuse_premultiplied)
DECLARE_BOOL(use_discard)
DECLARE_BOOL(use_instancing)
DECLARE_INT(lighting_model)
DECLARE_BOOL(use_lighting) 
DECLARE_BOOL(use_ambient_lighting)
DECLARE_BOOL(use_modulate_lighting)
DECLARE_BOOL(use_per_vertex_lighting)
DECLARE_BOOL(avoid_overlighting) 
DECLARE_BOOL(use_double_sided)
DECLARE_BOOL(use_probes_lighting)
DECLARE_OPT_UINT(use_light0);
DECLARE_OPT_UINT(use_light1);
DECLARE_OPT_UINT(use_light2);
DECLARE_OPT_UINT(use_light3);
DECLARE_BOOL(use_node_opacity)
DECLARE_BOOL(use_fog)
DECLARE_BOOL(use_ssao)
DECLARE_INT(io_texcoord_count)
#undef DECLARE_BOOL
#undef DECLARE_INT
#undef DECLARE_UINT
#undef DECLARE_OPT_INT
#undef DECLARE_OPT_UINT
#define LIGHT_TYPE(a)           ((a      ) & 0x7)
#define LIGHT_DIST_ATT(a)       ((a >> 3) & 0x7)
#define LIGHT_SPOT_ATT(a)       ((a >> 6) & 0x7)
#define LIGHT_HAS_GOBO(a)       (a & (1 << 9))
#define LIGHT_HAS_SHADOW(a)     (a & (1 << 10))
#define LIGHT_IS_MODULATE(a)    (a & (1 << 12))
#define LIGHT_IES_TYPE(a)       ((a >> 13) & 0x3)
#define LIGHT_SHADOW_SAMPLE(a)  ((a >> 15) & 0x1f)
#if defined(__METAL_VERSION__) 
enum C3DLightAttenuationType
    kC3DLightAttenuationTypeNone,
    kC3DLightAttenuationTypeConstant,
    kC3DLightAttenuationTypeLinear,
    kC3DLightAttenuationTypeQuadratic,
    kC3DLightAttenuationTypeExponent,
    kC3DLightAttenuationTypePhysicallyBased,
enum C3DLightType
    kC3DLightTypeAmbient,
    kC3DLightTypeDirectional,
    kC3DLightTypeOmni,
    kC3DLightTypeSpot,
    kC3DLightTypeProbe,
    kC3DLightTypeIES,
    kC3DLightTypeArea
enum C3DLightIESType
    kC3DLightIESType1D,
    kC3DLightIESType2D,
    kC3DLightIESTypeCubemap,
    kC3DLightIESTypeNone
#endif
struct SCNLightData {
    float4 color; 
    float4 pbrColor; 
    
    
    float3 position;  
    float3 direction; 
    float3 up; 
    float3 right; 
    
    float3 distanceAttenuation; 
    float3 spotAttenuation; 
    float shadowRadius; 
    float4x4 shadowMatrix; 
struct scn_floor_t {
    float3 u_floorNormal;
    float4 u_floorTangent;
    float3 u_floorCenter;
    float2 u_floorExtent;
#pragma arguments
    scn_floor_t scn_fg
#pragma body
    float3 u_floorNormal = scn_fg.u_floorNormal;
    float4 u_floorTangent = scn_fg.u_floorTangent;
    float3 u_floorCenter = scn_fg.u_floorCenter;
    float2 u_floorExtent = scn_fg.u_floorExtent;
    float3 floorBitangent =  normalize(cross(u_floorTangent.xyz, u_floorNormal));
    _geometry.position.xyz = u_floorCenter.xyz + u_floorExtent.x * (_geometry.position.x * u_floorTangent.xyz) + u_floorExtent.y * (_geometry.position.y * floorBitangent);
    _geometry.normal = u_floorNormal;
    _geometry.tangent = u_floorTangent;
    
    float2 tc;
    if (u_floorNormal.y != 0.)
        tc = _geometry.position.xz * 0.01;
    else if (u_floorNormal.z != 0.)
        tc = _geometry.position.xy * 0.01;
    else
        tc = _geometry.position.yz * 0.01;
    for (int i = 0; i < kSCNTexcoordCount; ++i)
        _geometry.texcoords[i] = tc;
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
struct SCNTessellatorTransforms {
    float4x4 modelViewTransform;
    float4x4 modelViewProjectionTransform;
    float4x4 projectionTransform;
#if OSD_IS_ADAPTIVE
kernel void compute_opensubdiv(
                               constant SCNTessellatorTransforms&     transforms                     [[ buffer(TRANSFORMS_BUFFER_INDEX) ]],
                               constant float&                        tessellationLevel              [[ buffer(TESSELLATION_LEVEL_BUFFER_INDEX) ]],
                               unsigned                               thread_position_in_grid        [[ thread_position_in_grid ]],
                               unsigned                               thread_position_in_threadgroup [[ thread_position_in_threadgroup ]],
                               unsigned                               threadgroup_position_in_grid   [[ threadgroup_position_in_grid ]],
                               OsdPatchParamBufferSet                 osdBuffers, 
                               device MTLQuadTessellationFactorsHalf* quadTessellationFactors        [[ buffer(QUAD_TESSFACTORS_INDEX) ]]
#if OSD_USE_PATCH_INDEX_BUFFER
                               ,device unsigned* patchIndex                                          [[ buffer(OSD_PATCH_INDEX_BUFFER_INDEX) ]]
                               ,device MTLDrawPatchIndirectArguments* drawIndirectCommands           [[ buffer(OSD_DRAWINDIRECT_BUFFER_INDEX) ]]
#endif
                         )
    
    
    
    
    
    
    
    threadgroup int3 patchParam[PATCHES_PER_THREADGROUP];
    
    threadgroup PatchVertexType patchVertices[PATCHES_PER_THREADGROUP * CONTROL_POINTS_PER_PATCH];
    
    const auto real_threadgroup = thread_position_in_grid / REAL_THREADGROUP_DIVISOR;
    const auto subthreadgroup_in_threadgroup = thread_position_in_threadgroup / REAL_THREADGROUP_DIVISOR;
    const auto real_thread_in_threadgroup = thread_position_in_threadgroup & (REAL_THREADGROUP_DIVISOR - 1);
    
#if NEEDS_BARRIER
    const auto validThread = thread_position_in_grid * CONTROL_POINTS_PER_THREAD < osdBuffers.kernelExecutionLimit;
#else
    const auto validThread = true;
    if(thread_position_in_grid * CONTROL_POINTS_PER_THREAD >= osdBuffers.kernelExecutionLimit)
        return;
#endif
    
    
    
    
    if(validThread)
    {
        patchParam[subthreadgroup_in_threadgroup] = OsdGetPatchParam(real_threadgroup, osdBuffers.patchParamBuffer);
        
        for(unsigned threadOffset = 0; threadOffset < CONTROL_POINTS_PER_THREAD; threadOffset++)
        {
            const auto vertexId = osdBuffers.indexBuffer[(thread_position_in_grid * CONTROL_POINTS_PER_THREAD + threadOffset) * IndexLookupStride];
            const auto v = osdBuffers.vertexBuffer[vertexId];
            
            threadgroup auto& patchVertex = patchVertices[thread_position_in_threadgroup * CONTROL_POINTS_PER_THREAD + threadOffset];
            
            
            
            
            
            OsdComputePerVertex(float4(v.position,1), patchVertex, vertexId, transforms.modelViewProjectionTransform, osdBuffers);
        }
    }
    
#if NEEDS_BARRIER
    threadgroup_barrier(mem_flags::mem_threadgroup);
#endif
    
    
    
    
    
    if(validThread)
    {
#if PATCHES_PER_THREADGROUP > 1
        auto patch = patchVertices + subthreadgroup_in_threadgroup * CONTROL_POINTS_PER_THREAD * CONTROL_POINTS_PER_PATCH;
#else
        
        auto patch = patchVertices;
#endif
        
        if(!OsdCullPerPatchVertex(patch, transforms.modelViewTransform))
        {
#if !OSD_USE_PATCH_INDEX_BUFFER
            quadTessellationFactors[real_threadgroup].edgeTessellationFactor[0] = 0.0h;
            quadTessellationFactors[real_threadgroup].edgeTessellationFactor[1] = 0.0h;
            quadTessellationFactors[real_threadgroup].edgeTessellationFactor[2] = 0.0h;
            quadTessellationFactors[real_threadgroup].edgeTessellationFactor[3] = 0.0h;
            quadTessellationFactors[real_threadgroup].insideTessellationFactor[0] = 0.0h;
            quadTessellationFactors[real_threadgroup].insideTessellationFactor[1] = 0.0h;
#endif
            
            patchParam[subthreadgroup_in_threadgroup].z = -1;
#if !NEEDS_BARRIER
            return;
#endif
        }
    }
    
#if NEEDS_BARRIER
    threadgroup_barrier(mem_flags::mem_threadgroup);
#endif
    
    
    
    
    if(validThread && patchParam[subthreadgroup_in_threadgroup].z != -1)
    {
        for(unsigned threadOffset = 0; threadOffset < CONTROL_POINTS_PER_THREAD; threadOffset++)
        {
            OsdComputePerPatchVertex(
                                     patchParam[subthreadgroup_in_threadgroup],
                                     real_thread_in_threadgroup * CONTROL_POINTS_PER_THREAD + threadOffset,
                                     real_threadgroup,
                                     thread_position_in_grid * CONTROL_POINTS_PER_THREAD + threadOffset,
                                     patchVertices + subthreadgroup_in_threadgroup * CONTROL_POINTS_PER_PATCH,
                                     osdBuffers
                                     );
        }
    }
    
#if NEEDS_BARRIER
    threadgroup_barrier(mem_flags::mem_device_and_threadgroup);
#endif
    
    
    
    
    if(validThread && real_thread_in_threadgroup == 0)
    {
        
#if OSD_USE_PATCH_INDEX_BUFFER
        const auto patchId = atomic_fetch_add_explicit((device atomic_uint*)&drawIndirectCommands->patchCount, 1, memory_order_relaxed);
        patchIndex[patchId] = real_threadgroup;
#else
        const auto patchId = real_threadgroup;
#endif
        
        OsdComputePerPatchFactors(
                                  patchParam[subthreadgroup_in_threadgroup],
                                  tessellationLevel,
                                  real_threadgroup,
                                  transforms.projectionTransform,
                                  transforms.modelViewTransform,
                                  osdBuffers,
                                  patchVertices + subthreadgroup_in_threadgroup * CONTROL_POINTS_PER_PATCH,
                                  quadTessellationFactors[patchId]
                                  );
    }
#endif 
#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE)
static inline void scn_smooth_geometry_pn_triangle(thread float3 &position, thread float3 &normal, float3 patchCoord, float3 P0, float3 P1, float3 P2, float3 N0, float3 N1, float3 N2)
    float u = patchCoord.y;
    float v = patchCoord.z;
    float w = patchCoord.x;
    
    float3 P0P1 = P1 - P0;
    float3 P1P2 = P2 - P1;
    float3 P2P0 = P0 - P2;
    
    float w12 = dot(P0P1, N0);
    float w23 = dot(P1P2, N1);
    float w31 = dot(P2P0, N2);
    
    float w21 = dot(-P0P1, N1);
    float w32 = dot(-P1P2, N2);
    float w13 = dot(-P2P0, N0);
    
    float inv3 = 1.f / 3.f;
    
    float3 b210 = (2.f * P0 + P1 - w12 * N0) * inv3;
    float3 b021 = (2.f * P1 + P2 - w23 * N1) * inv3;
    float3 b201 = (2.f * P0 + P2 - w13 * N0) * inv3;
    
    float3 b120 = (2.f * P1 + P0 - w21 * N1) * inv3;
    float3 b012 = (2.f * P2 + P1 - w32 * N2) * inv3;
    float3 b102 = (2.f * P2 + P0 - w31 * N2) * inv3;
    
    float3 E = (b210 + b120 + b021 + b012 + b201 + b102) / 6.f;
    float3 V = (P0 + P1 + P2) * inv3;
    float3 b111 = E + (E - V) / 2.f;
    
    position.xyz =
    P0 * (w * w * w) +
    P1 * (u * u * u) +
    P2 * (v * v * v) +
    b210 * (3.f * w * w * u) +
    b120 * (3.f * w * u * u) +
    b201 * (3.f * w * w * v) +
    b021 * (3.f * u * u * v) +
    b102 * (3.f * w * v * v) +
    b012 * (3.f * u * v * v) +
    b111 * (6.f * w * u * v);
    
    float3 v12 = 2.f * dot(P0P1, N0 + N1) / dot(P0P1, P0P1);
    float3 v23 = 2.f * dot(P1P2, N1 + N2) / dot(P1P2, P1P2);
    float3 v31 = 2.f * dot(P2P0, N2 + N0) / dot(P2P0, P2P0);
    
    float3 h110 = N0 + N1 - v12 * P0P1;
    float3 h011 = N1 + N2 - v23 * P1P2;
    float3 h101 = N2 + N0 - v31 * P2P0;
    
    float3 n010 = normalize(h110);
    float3 n011 = normalize(h011);
    float3 n001 = normalize(h101);
    
    normal = normalize(
    N0 * w * w +
    N1 * u * u +
    N2 * v * v +
    n010 * w * u +
    n011 * u * v +
    n001 * w * v);
#elif defined(TESSELLATION_SMOOTHING_MODE_PHONG)
static inline void scn_smooth_geometry_phong(thread float3 &position, thread float3 &normal, float3 patchCoord, float3 P0, float3 P1, float3 P2, float3 N0, float3 N1, float3 N2)
    float3 P = scn::barycentric_mix(P0, P1, P2, patchCoord);
    
    float3 proj0 = P - dot(P - P0, N0) * N0;
    float3 proj1 = P - dot(P - P1, N1) * N1;
    float3 proj2 = P - dot(P - P2, N2) * N2;
    
    float3 Pproj = scn::barycentric_mix(proj0, proj1, proj2, patchCoord);
    
    const float alpha = 0.75f;
    position = mix(P, Pproj, alpha);
    normal = normalize(scn::barycentric_mix(N0, N1, N2, patchCoord));
#endif 
#if __METAL_VERSION__ >= 220 
    #include <TargetConditionals.h>
    #if TARGET_OS_OSX || TARGET_OS_MACCATALYST
        
        
        #define SHOULD_CHECK_IF_OUTSIDE_TEXTURE  0
        #define RETURN_IF_OUTSIDE_TEXTURE(dst)
        #define RETURN_IF_OUTSIDE_TEXTURE3D(dst)
    #else
        #define SHOULD_CHECK_IF_OUTSIDE_TEXTURE  1
        #define RETURN_IF_OUTSIDE_TEXTURE(dst)   if ((index.x >= dst.get_width()) || (index.y >= dst.get_height())) return;
        #define RETURN_IF_OUTSIDE_TEXTURE3D(dst) if ((index.x >= dst.get_width()) || (index.y >= dst.get_height()) || (index.z >= dst.get_depth())) return;
    #endif
    #define SUPPORTS_LAYERED_RENDERING           1
    #define SUPPORTS_MULTIPLE_VIEWPORT_RENDERING 1
#else
    #if defined(__METAL_MACOS__)
        
        
        #define SHOULD_CHECK_IF_OUTSIDE_TEXTURE      0
        #define RETURN_IF_OUTSIDE_TEXTURE(dst)
        #define RETURN_IF_OUTSIDE_TEXTURE3D(dst)
        #define SUPPORTS_LAYERED_RENDERING           (__METAL_VERSION__ >= 200)
        #define SUPPORTS_MULTIPLE_VIEWPORT_RENDERING (__METAL_VERSION__ >= 200)
    #elif defined(__METAL_IOS__)
        #define SHOULD_CHECK_IF_OUTSIDE_TEXTURE      1
        #define RETURN_IF_OUTSIDE_TEXTURE(dst)       if ((index.x >= dst.get_width()) || (index.y >= dst.get_height())) return;
        #define RETURN_IF_OUTSIDE_TEXTURE3D(dst)     if ((index.x >= dst.get_width()) || (index.y >= dst.get_height()) || (index.z >= dst.get_depth())) return;
        #define SUPPORTS_LAYERED_RENDERING           (__METAL_VERSION__ >= 210)
        #define SUPPORTS_MULTIPLE_VIEWPORT_RENDERING (__METAL_VERSION__ >= 210)
    #endif
#endif
namespace scn {
    
    
    static inline float4 reduce_op(float4 d0, float4 d1)
    {
        d0.x = min(d0.x, d1.x);
        d0.y = max(d0.y, d1.y);
        d0.z += d1.z;
        d0.w += d1.w;
        return d0;
    }
    
    inline float vector_reduce_min(float4 v)
    {
        float2 min_lh = min(v.xy, v.zw);
        return min(min_lh.x, min_lh.y);
    }
    
    inline float vector_reduce_max(float4 v)
    {
        float2 max_lh = max(v.xy, v.zw);
        return max(max_lh.x, max_lh.y);
    }
    
    inline int vector_reduce_add(int4 v)
    {
        int2 add_lh = v.xy + v.zw;
        return add_lh.x + add_lh.y;
    }
    
    inline float3x3 mat3(float4x4 mat4)
    {
        return float3x3(mat4[0].xyz, mat4[1].xyz, mat4[2].xyz);
    }
    
    inline float3 mat4_mult_float3_normalized(float4x4 matrix, float3 src)
    {
        float3 dst  =  src.xxx * matrix[0].xyz;
        dst         += src.yyy * matrix[1].xyz;
        dst         += src.zzz * matrix[2].xyz;
        return normalize(dst);
    }
    
    inline float3 mat4_mult_float3(float4x4 matrix, float3 src)
    {
        float3 dst  =  src.xxx * matrix[0].xyz;
        dst         += src.yyy * matrix[1].xyz;
        dst         += src.zzz * matrix[2].xyz;
        return dst;
    }
    inline float3 matrix_rotate(float4x4 mat, float3 dir)
    {
        return  dir.xxx * mat[0].xyz +
                dir.yyy * mat[1].xyz +
                dir.zzz * mat[2].xyz;
    }
    inline float4 matrix_transform(float4x4 mat, float3 pos)
    {
        return  pos.xxxx * mat[0] +
                pos.yyyy * mat[1] +
                pos.zzzz * mat[2] +
                           mat[3];
    }
    inline float3 quaternion_rotate_vector(float4 q, float3 v)
    {
        float3 t = 2.f * cross(q.xyz, v);
        return v + q.w * t + cross(q.xyz, t);
    }
    
    template <class T>
    inline vec<T, 3> robust_normalize(vec<T, 3> v)
    {
        vec<T, 3> zero = 0.;
        return all(v == zero) ? zero : normalize(v);
    }
    template <class T>
    inline void generate_basis(vec<T, 3> inR, thread vec<T, 3> *outS, thread vec<T, 3> *outT)
    {
        
        T x  = -inR.x;
        T y  = inR.y;
        T z  = inR.z;
        T sz = copysign(T(1.), z);
        T a  = y / (abs(z) + T(1.));
        T b  = y * a;
        T c  = x * a;
        *outS = (vec<T, 3>){ z + sz * b,  sz * c,       x       };
        *outT = (vec<T, 3>){ c,           T(1.) - b,    -sz * y };
    }
    
    
    
    inline float3 blend_add(float3 base, float3 blend)
    {
        return min(base + blend, 1.0);
    }
    
    inline float3 blend_lighten(float3 base, float3 blend)
    {
        return max(blend, base);
    }
    
    inline float3 blend_screen(float3 base, float3 blend)
    {
        return (1.0 - ((1.0 - base) * (1.0 - blend)));
    }
    
    
    inline half sq(half f) {
        return f * f;
    }
    inline float sq(float f) {
        return f * f;
    }
    
    inline float2 sincos(float angle) {
        float cs;
        float sn = ::sincos(angle, cs);
        return float2(sn, cs);
    }
    
    
    inline float acos_fast(float f) {
        float x = abs(f);
        float res = -0.156583f * x + M_PI_2_F;
        res *= sqrt(1.0f - x);
        return (f >= 0.f) ? res : M_PI_F - res;
    }
    inline float asin_fast(float f)
    {
        return M_PI_2_F - acos_fast(f);
    }
    
    inline float atan_fast(float inX)
    {
        float  x = inX;
        return x*(-0.1784f * abs(x) - 0.0663f * x * x + 1.0301f);
    }
    
    inline float atan2_fast(float y, float x)
    {
        float sx = x > 0.f ? -1.f : 1.f;
        float abs_y = abs(y) + 1e-10f; 
        float r = (x + abs_y*sx) / (abs_y - x*sx);
        float angle = sx * M_PI_4_F + M_PI_2_F;
        angle      += (0.1963f * r * r - 0.9817f) * r;
        return y > 0.f ? angle : -angle;
    }
    
    
    template <class T>
    inline vec<T, 3> cartesian_from_spherical(vec<T, 2> uv)
    {
        
        
        T cos_phi;
        T phi = uv.x * 2.0f * M_PI_F;
        T sin_phi = ::sincos(phi, cos_phi);
        
        T cos_theta;
        T theta     = uv.y * M_PI_F;
        T sin_theta = ::sincos(theta, cos_theta);
        return vec<T, 3>(cos_phi * sin_theta,
                         cos_theta,
                         -sin_phi * sin_theta);
    }
    inline float2 spherical_from_cartesian(float3 dir)
    {
        return float2( atan2(-dir.z, dir.x) * (0.5f * M_1_PI_F), acos(dir.y) * M_1_PI_F);
    }
    inline half2 spherical_from_cartesian(half3 dir)
    {
        return half2(atan2(-dir.z, dir.x) * 0.5h, acos(dir.y)) * M_1_PI_H;
    }
    inline float2 spherical_from_cartesian_fast(float3 dir)
    {
        return float2( atan2_fast(-dir.z, dir.x) * (0.5f * M_1_PI_F), acos_fast(dir.y) * M_1_PI_F);
    }
    inline half2 spherical_from_cartesian_fast(half3 dir)
    {
        return half2( atan2_fast(-dir.z, dir.x) * 0.5h, acos_fast(dir.y)) * M_1_PI_H;
    }
    #define dual_contract_factor  1.0
    template <class T>
    inline vec<T, 2> dual_paraboloid_from_cartesian(vec<T, 3> dir)
    {
        dir.xy /= abs(dir.z) + 1.0;
        dir.y = 0.5 - dir.y * 0.5;
        T s   = sign(dir.z) * 0.25;
        dir.x = s * (dir.x - 1.0) + 0.5;
        return dir.xy;
    }
    
    
    template <class T>
    inline vec<T, 3> cartesian_from_dual_paraboloid(vec<T, 2>  uv)
    {
        
        T zside = 0.5 * sign(0.5 - uv.x);
        uv.x = 1.0 - abs(4.0 * uv.x - 2.0); 
        uv.y   = 1.0 - uv.y * 2.0;
        T z = length_squared(uv); 
        z = (1.0 - z) * zside;
        
        return vec<T, 3>(uv.x, uv.y, z);
    }
    inline float reduce_min(float3 v) {
        return min(v.x, min(v.y, v.z));
    }
    
    inline float reduce_min(float4 v) {
        return min(min(v.x, v.y), min(v.z, v.w));
    }
    inline float reduce_max(float3 v) {
        return max(v.x, max(v.y, v.z));
    }
    inline float reduce_max(float4 v) {
        return max(max(v.x, v.y), max(v.z, v.w));
    }
    
    inline float3 randomSphereDir(float2 rnd)
    {
        float s = rnd.x * M_PI_F * 2.f;
        float t = rnd.y * 2.f - 1.f;
        return float3(sin(s), cos(s), t) / sqrt(1.f + t * t);
    }
    
    
    template <class T>
    inline T interleaved_gradient_noise(vec<T, 2> pos)
    {
        vec<T, 3> magic( 0.06711056f, 0.00583715f, 52.9829189f );
        return fract( magic.z * fract( dot( pos, magic.xy ) ) );
    }
    
    inline float3 hemisphere_reflect(float3 v, float3 nrm)
    {
        return v * sign(dot(v, nrm));
    }
    
    inline float3 randomHemisphereDir(float3 dir, float2 rnd)
    {
        return hemisphere_reflect(randomSphereDir( rnd ), dir);
    }
    
    inline void orthogonal_basis(float3 n, thread float3& xp, thread float3& yp)
    {
        
        float sz = n.z >= 0.f ? 1.f : -1.f;
        float a  =  n.y / (1.f + abs(n.z));
        float b  =  n.y * a;
        float c  = -n.x * a;
        
        xp = float3(n.z + sz * b,   sz * c,     -n.x);
        yp = float3(c,              1.f - b,    -sz * n.y);
    }
    template <class U>
    inline float2 normalized_coordinate(ushort2 index, U texture)
    {
        uint width  = texture.get_width();
        uint height = texture.get_height();
        
        float u = width  == 1 ? 0.5f : float(index.x) / float(width - 1);
        float v = height == 1 ? 0.5f : float(index.y) / float(height - 1);
        
        return float2(u, v);
    }
    template <class U>
    inline float2 normalized_coordinate(uint2 index, U texture)
    {
        uint width  = texture.get_width();
        uint height = texture.get_height();
        
        float u = width  == 1 ? 0.5f : float(index.x) / float(width - 1);
        float v = height == 1 ? 0.5f : float(index.y) / float(height - 1);
        
        return float2(u, v);
    }
    template <class U>
    inline half2 normalized_coordinate_half(uint2 index, U texture)
    {
        uint width  = texture.get_width();
        uint height = texture.get_height();
        
        half u = width  == 1 ? 0.5h : half(index.x) / half(width - 1);
        half v = height == 1 ? 0.5h : half(index.y) / half(height - 1);
        
        return half2(u, v);
    }
    
    template <class T>
    inline vec<T, 3> cubemap_dir_from_sampleCoord(uint face, vec<T, 2> sampleCoord) 
    {
        switch(face) {
            case 0: 
                return vec<T, 3>( 1.0, -sampleCoord.y, -sampleCoord.x);
            case 1: 
                return vec<T, 3>(-1.0, -sampleCoord.y,  sampleCoord.x);
            case 2: 
                return vec<T, 3>(sampleCoord.x,  1.0,  sampleCoord.y);
            case 3: 
                return vec<T, 3>(sampleCoord.x, -1.0, -sampleCoord.y);
            case 4: 
                return vec<T, 3>( sampleCoord.x, -sampleCoord.y,  1.0);
            default: 
                return vec<T, 3>(-sampleCoord.x, -sampleCoord.y, -1.0);
        }
    }
    
    template <class T>
    inline T signed_unit(T uv) {
        return uv * 2.0 - 1.0;
    }
    
    template <class T>
    inline T unsigned_unit(T uv) {
        return uv * 0.5 + 0.5;
    }
    template <class T>
    inline vec<T, 3> cubemap_dir_from_uv(uint face, vec<T, 2> uv) 
    {
        return cubemap_dir_from_sampleCoord(face, signed_unit(uv));
    }
    template <class T>
    inline vec<T, 3> cubemap_dir_from_uv_unit(uint face, vec<T, 2> uv) 
    {
        return normalize(cubemap_dir_from_uv(face, uv));
    }
    
    
    inline float2 barycentric_mix(float2 __x, float2 __y, float2 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }
    inline float3 barycentric_mix(float3 __x, float3 __y, float3 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }
    inline float4 barycentric_mix(float4 __x, float4 __y, float4 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }
    
    static inline float rect(float2 lt, float2 rb, float2 uv)
    {
        float2 borders = step(lt, uv) * step(uv, rb);
        return borders.x * borders.y;
    }
    
    inline half4 debugColorForCascade(int cascade)
    {
        switch (cascade) {
            case 0:
            return half4(1.h, 0.h, 0.h, 1.h);
            case 1:
            return half4(0.9, 0.5, 0., 1.);
            case 2:
            return half4(1., 1., 0., 1.);
            case 3:
            return half4(0., 1., 0., 1.);
            default:
            return half4(0., 0., 0., 1.);
        }
    }
    inline half3 debugColorForFace(int count)
    {
        switch (count) {
            case 0:  return half3(1.0h, 0.1h, 0.1h);
            case 1:  return half3(0.1h, 1.0h, 1.0h);
            case 2:  return half3(0.1h, 1.0h, 0.1h);
            case 3:  return half3(1.0h, 0.1h, 1.0h);
            case 4:  return half3(0.1h, 0.1h, 1.0h);
            default: return half3(1.0h, 1.0h, 0.1h);
        }
    }
    inline half4 debugColorForCount(int count)
    {
        switch (count) {
            case 0: return half4(0.0h, 0.0h, 0.0h, 1.h);
            case 1: return half4(0.0h, 0.0h, 0.4h, 1.h);
            case 2: return half4(0.0h, 0.0h, 0.9h, 1.h);
            case 3: return half4(0.0h, 0.4h, 0.7h, 1.h);
            case 4: return half4(0.0h, 0.9h, 0.4h, 1.h);
            case 5: return half4(0.0h, 0.9h, 0.0h, 1.h);
            case 6: return half4(0.4h, 0.7h, 0.0h, 1.h);
            case 7: return half4(0.9h, 0.7h, 0.0h, 1.h);
            default: return half4(1., 0., 0., 1.);
        }
    }
    inline float grid(float2 lt, float2 rb, float2 gridSize, float thickness, float2 uv)
    {
        float insideRect = rect(lt, rb + thickness, uv);
        float2 gt = thickness * gridSize;
        float2 lines = step(abs(lt - fract(uv * gridSize)), gt);
        return insideRect * (lines.x + lines.y);
    }
    inline float checkerboard(float2 gridSize, float2 uv)
    {
        float2 check = floor(uv * gridSize);
        return step(fmod(check.x + check.y, 2.f), 0.f);
    }
    
    
    inline float luminance(float3 color)
    {
        
        
        return color.r * 0.212671 + color.g * 0.715160 + color.b * 0.072169;
    }
    
    inline float srgb_to_linear(float c)
    {
        return (c <= 0.04045f) ? c / 12.92f : powr((c + 0.055f) / 1.055f, 2.4f);
    }
    
    inline half srgb_to_linear_fast(half c)
    {
        return powr(c, 2.2h);
    }
    
    inline half3 srgb_to_linear_fast(half3 c)
    {
        return powr(c, 2.2h);
    }
    
    inline half srgb_to_linear(half c)
    {
        
        return (c <= 0.04045h) ? (c * 0.0773993808h) :  powr(0.9478672986h * c + 0.05213270142h, 2.4h);
    }
    
    inline float3 srgb_to_linear(float3 c)
    {
        return float3(srgb_to_linear(c.x), srgb_to_linear(c.y), srgb_to_linear(c.z));
    }
    
    inline float linear_to_srgb(float c)
    {
        return (c < 0.0031308f) ? (12.92f * c) : (1.055f * powr(c, 1.f/2.4f) - 0.055f);
    }
    
    inline float3 linear_to_srgb(float3 v) { 
        return float3(linear_to_srgb(v.x), linear_to_srgb(v.y), linear_to_srgb(v.z));
    }
    
template <typename T>
inline T dFdx(T v) {
    return dfdx(v);
template <typename T>
inline T dFdy(T v) {
    return -dfdy(v);
inline float4 texture2DProj(texture2d<float> tex, sampler smp, float4 uv)
    return tex.sample(smp, uv.xy / uv.w);
inline half4 texture2DProj(texture2d<half> tex, sampler smp, float4 uv)
    return tex.sample(smp, uv.xy / uv.w);
static constexpr sampler scn_shadow_sampler_rev_z = sampler(coord::normalized, filter::linear, mip_filter::none, address::clamp_to_zero, compare_func::less_equal);
static constexpr sampler scn_shadow_sampler_ord_z = sampler(coord::normalized, filter::linear, mip_filter::none, address::clamp_to_edge, compare_func::greater_equal);
#if defined(USE_REVERSE_Z) && USE_REVERSE_Z
static constexpr sampler scn_shadow_sampler = scn_shadow_sampler_rev_z;
#else
static constexpr sampler scn_shadow_sampler = scn_shadow_sampler_ord_z;
#endif
inline float shadow2D(sampler shadow_sampler, depth2d<float> tex, float3 uv)
    return tex.sample_compare(shadow_sampler, uv.xy, uv.z);
inline float shadow2DProj(sampler shadow_sampler, depth2d<float> tex, float4 uv)
    float3 uvp = uv.xyz / uv.w;
    return tex.sample_compare(shadow_sampler, uvp.xy, uvp.z);
inline float shadow2DArray(sampler shadow_sampler, depth2d_array<float> tex, float3 uv, uint slice)
    return tex.sample_compare(shadow_sampler, uv.xy, slice, uv.z);
inline float shadow2DArrayProj(sampler shadow_sampler, depth2d_array<float> tex, float4 uv, uint slice)
    float3 uvp = uv.xyz / uv.w;
    return tex.sample_compare(shadow_sampler, uvp.xy, slice, uvp.z);
inline float4 transformViewPosInShadowSpace(float3 pos, float4x4 shadowMatrix, bool reverseZ)
    
    float4 lightScreen =  shadowMatrix * float4(pos, 1.f);
    
    
    
    if (!reverseZ) {
        lightScreen.z = min(lightScreen.z, 0.9999f * lightScreen.w);
    } else {
        if (lightScreen.z <= 0.0) { 
            lightScreen.z = 2.0;
        }
    }
    return lightScreen;
inline float ComputeShadow(sampler shadow_sampler, float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap, bool reverseZ)
    float4 lightScreen =  transformViewPosInShadowSpace(worldPos, shadowMatrix, reverseZ);
    float shadow = shadow2DProj(shadow_sampler, shadowMap, lightScreen);
    
    shadow *= step(0., lightScreen.w);
    
    return shadow;
inline float ComputeSoftShadowGrid(sampler shadow_sampler, float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap, int sampleCount, bool reverseZ)
    float4 lightScreen =  transformViewPosInShadowSpace(worldPos, shadowMatrix, reverseZ);
    
    float shadow;
    if (sampleCount <= 1) {
        shadow = shadow2DProj(shadow_sampler, shadowMap, lightScreen);
    } else {
        float3 uvp = lightScreen.xyz / lightScreen.w;
        uvp.z += reverseZ ? 0.005f : -0.005f; 
        float2 texelSize = 2.f / float2(shadowMap.get_width(), shadowMap.get_height());
        float2 origin    = uvp.xy - (sampleCount * 0.5f) * texelSize;
        
        if (sampleCount <= 4) { 
            half totalAccum = 0.h;
            for (int y = 0; y < sampleCount; ++y) {
                for (int x = 0; x < sampleCount; ++x) {
                    totalAccum  += half(shadowMap.sample_compare(shadow_sampler, origin, uvp.z, 2 * int2(x,y)));
                }
            }
            shadow = totalAccum / half(sampleCount * sampleCount);
        } else {
            float totalAccum = 0.f;
            for (int y = 0; y < sampleCount; ++y) {
                for (int x = 0; x < sampleCount; ++x) {
                    float2 samplePos = origin + texelSize * float2(x, y);
                    totalAccum  += shadowMap.sample_compare(shadow_sampler, samplePos, uvp.z);
                }
            }
            shadow = totalAccum / float(sampleCount * sampleCount);
        }
    }
    
    shadow *= step(0., lightScreen.w);
    return shadow;
inline float ComputeSoftShadow(sampler shadow_sampler, float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount, float shadowRadius, bool reverseZ)
    float4 lightScreen =  transformViewPosInShadowSpace(worldPos, shadowMatrix, reverseZ);
    
    float shadow;
    if (sampleCount <= 1) {
        shadow = shadow2DProj(shadow_sampler, shadowMap, lightScreen);
    } else {
        
        float3 center_uv = lightScreen.xyz / lightScreen.w;
        float3 scale_uv  = float3(shadowRadius, shadowRadius, reverseZ ? shadowRadius * center_uv.z : shadowRadius / lightScreen.w );
        
        float totalAccum = 0.0;
        for (int i = 0; i < sampleCount; i++) {
            totalAccum += shadow2D(shadow_sampler, shadowMap, center_uv + shadowKernel[i].xyz * scale_uv);
        }
        
        shadow = totalAccum / float(sampleCount);
    }
    
    shadow *= step(0., lightScreen.w);
    return shadow;
inline float ComputeCascadeBlendAmount(float3 shadowPos, bool cascadeBlending)
    const float cascadeBlendingFactor = 0.1f; 
    float3 cascadePos = abs(shadowPos.xyz * 2.f - 1.f);
    
    if (cascadeBlending) {
#if 0
        const float edge = 1.f - cascadeBlendingFactor;
        
        cascadePos = 1.f - saturate((cascadePos - edge) / cascadeBlendingFactor);
        return cascadePos.x * cascadePos.y * cascadePos.z; 
#else
        
        float distToEdge = 1.0f - max(max(cascadePos.x, cascadePos.y), cascadePos.z);
        return smoothstep(0.0f, cascadeBlendingFactor, distToEdge);
#endif
    } else {
        return step(cascadePos.x, 1.f) * step(cascadePos.y, 1.f) * step(cascadePos.z, 1.f);
    }
inline float4 SampleShadowCascade(sampler shadow_sampler, depth2d_array<float> shadowMaps, float3 shadowPosition, uint cascadeIndex, constant float4* shadowKernel, int sampleCount, float shadowRadius)
    
    float2 gridSize = float2(shadowMaps.get_width(), shadowMaps.get_height()) / 32;
    float gd = scn::checkerboard(shadowPosition.xy, gridSize);
    float3 gridCol = mix(float3(scn::debugColorForCascade(cascadeIndex).rgb), float3(0.f), float3(gd > 0.f));
    
    float shadow = 0.f;
    if (sampleCount > 1) {
        
        for (int i = 0; i < sampleCount; ++i) {
            shadow += shadow2DArray(shadow_sampler, shadowMaps, shadowKernel[i].xyz * shadowRadius + shadowPosition, cascadeIndex);
        }
        shadow /= float(sampleCount);
    } else {
        
        shadow = shadow2DArray(shadow_sampler, shadowMaps, shadowPosition, cascadeIndex);
    }
    return float4(gridCol, shadow);
inline float4 ComputeCascadedShadow(sampler shadow_sampler, float3 viewPos, float4x4 shadowMatrix, constant float4 *cascadeScale, constant float4 *cascadeBias, int cascadeCount, depth2d_array<float> shadowMaps, bool enableCascadeBlending, constant float4* shadowKernel, int sampleCount, float shadowRadius)
    float4 shadow = 0.f;
    float opacitySum = 1.f;
    
    
    float3 pos_ls =  (shadowMatrix * float4(viewPos, 1.f)).xyz;
    for (int c = 0; c < cascadeCount; ++c) {
        
        float3 pos_cs =  pos_ls * cascadeScale[c].xyz + cascadeBias[c].xyz;
        
        float cascadeRadius = shadowRadius * cascadeScale[c].x;
        float opacity = ComputeCascadeBlendAmount(pos_cs, enableCascadeBlending);
        if (opacity > 0.f) { 
            
            float alpha = opacity * opacitySum;
            shadow += SampleShadowCascade(shadow_sampler, shadowMaps, pos_cs, c, shadowKernel, sampleCount, cascadeRadius) * alpha;
            opacitySum -= alpha;
        }
        if (opacitySum <= 0.f) 
            break;
    }
    return shadow;
#define USE_QUAT_FOR_IES 1
#define USE_PBR_DOMINANT_DIRECTION 1
struct scn_light
    float4 color; 
    float3 pos; 
    float3 dir; 
    float shadowRadius; 
    uint8_t lightType; 
    uint8_t attenuationType; 
    uint8_t shadowSampleCount; 
                                
    union {
        struct {
            float4      cascadeScale[4]; 
            float4      cascadeBias[4];
        } directional; 
        struct {
            float4      attenuationFactors; 
            float3      shadowScaleBias; 
        } omni;
        struct {
            float4      _attenuationFactors; 
            float2      scaleBias; 
        } spot;
        struct {
            float4      _attenuationFactors; 
            float2      scaleBias; 
#if USE_QUAT_FOR_IES
            float4      light_from_view_quat; 
#else
            float4x4    light_from_view; 
#endif
        } ies;
        union {
            struct {
                float2 halfExtents;
                float doubleSided;
            } rectangle;
            struct {
                uint32_t vertexCount;
                float doubleSided;
            } polygon;
            struct {
                float halfLength;
            } line;
            struct {
                float2 halfExtents;
                float doubleSided;
            } ellipse;
            struct {
                float3 halfExtents;
            } ellipsoid;
        } area;
        struct {
            float3  offset;
            float4  halfExtents; 
            float3  parallaxCenter;
            float3  parallaxExtents;
            int32_t index; 
            int32_t parallaxCorrection; 
        } probe;
    } parameters; 
    float4x4    shadowMatrix; 
#if defined(__METAL_VERSION__) 
using namespace metal;
namespace scn {
    static constexpr sampler linearSampler = sampler(filter::linear, mip_filter::linear);
#define ambientOcclusionTexcoord ambientTexcoord
struct SCNShaderSurface {
    float3 view;                
    float3 position;            
    float3 normal;              
    float3 geometryNormal;      
    float2 normalTexcoord;      
    float3 tangent;             
    float3 bitangent;           
    float4 ambient;             
    float2 ambientTexcoord;     
    float4 diffuse;             
    float2 diffuseTexcoord;     
    float4 specular;            
    float2 specularTexcoord;    
    float4 emission;            
    float2 emissionTexcoord;    
    float4 selfIllumination;            
    float2 selfIlluminationTexcoord;    
    float4 multiply;            
    float2 multiplyTexcoord;    
    float4 transparent;         
    float2 transparentTexcoord; 
    float4 reflective;          
    float  metalness;           
    float2 metalnessTexcoord;   
    float  roughness;           
    float2 roughnessTexcoord;   
    float clearCoat;            
    float2 clearCoatTexcoord;   
    float clearCoatRoughness;   
    float2 clearCoatRoughnessTexcoord;
    float3 clearCoatNormal;     
    float2 clearCoatNormalTexcoord;
    float shininess;            
    float fresnel;              
    float ambientOcclusion;     
    float3 _normalTS;           
    float3 _clearCoatNormalTS;  
#ifdef USE_SURFACE_EXTRA_DECL
    __SurfaceExtraDecl__
#endif
struct SCNShaderLight {
    float4 intensity;
    float3 direction;
    float  _att;
    float3 _spotDirection;
    float  _distance;
enum SCNLightingModel
    SCNLightingModelConstant,
    SCNLightingModelLambert,
    SCNLightingModelPhong,
    SCNLightingModelBlinn,
    SCNLightingModelNone,
    SCNLightingModelPhysicallyBased,
    SCNLightingModelShadowOnly,
    SCNLightingModelCustom 
enum C3DLightAttenuationType
    kC3DLightAttenuationTypeNone,
    kC3DLightAttenuationTypeConstant,
    kC3DLightAttenuationTypeLinear,
    kC3DLightAttenuationTypeQuadratic,
    kC3DLightAttenuationTypeExponent,
    kC3DLightAttenuationTypePhysicallyBased,
#define PROBES_NORMALIZATION 0
#define PROBES_OUTER_BLENDING 1
struct SCNShaderLightingContribution
    float3 ambient;
    float3 diffuse;
    float3 specular;
    float3 modulate;
#ifdef USE_SHADOWONLY
    float shadowFactor;
#endif
#if PROBES_NORMALIZATION
    float4 probesWeightedSum; 
#else
    float  probeRadianceRemainingFactor;
#endif
    thread SCNShaderSurface& surface;
#ifdef USE_PER_VERTEX_LIGHTING
    commonprofile_io out;
#else
    commonprofile_io in;
#endif
#if USE_REVERSE_Z
    constant static constexpr bool reverseZ = true;
#else
    constant static constexpr bool reverseZ = false;
#endif
#ifdef USE_PBR
    struct {
        float3 albedo;
        float3 envDiffuse;
        float3 envSpecular;
        float3 reflectance;
        float3 probeReflectance;
#ifndef USE_PBR_LAMBERTIAN_REFLECTION
        float2 diffuseHammonFactors;
#endif
#ifdef USE_PBR_TRANSPARENCY
        float  transparency;
#endif
        float  NoV;
        float  selfIlluminationOcclusion;
#ifdef USE_CLEARCOAT
        float  NoVClearCoat;
        float3 probeReflectanceClearCoat;
#endif
    } pbr;
#endif
    
    SCNShaderLightingContribution(thread SCNShaderSurface& iSurface, commonprofile_io io):surface(iSurface)
#ifdef USE_PER_VERTEX_LIGHTING
    ,out(io)
#else
    ,in(io)
#endif
    {
        ambient = 0.f;
        diffuse = 0.f;
        specular = 0.f;
#ifdef USE_SHADOWONLY
        shadowFactor = 1.f;
#endif
#if PROBES_NORMALIZATION
#if PROBES_OUTER_BLENDING
        probesWeightedSum = float4(0.f);
#else
        probesWeightedSum = float4(0.f, 0.f, 0.f, 0.000001f); 
#endif
#else
        probeRadianceRemainingFactor = 1.f;
#endif
#ifdef USE_MODULATE
        modulate = 1.f;
#else
        modulate = 0.f;
#endif
    }
#ifdef USE_PBR
    void prepareForPBR(texture2d<float, access::sample> specularDFGDiffuseHammonTexture, float occ)
    {
        pbr.envDiffuse = 0.f;
        pbr.envSpecular = 0.f;
        pbr.selfIlluminationOcclusion = occ;
      
        pbr.albedo = surface.diffuse.rgb;
#ifdef USE_PBR_TRANSPARENCY
  #ifdef DIFFUSE_PREMULTIPLIED
        
        pbr.transparency = 1.f;
  #else
        pbr.transparency = surface.diffuse.a;
  #endif
  #ifdef USE_TRANSPARENCY
    #ifdef USE_PER_VERTEX_LIGHTING
        pbr.transparency *= out.transparency;
    #else
        pbr.transparency *= in.transparency;
    #endif
  #endif
  #ifdef USE_TRANSPARENT
        
        pbr.transparency *= surface.transparent.a;
  #endif
        pbr.albedo *= pbr.transparency;
  #ifdef DIFFUSE_PREMULTIPLIED
        
        
        pbr.transparency *= surface.diffuse.a;
  #endif
#endif
        
        float3 n = surface.normal;
        float3 v = surface.view;
        pbr.NoV = abs(dot(n, v));
        
        float roughness = surface.roughness;
#ifdef USE_PBR_LAMBERTIAN_REFLECTION
        float2 specularDFG = specularDFGDiffuseHammonTexture.sample(scn::linearSampler, float2(pbr.NoV, roughness)).rg;
#else
        float4 env = specularDFGDiffuseHammonTexture.sample(scn::linearSampler, float2(pbr.NoV, roughness));
        float2 specularDFG = env.xy;
        pbr.diffuseHammonFactors = env.zw;
#endif
        
        pbr.reflectance = mix(PBR_F0_NON_METALLIC, pbr.albedo, surface.metalness);
        pbr.probeReflectance = pbr.reflectance * specularDFG.r + specularDFG.g;
                                
#ifdef USE_CLEARCOAT
        pbr.NoVClearCoat = abs(dot(surface.clearCoatNormal, v));
        float2 DFGClearCoat = specularDFGDiffuseHammonTexture.sample(scn::linearSampler, float2(pbr.NoVClearCoat, surface.clearCoatRoughness)).rg;
        pbr.probeReflectanceClearCoat = 0.04 * DFGClearCoat.r + DFGClearCoat.g;
#endif
    }
#endif
#ifdef USE_LIGHT_MODIFIER
    __LightModifierExtraDecl__
#endif
    float4 debug_pixel(float2 fragmentPosition)
    {
        const int width = 64;
        switch (int(fragmentPosition.x + fragmentPosition.y ) / width) {
            case 0: return float4(surface.view, 1.f);
            case 1: return float4(surface.position, 1.f);
            case 2: return float4(surface.normal, 1.f);
            case 3: return float4(surface.geometryNormal, 1.f);
            case 4: return float4(float3(surface.ambientOcclusion), 1.f);
            case 5: return surface.diffuse;
            case 6: return float4(float3(surface.metalness), 1.f);
            case 7: return float4(float3(surface.roughness), 1.f);
            case 8: return float4(ambient, 1.f);
            case 9: return float4(diffuse, 1.f);
            default: return float4(specular, 1.f);
        }
    }
    
    static inline float3 lambert_diffuse(float3 l, float3 n, float3 color, float intensity) {
        return color * (intensity * saturate(dot(n, l)));
    }
    void lambert(float3 l, float3 color, float intensity)
    {
        diffuse += lambert_diffuse(l, surface.normal, color, intensity);
    }
    void blinn(float3 l, float3 color, float intensity)
    {
        float3 D = lambert_diffuse(l, surface.normal, color, intensity);
        diffuse += D;
        float3 h = normalize(l + surface.view);
        specular += powr(saturate(dot(surface.normal, h)), surface.shininess) * D;
    }
    void phong(float3 l, float3 color, float intensity)
    {
        float3 D = lambert_diffuse(l, surface.normal, color, intensity);
        diffuse += D;
        float3 r = reflect(-l, surface.normal);
        specular += powr(saturate(dot(r, surface.view)), surface.shininess) * D;
    }
#ifdef USE_PBR
    void physicallyBased(float3 l, float3 color, float intensity)
    {
        float3 n         = surface.normal;
        float3 v         = surface.view;
        float  roughness = surface.roughness;
        float  alpha     = roughness * roughness;
        float3 h = normalize(l + v);
        float NoL = saturate(dot(n, l));
        float NoH = saturate(dot(n, h));
        float LoH = saturate(dot(l, h));
        
        float D   = scn_brdf_D(alpha, NoH);
        float3 F  = scn_brdf_F_opt(pbr.reflectance, LoH);
        float Vis = scn_brdf_V(alpha, NoL, pbr.NoV);
        
        diffuse  += color * (NoL * M_1_PI_F * intensity);
        specular += color * F * (NoL * D * Vis * intensity);
        
        #ifdef USE_CLEARCOAT
            n = surface.clearCoatNormal;
            roughness = max(surface.clearCoatRoughness, 0.089f);
            alpha = roughness * roughness; 
        
            
            
            float NoH_coat = saturate(dot(n, h));
            float NoL_coat = saturate(dot(n, l));
            D   = scn_brdf_D(alpha, NoH_coat);
            F   = scn_brdf_F_opt(0.04, LoH) * surface.clearCoat;
            Vis = scn_brdf_V(alpha, NoL_coat, saturate(dot(n,v)));
        
            float attenuation = 1.0 - F.r;
            specular *=  (attenuation * attenuation);
            specular += color * F * ( NoL_coat * D * Vis * intensity);
        #endif
    }
#endif
    void custom(float3 _l, float3 _color, float _intensity)
    {
#ifdef USE_LIGHT_MODIFIER
        thread SCNShaderLightingContribution &_lightingContribution = *this;
        thread SCNShaderSurface& _surface = surface;
        SCNShaderLight _light = {.direction = _l, .intensity = float4(_color, 1.f), ._att = _intensity };
        
        __DoLightModifier__
        
#endif
    }
    void shade(float3 l, float3 color, float intensity)
    {
#ifdef LIGHTING_MODEL
        switch (LIGHTING_MODEL) {
#ifdef USE_SHADOWONLY
            case SCNLightingModelShadowOnly:        shadowFactor *= intensity; break;
#endif
            case SCNLightingModelLambert:           lambert(l, color, intensity); break;
            case SCNLightingModelBlinn:             blinn(l, color, intensity);   break;
            case SCNLightingModelPhong:             phong(l, color, intensity);   break;
#ifdef USE_PBR
            case SCNLightingModelPhysicallyBased:   physicallyBased(l, color, intensity); break;
#endif
            case SCNLightingModelCustom:            custom(l, color, intensity);  break;
            default:  break; 
        }
#endif
    }
    
    
    
    float pbr_dist_attenuation_alternate(float3 l, float cutoff) {
        
        float radius = 0.1f; 
        float factor = 1.f / (1.f + length(l)/radius);
        float attenuation = saturate(factor * factor); 
        return saturate((attenuation - cutoff) / (1.f - cutoff));
    }
    float pbr_dist_attenuation(float3 l, float inv_square_radius) {
        float sqr_dist = length_squared(l);
        float atten = 1.f / max(sqr_dist, 0.0001f);
        
        float factor = saturate(1.f - scn::sq(sqr_dist * inv_square_radius));
        return atten * factor * factor;
    }
    float non_pbr_dist_attenuation(float3 l, float4 att)
    {
        return powr(saturate(length(l) * att.x + att.y), att.z);
    }
    float dist_attenuation(float3 unnormalized_l, scn_light light)
    {
#ifdef USE_PBR
        return 1000.f * pbr_dist_attenuation(unnormalized_l, light.parameters.omni.attenuationFactors.w);
        
        
#else
#ifdef USE_SHADOWONLY
        return 1.f;
#endif
        return non_pbr_dist_attenuation(unnormalized_l, light.parameters.omni.attenuationFactors);
#endif
    }
    float spot_attenuation(float3 l, scn_light light)
    {
#ifdef USE_SHADOWONLY
        return 1.f;
#endif
        
        return saturate(dot(l, light.dir) * light.parameters.spot.scaleBias.x + light.parameters.spot.scaleBias.y);
    }
    void shade_modulate(float3 l, float4 color, float intensity)
    {
        constexpr half3 white = half3(1.h);
        
        modulate *= float3(mix(white, half3(color.rgb), half(color.a * intensity)));
    }
    float3 gobo(float3 pos, scn_light light, texture2d<half> goboTexture, sampler goboSampler)
    {
        half3 g = texture2DProj(goboTexture, goboSampler, (light.shadowMatrix * float4(pos, 1.f))).rgb;
        return light.color.rgb * float3(mix(1.h, g, half(light.color.a)));
    }
    float shadow(float3 pos, scn_light light, depth2d<float> shadowMap)
    {
        float shadow = ComputeShadow(scn_shadow_sampler, pos, light.shadowMatrix, shadowMap, reverseZ);
        return 1.f - shadow * light.color.a; 
    }
    
    float shadow(float3 pos, scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel)
    {
        float shadow = ComputeSoftShadow(scn_shadow_sampler, pos, light.shadowMatrix, shadowMap, shadowKernel, light.shadowSampleCount, light.shadowRadius, reverseZ);
        return 1.f - shadow * light.color.a; 
    }
    float shadow(float3 pos, scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int shadowSampleCount)
    {
        float shadow = ComputeSoftShadow(scn_shadow_sampler, pos, light.shadowMatrix, shadowMap, shadowKernel, shadowSampleCount, light.shadowRadius, reverseZ);
        return 1.f - shadow * light.color.a; 
    }
    float shadow(float3 pos, scn_light light, depth2d<float> shadowMap, int shadowSampleCount)
    {
        float shadow = ComputeSoftShadowGrid(scn_shadow_sampler, pos, light.shadowMatrix, shadowMap, shadowSampleCount, reverseZ);
        return 1.f - shadow * light.color.a; 
    }
    float shadow_omni(float3 pos_vs, float3 nrm_vs, scn_light light, depthcube<float> shadowMap, constant float4* shadowKernel, int sampleCount)
    {
        
#define USE_TANGENT_SAMPLING 0
        float2 scaleBias = light.parameters.omni.shadowScaleBias.xy;
        float  depthBias = light.parameters.omni.shadowScaleBias.z;
        
        pos_vs += nrm_vs * depthBias;
        
        float3 pos_ls = (light.shadowMatrix * float4(pos_vs, 1.f)).xyz;
        
        float z_lin = scn::reduce_max(abs(pos_ls));
        
        
        
        
        float z_ndc = (z_lin * scaleBias.x + scaleBias.y) / z_lin - depthBias;
        
        float shadow;
        if (sampleCount <= 1) {
            shadow = shadowMap.sample_compare(scn_shadow_sampler, pos_ls.xyz, z_ndc);
        } else {
            
            float filteringSizeFactor = light.shadowRadius;
#if USE_TANGENT_SAMPLING
            float3 tgt_x, tgt_y;
            scn::orthogonal_basis(pos_ls, tgt_x, tgt_y);
#else
            float3 nrm_ls = (light.shadowMatrix * float4(nrm_vs, 0.f)).xyz;
#endif
            
            float totalAccum = 0.0;
            for(int i=0; i < sampleCount; i++){
#if USE_TANGENT_SAMPLING
                float2 scale = shadowKernel[i].xy * filteringSizeFactor * 2.f;
                float3 smp_ls = pos_ls.xyz + tgt_x * scale.x + tgt_y * scale.y;
#else
                float3 smp_ls = pos_ls.xyz + scn::randomHemisphereDir(nrm_ls, shadowKernel[i].xy) * filteringSizeFactor;
#endif
                
                
                
                totalAccum += shadowMap.sample_compare(scn_shadow_sampler, smp_ls, z_ndc);
            }
            shadow = totalAccum / float(sampleCount);
        }
        return 1.f - shadow * light.color.a; 
    }
    float shadow(float3 pos, constant scn_light& light, depth2d_array<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount)
    {
        float shadow = ComputeCascadedShadow(scn_shadow_sampler, pos, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius).a;
        return 1.f - shadow * light.color.a; 
    }
    
    void add_directional(scn_light light)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        shade(light.dir, light.color.rgb, intensity);
    }
    
    void add_directional(scn_light light, texture2d<half> goboTexture, sampler goboSampler, bool modulated)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);
        if (modulated) {
            shade_modulate(light.dir, light.color, 1.f);
        } else {
            shade(light.dir, light.color.rgb, intensity);
        }
    }
    
    void add_directional(scn_light light, depth2d<float> shadowMap)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        intensity *= shadow(surface.position, light, shadowMap);
        shade(light.dir, light.color.rgb, intensity);
    }
    
    void add_directional(scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        intensity *= shadow(surface.position, light, shadowMap, shadowKernel);
        shade(light.dir, light.color.rgb, intensity);
    }
    void add_directional(scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        intensity *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);
        shade(light.dir, light.color.rgb, intensity);
    }
    
    void add_directional(scn_light light, depth2d<float> shadowMap, int sampleCount)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        intensity *= shadow(surface.position, light, shadowMap, sampleCount);
        shade(light.dir, light.color.rgb, intensity);
    }
    
    void add_directional(constant scn_light& light, depth2d_array<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount, bool debugCascades)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        if (debugCascades) {
            float4 shadowDebug = ComputeCascadedShadow(scn_shadow_sampler, surface.position, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius);
            intensity *= (1.f - shadowDebug.a);
            shade(light.dir, light.color.rgb, intensity);
            diffuse.rgb = mix(diffuse.rgb, shadowDebug.rgb, light.color.a);
        } else {
            intensity *= shadow(surface.position, light, shadowMaps, cascadeCount, blendCascade, shadowKernel, sampleCount);
            shade(light.dir, light.color.rgb, intensity);
        }
    }
    
    void add_omni(scn_light light)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        shade(l, light.color.rgb, dist_attenuation(unnormalized_l, light));
    }
    void add_omni(scn_light light, depthcube<float> shadowMap, constant float4* shadowKernel, int sampleCount)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity *= shadow_omni(surface.position, surface.normal, light, shadowMap, shadowKernel, sampleCount);
        shade(l, light.color.rgb, intensity);
    }
    void add_local_omni(scn_light light)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        shade(l, light.color.rgb, dist_attenuation(unnormalized_l, light));
    }
    
    void add_spot(scn_light light)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity      *= spot_attenuation(l, light);
        shade(l, light.color.rgb, intensity);
    }
    void add_spot(scn_light light, texture2d<half> goboTexture, sampler goboSampler, bool modulated)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity      *= spot_attenuation(l, light);
        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);
        if (modulated) {
            shade_modulate(l, light.color, intensity);
        } else {
            shade(l, light.color.rgb, intensity);
        }
    }
    void add_local_spot(scn_light light)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity      *= spot_attenuation(l, light);
        shade(l, light.color.rgb, intensity);
    }
    
    void add_spot(scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity      *= spot_attenuation(l, light);
        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);
        shade(l, light.color.rgb, intensity);
    }
    
    void add_spot(scn_light light, 
                  depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount,
                  texture2d<half> goboTexture, sampler goboSampler)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity      *= spot_attenuation(l, light);
        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);
        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);
        shade(l, light.color.rgb, intensity);
    }
    
#ifdef USE_PBR
    
#ifdef C3D_SUPPORT_CUBE_ARRAY
    void add_local_probe(scn_light light, texturecube_array<half> probeTextureArray)
#else
    void add_local_probe(scn_light light, texture2d_array<half> probeTextureArray)
#endif
    {
#if !PROBES_NORMALIZATION
        if (probeRadianceRemainingFactor <= 0.f)
            return;
#endif
        bool parallaxCorrection = light.parameters.probe.parallaxCorrection;
        int    probeIndex       = light.parameters.probe.index;
        float3 probeExtents     = light.parameters.probe.halfExtents.xyz;
        float  blendDist        = light.parameters.probe.halfExtents.w;
        float3 probeOffset      = light.parameters.probe.offset;
        float3 parallaxExtents  = light.parameters.probe.parallaxExtents;
        float3 parallaxCenter   = light.parameters.probe.parallaxCenter;
        float3 n = surface.normal;
        float3 v = surface.view;
        float3 r = reflect(-v, n); 
        float3 specDir = scn::mat4_mult_float3(light.shadowMatrix, r);
        
        float3 pos_ls = (light.shadowMatrix * float4(surface.position, 1.f)).xyz;
        
        float3 d = abs(pos_ls) - probeExtents;
#if PROBES_OUTER_BLENDING
        if (any(d > blendDist))
#else
        if (any(d > 0.f))
#endif
        {
            return;
        }
#if PROBES_NORMALIZATION
        
        
#if PROBES_OUTER_BLENDING
        float3 nd = saturate(-(d / blendDist) * 0.5f + 0.5f);
#else
        float3 nd = saturate(-(d / blendDist));
#endif
        float probeFactor = (nd.x * nd.y * nd.z) * light.color.r;
#else
        
        float sd = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
#if PROBES_OUTER_BLENDING
        float probeFactor = saturate(1.f - sd / blendDist);
#else
        float probeFactor = saturate(-sd / blendDist);
#endif
        
        
        
        probeFactor *= probeRadianceRemainingFactor * light.color.r; 
#endif
        if (parallaxCorrection ) {
            
            float3 pos_off = pos_ls + parallaxCenter;
            float3 t1 = ( parallaxExtents - pos_off) / specDir;
            float3 t2 = (-parallaxExtents - pos_off) / specDir;
            float3 tmax = max(max(0, t1), t2); 
            float t = min(tmax.x, min(tmax.y, tmax.z));
            
            float3 hit_ls = pos_ls + specDir * t;
            specDir = hit_ls - probeOffset;
        }
        float mipd = float(probeTextureArray.get_num_mip_levels()) - 1.f;
        const float intensity = surface.ambientOcclusion * probeFactor;
        float mips = surface.roughness * mipd;
#ifdef C3D_SUPPORT_CUBE_ARRAY
        float3 LD = float3(probeTextureArray.sample(scn::linearSampler, specDir, probeIndex, level(mips)).rgb);
#else
        float2 specUV = scn::dual_paraboloid_from_cartesian(normalize(specDir));
        float3 LD = float3(probeTextureArray.sample(scn::linearSampler, specUV, probeIndex, level(mips)).rgb);
#endif
        
        
#if PROBES_NORMALIZATION
        probesWeightedSum += float4(LD * intensity * pbr.probeReflectance, probeFactor);
#else
        probeRadianceRemainingFactor = saturate(probeRadianceRemainingFactor - probeFactor);
        specular += LD * intensity * pbr.probeReflectance;
#endif
        
#ifdef USE_CLEARCOAT
        n = surface.clearCoatNormal;
        r = reflect(-v, n);
        specDir = scn::mat4_mult_float3(light.shadowMatrix, r);
        if (parallaxCorrection ) {
            float3 pos_off = pos_ls + parallaxCenter;
            
            float3 t1 = ( parallaxExtents - pos_off) / specDir;
            float3 t2 = (-parallaxExtents - pos_off) / specDir;
            float3 tmax = max(max(0, t1), t2); 
            float t = min(tmax.x, min(tmax.y, tmax.z));
            
            
            float3 hit_ls = pos_ls + specDir * t;
            specDir = hit_ls - probeOffset;
        }
        mips = surface.clearCoatRoughness * mipd;
#ifdef C3D_SUPPORT_CUBE_ARRAY
        LD = float3(probeTextureArray.sample(scn::linearSampler, specDir, probeIndex, level(mips)).rgb);
#else
        specUV = scn::dual_paraboloid_from_cartesian(normalize(specDir));
        LD = float3(probeTextureArray.sample(scn::linearSampler, specUV, probeIndex, level(mips)).rgb);
#endif
#if PROBES_NORMALIZATION
        probesWeightedSum += float4(LD * intensity * pbr.probeReflectanceClearCoat, probeFactor) * surface.clearCoat;
#else
        specular += LD * intensity * pbr.probeReflectanceClearCoat * surface.clearCoat;
#endif
#endif
    }
    void add_global_probe(float4x4 localDirToWorldCubemapDir,
                          float environmentIntensity,
#ifdef C3D_SUPPORT_CUBE_ARRAY
                          texturecube_array<half> probeTextureArray
#else
                          texture2d_array<half> probeTextureArray
#endif
                          )
    {
        float3 n = surface.normal;
        float3 v = surface.view;
        float3 r = reflect(-v, n); 
        
        float3 specDir = scn::mat4_mult_float3(localDirToWorldCubemapDir, r);
        float mips = surface.roughness * float(probeTextureArray.get_num_mip_levels() - 1);
#ifdef C3D_SUPPORT_CUBE_ARRAY
        float3 LD = float3(probeTextureArray.sample(scn::linearSampler, specDir, 0, level(mips)).rgb);
#else
        float2 specUV = scn::dual_paraboloid_from_cartesian(normalize(specDir));
        float3 LD = float3(probeTextureArray.sample(scn::linearSampler, specUV, 0, level(mips)).rgb);
#endif
        
        
        specular += pbr.probeReflectance * LD * surface.ambientOcclusion * environmentIntensity;
    }
    void add_global_probe(texturecube<float, access::sample> specularLD,
                          float4x4                           localDirToWorldCubemapDir,
                          float                              environmentIntensity)
    {
        float3 n        = surface.normal;
        float3 v        = surface.view;
        float3 r        = reflect(-v, n); 
        float roughness = surface.roughness;
#if USE_PBR_DOMINANT_DIRECTION
        float alpha = roughness * roughness;
        float smoothness = 1.0f - alpha;
        float specularLerpFactor = (1. - smoothness * (sqrt(smoothness) + alpha));
        float3 specularDominantNDirection = mix(r, n, specularLerpFactor); 
#else
        float3 specularDominantNDirection = r;
#endif
        
        
        float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);
        float3 dir = scn::mat4_mult_float3(localDirToWorldCubemapDir, specularDominantNDirection);
        float3 LD = specularLD.sample(scn::linearSampler, dir, level(mipLevel)).rgb;
        pbr.envSpecular += pbr.probeReflectance * LD * surface.ambientOcclusion * environmentIntensity;
    }
#ifdef USE_CLEARCOAT
    void add_global_probeClearCoat(texturecube<float, access::sample> specularLD,
                          float4x4                           localDirToWorldCubemapDir,
                          float                              environmentIntensity)
    {
        float3 n = surface.clearCoatNormal;
        
        float3 v        = surface.view;
        float3 r        = reflect(-v, n); 
        float roughness = surface.clearCoatRoughness;
        
        float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);
        float3 LD = specularLD.sample(scn::linearSampler, scn::mat4_mult_float3(localDirToWorldCubemapDir, r), level(mipLevel)).rgb;
        LD *= surface.ambientOcclusion;
        
        
        float Fc = scn_brdf_F_opt(0.04f, pbr.NoVClearCoat).r * surface.clearCoat;
        float attenuation = 1.0f - Fc;
        specular *= (attenuation * attenuation);
        
        specular += LD * environmentIntensity * pbr.probeReflectanceClearCoat * surface.clearCoat;
    }
#endif
    
    
    void add_irradiance_from_selfIllum()
    {
        float selfIlluminationAO = saturate(mix(1.f, surface.ambientOcclusion, pbr.selfIlluminationOcclusion));
        float3 irradiance = surface.selfIllumination.rgb;
        
        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);
#ifdef USE_PBR_LAMBERTIAN_REFLECTION
        pbr.envDiffuse += selfIlluminationAO * irradiance * diffuseAlbedo;
#else
        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);
        pbr.envDiffuse += selfIlluminationAO * irradiance * diffuseReflectance;
#endif
    }
    void add_global_irradiance_from_sh(float4x4         localDirToWorldCubemapDir,
#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)
                                       sh2_coefficients shCoefficients)
#else
    sh3_coefficients shCoefficients)
#endif
    {
        float3 n_sh_space = scn::mat4_mult_float3(localDirToWorldCubemapDir, surface.normal);
        float3 irradiance = shEvalDirection(float4(n_sh_space, 1.), shCoefficients);
        
        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);
#ifdef USE_PBR_LAMBERTIAN_REFLECTION
        pbr.envDiffuse += surface.ambientOcclusion * irradiance * diffuseAlbedo;
#else
        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);
        pbr.envDiffuse += surface.ambientOcclusion * irradiance * diffuseReflectance;
#endif
    }
    void add_global_irradiance_probe(texturecube<float, access::sample> irradianceTexture,
                                     float4x4                           localDirToWorldCubemapDir,
                                     float                              environmentIntensity)
    {
#if USE_PBR_DOMINANT_DIRECTION
        float3 n = surface.normal;
        float3 v = surface.view;
        
        
        const half a = 1.02341h * surface.roughness - 1.51174h; 
        const half b = -0.511705h * surface.roughness + 0.755868h;
        const half diffuseBendFactor = saturate((pbr.NoV * a + b) * surface.roughness);
        float3 diffuseDominantNDirection = mix(n, v, diffuseBendFactor);
#else
        float3 diffuseDominantNDirection = n;
#endif
        
        float3 n_cube_space = scn::mat4_mult_float3(localDirToWorldCubemapDir, diffuseDominantNDirection);
        float3 irradiance = irradianceTexture.sample(scn::linearSampler, n_cube_space).rgb;
        
        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);
#ifdef USE_PBR_LAMBERTIAN_REFLECTION
        pbr.envDiffuse += (surface.ambientOcclusion * environmentIntensity) * irradiance * diffuseAlbedo;
#else
        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);
        pbr.envDiffuse += (surface.ambientOcclusion * environmentIntensity) * irradiance * diffuseReflectance;
#endif
    }
#endif 
    
    static constexpr sampler iesSampler = sampler(filter::linear, mip_filter::none, address::clamp_to_edge);
    
    float ies_attenuation(float3 l, scn_light light, texture2d<half> iesTexture)
    {
#if USE_QUAT_FOR_IES
        float3 v    = scn::quaternion_rotate_vector(light.parameters.ies.light_from_view_quat, -l);
#else
        float3 v    = scn::matrix_rotate(light.parameters.ies.light_from_view, -l);
#endif
        float phi   = (v.z * light.parameters.ies.scaleBias.x + light.parameters.ies.scaleBias.y);
        float theta = atan2(v.y, v.x) * 0.5f * M_1_PI_F;
        return iesTexture.sample(iesSampler, float2(phi, abs(theta))).r;
    }
    void add_ies(scn_light light, texture2d<half> iesTexture)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity      *= ies_attenuation(l, light, iesTexture);
        shade(l, light.color.rgb, intensity);
    }
    void add_ies(scn_light light, texture2d<half> iesTexture, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity      *= ies_attenuation(l, light, iesTexture);
        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);
        shade(l, light.color.rgb, intensity);
    }
    
    void add_area_rectangle(scn_light light, texture2d_array<float> bakedDataTexture)
    {
#ifdef USE_PBR
        float3 v = surface.view;
        float3 n = surface.normal;
        float3 p = surface.position;
        
        float3 tangent = normalize(v - n * dot(v, n));
        float3 bitangent = cross(n, tangent);
        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));
        float3 lightCenter = light.shadowMatrix[3].xyz;
        
        
        float sidedness = dot(light.dir, lightCenter - p);
        if (light.parameters.area.rectangle.doubleSided == false && sidedness <= 0.f)
            return;
        
        float3 lightRight = light.shadowMatrix[0].xyz * light.parameters.area.rectangle.halfExtents.x * sign(sidedness);
        float3 lightTop   = light.shadowMatrix[1].xyz * light.parameters.area.rectangle.halfExtents.y;
        
        float4x3 cornerDirections = float4x3((lightCenter + lightRight + lightTop) - p,
                                             (lightCenter + lightRight - lightTop) - p,
                                             (lightCenter - lightRight - lightTop) - p,
                                             (lightCenter - lightRight + lightTop) - p);
        cornerDirections[0] = shadingSpaceTransform * cornerDirections[0];
        cornerDirections[1] = shadingSpaceTransform * cornerDirections[1];
        cornerDirections[2] = shadingSpaceTransform * cornerDirections[2];
        cornerDirections[3] = shadingSpaceTransform * cornerDirections[3];
        float diffuseAmount = pbr_area_light_eval_rectangle(cornerDirections);
        float brdfNorm = 1.f;
        float3x3 inverseLTCMatrix = scn_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);
        cornerDirections[0] = inverseLTCMatrix * cornerDirections[0];
        cornerDirections[1] = inverseLTCMatrix * cornerDirections[1];
        cornerDirections[2] = inverseLTCMatrix * cornerDirections[2];
        cornerDirections[3] = inverseLTCMatrix * cornerDirections[3];
        float specularAmount = brdfNorm * pbr_area_light_eval_rectangle(cornerDirections);
        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); 
        
        float3 lightColor = light.color.rgb;
        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;
        specular += specularAmount * lightColor * pbr.reflectance;
#endif
    }
    void add_area_polygon(scn_light light, texture2d_array<float> bakedDataTexture, device packed_float2 *vertexPositions)
    {
#ifdef USE_PBR
        float3 v = surface.view;
        float3 n = surface.normal;
        float3 p = surface.position;
        
        float3 tangent = normalize(v - n * dot(v, n));
        float3 bitangent = cross(n, tangent);
        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));
        float3 lightCenter = light.shadowMatrix[3].xyz;
        
        
        float sidedness = dot(light.dir, lightCenter - p);
        if (light.parameters.area.polygon.doubleSided == false && sidedness <= 0.f)
            return;
        
        float3 lightRight = light.shadowMatrix[0].xyz * sign(sidedness);
        float3 lightTop   = light.shadowMatrix[1].xyz;
        p           = shadingSpaceTransform * p;
        lightCenter = shadingSpaceTransform * lightCenter;
        lightRight  = shadingSpaceTransform * lightRight;
        lightTop    = shadingSpaceTransform * lightTop;
        float diffuseAmount = pbr_area_light_eval_polygon(p, lightCenter, lightRight, lightTop, light.parameters.area.polygon.vertexCount, vertexPositions);
        float brdfNorm = 1.f;
        float3x3 inverseLTCMatrix = scn_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);
        p           = inverseLTCMatrix * p;
        lightCenter = inverseLTCMatrix * lightCenter;
        lightRight  = inverseLTCMatrix * lightRight;
        lightTop    = inverseLTCMatrix * lightTop;
        float specularAmount = brdfNorm * pbr_area_light_eval_polygon(p, lightCenter, lightRight, lightTop, light.parameters.area.polygon.vertexCount, vertexPositions);
        
        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); 
        float3 lightColor = light.color.rgb;
        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;
        specular += specularAmount * lightColor * pbr.reflectance;
#endif
    }
    void add_area_line(scn_light light, texture2d_array<float> bakedDataTexture)
    {
#ifdef USE_PBR
        float3 v = surface.view;
        float3 n = surface.normal;
        float3 p = surface.position;
        
        float3 tangent = normalize(v - n * dot(v, n));
        float3 bitangent = cross(n, tangent);
        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));
        float3 lightCenter = light.shadowMatrix[3].xyz;
        float3 lightRight  = light.shadowMatrix[0].xyz * light.parameters.area.line.halfLength;
        float2x3 cornerDirections = float2x3((lightCenter + lightRight) - p,
                                             (lightCenter - lightRight) - p);
        cornerDirections[0] = shadingSpaceTransform * cornerDirections[0];
        cornerDirections[1] = shadingSpaceTransform * cornerDirections[1];
        float diffuseAmount = pbr_area_light_eval_line(cornerDirections);
        float brdfNorm = 1.f;
        float3x3 inverseLTCMatrix = scn_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);
        cornerDirections[0] = inverseLTCMatrix * cornerDirections[0];
        cornerDirections[1] = inverseLTCMatrix * cornerDirections[1];
        float specularAmount = brdfNorm * pbr_area_light_eval_line(cornerDirections);
        float3 ortho = normalize(cross(cornerDirections[0], cornerDirections[1]));
        float ltcWidthFactor = 1.0 / length(scn_ltc_matrix_invert_transpose(inverseLTCMatrix) * ortho);
        specularAmount *= ltcWidthFactor;
        
        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); 
        float3 lightColor = light.color.rgb;
        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;
        specular += specularAmount * lightColor * pbr.reflectance;
#endif
    }
    void add_area_ellipse(scn_light light, texture2d_array<float> bakedDataTexture)
    {
#ifdef USE_PBR
#endif
    }
    void add_area_ellipsoid(scn_light light, texture2d_array<float> bakedDataTexture)
    {
#ifdef USE_PBR
#endif
    }
#endif 
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
#import "C3D-PBR.metal"
#import "scn_tessellation.h"
#ifdef USE_LAYERED_RENDERING
#define texture2d_layer texture2d_array
#define sampleLayer(a,b) sample(a,b,in.sliceIndex)
#else
#define texture2d_layer texture2d
#define sampleLayer(a,b) sample(a,b)
#endif
#ifdef C3D_USE_TEXTURE_FOR_LIGHT_INDICES
#define LightIndex(lid) u_lightIndicesTexture.read((ushort)lid).x
#else
#define LightIndex(lid) u_lightIndicesBuffer[lid]
#endif
#ifdef IS_BEZIER_CURVE
[[visible]] bool scn_is_inside_bezier_curve(float2 p, device void const* curveData, device packed_float3 const* controlPoints);
#endif
typedef struct {
#ifdef USE_MODELTRANSFORM
    float4x4 modelTransform;
#endif
#ifdef USE_INVERSEMODELTRANSFORM
    float4x4 inverseModelTransform;
#endif
#ifdef USE_MODELVIEWTRANSFORM
    float4x4 modelViewTransform;
#endif
#ifdef USE_INVERSEMODELVIEWTRANSFORM
    float4x4 inverseModelViewTransform;
#endif
#ifdef USE_NORMALTRANSFORM
    float4x4 normalTransform;
#endif
#ifdef USE_MODELVIEWPROJECTIONTRANSFORM
    float4x4 modelViewProjectionTransform;
#endif
#ifdef USE_INVERSEMODELVIEWPROJECTIONTRANSFORM
    float4x4 inverseModelViewProjectionTransform;
#endif
#ifdef USE_MOTIONBLUR
    float4x4 lastFrameModelTransform;
    float motionBlurIntensity;
#endif
#ifdef USE_BOUNDINGBOX
    float2x3 boundingBox;
#endif
#ifdef USE_WORLDBOUNDINGBOX
    float2x3 worldBoundingBox;
#endif
#ifdef USE_NODE_OPACITY
    float nodeOpacity;
#endif
#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)
    sh2_coefficients shCoefficients;
#elif defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 3)
    sh3_coefficients shCoefficients;
#endif
} commonprofile_node;
typedef struct {
    float3 position         [[attribute(SCNVertexSemanticPosition)]];
#ifdef HAS_NORMAL
    float3 normal           [[attribute(SCNVertexSemanticNormal)]];
#endif
#ifdef USE_TANGENT
    float4 tangent          [[attribute(SCNVertexSemanticTangent)]];
#endif
#ifdef USE_VERTEX_COLOR
    float4 color            [[attribute(SCNVertexSemanticColor)]];
#endif
#if defined(NEED_IN_TEXCOORD0) || defined(DEBUG_PIXEL)
    float2 texcoord0        [[attribute(SCNVertexSemanticTexcoord0)]];
#endif
#ifdef NEED_IN_TEXCOORD1
    float2 texcoord1        [[attribute(SCNVertexSemanticTexcoord1)]];
#endif
#ifdef NEED_IN_TEXCOORD2
    float2 texcoord2        [[attribute(SCNVertexSemanticTexcoord2)]];
#endif
#ifdef NEED_IN_TEXCOORD3
    float2 texcoord3        [[attribute(SCNVertexSemanticTexcoord3)]];
#endif
#ifdef NEED_IN_TEXCOORD4
    float2 texcoord4        [[attribute(SCNVertexSemanticTexcoord4)]];
#endif
#ifdef NEED_IN_TEXCOORD5
    float2 texcoord5        [[attribute(SCNVertexSemanticTexcoord5)]];
#endif
#ifdef NEED_IN_TEXCOORD6
    float2 texcoord6        [[attribute(SCNVertexSemanticTexcoord6)]];
#endif
#ifdef NEED_IN_TEXCOORD7
    float2 texcoord7        [[attribute(SCNVertexSemanticTexcoord7)]];
#endif
} scn_vertex_t; 
typedef struct {
    float4 fragmentPosition [[position]]; 
#ifdef USE_POINT_RENDERING
    float fragmentSize [[point_size]];
#endif
#ifdef USE_VERTEX_COLOR
    float4 vertexColor;
#endif
#ifdef USE_PER_VERTEX_LIGHTING
    float3 diffuse;
#ifdef USE_SPECULAR
    float3 specular;
#endif
#ifdef USE_CLEARCOAT
    float clearCoat;
#endif
#ifdef USE_CLEARCOATROUGHNESS
    float clearCoatRoughness;
#endif
#ifdef USE_CLEARCOATNORMAL
    float clearCoatNormal;
#endif
#endif
#if defined(USE_POSITION) && (USE_POSITION == 2)
    float3 position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)
    float3 normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    float3 tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    float3 bitangent;
#endif
#ifdef USE_DISPLACEMENT_MAP
    float2 displacementTexcoord;   
#endif
#ifdef USE_CLEARCOAT_MAP
    float2 clearCoatTexcoord;   
#endif
#ifdef USE_CLEARCOATROUGHNESS_MAP
    float2 clearCoatRoughnessTexcoord;   
#endif
#ifdef USE_CLEARCOATNORMAL_MAP
    float2 clearCoatNormalTexcoord;   
#endif
#if defined(USE_PBR_TRANSPARENCY) && defined(USE_TRANSPARENCY)
    float transparency;
#endif
#ifdef USE_NODE_OPACITY
    float nodeOpacity;
#endif
#ifdef USE_TEXCOORD
    __TexcoordDecl__
#endif
    
#ifdef USE_EXTRA_VARYINGS
    __ExtraVaryingsDecl__
#endif
    
#ifdef USE_MOTIONBLUR
    float3 mv_fragment;
    float3 mv_lastFragment;
#endif
#ifdef USE_OUTLINE
    float outlineHash [[ flat ]];
#endif
#ifdef USE_INSTANCING
    uint   instanceID [[ flat ]];
#endif
#ifndef USE_VERTEX_AMPLIFICATION 
#ifdef USE_LAYERED_RENDERING
    uint   sliceIndex [[render_target_array_index]];
#endif
#ifdef USE_MULTIPLE_VIEWPORTS_RENDERING
    uint   sliceIndex [[viewport_array_index]];
#endif
#endif
#if DEBUG_PIXEL
    float2 uv0;
#endif
} commonprofile_io;
#ifdef USE_SHADER_MODIFIERS
__ShaderModifiersDecl__
#endif
#import "C3D-Lighting.metal"
enum C3DColorMask {
    kC3DColorMaskRed    = 0x1 << 3,
    kC3DColorMaskGreen  = 0x1 << 2,
    kC3DColorMaskBlue   = 0x1 << 1,
    kC3DColorMaskAlpha  = 0x1 << 0
inline float4 colorFromMask(float4 col, int mask)
    switch (mask) {
        case kC3DColorMaskRed:                      return col.r;
        case kC3DColorMaskRed|kC3DColorMaskGreen:   return float4(col.rg, 0.f, 1.f);
        case kC3DColorMaskRed|kC3DColorMaskBlue:    return float4(col.rb, 0.f, 1.f);
        case kC3DColorMaskRed|kC3DColorMaskAlpha:   return float4(col.ra, 0.f, 1.f);
        case kC3DColorMaskGreen:                    return col.g;
        case kC3DColorMaskGreen|kC3DColorMaskBlue:  return float4(col.bg, 0.f, 1.f);
        case kC3DColorMaskGreen|kC3DColorMaskAlpha: return float4(col.ag, 0.f, 1.f);
        case kC3DColorMaskBlue:     return col.b;
        case kC3DColorMaskBlue|kC3DColorMaskAlpha:  return float4(col.ab, 0.f, 1.f);
        case kC3DColorMaskAlpha:    return col.a;
    }
    return col;
#ifndef USE_PBR
inline float3 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)
    float3 albedo = surface.diffuse.rgb * surface.ambientOcclusion;
    float3 color = lighting.diffuse * albedo;
#if defined(USE_AMBIENT_LIGHTING) && (defined(LOCK_AMBIENT_WITH_DIFFUSE) || defined(USE_AMBIENT_AS_AMBIENTOCCLUSION))
    color +=  lighting.ambient * albedo;
#endif
#ifdef USE_SELFILLUMINATION
    color += surface.diffuse.rgb * surface.selfIllumination.rgb;
#endif
    
    
    
#ifdef USE_SPECULAR
    float3 S = lighting.specular;
#elif defined(USE_REFLECTIVE)
    float3 S = float3(0.);
#endif
#ifdef USE_REFLECTIVE
    S += surface.reflective.rgb * surface.ambientOcclusion;
#endif
#ifdef USE_SPECULAR
    S *= surface.specular.rgb;
#endif
#if (defined(USE_SPECULAR) || defined(USE_REFLECTIVE)) && !defined(DISABLE_SPECULAR)
    color += S;
#endif
#if defined(USE_AMBIENT) && !defined(USE_AMBIENT_AS_AMBIENTOCCLUSION)
    color += surface.ambient.rgb * lighting.ambient;
#endif
#ifdef USE_EMISSION
    color += surface.emission.rgb;
#endif
#ifdef USE_MULTIPLY
    color *= surface.multiply.rgb;
#endif
#ifdef USE_MODULATE
    color *= lighting.modulate;
#endif
    return color;
#endif
struct SCNShaderGeometry
    float4 position;
    float3 normal;
    float4 tangent;
    float4 color;
    float pointSize;
    float2 texcoords[8]; 
#ifdef USE_CLIP_DISTANCE0
    float clipDistance0;
#endif
#ifdef USE_CLIP_DISTANCE1
    float clipDistance1;
#endif
#ifdef USE_CLIP_DISTANCE2
    float clipDistance2;
#endif
#ifdef USE_CLIP_DISTANCE3
    float clipDistance3;
#endif
struct commonprofile_uniforms {
    
    float4 diffuseColor;
    float4 specularColor;
    float4 ambientColor;
    float4 emissionColor;
    float4 selfIlluminationColor;
    float4 reflectiveColor;
    float4 multiplyColor;
    float4 transparentColor;
    float clearCoat;
    float clearCoatRoughness;
    float3 clearCoatNormal;
    float metalness;
    
    float roughness;
    float diffuseIntensity;
    float specularIntensity;
    float normalIntensity;
    float ambientIntensity;
    float emissionIntensity;
    float selfIlluminationIntensity;
    float reflectiveIntensity;
    float multiplyIntensity;
    float transparentIntensity;
    
    float metalnessIntensity;
    float roughnessIntensity;
    float clearCoatIntensity;
    float clearCoatRoughnessIntensity;
    float clearCoatNormalIntensity;
    float displacementIntensity;
    float materialShininess;
    float selfIlluminationOcclusion;
    float transparency;
    float3 fresnel; 
#if USE_ARGUMENT_BUFFERS
    
    texture2d<float>    emissionTexture;
    sampler             emissionSampler;
    texture2d<float>    ambientTexture;
    sampler             ambientSampler;
    
    texture2d<float>    diffuseTexture;
    sampler             diffuseSampler;
    texture2d<float>    specularTexture;
    sampler             specularSampler;
#if defined(USE_REFLECTIVE_CUBEMAP)
    texturecube<float>  reflectiveTexture;
#else
    texture2d<float>    reflectiveTexture;
#endif
    sampler             reflectiveSampler;
    texture2d<float>    transparentTexture;
    sampler             transparentSampler;
    texture2d<float>    multiplyTexture;
    sampler             multiplySampler;
    
    texture2d<float>    normalTexture;
    sampler             normalSampler;
    texture2d<float>    selfIlluminationTexture;
    sampler             selfIlluminationSampler;
    texture2d<float>    metalnessTexture;
    sampler             metalnessSampler;
    texture2d<float>    roughnessTexture;
    sampler             roughnessSampler;
    texture2d<float>    displacementTexture;
    sampler             displacementSampler;
    
    
#endif 
#ifdef TEXTURE_TRANSFORM_COUNT
    float4x4 textureTransforms[TEXTURE_TRANSFORM_COUNT];
#endif
#ifdef USE_OPENSUBDIV
__OpenSubdivDeclPerGeometry__
__OpenSubdivDeclPerPatchType__
__OpenSubdivDeclShared__
struct osd_packed_vertex {
    packed_float3 position;
#if defined(OSD_USER_VARYING_DECLARE_PACKED)
    OSD_USER_VARYING_DECLARE_PACKED
#endif
#endif
#ifdef USE_DISPLACEMENT_MAP
static void applyDisplacement(texture2d<float>                 displacementTexture,
                              sampler                          displacementTextureSampler,
                              float2                           displacementTexcoord,
                              thread SCNShaderGeometry&        geometry,
                              constant commonprofile_uniforms& scn_commonprofile)
#ifdef USE_DISPLACEMENT_TEXTURE_COMPONENT
float altitude = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;
#ifdef USE_DISPLACEMENT_INTENSITY
altitude *= scn_commonprofile.displacementIntensity;
#endif
#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)
float3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));
geometry.position.xyz += geometry.normal * altitude;
float3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);
float3 h;
h.x = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;
h.y = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;
h.z = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord-offset.zy), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;
#ifdef USE_DISPLACEMENT_INTENSITY
h *= scn_commonprofile.displacementIntensity;
#endif
float3 n = normalize( float3( (h.x - h.y)/offset.x, 1., (h.x - h.z)/offset.y) );
geometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;
geometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));
#endif 
#else 
float3 displacement = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;
#ifdef USE_DISPLACEMENT_INTENSITY
displacement *= scn_commonprofile.displacementIntensity;
#endif
#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)
float3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));
geometry.position.xyz += geometry.tangent.xyz * displacement.x + geometry.normal.xyz * displacement.y + bitangent.xyz * displacement.z;
float3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);
float3 a = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;
float3 b = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz).rgb;
float3 c = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.zy).rgb;
#ifdef USE_DISPLACEMENT_INTENSITY
a *= scn_commonprofile.displacementIntensity;
b *= scn_commonprofile.displacementIntensity;
c *= scn_commonprofile.displacementIntensity;
#endif
b += offset.xzz;
c -= offset.zzy;
float3 n = (normalize( cross( b-a, c-a ) ));
geometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;
geometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));
#endif 
#endif 
#endif 
#ifdef USE_OUTLINE
static inline float hash(float2 p)
    const float2 kMod2 = float2(443.8975f, 397.2973f);
    p  = fract(p * kMod2);
    p += dot(p.xy, p.yx+19.19f);
    return fract(p.x * p.y);
#endif
    
#if defined(USE_TESSELLATION)
struct scn_patch_t {
    patch_control_point<scn_vertex_t> controlPoints;
#endif
#if defined(USE_OPENSUBDIV)
#if OSD_IS_ADAPTIVE
[[ patch(quad, VERTEX_CONTROL_POINTS_PER_PATCH) ]]
#endif
#elif defined(USE_TESSELLATION)
[[ patch(triangle, 3) ]]
#endif
    
    
vertex commonprofile_io commonprofile_vert(
#if !defined(USE_TESSELLATION)
                                           scn_vertex_t                       in                               [[ stage_in ]]
                                           , uint                             scn_vertexID                     [[ vertex_id ]]
#else 
                                           
#ifdef USE_OPENSUBDIV
#if OSD_IS_ADAPTIVE
#if USE_STAGE_IN
                                           PatchInput                         patchInput                       [[ stage_in ]]
#else
                                           OsdVertexBufferSet                 patchInput
#endif
                                           , float2                           patchCoord                       [[ position_in_patch ]]
                                           , uint                             patchID                          [[ patch_id ]]
                                           , constant float&                  osdTessellationLevel             [[ buffer(TESSELLATION_LEVEL_BUFFER_INDEX) ]]
#else 
                                           constant unsigned*                 osdIndicesBuffer                 [[ buffer(INDICES_BUFFER_INDEX) ]]
                                           , constant osd_packed_vertex*      osdVertexBuffer                  [[ buffer(VERTEX_BUFFER_INDEX) ]]
                                           , uint                             vertexID                         [[ vertex_id ]]
#endif 
#if defined(OSD_FVAR_WIDTH)
#if OSD_FVAR_USES_MULTIPLE_CHANNELS
                                           , constant uint32_t&               osdFaceVaryingChannelCount       [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_COUNT_INDEX) ]]
                                           , constant OsdFVarChannelDesc*     osdFaceVaryingChannelDescriptors [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_DESCRIPTORS_INDEX) ]]
                                           , constant uint32_t&               osdFaceVaryingPatchArrayIndex    [[ buffer(OSD_FVAR_CHANNELS_PATCH_ARRAY_INDEX_BUFFER_INDEX) ]]
                                           , constant void*                   osdFaceVaryingChannelsPackedData [[ buffer(OSD_FVAR_CHANNELS_PACKED_DATA_BUFFER_INDEX) ]]
#else
                                           , constant float*                  osdFaceVaryingData               [[ buffer(OSD_FVAR_DATA_BUFFER_INDEX) ]]
                                           , constant int*                    osdFaceVaryingIndices            [[ buffer(OSD_FVAR_INDICES_BUFFER_INDEX) ]]
#if OSD_IS_ADAPTIVE
                                           , constant packed_int3*            osdFaceVaryingPatchParams        [[ buffer(OSD_FVAR_PATCHPARAM_BUFFER_INDEX) ]]
                                           , constant packed_int4&            osdFaceVaryingPatchArray         [[ buffer(OSD_FVAR_PATCH_ARRAY_BUFFER_INDEX) ]]
#endif
#endif 
#endif 
#else 
                                           scn_patch_t                        in                               [[ stage_in ]]
                                           , float3                           patchCoord                       [[ position_in_patch ]]
#endif 
#endif 
                                           
#ifdef USE_MULTIPLE_RENDERING
                                           , constant SCNSceneBuffer*         scn_frame_multi                  [[ buffer(0) ]]
#else
                                           , constant SCNSceneBuffer&         scn_frame                        [[ buffer(0) ]]
#endif
#if defined(USE_INSTANCING) || defined(USE_MULTIPLE_RENDERING)
                                           , constant commonprofile_node*     scn_nodes                        [[ buffer(1) ]]
#else
                                           , constant commonprofile_node&     scn_node                         [[ buffer(1) ]]
#endif
#ifdef USE_PER_VERTEX_LIGHTING
                                           , constant scn_light*              scn_lights                       [[ buffer(2) ]]
                                           , constant float4*                 u_shadowKernel
                                           , texture2d_array<float>           u_areaLightBakedDataTexture
#endif
                                           
                                           , constant commonprofile_uniforms& scn_commonprofile
#ifdef USE_INSTANCING
                                           , uint                             scn_instanceID                   [[ instance_id ]]
#endif
#ifdef USE_VERTEX_AMPLIFICATION
                                           , ushort                           amplificationID                  [[ amplification_id ]]
#endif
#ifdef USE_POINT_RENDERING
                                           
                                           , constant float3&                 scn_pointSize
#endif
#ifdef USE_DISPLACEMENT_MAP
#if USE_ARGUMENT_BUFFERS
#define u_displacementTexture           scn_commonprofile.displacementTexture
#define u_displacementTextureSampler    scn_commonprofile.displacementSampler
#else
                                           , texture2d<float>                 u_displacementTexture
                                           , sampler                          u_displacementTextureSampler
#endif 
#endif 
#ifdef USE_VERTEX_EXTRA_ARGUMENTS
                                           __VertexExtraArguments__
#endif
                                           )
    commonprofile_io out;
    
#ifdef USE_MULTIPLE_RENDERING
#ifdef USE_VERTEX_AMPLIFICATION
    constant SCNSceneBuffer& scn_frame = scn_frame_multi[amplificationID];
#else
    out.instanceID = scn_instanceID / USE_MULTIPLE_RENDERING;
    out.sliceIndex = scn_instanceID % USE_MULTIPLE_RENDERING;
    constant SCNSceneBuffer& scn_frame = scn_frame_multi[out.sliceIndex];
#endif
    
#ifdef USE_INSTANCING
#ifdef USE_VERTEX_AMPLIFICATION
    constant commonprofile_node& scn_node = scn_nodes[USE_MULTIPLE_RENDERING * scn_instanceID + amplificationID];
#else
    
    
    constant commonprofile_node& scn_node = scn_nodes[scn_instanceID];
#endif
#else
#ifdef USE_VERTEX_AMPLIFICATION
    constant commonprofile_node& scn_node = scn_nodes[amplificationID];
#else
    constant commonprofile_node& scn_node = scn_nodes[out.sliceIndex];
#endif
#endif
    
#else 
    
#ifdef USE_INSTANCING
    out.instanceID = scn_instanceID;
    constant commonprofile_node& scn_node = scn_nodes[scn_instanceID];
#endif
    
#endif 
    
    
#ifdef USE_TESSELLATION
    uint scn_vertexID; 
    scn_vertexID = 0;
#endif
    
    
    
    
    
    SCNShaderGeometry _geometry;
    
#if !defined(USE_TESSELLATION)
    
    
    _geometry.position = float4(in.position, 1.f);
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
    _geometry.normal = in.normal;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _geometry.tangent = in.tangent;
#endif
#ifdef NEED_IN_TEXCOORD0
    _geometry.texcoords[0] = in.texcoord0;
#endif
#ifdef NEED_IN_TEXCOORD1
    _geometry.texcoords[1] = in.texcoord1;
#endif
#ifdef NEED_IN_TEXCOORD2
    _geometry.texcoords[2] = in.texcoord2;
#endif
#ifdef NEED_IN_TEXCOORD3
    _geometry.texcoords[3] = in.texcoord3;
#endif
#ifdef NEED_IN_TEXCOORD4
    _geometry.texcoords[4] = in.texcoord4;
#endif
#ifdef NEED_IN_TEXCOORD5
    _geometry.texcoords[5] = in.texcoord5;
#endif
#ifdef NEED_IN_TEXCOORD6
    _geometry.texcoords[6] = in.texcoord6;
#endif
#ifdef NEED_IN_TEXCOORD7
    _geometry.texcoords[7] = in.texcoord7;
#endif
#ifdef HAS_VERTEX_COLOR
    _geometry.color = in.color;
#elif USE_VERTEX_COLOR
    _geometry.color = float4(1.);
#endif
    
#else 
    
#ifdef USE_OPENSUBDIV
#if OSD_IS_ADAPTIVE
#if USE_STAGE_IN
    int3 patchParam = patchInput.patchParam;
#else
    int3 patchParam = patchInput.patchParamBuffer[patchID];
#endif
    
    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);
    float tessellationLevel = min(osdTessellationLevel, (float)OSD_MAX_TESS_LEVEL) / exp2((float)refinementLevel - 1);
    
    OsdPatchVertex patchVertex = OsdComputePatch(tessellationLevel, patchCoord, patchID, patchInput);
    
#if defined(OSD_FVAR_WIDTH)
    int patchIndex = OsdGetPatchIndex(patchID);
#if OSD_FVAR_USES_MULTIPLE_CHANNELS
    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);
#else
    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingIndices, osdFaceVaryingData, osdFaceVaryingPatchParams, osdFaceVaryingPatchArray);
#endif
#endif
    
    _geometry.position = float4(patchVertex.position, 1.f);
    
#if defined(USE_NORMAL)
    _geometry.normal = patchVertex.normal;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _geometry.tangent = float4(patchVertex.tangent, -1.f);
    
#endif
#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[0] = patchVertex.texcoord0;
#endif
#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[1] = patchVertex.texcoord1;
#endif
#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[2] = patchVertex.texcoord2;
#endif
#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[3] = patchVertex.texcoord3;
#endif
#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[4] = patchVertex.texcoord4;
#endif
#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[5] = patchVertex.texcoord5;
#endif
#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[6] = patchVertex.texcoord6;
#endif
#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[7] = patchVertex.texcoord7;
#endif
#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.color = patchVertex.color;
#endif
    
#else 
    
#if OSD_PATCH_QUADS
    const uint primitiveIndex = vertexID / 6;
#ifdef USE_NORMAL
    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 0]].position;
    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 1]].position;
    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 2]].position;
    float3 normal = normalize(cross(p2 - p1, p0 - p1));
#endif
    const uint triangleIndices[6] = { 0, 1, 2, 0, 2, 3 };
    const uint quadVertexIndex = triangleIndices[vertexID % 6];
    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + quadVertexIndex]];
#elif OSD_PATCH_TRIANGLES
    const uint primitiveIndex = vertexID / 3;
#ifdef USE_NORMAL
    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 0]].position;
    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 1]].position;
    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 2]].position;
    float3 normal = normalize(cross(p2 - p1, p0 - p1));
#endif
    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[vertexID]];
#endif
    
    float3 position = osdVertex.position;
    
#if defined(OSD_FVAR_WIDTH)
    int patchIndex = OsdGetPatchIndex(primitiveIndex);
#if OSD_PATCH_QUADS
    float2 quadUVs[4] = { float2(0,0), float2(1,0), float2(1,1), float2(0,1) };
#if OSD_FVAR_USES_MULTIPLE_CHANNELS
    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);
#else
    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingIndices, osdFaceVaryingData);
#endif
#elif OSD_PATCH_TRIANGLES
    
#endif
#endif 
    
#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[0] = osdVertex.texcoord0;
#endif
#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[1] = osdVertex.texcoord1;
#endif
#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[2] = osdVertex.texcoord2;
#endif
#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[3] = osdVertex.texcoord3;
#endif
#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[4] = osdVertex.texcoord4;
#endif
#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[5] = osdVertex.texcoord5;
#endif
#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[6] = osdVertex.texcoord6;
#endif
#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[7] = osdVertex.texcoord7;
#endif
#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.color = osdVertex.color;
#endif
    
    _geometry.position = float4(position, 1.f);
#ifdef USE_NORMAL
    _geometry.normal = normal;
#endif
    
#endif 
    
#else 
    
    
    
    
    
#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE) || defined(TESSELLATION_SMOOTHING_MODE_PHONG)
    float3 P0 = in.controlPoints[0].position;
    float3 P1 = in.controlPoints[1].position;
    float3 P2 = in.controlPoints[2].position;
    float3 N0 = in.controlPoints[0].normal;
    float3 N1 = in.controlPoints[1].normal;
    float3 N2 = in.controlPoints[2].normal;
#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE)
    float3 position, normal;
    scn_smooth_geometry_pn_triangle(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);
#elif defined(TESSELLATION_SMOOTHING_MODE_PHONG)
    float3 position, normal;
    scn_smooth_geometry_phong(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);
#endif
    _geometry.position = float4(position, 1.f);
#ifdef USE_NORMAL
    _geometry.normal = normal;
#endif
#else 
    
    _geometry.position = float4(scn::barycentric_mix(in.controlPoints[0].position, in.controlPoints[1].position, in.controlPoints[2].position, patchCoord), 1.f);
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
    _geometry.normal = normalize(scn::barycentric_mix(in.controlPoints[0].normal, in.controlPoints[1].normal, in.controlPoints[2].normal, patchCoord));
#endif
#endif 
    
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _geometry.tangent = normalize(scn::barycentric_mix(in.controlPoints[0].tangent, in.controlPoints[1].tangent, in.controlPoints[2].tangent, patchCoord));
#endif
#ifdef NEED_IN_TEXCOORD0
    _geometry.texcoords[0] = scn::barycentric_mix(in.controlPoints[0].texcoord0, in.controlPoints[1].texcoord0, in.controlPoints[2].texcoord0, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD1
    _geometry.texcoords[1] = scn::barycentric_mix(in.controlPoints[0].texcoord1, in.controlPoints[1].texcoord1, in.controlPoints[2].texcoord1, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD2
    _geometry.texcoords[2] = scn::barycentric_mix(in.controlPoints[0].texcoord2, in.controlPoints[1].texcoord2, in.controlPoints[2].texcoord2, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD3
    _geometry.texcoords[3] = scn::barycentric_mix(in.controlPoints[0].texcoord3, in.controlPoints[1].texcoord3, in.controlPoints[2].texcoord3, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD4
    _geometry.texcoords[4] = scn::barycentric_mix(in.controlPoints[0].texcoord4, in.controlPoints[1].texcoord4, in.controlPoints[2].texcoord4, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD5
    _geometry.texcoords[5] = scn::barycentric_mix(in.controlPoints[0].texcoord5, in.controlPoints[1].texcoord5, in.controlPoints[2].texcoord5, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD6
    _geometry.texcoords[6] = scn::barycentric_mix(in.controlPoints[0].texcoord6, in.controlPoints[1].texcoord6, in.controlPoints[2].texcoord6, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD7
    _geometry.texcoords[7] = scn::barycentric_mix(in.controlPoints[0].texcoord7, in.controlPoints[1].texcoord7, in.controlPoints[2].texcoord7, patchCoord);
#endif
#ifdef HAS_VERTEX_COLOR
    _geometry.color = scn::barycentric_mix(in.controlPoints[0].color, in.controlPoints[1].color, in.controlPoints[2].color, patchCoord);
#elif USE_VERTEX_COLOR
    _geometry.color = float4(1.);
#endif
    
#endif 
    
#endif 
    
#ifdef USE_POINT_RENDERING
    _geometry.pointSize = scn_pointSize.x;
#endif
    
#ifdef USE_TEXCOORD
    __VertexDoVertexOnlyTexcoord__
#endif
    
#ifdef USE_DISPLACEMENT_MAP
    applyDisplacement(u_displacementTexture, u_displacementTextureSampler, _displacementTexcoord, _geometry, scn_commonprofile);
    out.displacementTexcoord = _displacementTexcoord;
#endif
    
    
    
    
    
#ifdef USE_GEOMETRY_MODIFIER
    
    __DoGeometryModifier__
    
#endif
    
#ifdef USE_CLIP_DISTANCE0
    out.clipDistance[0] = _geometry.clipDistance0;
#endif
#ifdef USE_CLIP_DISTANCE1
    out.clipDistance[1] = _geometry.clipDistance1;
#endif
#ifdef USE_CLIP_DISTANCE2
    out.clipDistance[2] = _geometry.clipDistance2;
#endif
#ifdef USE_CLIP_DISTANCE3
    out.clipDistance[3] = _geometry.clipDistance3;
#endif
    
    
    
    
    
    
#if defined(USE_POSITION) || (defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)) || defined(USE_TANGENT) || defined(USE_BITANGENT) || defined(USE_INSTANCING)
    SCNShaderSurface _surface;
#endif
#if defined(USE_POSITION) || defined(USE_INSTANCING)
    _surface.position = (scn_node.modelViewTransform * _geometry.position).xyz;
#endif
#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)
#ifdef HINT_UNIFORM_SCALE
    float3x3 nrmTransform = scn::mat3(scn_node.modelViewTransform);
    _surface.normal = nrmTransform * _geometry.normal;
#else
    float3x3 modelViewTransform = scn::mat3(scn_node.modelViewTransform);
    float3 invScaleSquared = 1.f / float3(length_squared(modelViewTransform[0]),
                                          length_squared(modelViewTransform[1]),
                                          length_squared(modelViewTransform[2]));
    _surface.normal = normalize(modelViewTransform * (_geometry.normal * invScaleSquared));
#endif
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _surface.tangent = normalize(scn::mat3(scn_node.modelViewTransform) * _geometry.tangent.xyz);
    _surface.bitangent = _geometry.tangent.w * cross(_surface.tangent, _surface.normal); 
    
#endif
    
    
#ifdef USE_VIEW
    _surface.view = normalize(-_surface.position);
#endif
    
    
    
    
    
#ifdef USE_PER_VERTEX_LIGHTING
    
    SCNShaderLightingContribution _lightingContribution(_surface, out);
    _lightingContribution.diffuse = 0.;
  #ifdef USE_SPECULAR
    _lightingContribution.specular = 0.;
    _surface.shininess = scn_commonprofile.materialShininess;
  #endif
    
    __VertexDoLighting__
    
    out.diffuse = _lightingContribution.diffuse;
  #ifdef USE_SPECULAR
    out.specular = _lightingContribution.specular;
  #endif
#endif
#if defined(USE_POSITION) && (USE_POSITION == 2)
    out.position = _surface.position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)
    out.normal = _surface.normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    out.tangent = _surface.tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    out.bitangent = _surface.bitangent;
#endif
#ifdef USE_VERTEX_COLOR
    out.vertexColor = _geometry.color;
#endif
    
#if DEBUG_PIXEL
    out.uv0 = in.texcoord0;
#endif
#ifdef USE_TEXCOORD
    __VertexDoTexcoord__
#endif
    
#ifdef IS_BEZIER_CURVE
    out.bezierCurveUV = in.texcoord0;
#endif
    
    
    
    
    
#if defined(USE_POSITION) || defined(USE_INSTANCING)
    out.fragmentPosition = scn_frame.projectionTransform * float4(_surface.position, 1.);
#elif defined(USE_MODELVIEWPROJECTIONTRANSFORM) 
    out.fragmentPosition = scn_node.modelViewProjectionTransform * _geometry.position;
#endif
    
#if defined(USE_PBR_TRANSPARENCY) && defined(USE_TRANSPARENCY)
    out.transparency = scn_commonprofile.transparency;
#endif
#ifdef USE_NODE_OPACITY
    out.nodeOpacity = scn_node.nodeOpacity;
#endif
    
#ifdef USE_POINT_RENDERING
    float screenSize = _geometry.pointSize / out.fragmentPosition.w;
    out.fragmentSize = clamp(screenSize, scn_pointSize.y, scn_pointSize.z);
#endif
    
#ifdef USE_MOTIONBLUR
    float4 lastFrameFragmentPosition = scn_frame.lastFrameViewProjectionTransform * scn_node.lastFrameModelTransform * _geometry.position;
    out.mv_fragment = out.fragmentPosition.xyw;
    out.mv_lastFragment = lastFrameFragmentPosition.xyw;
#endif
    
#ifdef USE_OUTLINE
out.outlineHash = hash(scn_node.modelTransform[3].xy)+1.f/255.f;
#endif
    
    return out;
struct SCNOutput
    float4 color [[ color(0) ]];
#ifdef USE_COLOR1_OUTPUT
    half4 color1 [[ color(1) ]];
#endif
#ifdef USE_NORMALS_OUTPUT
    half4 normals [[ color(2) ]];
#endif
#ifdef USE_MOTIONBLUR
    half4 motionblur [[ color(3) ]];
#endif
#ifdef USE_REFLECTANCE_ROUGHNESS_OUTPUT
    half4 reflectanceRoughnessOutput [[ color(4) ]];
#endif
#ifdef USE_RADIANCE_OUTPUT
    half4 radiance [[ color(5) ]];
#endif
    
#ifdef USE_MODIFIER_FRAMEBUFFER
struct SCNFramebuffer
    float4 color;
#endif
fragment SCNOutput commonprofile_frag(commonprofile_io                   in                          [[ stage_in  ]]
                                      , constant commonprofile_uniforms& scn_commonprofile           [[ buffer(0) ]]
#ifdef USE_MULTIPLE_RENDERING
                                      , constant SCNSceneBuffer*         scn_frame_multi             [[ buffer(1) ]]
#else
                                      , constant SCNSceneBuffer&         scn_frame                   [[ buffer(1) ]]
#endif
#if defined(USE_INSTANCING) || defined(USE_MULTIPLE_RENDERING)
                                      , constant commonprofile_node*     scn_nodes                   [[ buffer(2) ]]
#else
                                      , constant commonprofile_node&     scn_node                    [[ buffer(2) ]]
#endif
#ifdef USE_PER_PIXEL_LIGHTING
                                      , constant scn_light*              scn_lights                  [[ buffer(3) ]]
                                      , constant float4*                 u_shadowKernel
                                      , texture2d_array<float>           u_areaLightBakedDataTexture
#ifdef C3D_SUPPORT_CUBE_ARRAY
                                      , texturecube_array<half>          u_reflectionProbeTexture
#else
                                      , texture2d_array<half>            u_reflectionProbeTexture
#endif
                                      , texture3d<ushort>                u_clusterTexture
#ifdef C3D_USE_TEXTURE_FOR_LIGHT_INDICES
                                      , texture1d<ushort>                u_lightIndicesTexture
#else
                                      , constant C3DLightIndexType*      u_lightIndicesBuffer
#endif
#endif
#if defined(C3D_SUPPORTS_PROGRAMMABLE_BLENDING) && defined(USE_MODIFIER_FRAMEBUFFER_COLOR0)
                                      , float4                           framebufferColor0           [[ color(0) ]]
#endif
#if USE_ARGUMENT_BUFFERS
#define u_emissionTexture               scn_commonprofile.emissionTexture
#define u_emissionTextureSampler        scn_commonprofile.emissionSampler
#define u_ambientTexture                scn_commonprofile.ambientTexture
#define u_ambientTextureSampler         scn_commonprofile.ambientSampler
#define u_diffuseTexture                scn_commonprofile.diffuseTexture
#define u_diffuseTextureSampler         scn_commonprofile.diffuseSampler
#define u_specularTexture               scn_commonprofile.specularTexture
#define u_specularTextureSampler        scn_commonprofile.specularSampler
#define u_reflectiveTexture             scn_commonprofile.reflectiveTexture
#define u_reflectiveTextureSampler      scn_commonprofile.reflectiveSampler
#define u_transparentTexture            scn_commonprofile.transparentTexture
#define u_transparentTextureSampler     scn_commonprofile.transparentSampler
#define u_multiplyTexture               scn_commonprofile.multiplyTexture
#define u_multiplyTextureSampler        scn_commonprofile.multiplySampler
#define u_normalTexture                 scn_commonprofile.normalTexture
#define u_normalTextureSampler          scn_commonprofile.normalSampler
#define u_selfIlluminationTexture       scn_commonprofile.selfIlluminationTexture
#define u_selfIlluminationTextureSampler scn_commonprofile.selfIlluminationSampler
#define u_metalnessTexture              scn_commonprofile.metalnessTexture
#define u_metalnessTextureSampler       scn_commonprofile.metalnessSampler
#define u_roughnessTexture              scn_commonprofile.roughnessTexture
#define u_roughnessTextureSampler       scn_commonprofile.roughnessSampler
#else
#ifdef USE_EMISSION_MAP
                                      , texture2d<float>              u_emissionTexture
                                      , sampler                       u_emissionTextureSampler
#endif
#ifdef USE_AMBIENT_MAP
                                      , texture2d<float>              u_ambientTexture
                                      , sampler                       u_ambientTextureSampler
#endif
#ifdef USE_DIFFUSE_MAP
                                      , texture2d<float>              u_diffuseTexture
                                      , sampler                       u_diffuseTextureSampler
#endif
#ifdef USE_SPECULAR_MAP
                                      , texture2d<float>              u_specularTexture
                                      , sampler                       u_specularTextureSampler
#endif
#ifdef USE_REFLECTIVE_MAP
                                      , texture2d<float>              u_reflectiveTexture
                                      , sampler                       u_reflectiveTextureSampler
#elif defined(USE_REFLECTIVE_CUBEMAP)
                                      , texturecube<float>            u_reflectiveTexture
                                      , sampler                       u_reflectiveTextureSampler
#endif
#ifdef USE_TRANSPARENT_MAP
                                      , texture2d<float>              u_transparentTexture
                                      , sampler                       u_transparentTextureSampler
#endif
#ifdef USE_MULTIPLY_MAP
                                      , texture2d<float>              u_multiplyTexture
                                      , sampler                       u_multiplyTextureSampler
#endif
#ifdef USE_NORMAL_MAP
                                      , texture2d<float>              u_normalTexture
                                      , sampler                       u_normalTextureSampler
#endif
#ifdef USE_SELFILLUMINATION_MAP
                                      , texture2d<float>              u_selfIlluminationTexture
                                      , sampler                       u_selfIlluminationTextureSampler
#endif
#ifdef USE_DISPLACEMENT_MAP
                                      , texture2d<float>              u_displacementTexture
                                      , sampler                       u_displacementTextureSampler
#endif
#ifdef USE_PBR
#ifdef USE_METALNESS_MAP
                                      , texture2d<float>              u_metalnessTexture
                                      , sampler                       u_metalnessTextureSampler
#endif
#ifdef USE_ROUGHNESS_MAP
                                      , texture2d<float>              u_roughnessTexture
                                      , sampler                       u_roughnessTextureSampler
#endif
#ifdef USE_CLEARCOAT_MAP
                                      , texture2d<float>              u_clearCoatTexture
                                      , sampler                       u_clearCoatTextureSampler
#endif
#ifdef USE_CLEARCOATROUGHNESS_MAP
                                      , texture2d<float>              u_clearCoatRoughnessTexture
                                      , sampler                       u_clearCoatRoughnessTextureSampler
#endif
#ifdef USE_CLEARCOATNORMAL_MAP
                                      , texture2d<float>              u_clearCoatNormalTexture
                                      , sampler                       u_clearCoatNormalTextureSampler
#endif
#endif 
#endif 
#ifdef USE_PBR
                                      , texturecube<float>            u_radianceTexture
                                      , texture2d<float>              u_specularDFGDiffuseHammonTexture
#if !defined(USE_SELFILLUMINATION_MAP)
                                      , texturecube<float>            u_irradianceTexture
#endif
#endif 
#ifdef USE_SSAO
                                      , texture2d<float>              u_ssaoTexture
#endif
#ifdef USE_FRAGMENT_EXTRA_ARGUMENTS
                                      __FragmentExtraArguments__
#endif
#if defined(USE_DOUBLE_SIDED)
                                      , bool                          isFrontFacing                    [[front_facing]]
#endif
#ifdef USE_POINT_RENDERING
                                      , float2                        pointCoord                       [[point_coord]]
#endif
#ifdef USE_VERTEX_AMPLIFICATION
                                      , ushort                        amplificationID                  [[amplification_id]]
#endif
                                      )
#ifdef USE_MULTIPLE_RENDERING
    
#ifdef USE_VERTEX_AMPLIFICATION
    constant SCNSceneBuffer& scn_frame = scn_frame_multi[amplificationID];
#else
    constant SCNSceneBuffer& scn_frame = scn_frame_multi[in.sliceIndex];
#endif
    
#ifdef USE_INSTANCING
#ifdef USE_VERTEX_AMPLIFICATION
    constant commonprofile_node& scn_node = scn_nodes[USE_MULTIPLE_RENDERING * in.instanceID + amplificationID];
#else
    constant commonprofile_node& scn_node = scn_nodes[USE_MULTIPLE_RENDERING * in.instanceID + in.sliceIndex];
#endif
#else
#ifdef USE_VERTEX_AMPLIFICATION
    constant commonprofile_node& scn_node = scn_nodes[amplificationID];
#else
    constant commonprofile_node& scn_node = scn_nodes[in.sliceIndex];
#endif
#endif
    
#else 
    
#ifdef USE_INSTANCING
    constant commonprofile_node& scn_node = scn_nodes[in.instanceID];
#endif
    
#endif 
    
#ifdef IS_BEZIER_CURVE
    bool insideCurve = scn_is_inside_bezier_curve(in.bezierCurveUV, scn_bezier_curve_data, scn_bezier_curve_controlPoints);
    if (insideCurve == false) {
        discard_fragment();
    }
#endif
    
    SCNOutput _output;
    
    
    
    
    SCNShaderSurface _surface;
#ifdef USE_TEXCOORD
    __FragmentDoTexcoord__
#endif
    _surface.ambientOcclusion = 1.f; 
#ifdef USE_AMBIENT_MAP
    #ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
        #if defined(USE_AMBIENT_TEXTURE_COMPONENT)
            _surface.ambientOcclusion = colorFromMask(u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord), USE_AMBIENT_TEXTURE_COMPONENT).r;
        #else
            _surface.ambientOcclusion = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord).r;
        #endif
        #ifdef USE_AMBIENT_INTENSITY
            _surface.ambientOcclusion = saturate(mix(1.f, _surface.ambientOcclusion, scn_commonprofile.ambientIntensity));
        #endif
    #else 
        _surface.ambient = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord);
        #if defined(USE_AMBIENT_TEXTURE_COMPONENT)
            _surface.ambient = colorFromMask(_surface.ambient, USE_AMBIENT_TEXTURE_COMPONENT);
        #endif
        #ifdef USE_AMBIENT_INTENSITY
            _surface.ambient *= scn_commonprofile.ambientIntensity;
        #endif
    #endif 
#elif defined(USE_AMBIENT_COLOR)
    _surface.ambient = scn_commonprofile.ambientColor;
#elif defined(USE_AMBIENT)
    _surface.ambient = float4(0.);
#endif
#if defined(USE_AMBIENT) && defined(USE_VERTEX_COLOR)
    _surface.ambient *= in.vertexColor;
#endif
#if  defined(USE_SSAO)
    _surface.ambientOcclusion *= u_ssaoTexture.sample( sampler(filter::linear), in.fragmentPosition.xy * scn_frame.inverseResolution.xy ).x;
#endif
    
#ifdef USE_DIFFUSE_MAP
    _surface.diffuse = u_diffuseTexture.sample(u_diffuseTextureSampler, _surface.diffuseTexcoord);
#if defined(USE_DIFFUSE_TEXTURE_COMPONENT)
    _surface.diffuse = colorFromMask(_surface.diffuse, USE_DIFFUSE_TEXTURE_COMPONENT);
#endif
#ifdef USE_DIFFUSE_INTENSITY
    _surface.diffuse.rgb *= scn_commonprofile.diffuseIntensity;
#endif
#elif defined(USE_DIFFUSE_COLOR)
    _surface.diffuse = scn_commonprofile.diffuseColor;
#else
    _surface.diffuse = float4(0.f,0.f,0.f,1.f);
#endif
#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)
    _surface.diffuse.rgb    *= in.vertexColor.rgb;
    _surface.diffuse        *= in.vertexColor.a; 
#endif
#ifdef USE_SPECULAR_MAP
    _surface.specular = u_specularTexture.sample(u_specularTextureSampler, _surface.specularTexcoord);
#if defined(USE_SPECULAR_TEXTURE_COMPONENT)
    _surface.specular = colorFromMask(_surface.specular, USE_SPECULAR_TEXTURE_COMPONENT);
#endif
#ifdef USE_SPECULAR_INTENSITY
    _surface.specular *= scn_commonprofile.specularIntensity;
#endif
#elif defined(USE_SPECULAR_COLOR)
    _surface.specular = scn_commonprofile.specularColor;
#elif defined(USE_SPECULAR)
    _surface.specular = float4(0.f);
#endif
    
#ifdef USE_CLEARCOAT_MAP
    _surface.clearCoat = u_clearCoatTexture.sample(u_clearCoatTextureSampler, _surface.clearCoatTexcoord).r;
#if defined(USE_CLEARCOAT_TEXTURE_COMPONENT)
    _surface.clearCoat = colorFromMask(_surface.clearCoat, USE_CLEARCOAT_TEXTURE_COMPONENT).r;
#endif
#ifdef USE_CLEARCOAT_INTENSITY
    _surface.clearCoat *= scn_commonprofile.clearCoatIntensity;
#endif
#elif defined(USE_CLEARCOAT_COLOR)
    _surface.clearCoat = scn_commonprofile.clearCoat;
#elif defined(USE_CLEARCOAT)
    _surface.clearCoat = 0.f;
#endif
    
#ifdef USE_CLEARCOATROUGHNESS_MAP
#if defined(USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT)
    _surface.clearCoatRoughness = colorFromMask(u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord), USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT).r;
#else
    _surface.clearCoatRoughness = u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord).r;
#endif
#ifdef USE_CLEARCOATROUGHNESS_INTENSITY
    _surface.clearCoatRoughness *= scn_commonprofile.clearCoatRoughnessIntensity;
#endif
#elif defined(USE_CLEARCOATROUGHNESS_COLOR)
    _surface.clearCoatRoughness = scn_commonprofile.clearCoatRoughness;
#else
    _surface.clearCoatRoughness = 0.03f;
#endif
#ifdef USE_EMISSION_MAP
    _surface.emission = u_emissionTexture.sample(u_emissionTextureSampler, _surface.emissionTexcoord);
#if defined(USE_EMISSION_TEXTURE_COMPONENT)
    _surface.emission = colorFromMask(_surface.emission, USE_EMISSION_TEXTURE_COMPONENT);
#endif
#ifdef USE_EMISSION_INTENSITY
    _surface.emission *= scn_commonprofile.emissionIntensity;
#endif
#elif defined(USE_EMISSION_COLOR)
    _surface.emission = scn_commonprofile.emissionColor;
#elif defined(USE_EMISSION)
    _surface.emission = float4(0.);
#endif
#ifdef USE_SELFILLUMINATION_MAP
    _surface.selfIllumination = u_selfIlluminationTexture.sample(u_selfIlluminationTextureSampler, _surface.selfIlluminationTexcoord);
#if defined(USE_SELFILLUMINATION_TEXTURE_COMPONENT)
    _surface.selfIllumination = colorFromMask(_surface.selfIllumination, USE_SELFILLUMINATION_TEXTURE_COMPONENT);
#endif
#ifdef USE_SELFILLUMINATION_INTENSITY
    _surface.selfIllumination *= scn_commonprofile.selfIlluminationIntensity;
#endif
#elif defined(USE_SELFILLUMINATION_COLOR)
    _surface.selfIllumination = scn_commonprofile.selfIlluminationColor;
#elif defined(USE_SELFILLUMINATION)
    _surface.selfIllumination = float4(0.);
#endif
#ifdef USE_MULTIPLY_MAP
    _surface.multiply = u_multiplyTexture.sample(u_multiplyTextureSampler, _surface.multiplyTexcoord);
#if defined(USE_MULTIPLY_TEXTURE_COMPONENT)
    _surface.multiply = colorFromMask(_surface.multiply, USE_MULTIPLY_TEXTURE_COMPONENT);
#endif
#ifdef USE_MULTIPLY_INTENSITY
    _surface.multiply = mix(float4(1.), _surface.multiply, scn_commonprofile.multiplyIntensity);
#endif
#elif defined(USE_MULTIPLY_COLOR)
    _surface.multiply = scn_commonprofile.multiplyColor;
#elif defined(USE_MULTIPLY)
    _surface.multiply = float4(1.);
#endif
#ifdef USE_TRANSPARENT_MAP
    _surface.transparent = u_transparentTexture.sample(u_transparentTextureSampler, _surface.transparentTexcoord);
#if defined(USE_TRANSPARENT_TEXTURE_COMPONENT)
    _surface.transparent = colorFromMask(_surface.transparent, USE_TRANSPARENT_TEXTURE_COMPONENT);
#endif
#ifdef USE_TRANSPARENT_INTENSITY
    _surface.transparent *= scn_commonprofile.transparentIntensity;
#endif
#elif defined(USE_TRANSPARENT_COLOR)
    _surface.transparent = scn_commonprofile.transparentColor;
#elif defined(USE_TRANSPARENT)
    _surface.transparent = float4(1.f);
#endif
    
#ifdef USE_METALNESS_MAP
#if defined(USE_METALNESS_TEXTURE_COMPONENT)
    _surface.metalness = colorFromMask(u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord), USE_METALNESS_TEXTURE_COMPONENT).r;
#else
    _surface.metalness = u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord).r;
#endif
#ifdef USE_METALNESS_INTENSITY
    _surface.metalness *= scn_commonprofile.metalnessIntensity;
#endif
#elif defined(USE_METALNESS_COLOR)
    _surface.metalness = scn_commonprofile.metalness;
#else
    _surface.metalness = 0.f;
#endif
    
#ifdef USE_ROUGHNESS_MAP
#if defined(USE_ROUGHNESS_TEXTURE_COMPONENT)
    _surface.roughness = colorFromMask(u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord), USE_ROUGHNESS_TEXTURE_COMPONENT).r;
#else
    _surface.roughness = u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord).r;
#endif
#ifdef USE_ROUGHNESS_INTENSITY
    _surface.roughness *= scn_commonprofile.roughnessIntensity;
#endif
#elif defined(USE_ROUGHNESS_COLOR)
    _surface.roughness = scn_commonprofile.roughness;
#else
    _surface.roughness = 0.f;
#endif
#if (defined USE_POSITION) && (USE_POSITION == 2)
    _surface.position = in.position;
#endif
#if (defined USE_NORMAL) && (USE_NORMAL == 2)
#if defined(HAS_NORMAL) || defined(USE_OPENSUBDIV)
#ifdef USE_DOUBLE_SIDED
    _surface.geometryNormal = normalize(in.normal.xyz) * (isFrontFacing ? 1.f : -1.f );
#else
    _surface.geometryNormal = normalize(in.normal.xyz);
#endif
#else 
    _surface.geometryNormal = normalize( cross(dfdy( _surface.position ), dfdx( _surface.position ) ));
#endif
    _surface.normal = _surface.geometryNormal;
    _surface.clearCoatNormal = _surface.geometryNormal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    _surface.tangent = in.tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    _surface.bitangent = in.bitangent;
#endif
#if (defined USE_VIEW) && (USE_VIEW == 2)
    _surface.view = normalize(-in.position);
    {
        
        
        float NoV = dot(_surface.geometryNormal, _surface.view);
        _surface.view = _surface.view + max(0.f, -2.f * NoV) * _surface.geometryNormal;         
        
    }
#endif
#if defined(USE_NORMAL_MAP)
    {
        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.normal);
#ifdef USE_NORMAL_MAP
#if defined(USE_NORMAL_TEXTURE_COMPONENT)
        _surface._normalTS.xy = colorFromMask(u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord), USE_NORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;
        _surface._normalTS.z = sqrt(1.f - saturate(length_squared(_surface._normalTS.xy)));
#else
        _surface._normalTS = u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord).rgb;
        _surface._normalTS = _surface._normalTS * 2.f - 1.f;
#endif
#ifdef USE_NORMAL_INTENSITY
        _surface._normalTS = mix(float3(0.f, 0.f, 1.f), _surface._normalTS, scn_commonprofile.normalIntensity);
#endif
#else
        _surface._normalTS = float3(0.f, 0.f, 1.f);
#endif
        _surface.normal.rgb = normalize(ts2vs * _surface._normalTS.xyz );
    }
#else
    _surface._normalTS = float3(0.f, 0.f, 1.f);
#endif
#ifdef USE_PBR
    {
        float roughness = clamp(_surface.roughness, PBR_MIN_ROUGHNESS, 1.0);
        float alpha = scn_filteredAlphaFromRoughness(_surface.normal, roughness);
        _surface.roughness = sqrt(alpha);
    }
#endif
#if defined(USE_CLEARCOATNORMAL_MAP)
    {
        
        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.geometryNormal);
#ifdef USE_CLEARCOATNORMAL_MAP
#if defined(USE_CLEARCOATNORMAL_TEXTURE_COMPONENT)
        _surface._clearCoatNormalTS.xy = colorFromMask(u_clearCoatNormalTexture.sample(u_clearCoatnormalTextureSampler, _surface.clearCoatNormalTexcoord), USE_CLEARCOATNORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;
        _surface._clearCoatNormalTS.z = sqrt(1.f - saturate(length_squared(_surface._clearCoatNormalTS.xy)));
#else
        _surface._clearCoatNormalTS = u_clearCoatNormalTexture.sample(u_clearCoatNormalTextureSampler, _surface.clearCoatNormalTexcoord).rgb;
        _surface._clearCoatNormalTS = _surface._clearCoatNormalTS * 2.f - 1.f;
#endif
#ifdef USE_CLEARCOATNORMAL_INTENSITY
        _surface._clearCoatNormalTS = mix(float3(0.f, 0.f, 1.f), _surface._clearCoatNormalTS, scn_commonprofile.clearCoatNormalIntensity);
#endif
#else
        _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);
#endif
        _surface.clearCoatNormal.rgb = normalize(ts2vs * _surface._clearCoatNormalTS.xyz );
    }
#else
    _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);
#endif
    
#ifdef USE_REFLECTIVE_MAP
    float3 refl = reflect( -_surface.view, _surface.normal );
    float m = 2.f * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.f)*(refl.z+1.f));
    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, float2(float2(refl.x,-refl.y) / m) + 0.5f);
#if defined(USE_REFLECTIVE_TEXTURE_COMPONENT)
    _surface.reflective = colorFromMask(_surface.reflective, USE_REFLECTIVE_TEXTURE_COMPONENT).r;
#endif
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective *= scn_commonprofile.reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_CUBEMAP)
    float3 refl = reflect( _surface.position, _surface.normal );
    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, scn::mat4_mult_float3(scn_frame.viewToCubeTransform, refl)); 
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective *= scn_commonprofile.reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_COLOR)
    _surface.reflective = scn_commonprofile.reflectiveColor;
#elif defined(USE_REFLECTIVE)
    _surface.reflective = float4(0.);
#endif
#ifdef USE_FRESNEL
    _surface.fresnel = scn_commonprofile.fresnel.x + scn_commonprofile.fresnel.y * pow(1.f - saturate(dot(_surface.view, _surface.normal)), scn_commonprofile.fresnel.z);
    _surface.reflective *= _surface.fresnel;
#endif
#ifdef USE_SHININESS
    _surface.shininess = scn_commonprofile.materialShininess;
#endif
    
    
    
    
    
#ifdef USE_SURFACE_MODIFIER
    
    __DoSurfaceModifier__
    
#endif
    
    
    
    
    
    SCNShaderLightingContribution _lightingContribution(_surface, in);
#ifdef USE_LIGHT_MODIFIER
    __LightModifierCopyDecl__
#endif
#ifdef USE_AMBIENT_LIGHTING
    _lightingContribution.ambient = scn_frame.ambientLightingColor.rgb;
#endif
#ifdef USE_LIGHTING
#ifdef USE_PER_PIXEL_LIGHTING
#ifdef USE_CLUSTERED_LIGHTING
    uint3 clusterIndex;
    clusterIndex.xy = uint2(in.fragmentPosition.xy * scn_frame.clusterScale.xy); 
    clusterIndex.z = in.position.z * scn_frame.clusterScale.z + scn_frame.clusterScale.w; 
    
    
    ushort4 cluster_offset_count = u_clusterTexture.read(clusterIndex);
    int lid = cluster_offset_count.x;
#endif
#ifdef USE_PBR
    _lightingContribution.prepareForPBR(u_specularDFGDiffuseHammonTexture, scn_commonprofile.selfIlluminationOcclusion);
    
    
#ifdef USE_SELFILLUMINATION
    _lightingContribution.add_irradiance_from_selfIllum();
#else
#ifdef USE_PROBES_LIGHTING 
    _lightingContribution.add_global_irradiance_from_sh(scn_frame.viewToCubeTransform, scn_node.shCoefficients);
#else
    _lightingContribution.add_global_irradiance_probe(u_irradianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);
#endif
#endif
    
#ifndef DISABLE_SPECULAR
#ifdef C3D_USE_REFLECTION_PROBES
    int probe_count = (cluster_offset_count.z & 0xff);
    for (int i = 0 ; i < probe_count; ++i, ++lid) {
        _lightingContribution.add_local_probe(scn_lights[LightIndex(lid)], u_reflectionProbeTexture);
    }
#if PROBES_NORMALIZATION
#if PROBES_OUTER_BLENDING
    _lightingContribution.specular += _lightingContribution.probesWeightedSum.rgb / max(1.f, _lightingContribution.probesWeightedSum.a);
#else
    _lightingContribution.specular += _lightingContribution.probesWeightedSum.rgb / _lightingContribution.probesWeightedSum.a;
#endif
    float globalFactor = saturate(1.f - _lightingContribution.probesWeightedSum.a);
#else
    float globalFactor = _lightingContribution.probeRadianceRemainingFactor;
#endif
    _lightingContribution.add_global_probe(scn_frame.viewToCubeTransform, globalFactor * scn_frame.environmentIntensity,
                                           u_reflectionProbeTexture);
#else 
   _lightingContribution.add_global_probe(u_radianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);
    
#ifdef USE_CLEARCOAT
    _lightingContribution.add_global_probeClearCoat(u_radianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);
#endif
    
#endif 
#endif 
#endif 
    #if DEBUG_PIXEL
        switch (DEBUG_PIXEL) {
            case 1: _output.color = float4(_surface.normal * 0.5f + 0.5f, 1.f); break;
            case 2: _output.color = float4(_surface.geometryNormal * 0.5f + 0.5f, 1.f); break;
            case 3: _output.color = float4(_surface.tangent * 0.5f + 0.5f, 1.f); break;
            case 4: _output.color = float4(in.uv0, 0.f, 1.f); break;
            case 5: _output.color = float4(_surface.diffuse.rgb, 1.f); break;
            case 6: _output.color = float4(float3(_surface.roughness), 1.f); break;
            case 7: _output.color = float4(float3(_surface.metalness), 1.f); break;
            case 8: _output.color = float4(float3(_surface.ambientOcclusion), 1.f); break;
            default: break;
        }
        return _output;
    #endif
    
    __FragmentDoLighting__
    
    #ifdef USE_CLUSTERED_LIGHTING
        
        int omni_count = cluster_offset_count.y & 0xff;
        for (int i = 0 ; i < omni_count; ++i, ++lid) {
            _lightingContribution.add_local_omni(scn_lights[LightIndex(lid)]);
        }
        
        int spot_count = (cluster_offset_count.y >> 8);
        for (int i = 0 ; i < spot_count; ++i, ++lid) {
            _lightingContribution.add_local_spot(scn_lights[LightIndex(lid)]);
        }
    #endif
#else 
        _lightingContribution.diffuse = in.diffuse;
    #ifdef USE_SPECULAR
        _lightingContribution.specular = in.specular;
    #endif
#endif 
    #ifdef AVOID_OVERLIGHTING
        _lightingContribution.diffuse = saturate(_lightingContribution.diffuse);
    #ifdef USE_SPECULAR
        _lightingContribution.specular = saturate(_lightingContribution.specular);
    #endif 
    #endif 
#else 
    _lightingContribution.diffuse = float3(1.);
#endif 
    
    
    
    
#ifdef USE_PBR
    { 
        float3 diffuseAlbedo = mix(_lightingContribution.pbr.albedo, float3(0.0), _surface.metalness);
        
        
#ifdef USE_PBR_TRANSPARENCY
        float3 color = (_lightingContribution.ambient * _surface.ambientOcclusion) * _lightingContribution.pbr.albedo;
#else
        float3 color = (_lightingContribution.ambient * _surface.ambientOcclusion) * _surface.diffuse.rgb;
#endif
        
        color += _lightingContribution.pbr.envDiffuse;
        color += _lightingContribution.diffuse * diffuseAlbedo;
#ifndef DISABLE_SPECULAR
        color += _lightingContribution.pbr.envSpecular;
        color += _lightingContribution.specular;
#endif
#ifdef USE_EMISSION
        color += _surface.emission.rgb;
#endif
#ifdef USE_MULTIPLY
        color *= _surface.multiply.rgb;
#endif
#ifdef USE_MODULATE
        color *= _lightingContribution.modulate;
#endif
        _output.color.rgb = color;
    }
#else 
#ifdef USE_SHADOWONLY
    _output.color.rgb = float3(0.0);
    _output.color.a = 1. - _lightingContribution.shadowFactor;
#else
    _output.color.rgb = illuminate(_surface, _lightingContribution);
#endif
#endif
#ifndef USE_SHADOWONLY
  #ifdef USE_PBR_TRANSPARENCY
    _output.color.a = _lightingContribution.pbr.transparency;
  #else
    _output.color.a = _surface.diffuse.a;
  #endif
#endif
#ifdef USE_FOG
    float fogFactor = pow(clamp(length(_surface.position.xyz) * scn_frame.fogParameters.x + scn_frame.fogParameters.y, 0., scn_frame.fogColor.a), scn_frame.fogParameters.z);
    _output.color.rgb = mix(_output.color.rgb, scn_frame.fogColor.rgb * _output.color.a, fogFactor);
#endif
#if !defined(DIFFUSE_PREMULTIPLIED) && !defined(USE_PBR_TRANSPARENCY)
    _output.color.rgb *= _surface.diffuse.a;
#endif
    
    
    
    
    
#ifdef USE_SHADOWONLY
    float transparencyFactor = 1.0;
  #ifdef USE_NODE_OPACITY
    transparencyFactor *= in.nodeOpacity;
  #endif
    _output.color.a *= transparencyFactor; 
#else 
#ifdef USE_TRANSPARENT 
    
#ifdef USE_TRANSPARENCY
    _surface.transparent *= scn_commonprofile.transparency;
#endif
    
#ifdef USE_TRANSPARENCY_RGBZERO
    
    _surface.transparent.a = (_surface.transparent.r * 0.212671f) + (_surface.transparent.g * 0.715160f) + (_surface.transparent.b * 0.072169f);
    _output.color *= (float4(1.f) - _surface.transparent);
#else
  #ifndef USE_PBR_TRANSPARENCY
    _output.color *= _surface.transparent.a;
  #endif
#endif
    
#else 
    
#ifdef USE_TRANSPARENCY 
  #ifndef USE_PBR_TRANSPARENCY
    _output.color *= scn_commonprofile.transparency;
  #endif
#endif
    
#endif 
    
#ifdef USE_NODE_OPACITY
    _output.color *= in.nodeOpacity;
#endif
    
#endif 
    
    
    
    
    
#ifdef USE_MODIFIER_FRAMEBUFFER
    const SCNFramebuffer _framebuffer = {
#if defined(C3D_SUPPORTS_PROGRAMMABLE_BLENDING) && defined(USE_MODIFIER_FRAMEBUFFER_COLOR0)
        .color = framebufferColor0
#else
        .color = 0.f
#endif
    };
#endif
    
#ifdef USE_FRAGMENT_MODIFIER
    
    __DoFragmentModifier__
    
#endif
#if defined(USE_CLUSTERED_LIGHTING) && defined(DEBUG_CLUSTER_TILE)
    _output.color.rgb = mix(_output.color.rgb, float3(scn::debugColorForCount(clusterIndex.z).xyz), 0.1f);
    _output.color.rgb = mix(_output.color.rgb, float3(clusterIndex.x & 0x1 ^ clusterIndex.y & 0x1).xyz, 0.01f);
#endif
#ifdef DISABLE_LINEAR_RENDERING
    _output.color.rgb = scn::linear_to_srgb(_output.color.rgb);
#endif
    
#ifdef USE_DISCARD
    if (_output.color.a == 0.) 
        discard_fragment();
#endif
#ifdef USE_POINT_RENDERING
    if ((dfdx(pointCoord.x) < 0.5f) && (length_squared(pointCoord * 2.f - 1.f) > 1.f)) {
        discard_fragment();
    }
#endif
    
    
#ifdef USE_OUTLINE
    _output.color.rgb = in.outlineHash;
#endif
    
#ifdef USE_MOTIONBLUR
#ifdef USE_MULTIPLE_RENDERING
    _output.motionblur.xy = half2((in.mv_fragment.xy - scn_frame.viewportSize.zw) / in.mv_fragment.z - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * scn_frame.motionBlurIntensity;
#else
    _output.motionblur.xy = half2((in.mv_fragment.xy / in.mv_fragment.z) - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * scn_frame.motionBlurIntensity;
#endif
    _output.motionblur.z = length(_output.motionblur.xy);
    _output.motionblur.w = half(-_surface.position.z);
#endif
#ifdef USE_NORMALS_OUTPUT
    _output.normals = half4( half3(_surface.normal.xyz), half(_surface.roughness) );
#endif
    
#ifdef USE_RADIANCE_OUTPUT
    _output.radiance.rgb = half3(_lightingContribution.specular.rgb);
#endif
                                 
#ifdef USE_REFLECTANCE_ROUGHNESS_OUTPUT
#ifdef USE_PBR
    _output.reflectanceRoughnessOutput = half4( half3(_lightingContribution.pbr.probeReflectance), half(_surface.roughness) );
#else 
    _output.reflectanceRoughnessOutput = half4( 0.h );
#endif
#endif
    
    return _output;
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
#import "scn_standard_lighting.h"
#import "scn_standard_constants.h"
#import "C3D-PBR.metal"
enum C3DLightingModel
    C3DLightingModelConstant,
    C3DLightingModelLambert,
    C3DLightingModelPhong,
    C3DLightingModelBlinn,
    C3DLightingModelNone,
    C3DLightingModelPhysicallyBased,
constant bool use_per_vertex_diffuse    = use_per_vertex_lighting;
constant bool use_per_vertex_specular   = use_per_vertex_lighting && use_specular;
constant bool use_per_pixel_lighting    = !use_per_vertex_lighting; 
constant bool lighting_model_is_pbr     = (lighting_model == C3DLightingModelPhysicallyBased);
constant bool use_pbr                   = is_function_constant_defined(lighting_model) && lighting_model_is_pbr;
constant bool use_io_texcoord0          = io_texcoord_count > 0;
constant bool use_io_texcoord1          = io_texcoord_count > 1;
constant bool use_io_texcoord2          = io_texcoord_count > 2;
constant bool use_io_texcoord3          = io_texcoord_count > 3;
constant bool use_io_texcoord4          = io_texcoord_count > 4;
constant bool use_io_texcoord5          = io_texcoord_count > 5;
constant bool use_io_texcoord6          = io_texcoord_count > 6;
constant bool use_io_texcoord7          = io_texcoord_count > 7;
constant bool use_no_instancing             = !use_instancing;
constant bool dummy_shadow0             = LIGHT_HAS_SHADOW(use_light0);
constant bool use_shadow0               = is_function_constant_defined(use_light0) && dummy_shadow0;
constant bool dummy_shadow1             = LIGHT_HAS_SHADOW(use_light1);
constant bool use_shadow1               = is_function_constant_defined(use_light1) && dummy_shadow1;
constant bool dummy_shadow2             = LIGHT_HAS_SHADOW(use_light2);
constant bool use_shadow2               = is_function_constant_defined(use_light2) && dummy_shadow2;
constant bool dummy_shadow3             = LIGHT_HAS_SHADOW(use_light3);
constant bool use_shadow3               = is_function_constant_defined(use_light3) && dummy_shadow3;
constant bool dummy_gobo0               = LIGHT_HAS_GOBO(use_light0);
constant bool use_gobo0                 = is_function_constant_defined(use_light0) && dummy_gobo0;
constant bool dummy_gobo1               = LIGHT_HAS_GOBO(use_light1);
constant bool use_gobo1                 = is_function_constant_defined(use_light1) && dummy_gobo1;
constant bool dummy_gobo2               = LIGHT_HAS_GOBO(use_light2);
constant bool use_gobo2                 = is_function_constant_defined(use_light2) && dummy_gobo2;
constant bool dummy_gobo3               = LIGHT_HAS_GOBO(use_light3);
constant bool use_gobo3                 = is_function_constant_defined(use_light3) && dummy_gobo3;
constant bool dummy_ies0                = LIGHT_TYPE(use_light0) == kC3DLightTypeIES;
constant bool dummy_iesType2d0          = (LIGHT_IES_TYPE(use_light0) != kC3DLightIESTypeCubemap);
constant bool dummy_iesTypeCube0        = (LIGHT_IES_TYPE(use_light0) == kC3DLightIESTypeCubemap);
constant bool dummy_ies2d0              = dummy_ies0 && dummy_iesType2d0;
constant bool dummy_iesCube0            = dummy_ies0 && dummy_iesTypeCube0;
constant bool use_ies0                  = is_function_constant_defined(use_light0) && dummy_ies2d0;
constant bool use_iesCube0              = is_function_constant_defined(use_light0) && dummy_iesCube0;
constant bool dummy_ies1                = LIGHT_TYPE(use_light1) == kC3DLightTypeIES;
constant bool dummy_iesType2d1          = (LIGHT_IES_TYPE(use_light1) != kC3DLightIESTypeCubemap);
constant bool dummy_iesTypeCube1        = (LIGHT_IES_TYPE(use_light1) == kC3DLightIESTypeCubemap);
constant bool dummy_ies2d1              = dummy_ies1 && dummy_iesType2d1;
constant bool dummy_iesCube1            = dummy_ies1 && dummy_iesTypeCube1;
constant bool use_ies1                  = is_function_constant_defined(use_light1) && dummy_ies2d1;
constant bool use_iesCube1              = is_function_constant_defined(use_light1) && dummy_iesCube1;
constant bool dummy_ies2                = LIGHT_TYPE(use_light2) == kC3DLightTypeIES;
constant bool dummy_iesType2d2          = (LIGHT_IES_TYPE(use_light2) != kC3DLightIESTypeCubemap);
constant bool dummy_iesTypeCube2        = (LIGHT_IES_TYPE(use_light2) == kC3DLightIESTypeCubemap);
constant bool dummy_ies2d2              = dummy_ies2 && dummy_iesType2d2;
constant bool dummy_iesCube2            = dummy_ies2 && dummy_iesTypeCube2;
constant bool use_ies2                  = is_function_constant_defined(use_light2) && dummy_ies2d2;
constant bool use_iesCube2              = is_function_constant_defined(use_light2) && dummy_iesCube2;
constant bool dummy_ies3                = LIGHT_TYPE(use_light3) == kC3DLightTypeIES;
constant bool dummy_iesType2d3          = (LIGHT_IES_TYPE(use_light3) != kC3DLightIESTypeCubemap);
constant bool dummy_iesTypeCube3        = (LIGHT_IES_TYPE(use_light3) == kC3DLightIESTypeCubemap);
constant bool dummy_ies2d3              = dummy_ies3 && dummy_iesType2d3;
constant bool dummy_iesCube3            = dummy_ies3 && dummy_iesTypeCube3;
constant bool use_ies3                  = is_function_constant_defined(use_light3) && dummy_ies2d3;
constant bool use_iesCube3              = is_function_constant_defined(use_light3) && dummy_iesCube3;
constexpr sampler linearSampler(filter::linear, mip_filter::linear);
constexpr sampler shadowSampler(filter::linear, mip_filter::none, compare_func::greater_equal);
#define MAX_LIGHT_COUNT 8
typedef struct {
    
    float4x4 modelViewTransform;            
    
    float4x4 normalTransform;               
    
    float4x4 modelTransform;            
    uint8_t lightIndices[MAX_LIGHT_COUNT];  
    float nodeOpacity;                      
    
} scn_std_node;
typedef struct {
    float3 position         [[ attribute(SCNVertexSemanticPosition)]];
    float3 normal           [[ attribute(SCNVertexSemanticNormal),      function_constant(need_normal) ]];
    float4 tangent          [[ attribute(SCNVertexSemanticTangent),     function_constant(need_tangent) ]];
    float4 color            [[ attribute(SCNVertexSemanticColor)        function_constant(need_vertex_color) ]];
    float2 texcoord0        [[ attribute(SCNVertexSemanticTexcoord0),   function_constant(need_texcoord0) ]];
    float2 texcoord1        [[ attribute(SCNVertexSemanticTexcoord1),   function_constant(need_texcoord1) ]];
    float2 texcoord2        [[ attribute(SCNVertexSemanticTexcoord2),   function_constant(need_texcoord2) ]];
    float2 texcoord3        [[ attribute(SCNVertexSemanticTexcoord3),   function_constant(need_texcoord3) ]];
    float2 texcoord4        [[ attribute(SCNVertexSemanticTexcoord4),   function_constant(need_texcoord4) ]];
    float2 texcoord5        [[ attribute(SCNVertexSemanticTexcoord5),   function_constant(need_texcoord5) ]];
    float2 texcoord6        [[ attribute(SCNVertexSemanticTexcoord6),   function_constant(need_texcoord6) ]];
    float2 texcoord7        [[ attribute(SCNVertexSemanticTexcoord7),   function_constant(need_texcoord7) ]];
} scn_vertex_t; 
typedef struct {
    float4 fragmentPosition [[position]]; 
    
    float fragmentSize  [[ point_size, function_constant(use_point_rendering) ]];
    float4 vertexColor  [[ function_constant(use_io_vertex_color) ]];
    float3 position     [[ function_constant(use_io_position) ]];
    float3 normal       [[ function_constant(use_io_normal) ]];
    float3 tangent      [[ function_constant(need_tangent) ]];
    float3 bitangent    [[ function_constant(need_tangent) ]];
    
    float2 texcoord0    [[ function_constant(use_io_texcoord0) ]];
    float2 texcoord1    [[ function_constant(use_io_texcoord1) ]];
    float2 texcoord2    [[ function_constant(use_io_texcoord2) ]];
    float2 texcoord3    [[ function_constant(use_io_texcoord3) ]];
    float2 texcoord4    [[ function_constant(use_io_texcoord4) ]];
    float2 texcoord5    [[ function_constant(use_io_texcoord5) ]];
    float2 texcoord6    [[ function_constant(use_io_texcoord6) ]];
    float2 texcoord7    [[ function_constant(use_io_texcoord7) ]];
    float3 diffuse      [[ function_constant(use_per_vertex_diffuse) ]];
    float3 specular     [[ function_constant(use_per_vertex_specular) ]];
    
#ifdef USE_EXTRA_VARYINGS
    __ExtraVaryingsDecl__
#endif
    
} commonprofile_io;
struct SCNShaderSurface {
    float3 view;                
    float3 position;            
    float3 normal;              
    float3 geometryNormal;      
    float2 normalTexcoord;      
    float3 tangent;             
    float3 bitangent;           
    float4 ambient;             
    float2 ambientTexcoord;     
    float4 diffuse;             
    float2 diffuseTexcoord;     
    float4 specular;            
    float2 specularTexcoord;    
    float4 emission;            
    float2 emissionTexcoord;    
    float4 multiply;            
    float2 multiplyTexcoord;    
    float4 transparent;         
    float2 transparentTexcoord; 
    float4 reflective;          
    float  metalness;           
    float2 metalnessTexcoord;   
    float  roughness;           
    float2 roughnessTexcoord;   
    float shininess;            
    float fresnel;              
    float ambientOcclusion;     
    float3 _normalTS;           
    
#ifdef USE_SURFACE_EXTRA_DECL
    __SurfaceExtraDecl__
#endif
struct SCNShaderGeometry
    float4 position;
    float3 normal;
    float4 tangent;
    float4 color;
    float2 texcoords[8]; 
struct commonprofile_uniforms {
    float4 diffuseColor;
    float4 specularColor;
    float4 ambientColor;
    float4 emissionColor;
    float4 reflectiveColor;
    float4 multiplyColor;
    float4 transparentColor;
    float metalness;
    float roughness;
    
    float diffuseIntensity;
    float specularIntensity;
    float normalIntensity;
    float ambientIntensity;
    float emissionIntensity;
    float reflectiveIntensity;
    float multiplyIntensity;
    float transparentIntensity;
    float metalnessIntensity;
    float roughnessIntensity;
    float displacementIntensity;
    
    float materialShininess;
    float selfIlluminationOcclusion;
    float transparency;
    float3 fresnel; 
    
    
    float4x4 textureTransforms[1];
#ifdef USE_SHADER_MODIFIERS
__ShaderModifiersDecl__
#endif
struct SCNShaderLightingContribution {
    float3 ambient;
    float3 diffuse;
    float3 specular;
    float3 modulate;
struct SCNLightingParameters {
    
    SCNLightData        lightData;
    uint                lightInfo;
    float3              lightDirection;
    float3              attenuation;
    SCNShaderSurface    surface;
static float3 scn_lighting_direction(SCNLightData lightData, uint lightInfo, thread SCNShaderSurface& surface)
    uint lightType = LIGHT_TYPE(lightInfo);
    if (lightType == kC3DLightTypeDirectional) {
        return lightData.direction;
    }
    return normalize(lightData.position - surface.position);
    
static void scn_lambert_lighting(SCNLightingParameters params, thread SCNShaderLightingContribution& lightingContribution)
    SCNLightData lightData      = params.lightData;
    SCNShaderSurface surface    = params.surface;
    float3 l                    = params.lightDirection;
    
    float3 intensity = lightData.color.rgb * max(0.f, dot(surface.normal, l));
    lightingContribution.diffuse += intensity;
static void scn_blinn_lighting(SCNLightingParameters params, thread SCNShaderLightingContribution& lightingContribution)
    SCNLightData lightData      = params.lightData;
    SCNShaderSurface surface    = params.surface;
    float3 l                    = params.lightDirection;
    float3 intensity =  lightData.color.rgb * max(0.f, dot(surface.normal, l));
    lightingContribution.diffuse += intensity;
    float3 h = normalize(l + surface.view);
    lightingContribution.specular += powr(max(0.f, dot(surface.normal, h)), surface.shininess) * intensity;
static void scn_phong_lighting(SCNLightingParameters params, thread SCNShaderLightingContribution& lightingContribution)
    SCNLightData lightData      = params.lightData;
    SCNShaderSurface surface    = params.surface;
    float3 l                    = params.lightDirection;
    
    float3 intensity = lightData.color.rgb * max(0.f, dot(surface.normal, l));
    lightingContribution.diffuse += intensity;
    
    float3 r = reflect(-l, surface.normal);
    lightingContribution.specular += pow(max(0.f, dot(r, surface.view)), surface.shininess) * intensity;
inline void scn_pbr_lightingContribution_pointLight(float3         l,
                                                    float3         n,
                                                    float3         v,
                                                    float3         albedo,
                                                    float          metalness,
                                                    float          roughness,
                                                    thread float3& lightingContributionDiffuse,
                                                    thread float3& lightingContributionSpecular)
    float3 h = normalize(l + v);
    
    float NoL = saturate(dot(n, l));
    float NoH = saturate(dot(n, h));
    float LoH = saturate(dot(l, h));
    
    float  effectiveAlbedo = (1.f - metalness); 
    float3 reflectance = mix(float3(PBR_F0_NON_METALLIC), albedo, metalness);
    
    float alpha = roughness * roughness; 
    
    float D   = scn_brdf_D(alpha, NoH);
    float3 F  = scn_brdf_F_opt(reflectance, LoH);
#if 0 
    float Vis = scn_brdf_V_opt(alpha, LoH);
#else
    float NoV = saturate(dot(n, v));
    float Vis = scn_brdf_V(alpha, NoL, NoV);
#endif
    
    lightingContributionDiffuse = NoL * effectiveAlbedo * M_1_PI_F;
    lightingContributionSpecular = NoL * D * F * Vis;
static void scn_pbr_lighting(SCNLightingParameters params, thread SCNShaderLightingContribution& lightingContribution)
    SCNLightData lightData      = params.lightData;
    SCNShaderSurface surface    = params.surface;
    float3 l                    = params.lightDirection;
    
    float3 diffuseOut, specularOut;
    scn_pbr_lightingContribution_pointLight(l, surface.normal.xyz, surface.view, surface.diffuse.rgb, surface.metalness, surface.roughness, diffuseOut, specularOut);
    
    lightingContribution.diffuse    += diffuseOut  * lightData.pbrColor.rgb;
    lightingContribution.specular   += specularOut * lightData.pbrColor.rgb;
static float scn_distance_attenuation(SCNLightingParameters params)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    float3 l = params.surface.position - lightData.position;
    if (use_pbr) {
        uint lightType = LIGHT_TYPE(lightInfo);
        if (lightType == kC3DLightTypeDirectional) { 
            return 1.f;
        }
        return scn_pbr_distanceAttenuation(l);
    } else {
        uint distAttType = LIGHT_DIST_ATT(lightInfo);
        if (distAttType != kC3DLightAttenuationTypeNone) {
            
            float3 att = lightData.distanceAttenuation;
            float dist = length(l);
            switch (distAttType) {
                case kC3DLightAttenuationTypeConstant:
                    return step(dist, att.x);
                case kC3DLightAttenuationTypeLinear:
                    return saturate(dist * att.x + att.y);
                case kC3DLightAttenuationTypeQuadratic:
                    return scn::sq(saturate(dist * att.x + att.y));
                case kC3DLightAttenuationTypeExponent:
                    return pow(saturate(dist * att.x + att.y), att.z);
            }
        }
    }
    return 1.f;
static float scn_spot_attenuation(SCNLightingParameters params)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    float3 l                = params.lightDirection;
    
    uint spotAttType = LIGHT_SPOT_ATT(lightInfo);
    if (spotAttType != kC3DLightAttenuationTypeNone) {
        
        float3 spotFactors = lightData.spotAttenuation;
        switch (spotAttType) {
            case kC3DLightAttenuationTypeConstant:
                return step(spotFactors.x, dot(l, lightData.direction));
            case kC3DLightAttenuationTypeLinear:
                return saturate(dot(l, lightData.direction) * spotFactors.x + spotFactors.y);
            case kC3DLightAttenuationTypeQuadratic:
                return scn::sq(saturate(dot(l, lightData.direction) * spotFactors.x + spotFactors.y));
            case kC3DLightAttenuationTypeExponent:
                return pow(saturate(dot(l, lightData.direction) * spotFactors.x + spotFactors.y), spotFactors.z);
        }
    }
    return 1.f;
static void scn_do_gobo(thread SCNLightingParameters& params, texture2d<float> goboMap)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    float goboIntensity = lightData.color.a; 
    float3 goboColor = texture2DProj(goboMap, linearSampler, (lightData.shadowMatrix * float4(params.surface.position, 1.f))).rgb;
    if (LIGHT_IS_MODULATE(lightInfo)) {
        params.attenuation *= mix(float3(1.), goboColor, goboIntensity);
    } else {
        params.attenuation *= goboColor * goboIntensity;
    }
static void scn_do_ies(thread SCNLightingParameters& params, texture2d<float> iesMap, sampler iesSampler)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    
    params.lightDirection   = scn_lighting_direction(params.lightData, lightInfo, params.surface);
    float3 spotFactors      = lightData.spotAttenuation;
    float att = 0.f;
    switch (LIGHT_IES_TYPE(lightInfo)) {
        case kC3DLightIESType1D:
            att = iesMap.sample(iesSampler, float2(acos(dot(params.lightDirection, lightData.direction))*spotFactors.x, 0.f)).r;
            break;
            
        case kC3DLightIESType2D:
        {
            
            float vertAngle     = acos(dot(params.lightDirection, lightData.direction));
            
            float3 surfaceRay   = params.surface.position - lightData.position;
            float3 projPos = normalize(surfaceRay - dot(surfaceRay, lightData.direction) * lightData.direction);
            float2 texCoord = float2(dot(projPos, lightData.right), dot(projPos, lightData.up)) * vertAngle * spotFactors.x;
            att = iesMap.sample(iesSampler, texCoord * 0.5f + 0.5f).r;
            
        } break;
    }
    params.attenuation.rgb *= att;
static void scn_do_ies(thread SCNLightingParameters& params, texturecube<float> iesMap, sampler iesSampler)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    
    params.lightDirection   = scn_lighting_direction(params.lightData, lightInfo, params.surface);
    if (LIGHT_IES_TYPE(lightInfo) == kC3DLightIESTypeCubemap) {
        float att = iesMap.sample(iesSampler, (lightData.shadowMatrix * float4(params.surface.position, 1.f)).xyz).r;
        params.attenuation.rgb *= att;
    } 
static void scn_do_shadow(thread SCNLightingParameters& params, depth2d<float> shadowMap, constant float4* u_shadowKernel)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    
    uchar sampleCount = LIGHT_SHADOW_SAMPLE(lightInfo);
    
    float4 lightScreen = lightData.shadowMatrix * float4(params.surface.position, 1.f);
    
    float shadowRadius = lightData.shadowRadius;
    
    float shadowingTerm = 0.f;
    if (sampleCount > 1) { 
        float filteringSizeFactor = shadowRadius * lightScreen.w;
        for (int i = 0; i < sampleCount; i++) {
            
            shadowingTerm += shadow2DProj(shadowSampler, shadowMap, lightScreen + (u_shadowKernel[i] * filteringSizeFactor));
        }
        shadowingTerm /= float(sampleCount);
    } else {
        shadowingTerm = shadow2DProj(shadowSampler, shadowMap, lightScreen);
    }
    
    
    
    params.attenuation *= (1.f - shadowingTerm * lightData.color.a);
static void scn_do_light(SCNLightingParameters params, thread SCNShaderLightingContribution& lightingContrib)
    uint lightInfo          = params.lightInfo;
    
    params.lightDirection   = scn_lighting_direction(params.lightData, lightInfo, params.surface);
    
    
    
    float attenuation = scn_distance_attenuation(params);
    
    
    uint lightType = LIGHT_TYPE(lightInfo);
    if (lightType == kC3DLightTypeSpot) {
        attenuation *= scn_spot_attenuation(params);
    }
    params.attenuation *= attenuation;
    
    params.lightData.color.rgb *= params.attenuation;
    params.lightData.pbrColor.rgb *= params.attenuation;
    switch (lighting_model) {
        case C3DLightingModelLambert:
            scn_lambert_lighting(params, lightingContrib);
            break;
        case C3DLightingModelBlinn:
            scn_blinn_lighting(params, lightingContrib);
            break;
        case C3DLightingModelPhong:
            scn_phong_lighting(params, lightingContrib);
            break;
        case C3DLightingModelPhysicallyBased:
            scn_pbr_lighting(params, lightingContrib);
            break;
        default:
            
            break;
            
            
    }
inline SCNPBRSurface SCNShaderSurfaceToSCNPBRSurface(SCNShaderSurface surface)
    SCNPBRSurface s;
    
    s.n = surface.normal;
    s.v = surface.view;
    s.albedo = surface.diffuse.xyz;
    
    if (use_emission)
        s.emission = surface.emission.xyz;
    else
        s.emission = float3(0.);
    
    s.metalness = surface.metalness;
    s.roughness = surface.roughness;
    s.ao = surface.ambientOcclusion;
    return s;
static float4 scn_pbr_combine_cubemap(SCNPBRSurface                      surface,
                                     SCNShaderLightingContribution      lighting,
                                     texture2d<float, access::sample>   specularDFG,
                                     texturecube<float, access::sample> specularLD,
                                     texturecube<float, access::sample> irradianceTexture,
                                     constant SCNSceneBuffer&           scn_frame)
    
    float4x4 localDirToWorldCubemapDir = scn_frame.viewToCubeTransform;
    float environmentIntensity = scn_frame.environmentIntensity;
    
    float3 n = surface.n;
    float3 v = surface.v;
    float3 albedo = surface.albedo;
    float metalness = surface.metalness;
    float roughness = surface.roughness;
    float ambientOcclusion = surface.ao;
    
    float3 r = reflect(-v, n); 
    float NoV = saturate(dot(n, v));
    
    float3 diffuseDominantNDirection = n;
    float3 specularDominantNDirection = r;
    
    
    diffuseDominantNDirection = scn::mat4_mult_float3(localDirToWorldCubemapDir, diffuseDominantNDirection);
    
    float3 irradiance;
    if (use_emission_as_selfIllumination) {
        irradiance = surface.emission;
    } else {
        
        irradiance = irradianceTexture.sample(linearSampler, diffuseDominantNDirection).rgb * environmentIntensity;
    }
    
    
    float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);
    
    float3 LD = specularLD.sample(linearSampler, scn::mat4_mult_float3(localDirToWorldCubemapDir, specularDominantNDirection), level(mipLevel)).rgb * environmentIntensity;
    float2 DFG = specularDFG.sample(linearSampler, float2(NoV, roughness)).rg;
    
    float3 effectiveAlbedo = mix(albedo, float3(0.0), metalness);
    float3 reflectance = mix(float3(PBR_F0_NON_METALLIC), albedo, metalness);
    
    float3 diffuse = effectiveAlbedo * irradiance;
    float3 specular = LD * (reflectance * DFG.r + DFG.g);
    
    
    float3 ibl_color;
    if (use_emission_as_selfIllumination) { 
        
        float selfIlluminationAmbientOcclusion = saturate(mix(1., ambientOcclusion, surface.selfIlluminationOcclusion));
        ibl_color = selfIlluminationAmbientOcclusion * diffuse + ambientOcclusion * specular;
    } else {
        ibl_color = ambientOcclusion * (diffuse + specular);
    }
    
    float4 color;
    color.rgb = (lighting.ambient * surface.ao + lighting.diffuse) * surface.albedo.rgb + lighting.specular + ibl_color;
    
    if (use_emission && !use_emission_as_selfIllumination)
        color.rgb += surface.emission.rgb;
    
    return color;
static float4 scn_pbr_combine_probes(SCNPBRSurface                      surface,
                              SCNShaderLightingContribution      lighting,
                              texture2d<float, access::sample>   specularDFG,
                              texturecube<float, access::sample> specularLD,
                              sh3_coefficients                   shCoefficients,
                              constant SCNSceneBuffer&           scn_frame)
    
    float4x4 localDirToWorldCubemapDir = scn_frame.viewToCubeTransform;
    float environmentIntensity = scn_frame.environmentIntensity;
    
    float3 n = surface.n;
    float3 v = surface.v;
    float3 albedo = surface.albedo;
    float metalness = surface.metalness;
    float roughness = surface.roughness;
    float ambientOcclusion = surface.ao;
    
    float3 r = reflect(-v, n); 
    float NoV = saturate(dot(n, v));
    
    float3 diffuseDominantNDirection = n;
    float3 specularDominantNDirection = r;
    
    
    diffuseDominantNDirection = scn::mat4_mult_float3(localDirToWorldCubemapDir, diffuseDominantNDirection);
    
    float3 irradiance;
    if (use_emission_as_selfIllumination) {
        irradiance = surface.emission;
    } else {
        irradiance = shEvalDirection(float4(diffuseDominantNDirection, 1.), shCoefficients) * environmentIntensity;
    }
    
    
    float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);
    
    float3 LD = specularLD.sample(linearSampler, scn::mat4_mult_float3(localDirToWorldCubemapDir, specularDominantNDirection), level(mipLevel)).rgb * environmentIntensity;
    float2 DFG = specularDFG.sample(linearSampler, float2(NoV, roughness)).rg;
    
    float3 effectiveAlbedo = mix(albedo, float3(0.0), metalness);
    float3 reflectance = mix(float3(PBR_F0_NON_METALLIC), albedo, metalness);
    
    float3 diffuse = effectiveAlbedo * irradiance;
    float3 specular = LD * (reflectance * DFG.r + DFG.g);
    
    
    float3 ibl_color;
    if (use_emission_as_selfIllumination) { 
        
        float selfIlluminationAmbientOcclusion = saturate(mix(1., ambientOcclusion, surface.selfIlluminationOcclusion));
        ibl_color = selfIlluminationAmbientOcclusion * diffuse + ambientOcclusion * specular;
    } else {
        ibl_color = ambientOcclusion * (diffuse + specular);
    }
    
    float4 color;
    color.rgb = (lighting.ambient * surface.ao + lighting.diffuse) * surface.albedo.rgb + lighting.specular + ibl_color;
    
    if (use_emission && !use_emission_as_selfIllumination)
        color.rgb += surface.emission.rgb;
    
    return color;
inline float4 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)
    float4 color = {0.,0.,0., surface.diffuse.a};
    
    float3 D = lighting.diffuse;
    if (use_ambient_lighting)
        D += lighting.ambient * surface.ambientOcclusion;
    if (use_emission_as_selfIllumination)
        D += surface.emission.rgb;
    
    color.rgb = surface.diffuse.rgb * D;
    if (use_specular || use_reflective) {
        float3 S = (use_specular) ? lighting.specular : float3(0.);
        if (use_reflective)
            S += surface.reflective.rgb * surface.ambientOcclusion;
        if (use_specular)
            S *= surface.specular.rgb;
        color.rgb += S;
    }
    
    if (use_ambient && !use_ambient_as_ambientOcclusion)
        color.rgb += surface.ambient.rgb * lighting.ambient;
    if (use_emission && !use_emission_as_selfIllumination)
        color.rgb += surface.emission.rgb;
    if (use_multiply)
        color.rgb *= surface.multiply.rgb;
    if (use_modulate_lighting)
        color.rgb *= lighting.modulate;
    return color;
struct scn_patch_t {
    patch_control_point<scn_vertex_t> controlPoints;
static void standard_initalize_surface(thread SCNShaderSurface&  surface,
                                       thread SCNShaderGeometry& geometry,
                                       thread scn_std_node&      in_node)
    
    surface.position = (in_node.modelViewTransform * geometry.position).xyz;
    
    if (use_io_normal)
        surface.normal = normalize(scn::mat3(in_node.normalTransform) * geometry.normal);
    
    if (need_tangent) {
        surface.tangent = normalize(scn::mat3(in_node.normalTransform) * geometry.tangent.xyz);
        
        surface.bitangent = geometry.tangent.w * cross(surface.tangent, surface.normal);
    }
    if (use_io_view)
        surface.view = normalize(-surface.position);
static void standard_initalize_geometry(thread scn_vertex_t&      in,
                                        thread SCNShaderGeometry& geometry)
    geometry.position = float4(in.position, 1.f);
    
    if (need_normal)
        geometry.normal = in.normal;
    
    if (need_tangent)
        geometry.tangent = in.tangent;
    
    if (need_texcoord0)
        geometry.texcoords[0] = in.texcoord0;
    if (need_texcoord1)
        geometry.texcoords[1] = in.texcoord1;
    if (need_texcoord2)
        geometry.texcoords[2] = in.texcoord2;
    if (need_texcoord3)
        geometry.texcoords[3] = in.texcoord3;
    if (need_texcoord4)
        geometry.texcoords[4] = in.texcoord4;
    if (need_texcoord5)
        geometry.texcoords[5] = in.texcoord5;
    if (need_texcoord6)
        geometry.texcoords[6] = in.texcoord6;
    if (need_texcoord7)
        geometry.texcoords[7] = in.texcoord7;
    
    geometry.color = (need_vertex_color) ? in.color : float4(1.f);
static void standard_initalize_geometry_post_tessellation(thread scn_patch_t&       in,
                                                          thread SCNShaderGeometry& geometry,
                                                          float3                    patchCoord)
    geometry.position = float4(scn::barycentric_mix(in.controlPoints[0].position, in.controlPoints[1].position, in.controlPoints[2].position, patchCoord), 1.0);
    
    if (need_normal)
        geometry.normal = normalize(scn::barycentric_mix(in.controlPoints[0].normal, in.controlPoints[1].normal, in.controlPoints[2].normal, patchCoord));
    
    if (need_tangent)
        geometry.tangent = normalize(scn::barycentric_mix(in.controlPoints[0].tangent, in.controlPoints[1].tangent, in.controlPoints[2].tangent, patchCoord));
    
    if (need_texcoord0)
        geometry.texcoords[0] = scn::barycentric_mix(in.controlPoints[0].texcoord0, in.controlPoints[1].texcoord0, in.controlPoints[2].texcoord0, patchCoord);
    if (need_texcoord1)
        geometry.texcoords[1] = scn::barycentric_mix(in.controlPoints[0].texcoord1, in.controlPoints[1].texcoord1, in.controlPoints[2].texcoord1, patchCoord);
    if (need_texcoord2)
        geometry.texcoords[2] = scn::barycentric_mix(in.controlPoints[0].texcoord2, in.controlPoints[1].texcoord2, in.controlPoints[2].texcoord2, patchCoord);
    if (need_texcoord3)
        geometry.texcoords[3] = scn::barycentric_mix(in.controlPoints[0].texcoord3, in.controlPoints[1].texcoord3, in.controlPoints[2].texcoord3, patchCoord);
    if (need_texcoord4)
        geometry.texcoords[4] = scn::barycentric_mix(in.controlPoints[0].texcoord4, in.controlPoints[1].texcoord4, in.controlPoints[2].texcoord4, patchCoord);
    if (need_texcoord5)
        geometry.texcoords[5] = scn::barycentric_mix(in.controlPoints[0].texcoord5, in.controlPoints[1].texcoord5, in.controlPoints[2].texcoord5, patchCoord);
    if (need_texcoord6)
        geometry.texcoords[6] = scn::barycentric_mix(in.controlPoints[0].texcoord6, in.controlPoints[1].texcoord6, in.controlPoints[2].texcoord6, patchCoord);
    if (need_texcoord7)
        geometry.texcoords[7] = scn::barycentric_mix(in.controlPoints[0].texcoord7, in.controlPoints[1].texcoord7, in.controlPoints[2].texcoord7, patchCoord);
    
    geometry.color = (need_vertex_color) ? scn::barycentric_mix(in.controlPoints[0].color, in.controlPoints[1].color, in.controlPoints[2].color, patchCoord) : float4(1.f);
static void standard_configure_out(constant commonprofile_uniforms& commonprofile,
                                   thread SCNShaderSurface&         surface,
                                   thread SCNShaderGeometry&        geometry,
                                   thread commonprofile_io&         out)
    if (use_io_position)
        out.position = surface.position;
    
    if (use_io_normal)
        out.normal = surface.normal;
    
    if (need_tangent) {
        out.tangent = surface.tangent;
        out.bitangent = surface.bitangent;
    }
    
    if (use_io_vertex_color)
        out.vertexColor = geometry.color;
    
    float2 uvOut[kSCNTexcoordCount];
    
    if (is_function_constant_defined(diffuse_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ diffuse_channel ];
        if (is_function_constant_defined(diffuse_transform_index))
            uv = (commonprofile.textureTransforms[diffuse_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ diffuse_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(normal_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ normal_channel ];
        if (is_function_constant_defined(normal_transform_index))
            uv = (commonprofile.textureTransforms[normal_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ normal_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(transparent_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ transparent_channel ];
        if (is_function_constant_defined(transparent_transform_index))
            uv = (commonprofile.textureTransforms[transparent_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ transparent_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(emission_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ emission_channel ];
        if (is_function_constant_defined(emission_transform_index))
            uv = (commonprofile.textureTransforms[emission_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ emission_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(ambient_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ ambient_channel ];
        if (is_function_constant_defined(ambient_transform_index))
            uv = (commonprofile.textureTransforms[ambient_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ ambient_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(multiply_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ multiply_channel ];
        if (is_function_constant_defined(multiply_transform_index))
            uv = (commonprofile.textureTransforms[multiply_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ multiply_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(specular_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ specular_channel ];
        if (is_function_constant_defined(specular_transform_index))
            uv = (commonprofile.textureTransforms[specular_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ specular_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(roughness_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ roughness_channel ];
        if (is_function_constant_defined(roughness_transform_index))
            uv = (commonprofile.textureTransforms[roughness_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ roughness_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(metalness_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ metalness_channel ];
        if (is_function_constant_defined(metalness_transform_index))
            uv = (commonprofile.textureTransforms[metalness_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ metalness_texcoord_io_index ] = uv;
    }
    
    switch (io_texcoord_count - 1) {
        case 7 : out.texcoord7 = uvOut[7];
        case 6 : out.texcoord6 = uvOut[6];
        case 5 : out.texcoord5 = uvOut[5];
        case 4 : out.texcoord4 = uvOut[4];
        case 3 : out.texcoord3 = uvOut[3];
        case 2 : out.texcoord2 = uvOut[2];
        case 1 : out.texcoord1 = uvOut[1];
        case 0 : out.texcoord0 = uvOut[0];
    }
vertex commonprofile_io standard_vert(scn_vertex_t                      in                        [[ stage_in ]],
                                      constant SCNSceneBuffer&          scn_frame                 [[ buffer(0) ]],
                                      constant scn_std_node&            scn_node                  [[ buffer(1), function_constant(use_no_instancing) ]],
                                      
                                      device scn_std_node*              scn_nodes                 [[ buffer(1), function_constant(use_instancing) ]],
                                      device SCNLightData*              scn_lights                [[ buffer(2), function_constant(use_per_vertex_lighting) ]],
                                      constant commonprofile_uniforms&  scn_commonprofile         [[ buffer(3) ]],
                                      uint                              instanceID                [[ instance_id, function_constant(use_instancing) ]]
                                      
#ifdef USE_VERTEX_EXTRA_ARGUMENTS
                                      __VertexExtraArguments__
#endif
                                      )
    scn_std_node in_node;
    if (use_instancing) {
        in_node = scn_nodes[instanceID];
    } else {
        in_node = scn_node;
    }
    SCNShaderGeometry _geometry;
    standard_initalize_geometry(in, _geometry);
    
#ifdef USE_GEOMETRY_MODIFIER
__DoGeometryModifier__
#endif
    
    
    SCNShaderSurface _surface;
    standard_initalize_surface(_surface, _geometry, in_node);
    commonprofile_io out;
    
    
    if (use_per_vertex_lighting) {
        SCNShaderLightingContribution _lightingContribution;
        _lightingContribution.diffuse = 0.;
        _lightingContribution.specular = 0.;
        _surface.shininess = scn_commonprofile.materialShininess;
        
        
        out.diffuse = _lightingContribution.diffuse;
        if (use_specular)
            out.specular = _lightingContribution.specular;
    }
    standard_configure_out(scn_commonprofile, _surface, _geometry, out);
    
    
    
    out.fragmentPosition = scn_frame.projectionTransform * float4(_surface.position, 1.f);
    
    if (use_point_rendering) 
        out.fragmentSize = 1.f;
    return out;
[[ patch(triangle, 3) ]]
vertex commonprofile_io standard_post_tessellation_vert(scn_patch_t                       in                        [[ stage_in ]],
                                                        float3                            patchCoord                [[ position_in_patch ]],
                                                        constant SCNSceneBuffer&          scn_frame                 [[ buffer(0) ]],
                                                        constant scn_std_node&            scn_node                  [[ buffer(1), function_constant(use_no_instancing) ]],
                                                        
                                                        device scn_std_node*              scn_nodes                 [[ buffer(1), function_constant(use_instancing) ]],
                                                        device SCNLightData*              scn_lights                [[ buffer(2), function_constant(use_per_vertex_lighting) ]],
                                                        constant commonprofile_uniforms&  scn_commonprofile         [[ buffer(3) ]],
                                                        
                                                        uint                              instanceID                [[ instance_id, function_constant(use_instancing) ]]
                                                        
#ifdef USE_VERTEX_EXTRA_ARGUMENTS
                                      __VertexExtraArgumentsPostTessellation__
#endif
                                      )
    scn_std_node in_node;
    if (use_instancing) {
        in_node = scn_nodes[instanceID];
    } else {
        in_node = scn_node;
    }
    
    SCNShaderGeometry _geometry;
    standard_initalize_geometry_post_tessellation(in, _geometry, patchCoord);
    
#ifdef USE_GEOMETRY_MODIFIER
    
    __DoGeometryModifierPostTessellation__
    
#endif
    
    
    SCNShaderSurface _surface;
    standard_initalize_surface(_surface, _geometry, in_node);
    
    commonprofile_io out;
    
    
    if (use_per_vertex_lighting) {
        SCNShaderLightingContribution _lightingContribution;
        _lightingContribution.diffuse = 0.;
        _lightingContribution.specular = 0.;
        _surface.shininess = scn_commonprofile.materialShininess;
        
        
        
        
        out.diffuse = _lightingContribution.diffuse;
        if (use_specular)
            out.specular = _lightingContribution.specular;
    }
    
    standard_configure_out(scn_commonprofile, _surface, _geometry, out);
    
    
    
    
    out.fragmentPosition = scn_frame.projectionTransform * float4(_surface.position, 1.f);
    
    if (use_point_rendering) 
        out.fragmentSize = 1.f;
    return out;
struct SCNOutput
    float4 color;
fragment half4 standard_frag(commonprofile_io in [[stage_in]],
                             constant commonprofile_uniforms& scn_commonprofile [[buffer(0)]],
                             constant SCNSceneBuffer& scn_frame [[buffer(1)]]
                             
                             , device SCNLightData* scn_lights                     [[ buffer(2),  function_constant(use_per_pixel_lighting) ]]
                             , constant scn_std_node& scn_node                     [[ buffer(3), function_constant(use_no_instancing) ]]
                             , device scn_std_node* scn_nodes                      [[ buffer(3), function_constant(use_instancing) ]]
                             , constant float4* u_shadowKernel                     [[ buffer(4) ]] 
                             , constant sh3_coefficients& scn_shCoefficients       [[ buffer(5), function_constant(use_probes_lighting) ]]
                             , texture2d<float> u_emissionTexture                  [[ texture(0), function_constant(use_emission_map)]]
                             , sampler          u_emissionTextureSampler           [[ sampler(0), function_constant(use_emission_map)]]
                             , texture2d<float> u_ambientTexture                   [[ texture(1), function_constant(use_ambient_map)]]
                             , sampler          u_ambientTextureSampler            [[ sampler(1), function_constant(use_ambient_map)]]
                             , texture2d<float> u_diffuseTexture                   [[ texture(2), function_constant(use_diffuse_map)]]
                             , sampler          u_diffuseTextureSampler            [[ sampler(2), function_constant(use_diffuse_map)]]
                             , texture2d<float> u_specularTexture                  [[ texture(3), function_constant(use_specular_map)]]
                             , sampler          u_specularTextureSampler           [[ sampler(3), function_constant(use_specular_map)]]
                             , texture2d<float> u_reflectiveTexture                [[ texture(4), function_constant(use_reflective_map)]]
                             , sampler          u_reflectiveTextureSampler         [[ sampler(4), function_constant(use_reflective_map)]]
                             , texturecube<float> u_reflectiveCubeTexture          [[ texture(4), function_constant(use_reflectivecube_map)]]
                             , sampler            u_reflectiveCubeTextureSampler   [[ sampler(4), function_constant(use_reflectivecube_map)]]
                             , texture2d<float> u_transparentTexture               [[ texture(5), function_constant(use_transparent_map)]]
                             , sampler          u_transparentTextureSampler        [[ sampler(5), function_constant(use_transparent_map)]]
                             , texture2d<float> u_multiplyTexture                  [[ texture(6), function_constant(use_multiply_map)]]
                             , sampler          u_multiplyTextureSampler           [[ sampler(6), function_constant(use_multiply_map)]]
                             , texture2d<float> u_normalTexture                    [[ texture(7), function_constant(use_normal_map)]]
                             , sampler          u_normalTextureSampler             [[ sampler(7), function_constant(use_normal_map)]]
                             , texture2d<float> u_metalnessTexture                 [[ texture(3), function_constant(use_metalness_map) ]]
                             , sampler          u_metalnessTextureSampler          [[ sampler(3), function_constant(use_metalness_map) ]]
                             , texture2d<float> u_roughnessTexture                 [[ texture(4), function_constant(use_roughness_map) ]]
                             , sampler          u_roughnessTextureSampler          [[ sampler(4), function_constant(use_roughness_map) ]]
                             , texturecube<float> u_irradianceTexture              [[ texture(8), function_constant(use_pbr) ]]
                             
                             , texturecube<float> u_radianceTexture                [[ texture(9), function_constant(use_pbr) ]]
                             , texture2d<float>   u_specularDFGTexture             [[ texture(10), function_constant(use_pbr) ]]
                             , texture2d<float> u_ssaoTexture                      [[ texture(11), function_constant(use_ssao) ]]
                             
                             , depth2d<float> u_shadowTexture0                     [[ texture(12), function_constant(use_shadow0) ]]
                             , depth2d<float> u_shadowTexture1                     [[ texture(13), function_constant(use_shadow1) ]]
                             , depth2d<float> u_shadowTexture2                     [[ texture(14), function_constant(use_shadow2) ]]
                             , depth2d<float> u_shadowTexture3                     [[ texture(15), function_constant(use_shadow3) ]]
                             
                             
                             , texture2d<float> u_goboTexture0                     [[ texture(16), function_constant(use_gobo0) ]]
                             , texture2d<float> u_goboTexture1                     [[ texture(17), function_constant(use_gobo1) ]]
                             , texture2d<float> u_goboTexture2                     [[ texture(18), function_constant(use_gobo2) ]]
                             , texture2d<float> u_goboTexture3                     [[ texture(19), function_constant(use_gobo3) ]]
                             
                             
                             
                             
                             
                             , texture2d<float> u_iesTexture0                      [[ texture(16), function_constant(use_ies0) ]]
                             , texture2d<float> u_iesTexture1                      [[ texture(17), function_constant(use_ies1) ]]
                             , texture2d<float> u_iesTexture2                      [[ texture(18), function_constant(use_ies2) ]]
                             , texture2d<float> u_iesTexture3                      [[ texture(19), function_constant(use_ies3) ]]
                             
                             , texturecube<float> u_iesCubeTexture0                [[ texture(16), function_constant(use_iesCube0) ]]
                             , texturecube<float> u_iesCubeTexture1                [[ texture(17), function_constant(use_iesCube1) ]]
                             , texturecube<float> u_iesCubeTexture2                [[ texture(18), function_constant(use_iesCube2) ]]
                             , texturecube<float> u_iesCubeTexture3                [[ texture(19), function_constant(use_iesCube3) ]]
                             
                             , bool isFrontFacing                                  [[ front_facing, function_constant(use_double_sided) ]]
#ifdef USE_FRAGMENT_EXTRA_ARGUMENTS
__FragmentExtraArguments__
#endif
                             )
    
    
    scn_std_node in_node;
    if (use_instancing) {
        
        in_node = scn_nodes[0];
    } else {
        in_node = scn_node;
    }
    SCNShaderSurface _surface;
    float2 uv[kSCNTexcoordCount];
    switch (io_texcoord_count - 1) {
        case 7 : uv[7] = in.texcoord7;
        case 6 : uv[6] = in.texcoord6;
        case 5 : uv[5] = in.texcoord5;
        case 4 : uv[4] = in.texcoord4;
        case 3 : uv[3] = in.texcoord3;
        case 2 : uv[2] = in.texcoord2;
        case 1 : uv[1] = in.texcoord1;
        case 0 : uv[0] = in.texcoord0;
    }
    if (is_function_constant_defined(diffuse_texcoord_io_index))
        _surface.diffuseTexcoord = uv[diffuse_texcoord_io_index];
    
    if (is_function_constant_defined(normal_texcoord_io_index))
        _surface.normalTexcoord = uv[normal_texcoord_io_index];
    
    if (is_function_constant_defined(transparent_texcoord_io_index))
        _surface.transparentTexcoord = uv[transparent_texcoord_io_index];
    
    if (is_function_constant_defined(emission_texcoord_io_index))
        _surface.emissionTexcoord = uv[emission_texcoord_io_index];
    
    if (is_function_constant_defined(ambient_texcoord_io_index))
        _surface.ambientTexcoord = uv[ambient_texcoord_io_index];
    
    if (is_function_constant_defined(multiply_texcoord_io_index))
        _surface.multiplyTexcoord = uv[multiply_texcoord_io_index];
    
    if (is_function_constant_defined(specular_texcoord_io_index))
        _surface.specularTexcoord = uv[specular_texcoord_io_index];
    
    if (is_function_constant_defined(roughness_texcoord_io_index))
        _surface.roughnessTexcoord = uv[roughness_texcoord_io_index];
    if (is_function_constant_defined(metalness_texcoord_io_index))
        _surface.metalnessTexcoord = uv[metalness_texcoord_io_index];
    _surface.ambientOcclusion = 1.f; 
    if (use_ambient_map) {
        float4 c = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord);
        if (is_function_constant_defined(ambient_texture_component)) {
            c = c[ambient_texture_component];
        }
        
        if (use_ambient_as_ambientOcclusion) {
            _surface.ambientOcclusion = c.r;
            if (use_ambient_intensity)
                _surface.ambientOcclusion = saturate(mix(1.f, _surface.ambientOcclusion, scn_commonprofile.ambientIntensity));
        } else {
            _surface.ambient = c;
            if (use_ambient_intensity)
                _surface.ambient *= scn_commonprofile.ambientIntensity;
        }
    } else {
        _surface.ambient = scn_commonprofile.ambientColor;
    }
    if (use_ambient && use_io_vertex_color)
        _surface.ambient *= in.vertexColor;
    if (use_ssao)
        _surface.ambientOcclusion *= u_ssaoTexture.sample( linearSampler, in.fragmentPosition.xy * scn_frame.inverseResolution.xy ).x;
    
    if (use_diffuse_map) {
        _surface.diffuse = u_diffuseTexture.sample(u_diffuseTextureSampler, _surface.diffuseTexcoord);
        if (is_function_constant_defined(diffuse_texture_component))
            _surface.diffuse = _surface.diffuse[diffuse_texture_component];
        if (use_diffuse_intensity)
            _surface.diffuse.rgb *= scn_commonprofile.diffuseIntensity;
    } else {
        _surface.diffuse = scn_commonprofile.diffuseColor;
    }
    if (use_diffuse && use_io_vertex_color) {
        _surface.diffuse *= in.vertexColor;
    }
    
    if (use_specular_map) {
        _surface.specular = u_specularTexture.sample(u_specularTextureSampler, _surface.specularTexcoord);
        if (is_function_constant_defined(specular_texture_component))
            _surface.specular = _surface.specular[specular_texture_component];
        if (use_specular_intensity)
            _surface.specular *= scn_commonprofile.specularIntensity;
    } else {
        _surface.specular = scn_commonprofile.specularColor;
    }
    if (use_emission_map) {
        _surface.emission = u_emissionTexture.sample(u_emissionTextureSampler, _surface.emissionTexcoord);
        if (is_function_constant_defined(emission_texture_component))
            _surface.emission = float4(_surface.emission[emission_texture_component]);
        if (use_emission_intensity)
            _surface.emission *= scn_commonprofile.emissionIntensity;
    } else {
        _surface.emission = scn_commonprofile.emissionColor;
    }
    if (use_multiply_map) {
        _surface.multiply = u_multiplyTexture.sample(u_multiplyTextureSampler, _surface.multiplyTexcoord);
        if (is_function_constant_defined(multiply_texture_component))
            _surface.multiply = float4(_surface.multiply[multiply_texture_component]);
        if (use_multiply_intensity)
            _surface.multiply = mix(float4(1.f), _surface.multiply, scn_commonprofile.multiplyIntensity);
    } else {
        _surface.multiply = scn_commonprofile.multiplyColor;
    }
    
    if (use_transparent_map) {
        _surface.transparent = u_transparentTexture.sample(u_transparentTextureSampler, _surface.transparentTexcoord);
        if (is_function_constant_defined(transparent_texture_component))
            _surface.transparent = float4(_surface.transparent[transparent_texture_component]);
        if (use_transparent_intensity)
            _surface.transparent *= scn_commonprofile.transparentIntensity;
    } else {
        _surface.transparent = scn_commonprofile.transparentColor;
    }
    if (use_metalness_map) {
        float4 c = u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord);
        if (is_function_constant_defined(metalness_texture_component))
            _surface.metalness = c[metalness_texture_component];
        else 
            _surface.metalness = c.r;
        if (use_metalness_intensity)
            _surface.metalness *= scn_commonprofile.metalnessIntensity;
    } else {
        _surface.metalness = scn_commonprofile.metalness;
    }
    
    if (use_roughness_map) {
        float4 c = u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord).r;
        if (is_function_constant_defined(roughness_texture_component))
            _surface.roughness = c[roughness_texture_component];
        else 
            _surface.roughness = c.r;
        if (use_roughness_intensity)
            _surface.roughness *= scn_commonprofile.roughnessIntensity;
    } else {
        _surface.roughness = scn_commonprofile.roughness;
    }
    
    
    if (use_io_normal) {
        if (use_double_sided)
            _surface.geometryNormal = normalize(in.normal.xyz) * (in.normal.z >= 0.f ? 1.f : -1.f );
        else
            _surface.geometryNormal = normalize(in.normal.xyz);
        _surface.normal = _surface.geometryNormal;
    }
    if (need_tangent) {
        _surface.tangent = in.tangent;
        _surface.bitangent = in.bitangent;
    }
    if (use_io_position)
        _surface.position = in.position;
    if (use_io_view)
        _surface.view = normalize(-in.position);
    if (use_normal_map) {
        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.normal);
        _surface._normalTS = u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord).rgb;
        if (is_function_constant_defined(normal_texture_component)) { 
            _surface._normalTS.xy = _surface._normalTS.xy * 2.f - 1.f;
            _surface._normalTS.z = sqrt(1 - length_squared(_surface._normalTS.xy));
        } else {
            _surface._normalTS = _surface._normalTS * 2.f - 1.f;
        }
        if (use_normal_intensity)
            _surface._normalTS = mix(float3(0.f, 0.f, 1.f), _surface._normalTS, scn_commonprofile.normalIntensity);
        
        _surface.normal.rgb = normalize(ts2vs * _surface._normalTS);
    } else {
        _surface._normalTS = float3(0.f);
    }
    
    if (use_reflective_map) {
        
        float3 refl = reflect( -_surface.view, _surface.normal );
        float m = 2.f * sqrt( refl.x*refl.x + refl.y*refl.y + scn::sq(refl.z + 1.f));
        _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, float2(float2(refl.x,-refl.y) / m) + 0.5f);
        if (is_function_constant_defined(reflective_texture_component))
            _surface.reflective = _surface.reflective[reflective_texture_component];
        
        if (use_reflective_intensity)
            _surface.reflective *= scn_commonprofile.reflectiveIntensity;
    
    } else if (use_reflectivecube_map) {
    
        float3 refl = reflect( _surface.position, _surface.normal );
        _surface.reflective = u_reflectiveCubeTexture.sample(u_reflectiveCubeTextureSampler, scn::mat4_mult_float3(scn_frame.viewToCubeTransform, refl)); 
        if (is_function_constant_defined(reflective_texture_component))
            _surface.reflective = _surface.reflective[reflective_texture_component];
        
        if (use_reflective_intensity)
            _surface.reflective *= scn_commonprofile.reflectiveIntensity;
    
    } else {
        _surface.reflective = scn_commonprofile.reflectiveColor;
    }
    
    if (use_fresnel) {
        _surface.fresnel = scn_commonprofile.fresnel.x + scn_commonprofile.fresnel.y * pow(1.f - saturate(dot(_surface.view, _surface.normal)), scn_commonprofile.fresnel.z);
        _surface.reflective *= _surface.fresnel;
    }
    _surface.shininess = scn_commonprofile.materialShininess;
    
#ifdef USE_SURFACE_MODIFIER
__DoSurfaceModifier__
#endif
    SCNShaderLightingContribution _lightingContribution = {0};
    if (use_ambient_lighting)
        _lightingContribution.ambient = scn_frame.ambientLightingColor.rgb;
    
    if (use_lighting) {
        if (use_per_pixel_lighting) {
            _lightingContribution.diffuse = float3(0.f);
            if (use_modulate_lighting)
                _lightingContribution.modulate = float3(1.f);
            if (use_specular)
                _lightingContribution.specular = float3(0.f);
            
            if (is_function_constant_defined(use_light0)) {
                SCNLightingParameters params;
                params.surface = _surface;
                params.lightInfo = use_light0;
                params.lightData = scn_lights[ in_node.lightIndices[0] ];
                params.attenuation = float3(1.f);
                if (use_shadow0) scn_do_shadow(params, u_shadowTexture0, u_shadowKernel);
                if (use_gobo0)   scn_do_gobo(params, u_goboTexture0);
                if (use_ies0)    scn_do_ies(params, u_iesTexture0, linearSampler );
                if (use_iesCube0)    scn_do_ies(params, u_iesCubeTexture0, linearSampler );
                scn_do_light(params, _lightingContribution);
            }
            if (is_function_constant_defined(use_light1)) {
                SCNLightingParameters params;
                params.surface = _surface;
                params.lightInfo = use_light1;
                params.lightData = scn_lights[ in_node.lightIndices[1] ];
                params.attenuation = float3(1.f);
                if (use_shadow1) scn_do_shadow(params, u_shadowTexture1, u_shadowKernel);
                if (use_gobo1)   scn_do_gobo(params, u_goboTexture1);
                if (use_ies1)    scn_do_ies(params, u_iesTexture1, linearSampler );
                if (use_iesCube1)    scn_do_ies(params, u_iesCubeTexture1, linearSampler );
                scn_do_light(params, _lightingContribution);
            }
            if (is_function_constant_defined(use_light2)) {
                SCNLightingParameters params;
                params.surface = _surface;
                params.lightInfo = use_light2;
                params.lightData = scn_lights[ in_node.lightIndices[2] ];
                params.attenuation = float3(1.f);
                if (use_shadow2) scn_do_shadow(params, u_shadowTexture2, u_shadowKernel);
                if (use_gobo2)   scn_do_gobo(params, u_goboTexture2);
                if (use_ies2)    scn_do_ies(params, u_iesTexture2, linearSampler );
                if (use_iesCube2)    scn_do_ies(params, u_iesCubeTexture2, linearSampler );
                scn_do_light(params, _lightingContribution);
            }
            
            if (is_function_constant_defined(use_light3)) {
                SCNLightingParameters params;
                params.surface = _surface;
                params.lightInfo = use_light3;
                params.lightData = scn_lights[ in_node.lightIndices[3] ];
                params.attenuation = float3(1.f);
                if (use_shadow3) scn_do_shadow(params, u_shadowTexture3, u_shadowKernel);
                if (use_gobo3)   scn_do_gobo(params, u_goboTexture3);
                if (use_ies3)    scn_do_ies(params, u_iesTexture3, linearSampler );
                if (use_iesCube3)    scn_do_ies(params, u_iesCubeTexture3, linearSampler );
                scn_do_light(params, _lightingContribution);
            }
            
        } else { 
            _lightingContribution.diffuse = in.diffuse;
            if (use_specular)
                _lightingContribution.specular = in.specular;
        }
        if (avoid_overlighting) {
            _lightingContribution.diffuse = saturate(_lightingContribution.diffuse);
            if (use_specular)
                _lightingContribution.specular = saturate(_lightingContribution.specular);
        }
    } else { 
        _lightingContribution.diffuse = float3(1.f);
    }
    
    
    SCNOutput _output;
    if (use_pbr) {
        SCNPBRSurface pbr_surface = SCNShaderSurfaceToSCNPBRSurface(_surface);
        pbr_surface.selfIlluminationOcclusion = scn_commonprofile.selfIlluminationOcclusion;
        if (use_probes_lighting) {
            _output.color = scn_pbr_combine_probes(pbr_surface, _lightingContribution, u_specularDFGTexture, u_radianceTexture, scn_shCoefficients, scn_frame);
        } else {
            _output.color = scn_pbr_combine_cubemap(pbr_surface, _lightingContribution, u_specularDFGTexture, u_radianceTexture, u_irradianceTexture, scn_frame);
        }
        _output.color.a = _surface.diffuse.a;
    } else {
        _output.color = illuminate(_surface, _lightingContribution);
    }
    
    if (use_fog) {
        float fogFactor = pow(clamp(length(_surface.position.xyz) * scn_frame.fogParameters.x + scn_frame.fogParameters.y, 0., scn_frame.fogColor.a), scn_frame.fogParameters.z);
        _output.color.rgb = mix(_output.color.rgb, scn_frame.fogColor.rgb * _output.color.a, fogFactor);
    }
    if (!diffuse_premultiplied)
        _output.color.rgb *= _surface.diffuse.a;
    float nodeOpacity = use_node_opacity ? in_node.nodeOpacity : 1.f;
    if (use_transparent) {
        if (use_transparency)
            _surface.transparent *= scn_commonprofile.transparency;
        
        if (use_transparency_rgbzero) {
            
            _surface.transparent.a = (_surface.transparent.r * 0.212671f) + (_surface.transparent.g * 0.715160f) + (_surface.transparent.b * 0.072169f);
            _output.color *= nodeOpacity * (float4(1.f) - _surface.transparent);
        } else { 
            _output.color *= (nodeOpacity * _surface.transparent.a);
        }
    } else {
        if (use_transparency) { 
            _output.color *= (nodeOpacity * scn_commonprofile.transparency);
        }
    }
    
#ifdef USE_FRAGMENT_MODIFIER
__DoFragmentModifier__
#endif
    
    
    if (use_discard && _output.color.a == 0.) 
        discard_fragment();
    return half4(_output.color);
static int OsdGetPatchNumControlVertices(int patchType) {
    switch(patchType) {
        case 3: return 4;
        case 6: return 16;
        case 9: return 20;
        default: return 0;
    }
#if OSD_IS_ADAPTIVE
#if USE_STAGE_IN
#if OSD_PATCH_REGULAR
struct ControlPoint
    
    float3 P [[attribute(0)]];
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    float3 P1 [[attribute(1)]];
    float3 P2 [[attribute(2)]];
#if !USE_PTVS_SHARPNESS
    float2 vSegments [[attribute(3)]];
#endif 
#endif 
struct PatchInput
    patch_control_point<ControlPoint> cv;
#if !USE_PTVS_FACTORS
    float4 tessOuterLo [[attribute(5)]];
    float4 tessOuterHi [[attribute(6)]];
#endif 
    int3 patchParam [[attribute(10)]];
#elif OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY
struct ControlPoint
    
    float3 P [[attribute(0)]];
    float3 Ep [[attribute(1)]];
    float3 Em [[attribute(2)]];
    float3 Fp [[attribute(3)]];
    float3 Fm [[attribute(4)]];
struct PatchInput
    patch_control_point<ControlPoint> cv;
    int3 patchParam [[attribute(10)]];
#elif OSD_PATCH_GREGORY_BASIS
struct ControlPoint
    float3 position [[attribute(0)]];
struct PatchInput
    patch_control_point<ControlPoint> cv;
    int3 patchParam [[attribute(10)]];
#endif
#endif 
#endif 
#if defined(OSD_FVAR_WIDTH)
static void OsdInterpolateFaceVarings(thread SCNShaderGeometry&      geometry
                                      , float2                       uv
                                      , int                          patchIndex
#if OSD_FVAR_USES_MULTIPLE_CHANNELS
                                      , constant uint32_t&           osdFaceVaryingChannelCount
                                      , constant OsdFVarChannelDesc* osdFaceVaryingChannelDescriptors
                                      , constant uint32_t&           osdFaceVaryingPatchArrayIndex
                                      , constant void*               osdFaceVaryingChannelsPackedData
#else 
                                      , constant int*                osdFaceVaryingIndices
                                      , constant float*              osdFaceVaryingData
#if OSD_IS_ADAPTIVE
                                      , constant packed_int3*        osdFaceVaryingPatchParams
                                      , constant packed_int4&        osdFaceVaryingPatchArray
#endif
#endif 
                                      )
#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[0] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[1] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[2] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[3] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[4] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[5] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[6] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[7] = float2(0.0);
#endif
#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.color = float4(0.0);
#endif
    
#if OSD_FVAR_USES_MULTIPLE_CHANNELS
    for (uint32_t channel = 0; channel < osdFaceVaryingChannelCount; ++channel) {
        OsdFVarChannelDesc channelDescriptor = osdFaceVaryingChannelDescriptors[channel];
        
        int4 osdFaceVaryingPatchArray = ((constant packed_int4 *)((constant uint8_t *)osdFaceVaryingChannelsPackedData + channelDescriptor.patchArraysBufferOffset))[osdFaceVaryingPatchArrayIndex];
        int indexBase = osdFaceVaryingPatchArray.z;
        
        constant int *osdFaceVaryingIndices = (constant int *)((constant uint8_t *)osdFaceVaryingChannelsPackedData + channelDescriptor.indicesBufferOffset) + indexBase * 3;
        constant float *osdFaceVaryingData = (constant float *)((constant uint8_t *)osdFaceVaryingChannelsPackedData + channelDescriptor.dataBufferOffset);
        
#if OSD_IS_ADAPTIVE
        int primitiveIdBase = osdFaceVaryingPatchArray.w;
        constant packed_int3 *osdFaceVaryingPatchParams = (constant packed_int3 *)((constant uint8_t *)osdFaceVaryingChannelsPackedData + channelDescriptor.patchParamsBufferOffset) + primitiveIdBase;
        
        int3 fvarPatchParam = osdFaceVaryingPatchParams[patchIndex];
        bool isRegular = OsdGetPatchIsRegular(fvarPatchParam);
        
        int4 patchArray = osdFaceVaryingPatchArray;
        int patchStride = OsdGetPatchNumControlVertices(patchArray.x);
        int patchType = select(patchArray.x, int(6), isRegular);
        int patchCVs = OsdGetPatchNumControlVertices(patchType);
        
        float wP[20], wDs[20], wDt[20], wDss[20], wDst[20], wDtt[20];
        
        if (patchType == 3) {
            OsdGetBilinearPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
        } else if (patchType == 6) {
            int boundaryMask = OsdGetPatchBoundaryMask(fvarPatchParam);
            OsdGetBSplinePatchWeights(uv.x, uv.y, 1.0f, boundaryMask, wP, wDs, wDt, wDss, wDst, wDtt);
        } else if (patchType == 9) {
            OsdGetGregoryPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
        }
#else
        float wP[4], wDs[4], wDt[4], wDss[4], wDst[4], wDtt[4];
        int patchCVs = 4;
        int patchStride = patchCVs;
        OsdGetBilinearPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
#endif
        
        for (int i = 0; i < patchCVs; ++i) {
#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.colorPrimvar.isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.colorPrimvar.offset;
                geometry.color += wP[i] * float4(osdFaceVaryingData[index], osdFaceVaryingData[index+1], osdFaceVaryingData[index+2], osdFaceVaryingData[index+3]);
            }
#endif
#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[0].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[0].offset;
                geometry.texcoords[0] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[1].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[1].offset;
                geometry.texcoords[1] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[2].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[2].offset;
                geometry.texcoords[2] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[3].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[3].offset;
                geometry.texcoords[3] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[4].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[4].offset;
                geometry.texcoords[4] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[5].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[5].offset;
                geometry.texcoords[5] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[6].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[6].offset;
                geometry.texcoords[6] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[7].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[7].offset;
                geometry.texcoords[7] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
        }
    }
    
#else 
    
#if OSD_IS_ADAPTIVE
    int3 fvarPatchParam = osdFaceVaryingPatchParams[patchIndex];
    bool isRegular = OsdGetPatchIsRegular(fvarPatchParam);
    
    int4 patchArray = osdFaceVaryingPatchArray;
    int patchStride = OsdGetPatchNumControlVertices(patchArray.x);
    int patchType = select(patchArray.x, int(6), isRegular);
    int patchCVs = OsdGetPatchNumControlVertices(patchType);
    
    float wP[20], wDs[20], wDt[20], wDss[20], wDst[20], wDtt[20];
    
    if (patchType == 3) {
        OsdGetBilinearPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
    } else if (patchType == 6) {
        int boundaryMask = OsdGetPatchBoundaryMask(fvarPatchParam);
        OsdGetBSplinePatchWeights(uv.x, uv.y, 1.0f, boundaryMask, wP, wDs, wDt, wDss, wDst, wDtt);
    } else if (patchType == 9) {
        OsdGetGregoryPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
    }
#else
    float wP[4], wDs[4], wDt[4], wDss[4], wDst[4], wDtt[4];
    int patchCVs = 4;
    int patchStride = patchCVs;
    OsdGetBilinearPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
#endif
    
    for (int i = 0; i < patchCVs; ++i) {
        int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * OSD_FVAR_WIDTH + 0 ;
#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.color += wP[i] * float4(osdFaceVaryingData[index], osdFaceVaryingData[index+1], osdFaceVaryingData[index+2], osdFaceVaryingData[index+3]);
        index += 4;
#endif
#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[0] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[1] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[2] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[3] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[4] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[5] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[6] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[7] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
    }
#endif 
#endif 
#import <metal_stdlib>
using namespace metal;
struct sh2_coefficients
    float4 R;
    float4 G;
    float4 B;
struct sh3_coefficients
    float4 ar;
    float4 ag;
    float4 ab;
    float4 br;
    float4 bg;
    float4 bb;
    float4 c;
struct SCNPBRSurface {
    float3 n;
    float3 v;
    
    float3 albedo;
    float3 emission;
    float3 selfIllumination;
    float  metalness;
    float  roughness;
    float  ao;
    float  selfIlluminationOcclusion;
#define PBR_F0_NON_METALLIC 0.04f
#define PBR_MIN_ROUGHNESS 0.01
#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)
inline float3 shEvalDirection(float4 dir, sh2_coefficients cachedSH)
    const float Exponent = 1;
    
    
    sh2_vector diffSH = sh2_compute_diffuse_transfer(half3(dir.xyz), Exponent);
    
    
    half3 lighting = max(half3(0,0,0), sh2_dot(cachedSH, diffSH)) * M_1_PI_F;
    
    
    
    return float3(lighting);
#endif
inline float3 shEvalDirection(float4 dir, sh3_coefficients sh)
    float3 x1, x2, x3;
    
    
    x1.r = dot(sh.ar, dir);
    x1.g = dot(sh.ag, dir);
    x1.b = dot(sh.ab, dir);
    
    
    float4 vB = dir.xyzz * dir.yzzx;
    x2.r = dot(sh.br, vB);
    x2.g = dot(sh.bg, vB);
    x2.b = dot(sh.bb, vB);
    
    
    float vC = dir.x * dir.x - dir.y * dir.y;
    x3 = sh.c.xyz * vC;
    
    return x1 + x2 + x3;
inline float scn_radicalInverse(uint32_t bits) {
#if __METAL_VERSION__ >= 210
    bits = reverse_bits(bits);
#else
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
#endif
    return float(bits) * 0x1p-32;
inline float scn_filteredAlphaFromRoughness(float3 N, float roughness)
    float3 dNdx = dfdx(N);
    float3 dNdy = dfdy(N);
#if 1
    constexpr half sigma2 = 0.5h * 0.5h;
#else
    constexpr half sigma2 = 0.15915494h;
#endif
    constexpr half kappa = 0.18h;
    half variance = (half)sigma2 * (dot(dNdx, dNdx) + dot(dNdy, dNdy));
    half kernelAlphaSquared = min(variance, kappa);
    half alpha = roughness * roughness;
    half filteredAlphaSquared = saturate(alpha * alpha + kernelAlphaSquared);
    return sqrt(filteredAlphaSquared);
inline float3 scn_tangentSpaceToLocalSpace(float3 v, float3 normal) {
    float3 tangent,bitangent;
    scn::generate_basis(normal, &tangent, &bitangent);
    
    return tangent * v.x + bitangent * v.y + normal * v.z;
inline float2 scn_sampleHammersley(uint32_t i, uint sampleCount) {
    return float2(float(i) / sampleCount, scn_radicalInverse(i));
static float3 scn_importanceSampleGGX_brdf(float2 random, float alpha) __attribute__((overloadable)) {
    
    
    float cosTheta = sqrt((1.0 - random.x) / (1.0 + (alpha * alpha - 1.0) * random.x));
    float phi = 2.0 * M_PI_F * random.y;
    
    
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    return float3(sinTheta * cos(phi),
                  sinTheta * sin(phi),
                  cosTheta);
static float3 scn_importanceSampleGGX_brdf(float2 random, float alpha, float3 n) __attribute__((overloadable)) {
    float3 importanceSampleGGX = scn_importanceSampleGGX_brdf(random, alpha);
    return scn_tangentSpaceToLocalSpace(importanceSampleGGX, n);
static float3 scn_importanceSampleCosine_brdf(float2 random) __attribute__((overloadable)) {
    
    
    
    float r = sqrt(random.x);
    float phi = 2.0 * M_PI_F * random.y;
    
    float cosPhi;
    float sinPhi = sincos(phi, cosPhi);
    
    
    float x = r * cosPhi;
    float y = r * sinPhi;
    float z = sqrt(max(0.f, 1.f - random.x)); 
    return float3(x, y, z);
static float3 scn_importanceSampleCosine_brdf(float2 random, float3 n) __attribute__((overloadable)) {
    float3 importanceSampleCosine = scn_importanceSampleCosine_brdf(random);
    return scn_tangentSpaceToLocalSpace(importanceSampleCosine, n);
inline float scn_brdf_D(float alpha, float NoH) {
    float alpha_squared = alpha * alpha;
    float denom = (NoH * alpha_squared - NoH) * NoH + 1.0f;
    float denom_squared = denom * denom;
    return alpha_squared / (denom_squared * M_PI_F);
inline float3 scn_brdf_F(float3 F0, float LoH) {
    return F0 + (1.f - F0) * pow(1.f - LoH, 5.f);
inline float3 scn_brdf_F_opt(float3 F0, float LoH) {
    float inv_LoH = 1.f - LoH;
    float inv_LoH_pow_2 = inv_LoH * inv_LoH;
    float inv_LoH_pow_5 = inv_LoH_pow_2 * inv_LoH_pow_2 * inv_LoH;
    return F0 + (1.f - F0) * inv_LoH_pow_5;
inline float scn_brdf_GLambda(float alpha2, float NoL) {
    float NoL2 = NoL * NoL;
    float t = (1.0f - NoL2) * alpha2 / NoL2;
    return 0.5f * (-1.0f + sqrt(1.0f + t));
inline float scn_brdf_G(float alpha, float NoL, float NoV) {
    float alpha2 = alpha * alpha;
    float lambdaL = scn_brdf_GLambda(alpha2, NoL);
    float lambdaV = scn_brdf_GLambda(alpha2, NoV);
    return 1.f / (1.f + lambdaL + lambdaV);
inline float scn_brdf_V(float alpha, float NoL, float NoV) {
    float alpha_squared = alpha * alpha;
    float NoL_squared = NoL * NoL;
    float NoV_squared = NoV * NoV;
    float lambda_L = NoV * sqrt(NoL_squared + alpha_squared * (1.0f - NoL_squared));
    float lambda_V = NoL * sqrt(NoV_squared + alpha_squared * (1.0f - NoV_squared));
    return 0.5f / (lambda_L + lambda_V + 1e-6f);
inline float scn_brdf_V_opt(float alpha, float LoH) {
    float k = alpha * 0.5f;
    float k2 = k * k;
    float invK2 = 1.f - k2;
    return 1.f / (LoH * LoH * invK2 + k2);
static float2 scn_computeHammonFactors(float NdotL, float NdotH, float NdotV, float LdotV, float alpha)
    
    
    
    
    
    
    
    
    
    float facing = 0.5f + 0.5f * LdotV;
    float rough = facing * (0.9f - 0.4f * facing) * (0.5f + NdotH) / NdotH;
    float smooth = 1.05f * (1.0f - pow(1.0f - NdotL, 5.f)) * (1.0f - pow(1.0f - NdotV, 5.f));
    float single = mix(smooth, rough, alpha);
    float multi = M_PI_F * 0.1159f * alpha;
    return float2(single, multi);
inline float4 scn_specularDFG_diffuseHammon(float NoV,
                                            float roughness)
    
    
    float3 v = float3(sqrt(1.0 - NoV * NoV),
                      0.0,
                      NoV);
    
    float alpha = roughness * roughness; 
    
    float2 specularDFG = float2(0.0);
    float2 diffuseHammonFactors = float2(0.0);
    
    int const sampleCount = 1024;
    for (int i = 0; i < sampleCount; ++i) {
        float2 random = scn_sampleHammersley(i, sampleCount);
        
        
        float3 h = scn_importanceSampleGGX_brdf(random, alpha); 
        float3 l = reflect(-v, h); 
        
        float NoL = saturate(l.z); 
        float NoH = saturate(h.z); 
        float LoH = saturate(dot(l, h));
        
        if (NoL > 0.f) {
            float G = scn_brdf_G(alpha, NoL, NoV);
            float GVis = G * LoH / (NoH * NoV);
            float Fc = pow(1.f - LoH, 5.f);
            specularDFG.x += (1.f - Fc) * GVis;
            specularDFG.y += Fc * GVis;
        }
        
        
        float3 Ld = scn_importanceSampleCosine_brdf(random); 
        float NoLd = saturate(Ld.z);
        if (NoLd > 0.f) {
            float3 Hd = normalize(v + Ld);
            float NoHd = Hd.z;
            
            float LoVd = saturate(dot(Ld, v));
            float2 HF = scn_computeHammonFactors(NoLd, NoHd, NoV, LoVd, alpha);
            diffuseHammonFactors.x += HF.x;
            diffuseHammonFactors.y += HF.y;
        }
    }
    
    return float4(specularDFG.x, specularDFG.y, diffuseHammonFactors.x, diffuseHammonFactors.y) / sampleCount;
inline float3 scn_irradiance_cube(texturecube<float, access::sample> environment,
                                  uint                               environmentMipmapLevel,
                                  float3                             n_cube)
    float3 n = float3(n_cube.x, -n_cube.z, n_cube.y);
    
    constexpr sampler linearSampler(filter::linear);
    
    float3 L = float3(0.0);
    float weight = 0.0f;
    
    ushort const sampleCount = 1024;
    for (ushort i = 0; i < sampleCount; ++i) {
        float2 random = scn_sampleHammersley(i, sampleCount);
        float3 l = scn_importanceSampleCosine_brdf(random, n); 
        
        float NoL = saturate(dot(n, l));
        if (NoL > 0) {
            float3 Li = environment.sample(linearSampler, float3(l.x , l.z, -l.y), level(environmentMipmapLevel)).rgb;
            L += Li; 
            weight += 1.0;
        }
    }
    
    return L / weight;
inline float scn_pbr_distanceAttenuation(float3 lightVector)
    float sqrDist = dot(lightVector, lightVector);
    return 1. / max(sqrDist, 0.0001);
inline float3 scn_pbr_reference_world(SCNPBRSurface                      surface,
                                      texturecube<float, access::sample> environment,
                                      uint                               environmentSamplingLevel,
                                      float4x4                           localDirToWorldCubemapDir,
                                      float                              environmentIntensity)
    constexpr sampler linearSampler(filter::linear, mip_filter::linear);
    
    float3 n = surface.n;
    float3 v = surface.v;
    float3 albedo = surface.albedo;
    float metalness = surface.metalness;
    float roughness = surface.roughness;
    float ambientOcclusion = surface.ao;
    
    float NoV = saturate(dot(n, v));
    
    float3 effectiveAlbedo = mix(albedo, float3(0.0), metalness);
    float3 reflectance = mix(float3(PBR_F0_NON_METALLIC), albedo, metalness);
    
    
    float3 irradiance = float3(0.0);
    
    ushort const sampleCountDiffuse = 1024;
    for (ushort i = 0; i < sampleCountDiffuse; ++i) {
        float2 random = scn_sampleHammersley(i, sampleCountDiffuse);
        float3 l = scn_importanceSampleCosine_brdf(random, n); 
        
        float NoL = saturate(dot(n, l));
        
        if (NoL > 0) {
            float3 Li = environment.sample(linearSampler, scn::mat4_mult_float3(localDirToWorldCubemapDir, l), level(environmentSamplingLevel)).rgb * environmentIntensity;
            irradiance += Li; 
        }
    }
    
    irradiance = irradiance / float(sampleCountDiffuse);
    
    
    float3 specular = float3(0.0);
    float specularWeight = 0.0;
    
    float correctedRoughness = mix(1.0f / 128.0f, 1.0f - 1.0f / 128.0f, roughness);
    float alpha = correctedRoughness * correctedRoughness; 
    
    ushort const sampleCountSpecular = 128;
    for (ushort i = 0; i < sampleCountSpecular; ++i) {
        float2 random = scn_sampleHammersley(i, sampleCountSpecular);
        float3 h = scn_importanceSampleGGX_brdf(random, correctedRoughness, n); 
        float3 l = reflect(-v, h); 
        
        float NoL = saturate(dot(n, l));
        float NoH = saturate(dot(n, h));
        float LoH = saturate(dot(l, h));
        
        if (NoH * NoV > 0) {
            float3 Li = environment.sample(linearSampler, scn::mat4_mult_float3(localDirToWorldCubemapDir, l), level(environmentSamplingLevel)).rgb * environmentIntensity;
            float3 F = scn_brdf_F(reflectance, LoH);
            float G = scn_brdf_G(alpha, NoL, NoV);
#if 0
            float D = scn_brdf_D(alpha, NoH);
            float pdf = (D * NoH) / (4.0f * LoH);
            
            if (pdf >= 0) {
                float3 l = D * F * G / (4.0f * NoV); 
                specular += Li * l / pdf;
                specularWeight += 1.0f;
            }
#else
            specular += Li * F * G * LoH / (NoH * NoV);
            specularWeight += 1.0f;
#endif
        }
    }
    
    specular /= specularWeight;
    
    
    return ambientOcclusion * (effectiveAlbedo * irradiance + specular);
inline float3x3 scn_ltc_matrix_invert_transpose(float3x3 m)
    float a = m[0][0];
    float b = m[1][0];
    float c = m[0][1];
    float d = m[1][1];
    float det = a * d - b * c;
    m[0][0] = +det * d;
    m[1][0] = -det * b;
    m[1][0] = -det * c;
    m[1][1] = +det * a;
    m[2][2] = 1.f / m[2][2];
    return m;
inline float3x3 scn_sample_area_light_precomputed_data(float3                 v,
                                                       float3                 n,
                                                       float                  roughness,
                                                       thread float*          brdfNorm,
                                                       texture2d_array<float> bakedDataTexture)
    constexpr sampler linearSampler = sampler(address::clamp_to_edge, filter::linear);
    
    float theta = acos(fabs(dot(n, v)));
    float2 uv = float2(roughness, theta * M_2_PI_F);
    
    float4 dataA = bakedDataTexture.sample(linearSampler, uv, 0);
    float4 dataB = bakedDataTexture.sample(linearSampler, uv, 1);
    
    *brdfNorm = dataB.y;
    
    return float3x3(float3(dataA.x, dataA.y, 0.f),
                    float3(dataA.z, dataA.w, 0.f),
                    float3(0.f, 0.f, dataB.x));
inline float3 scn_area_light_polygon_edge_vector_form_factor(float3 cornerDirectionA,
                                                             float3 cornerDirectionB)
    
    
    
#if 0
    float theta = acos(dot(cornerDirectionA, cornerDirectionB));
    return (0.5f * M_1_PI_F) * cross(cornerDirectionA, cornerDirectionB) * ((theta > 0.001) ? theta/sin(theta) : 1.0);
#else
    float x = dot(cornerDirectionA, cornerDirectionB);
    float y = abs(x);
    
    float a = 5.42031f + (3.12829f + 0.0902326 * y) * y;
    float b = 3.45068f + (4.18814f + y) * y;
    float thetaOverSinTheta = a / b;
    
    if (x < 0.f)
        thetaOverSinTheta = M_PI_F * rsqrt(1.f - x * x) - thetaOverSinTheta;
    
    float3 u = cross(cornerDirectionA, cornerDirectionB);
    return (0.5f * M_1_PI_F) * thetaOverSinTheta * u;
#endif
inline float scn_area_light_horizon_clipped_sphere_form_factor_from_polygon_vector_form_factor(float3 vectorFormFactor)
#if 1
    
    float l = length(vectorFormFactor);
    return max((l * l + vectorFormFactor.y) / (l + 1.f), 0.f);
#else
    
    return max(vectorFormFactor.y, 0.f);
#endif
inline float pbr_area_light_eval_rectangle(float4x3 corners)
    
    
    
    float3 corner0 = normalize(corners[0]);
    float3 corner1 = normalize(corners[1]);
    float3 corner2 = normalize(corners[2]);
    float3 corner3 = normalize(corners[3]);
    
    float3 vectorFormFactor = float3(0.f);
    vectorFormFactor += scn_area_light_polygon_edge_vector_form_factor(corner0, corner1);
    vectorFormFactor += scn_area_light_polygon_edge_vector_form_factor(corner1, corner2);
    vectorFormFactor += scn_area_light_polygon_edge_vector_form_factor(corner2, corner3);
    vectorFormFactor += scn_area_light_polygon_edge_vector_form_factor(corner3, corner0);
    
    return scn_area_light_horizon_clipped_sphere_form_factor_from_polygon_vector_form_factor(vectorFormFactor);
inline float pbr_area_light_eval_polygon(float3                position,
                                         float3                lightCenter,
                                         float3                lightRight,
                                         float3                lightTop,
                                         uint32_t              vertexCount,
                                         device packed_float2 *vertexPositions)
    
    
    
    float3 vectorFormFactor = float3(0.f);
    for (uint32_t vertexIndex = 0; vertexIndex < vertexCount; ++vertexIndex) {
        packed_float2 localCorner0 = vertexPositions[vertexIndex];
        packed_float2 localCorner1 = vertexPositions[(vertexIndex + 1) % vertexCount];
        
        
        
        float3 cornerDirection0 = lightCenter - localCorner0[0] * lightRight + localCorner0[1] * lightTop;
        float3 cornerDirection1 = lightCenter - localCorner1[0] * lightRight + localCorner1[1] * lightTop;
        
        float3 corner0 = normalize(cornerDirection0 - position);
        float3 corner1 = normalize(cornerDirection1 - position);
        
        vectorFormFactor += scn_area_light_polygon_edge_vector_form_factor(corner0, corner1);
    }
    
    return scn_area_light_horizon_clipped_sphere_form_factor_from_polygon_vector_form_factor(vectorFormFactor);
inline float pbr_area_light_line_integral_position(float d, float l) {
    float d_squared = d * d;
    float l_squared = l * l;
    return l / (d * (d_squared + l_squared)) + atan(l / d) / d_squared;
inline float pbr_area_light_line_integral_direction(float d, float l) {
    float d_squared = d * d;
    float l_squared = l * l;
    return l_squared / (d * (d_squared + l_squared));
inline float pbr_area_light_eval_line(float2x3 cornerDirections)
    
    
    
    float3 corner0 = normalize(cornerDirections[0]);
    float3 corner1 = normalize(cornerDirections[1]);
    
    float3 direction = normalize(corner1 - corner0);
    
    if (corner0.y <= 0.f && corner1.y <= 0.f) return 0.f;
    if (corner0.y < 0.f) corner0 = (+corner0 * corner1.y - corner1 * corner0.y) / (+corner1.y - corner0.y);
    if (corner1.y < 0.f) corner1 = (-corner0 * corner1.y + corner1 * corner0.y) / (-corner1.y + corner0.y);
    
    float l1 = dot(corner0, direction);
    float l2 = dot(corner1, direction);
    
    float3 position = corner0 - l1 * direction;
    float d = length(position);
    
    float I = (pbr_area_light_line_integral_position(d, l2) - pbr_area_light_line_integral_position(d, l1)) * position.y
            + (pbr_area_light_line_integral_direction(d, l2) - pbr_area_light_line_integral_direction(d, l1)) * direction.y;
    
    return M_1_PI_F * I;
#ifndef __SCNMetalDefines__
#define __SCNMetalDefines__
enum {
    SCNVertexSemanticPosition,
    SCNVertexSemanticNormal,
    SCNVertexSemanticTangent,
    SCNVertexSemanticColor,
    SCNVertexSemanticBoneIndices,
    SCNVertexSemanticBoneWeights,
    SCNVertexSemanticTexcoord0,
    SCNVertexSemanticTexcoord1,
    SCNVertexSemanticTexcoord2,
    SCNVertexSemanticTexcoord3,
    SCNVertexSemanticTexcoord4,
    SCNVertexSemanticTexcoord5,
    SCNVertexSemanticTexcoord6,
    SCNVertexSemanticTexcoord7
struct SCNSceneBuffer {
    float4x4    viewTransform;
    float4x4    inverseViewTransform; 
    float4x4    projectionTransform;
    float4x4    viewProjectionTransform;
    float4x4    viewToCubeTransform; 
    float4x4    lastFrameViewProjectionTransform;
    float4      ambientLightingColor;
    float4
fogColor;
    float3
fogParameters; 
    float2      inverseResolution;
    float       time;
    float       sinTime;
    float       cosTime;
    float       random01;
    float       motionBlurIntensity;
    
    float       environmentIntensity;
    float4x4    inverseProjectionTransform;
    float4x4    inverseViewProjectionTransform;
    
    float2      nearFar; 
    float4      viewportSize; 
    
    float4x4    inverseTransposeViewTransform;
    
    float4      clusterScale; 
#endif 
struct OsdFVarPrimvar {
    uint8_t isUsed;
    uint8_t offset;
struct OsdFVarChannelDesc {
    uint32_t indicesBufferOffset;
    uint32_t dataBufferOffset;
    uint32_t dataBufferFVarWidth;
    uint32_t patchParamsBufferOffset;
    uint32_t patchArraysBufferOffset;
    OsdFVarPrimvar colorPrimvar;
    OsdFVarPrimvar texcoordPrimvars[8];
enum {
    SCNDeformerAttributeSrcPosition,
    SCNDeformerAttributeSrcNormal,
    SCNDeformerAttributeSrcTangent,
    
    SCNDeformerAttributeDstPosition,
    SCNDeformerAttributeDstNormal,
    SCNDeformerAttributeDstTangent,
    
    SCNDeformerAttributeCount
  struct scn_floor {
    float4 u_floor_viewport;
    float u_floorReflectivity;
#ifdef USE_FALLOFF
    float4x4 u_floorMVP_i;
    float4 u_floorPlane;
    float u_floorFalloff;
#ifdef USE_FALLOFF_START
    float u_floorFalloffStart;
#endif
#endif
static inline float3 floorUnprojectPoint(float3 screenPos, float4x4 mvp_i)
    float4 pTmp = mvp_i * float4(screenPos.xy * 2.0 - 1.0, screenPos.z, 1.0);
    return pTmp.xyz / pTmp.w;
#pragma arguments
scn_floor scn_floorSurf
texture2d_layer u_floorReflectionColor;
depth2d u_floorReflectionDepth;
#pragma body
float2 normalizedFragCoord =  scn_floorSurf.u_floor_viewport.xy + in.fragmentPosition.xy * scn_floorSurf.u_floor_viewport.zw;
normalizedFragCoord.xy += 0.2 * _surface._normalTS.xy;
constexpr sampler linear_sampler(filter::linear);
float4 floorColor = u_floorReflectionColor.sampleLayer(linear_sampler, normalizedFragCoord);
float reflectionFactor = scn_floorSurf.u_floorReflectivity;
#ifdef USE_FALLOFF
float floorDepth = u_floorReflectionDepth.sample(linear_sampler, normalizedFragCoord);
float3  floorPW = floorUnprojectPoint(float3(normalizedFragCoord.x, 1. - normalizedFragCoord.y, floorDepth), scn_floorSurf.u_floorMVP_i);
float floorDist = -dot(floorPW.xyz, scn_floorSurf.u_floorPlane.xyz) - scn_floorSurf.u_floorPlane.w;;
#ifdef USE_FALLOFF_START
floorDist -= scn_floorSurf.u_floorFalloffStart; 
#endif 
reflectionFactor *= 1.0 - clamp(floorDist / scn_floorSurf.u_floorFalloff, 0.0, 1.0);
#endif 
floorColor *= reflectionFactor; 
_output.color.rgb *= (1. - floorColor.a); 
_output.color.rgba += floorColor.rgba; 
C3DShaderModifier
v8@?0
view
normalTexcoord
tangent
bitangent
ambient
ambientTexcoord
diffuse
diffuseTexcoord
specular
specularTexcoord
emission
emissionTexcoord
selfIllumination
selfIlluminationTexcoord
multiply
multiplyTexcoord
transparent
transparentTexcoord
displacement
displacementTexcoord
clearCoat
clearCoatTexcoord
clearCoatRoughness
clearCoatRoughnessTexcoord
clearCoatNormal
clearCoatNormalTexcoord
reflective
fresnel
_surface.%@
u_%@Texture
USE_%@_MAP
_geometry.normal
_geometry.tangent
_geometry.color
_geometry.clipDistance0
_geometry.clipDistance1
_geometry.clipDistance2
_geometry.clipDistance3
USE_NORMAL
USE_CLIP_DISTANCE0
USE_CLIP_DISTANCE2
_framebuffer
_framebuffer.color
USE_MODIFIER_FRAMEBUFFER
iModifier
v24@?0r^v8r^v16
<C3DShaderModifier %p language:%s, entryPoint:"%d" flags:%x
Metal
GLSL
  declaration : %@
  arguments : %@
  varyings : %@
  code : %@
newDefines
USE_EMISSIVETEXCOORD
USE_AMBIENTTEXCOORD
USE_DIFFUSETEXCOORD
USE_SPECULARTEXCOORD
USE_REFLECTIVETEXCOORD
USE_TRANSPARENTTEXCOORD
USE_FILTERTEXCOORD
USE_NORMALTEXCOORD
USE_METALNESSTEXCOORD
USE_ROUGHNESSTEXCOORD
USE_CLEARCOATTEXCOORD
USE_CLEARCOATROUGHNESSTEXCOORD
USE_CLEARCOATNORMALTEXCOORD
_geometry.texcoords[x]
u_%@TextureMatrix
{_SCNVector4=dddd}
{_SCNVector3=ddd}
is%@%@
v@:^v
^v@:
v@:f
v@:i
v@:B
v@:c
v@:d
v@:{CGPoint=dd}
{CGPoint=dd}@:
v@:{SCNVector3=ddd}
{SCNVector3=ddd}@:
v@:{SCNVector4=dddd}
{SCNVector4=dddd}@:
v@:{SCNMatrix4=dddddddddddddddd}
{SCNMatrix4=dddddddddddddddd}@:
v@:{CATransform3D=dddddddddddddddd}
{CATransform3D=dddddddddddddddd}@:
v@:{C3DMatrix3x3=ddddddddd}
{C3DMatrix3x3=ddddddddd}@:
v@:{C3DColor4=ffff}
{C3DColor4=ffff}@:
v@:s
v@:C
v@:S
constraint
constraintController
C3DConstraintController
C3DConstraintConstantScale
C3DConstraintProcedural
<C3DConstraintController>
C3DConstraint
<C3DConstraint %@ %p>
influenceFactor
C3DConstraintLookAt
<C3DConstraintLookAt %p>
targetOffset
worldUp
localFront
C3DConstraintBillboard
<C3DConstraintBillboard %p>
<C3DConstraintConstantScale>
<C3DConstraintProcedural>
C3DConstraintIK
<C3DConstraintIK %p>
targetPosition
C3DConstraintDistance
<C3DConstraintDistance>
maximumDistance
C3DConstraintAcceleration
maximumLinearAcceleration
maximumLinearVelocity
decelerationDistance
C3DConstraintReplicator
<C3DConstraintReplicator>
orientationOffset
positionOffset
scaleOffset
C3DConstraintManager
<C3DConstraintManagerRef>
__controller
superClass
_currentClassRegistry
CFDictionaryGetCountOfKey(_currentClassRegistry, propertyName) == 0
prefix
indexString
GenerateMipmapPass
C3DModelTarget
<C3DModelTarget>
ControllerAnimation
ControllerVariableMode
ControllerVariableOverLife
ControllerVariableOverDistance
ControllerVariableOverOtherProperty
ControllerVariableOrigin
ControllerVariableScale
ControllerVariableBias
C3DParticleSystem
<C3DParticleSystemRef>
InvLifeSpan
BirthTime
SortingIndices
Mass
TempData
EventIndex
C3DModelValueStorageItem
item
C3DModelValueStorage
item->_getter
item->_setter
CFGetTypeID(target->_owner) == C3DNodeGetTypeID()
aValue
<C3DModelValueStorageItem %p>
<C3DModelValueStorage>
incremental
gimbalLockEnabled
upVector
targetDirection
replicatesOrientation
replicatesScale
replicatesPosition
collisionCategoryBitMask
bias
freeAxes
preserveScale
v36@?0^{__C3DConstraint={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__CFString}fBB{?=^?^?^?^?^?^?}^v}8^v16^{__C3DModelTarget={__CFRuntimeBase=QAQ}^v^vscCCB^?^?}24f32
node%d
angle%d
ikTarget
chainRootNode
C3DAnimationEvents
events
events->_eventCount < events->_eventCapacity
<C3DAnimationEvents>
t0 <= t1
index < events->_eventCount
C3DRendererElementStore
node == NULL || node->_rendererElementSpan.count == 0 || renderableHash & kC3DRenderableAttributeHashParticleSystem
node->_rendererLOD->count == count
index < (CFIndex)span.count
<C3DRendererElementStore %p>
C3DIndexStore
indexStore
<C3DIndexStore>
alignedIndex >= 0 && alignedIndex < bufferLength
copy_no_alpha_depth_texture
copy_no_alpha_uint_texture
copy_no_alpha_texture
addDependency
C3DRenderGraph.mm
_renderGraph->size() > n1
_renderGraph->size() > n2
n1Port == kPartialDependencyPort || node1.pass->descriptor().inputCount() > n1Port
n2Port == kPartialDependencyPort || node2.pass->descriptor().outputCount() > n2Port
a->identifier() != kInvalidPass
b->identifier() != kInvalidPass
(*_renderGraph).size() > n1
(*_renderGraph).size() > n2
v16@?0^{__C3DLight=}8
simd_all(viewport != -1)
output.textureDesc.sampleCount != 1
nextInput.textureDesc.sampleCount != 1
_graphDescription
%@/%s_%d.tiff
no_name
imagePath
attachmentID < 255
outputResource->type == output.type
stages
outputDesc
%d-i-%d
%d-o-%d
links
addPass
passIndex < 32767
res->poolSubBuffer.buffer
res->texture
param.attachmentType == TextureAttachmentType::Color
resolveParam->textureDesc.sampleCount == 0 || resolveParam->textureDesc.sampleCount == 1
!SCNMTLTextureTypeIsMultisampled((MTLTextureType)resolveParam->textureDesc.textureType)
res->resolveTexture
sort
_renderGraph->size() < 32767
!_stageFirst->passes.empty()
index == 0 || inputPorts[index].a != inputPorts[index - 1].a
!portsPairs.empty()
strlen(inputParam.name) != 0
outputParam
inputParam.type == outputParam->type
res->usedCount >= 0
node.resource().outputCount() == node.descriptor().outputCount()
resOutput == nullptr
resInput
resDestination == outputRes
inputRes
!outputResDesc.usedInternally
Clear drawable
SpriteKit transition
renderEncoder
linked to : %s slot %d (%s)
%s %s slot %d (%s)
texture.storageMode == MTLStorageModeManaged
Allocator::_allocator
initial_capacity || _capacity == 0
a._capacity == initial_capacity
PickedObjectPass
COLOR_PICKED
DEPTH_PICKED
dstParticles != srcParticles
invLifeSpanArray
C3DParticleSystemInstance
v16@?0Q8
<C3DParticleSystemInstanceRef>
offset < 4
size == sizeof(C3DFloat)
_affineValid(t)
!_matrixValid(t)
_matrixValid(t)
!_affineValid(t)
C3DAllocator
<C3DAllocator>
address < (void*) ((unsigned char*)controller+sizeof(struct __C3DAnimatableParamController))
C3DAnimatableParamController
<C3DAnimatableParamController>
pname
C3DProgramHashCodeStore
v24@?0Q8r^v16
programIndex < 0xffffffff
<C3DProgramHashCodeStore %p>
cullingContext->eyeCount == 2
passInstance->_cullingData[eye] == NULL
cullingContext->scene
C3DKeyValueStore
<C3DKeyValueStore>
SCNProgramDidChangeNotification
parameter
vertexFunctionName
sourceFile
fragmentFunctionName
semanticInfos
SCNShaderModifierEntryPointGeometry
SCNShaderModifierEntryPointSurface
SCNShaderModifierEntryPointFragment
SCNShaderModifierEntryPointLightingModel
_owner == nil
^v16@?0^v8
v32@?0@"NSString"8@"SCNBufferBinding"16*24
v24@?0i8^{__CFString=}12c20
owner
minimumLanguageVersion
SCNShadableDidCompileNotificationName
issues
%@ // [SCN_%@(%d)]
C3DArray
index < C3DArrayGetCount(array)
<C3DArray %p:, %d objects>
<%@ | string=%@ extrusionDepth=%.3f> 
-[SCNText set_wantsSeparateGeometryElements:]
-[SCNText setChamferRadius:]
-[SCNText setDiscretizedStraightLineMaxLength:]
-[SCNText setExtrusionDepth:]
extrusionDepth
-[SCNText setFlatness:]
-[SCNText setPrimitiveType:]
-[SCNText setString:]
-[SCNText setWrapped:]
SFProUI
SFProText
HelveticaNeue
.AppleSystemUIFont
.SFUI
.SFNS
-[SCNText setContainerFrame:]
chamferProfile
font
alignmentMode
truncationMode
discretizedStraightLineMaxLength
wrapped
useCustomContainerFrame
customContainerFrame
_wantsSeparateGeometryElements
root_node
/System/Library/PrivateFrameworks/USDKit.framework/USDKit
../SharedFrameworks/USDKit.framework/USDKit
USKObjectPath
USKToken
USKData
USKScene
USKDataTypeResourcePath
USKDataTypeInt
USKDataTypeBool
USKDataTypeDouble3
USKDataTypeDouble4x4
USKDataTypeDouble4x4Array
USKDataTypeFloat
USKDataTypeFloat2
USKDataTypeFloat3
USKDataTypeFloat4
USKDataTypeFloat2Array
USKDataTypeFloat3Array
USKDataTypeFloatArray
USKDataTypeIntArray
USKDataTypeObjectPath
USKDataTypeObjectPathArray
USKDataTypeQuatf
USKDataTypeQuatfArray
USKDataTypeStringArray
USKDataTypeToken
USKDataTypeTokenArray
USKNodeTypeCamera
USKNodeTypeMaterial
USKNodeTypeMesh
USKNodeTypeMeshGroup
USKNodeTypeScope
USKNodeTypeShader
USKNodeTypeSkeletalAnimation
USKNodeTypeSkeleton
USKNodeTypeSkeletonRoot
USKNodeTypeBlendShape
USKNodeTypeTransform
USKRoleTypeColor
USKRoleTypeNone
USKRoleTypeNormal
USKRoleTypePoint
USKRoleTypeVector
USKRoleTypeTextureCoordinate
USKSchemaTypeBindingAPI
[^A-Za-z0-9]
SceneKit export preview %.02f
customLayerData
creator
assetInfo
kind
component
defaultPrim
metersPerUnit
startTimeCode
endTimeCode
timeCodesPerSecond
invisible
Node_
Skeleton
restTransforms
bindTransforms
skel:skeleton
subdivisionScheme
faceVertexCounts
faceVarying
extent
material:binding
_meshGroup
elementType
face
familyName
materialBind
indices
primvars:normals
primvars:st
primvars:displayColor
faceVertexIndices
primvars:normals:indices
primvars:st:indices
primvars:displayColor:indices
Material_
surfaceShader
info:id
UsdPreviewSurface
outputs:surface
emissiveColor
occlusion
Materials
texgen_%lu.png
texgen_%lu
@"NSString"24@?0@"NSString"8@?<c@?@"NSString">16
c16@?0@"NSString"8
inputs:
_texCoordReader
UsdPrimvarReader_float2
outputs:result
inputs:varname
inputs:frame:stPrimvarName
_transform2D
sdrMetadata
role
math
UsdTransform2d
inputs:in
inputs:rotation
inputs:scale
inputs:translation
_texture
UsdUVTexture
inputs:bias
inputs:file
inputs:st
inputs:wrapS
inputs:wrapT
inputs:minFilter
inputs:magFilter
outputs:
blendShape
BlendShape
pointIndices
skel:blendShapes
skel:blendShapeTargets
offsets
normalOffsets
projection
horizontalAperture
verticalAperture
clippingRange
xformOp:transform
xformOp:translate
xformOp:orient
rotation.euler
xformOp:rotate
xformOp:rotateXYZ
xformOp:scale
xformOp:rotateX
xformOp:rotateY
xformOp:rotateZ
xformOpOrder
Geom
blendShapeWeights
skel:animationSource
blendShapes
primvars:skel:jointWeights
elementSize
primvars:skel:jointIndices
primvars:skel:geomBindTransform
translations
rotations
scales
baseGeometryMeshlessPositionSource
maxMorphTargetCount > 0
-[SCNMTLMorphDeformer setupMorphTargetsWithComputeContext:]
SCNMTLMorphDeformer.mm
_finalMeshDataKind == _dataKindForComputeKernel
baseNormalSource
-[SCNMTLMorphDeformer setupMorphTargetsWithComputeContext:]_block_invoke
morphUsesSparseTargets == false
originalNormalSource
vertexCount == _vertexCountForComputeKernel
vertexBufferOffset == vertexBufferLength
sparseIndicesBufferOffset == sparseIndicesBufferLength
morphNormal
copy_generic
copy_indexed_u8_generic
blend_indexed_u8_generic
copy_indexed_u16_generic
blend_indexed_u16_generic
copy_indexed_u32_generic
blend_indexed_u32_generic
blend_generic
splat_indexed_s8_vertices
splat_indexed_s16_vertices
splat_indexed_s32_vertices
blend_inc_init_8x_pn_kernel
blend_inc_add_8x_pn_kernel
blend_inc_init_8x_p_kernel
blend_inc_add_8x_p_kernel
dstForWriting == dst + length
writtenIndexCount == runtimeTarget->vertexCount
weightCount == _morphTargetCount
SSRDepthBackFacePass
--SSRBackFaceMaterial--
C3DWrapDeformerComputeBindingPointIndicesAndBarycentricCoordsFromUVs
SCNGeometryWrapDeformerUtils.mm
doneIndicesCount == vertexCount
C3DWrapDeformerComputeSharedBindingPointIndicesAndBarycentricCoordsFromSandwichedPositions_block_invoke_2
__bindToUV_block_invoke
__computeBarycentricCoordinates2D
__adjustDistanceByAligningProjection
CopyTextureBlitPass
CopyTextureComputePass
texturecube_slices_copy_kernel
texturecube_copy_kernel
texturecube_copy_resample_kernel
texture2d_copy_kernel
texture2d_copy_resample_kernel
descriptor().renderStartIndex == 0
srcElementType == dstElementType
CopyTextureRenderPass
<%@ | path=%@ extrusionDepth=%.3f> 
-[SCNShape setChamferMode:]
-[SCNShape setChamferRadius:]
-[SCNShape setDiscretizedStraightLineMaxLength:]
-[SCNShape setExtrusionDepth:]
-[SCNShape setPrimitiveType:]
chamferMode
C3DShape
<C3DShape '%@'>
C3DShapeGeometryValidate
C3DShapeGeometry.m
CFGetTypeID(geometry) == C3DShapeGeometryGetTypeID()
newMesh
shapeGeometry
Helvetica
C3DShapeGeometryMeshForBoundingBox
^{__C3DMesh=}8@?0
C3DShapeGeometryGetBoundingBox
C3DShapeGeometryGetBoundingSphere
C3DShapeGeometry
C3DTextGeometry
scn_generate_grain
levelOfDetail <%p>: geometry:%@ threshold:%f useDistance:%d
mode
C3DNodeGetLight(_drawNodesParameters.pointOfView)
PROBE
RenderProbePass
CFDictionaryGetValue(dic, uniformName) == NULL
mat2x3
scn_frame.invScreenPixelSize
SceneKit_downSample4x
SceneKit_DOF_blurCoc_H
SceneKit_DOF_blurCoc_V
SceneKit_blurColor4x_H
SceneKit_blurColor4x_V
C3D-dof-lerpBias
C3D-dof-lerpScale
C3D-dof-cocScaleBias
C3D-dof-invertPixelSize
scnasset
.scnassets
baseTangentSource
_finalDataKind == kC3DMeshDataKindOriginal && subdivIsUsed
UInt%d-%d-%d
deformer_splat
_meshlessDeformer
info.wantsFinalNormalsBuffer == false
info.wantsFinalTangentsBuffer == false
orig < originalVertexCount
prov < deindexedVertexCount
-[SCNMTLDeformerStack reconfigureIfNeededWithContext:programHashCodeRequirements:]
SCNMTLDeformerStack.mm
wantsDrawIndirect == NO
^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}12@?0C8
-[SCNMTLDeformerStack reconfigureIfNeededWithContext:programHashCodeRequirements:]_block_invoke_2
-[SCNMTLDeformerStack reconfigureIfNeededWithContext:programHashCodeRequirements:]_block_invoke
_finalMesh != nil
[dependencyDeformerStack computeDeformedMeshReliesOnTransforms] == NO
[dependencyDeformerStack computeDeformedMeshReliesOnFrustum] == NO
@"<MTLComputeCommandEncoder>"8@?0
buffer != nil
-[SCNMTLDeformerStack dependencyBufferForInput:dependencyMesh:]
buffers->dependency0Positions
buffers->dependency0Normals
buffers->dependency0Tangents
buffers->dependency1Positions
buffers->dependency1Normals
buffers->dependency1Tangents
_configureStageInputOutputDescriptorWithDeformerFunction
info.isActive
btOptimizedBvhNodeData
btQuantizedBvhNodeData
btBvhSubtreeInfoData
btQuantizedBvhFloatData
btCollisionObjectFloatData
Overflow in AABB, object removed from simulation
If you can reproduce this, please email bugs@continuousphysics.com
Please include above information, your Platform, version of OS.
Thanks.
Triangle
btConvexInternalShapeData
Box2d
btTriangleMeshShapeData
BVHTRIANGLEMESH
CapsuleShape
btCapsuleShapeData
btCollisionShapeData
btCompoundShapeChildData
btCompoundShapeData
Compound
btVector3FloatData
btConvexHullShapeData
Convex
ConvexTrimesh
CylinderY
btCylinderShapeData
btPositionAndRadius
btMultiSphereShapeData
MultiSphere
SPHERE
STATICPLANE
btStaticPlaneShapeData
btIntIndexData
btShortIntIndexTripletData
btCharIndexTripletData
btVector3DoubleData
btMeshPartData
btStridingMeshInterfaceData
TRIANGLEMESH
btConeTwistConstraintData
btHingeConstraintFloatData
btPoint2PointConstraintFloatData
btSliderConstraintData
btTypedConstraintData
btDynamicsWorldFloatData
btRigidBodyFloatData
completeTopologyFromFaceValues
fvarLevel.cpp
vSpan._size != 0
getVertexEdgeValues
edgeTopologyMatches(eIndex)
getFaceValueTags
_vertValueIndices[srcValueIndex] == faceValues[i]
getFaceCompositeValueTag
bilinear
catmark
loop
AddWithWeight
stencilBuilder.cpp
_sources[i] < _coarseVertCount
patchTableFactory.cpp
IsPatchEligible
fVerts.size() == 4
GetRegularPatchBoundaryMask
eBoundaryMask != -1
computePatchParam
ptexIndex!=-1
createUniform
refiner.IsUniform()
ptype!=PatchDescriptor::NON_PATCH
npatches>=0
(levelVertOffset + fvalues[vert]) < (int)table->getFVarValues(fvc).size()
createAdaptive
! refiner.IsUniform()
populateAdaptivePatches
"Unknown Descriptor for FVar patch" == 0
identifyNonManifoldCornerSpan
vSpan._numFaces == 1
getPatchIndex
patchTable.cpp
patchIndex<pa.numPatches
getPatchArrayVertices
pa.vertIndex<(Index)_patchVerts.size()
GetPatchArrayVertices
GetPatchVertices
(pa.vertIndex + patchIndex*size)<(Index)_patchVerts.size()
getFVarPatchChannel
channel>=0 && channel<(int)_fvarChannels.size()
getPatchArray
arrayIndex<(Index)GetNumPatchArrays()
Failure in TopologyRefinerFactory<>::Create() -- mesh contains no vertices.
Failure in TopologyRefinerFactory<>::Create() -- meshes without faces not yet supported.
Failure in TopologyRefinerFactory<>::Create() -- face with %d vertices > %d max.
Failure in TopologyRefinerFactory<>::Create() -- mesh contains no face-vertices.
Failure in TopologyRefinerFactory<>::Create() -- non-triangular faces not supported by Loop scheme.
prepareComponentTopologySizing
topologyRefinerFactory.cpp
baseLevel.getNumFaceEdgesTotal() > 0
baseLevel.getNumEdgeVerticesTotal() > 0
baseLevel.getNumEdgeFacesTotal() > 0
baseLevel.getNumVertexFacesTotal() > 0
baseLevel.getNumVertexEdgesTotal() > 0
Failure in TopologyRefinerFactory<>::Create() -- vertex with valence %d > %d max.
Failure in TopologyRefinerFactory<>::Create() -- maximum valence not assigned.
Failure in TopologyRefinerFactory<>::Create() -- invalid topology detected from partial specification.
Failure in TopologyRefinerFactory<>::Create() -- invalid topology detected as fully specified.
prepareComponentTagsAndSharpness
(schemeRegularInteriorValence == 4) || (schemeRegularInteriorValence == 6)
Failure in TopologyRefinerFactory<>::Create() -- face-varying channel %d has no values.
GetFaceId
ptexIndices.cpp
f<(int)_ptexIndices.size()
FindIndexIn4Tuple
array.h
_size>=4
"FindIndexIn4Tuple() did not find expected value!" == 0
Create
mtlPatchTable.mm
0 && "MTLPatchTable Creation Failed"
OSD PatchIndexBuffer
OSD PatchParamBuffer
MISSING_EDGE_FACES
MISSING_EDGE_VERTS
MISSING_FACE_EDGES
MISSING_FACE_VERTS
MISSING_VERT_FACES
MISSING_VERT_EDGES
FAILED_CORRELATION_FACE_VERT
FAILED_CORRELATION_FACE_EDGE
FAILED_ORIENTATION_INCIDENT_EDGE
FAILED_ORIENTATION_INCIDENT_FACE
FAILED_ORIENTATION_INCIDENT_FACES_EDGES
DEGENERATE_EDGE
NON_MANIFOLD_EDGE
level.cpp
%s - missing face-verts
%s - missing vert-faces
%s - face %d correlation of vert %d failed
%s - missing edge-faces
%s - missing face-edges
%s - face %d correlation of edge %d failed
%s - missing edge-verts
%s - missing vert-edges
%s - edge %d correlation of vert %d failed
%s - vertex %d cannot orient incident faces and edges
%s - vertex %d orientation failure at incident face %d
%s - vertex %d orientation failure at incident edge %d
%s - Error in eIndex = %d:  degenerate edge not tagged marked non-manifold
%s - edge %d with %d incident faces not tagged non-manifold
gatherQuadRegularPartialRingAroundVertex
! level.isVertexNonManifold(vIndex)
(0 <= rotation) && (rotation < 4)
gatherQuadRegularInteriorPatchPoints
gatherQuadRegularBoundaryPatchPoints
(boundaryFaceInV0Faces >= 0) && (boundaryFaceInV1Faces >= 0)
gatherQuadRegularCornerPatchPoints
cornerFaceInIntVertFaces >= 0
completeTopologyFromFaceVertices
(vCount > 0) && (fCount > 0) && (eCount == 0)
_maxValence > 0
orderVertexFacesAndEdges
fCountOrdered == fCount
MTLStencilTable
mtlComputeEvaluator.mm
context != nil
context->device != nil && context->commandQueue != nil
StencilTable Sizes
StencilTable Offsets
StencilTable Indices
StencilTable Weights
Compile
Using OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES
LENGTH
SRC_STRIDE
DST_STRIDE
WORK_GROUP_SIZE
OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES
PARAMETER_BUFFER_INDEX
SIZES_BUFFER_INDEX
OFFSETS_BUFFER_INDEX
WEIGHTS_BUFFER_INDEX
SRC_VERTEX_BUFFER_INDEX
DST_VERTEX_BUFFER_INDEX
DU_WEIGHTS_BUFFER_INDEX
DV_WEIGHTS_BUFFER_INDEX
DU_DERIVATIVE_BUFFER_INDEX
DV_DERIVATIVE_BUFFER_INDEX
PATCH_ARRAYS_BUFFER_INDEX
PATCH_COORDS_BUFFER_INDEX
PATCH_PARAMS_BUFFER_INDEX
Error compiling MTL Shader: %s
eval_stencils
Error compiling MTL Pipeline eval_stencils: %s
eval_patches
Error compiling MTL Pipeline eval_patches:  %s
EvalStencils
context != nullptr
device != nil && commandQueue != nil
#line 0 "osd/mtlComputeKernel.metal"
//   Copyright 2015 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
#include <metal_stdlib>
#ifndef OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES
#define OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES 0
#endif
using namespace metal;
struct PatchCoord
    int arrayIndex;
    int patchIndex;
    int vertIndex;
    float s;
    float t;
struct PatchParam
    uint field0;
    uint field1;
    float sharpness;
struct KernelUniformArgs
int batchStart;
int batchEnd;
    int srcOffset;
int dstOffset;
    int3 duDesc;
    int3 dvDesc;
struct Vertex {
    float vertexData[LENGTH];
void clear(thread Vertex& v) {
    for (int i = 0; i < LENGTH; ++i) {
        v.vertexData[i] = 0;
    }
Vertex readVertex(int index, device float* vertexBuffer, KernelUniformArgs args) {
    Vertex v;
    int vertexIndex = args.srcOffset + index * SRC_STRIDE;
    for (int i = 0; i < LENGTH; ++i) {
        v.vertexData[i] = vertexBuffer[vertexIndex + i];
    }
    return v;
void writeVertex(int index, Vertex v, device float* vertexBuffer, KernelUniformArgs args) {
    int vertexIndex = args.dstOffset + index * DST_STRIDE;
    for (int i = 0; i < LENGTH; ++i) {
        vertexBuffer[vertexIndex + i] = v.vertexData[i];
    }
void writeVertexSeparate(int index, Vertex v, device float* dstVertexBuffer, KernelUniformArgs args) {
    int vertexIndex = args.dstOffset + index * DST_STRIDE;
    for (int i = 0; i < LENGTH; ++i) {
        dstVertexBuffer[vertexIndex + i] = v.vertexData[i];
    }
void addWithWeight(thread Vertex& v, const Vertex src, float weight) {
    for (int i = 0; i < LENGTH; ++i) {
        v.vertexData[i] += weight * src.vertexData[i];
    }
void writeDu(int index, Vertex du, device float* duDerivativeBuffer, KernelUniformArgs args)
    int duIndex = args.duDesc.x + index * args.duDesc.z;
    for(int i = 0; i < LENGTH; i++)
    {
        duDerivativeBuffer[duIndex + i] = du.vertexData[i];
    }
void writeDv(int index, Vertex dv, device float* dvDerivativeBuffer, KernelUniformArgs args)
    int dvIndex = args.dvDesc.x + index * args.dvDesc.z;
    for(int i = 0; i < LENGTH; i++)
    {
        dvDerivativeBuffer[dvIndex + i] = dv.vertexData[i];
    }
// ---------------------------------------------------------------------------
kernel void eval_stencils(
    uint thread_position_in_grid [[thread_position_in_grid]],
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    const device uint8_t* sizes [[buffer(SIZES_BUFFER_INDEX)]],
    const device int* offsets [[buffer(OFFSETS_BUFFER_INDEX)]],
    const device uint16_t* indices [[buffer(INDICES_BUFFER_INDEX)]],
    const device half* weights [[buffer(WEIGHTS_BUFFER_INDEX)]],
#else
    const device int* sizes [[buffer(SIZES_BUFFER_INDEX)]],
    const device int* offsets [[buffer(OFFSETS_BUFFER_INDEX)]],
    const device int* indices [[buffer(INDICES_BUFFER_INDEX)]],
    const device float* weights [[buffer(WEIGHTS_BUFFER_INDEX)]],
#endif
    device float* srcVertices [[buffer(SRC_VERTEX_BUFFER_INDEX)]],
    device float* dstVertexBuffer [[buffer(DST_VERTEX_BUFFER_INDEX)]],
    const device float* duWeights [[buffer(DU_WEIGHTS_BUFFER_INDEX)]],
    const device float* dvWeights [[buffer(DV_WEIGHTS_BUFFER_INDEX)]],
    device float* duDerivativeBuffer [[buffer(DU_DERIVATIVE_BUFFER_INDEX)]],
    device float* dvDerivativeBuffer [[buffer(DV_DERIVATIVE_BUFFER_INDEX)]],
    const constant KernelUniformArgs& args [[buffer(PARAMETER_BUFFER_INDEX)]]
    auto current  = thread_position_in_grid + args.batchStart;
    if(current >= args.batchEnd)
        return;
    Vertex dst;
    clear(dst);
    auto offset = offsets[current];
    auto size = sizes[current];
    for(auto stencil = 0; stencil < size; stencil++)
    {
        auto vindex = offset + stencil;
        addWithWeight(dst, readVertex(indices[vindex], srcVertices, args), weights[vindex]);
    }
    writeVertex(current, dst, dstVertexBuffer, args);
#if OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES
    Vertex du, dv;
    clear(du);
    clear(dv);
    for(auto i = 0; i < size; i++)
    {
        auto src = readVertex(indices[offset + i], srcVertices, args);
        addWithWeight(du, src, duWeights[offset + i]);
        addWithWeight(dv, src, dvWeights[offset + i]);
    }
    writeDu(current, du, duDerivativeBuffer, args);
    writeDv(current, dv, dvDerivativeBuffer, args);
#endif
// ---------------------------------------------------------------------------
// PERFORMANCE: stride could be constant, but not as significant as length
//struct PatchArray {
//    int patchType;
//    int numPatches;
//    int indexBase;        // an offset within the index buffer
//    int primitiveIdBase;  // an offset within the patch param buffer
//};
// # of patcharrays is 1 or 2.
uint getDepth(uint patchBits) {
    return (patchBits & 0xf);
float getParamFraction(uint patchBits) {
    uint nonQuadRoot = (patchBits >> 4) & 0x1;
    uint depth = getDepth(patchBits);
    if (nonQuadRoot == 1) {
        return 1.0f / float( 1 << (depth-1) );
    } else {
        return 1.0f / float( 1 << depth );
    }
float2 normalizePatchCoord(uint patchBits, float2 uv) {
    float frac = getParamFraction(patchBits);
    uint iu = (patchBits >> 22) & 0x3ff;
    uint iv = (patchBits >> 12) & 0x3ff;
    // top left corner
    float pu = float(iu*frac);
    float pv = float(iv*frac);
    // normalize u,v coordinates
    return float2((uv.x - pu) / frac, (uv.y - pv) / frac);
bool isRegular(uint patchBits) {
    return (((patchBits >> 5) & 0x1u) != 0);
int getNumControlVertices(int patchType) {
    switch(patchType) {
        case 3: return 4;
        case 6: return 16;
        case 9: return 20;
        default: return 0;
    }
// ---------------------------------------------------------------------------
kernel void eval_patches(
                         uint thread_position_in_grid [[thread_position_in_grid]],
                         const constant uint4* patchArrays [[buffer(PATCH_ARRAYS_BUFFER_INDEX)]],
                         device PatchCoord* patchCoords [[buffer(PATCH_COORDS_BUFFER_INDEX)]],
                         device int* patchIndices [[buffer(PATCH_INDICES_BUFFER_INDEX)]],
                         device PatchParam* patchParams [[buffer(PATCH_PARAMS_BUFFER_INDEX)]],
                         device float* srcVertexBuffer [[buffer(SRC_VERTEX_BUFFER_INDEX)]],
                         device float* dstVertexBuffer [[buffer(DST_VERTEX_BUFFER_INDEX)]],
                         device float* duDerivativeBuffer [[buffer(DU_DERIVATIVE_BUFFER_INDEX)]],
                         device float* dvDerivativeBuffer [[buffer(DV_DERIVATIVE_BUFFER_INDEX)]],
                         const constant KernelUniformArgs& args [[buffer(PARAMETER_BUFFER_INDEX)]]
                         )
    auto current = thread_position_in_grid;
    auto patchCoord = patchCoords[current];
    auto patchIndex = patchIndices[patchCoord.patchIndex];
    auto patchArray = patchArrays[patchCoord.arrayIndex];
    auto patchBits = patchParams[patchIndex].field1; 
    auto patchType = select(patchArray.x, uint(6), isRegular(patchBits));
    auto numControlVertices = getNumControlVertices(patchType);
    auto uv = normalizePatchCoord(patchBits, float2(patchCoord.s, patchCoord.t));
    auto dScale = float(1 << getDepth(patchBits));
    auto boundaryMask = int((patchBits >> 8) & 0xFU);
    float wP[20], wDs[20], wDt[20], wDss[20], wDst[20], wDtt[20];
    if(patchType == 3) {
        OsdGetBilinearPatchWeights(uv.x, uv.y, dScale, wP, wDs, wDt, wDss, wDst, wDtt);
    } else if(patchType == 6) {
        OsdGetBSplinePatchWeights(uv.x, uv.y, dScale, boundaryMask, wP, wDs, wDt, wDss, wDst, wDtt);
    } else if(patchType == 9) {
        OsdGetGregoryPatchWeights(uv.x, uv.y, dScale, wP, wDs, wDt, wDss, wDst, wDtt);
    }
    Vertex dst, du, dv;
    clear(dst);
    clear(du);
    clear(dv);
    auto indexBase = patchArray.z + numControlVertices * (patchCoord.patchIndex - patchArray.w);
    for(auto cv = 0; cv < numControlVertices; cv++)
    {
        auto index = patchIndices[indexBase + cv];
        auto src = readVertex(index, srcVertexBuffer, args);
        addWithWeight(dst, src, wP[cv]);
        addWithWeight(du, src, wDs[cv]);
        addWithWeight(dv, src, wDt[cv]);
    }
    writeVertex(current, dst, dstVertexBuffer, args);
#if OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES
    if(args.duDesc.y > 0)
        writeDu(current, du, duDerivativeBuffer, args);
    if(args.dvDesc.y > 0)
        writeDv(current, dv, dvDerivativeBuffer, args);
#endif
appendLocalPointStencilTable
stencilTableFactory.cpp
GetStencil
stencilTable.h
(! _offsets.empty()) && i<(int)_offsets.size()
ProtoBasis
gregoryBasis.cpp
cornerPatchFace[corner] != -1
gregoryBasis.h
_size < (int)_stencils.GetSize()
computeCoefficient
valence > 0
operator=
_size <= (int)_stencils.GetSize()
Refinement
refinement.cpp
(childArg.getDepth() == 0) && (childArg.getNumVertices() == 0)
refine
_parent && _child
populateParentToChildMapping
"Unsupported empty sparse refinement detected in Refinement" == 0
subdivideFVarChannels
_child->_fvarChannels.size() == 0
this->_fvarChannels.size() == 0
markSparseVertexChildren
_parentVertexTag.size() > 0
markSparseEdgeChildren
_parentEdgeTag.size() > 0
No Error
Fatal Error
Coding Error (internal)
Coding Error
Error
error.cpp
err!=FAR_NO_ERROR
%s: %s
Warning: %s
estimateAndAllocateChildValues
fvarRefinement.cpp
_refinement.isChildVertexComplete(cVert)
propagateValueTags
propagateValueCreases
_childFVar.hasSmoothBoundaries()
populateChildValuesForEdgeVertex
cVertFaces.size() == cVertFaceSiblings.size()
cVertFaces.size() >= cValueCount
populateChildValuesForVertexVertex
populateFaceVerticesFromParentFaces
triRefinement.cpp
pFaceVerts.size() == 3
pFaceChildren.size() == 4
populateFaceEdgesFromParentFaces
pFaceChildFaces.size() == 4
pFaceChildEdges.size() == 3
populateEdgeVerticesFromParentFaces
pFaceEdges.size() == 3
populateEdgeFacesFromParentFaces
populateVertexFacesFromParentEdges
markSparseFaceChildren
_parentFaceTag.size() > 0
fChildFaces.size() == 4
fChildEdges.size() == 3
#define OSD_METAL_OSX 1
#define OSD_PATCH_BASIS_METAL 1
#line 0 "osd/mtlPatchCommon.metal"
//   Copyright 2015 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//----------------------------------------------------------
// Patches.Common
//----------------------------------------------------------
#define offsetof_(X, Y) &(((device X*)nullptr)->Y)
#define OSD_IS_ADAPTIVE (OSD_PATCH_REGULAR || OSD_PATCH_GREGORY_BASIS || OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY)
#ifndef OSD_MAX_TESS_LEVEL
#define OSD_MAX_TESS_LEVEL 64
#endif
#ifndef OSD_NUM_ELEMENTS
#define OSD_NUM_ELEMENTS 3
#endif
#ifndef OSD_USER_VARYING_DECLARE
#define OSD_USER_VARYING_DECLARE
#endif
#ifndef OSD_USER_VARYING_DECLARE_ATTRIBUTE
#define OSD_USER_VARYING_DECLARE_ATTRIBUTE
#endif
#ifndef OSD_USER_VARYING_PER_VERTEX
#define OSD_USER_VARYING_PER_VERTEX(in, out)
#endif
#ifndef OSD_USER_VARYING_PER_CONTROL_POINT
#define OSD_USER_VARYING_PER_CONTROL_POINT(in, out)
#endif
#ifndef OSD_USER_VARYING_PER_EVAL_POINT
#define OSD_USER_VARYING_PER_EVAL_POINT(UV, a, b, c, d, out)
#endif
static_assert(sizeof(OsdInputVertexType) > 0, "OsdInputVertexType must be defined and have a float3 position member");
#if OSD_IS_ADAPTIVE
#if OSD_PATCH_GREGORY_BASIS
constant constexpr unsigned IndexLookupStride = 5;
#else 
constant constexpr unsigned IndexLookupStride = 1;
#endif
#define PATCHES_PER_THREADGROUP ((THREADS_PER_THREADGROUP * CONTROL_POINTS_PER_THREAD) / CONTROL_POINTS_PER_PATCH)
#define REAL_THREADGROUP_DIVISOR (CONTROL_POINTS_PER_PATCH / CONTROL_POINTS_PER_THREAD)
static_assert(REAL_THREADGROUP_DIVISOR % 2 == 0, "REAL_THREADGROUP_DIVISOR must be a power of 2");
static_assert(!OSD_ENABLE_SCREENSPACE_TESSELLATION || !USE_PTVS_FACTORS, "USE_PTVS_FACTORS cannot be enabled if OSD_ENABLE_SCREENSPACE_TESSELLATION is enabled");
static_assert((OSD_ENABLE_SCREENSPACE_TESSELLATION && (OSD_FRACTIONAL_ODD_SPACING || OSD_FRACTIONAL_EVEN_SPACING)) || !OSD_ENABLE_SCREENSPACE_TESSELLATION, "OSD_ENABLE_SCREENSPACE_TESSELLATION requires OSD_FRACTIONAL_ODD_SPACING or OSD_FRACTIONAL_EVEN_SPACING");
#endif
//Adjustments to the UV reparameterization can be defined here. 
#ifndef OSD_UV_CORRECTION
#define OSD_UV_CORRECTION
#endif
using namespace metal;
// ----------------------------------------------------------------------------
// Patch Parameters
// ----------------------------------------------------------------------------
// Each patch has a corresponding patchParam. This is a set of three values
// specifying additional information about the patch:
//    faceId    -- topological face identifier (e.g. Ptex FaceId)
//    bitfield  -- refinement-level, non-quad, boundary, transition, uv-offset
//    sharpness -- crease sharpness for single-crease patches
// These are stored in OsdPatchParamBuffer indexed by the value returned
// from OsdGetPatchIndex() which is a function of the current PrimitiveID
// along with an optional client provided offset.
using OsdPatchParamBufferType = packed_int3;
struct OsdPerVertexGregory {
    float3 P;
    short3 clipFlag;
    int valence;
    float3 e0;
    float3 e1;
#if OSD_PATCH_GREGORY_BOUNDARY
    int zerothNeighbor;
    float3 org;
#endif
    float3 r[OSD_MAX_VALENCE];
    OSD_USER_VARYING_DECLARE
struct OsdPerPatchVertexGregory {
    packed_float3 P;
    packed_float3 Ep;
    packed_float3 Em;
    packed_float3 Fp;
    packed_float3 Fm;
    OSD_USER_VARYING_DECLARE
//----------------------------------------------------------
// HLSL->Metal Compatibility
//----------------------------------------------------------
static inline float4 mul(float4x4 a, float4 b)
    return a * b;
static inline float3 mul(float4x4 a, float3 b)
    float3x3 m(a[0].xyz, a[1].xyz, a[2].xyz);
    return m * b;
//----------------------------------------------------------
// Patches.Common
//----------------------------------------------------------
// For now, fractional spacing is supported only with screen space tessellation
#ifndef OSD_ENABLE_SCREENSPACE_TESSELLATION
#undef OSD_FRACTIONAL_EVEN_SPACING
#undef OSD_FRACTIONAL_ODD_SPACING
#endif
struct HullVertex {
    float4 position;
#if OSD_ENABLE_PATCH_CULL
    short3 clipFlag;
#endif
    OSD_USER_VARYING_DECLARE
    float3 GetPosition() threadgroup
    {
        return position.xyz;
    }
    void SetPosition(float3 v) threadgroup
    {
    
position.xyz = v;
    }
// XXXdyu all downstream data can be handled by client code
struct OsdPatchVertex {
    float3 position;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 patchCoord; //u, v, faceLevel, faceId
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    float3 Nu;
    float3 Nv;
#endif
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    float2 vSegments;
#endif
    OSD_USER_VARYING_DECLARE
struct OsdPerPatchTessFactors {
    float4 tessOuterLo;
    float4 tessOuterHi;
struct OsdPerPatchVertexBezier {
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    packed_half3 P;
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    packed_half3 P1;
    packed_half3 P2;
#if !USE_PTVS_SHARPNESS
    half2 vSegments;
#endif
#endif
#else
    packed_float3 P;
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    packed_float3 P1;
    packed_float3 P2;
#if !USE_PTVS_SHARPNESS
    float2 vSegments;
#endif
#endif
#endif //C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    OSD_USER_VARYING_DECLARE
struct OsdPerPatchVertexGregoryBasis {
    packed_float3 P;
    OSD_USER_VARYING_DECLARE
#if OSD_PATCH_REGULAR
using PatchVertexType = HullVertex;
using PerPatchVertexType = OsdPerPatchVertexBezier;
#elif OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY
using PatchVertexType = OsdPerVertexGregory;
using PerPatchVertexType = OsdPerPatchVertexGregory;
#elif OSD_PATCH_GREGORY_BASIS
using PatchVertexType = HullVertex;
using PerPatchVertexType = OsdPerPatchVertexGregoryBasis;
#else
using PatchVertexType = OsdInputVertexType;
using PerPatchVertexType = OsdInputVertexType;
#endif
//Shared buffers used by OSD that are common to all kernels
struct OsdPatchParamBufferSet
const device OsdInputVertexType* vertexBuffer [[buffer(VERTEX_BUFFER_INDEX)]];
const device unsigned* indexBuffer [[buffer(CONTROL_INDICES_BUFFER_INDEX)]];
const device OsdPatchParamBufferType* patchParamBuffer [[buffer(OSD_PATCHPARAM_BUFFER_INDEX)]];
device PerPatchVertexType* perPatchVertexBuffer [[buffer(OSD_PERPATCHVERTEXBEZIER_BUFFER_INDEX)]];
#if !USE_PTVS_FACTORS    
    device OsdPerPatchTessFactors* patchTessBuffer [[buffer(OSD_PERPATCHTESSFACTORS_BUFFER_INDEX)]];
#endif
#if OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY
const device int* quadOffsetBuffer [[buffer(OSD_QUADOFFSET_BUFFER_INDEX)]];
const device int* valenceBuffer [[buffer(OSD_VALENCE_BUFFER_INDEX)]];
#endif
const constant unsigned& kernelExecutionLimit [[buffer(OSD_KERNELLIMIT_BUFFER_INDEX)]];
//Shared buffers used by OSD that are common to all PTVS implementations
struct OsdVertexBufferSet
const device OsdInputVertexType* vertexBuffer [[buffer(VERTEX_BUFFER_INDEX)]];
const device unsigned* indexBuffer [[buffer(CONTROL_INDICES_BUFFER_INDEX)]];
const device OsdPatchParamBufferType* patchParamBuffer [[buffer(OSD_PATCHPARAM_BUFFER_INDEX)]];
device PerPatchVertexType* perPatchVertexBuffer [[buffer(OSD_PERPATCHVERTEXBEZIER_BUFFER_INDEX)]];
#if !USE_PTVS_FACTORS    
    device OsdPerPatchTessFactors* patchTessBuffer [[buffer(OSD_PERPATCHTESSFACTORS_BUFFER_INDEX)]];
#endif
// ----------------------------------------------------------------------------
// Patch Parameters Accessors
// ----------------------------------------------------------------------------
static int3 OsdGetPatchParam(int patchIndex, const device OsdPatchParamBufferType* osdPatchParamBuffer)
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    return int3(osdPatchParamBuffer[patchIndex]);
#else
    auto p = osdPatchParamBuffer[patchIndex];
    return int3(p[0], p[1], 0);
#endif
static int OsdGetPatchIndex(int primitiveId)
    return primitiveId;
static int OsdGetPatchFaceId(int3 patchParam)
    return (patchParam.x & 0xfffffff);
static int OsdGetPatchFaceLevel(int3 patchParam)
    return (1 << ((patchParam.y & 0xf) - ((patchParam.y >> 4) & 1)));
static int OsdGetPatchRefinementLevel(int3 patchParam)
    return (patchParam.y & 0xf);
static int OsdGetPatchBoundaryMask(int3 patchParam)
    return ((patchParam.y >> 8) & 0xf);
static int OsdGetPatchTransitionMask(int3 patchParam)
    return ((patchParam.x >> 28) & 0xf);
static int2 OsdGetPatchFaceUV(int3 patchParam)
    int u = (patchParam.y >> 22) & 0x3ff;
    int v = (patchParam.y >> 12) & 0x3ff;
    return int2(u,v);
static bool OsdGetPatchIsRegular(int3 patchParam)
    return ((patchParam.y >> 5) & 0x1) != 0;
static float OsdGetPatchSharpness(int3 patchParam)
    return as_type<float>(patchParam.z);
static float OsdGetPatchSingleCreaseSegmentParameter(int3 patchParam, float2 uv)
    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);
    float s = 0;
    if ((boundaryMask & 1) != 0) {
        s = 1 - uv.y;
    } else if ((boundaryMask & 2) != 0) {
        s = uv.x;
    } else if ((boundaryMask & 4) != 0) {
        s = uv.y;
    } else if ((boundaryMask & 8) != 0) {
        s = 1 - uv.x;
    }
    return s;
// ----------------------------------------------------------------------------
static void OsdUnivar4x4(float u, thread float* B)
    float t = u;
    float s = 1.0f - u;
    
    float A0 = s * s;
    float A1 = 2 * s * t;
    float A2 = t * t;
    
    B[0] = s * A0;
    B[1] = t * A0 + s * A1;
    B[2] = t * A1 + s * A2;
    B[3] = t * A2;
static void OsdUnivar4x4(float u, thread float* B, thread float* D)
    float t = u;
    float s = 1.0f - u;
    float A0 = s * s;
    float A1 = 2 * s * t;
    float A2 = t * t;
    B[0] = s * A0;
    B[1] = t * A0 + s * A1;
    B[2] = t * A1 + s * A2;
    B[3] = t * A2;
    D[0] =    - A0;
    D[1] = A0 - A1;
    D[2] = A1 - A2;
    D[3] = A2;
static void OsdUnivar4x4(float u, thread float* B, thread float* D, thread float* C)
    float t = u;
    float s = 1.0f - u;
    float A0 = s * s;
    float A1 = 2 * s * t;
    float A2 = t * t;
    B[0] = s * A0;
    B[1] = t * A0 + s * A1;
    B[2] = t * A1 + s * A2;
    B[3] = t * A2;
    D[0] =    - A0;
    D[1] = A0 - A1;
    D[2] = A1 - A2;
    D[3] = A2;
    A0 =   - s;
    A1 = s - t;
    A2 = t;
    C[0] =    - A0;
    C[1] = A0 - A1;
    C[2] = A1 - A2;
    C[3] = A2;
// ----------------------------------------------------------------------------
static float3 OsdEvalBezier(float3 cp[16], float2 uv)
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    float B[4], D[4];
    OsdUnivar4x4(uv.x, B, D);
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            float3 A = cp[4*i + j];
            BUCP[i] += A * B[j];
        }
    }
    float3 P = float3(0,0,0);
    OsdUnivar4x4(uv.y, B, D);
    for (int k=0; k<4; ++k) {
        P += B[k] * BUCP[k];
    }
    return P;
static bool OsdCullPerPatchVertex(
threadgroup PatchVertexType* patch, 
float4x4 ModelViewMatrix
#if OSD_ENABLE_BACKPATCH_CULL && OSD_PATCH_REGULAR
    auto v0 = float3(ModelViewMatrix * patch[5].position);
    auto v3 = float3(ModelViewMatrix * patch[6].position);
    auto v12 = float3(ModelViewMatrix * patch[9].position);
    auto n = normalize(cross(v3 - v0, v12 - v0));
    v0 = normalize(v0 + v3 + v12);
    if(dot(v0, n) > 0.6f)
    {
        return false;
    }
#endif
#if OSD_ENABLE_PATCH_CULL
    short3 clipFlag = short3(0,0,0);
    for(int i = 0; i < CONTROL_POINTS_PER_PATCH; ++i) {
        clipFlag |= patch[i].clipFlag;
    }
    if (any(clipFlag != short3(3,3,3))) {
        return false;
    }
#endif
    return true;
// When OSD_PATCH_ENABLE_SINGLE_CREASE is defined,
// this function evaluates single-crease patch, which is segmented into
// 3 parts in the v-direction.
//  v=0             vSegment.x        vSegment.y              v=1
//   +------------------+-------------------+------------------+
//   |       cp 0       |     cp 1          |      cp 2        |
//   | (infinite sharp) | (floor sharpness) | (ceil sharpness) |
//   +------------------+-------------------+------------------+
static float3 OsdEvalBezier(device OsdPerPatchVertexBezier* cp, int3 patchParam, float2 uv)
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    float B[4], D[4];
    float s = OsdGetPatchSingleCreaseSegmentParameter(patchParam, uv);
    OsdUnivar4x4(uv.x, B, D);
#if OSD_PATCH_ENABLE_SINGLE_CREASE
#if USE_PTVS_SHARPNESS
    float sharpness = OsdGetPatchSharpness(patchParam);
    float Sf = floor(sharpness);
    float Sc = ceil(sharpness);
    float s0 = 1 - exp2(-Sf);
    float s1 = 1 - exp2(-Sc);
    float2 vSegments(s0, s1);
#else
    float2 vSegments = float2(cp[0].vSegments);
#endif // USE_PTVS_SHARPNESS
    //By doing the offset calculation ahead of time it can be kept out of the actual indexing lookup.
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    if(s <= vSegments.x)
        cp = (device OsdPerPatchVertexBezier*)(((device half*)cp) + 0);
    else if( s <= vSegments.y)
        cp = (device OsdPerPatchVertexBezier*)(((device half*)cp) + 3);
    else
        cp = (device OsdPerPatchVertexBezier*)(((device half*)cp) + 6);
#else
    if(s <= vSegments.x)
        cp = (device OsdPerPatchVertexBezier*)(((device float*)cp) + 0);
    else if( s <= vSegments.y)
        cp = (device OsdPerPatchVertexBezier*)(((device float*)cp) + 3);
    else
        cp = (device OsdPerPatchVertexBezier*)(((device float*)cp) + 6);
#endif //C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    BUCP[0] += float3(cp[0].P) * B[0];
    BUCP[0] += float3(cp[1].P) * B[1];
    BUCP[0] += float3(cp[2].P) * B[2];
    BUCP[0] += float3(cp[3].P) * B[3];
    BUCP[1] += float3(cp[4].P) * B[0];
    BUCP[1] += float3(cp[5].P) * B[1];
    BUCP[1] += float3(cp[6].P) * B[2];
    BUCP[1] += float3(cp[7].P) * B[3];
    BUCP[2] += float3(cp[8].P) * B[0];
    BUCP[2] += float3(cp[9].P) * B[1];
    BUCP[2] += float3(cp[10].P) * B[2];
    BUCP[2] += float3(cp[11].P) * B[3];
    BUCP[3] += float3(cp[12].P) * B[0];
    BUCP[3] += float3(cp[13].P) * B[1];
    BUCP[3] += float3(cp[14].P) * B[2];
    BUCP[3] += float3(cp[15].P) * B[3];
#else // single crease
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            float3 A = float3(cp[4*i + j].P);
            BUCP[i] += A * B[j];
        }
    }
#endif  // single crease
    OsdUnivar4x4(uv.y, B);
    float3 P = B[0] * BUCP[0];
    for (int k=1; k<4; ++k) {
        P += B[k] * BUCP[k];
    }
    return P;
// ----------------------------------------------------------------------------
// Boundary Interpolation
// ----------------------------------------------------------------------------
template<typename VertexType>
static void OsdComputeBSplineBoundaryPoints(threadgroup VertexType* cpt, int3 patchParam)
//APPL TODO - multithread this
    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);
    if ((boundaryMask & 1) != 0) {
        cpt[0].SetPosition(2*cpt[4].GetPosition() - cpt[8].GetPosition());
        cpt[1].SetPosition(2*cpt[5].GetPosition() - cpt[9].GetPosition());
        cpt[2].SetPosition(2*cpt[6].GetPosition() - cpt[10].GetPosition());
        cpt[3].SetPosition(2*cpt[7].GetPosition() - cpt[11].GetPosition());
    }
    if ((boundaryMask & 2) != 0) {
        cpt[3].SetPosition(2*cpt[2].GetPosition() - cpt[1].GetPosition());
        cpt[7].SetPosition(2*cpt[6].GetPosition() - cpt[5].GetPosition());
        cpt[11].SetPosition(2*cpt[10].GetPosition() - cpt[9].GetPosition());
        cpt[15].SetPosition(2*cpt[14].GetPosition() - cpt[13].GetPosition());
    }
    if ((boundaryMask & 4) != 0) {
        cpt[12].SetPosition(2*cpt[8].GetPosition() - cpt[4].GetPosition());
        cpt[13].SetPosition(2*cpt[9].GetPosition() - cpt[5].GetPosition());
        cpt[14].SetPosition(2*cpt[10].GetPosition() - cpt[6].GetPosition());
        cpt[15].SetPosition(2*cpt[11].GetPosition() - cpt[7].GetPosition());
    }
    if ((boundaryMask & 8) != 0) {
        cpt[0].SetPosition(2*cpt[1].GetPosition() - cpt[2].GetPosition());
        cpt[4].SetPosition(2*cpt[5].GetPosition() - cpt[6].GetPosition());
        cpt[8].SetPosition(2*cpt[9].GetPosition() - cpt[10].GetPosition());
        cpt[12].SetPosition(2*cpt[13].GetPosition() - cpt[14].GetPosition());
    }
template<typename VertexType>
static void OsdComputeBSplineBoundaryPoints(thread VertexType* cpt, int3 patchParam)
    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);
    if ((boundaryMask & 1) != 0) {
        cpt[0].SetPosition(2*cpt[4].GetPosition() - cpt[8].GetPosition());
        cpt[1].SetPosition(2*cpt[5].GetPosition() - cpt[9].GetPosition());
        cpt[2].SetPosition(2*cpt[6].GetPosition() - cpt[10].GetPosition());
        cpt[3].SetPosition(2*cpt[7].GetPosition() - cpt[11].GetPosition());
    }
    if ((boundaryMask & 2) != 0) {
        cpt[3].SetPosition(2*cpt[2].GetPosition() - cpt[1].GetPosition());
        cpt[7].SetPosition(2*cpt[6].GetPosition() - cpt[5].GetPosition());
        cpt[11].SetPosition(2*cpt[10].GetPosition() - cpt[9].GetPosition());
        cpt[15].SetPosition(2*cpt[14].GetPosition() - cpt[13].GetPosition());
    }
    if ((boundaryMask & 4) != 0) {
        cpt[12].SetPosition(2*cpt[8].GetPosition() - cpt[4].GetPosition());
        cpt[13].SetPosition(2*cpt[9].GetPosition() - cpt[5].GetPosition());
        cpt[14].SetPosition(2*cpt[10].GetPosition() - cpt[6].GetPosition());
        cpt[15].SetPosition(2*cpt[11].GetPosition() - cpt[7].GetPosition());
    }
    if ((boundaryMask & 8) != 0) {
      cpt[0].SetPosition(2*cpt[1].GetPosition() - cpt[2].GetPosition());
      cpt[4].SetPosition(2*cpt[5].GetPosition() - cpt[6].GetPosition());
      cpt[8].SetPosition(2*cpt[9].GetPosition() - cpt[10].GetPosition());
      cpt[12].SetPosition(2*cpt[13].GetPosition() - cpt[14].GetPosition());
    }
static void OsdEvalPatchGregory(int3 patchParam, float2 UV, thread float3* cv,
                    thread float3& P, thread float3& dPu, thread float3& dPv,
                    thread float3& N, thread float3& dNu, thread float3& dNv)
    float u = UV.x, v = UV.y;
    float U = 1-u, V = 1-v;
    //(0,1)                              (1,1)
    //   P3         e3-      e2+         P2
    //      15------17-------11-------10
    //      |        |        |        |
    //      |        |        |        |
    //      |        | f3-    | f2+    |
    //      |       19       13        |
    //  e3+ 16-----18          14-----12 e2-
    //      |     f3+          f2-     |
    //      |                          |
    //      |                          |
    //      |     f0-         f1+      |
    //  e0- 2------4            8------6 e1+
    //      |        3 f0+    9        |
    //      |        |        | f1-    |
    //      |        |        |        |
    //      |        |        |        |
    //      0--------1--------7--------5
    //    P0        e0+      e1-         P1
    //(0,0)                               (1,0)
    float d11 = u+v;
    float d12 = U+v;
    float d21 = u+V;
    float d22 = U+V;
    float3 q[16];
    q[ 5] = (d11 == 0.0) ? cv[3]  : (u*cv[3] + v*cv[4])/d11;
    q[ 6] = (d12 == 0.0) ? cv[8]  : (U*cv[9] + v*cv[8])/d12;
    q[ 9] = (d21 == 0.0) ? cv[18] : (u*cv[19] + V*cv[18])/d21;
    q[10] = (d22 == 0.0) ? cv[13] : (U*cv[13] + V*cv[14])/d22;
    q[ 0] = cv[0];
    q[ 1] = cv[1];
    q[ 2] = cv[7];
    q[ 3] = cv[5];
    q[ 4] = cv[2];
    q[ 7] = cv[6];
    q[ 8] = cv[16];
    q[11] = cv[12];
    q[12] = cv[15];
    q[13] = cv[17];
    q[14] = cv[11];
    q[15] = cv[10];
    P   = float3(0,0,0);
    dPu = float3(0,0,0);
    dPv = float3(0,0,0);
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    float B[4], D[4], C[4];
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    DUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    CUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    float3 dUU = float3(0,0,0);
    float3 dVV = float3(0,0,0);
    float3 dUV = float3(0,0,0);
    OsdUnivar4x4(UV.x, B, D, C);
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            float3 A = q[4*i + j];
            BUCP[i] += A * B[j];
            DUCP[i] += A * D[j];
            CUCP[i] += A * C[j];
        }
    }
    OsdUnivar4x4(UV.y, B, D, C);
    for (int i=0; i<4; ++i) {
        P   += B[i] * BUCP[i];
        dPu += B[i] * DUCP[i];
        dPv += D[i] * BUCP[i];
        dUU += B[i] * CUCP[i];
        dVV += C[i] * BUCP[i];
        dUV += D[i] * DUCP[i];
    }
    int level = OsdGetPatchFaceLevel(patchParam);
    dPu *= 3 * level;
    dPv *= 3 * level;
    dUU *= 6 * level;
    dVV *= 6 * level;
    dUV *= 9 * level;
    float3 n = cross(dPu, dPv);
    N = normalize(n);
    float E = dot(dPu, dPu);
    float F = dot(dPu, dPv);
    float G = dot(dPv, dPv);
    float e = dot(N, dUU);
    float f = dot(N, dUV);
    float g = dot(N, dVV);
    dNu = (f*F-e*G)/(E*G-F*F) * dPu + (e*F-f*E)/(E*G-F*F) * dPv;
    dNv = (g*F-f*G)/(E*G-F*F) * dPu + (f*F-g*E)/(E*G-F*F) * dPv;
    dNu = dNu/length(n) - n * (dot(dNu,n)/powr(dot(n,n), 1.5));
    dNv = dNv/length(n) - n * (dot(dNv,n)/powr(dot(n,n), 1.5));
#else //OSD_COMPUTE_NORMAL_DERIVATIVES
    float B[4], D[4];
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    DUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    OsdUnivar4x4(UV.x, B, D);
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            float3 A = q[4*i + j];
            BUCP[i] += A * B[j];
            DUCP[i] += A * D[j];
        }
    }
    OsdUnivar4x4(UV.y, B, D);
    for (int i=0; i<4; ++i) {
        P += B[i] * BUCP[i];
        dPu += B[i] * DUCP[i];
        dPv += D[i] * BUCP[i];
    }
    int level = OsdGetPatchFaceLevel(patchParam);
    dPu *= 3 * level;
    dPv *= 3 * level;
    N = normalize(cross(dPu, dPv));
    dNu = float3(0,0,0);
    dNv = float3(0,0,0);
#endif //OSD_COMPUTE_NORMAL_DERIVATIVES
// ----------------------------------------------------------------------------
// Tessellation
// ----------------------------------------------------------------------------
// Organization of B-spline and Bezier control points.
// Each patch is defined by 16 control points (labeled 0-15).
// The patch will be evaluated across the domain from (0,0) at
// the lower-left to (1,1) at the upper-right. When computing
// adaptive tessellation metrics, we consider refined vertex-vertex
// and edge-vertex points along the transition edges of the patch
// (labeled vv* and ev* respectively).
// The two segments of each transition edge are labeled Lo and Hi,
// with the Lo segment occuring before the Hi segment along the
// transition edge's domain parameterization. These Lo and Hi segment
// tessellation levels determine how domain evaluation coordinates
// are remapped along transition edges. The Hi segment value will
// be zero for a non-transition edge.
// (0,1)                                         (1,1)
//   vv3                  ev23                   vv2
//        |       Lo3       |       Hi3       |
//      --O-----------O-----+-----O-----------O--
//        | 12        | 13     14 |        15 |
//        |           |           |           |
//        |           |           |           |
//    Hi0 |           |           |           | Hi2
//        |           |           |           |
//        O-----------O-----------O-----------O
//        | 8         | 9      10 |        11 |
//        |           |           |           |
// ev03 --+           |           |           +-- ev12
//        |           |           |           |
//        | 4         | 5       6 |         7 |
//        O-----------O-----------O-----------O
//        |           |           |           |
//    Lo0 |           |           |           | Lo2
//        |           |           |           |
//        |           |           |           |
//        | 0         | 1       2 |         3 |
//      --O-----------O-----+-----O-----------O--
//        |       Lo1       |       Hi1       |
//   vv0                  ev01                   vv1
// (0,0)                                         (1,0)
static float OsdComputePostProjectionSphereExtent(const float4x4 OsdProjectionMatrix, float3 center, float diameter)
    //float4 p = OsdProjectionMatrix * float4(center, 1.0);
    float w = OsdProjectionMatrix[0][3] * center.x + OsdProjectionMatrix[1][3] * center.y + OsdProjectionMatrix[2][3] * center.z + OsdProjectionMatrix[3][3];
    return abs(diameter * OsdProjectionMatrix[1][1] / w);
// Round up to the nearest even integer
static float OsdRoundUpEven(float x) {
    return 2*ceil(x/2);
// Round up to the nearest odd integer
static float OsdRoundUpOdd(float x) {
    return 2*ceil((x+1)/2)-1;
// Compute outer and inner tessellation levels taking into account the
// current tessellation spacing mode.
static void OsdComputeTessLevels(thread float4& tessOuterLo, thread float4& tessOuterHi,
                     thread float4& tessLevelOuter, thread float2& tessLevelInner)
    // Outer levels are the sum of the Lo and Hi segments where the Hi
    // segments will have lengths of zero for non-transition edges.
#if OSD_FRACTIONAL_EVEN_SPACING
    // Combine fractional outer transition edge levels before rounding.
    float4 combinedOuter = tessOuterLo + tessOuterHi;
    // Round the segments of transition edges separately. We will recover the
    // fractional parameterization of transition edges after tessellation.
    tessLevelOuter = combinedOuter;
    if (tessOuterHi[0] > 0) {
        tessLevelOuter[0] =
            OsdRoundUpEven(tessOuterLo[0]) + OsdRoundUpEven(tessOuterHi[0]);
    }
    if (tessOuterHi[1] > 0) {
        tessLevelOuter[1] =
            OsdRoundUpEven(tessOuterLo[1]) + OsdRoundUpEven(tessOuterHi[1]);
    }
    if (tessOuterHi[2] > 0) {
        tessLevelOuter[2] =
            OsdRoundUpEven(tessOuterLo[2]) + OsdRoundUpEven(tessOuterHi[2]);
    }
    if (tessOuterHi[3] > 0) {
        tessLevelOuter[3] =
            OsdRoundUpEven(tessOuterLo[3]) + OsdRoundUpEven(tessOuterHi[3]);
    }
#elif OSD_FRACTIONAL_ODD_SPACING
    // Combine fractional outer transition edge levels before rounding.
    float4 combinedOuter = tessOuterLo + tessOuterHi;
    // Round the segments of transition edges separately. We will recover the
    // fractional parameterization of transition edges after tessellation.
    //
    // The sum of the two outer odd segment lengths will be an even number
    // which the tessellator will increase by +1 so that there will be a
    // total odd number of segments. We clamp the combinedOuter tess levels
    // (used to compute the inner tess levels) so that the outer transition
    // edges will be sampled without degenerate triangles.
    tessLevelOuter = combinedOuter;
    if (tessOuterHi[0] > 0) {
        tessLevelOuter[0] =
            OsdRoundUpOdd(tessOuterLo[0]) + OsdRoundUpOdd(tessOuterHi[0]);
        combinedOuter = max(float4(3,3,3,3), combinedOuter);
    }
    if (tessOuterHi[1] > 0) {
        tessLevelOuter[1] =
            OsdRoundUpOdd(tessOuterLo[1]) + OsdRoundUpOdd(tessOuterHi[1]);
        combinedOuter = max(float4(3,3,3,3), combinedOuter);
    }
    if (tessOuterHi[2] > 0) {
        tessLevelOuter[2] =
            OsdRoundUpOdd(tessOuterLo[2]) + OsdRoundUpOdd(tessOuterHi[2]);
        combinedOuter = max(float4(3,3,3,3), combinedOuter);
    }
    if (tessOuterHi[3] > 0) {
        tessLevelOuter[3] =
            OsdRoundUpOdd(tessOuterLo[3]) + OsdRoundUpOdd(tessOuterHi[3]);
        combinedOuter = max(float4(3,3,3,3), combinedOuter);
    }
#else //OSD_FRACTIONAL_ODD_SPACING
    // Round equally spaced transition edge levels before combining.
    tessOuterLo = round(tessOuterLo);
    tessOuterHi = round(tessOuterHi);
    float4 combinedOuter = tessOuterLo + tessOuterHi;
    tessLevelOuter = combinedOuter;
#endif //OSD_FRACTIONAL_ODD_SPACING
    // Inner levels are the averages the corresponding outer levels.
    tessLevelInner[0] = (combinedOuter[1] + combinedOuter[3]) * 0.5;
    tessLevelInner[1] = (combinedOuter[0] + combinedOuter[2]) * 0.5;
static float OsdComputeTessLevel(const float OsdTessLevel, const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix, float3 p0, float3 p1)
    // Adaptive factor can be any computation that depends only on arg values.
    // Project the diameter of the edge's bounding sphere instead of using the
    // length of the projected edge itself to avoid problems near silhouettes.
    float3 center = (p0 + p1) / 2.0;
    float diameter = distance(p0, p1);
    float projLength = OsdComputePostProjectionSphereExtent(OsdProjectionMatrix, center, diameter);
    float tessLevel = max(1.0, OsdTessLevel * projLength);
    // We restrict adaptive tessellation levels to half of the device
    // supported maximum because transition edges are split into two
    // halfs and the sum of the two corresponding levels must not exceed
    // the device maximum. We impose this limit even for non-transition
    // edges because a non-transition edge must be able to match up with
    // one half of the transition edge of an adjacent transition patch.
    return min(tessLevel, (float)(OSD_MAX_TESS_LEVEL / 2));
static void OsdGetTessLevelsUniform(const float OsdTessLevel, int3 patchParam,
                        thread float4& tessOuterLo, thread float4& tessOuterHi)
    // Uniform factors are simple powers of two for each level.
    // The maximum here can be increased if we know the maximum
    // refinement level of the mesh:
    //     min(OSD_MAX_TESS_LEVEL, pow(2, MaximumRefinementLevel-1)
    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);
    float tessLevel = min(OsdTessLevel, ((float)OSD_MAX_TESS_LEVEL / 2)) /
                        pow(2, refinementLevel - 1.0f);
//    float tessLevel = min(OsdTessLevel, (float)OSD_MAX_TESS_LEVEL);
//    if(refinementLevel != 0)
//         tessLevel /= (1 << (refinementLevel - 1));
//    else
//    {
//        tessLevel /= pow(2.0, (0 - 1));
//        tessLevel /= pow(2.0, (refinementLevel - 1));
//    }
    // tessLevels of transition edge should be clamped to 2.
    int transitionMask = OsdGetPatchTransitionMask(patchParam);
    float4 tessLevelMin = float4(1)
    + float4(((transitionMask & 8) >> 3),
             ((transitionMask & 1) >> 0),
             ((transitionMask & 2) >> 1),
             ((transitionMask & 4) >> 2));
//    tessLevelMin =  (tessLevelMin - 1.0) * 2.0f + 1.0;
//    tessLevelMin = float4(OsdTessLevel);
    tessOuterLo = max(float4(tessLevel,tessLevel,tessLevel,tessLevel),
                      tessLevelMin);
    tessOuterHi = float4(0,0,0,0);
//    tessOuterLo.x = refinementLevel;
static void OsdGetTessLevelsRefinedPoints(const float OsdTessLevel,
                              const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,
                              float3 cp[16], int3 patchParam,
                              thread float4& tessOuterLo, thread float4& tessOuterHi)
    // Each edge of a transition patch is adjacent to one or two patches
    // at the next refined level of subdivision. We compute the corresponding
    // vertex-vertex and edge-vertex refined points along the edges of the
    // patch using Catmull-Clark subdivision stencil weights.
    // For simplicity, we let the optimizer discard unused computation.
    float3 vv0 = (cp[0] + cp[2] + cp[8] + cp[10]) * 0.015625 +
    (cp[1] + cp[4] + cp[6] + cp[9]) * 0.09375 + cp[5] * 0.5625;
    float3 ev01 = (cp[1] + cp[2] + cp[9] + cp[10]) * 0.0625 +
    (cp[5] + cp[6]) * 0.375;
    float3 vv1 = (cp[1] + cp[3] + cp[9] + cp[11]) * 0.015625 +
    (cp[2] + cp[5] + cp[7] + cp[10]) * 0.09375 + cp[6] * 0.5625;
    float3 ev12 = (cp[5] + cp[7] + cp[9] + cp[11]) * 0.0625 +
    (cp[6] + cp[10]) * 0.375;
    float3 vv2 = (cp[5] + cp[7] + cp[13] + cp[15]) * 0.015625 +
    (cp[6] + cp[9] + cp[11] + cp[14]) * 0.09375 + cp[10] * 0.5625;
    float3 ev23 = (cp[5] + cp[6] + cp[13] + cp[14]) * 0.0625 +
    (cp[9] + cp[10]) * 0.375;
    float3 vv3 = (cp[4] + cp[6] + cp[12] + cp[14]) * 0.015625 +
    (cp[5] + cp[8] + cp[10] + cp[13]) * 0.09375 + cp[9] * 0.5625;
    float3 ev03 = (cp[4] + cp[6] + cp[8] + cp[10]) * 0.0625 +
    (cp[5] + cp[9]) * 0.375;
    tessOuterLo = float4(0,0,0,0);
    tessOuterHi = float4(0,0,0,0);
    int transitionMask = OsdGetPatchTransitionMask(patchParam);
    if ((transitionMask & 8) != 0) {
        tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv0, ev03);
        tessOuterHi[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv3, ev03);
    } else {
        tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp[5], cp[9]);
    }
    if ((transitionMask & 1) != 0) {
        tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv0, ev01);
        tessOuterHi[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv1, ev01);
    } else {
        tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp[5], cp[6]);
    }
    if ((transitionMask & 2) != 0) {
        tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv1, ev12);
        tessOuterHi[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv2, ev12);
    } else {
        tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp[6], cp[10]);
    }
    if ((transitionMask & 4) != 0) {
        tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv3, ev23);
        tessOuterHi[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv2, ev23);
    } else {
        tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp[9], cp[10]);
    }
static float3 miniMul(float4x4 a, float3 b)
    float3 r;
    r.x = a[0][0] * b[0] + a[1][0] * b[1] + a[2][0] * b[2] + a[3][0];
    r.y = a[0][1] * b[0] + a[1][1] * b[1] + a[2][1] * b[2] + a[3][1];
    r.z = a[0][2] * b[0] + a[1][2] * b[1] + a[2][2] * b[2] + a[3][2];
    return r;
static void OsdGetTessLevelsLimitPoints(const float OsdTessLevel, const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,
                            device OsdPerPatchVertexBezier* cpBezier,
                            int3 patchParam, thread float4& tessOuterLo, thread float4& tessOuterHi)
    // Each edge of a transition patch is adjacent to one or two patches
    // at the next refined level of subdivision. When the patch control
    // points have been converted to the Bezier basis, the control points
    // at the four corners are on the limit surface (since a Bezier patch
    // interpolates its corner control points). We can compute an adaptive
    // tessellation level for transition edges on the limit surface by
    // evaluating a limit position at the mid point of each transition edge.
    tessOuterLo = float4(0,0,0,0);
    tessOuterHi = float4(0,0,0,0);
    int transitionMask = OsdGetPatchTransitionMask(patchParam);
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    // PERFOMANCE: we just need to pick the correct corner points from P, P1, P2
    float3 p0 = OsdEvalBezier(cpBezier, patchParam, float2(0.0, 0.0));
    float3 p3 = OsdEvalBezier(cpBezier, patchParam, float2(1.0, 0.0));
    float3 p12 = OsdEvalBezier(cpBezier, patchParam, float2(0.0, 1.0));
    float3 p15 = OsdEvalBezier(cpBezier, patchParam, float2(1.0, 1.0));
    p0 = miniMul(OsdModelViewMatrix, p0);
    p3 = miniMul(OsdModelViewMatrix, p3);
    p12 = miniMul(OsdModelViewMatrix, p12);
    p15 = miniMul(OsdModelViewMatrix, p15);
    thread float3 * tPt;
    float3 ev;
    if ((transitionMask & 8) != 0) { // EVO3
        ev = OsdEvalBezier(cpBezier, patchParam, float2(0.0, 0.5));
        ev = miniMul(OsdModelViewMatrix, ev);
        tPt = &ev;
        tessOuterHi[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p12, ev);
    } else {
        tPt = &p12;
    }
    tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p0, *tPt);
    
    if ((transitionMask & 1) != 0) { // EV01
        ev = OsdEvalBezier(cpBezier, patchParam, float2(0.5, 0.0));
        ev = miniMul(OsdModelViewMatrix, ev);
        tPt = &ev;
        tessOuterHi[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p3, ev);
    } else {
        tPt = &p3;
    }
    tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p0, *tPt);
    
    if ((transitionMask & 2) != 0) { // EV12
        ev = OsdEvalBezier(cpBezier, patchParam, float2(1.0, 0.5));
        ev = miniMul(OsdModelViewMatrix, ev);
        tPt = &ev;
        tessOuterHi[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p15, ev);
    } else {
        tPt = &p15;
    }
    tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p3, *tPt);
    
    if ((transitionMask & 4) != 0) { // EV23
        ev = OsdEvalBezier(cpBezier, patchParam, float2(0.5, 1.0));
        ev = miniMul(OsdModelViewMatrix, ev);
        tPt = &ev;
        tessOuterHi[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p15, ev);
    } else {
        tPt = &p15;
    }
    tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p12, *tPt);
#else // OSD_PATCH_ENABLE_SINGLE_CREASE
    float3 p0 = OsdEvalBezier(cpBezier, patchParam, float2(0.0, 0.5));
    float3 p3 = OsdEvalBezier(cpBezier, patchParam, float2(0.5, 0.0));
    float3 p12 = OsdEvalBezier(cpBezier, patchParam, float2(1.0, 0.5));
    float3 p15 = OsdEvalBezier(cpBezier, patchParam, float2(0.5, 1.0));
    p0 = miniMul(OsdModelViewMatrix, p0);
    p3 = miniMul(OsdModelViewMatrix, p3);
    p12 = miniMul(OsdModelViewMatrix, p12);
    p15 = miniMul(OsdModelViewMatrix, p15);
    float3 c00 = miniMul(OsdModelViewMatrix, float3(cpBezier[0].P));
    float3 c12 = miniMul(OsdModelViewMatrix, float3(cpBezier[12].P));
    float3 c03 = miniMul(OsdModelViewMatrix, float3(cpBezier[3].P));
    float3 c15 = miniMul(OsdModelViewMatrix, float3(cpBezier[15].P));
    
    if ((transitionMask & 8) != 0) {
        tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c00, p0);
        tessOuterHi[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c12, p0);
    } else {
        tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c00, c12);
    }
    if ((transitionMask & 1) != 0) {
        tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c00, p3);
        tessOuterHi[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c03, p3);
    } else {
        tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c00, c03);
    }
    if ((transitionMask & 2) != 0) {
        tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c03, p12);
        tessOuterHi[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c15, p12);
    } else {
        tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c03, c15);
    }
    if ((transitionMask & 4) != 0) {
        tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c12, p15);
        tessOuterHi[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c15, p15);
    } else {
        tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c12, c15);
    }
#endif
static void OsdGetTessLevelsUniform(const float OsdTessLevel, int3 patchParam,
                        thread float4& tessLevelOuter, thread float2& tessLevelInner,
                        thread float4& tessOuterLo, thread float4& tessOuterHi)
    OsdGetTessLevelsUniform(OsdTessLevel, patchParam, tessOuterLo, tessOuterHi);
    OsdComputeTessLevels(tessOuterLo, tessOuterHi, tessLevelOuter, tessLevelInner);
static void OsdGetTessLevelsAdaptiveRefinedPoints(const float OsdTessLevel, const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,
                                      float3 cpRefined[16], int3 patchParam,
                                      thread float4& tessLevelOuter, thread float2& tessLevelInner,
                                      thread float4& tessOuterLo, thread float4& tessOuterHi)
    OsdGetTessLevelsRefinedPoints(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cpRefined, patchParam, tessOuterLo, tessOuterHi);
    OsdComputeTessLevels(tessOuterLo, tessOuterHi,
                         tessLevelOuter, tessLevelInner);
static void OsdGetTessLevelsAdaptiveLimitPoints(const float OsdTessLevel, const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,
                                    device OsdPerPatchVertexBezier* cpBezier,
                                    int3 patchParam,
                                    thread float4& tessLevelOuter, thread float2& tessLevelInner,
                                    thread float4& tessOuterLo, thread float4& tessOuterHi)
    OsdGetTessLevelsLimitPoints(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cpBezier, patchParam, tessOuterLo, tessOuterHi);
    OsdComputeTessLevels(tessOuterLo, tessOuterHi,
                         tessLevelOuter, tessLevelInner);
static void OsdGetTessLevels(const float OsdTessLevel, const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,
                 float3 cp0, float3 cp1, float3 cp2, float3 cp3,
                 int3 patchParam,
                 thread float4& tessLevelOuter, thread float2& tessLevelInner)
    float4 tessOuterLo = float4(0,0,0,0);
    float4 tessOuterHi = float4(0,0,0,0);
    cp0 = mul(OsdModelViewMatrix, float4(cp0, 1.0)).xyz;
    cp1 = mul(OsdModelViewMatrix, float4(cp1, 1.0)).xyz;
    cp2 = mul(OsdModelViewMatrix, float4(cp2, 1.0)).xyz;
    cp3 = mul(OsdModelViewMatrix, float4(cp3, 1.0)).xyz;
#if OSD_ENABLE_SCREENSPACE_TESSELLATION
    tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp0, cp1);
    tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp0, cp3);
    tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp2, cp3);
    tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp1, cp2);
    tessOuterHi = float4(0,0,0,0);
#else //OSD_ENABLE_SCREENSPACE_TESSELLATION
    OsdGetTessLevelsUniform(OsdTessLevel, patchParam, tessOuterLo, tessOuterHi);
#endif //OSD_ENABLE_SCREENSPACE_TESSELLATION
    OsdComputeTessLevels(tessOuterLo, tessOuterHi,
                         tessLevelOuter, tessLevelInner);
#if OSD_FRACTIONAL_EVEN_SPACING || OSD_FRACTIONAL_ODD_SPACING
static float OsdGetTessFractionalSplit(float t, float level, float levelUp)
    // Fractional tessellation of an edge will produce n segments where n
    // is the tessellation level of the edge (level) rounded up to the
    // nearest even or odd integer (levelUp). There will be n-2 segments of
    // equal length (dx1) and two additional segments of equal length (dx0)
    // that are typically shorter than the other segments. The two additional
    // segments should be placed symmetrically on opposite sides of the
    // edge (offset).
#if OSD_FRACTIONAL_EVEN_SPACING
    if (level <= 2) return t;
    float base = pow(2.0,floor(log2(levelUp)));
    float offset = 1.0/(int(2*base-levelUp)/2 & int(base/2-1));
#elif OSD_FRACTIONAL_ODD_SPACING
    if (level <= 1) return t;
    float base = pow(2.0,floor(log2(levelUp)));
    float offset = 1.0/(((int(2*base-levelUp)/2+1) & int(base/2-1))+1);
#endif //OSD_FRACTIONAL_ODD_SPACING
    float dx0 = (1.0 - (levelUp-level)/2) / levelUp;
    float dx1 = (1.0 - 2.0*dx0) / (levelUp - 2.0*ceil(dx0));
    if (t < 0.5) {
        float x = levelUp/2 - round(t*levelUp);
        return 0.5 - (x*dx1 + int(x*offset > 1) * (dx0 - dx1));
    } else if (t > 0.5) {
        float x = round(t*levelUp) - levelUp/2;
        return 0.5 + (x*dx1 + int(x*offset > 1) * (dx0 - dx1));
    } else {
        return t;
    }
#endif //OSD_FRACTIONAL_EVEN_SPACING || OSD_FRACTIONAL_ODD_SPACING
static float OsdGetTessTransitionSplit(float t, float lo, float hi )
#if OSD_FRACTIONAL_EVEN_SPACING
  float loRoundUp = OsdRoundUpEven(lo);
  float hiRoundUp = OsdRoundUpEven(hi);
  // Convert the parametric t into a segment index along the combined edge.
  float ti = round(t * (loRoundUp + hiRoundUp));
  if (ti <= loRoundUp) {
      float t0 = ti / loRoundUp;
      return OsdGetTessFractionalSplit(t0, lo, loRoundUp) * 0.5;
   } else {
      float t1 = (ti - loRoundUp) / hiRoundUp;
      return OsdGetTessFractionalSplit(t1, hi, hiRoundUp) * 0.5 + 0.5;
    }
#elif OSD_FRACTIONAL_ODD_SPACING
  float loRoundUp = OsdRoundUpOdd(lo);
  float hiRoundUp = OsdRoundUpOdd(hi);
  // Convert the parametric t into a segment index along the combined edge.
  // The +1 below is to account for the extra segment produced by the
  // tessellator since the sum of two odd tess levels will be rounded
  // up by one to the next odd integer tess level.
  float ti = (t * (loRoundUp + hiRoundUp + 1));
  OSD_UV_CORRECTION
  ti = round(ti);
  if (ti <= loRoundUp) {
      float t0 = ti / loRoundUp;
      return OsdGetTessFractionalSplit(t0, lo, loRoundUp) * 0.5;
  } else if (ti > (loRoundUp+1)) {
      float t1 = (ti - (loRoundUp+1)) / hiRoundUp;
      return OsdGetTessFractionalSplit(t1, hi, hiRoundUp) * 0.5 + 0.5;
  } else {
      return 0.5;
#else //OSD_FRACTIONAL_ODD_SPACING
  // Convert the parametric t into a segment index along the combined edge.
  float ti = round(t * (lo + hi));
  if (ti <= lo) {
      return (ti / lo) * 0.5;
  } else {
      return ((ti - lo) / hi) * 0.5 + 0.5;
#endif //OSD_FRACTIONAL_ODD_SPACING
static float2 OsdGetTessParameterization(float2 uv, float4 tessOuterLo, float4 tessOuterHi)
    float2 UV = uv;
if (UV.x == 0 && tessOuterHi[0] > 0)
UV.y = OsdGetTessTransitionSplit(UV.y, tessOuterLo[0], tessOuterHi[0]);
else if (UV.y == 0 && tessOuterHi[1] > 0)
UV.x = OsdGetTessTransitionSplit(UV.x, tessOuterLo[1], tessOuterHi[1]);
else if (UV.x == 1 && tessOuterHi[2] > 0)
UV.y = OsdGetTessTransitionSplit(UV.y, tessOuterLo[2], tessOuterHi[2]);
else if (UV.y == 1 && tessOuterHi[3] > 0)
UV.x = OsdGetTessTransitionSplit(UV.x, tessOuterLo[3], tessOuterHi[3]);
    return UV;
static int4 OsdGetPatchCoord(int3 patchParam)
    int faceId = OsdGetPatchFaceId(patchParam);
    int faceLevel = OsdGetPatchFaceLevel(patchParam);
    int2 faceUV = OsdGetPatchFaceUV(patchParam);
    return int4(faceUV.x, faceUV.y, faceLevel, faceId);
static float4 OsdInterpolatePatchCoord(float2 localUV, int3 patchParam)
    int4 perPrimPatchCoord = OsdGetPatchCoord(patchParam);
    int faceId = perPrimPatchCoord.w;
    int faceLevel = perPrimPatchCoord.z;
    float2 faceUV = float2(perPrimPatchCoord.x, perPrimPatchCoord.y);
    float2 uv = localUV/faceLevel + faceUV/faceLevel;
    // add 0.5 to integer values for more robust interpolation
    return float4(uv.x, uv.y, faceLevel+0.5, faceId+0.5);
// ----------------------------------------------------------------------------
// GregoryBasis
// ----------------------------------------------------------------------------
static void OsdComputePerPatchVertexGregoryBasis(int3 patchParam, int ID, float3 cv,
                                     device OsdPerPatchVertexGregoryBasis& result)
    result.P = cv;
// Regular BSpline to Bezier
constant float4x4 Q(
                    float4(1.f/6.f, 4.f/6.f, 1.f/6.f, 0.f),
                    float4(0.f,     4.f/6.f, 2.f/6.f, 0.f),
                    float4(0.f,     2.f/6.f, 4.f/6.f, 0.f),
                    float4(0.f,     1.f/6.f, 4.f/6.f, 1.f/6.f)
                    );
// Infinitely Sharp (boundary)
constant float4x4 Mi(
                     float4(1.f/6.f, 4.f/6.f, 1.f/6.f, 0.f),
                     float4(0.f,     4.f/6.f, 2.f/6.f, 0.f),
                     float4(0.f,     2.f/6.f, 4.f/6.f, 0.f),
                     float4(0.f,     0.f,     1.f,     0.f)
                     );
    
static float4x4 OsdComputeMs2(float sharpness, float factor)
    float s = exp2(sharpness);
    float s2 = s*s;
    float s3 = s2*s;
    float sx6 = s*6.0;
    float sx6m2 = sx6 - 2;
    float sfrac1 = 1-s;
    float ssub1 = s-1;
    float ssub1_2 = ssub1 * ssub1;
    float div6 = 1.0/6.0;
    
    float4x4 m(
               float4(0, s + 1 + 3*s2 - s3, 7*s - 2 - 6*s2 + 2*s3,    sfrac1 * ssub1_2),
               float4(0,      1 + 2*s + s2,         sx6m2 - 2*s2,             ssub1_2),
               float4(0,               1+s,                sx6m2,              sfrac1),
               float4(0,                 1,                sx6m2,                 1));
    
    m *= factor * (1/sx6);
    
    m[0][0] = div6 * factor;
    
    return m;
// ----------------------------------------------------------------------------
// BSpline
// ----------------------------------------------------------------------------
// convert BSpline cv to Bezier cv
template<typename VertexType> //VertexType should be some type that implements float3 VertexType::GetPosition()
static void OsdComputePerPatchVertexBSpline(int3 patchParam, unsigned ID, threadgroup VertexType* cv, device OsdPerPatchVertexBezier& result)
    int i = ID%4;
    int j = ID/4;
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    float3 P  = float3(0,0,0); // 0 to 1-2^(-Sf)
    float3 P1 = float3(0,0,0); // 1-2^(-Sf) to 1-2^(-Sc)
    float3 P2 = float3(0,0,0); // 1-2^(-Sc) to 1
    float sharpness = OsdGetPatchSharpness(patchParam);
    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);
    if (sharpness > 0 && (boundaryMask & 15))
    {
        float Sf = floor(sharpness);
        float Sc = ceil(sharpness);
        float Sr = fract(sharpness);
        float4x4 Mj = OsdComputeMs2(Sf, 1-Sr);
        float4x4 Ms = Mj;
        Mj += (Sr * Mi);
        Ms += OsdComputeMs2(Sc, Sr);
#if USE_PTVS_SHARPNESS
#else
        float s0 = 1 - exp2(-Sf);
        float s1 = 1 - exp2(-Sc);
        result.vSegments = float2(s0, s1);
#endif
        
        bool isBoundary[2];
        isBoundary[0] = (((boundaryMask & 8) != 0) || ((boundaryMask & 2) != 0)) ? true : false;
        isBoundary[1] = (((boundaryMask & 4) != 0) || ((boundaryMask & 1) != 0)) ? true : false;
        bool needsFlip[2];
        needsFlip[0] = (boundaryMask & 8) ? true : false;
        needsFlip[1] = (boundaryMask & 1) ? true : false;
        float3 Hi[4], Hj[4], Hs[4];
        
        if (isBoundary[0])
        {
            int t[4] = {0,1,2,3};
            int ti = i, step = 1, start = 0;
            if (needsFlip[0]) {
                t[0] = 3; t[1] = 2; t[2] = 1; t[3] = 0;
                ti = 3-i;
                start = 3; step = -1;
            }
            for (int l=0; l<4; ++l) {
                Hi[l] = Hj[l] = Hs[l] = float3(0,0,0);
                for (int k=0, tk = start; k<4; ++k, tk+=step) {
                    float3 p = cv[l*4 + k].GetPosition();
                    Hi[l] += Mi[ti][tk] * p;
                    Hj[l] += Mj[ti][tk] * p;
                    Hs[l] += Ms[ti][tk] * p;
                }
            }
        }
        else
        {
            for (int l=0; l<4; ++l) {
                Hi[l] = Hj[l] = Hs[l] = float3(0,0,0);
                for (int k=0; k<4; ++k) {
                    float3 p = cv[l*4 + k].GetPosition();
                    float3 val = Q[i][k] * p;
                    Hi[l] += val;
                    Hj[l] += val;
                    Hs[l] += val;
                }
            }
        }
        {
            int t[4] = {0,1,2,3};
            int tj = j, step = 1, start = 0;
            if (needsFlip[1]) {
                t[0] = 3; t[1] = 2; t[2] = 1; t[3] = 0;
                tj = 3-j;
                start = 3; step = -1;
            }
            for (int k=0, tk = start; k<4; ++k, tk+=step) {
                if (isBoundary[1])
                {
                    P  += Mi[tj][tk]*Hi[k];
                    P1 += Mj[tj][tk]*Hj[k];
                    P2 += Ms[tj][tk]*Hs[k];
                }
                else
                {
                    P  += Q[j][k]*Hi[k];
                    P1 += Q[j][k]*Hj[k];
                    P2 += Q[j][k]*Hs[k];
                }
            }
        }
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    result.P  = half3(P);
    result.P1 = half3(P1);
    result.P2 = half3(P2);
#else
    result.P  = P;
    result.P1 = P1;
    result.P2 = P2;
#endif //C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    } else {
#if USE_PTVS_SHARPNESS
#else
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
        result.vSegments = half2(0, 0);
#else
        result.vSegments = float2(0, 0);
#endif //C3D_OPTIMIZE_OPENSUBDIV_STORAGE
#endif
        OsdComputeBSplineBoundaryPoints(cv, patchParam);
    float3 Hi[4];
    for (int l=0; l<4; ++l) {
        Hi[l] = float3(0,0,0);
        for (int k=0; k<4; ++k) {
            Hi[l] += Q[i][k] * cv[l*4 + k].GetPosition();
        }
    }
    for (int k=0; k<4; ++k) {
        P += Q[j][k]*Hi[k];
    }
        
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    result.P  = half3(P);
    result.P1 = half3(P);
    result.P2 = half3(P);
#else
    result.P  = P;
    result.P1 = P;
    result.P2 = P;
#endif //C3D_OPTIMIZE_OPENSUBDIV_STORAGE
#else
    OsdComputeBSplineBoundaryPoints(cv, patchParam);
    float3 H[4];
    for (int l=0; l<4; ++l) {
        H[l] = float3(0,0,0);
        for(int k=0; k<4; ++k) {
            H[l] += Q[i][k] * (cv + l*4 + k)->GetPosition();
        }
    }
    {
        float3 P = float3(0,0,0);
        for (int k=0; k<4; ++k){
            P += Q[j][k]*H[k];
        }
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
        result.P = half3(P);
#else
        result.P = P;
#endif
    }
#endif
template<typename PerPatchVertexBezier>
static void OsdEvalPatchBezier(int3 patchParam, float2 UV,
                   PerPatchVertexBezier cv,
                   thread float3& P, thread float3& dPu, thread float3& dPv,
                   thread float3& N, thread float3& dNu, thread float3& dNv,
                   thread float2& vSegments)
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    float B[4], D[4], C[4];
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    DUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    CUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    OsdUnivar4x4(UV.x, B, D, C);
#else
    float B[4], D[4];
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    DUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    OsdUnivar4x4(UV.x, B, D);
#endif
    // ----------------------------------------------------------------
#if OSD_PATCH_ENABLE_SINGLE_CREASE
#if USE_PTVS_SHARPNESS
    float sharpness = OsdGetPatchSharpness(patchParam);
    float Sf = floor(sharpness);
    float Sc = ceil(sharpness);
    float s0 = 1 - exp2(-Sf);
    float s1 = 1 - exp2(-Sc);
    vSegments = float2(s0, s1);
#else //USE_PTVS_SHARPNESS
    vSegments = cv[0].vSegments;
#endif //USE_PTVS_SHARPNESS
    float s = OsdGetPatchSingleCreaseSegmentParameter(patchParam, UV);
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            int k = 4*i + j;
            float3 A = (s <= vSegments.x) ? float3(cv[k].P)
            :   ((s <= vSegments.y) ?  float3(cv[k].P1)
                 :  float3(cv[k].P2));
            BUCP[i] += A * B[j];
            DUCP[i] += A * D[j];
#if OSD_COMPUTE_NORMAL_DERIVATIVES
            CUCP[i] += A * C[j];
#endif //OSD_COMPUTE_NORMAL_DERIVATIVES
        }
    }
#else //OSD_PATCH_ENABLE_SINGLE_CREASE
    // ----------------------------------------------------------------
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            float3 A = float3(cv[4*i + j].P);
            BUCP[i] += A * B[j];
            DUCP[i] += A * D[j];
#if OSD_COMPUTE_NORMAL_DERIVATIVES
            CUCP[i] += A * C[j];
#endif //OSD_COMPUTE_NORMAL_DERIVATIVES
        }
    }
#endif //OSD_PATCH_ENABLE_SINGLE_CREASE
    // ----------------------------------------------------------------
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    // used for weingarten term
    OsdUnivar4x4(UV.y, B, D, C);
    P = B[0] * BUCP[0];
    dPu = B[0] * DUCP[0];
    dPv = D[0] * BUCP[0];
    float3 dUU = B[0] * CUCP[0];
    float3 dVV = C[0] * BUCP[0];
    float3 dUV = D[0] * DUCP[0];
    for (int k=1; k<4; ++k) {
        P   += B[k] * BUCP[k];
        dPu += B[k] * DUCP[k];
        dPv += D[k] * BUCP[k];
        dUU += B[k] * CUCP[k];
        dVV += C[k] * BUCP[k];
        dUV += D[k] * DUCP[k];
    }
    int level = OsdGetPatchFaceLevel(patchParam);
    dPu *= 3 * level;
    dPv *= 3 * level;
    dUU *= 6 * level;
    dVV *= 6 * level;
    dUV *= 9 * level;
    float3 n = cross(dPu, dPv);
    float ln = 1.0 / length(n);
    N = ln * n;
    float E = dot(dPu, dPu);
    float F = dot(dPu, dPv);
    float G = dot(dPv, dPv);
    float e = dot(N, dUU);
    float f = dot(N, dUV);
    float g = dot(N, dVV);
    float EGFF = 1.0 / (E*G - F*F);
    dNu = (f*F-e*G) * EGFF * dPu + (e*F-f*E) * EGFF * dPv;
    dNv = (g*F-f*G) * EGFF * dPu + (f*F-g*E) * EGFF * dPv;
    float powrn = 1.0 / powr(dot(n,n), 1.5);
    dNu = dNu * ln - n * (dot(dNu,n) * powrn);
    dNv = dNv * ln - n * (dot(dNv,n) * powrn);
#else //OSD_COMPUTE_NORMAL_DERIVATIVES
    OsdUnivar4x4(UV.y, B, D);
    P = B[0] * BUCP[0];
    dPu = B[0] * DUCP[0];
    dPv = D[0] * BUCP[0];
    for (int k=1; k<4; ++k) {
        P   += B[k] * BUCP[k];
        dPu += B[k] * DUCP[k];
        dPv += D[k] * BUCP[k];
    }
    int level = OsdGetPatchFaceLevel(patchParam);
    dPu *= 3 * level;
    dPv *= 3 * level;
    N = normalize(cross(dPu, dPv));
    dNu = float3(0,0,0);
    dNv = float3(0,0,0);
#endif //OSD_COMPUTE_NORMAL_DERIVATIVES
// compute single-crease patch matrix
static float4x4 OsdComputeMs(float sharpness)
    float s = exp2(sharpness);
    float s2 = s*s;
    float s3 = s2*s;
    float4x4 m(
        float4(0, s + 1 + 3*s2 - s3, 7*s - 2 - 6*s2 + 2*s3, (1-s)*(s-1)*(s-1)),
        float4(0,       (1+s)*(1+s),        6*s - 2 - 2*s2,       (s-1)*(s-1)),
        float4(0,               1+s,               6*s - 2,               1-s),
        float4(0,                 1,               6*s - 2,                 1));
    m[0] /= (s*6.0);
    m[1] /= (s*6.0);
    m[2] /= (s*6.0);
    m[3] /= (s*6.0);
    m[0][0] = 1.0/6.0;
    return m;
// flip matrix orientation
static float4x4 OsdFlipMatrix(float4x4 m)
    return float4x4(float4(m[3][3], m[3][2], m[3][1], m[3][0]),
                    float4(m[2][3], m[2][2], m[2][1], m[2][0]),
                    float4(m[1][3], m[1][2], m[1][1], m[1][0]),
                    float4(m[0][3], m[0][2], m[0][1], m[0][0]));
static void OsdFlipMatrix(threadgroup float * src, threadgroup float * dst)
    for (int i = 0; i < 16; i++) dst[i] = src[15-i];
// ----------------------------------------------------------------------------
// Legacy Gregory
// ----------------------------------------------------------------------------
#if OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY
#if OSD_MAX_VALENCE<=10
constant float ef[7] = {
    0.813008, 0.500000, 0.363636, 0.287505,
    0.238692, 0.204549, 0.179211
#else
constant float ef[27] = {
    0.812816, 0.500000, 0.363644, 0.287514,
    0.238688, 0.204544, 0.179229, 0.159657,
    0.144042, 0.131276, 0.120632, 0.111614,
    0.103872, 0.09715, 0.0912559, 0.0860444,
    0.0814022, 0.0772401, 0.0734867, 0.0700842,
    0.0669851, 0.0641504, 0.0615475, 0.0591488,
    0.0569311, 0.0548745, 0.0529621
#endif
static float cosfn(int n, int j) {
    return cospi((2.0f * j)/float(n));
static float sinfn(int n, int j) {
    return sinpi((2.0f * j)/float(n));
#ifndef OSD_MAX_VALENCE
#define OSD_MAX_VALENCE 4
#endif
template<typename OsdVertexBuffer>
static float3 OsdReadVertex(int vertexIndex, OsdVertexBuffer osdVertexBuffer)
    int index = (vertexIndex /*+ OsdBaseVertex()*/);
    return osdVertexBuffer[index].position;
template<typename OsdValenceBuffer>
static int OsdReadVertexValence(int vertexID, OsdValenceBuffer osdValenceBuffer)
    int index = int(vertexID * (2 * OSD_MAX_VALENCE + 1));
    return osdValenceBuffer[index];
template<typename OsdValenceBuffer>
static int OsdReadVertexIndex(int vertexID, int valenceVertex, OsdValenceBuffer osdValenceBuffer)
    int index = int(vertexID * (2 * OSD_MAX_VALENCE + 1) + 1 + valenceVertex);
    return osdValenceBuffer[index];
template<typename OsdQuadOffsetBuffer>
static int OsdReadQuadOffset(int primitiveID, int offsetVertex, OsdQuadOffsetBuffer osdQuadOffsetBuffer)
    int index = int(4*primitiveID + offsetVertex);
    return osdQuadOffsetBuffer[index];
static void OsdComputePerVertexGregory(unsigned vID, float3 P, threadgroup OsdPerVertexGregory& v, OsdPatchParamBufferSet osdBuffers)
    v.clipFlag = short3(0,0,0);
    int ivalence = OsdReadVertexValence(vID, osdBuffers.valenceBuffer);
    v.valence = ivalence;
    int valence = abs(ivalence);
    float3 f[OSD_MAX_VALENCE];
    float3 pos = P;
    float3 opos = float3(0,0,0);
#if OSD_PATCH_GREGORY_BOUNDARY
    v.org = pos;
    int boundaryEdgeNeighbors[2];
    int currNeighbor = 0;
    int ibefore = 0;
    int zerothNeighbor = 0;
#endif
    for (int i=0; i<valence; ++i) {
        int im = (i+valence-1)%valence;
        int ip = (i+1)%valence;
        int idx_neighbor = OsdReadVertexIndex(vID, 2*i, osdBuffers.valenceBuffer);
#if OSD_PATCH_GREGORY_BOUNDARY
        bool isBoundaryNeighbor = false;
        int valenceNeighbor = OsdReadVertexValence(idx_neighbor, osdBuffers.valenceBuffer);
        if (valenceNeighbor < 0) {
            isBoundaryNeighbor = true;
            if (currNeighbor<2) {
                boundaryEdgeNeighbors[currNeighbor] = idx_neighbor;
            }
            currNeighbor++;
            if (currNeighbor == 1) {
                ibefore = i;
                zerothNeighbor = i;
            } else {
                if (i-ibefore == 1) {
                    int tmp = boundaryEdgeNeighbors[0];
                    boundaryEdgeNeighbors[0] = boundaryEdgeNeighbors[1];
                    boundaryEdgeNeighbors[1] = tmp;
                    zerothNeighbor = i;
                }
            }
        }
#endif
        float3 neighbor = OsdReadVertex(idx_neighbor, osdBuffers.vertexBuffer);
        int idx_diagonal = OsdReadVertexIndex(vID, 2*i + 1, osdBuffers.valenceBuffer);
        float3 diagonal = OsdReadVertex(idx_diagonal, osdBuffers.vertexBuffer);
        int idx_neighbor_p = OsdReadVertexIndex(vID, 2*ip, osdBuffers.valenceBuffer);
        float3 neighbor_p = OsdReadVertex(idx_neighbor_p, osdBuffers.vertexBuffer);
        int idx_neighbor_m = OsdReadVertexIndex(vID, 2*im, osdBuffers.valenceBuffer);
        float3 neighbor_m = OsdReadVertex(idx_neighbor_m, osdBuffers.vertexBuffer);
        int idx_diagonal_m = OsdReadVertexIndex(vID, 2*im + 1, osdBuffers.valenceBuffer);
        float3 diagonal_m = OsdReadVertex(idx_diagonal_m, osdBuffers.vertexBuffer);
        f[i] = (pos * float(valence) + (neighbor_p + neighbor)*2.0f + diagonal) / (float(valence)+5.0f);
        opos += f[i];
        v.r[i] = (neighbor_p-neighbor_m)/3.0f + (diagonal - diagonal_m)/6.0f;
    }
    opos /= valence;
    v.P = float4(opos, 1.0f).xyz;
    float3 e;
    v.e0 = float3(0,0,0);
    v.e1 = float3(0,0,0);
    for(int i=0; i<valence; ++i) {
        int im = (i + valence -1) % valence;
        e = 0.5f * (f[i] + f[im]);
        v.e0 += cosfn(valence, i)*e;
        v.e1 += sinfn(valence, i)*e;
    }
    v.e0 *= ef[valence - 3];
    v.e1 *= ef[valence - 3];
#if OSD_PATCH_GREGORY_BOUNDARY
    v.zerothNeighbor = zerothNeighbor;
    if (currNeighbor == 1) {
        boundaryEdgeNeighbors[1] = boundaryEdgeNeighbors[0];
    }
    if (ivalence < 0) {
        if (valence > 2) {
            v.P = (OsdReadVertex(boundaryEdgeNeighbors[0], osdBuffers.vertexBuffer) +
                   OsdReadVertex(boundaryEdgeNeighbors[1], osdBuffers.vertexBuffer) +
                   4.0f * pos)/6.0f;
        } else {
            v.P = pos;
        }
        v.e0 = (OsdReadVertex(boundaryEdgeNeighbors[0], osdBuffers.vertexBuffer) -
                OsdReadVertex(boundaryEdgeNeighbors[1], osdBuffers.vertexBuffer))/6.0;
        float k = float(float(valence) - 1.0f);    //k is the number of faces
        float c = cospi(1.0/k);
        float s = sinpi(1.0/k);
        float gamma = -(4.0f*s)/(3.0f*k+c);
        float alpha_0k = -((1.0f+2.0f*c)*sqrt(1.0f+c))/((3.0f*k+c)*sqrt(1.0f-c));
        float beta_0 = s/(3.0f*k + c);
        int idx_diagonal = OsdReadVertexIndex(vID, 2*zerothNeighbor + 1, osdBuffers.valenceBuffer);
        float3 diagonal = OsdReadVertex(idx_diagonal, osdBuffers.vertexBuffer);
        v.e1 = gamma * pos +
            alpha_0k * OsdReadVertex(boundaryEdgeNeighbors[0], osdBuffers.vertexBuffer) +
            alpha_0k * OsdReadVertex(boundaryEdgeNeighbors[1], osdBuffers.vertexBuffer) +
            beta_0 * diagonal;
        for (int x=1; x<valence - 1; ++x) {
            int curri = ((x + zerothNeighbor)%valence);
            float alpha = (4.0f*sinpi((float(x))/k))/(3.0f*k+c);
            float beta = (sinpi((float(x))/k) + sinpi((float(x+1))/k))/(3.0f*k+c);
            int idx_neighbor = OsdReadVertexIndex(vID, 2*curri, osdBuffers.valenceBuffer);
            float3 neighbor = OsdReadVertex(idx_neighbor, osdBuffers.vertexBuffer);
            idx_diagonal = OsdReadVertexIndex(vID, 2*curri + 1, osdBuffers.valenceBuffer);
            diagonal = OsdReadVertex(idx_diagonal, osdBuffers.vertexBuffer);
            v.e1 += alpha * neighbor + beta * diagonal;
        }
        v.e1 /= 3.0f;
    }
#endif
static void OsdComputePerPatchVertexGregory(int3 patchParam, unsigned ID, unsigned primitiveID,
                                threadgroup OsdPerVertexGregory* v,
                                device OsdPerPatchVertexGregory& result,
                                OsdPatchParamBufferSet osdBuffers)
    result.P = v[ID].P;
    int i = ID;
    int ip = (i+1)%4;
    int im = (i+3)%4;
    int valence = abs(v[i].valence);
    int n = valence;
    int start = OsdReadQuadOffset(primitiveID, i, osdBuffers.quadOffsetBuffer) & 0xff;
    int prev = (OsdReadQuadOffset(primitiveID, i, osdBuffers.quadOffsetBuffer) >> 8) & 0xff;
    int start_m = OsdReadQuadOffset(primitiveID, im, osdBuffers.quadOffsetBuffer) & 0xff;
    int prev_p = (OsdReadQuadOffset(primitiveID, ip, osdBuffers.quadOffsetBuffer) >> 8) & 0xff;
    int np = abs(v[ip].valence);
    int nm = abs(v[im].valence);
    // Control Vertices based on :
    // "Approximating Subdivision Surfaces with Gregory Patches
    //  for Hardware Tessellation"
    // Loop, Schaefer, Ni, Castano (ACM ToG Siggraph Asia 2009)
    //
    //  P3         e3-      e2+         P2
    //     O--------O--------O--------O
    //     |        |        |        |
    //     |        |        |        |
    //     |        | f3-    | f2+    |
    //     |        O        O        |
    // e3+ O------O            O------O e2-
    //     |     f3+          f2-     |
    //     |                          |
    //     |                          |
    //     |      f0-         f1+     |
    // e0- O------O            O------O e1+
    //     |        O        O        |
    //     |        | f0+    | f1-    |
    //     |        |        |        |
    //     |        |        |        |
    //     O--------O--------O--------O
    //  P0         e0+      e1-         P1
    //
#if OSD_PATCH_GREGORY_BOUNDARY
    float3 Em_ip;
    if (v[ip].valence < -2) {
        int j = (np + prev_p - v[ip].zerothNeighbor) % np;
        Em_ip = v[ip].P + cospi(j/float(np-1))*v[ip].e0 + sinpi(j/float(np-1))*v[ip].e1;
    } else {
        Em_ip = v[ip].P + v[ip].e0*cosfn(np, prev_p) + v[ip].e1*sinfn(np, prev_p);
    }
    float3 Ep_im;
    if (v[im].valence < -2) {
        int j = (nm + start_m - v[im].zerothNeighbor) % nm;
        Ep_im = v[im].P + cospi(j/float(nm-1))*v[im].e0 + sinpi(j/float(nm-1))*v[im].e1;
    } else {
        Ep_im = v[im].P + v[im].e0*cosfn(nm, start_m) + v[im].e1*sinfn(nm, start_m);
    }
    if (v[i].valence < 0) {
        n = (n-1)*2;
    }
    if (v[im].valence < 0) {
        nm = (nm-1)*2;
    }
    if (v[ip].valence < 0) {
        np = (np-1)*2;
    }
    if (v[i].valence > 2) {
        result.Ep = v[i].P + (v[i].e0*cosfn(n, start) + v[i].e1*sinfn(n, start));
        result.Em = v[i].P + (v[i].e0*cosfn(n, prev) +  v[i].e1*sinfn(n, prev));
        float s1=3-2*cosfn(n,1)-cosfn(np,1);
        float s2=2*cosfn(n,1);
        result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;
        s1 = 3.0f-2.0f*cospi(2.0f/float(n))-cospi(2.0f/float(nm));
        result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;
    } else if (v[i].valence < -2) {
        int j = (valence + start - v[i].zerothNeighbor) % valence;
        result.Ep = v[i].P + cospi(j/float(valence-1))*v[i].e0 + sinpi(j/float(valence-1))*v[i].e1;
        j = (valence + prev - v[i].zerothNeighbor) % valence;
        result.Em = v[i].P + cospi(j/float(valence-1))*v[i].e0 + sinpi(j/float(valence-1))*v[i].e1;
        float3 Rp = ((-2.0f * v[i].org - 1.0f * v[im].org) + (2.0f * v[ip].org + 1.0f * v[(i+2)%4].org))/3.0f;
        float3 Rm = ((-2.0f * v[i].org - 1.0f * v[ip].org) + (2.0f * v[im].org + 1.0f * v[(i+2)%4].org))/3.0f;
        float s1 = 3-2*cosfn(n,1)-cosfn(np,1);
        float s2 = 2*cosfn(n,1);
        result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;
        s1 = 3.0f-2.0f*cospi(2.0f/float(n))-cospi(2.0f/float(nm));
        result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;
        if (v[im].valence < 0) {
            s1 = 3-2*cosfn(n,1)-cosfn(np,1);
            result.Fp = result.Fm = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;
        } else if (v[ip].valence < 0) {
            s1 = 3.0f-2.0f*cospi(2.0f/n)-cospi(2.0f/nm);
            result.Fm = result.Fp = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;
        }
    } else if (v[i].valence == -2) {
        result.Ep = (2.0f * v[i].org + v[ip].org)/3.0f;
        result.Em = (2.0f * v[i].org + v[im].org)/3.0f;
        result.Fp = result.Fm = (4.0f * v[i].org + v[(i+2)%n].org + 2.0f * v[ip].org + 2.0f * v[im].org)/9.0f;
    }
#else // not OSD_PATCH_GREGORY_BOUNDARY
    result.Ep = v[i].P + v[i].e0 * cosfn(n, start) + v[i].e1*sinfn(n, start);
    result.Em = v[i].P + v[i].e0 * cosfn(n, prev ) + v[i].e1*sinfn(n, prev );
    float3 Em_ip = v[ip].P + v[ip].e0*cosfn(np, prev_p) + v[ip].e1*sinfn(np, prev_p);
    float3 Ep_im = v[im].P + v[im].e0*cosfn(nm, start_m) + v[im].e1*sinfn(nm, start_m);
    float s1 = 3-2*cosfn(n,1)-cosfn(np,1);
    float s2 = 2*cosfn(n,1);
    result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;
    s1 = 3.0f-2.0f*cospi(2.0f/float(n))-cospi(2.0f/float(nm));
    result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em +s2*Ep_im - v[i].r[prev])/3.0f;
#endif
#endif  // OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY
//   Copyright 2016 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
#ifndef OPENSUBDIV3_OSD_PATCH_BASIS_COMMON_H
#define OPENSUBDIV3_OSD_PATCH_BASIS_COMMON_H
#if defined(OSD_PATCH_BASIS_GLSL)
    #define OSD_FUNCTION_STORAGE_CLASS
    #define OSD_DATA_STORAGE_CLASS
    #define OSD_OPTIONAL(a) true
    #define OSD_OPTIONAL_INIT(a,b) b
    #define OSD_OUT out
    #define OSD_INOUT inout
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             elementType[](a0,a1,a2,a3,a4,a5,a6,a7)
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             elementType[](a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)
#elif defined(OSD_PATCH_BASIS_HLSL)
    #define OSD_FUNCTION_STORAGE_CLASS
    #define OSD_DATA_STORAGE_CLASS
    #define OSD_OPTIONAL(a) true
    #define OSD_OPTIONAL_INIT(a,b) b
    #define OSD_OUT out
    #define OSD_INOUT inout
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             {a0,a1,a2,a3,a4,a5,a6,a7}
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}
#elif defined(OSD_PATCH_BASIS_CUDA)
    #define OSD_FUNCTION_STORAGE_CLASS __device__
    #define OSD_DATA_STORAGE_CLASS
    #define OSD_OPTIONAL(a) true
    #define OSD_OPTIONAL_INIT(a,b) b
    #define OSD_OUT
    #define OSD_INOUT
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             {a0,a1,a2,a3,a4,a5,a6,a7}
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}
#elif defined(OSD_PATCH_BASIS_OPENCL)
    #define OSD_FUNCTION_STORAGE_CLASS static
    #define OSD_DATA_STORAGE_CLASS
    #define OSD_OPTIONAL(a) true
    #define OSD_OPTIONAL_INIT(a,b) b
    #define OSD_OUT
    #define OSD_INOUT
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             {a0,a1,a2,a3,a4,a5,a6,a7}
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}
#elif defined(OSD_PATCH_BASIS_METAL)
    #define OSD_FUNCTION_STORAGE_CLASS static
    #define OSD_DATA_STORAGE_CLASS
    #define OSD_OPTIONAL(a) true
    #define OSD_OPTIONAL_INIT(a,b) b
    #define OSD_OUT
    #define OSD_INOUT
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) thread elementType* identifier
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             {a0,a1,a2,a3,a4,a5,a6,a7}
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}
#else
    #define OSD_FUNCTION_STORAGE_CLASS static inline
    #define OSD_DATA_STORAGE_CLASS static
    #define OSD_OPTIONAL(a) (a)
    #define OSD_OPTIONAL_INIT(a,b) (a ? b : 0)
    #define OSD_OUT
    #define OSD_INOUT
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             {a0,a1,a2,a3,a4,a5,a6,a7}
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}
#endif
OSD_FUNCTION_STORAGE_CLASS
void
OsdGetBezierWeights(
    float t, OSD_TYPE_ARRAY(OSD_OUT float, wP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDP2, 4)) {
    // The four uniform cubic Bezier basis functions (in terms of t and its
    // complement tC) evaluated at t:
    float t2 = t*t;
    float tC = 1.0f - t;
    float tC2 = tC * tC;
    wP[0] = tC2 * tC;
    wP[1] = tC2 * t * 3.0f;
    wP[2] = t2 * tC * 3.0f;
    wP[3] = t2 * t;
    // Derivatives of the above four basis functions at t:
    if (OSD_OPTIONAL(wDP)) {
       wDP[0] = -3.0f * tC2;
       wDP[1] =  9.0f * t2 - 12.0f * t + 3.0f;
       wDP[2] = -9.0f * t2 +  6.0f * t;
       wDP[3] =  3.0f * t2;
    }
    // Second derivatives of the basis functions at t:
    if (OSD_OPTIONAL(wDP2)) {
        wDP2[0] =   6.0f * tC;
        wDP2[1] =  18.0f * t - 12.0f;
        wDP2[2] = -18.0f * t +  6.0f;
        wDP2[3] =   6.0f * t;
    }
OSD_FUNCTION_STORAGE_CLASS
void
OsdGetBSplineWeights(
    float t, OSD_TYPE_ARRAY(OSD_OUT float, wP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDP2, 4)) {
    // The four uniform cubic B-Spline basis functions evaluated at t:
    const float one6th = 1.0f / 6.0f;
    float t2 = t * t;
    float t3 = t * t2;
    wP[0] = one6th * (1.0f - 3.0f*(t -      t2) -      t3);
    wP[1] = one6th * (4.0f           - 6.0f*t2  + 3.0f*t3);
    wP[2] = one6th * (1.0f + 3.0f*(t +      t2  -      t3));
    wP[3] = one6th * (                                 t3);
    // Derivatives of the above four basis functions at t:
    if (OSD_OPTIONAL(wDP)) {
        wDP[0] = -0.5f*t2 +      t - 0.5f;
        wDP[1] =  1.5f*t2 - 2.0f*t;
        wDP[2] = -1.5f*t2 +      t + 0.5f;
        wDP[3] =  0.5f*t2;
    }
    // Second derivatives of the basis functions at t:
    if (OSD_OPTIONAL(wDP2)) {
        wDP2[0] = -       t + 1.0f;
        wDP2[1] =  3.0f * t - 2.0f;
        wDP2[2] = -3.0f * t + 1.0f;
        wDP2[3] =         t;
    }
OSD_FUNCTION_STORAGE_CLASS
void
OsdGetBoxSplineWeights(float v, float w, OSD_TYPE_ARRAY(OSD_OUT float, wP, 12)) {
    float u = 1.0f - v - w;
    //
    //  The 12 basis functions of the quartic box spline (unscaled by their common
    //  factor of 1/12 until later, and formatted to make it easy to spot any
    //  typing errors):
    //
    //      15 terms for the 3 points above the triangle corners
    //       9 terms for the 3 points on faces opposite the triangle edges
    //       2 terms for the 6 points on faces opposite the triangle corners
    //
    //  Powers of each variable for notational convenience:
    float u2 = u*u;
    float u3 = u*u2;
    float u4 = u*u3;
    float v2 = v*v;
    float v3 = v*v2;
    float v4 = v*v3;
    float w2 = w*w;
    float w3 = w*w2;
    float w4 = w*w3;
    //  And now the basis functions:
    wP[ 0] = u4 + 2.0f*u3*v;
    wP[ 1] = u4 + 2.0f*u3*w;
    wP[ 8] = w4 + 2.0f*w3*u;
    wP[11] = w4 + 2.0f*w3*v;
    wP[ 9] = v4 + 2.0f*v3*w;
    wP[ 5] = v4 + 2.0f*v3*u;
    wP[ 2] = u4 + 2.0f*u3*w + 6.0f*u3*v + 6.0f*u2*v*w + 12.0f*u2*v2 +
                v4 + 2.0f*v3*w + 6.0f*v3*u + 6.0f*v2*u*w;
    wP[ 4] = w4 + 2.0f*w3*v + 6.0f*w3*u + 6.0f*w2*u*v + 12.0f*w2*u2 +
                u4 + 2.0f*u3*v + 6.0f*u3*w + 6.0f*u2*v*w;
    wP[10] = v4 + 2.0f*v3*u + 6.0f*v3*w + 6.0f*v2*w*u + 12.0f*v2*w2 +
                w4 + 2.0f*w3*u + 6.0f*w3*v + 6.0f*w3*u*v;
    wP[ 3] = v4 + 6*v3*w + 8*v3*u + 36*v2*w*u + 24*v2*u2 + 24*v*u3 +
                w4 + 6*w3*v + 8*w3*u + 36*w2*v*u + 24*w2*u2 + 24*w*u3 + 6*u4 + 60*u2*v*w + 12*v2*w2;
    wP[ 6] = w4 + 6*w3*u + 8*w3*v + 36*w2*u*v + 24*w2*v2 + 24*w*v3 +
                u4 + 6*u3*w + 8*u3*v + 36*u2*v*w + 24*u2*v2 + 24*u*v3 + 6*v4 + 60*v2*w*u + 12*w2*u2;
    wP[ 7] = u4 + 6*u3*v + 8*u3*w + 36*u2*v*w + 24*u2*w2 + 24*u*w3 +
                v4 + 6*v3*u + 8*v3*w + 36*v2*u*w + 24*v2*w2 + 24*v*w3 + 6*w4 + 60*w2*u*v + 12*u2*v2;
    for (int i = 0; i < 12; ++i) {
        wP[i] *= 1.0f / 12.0f;
    }
OSD_FUNCTION_STORAGE_CLASS
void
OsdGetBilinearPatchWeights(
        float s, float t, float dScale,
        OSD_TYPE_ARRAY(OSD_OUT float, wP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDs, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDt, 4),
        OSD_TYPE_ARRAY(OSD_OUT float, wDss, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDst, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDtt, 4)) {
    float sC = 1.0f - s,
          tC = 1.0f - t;
    if (OSD_OPTIONAL(wP)) {
        wP[0] = sC * tC;
        wP[1] =  s * tC;
        wP[2] =  s * t;
        wP[3] = sC * t;
    }
    if (OSD_OPTIONAL(derivS && derivT)) {
        wDs[0] = -tC * dScale;
        wDs[1] =  tC * dScale;
        wDs[2] =   t * dScale;
        wDs[3] =  -t * dScale;
        wDt[0] = -sC * dScale;
        wDt[1] =  -s * dScale;
        wDt[2] =   s * dScale;
        wDt[3] =  sC * dScale;
        if (OSD_OPTIONAL(derivSS && derivST && derivTT)) {
            float d2Scale = dScale * dScale;
            for(int i=0;i<4;i++) {
                wDss[i] = 0;
                wDtt[i] = 0;
            }
            wDst[0] =  d2Scale;
            wDst[1] = -d2Scale;
            wDst[2] = -d2Scale;
            wDst[3] =  d2Scale;
        }
    }
OSD_FUNCTION_STORAGE_CLASS
void OsdAdjustBoundaryWeights(
        int boundary,
        OSD_TYPE_ARRAY(OSD_INOUT float, sWeights, 4), OSD_TYPE_ARRAY(OSD_INOUT float, tWeights, 4)) {
    if ((boundary & 1) != 0) {
        tWeights[2] -= tWeights[0];
        tWeights[1] += 2*tWeights[0];
        tWeights[0] = 0;
    }
    if ((boundary & 2) != 0) {
        sWeights[1] -= sWeights[3];
        sWeights[2] += 2*sWeights[3];
        sWeights[3] = 0;
    }
    if ((boundary & 4) != 0) {
        tWeights[1] -= tWeights[3];
        tWeights[2] += 2*tWeights[3];
        tWeights[3] = 0;
    }
    if ((boundary & 8) != 0) {
        sWeights[2] -= sWeights[0];
        sWeights[1] += 2*sWeights[0];
        sWeights[0] = 0;
    }
OSD_FUNCTION_STORAGE_CLASS
void OsdComputeTensorProductPatchWeights(float dScale, int boundary,
    OSD_TYPE_ARRAY(float, sWeights, 4), OSD_TYPE_ARRAY(float, tWeights, 4),
    OSD_TYPE_ARRAY(float, dsWeights, 4), OSD_TYPE_ARRAY(float, dtWeights, 4),
    OSD_TYPE_ARRAY(float, dssWeights, 4), OSD_TYPE_ARRAY(float, dttWeights, 4),
    OSD_TYPE_ARRAY(OSD_OUT float, wP, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDs, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDt, 16),
    OSD_TYPE_ARRAY(OSD_OUT float, wDss, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDst, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDtt, 16)) {
    if (OSD_OPTIONAL(wP)) {
        // Compute the tensor product weight of the (s,t) basis function
        // corresponding to each control vertex:
        OsdAdjustBoundaryWeights(boundary, sWeights, tWeights);
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                wP[4*i+j] = sWeights[j] * tWeights[i];
            }
        }
    }
    if (OSD_OPTIONAL(derivS && derivT)) {
        // Compute the tensor product weight of the differentiated (s,t) basis
        // function corresponding to each control vertex (scaled accordingly):
        OsdAdjustBoundaryWeights(boundary, dsWeights, dtWeights);
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                wDs[4*i+j] = dsWeights[j] * tWeights[i] * dScale;
                wDt[4*i+j] = sWeights[j] * dtWeights[i] * dScale;
            }
        }
        if (OSD_OPTIONAL(derivSS && derivST && derivTT)) {
            // Compute the tensor product weight of appropriate differentiated
            // (s,t) basis functions for each control vertex (scaled accordingly):
            float d2Scale = dScale * dScale;
            OsdAdjustBoundaryWeights(boundary, dssWeights, dttWeights);
            for (int i = 0; i < 4; ++i) {
                for (int j = 0; j < 4; ++j) {
                    wDss[4*i+j] = dssWeights[j] * tWeights[i] * d2Scale;
                    wDst[4*i+j] = dsWeights[j] * dtWeights[i] * d2Scale;
                    wDtt[4*i+j] = sWeights[j] * dttWeights[i] * d2Scale;
                }
            }
        }
    }
OSD_FUNCTION_STORAGE_CLASS
void OsdGetBezierPatchWeights(
    float s, float t, float dScale,
    OSD_TYPE_ARRAY(OSD_OUT float, wP, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDS, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDT, 16),
    OSD_TYPE_ARRAY(OSD_OUT float, wDSS, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDST, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDTT, 16)) {
    float sWeights[4], tWeights[4], dsWeights[4], dtWeights[4], dssWeights[4], dttWeights[4];
    OsdGetBezierWeights(s, OSD_OPTIONAL_INIT(wP, sWeights), OSD_OPTIONAL_INIT(wDS, dsWeights), OSD_OPTIONAL_INIT(wDSS, dssWeights));
    OsdGetBezierWeights(t, OSD_OPTIONAL_INIT(wP, tWeights), OSD_OPTIONAL_INIT(wDT, dtWeights), OSD_OPTIONAL_INIT(wDTT, dttWeights));
    OsdComputeTensorProductPatchWeights(dScale, /*boundary=*/0, sWeights, tWeights, dsWeights, dtWeights, dssWeights, dttWeights, wP, wDS, wDT, wDSS, wDST, wDTT);
OSD_FUNCTION_STORAGE_CLASS
void OsdGetBSplinePatchWeights(
    float s, float t, float dScale, int boundary,
    OSD_TYPE_ARRAY(OSD_OUT float, wP, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDs, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDt, 16),
    OSD_TYPE_ARRAY(OSD_OUT float, wDss, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDst, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDtt, 16)) {
    float sWeights[4], tWeights[4], dsWeights[4], dtWeights[4], dssWeights[4], dttWeights[4];
    OsdGetBSplineWeights(s, sWeights, OSD_OPTIONAL_INIT(wDS, dsWeights), OSD_OPTIONAL_INIT(wDSS, dssWeights));
    OsdGetBSplineWeights(t, tWeights, OSD_OPTIONAL_INIT(wDT, dtWeights), OSD_OPTIONAL_INIT(wDTT, dttWeights));
    OsdComputeTensorProductPatchWeights(dScale, boundary, sWeights, tWeights, dsWeights, dtWeights, dssWeights, dttWeights, wP, wDs, wDt, wDss, wDst, wDtt);
OSD_FUNCTION_STORAGE_CLASS
void OsdGetGregoryPatchWeights(
    float s, float t, float dScale,
    OSD_TYPE_ARRAY(OSD_OUT float, wP, 20), OSD_TYPE_ARRAY(OSD_OUT float, wDs, 20), OSD_TYPE_ARRAY(OSD_OUT float, wDt, 20),
    OSD_TYPE_ARRAY(OSD_OUT float, wDss, 20), OSD_TYPE_ARRAY(OSD_OUT float, wDst, 20), OSD_TYPE_ARRAY(OSD_OUT float, wDtt, 20)) {
    //
    //  P3         e3-      e2+         P2
    //     15------17-------11--------10
    //     |        |        |        |
    //     |        |        |        |
    //     |        | f3-    | f2+    |
    //     |       19       13        |
    // e3+ 16-----18           14-----12 e2-
    //     |     f3+          f2-     |
    //     |                          |
    //     |                          |
    //     |      f0-         f1+     |
    // e0- 2------4            8------6 e1+
    //     |        3        9        |
    //     |        | f0+    | f1-    |
    //     |        |        |        |
    //     |        |        |        |
    //     O--------1--------7--------5
    //  P0         e0+      e1-         P1
    //
    //  Indices of boundary and interior points and their corresponding Bezier points
    //  (this can be reduced with more direct indexing and unrolling of loops):
    //
    OSD_DATA_STORAGE_CLASS const int boundaryGregory[12] = OSD_ARRAY_12(int, 0, 1, 7, 5, 2, 6, 16, 12, 15, 17, 11, 10 );
    OSD_DATA_STORAGE_CLASS const int boundaryBezSCol[12] = OSD_ARRAY_12(int, 0, 1, 2, 3, 0, 3,  0,  3,  0,  1,  2,  3 );
    OSD_DATA_STORAGE_CLASS const int boundaryBezTRow[12] = OSD_ARRAY_12(int, 0, 0, 0, 0, 1, 1,  2,  2,  3,  3,  3,  3 );
    OSD_DATA_STORAGE_CLASS const int interiorGregory[8] = OSD_ARRAY_8(int, 3, 4,  8, 9,  13, 14,  18, 19 );
    OSD_DATA_STORAGE_CLASS const int interiorBezSCol[8] = OSD_ARRAY_8(int, 1, 1,  2, 2,   2,  2,   1,  1 );
    OSD_DATA_STORAGE_CLASS const int interiorBezTRow[8] = OSD_ARRAY_8(int, 1, 1,  1, 1,   2,  2,   2,  2 );
    //
    //  Bezier basis functions are denoted with B while the rational multipliers for the
    //  interior points will be denoted G -- so we have B(s), B(t) and G(s,t):
    //
    //  Directional Bezier basis functions B at s and t:
    float Bs[4], Bds[4], Bdss[4];
    float Bt[4], Bdt[4], Bdtt[4];
    OsdGetBezierWeights(s, Bs, OSD_OPTIONAL_INIT(wDs, Bds), OSD_OPTIONAL_INIT(wDss, Bdss));
    OsdGetBezierWeights(t, Bt, OSD_OPTIONAL_INIT(wDt, Bdt), OSD_OPTIONAL_INIT(wDtt, Bdtt));
    //  Rational multipliers G at s and t:
    float sC = 1.0f - s;
    float tC = 1.0f - t;
    //  Use <= here to avoid compiler warnings -- the sums should always be non-negative:
    float df0 = s  + t;   df0 = (df0 <= 0.0f) ? 1.0f : (1.0f / df0);
    float df1 = sC + t;   df1 = (df1 <= 0.0f) ? 1.0f : (1.0f / df1);
    float df2 = sC + tC;  df2 = (df2 <= 0.0f) ? 1.0f : (1.0f / df2);
    float df3 = s  + tC;  df3 = (df3 <= 0.0f) ? 1.0f : (1.0f / df3);
    float G[8] = OSD_ARRAY_8(float, s*df0, t*df0,  t*df1, sC*df1,  sC*df2, tC*df2,  tC*df3, s*df3 );
    //  Combined weights for boundary and interior points:
    for (int i = 0; i < 12; ++i) {
        wP[boundaryGregory[i]] = Bs[boundaryBezSCol[i]] * Bt[boundaryBezTRow[i]];
    }
    for (int i = 0; i < 8; ++i) {
        wP[interiorGregory[i]] = Bs[interiorBezSCol[i]] * Bt[interiorBezTRow[i]] * G[i];
    }
    //
    //  For derivatives, the basis functions for the interior points are rational and ideally
    //  require appropriate differentiation, i.e. product rule for the combination of B and G
    //  and the quotient rule for the rational G itself.  As initially proposed by Loop et al
    //  though, the approximation using the 16 Bezier points arising from the G(s,t) has
    //  proved adequate (and is what the GPU shaders use) so we continue to use that here.
    //
    //  An implementation of the true derivatives is provided for future reference -- it is
    //  unclear if the approximations will hold up under surface analysis involving higher
    //  order differentiation.
    //
    if (OSD_OPTIONAL(wDs && wDt)) {
        bool find_second_partials = OSD_OPTIONAL(wDs && wDst && wDtt);
        //  Remember to include derivative scaling in all assignments below:
        float d2Scale = dScale * dScale;
        //  Combined weights for boundary points -- simple (scaled) tensor products:
        for (int i = 0; i < 12; ++i) {
            int iDst = boundaryGregory[i];
            int tRow = boundaryBezTRow[i];
            int sCol = boundaryBezSCol[i];
            wDs[iDst] = Bds[sCol] * Bt[tRow] * dScale;
            wDt[iDst] = Bdt[tRow] * Bs[sCol] * dScale;
            if (find_second_partials) {
                wDss[iDst] = Bdss[sCol] * Bt[tRow] * d2Scale;
                wDst[iDst] = Bds[sCol] * Bdt[tRow] * d2Scale;
                wDtt[iDst] = Bs[sCol] * Bdtt[tRow] * d2Scale;
            }
        }
        // dclyde's note: skipping half of the product rule like this does seem to change the result a lot in my tests.
        // This is not a runtime bottleneck for cloth sims anyway so I'm just using the accurate version.
#ifndef OPENSUBDIV_GREGORY_EVAL_TRUE_DERIVATIVES
        //  Approximation to the true Gregory derivatives by differentiating the Bezier patch
        //  unique to the given (s,t), i.e. having F = (g^+ * f^+) + (g^- * f^-) as its four
        //  interior points:
        //
        //  Combined weights for interior points -- (scaled) tensor products with G+ or G-:
        for (int i = 0; i < 8; ++i) {
            int iDst = interiorGregory[i];
            int tRow = interiorBezTRow[i];
            int sCol = interiorBezSCol[i];
            wDs[iDst] = Bds[sCol] * Bt[tRow] * G[i] * dScale;
            wDt[iDst] = Bdt[tRow] * Bs[sCol] * G[i] * dScale;
            if (find_second_partials) {
                wDss[iDst] = Bdss[sCol] * Bt[tRow] * G[i] * d2Scale;
                wDst[iDst] = Bds[sCol] * Bdt[tRow] * G[i] * d2Scale;
                wDtt[iDst] = Bs[sCol] * Bdtt[tRow] * G[i] * d2Scale;
            }
        }
#else
        //  True Gregory derivatives using appropriate differentiation of composite functions:
        //
        //  Note that for G(s,t) = N(s,t) / D(s,t), all N' and D' are trivial constants (which
        //  simplifies things for higher order derivatives).  And while each pair of functions
        //  G (i.e. the G+ and G- corresponding to points f+ and f-) must sum to 1 to ensure
        //  Bezier equivalence (when f+ = f-), the pairs of G' must similarly sum to 0.  So we
        //  can potentially compute only one of the pair and negate the result for the other
        //  (and with 4 or 8 computations involving these constants, this is all very SIMD
        //  friendly...) but for now we treat all 8 independently for simplicity.
        //
        //float N[8] = OSD_ARRAY_8(float,    s,     t,      t,     sC,      sC,     tC,      tC,     s );
        float D[8] = OSD_ARRAY_8(float,  df0,   df0,    df1,    df1,     df2,    df2,     df3,   df3 );
        OSD_DATA_STORAGE_CLASS const float Nds[8] = OSD_ARRAY_8(float, 1.0f, 0.0f,  0.0f, -1.0f, -1.0f,  0.0f,  0.0f,  1.0f );
        OSD_DATA_STORAGE_CLASS const float Ndt[8] = OSD_ARRAY_8(float, 0.0f, 1.0f,  1.0f,  0.0f,  0.0f, -1.0f, -1.0f,  0.0f );
        OSD_DATA_STORAGE_CLASS const float Dds[8] = OSD_ARRAY_8(float, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  1.0f );
        OSD_DATA_STORAGE_CLASS const float Ddt[8] = OSD_ARRAY_8(float, 1.0f, 1.0f,  1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f );
        //  Combined weights for interior points -- (scaled) combinations of B, B', G and G':
        for (int i = 0; i < 8; ++i) {
            int iDst = interiorGregory[i];
            int tRow = interiorBezTRow[i];
            int sCol = interiorBezSCol[i];
            //  Quotient rule for G' (re-expressed in terms of G to simplify (and D = 1/D)):
            float Gds = (Nds[i] - Dds[i] * G[i]) * D[i];
            float Gdt = (Ndt[i] - Ddt[i] * G[i]) * D[i];
            //  Product rule combining B and B' with G and G' (and scaled):
            wDs[iDst] = (Bds[sCol] * G[i] + Bs[sCol] * Gds) * Bt[tRow] * dScale;
            wDt[iDst] = (Bdt[tRow] * G[i] + Bt[tRow] * Gdt) * Bs[sCol] * dScale;
            if (find_second_partials) {
                float Dsqr_inv = D[i]*D[i];
                float Gdss = 2.0f * Dds[i] * Dsqr_inv * (G[i] * Dds[i] - Nds[i]);
                float Gdst = Dsqr_inv * (2.0f * G[i] * Dds[i] * Ddt[i] - Nds[i] * Ddt[i] - Ndt[i] * Dds[i]);
                float Gdtt = 2.0f * Ddt[i] * Dsqr_inv * (G[i] * Ddt[i] - Ndt[i]);
                wDss[iDst] = (Bdss[sCol] * G[i] + 2.0f * Bds[sCol] * Gds + Bs[sCol] * Gdss) * Bt[tRow] * d2Scale;
                wDst[iDst] = (Bt[tRow] * (Bs[sCol] * Gdst + Bds[sCol] * Gdt) + Bdt[tRow] * (Bds[sCol] * G[i] + Bs[sCol] * Gds)) * d2Scale;
                wDtt[iDst] = (Bdtt[tRow] * G[i] + 2.0f * Bdt[tRow] * Gdt + Bt[tRow] * Gdtt) * Bs[sCol] * d2Scale;
            }
        }
#endif
    }
#endif /* OPENSUBDIV3_OSD_PATCH_BASIS_COMMON_H */
#define OSD_PATCH_LINES 1
#define OSD_PATCH_TRIANGLES 1
#define OSD_PATCH_QUADS 1
#define OSD_PATCH_BSPLINE 1
#define OSD_PATCH_REGULAR 1
#define OSD_PATCH_GREGORY 1
#define OSD_PATCH_GREGORY_BOUNDARY 1
#define OSD_PATCH_GREGORY_BASIS 1
GetPatchTypeDefine
mtlPatchShaderSource.mm
"Unknown Far::PatchDescriptor::Type" && 0
GetPatchTypeSource
#line 0 "osd/mtlPatchBSpline.metal"
//   Copyright 2015 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//----------------------------------------------------------
// Patches.BSpline.Hull
//----------------------------------------------------------
static void OsdComputePerVertex(
float4 vertexPosition,
    threadgroup HullVertex& hullVertex,
    int vertexId,
    float4x4 ModelViewProjectionMatrix,
    OsdPatchParamBufferSet osdBuffers
    )
    hullVertex.position = vertexPosition;
#if OSD_ENABLE_PATCH_CULL
    float4 clipPos = mul(ModelViewProjectionMatrix, vertexPosition);   
    short3 clip0 = short3(clipPos.x < clipPos.w,                    
    clipPos.y < clipPos.w,                    
    clipPos.z < clipPos.w);                   
    short3 clip1 = short3(clipPos.x > -clipPos.w,                   
    clipPos.y > -clipPos.w,                   
    clipPos.z > -clipPos.w);                  
    hullVertex.clipFlag = short3(clip0) + 2*short3(clip1);              
#endif
    
    OSD_USER_VARYING_PER_CONTROL_POINT(osdBuffers.vertexBuffer[vertexId], hullVertex);
//----------------------------------------------------------
// Patches.BSpline.Factors
//----------------------------------------------------------
static void OsdComputePerPatchBSplineFactors(
    int3 patchParam,
    float tessLevel,
    float4x4 projectionMatrix,
    float4x4 modelViewMatrix,
    device OsdPerPatchVertexBezier* patch
#if !USE_PTVS_FACTORS
    ,device OsdPerPatchTessFactors& patchFactors
#endif
    ,device MTLQuadTessellationFactorsHalf& quadFactors
    float4 tessLevelOuter = float4(0,0,0,0);
    float2 tessLevelInner = float2(0,0);
    float4 tessOuterLo = float4(0,0,0,0);
    float4 tessOuterHi = float4(0,0,0,0);
#if OSD_ENABLE_SCREENSPACE_TESSELLATION
    OsdGetTessLevelsAdaptiveLimitPoints(
        tessLevel, 
        projectionMatrix, 
        modelViewMatrix,
        patch,
        patchParam,
        tessLevelOuter,
        tessLevelInner,
        tessOuterLo,
        tessOuterHi
        );
#else
    OsdGetTessLevelsUniform(
        tessLevel, 
        patchParam, 
        tessLevelOuter,
        tessLevelInner,
        tessOuterLo,
        tessOuterHi
        );
#endif
    quadFactors.edgeTessellationFactor[0] = tessLevelOuter[0];
    quadFactors.edgeTessellationFactor[1] = tessLevelOuter[1];
    quadFactors.edgeTessellationFactor[2] = tessLevelOuter[2];
    quadFactors.edgeTessellationFactor[3] = tessLevelOuter[3];
    quadFactors.insideTessellationFactor[0] = tessLevelInner[0];
    quadFactors.insideTessellationFactor[1] = tessLevelInner[1];
#if !USE_PTVS_FACTORS
    patchFactors.tessOuterLo = tessOuterLo;
    patchFactors.tessOuterHi = tessOuterHi;
#endif
static void OsdComputePerPatchFactors(
int3 patchParam,
float tessLevel,
unsigned patchID,
float4x4 projectionMatrix,
float4x4 modelViewMatrix,
OsdPatchParamBufferSet osdBuffer,
threadgroup PatchVertexType* patchVertices,
device MTLQuadTessellationFactorsHalf& quadFactors
OsdComputePerPatchBSplineFactors(
patchParam, 
tessLevel, 
projectionMatrix, 
modelViewMatrix, 
osdBuffer.perPatchVertexBuffer + patchID * CONTROL_POINTS_PER_PATCH,
#if !USE_PTVS_FACTORS
osdBuffer.patchTessBuffer[patchID],
#endif
quadFactors
//----------------------------------------------------------
// Patches.BSpline.Vertex
//----------------------------------------------------------
static void OsdComputePerPatchVertex(
int3 patchParam, 
unsigned ID, 
unsigned PrimitiveID, 
unsigned ControlID,
threadgroup PatchVertexType* patchVertices,
OsdPatchParamBufferSet osdBuffers
OsdComputePerPatchVertexBSpline(patchParam, ID, patchVertices, osdBuffers.perPatchVertexBuffer[ControlID]);
    
    OSD_USER_VARYING_PER_VERTEX(patchVertices[ID], osdBuffers.perPatchVertexBuffer[ControlID]);
//----------------------------------------------------------
// Patches.BSpline.Domain
//----------------------------------------------------------
template<typename PerPatchVertexBezier>
static OsdPatchVertex ds_regular_patches(
    const float TessLevel,
#if !USE_PTVS_FACTORS
    float4 tessOuterHi,
    float4 tessOuterLo,
#endif
    PerPatchVertexBezier cv,
    int3 patchParam,
    float2 domainCoord)
    OsdPatchVertex output;
    float3 P, dPu, dPv;
    float3 N, dNu, dNv;
    float2 vSegments;
#if !USE_PTVS_FACTORS
    float2 UV = OsdGetTessParameterization(domainCoord,
                                           tessOuterLo,
                                           tessOuterHi);
#else
    auto transitionMask = OsdGetPatchTransitionMask(patchParam);
    float4 tessLevelMin = float4(1)
    + float4(((transitionMask & 8) >> 3),
             ((transitionMask & 1) >> 0),
             ((transitionMask & 2) >> 1),
             ((transitionMask & 4) >> 2));
    float2 UV = OsdGetTessParameterization(domainCoord,
                                           tessLevelMin,
                                           float4(0));
#endif
    OsdEvalPatchBezier(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv, vSegments);
    output.normal = N;
    output.tangent = dPu;
    output.bitangent = dPv;
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    output.Nu = dNu;
    output.Nv = dNv;
#endif
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    output.vSegments = vSegments;
#endif
    output.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);
    output.position = P;
    
    OSD_USER_VARYING_PER_EVAL_POINT(UV, cv[5], cv[6], cv[9], cv[10], output);
    
    return output;
#if USE_STAGE_IN
template<typename PerPatchVertexBezier>
#endif
static OsdPatchVertex OsdComputePatch(
float tessLevel,
float2 domainCoord,
unsigned patchID,
#if USE_STAGE_IN
PerPatchVertexBezier osdPatch
#else
OsdVertexBufferSet osdBuffers
#endif
return ds_regular_patches(
tessLevel,
#if !USE_PTVS_FACTORS
#if USE_STAGE_IN
osdPatch.tessOuterHi,
osdPatch.tessOuterLo,
#else
osdBuffers.patchTessBuffer[patchID].tessOuterHi,
osdBuffers.patchTessBuffer[patchID].tessOuterLo,
#endif
#endif
#if USE_STAGE_IN
osdPatch.cv,
osdPatch.patchParam,
#else
osdBuffers.perPatchVertexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,
osdBuffers.patchParamBuffer[patchID],
#endif
domainCoord
#line 0 "osd/mtlPatchGregory.metal"
//   Copyright 2013 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//----------------------------------------------------------
// Patches.Gregory.Hull
//----------------------------------------------------------
void OsdComputePerVertex(
float4 position,
    threadgroup OsdPerVertexGregory& hullVertex,
    int vertexId,
    float4x4 modelViewProjectionMatrix,
    OsdPatchParamBufferSet osdBuffers
    )
OsdComputePerVertexGregory(vertexId, position.xyz, hullVertex, osdBuffers);
#if OSD_ENABLE_PATCH_CULL
    float4 clipPos = mul(modelViewProjectionMatrix, position);    
    short3 clip0 = short3(clipPos.x < clipPos.w,                    
    clipPos.y < clipPos.w,                    
    clipPos.z < clipPos.w);                   
    short3 clip1 = short3(clipPos.x > -clipPos.w,                   
    clipPos.y > -clipPos.w,                   
    clipPos.z > -clipPos.w);                  
    hullVertex.clipFlag = short3(clip0) + 2*short3(clip1);
#endif
    
    OSD_USER_VARYING_PER_CONTROL_POINT(osdBuffers.vertexBuffer[vertexId], hullVertex);
//----------------------------------------------------------
// Patches.Gregory.Factors
//----------------------------------------------------------
void OsdComputePerPatchFactors(
int3 patchParam,
float tessLevel,
unsigned patchID,
float4x4 projectionMatrix,
float4x4 modelViewMatrix,
OsdPatchParamBufferSet osdBuffer,
threadgroup PatchVertexType* patchVertices,
device MTLQuadTessellationFactorsHalf& quadFactors
    float4 tessLevelOuter = float4(0,0,0,0);
    float2 tessLevelInner = float2(0,0);
OsdGetTessLevels(
tessLevel, 
projectionMatrix, 
modelViewMatrix,
patchVertices[0].P, 
patchVertices[3].P, 
patchVertices[2].P, 
patchVertices[1].P,
patchParam, 
tessLevelOuter, 
tessLevelInner
    quadFactors.edgeTessellationFactor[0] = tessLevelOuter[0];
    quadFactors.edgeTessellationFactor[1] = tessLevelOuter[1];
    quadFactors.edgeTessellationFactor[2] = tessLevelOuter[2];
    quadFactors.edgeTessellationFactor[3] = tessLevelOuter[3];
    quadFactors.insideTessellationFactor[0] = tessLevelInner[0];
    quadFactors.insideTessellationFactor[1] = tessLevelInner[1];
//----------------------------------------------------------
// Patches.Gregory.Vertex
//----------------------------------------------------------
void OsdComputePerPatchVertex(
int3 patchParam, 
unsigned ID, 
unsigned PrimitiveID, 
unsigned ControlID,
threadgroup PatchVertexType* patchVertices,
OsdPatchParamBufferSet osdBuffers
OsdComputePerPatchVertexGregory(
patchParam,
PrimitiveID,
patchVertices,
osdBuffers.perPatchVertexBuffer[ControlID],
osdBuffers);
    
    OSD_USER_VARYING_PER_VERTEX(patchVertices[ID], osdBuffers.perPatchVertexBuffer[ControlID]);
//----------------------------------------------------------
// Patches.Gregory.Domain
//----------------------------------------------------------
template<typename PerPatchVertexGregory>
static OsdPatchVertex ds_gregory_patches(
                     PerPatchVertexGregory patch,
                     int3 patchParam,
                     float2 UV
                    )
    OsdPatchVertex output;
    
    float3 P = float3(0,0,0), dPu = float3(0,0,0), dPv = float3(0,0,0);
    float3 N = float3(0,0,0), dNu = float3(0,0,0), dNv = float3(0,0,0);
    
    float3 cv[20];
    cv[0] = patch[0].P;
    cv[1] = patch[0].Ep;
    cv[2] = patch[0].Em;
    cv[3] = patch[0].Fp;
    cv[4] = patch[0].Fm;
    
    cv[5] = patch[1].P;
    cv[6] = patch[1].Ep;
    cv[7] = patch[1].Em;
    cv[8] = patch[1].Fp;
    cv[9] = patch[1].Fm;
    
    cv[10] = patch[2].P;
    cv[11] = patch[2].Ep;
    cv[12] = patch[2].Em;
    cv[13] = patch[2].Fp;
    cv[14] = patch[2].Fm;
    
    cv[15] = patch[3].P;
    cv[16] = patch[3].Ep;
    cv[17] = patch[3].Em;
    cv[18] = patch[3].Fp;
    cv[19] = patch[3].Fm;
    
    OsdEvalPatchGregory(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);
    
    // all code below here is client code
    output.position = P;
    output.normal = N;
    output.tangent = dPu;
    output.bitangent = dPv;
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    output.Nu = dNu;
    output.Nv = dNv;
#endif
    output.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);
    
    OSD_USER_VARYING_PER_EVAL_POINT(UV, patch[0], patch[1], patch[3], patch[2], output);
    return output;
#if USE_STAGE_IN
template<typename PerPatchVertexGregoryBasis>
#endif
static OsdPatchVertex OsdComputePatch(
float tessLevel,
float2 domainCoord,
unsigned patchID,
#if USE_STAGE_IN
PerPatchVertexGregoryBasis osdPatch
#else
    OsdVertexBufferSet osdBuffers
#endif
return ds_gregory_patches(
#if USE_STAGE_IN
osdPatch.cv,
osdPatch.patchParam,
#else
        osdBuffers.perPatchVertexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,
        osdBuffers.patchParamBuffer[patchID],
#endif
domainCoord);
#line 0 "osd/mtlPatchGregoryBasis.metal"
//   Copyright 2015 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//----------------------------------------------------------
// Patches.GregoryBasis.Hull
//----------------------------------------------------------
void OsdComputePerVertex(
float4 position,
    threadgroup HullVertex& hullVertex,
    int vertexId,
    float4x4 modelViewProjectionMatrix,
    OsdPatchParamBufferSet osdBuffers
    )
hullVertex.position = position;
#if OSD_ENABLE_PATCH_CULL
    float4 clipPos = mul(modelViewProjectionMatrix, position);    
    short3 clip0 = short3(clipPos.x < clipPos.w,                    
    clipPos.y < clipPos.w,                    
    clipPos.z < clipPos.w);                   
    short3 clip1 = short3(clipPos.x > -clipPos.w,                   
    clipPos.y > -clipPos.w,                   
    clipPos.z > -clipPos.w);                  
    hullVertex.clipFlag = short3(clip0) + 2*short3(clip1);              
#endif
    
    OSD_USER_VARYING_PER_CONTROL_POINT(osdBuffers.vertexBuffer[vertexId], hullVertex);
//----------------------------------------------------------
// Patches.GregoryBasis.Factors
//----------------------------------------------------------
void OsdComputePerPatchFactors(
int3 patchParam,
float tessLevel,
unsigned patchID,
float4x4 projectionMatrix,
float4x4 modelViewMatrix,
OsdPatchParamBufferSet osdBuffer,
threadgroup PatchVertexType* patchVertices,
device MTLQuadTessellationFactorsHalf& quadFactors
    float4 tessLevelOuter = float4(0,0,0,0);
    float2 tessLevelInner = float2(0,0);
OsdGetTessLevels(
tessLevel, 
projectionMatrix, 
modelViewMatrix,
patchVertices[0].position.xyz, 
patchVertices[3].position.xyz, 
patchVertices[2].position.xyz, 
patchVertices[1].position.xyz,
patchParam, 
tessLevelOuter, 
tessLevelInner
    quadFactors.edgeTessellationFactor[0] = tessLevelOuter[0];
    quadFactors.edgeTessellationFactor[1] = tessLevelOuter[1];
    quadFactors.edgeTessellationFactor[2] = tessLevelOuter[2];
    quadFactors.edgeTessellationFactor[3] = tessLevelOuter[3];
    quadFactors.insideTessellationFactor[0] = tessLevelInner[0];
    quadFactors.insideTessellationFactor[1] = tessLevelInner[1];
//----------------------------------------------------------
// Patches.GregoryBasis.Vertex
//----------------------------------------------------------
void OsdComputePerPatchVertex(
int3 patchParam, 
unsigned ID, 
unsigned PrimitiveID, 
unsigned ControlID,
threadgroup PatchVertexType* patchVertices,
OsdPatchParamBufferSet osdBuffers
//Does nothing, all transforms are in the PTVS
    OSD_USER_VARYING_PER_VERTEX(patchVertices[ID], osdBuffers.perPatchVertexBuffer[ControlID]);
//----------------------------------------------------------
// Patches.GregoryBasis.Domain
//----------------------------------------------------------
#define USE_128BIT_GREGORY_BASIS_INDICES_READ 1
#if USE_STAGE_IN
template<typename PerPatchVertexGregoryBasis>
#endif
static OsdPatchVertex ds_gregory_basis_patches(
#if USE_STAGE_IN
                     PerPatchVertexGregoryBasis patch,
#else
                     const device OsdInputVertexType* patch,
                     const device unsigned* patchIndices,
#endif
                     int3 patchParam,
                     float2 UV
                     )
    OsdPatchVertex output;
    float3 P = float3(0,0,0), dPu = float3(0,0,0), dPv = float3(0,0,0);
    float3 N = float3(0,0,0), dNu = float3(0,0,0), dNv = float3(0,0,0);
#if USE_STAGE_IN
    float3 cv[20];
    for(int i = 0; i < 20; i++)
        cv[i] = patch[i].position;
#else   
#if USE_128BIT_GREGORY_BASIS_INDICES_READ
    float3 cv[20];
    for(int i = 0; i < 5; i++) {
        int4 indices = ((device int4*)patchIndices)[i];
        
        int n = i * 4;
        cv[n + 0] = (patch + indices[0])->position;
        cv[n + 1] = (patch + indices[1])->position;
        cv[n + 2] = (patch + indices[2])->position;
        cv[n + 3] = (patch + indices[3])->position;
    }
#else
    float3 cv[20];
    for (int i = 0; i < 20; ++i) {
        cv[i] = patch[patchIndices[i]].position;
    }
#endif
#endif
    
    OsdEvalPatchGregory(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);
    
    output.position = P;
    output.normal = N;
    output.tangent = dPu;
    output.bitangent = dPv;
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    output.Nu = dNu;
    output.Nv = dNv;
#endif
    
    output.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);
    
#if USE_STAGE_IN
    OSD_USER_VARYING_PER_EVAL_POINT(UV, patch[0], patch[5], patch[15], patch[10], output);
#else
    OSD_USER_VARYING_PER_EVAL_POINT(UV, patch[patchIndices[0]], patch[patchIndices[5]], patch[patchIndices[15]], patch[patchIndices[10]], output);
#endif
    
    return output;
#if USE_STAGE_IN
template<typename PerPatchVertexGregoryBasis>
#endif
static OsdPatchVertex OsdComputePatch(
float tessLevel,
float2 domainCoord,
unsigned patchID,
#if USE_STAGE_IN
PerPatchVertexGregoryBasis osdPatch
#else
OsdVertexBufferSet osdBuffers
#endif
return ds_gregory_basis_patches(
#if USE_STAGE_IN
osdPatch.cv,
osdPatch.patchParam,
#else
osdBuffers.vertexBuffer,
osdBuffers.indexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,
osdBuffers.patchParamBuffer[patchID],
#endif
domainCoord
EndCapBSplineBasisPatchFactory
endCapBSplineBasisPatchFactory.cpp
computeLimitStencils
(ringSize & 1) == 0
start > -1 && prev > -1
EndCapGregoryBasisPatchFactory
endCapGregoryBasisPatchFactory.cpp
GetPatchPoints
fedges.size()==4
aedge!=Vtr::INDEX_INVALID
adjPatchIndex>=0 && adjPatchIndex<(int)_levelAndFaceIndices.size()
quadRefinement.cpp
_splitType == Sdc::SPLIT_TO_QUADS
initializeInventory
topologyRefiner.cpp
_levels.size() == 1
Failure in TopologyRefiner::RefineUniform() -- base level is uninitialized.
Failure in TopologyRefiner::RefineUniform() -- previous refinements already applied.
Failure in TopologyRefiner::RefineAdaptive() -- base level is uninitialized.
Failure in TopologyRefiner::RefineAdaptive() -- previous refinements already applied.
Failure in TopologyRefiner::RefineAdaptive() -- currently only supported for Catmark scheme.
doesFaceHaveDistinctFaceVaryingFeatures
!level.doesFaceFVarTopologyMatch(face, fvarChannel)
getQuadOffsets
endCapLegacyGregoryPatchFactory.cpp
thisFaceInVFaces != -1
Edge %d specified to be sharp does not exist (%d, %d)
Vertex %d specified to be sharp does not exist
OSD VertexBuffer
skew
_value
Float7
xsNCName
xsAnyURI
Float4x4
Uint
ListOfUInts
ListOfInts
bool_array
xsID
Float
control_vertices
closed
Bool
tapered_capsule
radius1
radius2
Float2
tapered_cylinder
TargetableFloat
TargetableFloat3
Float3
xsNMTOKEN
trifans
xsBoolean
xsDateTime
DateTime
xsDouble
xsLong
xsName
Name
xsString
xsToken
Token
xsUnsignedLong
ListOfBools
ListOfFloats
xsHexBinary
ListOfHexBinary
ListOfNames
ListOfTokens
Bool2
Bool3
Bool4
Float4
Float2x2
Float3x3
Float2x3
Float2x4
Float3x2
Float3x4
Float4x2
Float4x3
Int2
Int3
Int4
Int2x2
Int3x3
Int4x4
MorphMethodType
NodeType
NODE
URIFragmentType
UpAxisType
VersionType
1.4.0
Fx_color_common
Fx_opaque_enum
Fx_surface_type_enum
UNTYPED
RECT
Fx_surface_face_enum
POSITIVE_X
NEGATIVE_X
POSITIVE_Y
NEGATIVE_Y
POSITIVE_Z
NEGATIVE_Z
Fx_surface_format_hint_channels_enum
RGBA
XYZW
Fx_surface_format_hint_precision_enum
HIGH
Fx_surface_format_hint_range_enum
SNORM
UNORM
SINT
UINT
FLOAT
Fx_surface_format_hint_option_enum
SRGB_GAMMA
NORMALIZED3
NORMALIZED4
COMPRESSABLE
Fx_sampler_wrap_common
Fx_sampler_filter_common
NEAREST_MIPMAP_NEAREST
LINEAR_MIPMAP_NEAREST
NEAREST_MIPMAP_LINEAR
LINEAR_MIPMAP_LINEAR
Fx_modifier_enum_common
CONST
UNIFORM
VARYING
STATIC
VOLATILE
EXTERN
SHARED
Fx_draw_common
Fx_pipeline_stage_common
VERTEXPROGRAM
FRAGMENTPROGRAM
VERTEXSHADER
PIXELSHADER
xsNonNegativeInteger
GL_MAX_LIGHTS_index
GL_MAX_CLIP_PLANES_index
GL_MAX_TEXTURE_IMAGE_UNITS_index
Gl_blend_type
ZERO
SRC_COLOR
ONE_MINUS_SRC_COLOR
DEST_COLOR
ONE_MINUS_DEST_COLOR
SRC_ALPHA
ONE_MINUS_SRC_ALPHA
DST_ALPHA
ONE_MINUS_DST_ALPHA
CONSTANT_COLOR
ONE_MINUS_CONSTANT_COLOR
CONSTANT_ALPHA
ONE_MINUS_CONSTANT_ALPHA
SRC_ALPHA_SATURATE
Gl_face_type
FRONT
BACK
FRONT_AND_BACK
Gl_blend_equation_type
FUNC_ADD
FUNC_SUBTRACT
FUNC_REVERSE_SUBTRACT
Gl_func_type
NEVER
LESS
LEQUAL
EQUAL
GREATER
NOTEQUAL
GEQUAL
ALWAYS
Gl_stencil_op_type
KEEP
REPLACE
INCR
DECR
INVERT
INCR_WRAP
DECR_WRAP
Gl_material_type
EMISSION
AMBIENT
DIFFUSE
SPECULAR
AMBIENT_AND_DIFFUSE
Gl_fog_type
EXP2
Gl_fog_coord_src_type
FOG_COORDINATE
FRAGMENT_DEPTH
Gl_front_face_type
Gl_light_model_color_control_type
SINGLE_COLOR
SEPARATE_SPECULAR_COLOR
Gl_logic_op_type
CLEAR
AND_REVERSE
COPY
AND_INVERTED
NOOP
EQUIV
OR_REVERSE
COPY_INVERTED
NAND
Gl_polygon_mode_type
POINT
LINE
FILL
Gl_shade_model_type
FLAT
SMOOTH
xsFloat
Gl_alpha_value_type
Gl_enumeration
Glsl_float
xsInt
Glsl_int
Glsl_bool
Glsl_ListOfBool
Glsl_ListOfFloat
Glsl_ListOfInt
Glsl_bool2
Glsl_bool3
Glsl_bool4
Glsl_float2
Glsl_float3
Glsl_float4
Glsl_float2x2
Glsl_float3x3
Glsl_float4x4
Glsl_int2
Glsl_int3
Glsl_int4
Glsl_pipeline_stage
Glsl_identifier
Cg_bool
Cg_float
Cg_int
Cg_half
Cg_fixed
Cg_bool1
Cg_float1
Cg_int1
Cg_half1
Cg_fixed1
Cg_ListOfBool
Cg_ListOfFloat
Cg_ListOfInt
Cg_ListOfHalf
Cg_ListOfFixed
Cg_bool2
Cg_bool3
Cg_bool4
Cg_bool1x1
Cg_bool1x2
Cg_bool1x3
Cg_bool1x4
Cg_bool2x1
Cg_bool2x2
Cg_bool2x3
Cg_bool2x4
Cg_bool3x1
Cg_bool3x2
Cg_bool3x3
Cg_bool3x4
Cg_bool4x1
Cg_bool4x2
Cg_bool4x3
Cg_bool4x4
Cg_float2
Cg_float3
Cg_float4
Cg_float1x1
Cg_float1x2
Cg_float1x3
Cg_float1x4
Cg_float2x1
Cg_float2x2
Cg_float2x3
Cg_float2x4
Cg_float3x1
Cg_float3x2
Cg_float3x3
Cg_float3x4
Cg_float4x1
Cg_float4x2
Cg_float4x3
Cg_float4x4
Cg_int2
Cg_int3
Cg_int4
Cg_int1x1
Cg_int1x2
Cg_int1x3
Cg_int1x4
Cg_int2x1
Cg_int2x2
Cg_int2x3
Cg_int2x4
Cg_int3x1
Cg_int3x2
Cg_int3x3
Cg_int3x4
Cg_int4x1
Cg_int4x2
Cg_int4x3
Cg_int4x4
Cg_half2
Cg_half3
Cg_half4
Cg_half1x1
Cg_half1x2
Cg_half1x3
Cg_half1x4
Cg_half2x1
Cg_half2x2
Cg_half2x3
Cg_half2x4
Cg_half3x1
Cg_half3x2
Cg_half3x3
Cg_half3x4
Cg_half4x1
Cg_half4x2
Cg_half4x3
Cg_half4x4
Cg_fixed2
Cg_fixed3
Cg_fixed4
Cg_fixed1x1
Cg_fixed1x2
Cg_fixed1x3
Cg_fixed1x4
Cg_fixed2x1
Cg_fixed2x2
Cg_fixed2x3
Cg_fixed2x4
Cg_fixed3x1
Cg_fixed3x2
Cg_fixed3x3
Cg_fixed3x4
Cg_fixed4x1
Cg_fixed4x2
Cg_fixed4x3
Cg_fixed4x4
Cg_pipeline_stage
FRAGMENT
Cg_identifier
GLES_MAX_LIGHTS_index
GLES_MAX_CLIP_PLANES_index
GLES_MAX_TEXTURE_COORDS_index
GLES_MAX_TEXTURE_IMAGE_UNITS_index
Gles_texenv_mode_enums
MODULATE
DECAL
BLEND
Gles_texcombiner_operatorRGB_enums
ADD_SIGNED
INTERPOLATE
SUBTRACT
DOT3_RGB
DOT3_RGBA
Gles_texcombiner_operatorAlpha_enums
Gles_texcombiner_source_enums
TEXTURE
CONSTANT
PRIMARY
PREVIOUS
Gles_texcombiner_operandRGB_enums
Gles_texcombiner_operandAlpha_enums
Gles_texcombiner_argument_index_type
Gles_sampler_wrap
REPEAT
CLAMP_TO_EDGE
MIRRORED_REPEAT
Gles_stencil_op_type
Gles_enumeration
Gles_rendertarget_common
SpringType
ANGULAR
evaluate_scene
camera_node
notype
badtype
enum
xsInteger
xsIntegerArray
xsHexBinaryArray
xsByte
xsLongArray
%lld
long
xsShort
xsUnsignedByte
xsUnsignedInt
xsPositiveInteger
ulong
%llu
xsDecimal
token
xsNameArray
xsTokenArray
xsNCNameArray
Element
TrackedElement
resolver
xsIDREF
xsIDREFS
idref_resolver
-INF
NaN encountered while setting an attribute or value
INF encountered while setting an attribute or value
-INF encountered while setting an attribute or value
createArray
daeAtomicType.cpp
setDocument
keywords
revision
title
comments
copyright
half_extents
imager
ymag
aspect_ratio
cg_connect_param
cg_newarray_type
cg_param_type
usertype
connect_param
cg_newparam
bool1
bool1x1
bool1x2
bool1x3
bool1x4
bool2x1
bool2x2
bool2x3
bool2x4
bool3x1
bool3x2
bool3x3
bool3x4
bool4x1
bool4x2
bool4x3
bool4x4
float1
float1x1
float1x2
float1x3
float1x4
float2x1
float3x1
float4x1
int1
int1x1
int1x2
int1x3
int1x4
int2x1
int2x2
int2x3
int2x4
int3x1
int3x2
int3x3
int3x4
int4x1
int4x2
int4x3
int4x4
half1
half1x1
half1x2
half1x3
half1x4
half2x1
half3x1
half4x1
fixed
fixed1
fixed2
fixed3
fixed4
fixed1x1
fixed1x2
fixed1x3
fixed1x4
fixed2x1
fixed2x2
fixed2x3
fixed2x4
fixed3x1
fixed3x2
fixed3x3
fixed3x4
fixed4x1
fixed4x2
fixed4x3
fixed4x4
samplerRECT
samplerCUBE
samplerDEPTH
cg_sampler1D
border_color
mipmap_maxlevel
mipmap_bias
cg_sampler2D
cg_sampler3D
wrap_p
cg_samplerCUBE
cg_samplerDEPTH
cg_samplerRECT
cg_setarray_type
cg_setparam
cg_setparam_simple
cg_setuser_type
setparam
cg_surface_type
fx_surface_init_common
format_hint
viewport_ratio
mip_levels
mipmap_generate
generator
code
gles_pipeline_settings
alpha_func
blend_func
clear_color
clear_stencil
clear_depth
clip_plane
color_mask
cull_face
depth_func
depth_mask
depth_range
fog_color
fog_density
fog_mode
fog_start
fog_end
front_face
texture_pipeline
logic_op
light_ambient
light_diffuse
light_specular
light_position
light_constant_attenuation
light_linear_attenutation
light_quadratic_attenuation
light_spot_cutoff
light_spot_direction
light_spot_exponent
light_model_ambient
line_width
material_ambient
material_diffuse
material_emission
material_shininess
material_specular
model_view_matrix
point_distance_attenuation
point_fade_threshold_size
point_size
point_size_min
point_size_max
polygon_offset
projection_matrix
scissor
shade_model
stencil_func
stencil_mask
stencil_op
alpha_test_enable
blend_enable
clip_plane_enable
color_logic_op_enable
color_material_enable
cull_face_enable
depth_test_enable
dither_enable
fog_enable
texture_pipeline_enable
light_enable
lighting_enable
light_model_two_side_enable
line_smooth_enable
multisample_enable
normalize_enable
point_smooth_enable
polygon_offset_fill_enable
rescale_normal_enable
sample_alpha_to_coverage_enable
sample_alpha_to_one_enable
sample_coverage_enable
scissor_test_enable
stencil_test_enable
index
0 0 0 0
0 0 0 1
0 0 1 0
0 0 -1
0.2 0.2 0.2 1.0
0.8 0.8 0.8 1.0
1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1
1 0 0
mask
4294967295
zfail
zpass
gles_sampler_state
gles_texcombiner_argumentAlpha_type
operand
gles_texcombiner_argumentRGB_type
gles_texcombiner_command_type
gles_texcombiner_commandAlpha_type
argument
operator
gles_texcombiner_commandRGB_type
gles_texenv_command_type
gles_texture_constant_type
gles_texture_pipeline
texcombiner
texenv
gles_texture_unit
sampler_state
glsl_newarray_type
glsl_param_type
glsl_newparam
glsl_setarray_type
glsl_setparam
glsl_setparam_simple
glsl_surface_type
InputLocal
InputLocalOffset
technique_hint
platform
fx_basic_type_common
instance_force_field
bind
instance_node
instance_physics_material
instance_physics_model
instance_rigid_body
instance_rigid_constraint
angular_velocity
mass_frame
inertia
physics_material
shape
hollow
density
InstanceWithExtra
minInclusive
-2147483648
maxInclusive
2147483647
library_force_fields
force_field
library_nodes
library_physics_materials
physics_model
physics_scene
xml_base
common_color_or_texture_type
common_float_or_param_type
common_newparam_type
common_transparent_type
fx_surface_format_hint_common
range
precision
option
fx_surface_init_planar_common
fx_surface_init_volume_common
primary
fx_surface_init_cube_common
order
fx_surface_init_from_common
fx_surface_common
fx_sampler1D_common
fx_sampler2D_common
fx_sampler3D_common
fx_samplerCUBE_common
fx_samplerRECT_common
fx_samplerDEPTH_common
fx_colortarget_common
fx_depthtarget_common
fx_stenciltarget_common
fx_clearcolor_common
fx_cleardepth_common
fx_clearstencil_common
fx_annotate_common
fx_include_common
fx_newparam_common
fx_code_profile
gl_sampler1D
gl_sampler2D
gl_sampler3D
gl_samplerCUBE
gl_samplerRECT
gl_samplerDEPTH
gles_newparam
init_as_null
init_as_target
fx_annotate_type_common
gl_pipeline_settings
blend_func_separate
src_rgb
dest_rgb
src_alpha
dest_alpha
blend_equation
blend_equation_separate
color_material
fog_coord_src
light_model_color_control
polygon_mode
stencil_func_separate
stencil_op_separate
stencil_mask_separate
light_linear_attenuation
textureCUBE
textureRECT
textureDEPTH
texture1D_enable
texture2D_enable
texture3D_enable
textureCUBE_enable
textureRECT_enable
textureDEPTH_enable
texture_env_color
texture_env_mode
blend_color
depth_bounds
line_stipple
auto_normal_enable
depth_bounds_enable
depth_clamp_enable
light_model_local_viewer_enable
line_stipple_enable
logic_op_enable
polygon_offset_line_enable
polygon_offset_point_enable
polygon_smooth_enable
polygon_stipple_enable
gles_basic_type_common
linestrips
polylist
lookat
fx_profile_abstract
gl_hook_abstract
profile_GLSL
compiler_target
compiler_options
profile_CG
profile_GLES
color_target
depth_target
stencil_target
color_clear
depth_clear
stencil_clear
equation
convex_mesh
rigid_body
rigid_constraint
ref_attachment
interpenetrate
limits
swing_cone_and_twist
spring
angular
init_cube
init_volume
init_planar
texture_unit
dynamic_friction
static_friction
time_step
stiffness
target_value
convex_hull_of
digits
magnitude
slice
true true true true
1 65536
DefaultIDRefResolver
Failed to load XML document from memory
Failed to load 
The DOM was unable to create an element named 
 at line 
. Probably a schema violation.
The DOM was unable to create an attribute 
Probably a schema violation.
Trying to load an invalid COLLADA version for this DOM build!
Missing xmlns meta attribute for root element.
The DOM was unable to set a value for element of type 
noname
placeElement
daeMetaChoice.cpp
contentsOrder
CMData
RawResolver
daeRawResolver::resolveElement() - Can't get path from URI
-array
XMLResolver
file://
saveRawBinary
TRUE
Failed to open 
 in daeLIBXMLPlugin::readFromFile
Failed to open XML document from memory buffer in daeLIBXMLPlugin::readFromMemory
Error parsing XML in daeLIBXMLPlugin::read
readElement
daeLIBXMLPlugin.cpp
xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
can't get path in write
daeLIBXMLPlugin::write(
) failed
UTF-8
writeRawSource
accessor != NULL
%s#%ld
ColladaDOM Error: %s
daeStandardURIResolver::resolveElement() - Failed to resolve 
getInfo
AnimDecoder.cpp
headerSizeInBytes == HeaderSizeInBytes
incrementNeighborCount
AnimCodec.h
i < int32_t(_neighborCount.size())
addNeighbor
_neighborCount[i] < maxNeighborCount(i)
maxNeighborCount
kCFAllocatorNull
CFDataCreateWithBytesNoCopy
CFPropertyListCreateWithData
CFPropertyListCreateFromXMLData
CFStringCreateWithCStringNoCopy
CFDictionaryGetValue
CFGetTypeID
CFStringGetTypeID
CFStringGetCString
CFRelease
/System/Library/CoreServices/SystemVersion.plist
ProductVersion
%d.%d.%d
Assertion '%s' failed. Null argument
Error: C3DTransformsArrayAppendTransforms - out of bounds
Assertion '%s' failed. Default irradiance texture is not valid
Assertion '%s' failed. Default radiance texture is not valid
Assertion '%s' failed. Pre-computed irradiance texture is not valid
Assertion '%s' failed. Pre-computed radiance texture is not valid
Assertion '%s' failed. non managed storage mode cannot be synchronized
Unreachable code: Asking to created a texture with an invalid format!
Error: Failed to load image with error %@
Error: Cannot load image %@. Using dummy texture.
Assertion '%s' failed. Too many mip level loaded
Error: unknown compression format
Error: Cannot load image %@. Texture will be garbage.
Error: C3DRendererCreateTextureWithImage : error while getting bitmap bytes
Error: Failed to load texture named %@ : %@
Assertion '%s' failed. slice count must match to copy
Assertion '%s' failed. width must match to copy
Assertion '%s' failed. height must match to copy
Assertion '%s' failed. depth must match to copy
Assertion '%s' failed. bad time
Assertion '%s' failed. bad count
Assertion '%s' failed. C3DAnimationClusterCreateWithAnimationGroup out of bounds
Assertion '%s' failed. unexpected animation class
Assertion '%s' failed. _getNextKeyTime twice the same keytime?
Error: can't edit NULL address
Error: can't edit pointer
Error: can't edit unknown type
Error: repeatAction: invoked with a nil action
Error: repeatActionForever: invoked with a nil action
Assertion '%s' failed. wrong light type
Assertion '%s' failed. wrong probe type
Warning: Should not register a node without light to the light system
Error: Node is already registered to the light system
Assertion '%s' failed. Invalid runtime light index
Error: Invalid runtime light index
Error: The shadow node is not registered
Assertion '%s' failed. Light does not casts shadow. Cannot compute shadow parameters.
Error: Too many shadow caster lights at once. Limit is %d
Assertion '%s' failed. Not Yet Implemented!!!!
Assertion '%s' failed. Max caster index overflow
Assertion '%s' failed. 0 caster index is reserved
Error: Too many effective lights at once. Limit is %d
Error: Missing shadow %@
Error: unabled to create a read stream at %@
Assertion '%s' failed. texture is not a MTLTexture
Assertion '%s' failed. Depth Clip Mode is not supported on this device
Assertion '%s' failed. Dereferencing null pointer
Error: Failed to create instance of type %ld. Extra size too large
Error: Failed to create instance of type %@
Error: No point of view set for tone mapping pass
Error: No camera set for tone mapping pass
Error: Color deserialize: could not read the float array
Error: Color deserialize: no color or no deserialized data
Assertion '%s' failed. Unsupported conversion info - different TRCs for input components
Error: Unsupported conversion info - unsupported TRC type %d
Error: Unsupported conversion info - stage %d of %d will be ignored!
Error: Unsupported conversion info - %d color matrices
Error: Unsupported conversion info - NxMLUTs not supported
Error: Failed to compute color conversion parameters for %@ 
Error: No conversion info for %@ 
 %@, texture will be copied
Error: Color matching for %@ 
 %@ could be done more efficiently by switching to a _sRGB variant of the MTLPixelFormat
Error: C3DBaseTypeForCFNumberType: Type not supported
Assertion '%s' failed. Not enough room for the specified count & stride to read
Assertion '%s' failed. Not enough room for the specified count & stride to write
Error: C3DConvertToPlatformIndependentData - archiving pointers makes no sense
Error: C3DConvertToPlatformIndependentData - Type not supported
Error: C3DConvertFromPlatformIndependentData: Not enough room for the specified count & stride to read
Error: C3DConvertFromPlatformIndependentData: Not enough room for the specified count & stride to write
Error: C3DConvertFromPlatformIndependentData - Type not supported
Assertion '%s' failed. unknown type
Error: unknown type
Unreachable code: Compound type %s%d is not supported
Assertion '%s' failed. Only one compound type per vector
Assertion '%s' failed. wrong parameters
Warning: C3DBaseTypeFromDescription - signed/unsigned ambiguity
Error: C3DBaseTypeFromDescription - Type not supported
Error: C3DBaseTypeRequires32to64bitConversion:: unknown type
Error: C3DAddBaseType - type %d can't be added
Error: C3DAddBaseType - addition of half float not supported
Error: C3DAddBaseType - unknown type
Error: C3DSubBaseType - type %d can't be substracted
Error: C3DSubBaseType - substraction of half float not supported
Error: C3DSubBaseType - unknown type
Error: Conversion to C string failed
Warning: C3DParseVersionNumber - No version found
Error: failed to load resource named %@
Error: failed to load dictionary named %@
Error: failed to load json named %@ (reason: %@)
Error: failed to load json named %@
Warning: C3DDataFromMTLBuffer - can't read private MTL buffer
Info: linear rendering forced to %d
Assertion '%s' failed. Spherical Harmonics Data seems malformed: order(%d) !=> length(%zu)
Error: Could not deserialize a number array (nil buffer or serialized data)
Error: Could not deserialize a number (%@) in a number array
Error: Could not deserialize a number array (unexpected type)
Warning: C3DBaseTypeFromGLSLString: unknown type name '%@'
Warning: C3DBaseTypeFromMetalString: unknown type name '%@'
Warning: C3DBaseTypeFromMetalOrGLSLString: unknown type name '%@'
Assertion '%s' failed. No node should be tracked anymore by the geometry %@
Error: Geometry deserialization: cannot find the mesh ID
Error: Geometry deserialization: cannot find the specified mesh
Error: Geometry deserialization: cannot find the specified material
Warning: _C3DGeometryFinalizeDeserialization - material ID of 0 is unexpected
Assertion '%s' failed. Node should not already been tracked by this geometry
Assertion '%s' failed. Node should been tracked by this geometry
Error: cannot generate points : mismatch between vertices and normals count
Error: Cannot use volume generation on a generic mesh. fallbacking on surface
Error: Could not deserialize the property %@ in the serialized effect %@
Error: C3DMeshElementCreateByMergingElements - strip not supported
Error: C3DMeshElementCreateByMergingElements - merging elements with different byte per index
Assertion '%s' failed. Mesh element has %d channels but channel %d was requested
Warning: %s does not support non-renderable topologies.
Error: C3DMeshElementGetIndexCount:primitive type not handled
Assertion '%s' failed. Internal consistency error: number of indices should be a multiple of number of channels
Unreachable code: unexpected vertex count
Error: unexpected vertex count
Unreachable code: Invalid bytes per index (%d)
Unreachable code: Unknown primitive type %d
Error: invalid propertylist in %s
Error: Mesh element deserialization: no faces count
Error: Mesh element deserialization: no mesh element type
Error: Mesh element deserialization: no bytes per index
Error: Could not read the indexes
Error: Mesh element deserialization: no serialized indices
Warning: Unknown mesh element type %@, assuming triangles array.
Error: C3DMeshElementSetPrimitives invalid index buffer size
Error: __readIndexInBuffer - index (%u) out of bounds (%lu)
Assertion '%s' failed. %s - unsupported index size (%ld)
Unreachable code: Unknown index type %d
Unreachable code: A tessellator object should not exist when no tessellation is required
Error: failed to copy a snapshot of %@
Assertion '%s' failed. error in computing triangle bbox
Assertion '%s' failed. Update %s to support mesh element channels
Assertion '%s' failed. there should be exactly one transposed matrix in here
Warning: unlock not locked ressource
Assertion '%s' failed. Unsupported element type in C3DMeshCreateByMergingMeshes
Error: C3DMeshSubdivide inconsistency
Assertion '%s' failed. inconsistency (2) in C3DMeshSubdivide
Warning: try to preload a geometry with no mesh
Error: WARNING: NULL data in mesh source (warming geometry)
Error: Cannot generate tangents without valid positions
Error: Cannot generate valid tangents without valid texture coordinates
Error: Cannot generate valid tangents without valid normals
Unreachable code: Unsupported index size (%zu)
Error: invalid geometry detected - skip C3DCreateTangentsWithGeometryOptimized
Error: target mesh has a different number of vertices (%d != %d)
Error: Cannot generate tangents without positions
Error: Cannot generate tangents without texture coordinates
Error: error in C3DMeshCreateTangentsIfNeeded
Warning: Cannot create an interleaved copy, count mismatch
Unreachable code: C3DAdjustZRangeOfProjectionInfos - no scene or no point of view
Unreachable code: C3DAdjustZRangeOfProjectionInfos - no root node
Unreachable code: C3DAdjustZRangeOfProjectionInfos - no world matrix
Assertion '%s' failed. We badly computed zFar (%f) and zNear (%f) in this scene
Error: Given sources must be of the same length for interval list creation
Assertion '%s' failed. different material!!!!
Warning: __MergeMeshSources unknown source type
Assertion '%s' failed. __AllocateNewSource - componentsCount is zero
Assertion '%s' failed. inconsistency in _finalizeSplit
Assertion '%s' failed. _finalizeSplit - inconsistent data length
Assertion '%s' failed. _createSubSource - inconsistent data length
Error: C3DSourceAccessorCopyDataToAccessor failed
Warning: C3DUnifyNormalsFromGeometry can only process triangles and polygons
Warning: C3DUnifyNormalsFromGeometry empty indices
Assertion '%s' failed. unexpected vertex count
Assertion '%s' failed. NULL allocator
Error: inconsistency in lru list
Error: inconsistency in lru list (2)
Error: [SCNAction sequence:] invoked with nil
Assertion '%s' failed. Wrong probe type
Assertion '%s' failed. Wrong light type
Assertion '%s' failed. Slice index should have been attributed already
Assertion '%s' failed. first light was not of the same index
Assertion '%s' failed. end index should be set already
Assertion '%s' failed. previous light was not of the same index
Assertion '%s' failed. nextIndex out of range
Assertion '%s' failed. Should be non empty
Assertion '%s' failed. range overflow
Assertion '%s' failed. Pass input descriptor out of bound access %d
Assertion '%s' failed. Pass output descriptor out of bound access %d
Assertion '%s' failed. input resource index out of bound %d
Assertion '%s' failed. output resource index out of bound %d
Assertion '%s' failed. Adding dependency on self
Assertion '%s' failed. Input buffer parameter index out of bounds
Assertion '%s' failed. Output buffer parameter index out of bounds
Welcome to SceneKit 602 (Jul  4 2024 03:00:01)
Assertion '%s' failed. invalid handle (%d) given
Assertion '%s' failed. no more handle available
Assertion '%s' failed. can't move negative number of data
Assertion '%s' failed. overflow !
Assertion '%s' failed. child must be one level under parent
Assertion '%s' failed. C3DNodeIterateTree : null node
Assertion '%s' failed. C3DNodeIterateTree : no callbacks
Error: Could not create texture with descriptor : %@
Unreachable code: Wrong texture given to the cache %@
Error: object %@ doesn't conform to the copying protocol
Error: invalid ref count for entity %@
Assertion '%s' failed. Must call GetScene with an entity
Error: Failed to instantiate unarchiver with error %@
Assertion '%s' failed. Stack Pop error
Assertion '%s' failed. C3DStackSetValue only accept CFTypeRef stacks
Assertion '%s' failed. C3DStackGetValue only accept CFTypeRef stacks
Assertion '%s' failed. range not found
Unreachable code: Argument type not supported %d
Unreachable code: OpenSubdiv support not implemented yet for constant shaders
Error: Invalid shader modifier: programmable blending is not supported by this device
Error: cannot handle more than one lighting modifier
Assertion '%s' failed. wrong entry point
Error: Invalid shader modifier : no code provided
Unreachable code: Multiple rendering is lacking a multiple output vertex streams generator
Assertion '%s' failed. Infinite lights can only be dir or unranged omni
Assertion '%s' failed. No more than 4 components for mesh source value types
Error: Morph: target vertex count do not match base vertex count (%d != %d)
Error: MeshSource packing only supports non interleaved float sources
Assertion '%s' failed. Provided mesh element is not an interval list
Error: Conversion from other types than float is not supported
Error: Conversion of an interleaved source is not supported, please convert your sources before interleaving
Error: C3DMeshSourceCreateCopyWithComponentsBaseType: unsupported type
Error: Conversion from %@ to %@ to is not supported
Error: no meshSource deserialize => semantic in mesh source
Error: _C3DMeshSourceCopyPropertyList unsupported semantic
Assertion '%s' failed. C3DFramebufferRegistryRetainTextureWithName retainCount==0
Assertion '%s' failed. _removeReference - index==0
Assertion '%s' failed. _C3DAnimationManagerAddAnimationNode - cluster not expected
Warning: fail to setup the animation - won't be added to the animation stack
Assertion '%s' failed. _C3DAnimationManagerAppendCallback triggered while animation manager is muted
Assertion '%s' failed. C3DAnimationManagerUpdateConstantCount
Assertion '%s' failed. C3DAnimationManagerNeedsRedraw - inconsistant constant count
Error: Binding: Unable to resolve destination keypath: %@(%@)
Error: Binding: Trying to bind two incompatible keypaths: %@(%@) -> %@(%@)
Assertion '%s' failed. C3DAnimationManagerNewStackWithKey key already exist
Assertion '%s' failed. unexpected semantic
Assertion '%s' failed. C3DAnimationManagerNewStackWithKey key doesn't exist
Error: _resolveAnimationGroupTargets - can't find common ancessor
Assertion '%s' failed. Inconsistency in _C3DAnimationManagerRemoveAnimationNode: triggered while applying animations
Assertion '%s' failed. C3DAnimationManagerRemoveAnimationNode removing an animation while applying
Assertion '%s' failed. _C3DPreviousKeyIndexForTime - unexpected integer division
Error: C3DKeyframeControllerSetKeyframeAtIndex - time is NaN
Error: C3DKeyframeControllerRef - index out of bounds
Assertion '%s' failed. C3DKeyframeControllerEvaluateAtTime animation has no key
Warning: can't simplify keyframes because of cubic interpolation
Warning: can't simplify keyframes because of tcb values
Warning: can't simplify keyframes because of timing functions
Assertion '%s' failed. wrong number of keyCount in data
Error: failed to deserialize animation data
Error: _C3DKeyframeControllerFlattenKeyframeData unexpected value
Assertion '%s' failed. _C3DKeyframeControllerFlattenKeyframeData bad value type
Error: _C3DKeyframeControllerCreateKeyframeArray unknown key type
Warning: _C3DKeyDistance - can't compute key distance for type %d
Unreachable code: Unknown SCNSceneRenderer conforming class
Error: Cannot append manipulator vertex data because we encountered an overflow and we are not allowed to flush
Assertion '%s' failed. A mesh should have been allocated by now
Assertion '%s' failed. Can not nest two Timed record
Warning: ring buffer is full [%d/%d]
Assertion '%s' failed. start != end
Assertion '%s' failed. Found crease element with more than 1 channel
Assertion '%s' failed. Only GL_LINES and kC3DManipulatorDrawModeTriangles are supported
Assertion '%s' failed. basevertex should be 0 here.
Assertion '%s' failed. Base index should be reset at this point
Unreachable code: Unknown use of manipulators
Assertion '%s' failed. There should be at lease a valid C3DRendererContext or a valid SCNRenderer
Assertion '%s' failed. No program for the auth env!
Assertion '%s' failed. __appendRect2D: uv but not texture
Assertion '%s' failed. __appendRect2D: no uv but texture
Error: Unable to create context
Assertion '%s' failed. C3DAnimationStackInit called twice
Assertion '%s' failed. C3DAnimationStack invalid
Assertion '%s' failed. unexpected animation node class
Assertion '%s' failed. unexpected size
Error: didAddToPhysicsWorld - can't share a physics behavior to multiple world
Warning: Character should already have a body
Error: SCNMTLRenderContext initWithDevice : device should not be nil
Error: SCNMTLRenderContext initWithDevice : cannot create a command queue. Bailing out.
Error: Deallocating render context with %d outstanding command buffer scheduling handlers
Error: Deallocating render context with 1 outstanding command buffer scheduling handler
Error: Deallocating render context with %d outstanding command buffer completion handlers
Error: Deallocating render context with 1 outstanding command buffer completion handler
Error: Deallocating render context with %d outstanding drawable presentation handlers
Error: Deallocating render context with 1 outstanding drawable presentation handler
Error: Main command buffer execution failed with status %d, error: %@
Warning: Failed getting a valid drawable. Skipping this frame.
Error: Resource command buffer execution failed with status %d, error: %@
Assertion '%s' failed. Control point indices must be 16-bit or 32-bit
Assertion '%s' failed. Only triangle arrays are supported for tessellation
Unreachable code: Cannot render video background with an unspecified source type.
Error: cannot renderMesh without a vaid passDescriptor
Assertion '%s' failed. Volatile mesh must have been mapped already
Assertion '%s' failed. shader does not support batching!
Assertion '%s' failed. unexpected engine context
Error: can not render without programs, using default
Assertion '%s' failed. C3DDeformerTransforms is not supported when instancing is active
Assertion '%s' failed. 
Unreachable code: Internal consistency error
Error: _executeProgram - no pipeline state
Error: pass has no storage for input %@
Error: binding is broken : neither block or semantic
Assertion '%s' failed. Light indices buffer has wrong size
Assertion '%s' failed. size mismatch for sh coefficients
Assertion '%s' failed. only shOrder 3 supported with function constants
Assertion '%s' failed. Cannot set more than 4 matrices for cascade shadows
Assertion '%s' failed. You can only map volatile mesh
Assertion '%s' failed. Mesh should have volatile data to allocate
Assertion '%s' failed. Mesh should be mapped
Assertion '%s' failed. MeshElement should be mapped
Assertion '%s' failed. Mesh should not be already mapped
Assertion '%s' failed. Hidden nodes should have been removed from the pipeline already
Assertion '%s' failed. Fully transparents objects should have been removed from the pipeline already
Error: C3DEngineContextRenderTechnique - unknown draw instruction
Error: _initializeRenderFromLightPass - no light
Error: _initializeDeferredShadows - no light
Error: _willExecuteDeferredShadows - no light
Error: _setupDeferredShadows - no light
Error: _C3DKeyframedAnimationInitWithPropertyList serializedData invalid
Error: _C3DKeyframedAnimationInitWithPropertyList plist invalid
Assertion '%s' failed. Completion item will be released without having handled a completion or interruption event. This can lead to an inconsistent state.
Error: can't set a property (%s::%d) on the presentation instance %@ - ignoring
Assertion '%s' failed. __removeAnimationForKey: cftype is not an entity
Error: attempt to add a null animation player on %@
Error: attempt to add a null animation on %@
Assertion '%s' failed. sync animations: cftype is not an entity
Error: referenced particle systems can't be resolved without a SCNAssetCatalog
Error: particle reference name is nil
Error: animation class %@ is not supported for particle systems
Error: Can't introspect type of property %@
Error: unknown particle controller input mode
Error: Cannot build cubemap from array of images because image at index %d is NULL
Error: Cannot build cubemap from array of images because image at index %d is not square: %fx%f
Error: Cannot build cubemap from array of images because image at index %d (%fx%f) does not have the expected size (%zux%zu)
Error: Cannot build cubemap from array of images because conversion to CGImageRef of image at index %d failed
Error: Cannot build column cubemap from non-cubemap image
Warning: Failed to create bitmap context for CG image %@
Assertion '%s' failed. Can't get name for non catalog texture
Error: failed to map image data for image inside %@
Error: failed to resolve image inside %@
Error: Failed to create image source from data %@
Error: Failed to create image from image source %@ (status: %d)
Assertion '%s' failed. C3DImageCacheBitmap context is not null when it should be
Error: failed to create a CGBitmapContext from a CGImage for %@
Info: FixIncorrectPremultiply %@ time %u x %u : %fms
Error: Unknown cubemap image type
Error: Cannot support rotation layout for compressed texture
Error: Unknown Texture3D image type
Assertion '%s' failed. image has already compression infos
Error: failed to load image with description: %@
Warning: serialize C3DImage: empty image
Error: _C3DImageCopyPropertyList error retrieving path
Error: Failed to load %@
Error: unable to get a CGImageRef from image
Warning: While reading a texture sampler: could not read %@ (serializedData: %@), using the default value %d instead
Error: Could not serialize an integer
Error: convexSweep only works with convex shapes
Assertion '%s' failed. Node should be visible
Assertion '%s' failed. update should not be called if not implemented by the delegate
Warning: PhysicsWarn: %s
Info: Reload Shaders
Assertion '%s' failed. wrong viewport
Assertion '%s' failed. src and dst count must be equal
Error: unsupported conversion %@ -> float4
Unreachable code: not implemented
Assertion '%s' failed. cannot remove null span
Assertion '%s' failed. page overflow
Assertion '%s' failed. wrong page selected for span size %d
Error: RendererElementStore does not support span of more than %d
Assertion '%s' failed. pages are broken...
Assertion '%s' failed. handle is broken...
Assertion '%s' failed. re is broken...
Error: SCNLayer::copyCGLPixelFormatForDisplayMask -> unable to find a valid pixel format
Error: copyCGLContextForPixelFormat: cannot create context error %d
Assertion '%s' failed. unoptimal : don't keep empty arrays
Error: program failed to build:
Error: Cannot compile empty shader %@
Error: %3d: %@
Error: failed to link program: %s
Error: C3DRendererContextSetupResidentMeshSourceAtLocation:not handling type, using float as default
Error: C3DRendererContextCreateProgramObjectForProgram : missing vertex shader
Error: C3DRendererContextCreateProgramObjectForProgram : missing fragment shader
Error: C3DRendererContextCreateProgramObjectForProgram metal program unsupported
Error: C3DRendererContextCreateProgramObjectForProgram unsupported program
Warning: Trying to delete an empty or already released VBO
Error: image copy did fail: %@
Assertion '%s' failed. gl texture allocation failed
Assertion '%s' failed. inconsistent sample count
Error: C3DRendererContextSetupFramebuffer invoked twice on a Framebuffer
Assertion '%s' failed. C3DRendererContextUnbindFramebuffer - fbo is not bound
Unreachable code: C3DRendererContextUnbindFramebuffer - no fbo bound
Warning: C3DRendererContextInferTextureTargetForImageTypeAndTextureSampler: called with kC3DTextureUntype type should be resolved before calling it, using GL_TEXTURE_2D as fallback
Assertion '%s' failed. Wrong light index %d
Assertion '%s' failed. C3DRendererContextSetLight texture unit out of bounds
Error: Physically based lighting model is not supported by the OpenGL renderer, using Phong instead
Error: C3DRendererContextCreateBufferObjectForMeshSource - mesh source has no data
Assertion '%s' failed. mesh elements to vbo id dictionary should already be allocated
Error: C3DRendererContextBindMeshElement unsupported byte per index (%d)
Assertion '%s' failed. `polygon array` is not a supported element type for volatile meshes
Assertion '%s' failed. there should be at least one primitive of a known type
Assertion '%s' failed. mesh elements to vbo id dictionary should be allocated by now
Assertion '%s' failed. mesh element should be volatile
Assertion '%s' failed. fillProgramLocation: index out of bounds
Error: __FillProgramObjectLocations uniform index out of bounds
Error: Cannot load image %@.
Error: For best performance when using OpenGL, consider adding the `SCNDisableLinearSpaceRendering` and `SCNDisableWideGamut` keys with a bool value of `YES` to your app's Info.plist
Error: _createTextureForRenderTarget - fbo size is zero
Error: _createRBOForRenderTargetDescription - fbo size is zero
Unreachable code: NOT IMPLEMENTED
Error: Max number of texture unit (%d) is reached - can't bind a new texture
Error: We do not handle property %d to get the program attribute enum for the texture (using default: diffuse)
Assertion '%s' failed. Cube conversion can only happen for global probe
Assertion '%s' failed. Bad index
Assertion '%s' failed. Out of bound Array:%p access %d size %d
Warning: We do not support skipping <param>s yet
Warning: We do not support alternating types yet
Info: zNear of 0 found while loading DAE - will use 0.01 instead
Warning: Found a camera without either an orthographic specification or a perspective one. Discarding the camera. Please ensure the document has been checked for consistency.
Warning: Could not get the controller referenced by the URL %s. Please ensure the document has been checked for consistency
Warning: Could not interpret the URL %s
Warning: Could not interpret (2) the URL %s
Warning: Could not initialize an image, an init_from element is needed
Error: The DOM could not be loaded
Error: failed to resolve referenced animation %@ at index %ld
Warning: The instance_effect with URL %s does not reference an effect, skipping it
Warning: Found an invalid material [%s], reverting to a default material
Warning: We cannot yet read geometries without IDs; discarding one
Error: Cannot create an unique ID for a node
Warning: Node %@: we do not handle multiple controller instances per node. Using the first and skipping the others
Warning: We do not handle multiple controller instances per node. Using the first and skipping the others
Warning: Could not create an instance_node, no URL specified. Please check the document for consistency.
Assertion '%s' failed. We only support internal URIs for now
Warning: Could not find a skeleton for the URI %s
Warning: Could not find a node for the skeleton with the URI %s
Error: Found a Rotate element without the 4 required floats, please ensure the document has been checked for coherency
Error: Found a translate element without three associated floats; please ensure the document has been checked for consistency
Error: Found a scale element without three associated floats; please ensure the document has been checked for consistency
Warning: We do not handle skew transforms yet
Warning: [Coherency check] %s %s
Warning: No bind_material in %s
Warning: Invalid bind_material %s: no technique_common
Warning: Unknown array type %s
Warning: Ignoring a non-required invalid input
Warning: Ignoring error XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 on a texture element as it is a bit too harsh with texcoords
Warning: Ignoring error XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 on a source_data element
Warning: Ignoring error XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 on a node element (Illusoft exports wrong layer attributes)
Warning: Ignoring an invalid URL exported by older exporters in an init_from element
Warning: Ignoring an invalid names or IDs exported by exporters
Warning: Ignoring error concerning empty library_images elements
Warning: Ignoring error concerning empty technique_common elements
Warning: Ignoring error concerning empty animation elements
Warning: Ignoring error concerning multiple texture elements
Warning: Ignoring error concerning slots exported in the wrong order
Warning: Ignoring error from an extra or physics element
Warning: Ignoring error concerning <annotate> elements
Warning: Ignoring an invalid SID attribute error
Warning: Ignoring an invalid URL attribute error
Warning: Ignoring an empty ID or name attribute on visual_scene error
Warning: Ignoring error concerning <extra> and <node> exported in the wrong order
Warning: Ignoring error concerning <subject> and <title> exported in the wrong order
Warning: Ignoring error concerning non-existent canvas_aspect element
Warning: Schema validation warning: msg=%s (%s:%d) (code %d)
Warning: Cannot perform validation, validation context could not be created
Error: Failed to parse the XML document (base URL: %s)
Error: Index out of bounds.
Error: <vertices> not found in mesh, please check the document for consistency
Error: Deindexer: source %s has a count of %d, but the morphed source %s has a count of %d
Error: Deindexer: Detected a morph target and a morph source which do not have the same number of vertices
Warning: Targets input missing in a <morph> element, ignoring the morph
Warning: Invalid <input> in a <morph> element, ignoring the morph
Warning: We only support name arrays and IDREF arrays for morph targets for now, ignoring the morph
Warning: Found a morph target which does not exist or is not a geometry, ignoring the morph
Warning: Could not interpret or find the image for the id %s, ignoring it
Warning: Could not find the image information for the id %s, ignoring it
Warning: Could not find the image information (empty fx_surface array), ignoring it
Warning: Unsupported domFx_surface_type_enum
Error: Expecting a surface
Error: C3DIO_COLLADA_ReadEffect error 4
Error: invalid property name
Error: Found errors while checking the document for coherency:
Error: Could not deindex.
Error: Unable to get the referenced visual_scene
Error: Could not get the instance_visual_scene
Error: invalid collada file - missing animation input
Warning: failed to create an animation keyframes for: %s
Warning: failed to create an animation target for: %s
Warning: failed to create an animation for target: %s
Warning: kvcPathForElement: We do not know how to handle elements named %s
Error: Found a Rotate element without 4 attached floats. Please check the document for consistency.
Warning: kvcPathForElement: unknown color slot: %s
Warning: kvcPathForElement: unexpected color path
Warning: inconsistent keyframe length
Error: invalid tangent buffer length
Warning: trying to animate kC3DBaseTypeNone
Error: _sampleAndAddAnimations can't find transform stack for node %@
Error: animation duration is too long: %f - skip sampling
Error: animation duration is too long (>9hours) to be sampled - skipping
Error: unable to sample transform animation - fail to transpose animation target
Error: unable to sample transform animation - no transform found with sid %@
Error: unable to sample transform animation - no transform sid found
Warning: failed to evaluate animation to bake animation
Error: unable to sample transform animation - to parent animation to attach sampled animation
Error: _C3DCreateTransformAnimationChannelFromChannels - no path
Warning: invalide animation group detected
Warning: loaded an animation with duration == 0
Error: C3DIO_COLLADA_ReadMesh: geometry should already be cached into the library
Warning: The source %s does not have a Technique_common element. This might be caused by an exporter bug. Skipping it.
Warning: Found a source %s without a Technique_common element. This might be caused by an exporter bug. Skipping it.
Warning: The source %s has some unsupported traits (advanced params or non-float arrays). Skipping it
Warning: Found a source with some unsupported traits (advanced params or non-float arrays). Skipping it
Warning: The source %s has some unsupported traits (non-float array or interleaved arrays). Skipping it
Warning: Found a source with some unsupported traits (non-float array or interleaved arrays). Skipping it
Warning: Found an invalid source (stride == 0). Skipping it
Warning: Invalid source %s: offset + stride * count > source count. Skipping it
Warning: Found an invalid source (offset + stride * count > source count). Skipping it
Warning: Source %s: unsupported semantic %s. Skipping it.
Warning: Found an source with the unsupported semantic %s. Skipping it
Error: C3DIO_COLLADA_ReadElements: geometryElement references an index out of bounds - ignoring
Error: __CreateMeshElement inconsistent index count
Unreachable code: Unsupported element index size (%d)
Error: Invalid polygon array indices buffer size
Warning: The morph base geometry does not exist or is not a geometry, ignoring the morph
Warning: Unable to read the geometry of one of the targets, ignoring the morph
Warning: Weights input missing in a <morph> element, ignoring the morph
Warning: Lightmap image at path %s not found, can't create lightmap info
Warning: No path found, can't create lightmap info
Warning: Skipping the skin with source %s: it is not a geometry, or it is an invalid geometry
Error: Skipping the skin with source %s: we only support joints elements with joints and inverse bind matrices
Error: Skipping the skin with source %s: a joints source should have either a name array or an IDREF array
Error: Skipping the skin with source %s: inv bind matrices need to be 4x4 matrices. Please ensure the document has been checked for consistency
Error: Skipping the skin with source %s: a inv bind matrix accessor should have only one param
Error: Skipping the skin with source %s: a inv bind matrix should be a float4x4
Error: Skipping the skin with source %s: the number of floats describing the inverse bind matrices should be 16 * number of joints
Error: Skipping the skin with source %s: found two different sources for the bones
Error: Skipping the skin with source %s: vertex weights source not found
Error: Skipping the skin with source %s: vertex weights source accessor does not reference the source's float array
Assertion '%s' failed. invalid skin
Warning: could not find bundle %@, fall back to main bundle
Error: No source referencing the <vertices> element found
Error: [Deindexer] Found a vertices element without a POSITION source
Error: [Deindexer] Found a mesh element without a <vertices> element in its inputs
Error: [Deindexer] Vertices %s: index %llu -> %llu out of bounds (%llu)
Error: [Deindexer] Input %d: index %llu out of bounds (%llu)
Error: [Deindexer] Source resizing failed, the size to allocate was probably too big
Error: [Deindexer] Source resizing failed, old/new indices are out of ranges
Error: [Deindexer] Source %s: index %llu out of bounds (%llu)
Error: [Deindexer] Vertices %s: index %llu out of bounds (%llu)
Error: [Deindexer] Found a source referencing %s which is not a vertices or input element
Error: [Deindexing] Target %d of a morph does not have a mesh
Unreachable code: Invalid CommonProfile generator
Warning: Failed to create program for hashcode %@: %@
Error: C3DCommonProfileProgramReleaseHashCode can't find cache for tracked resource
Assertion '%s' failed. wrong notification sent
Unreachable code: _getCIFilterParameterValue - unexpected type
Error: _applyCIFilter can't fint render target named SceneKit-CI-nodetree-color
Warning: CIFilter should have been clipped by the culling
Warning: CIFilter should have been clipped by the culling (2)
Assertion '%s' failed. _createCIImageForTexture texture is not rect
Unreachable code: Could not find mesh source indexing info for source %p
Unreachable code: Unssuported texture coordinates channel (%d)
Unreachable code: Does not make sense
Unreachable code: Trying to subdivide a mesh that does not have exactly 1 position source.
Warning: Subdivision process might lead to gaps in surface because vertex welding is disabled when subdividing on the GPU
Assertion '%s' failed. Error while building face-varying channel.
Assertion '%s' failed. Internal consistency error
Unreachable code: Internal consistency error - Unexpected element type
Error (OpenSubdiv): %s
Warning (OpenSubdiv ): %s
Assertion '%s' failed. Semantic %d can not be a primvar
Unreachable code: Can not subdivide primvar data with %d values per component
Assertion '%s' failed. Can't subdivide further
Unreachable code: Invalid GPU primvar semantic '%@'
Assertion '%s' failed. Primvar data size is too big (cannot fit %d floats in a float4)
Assertion '%s' failed. Position sources must use the 'vertex' interpolation mode
Assertion '%s' failed. Number of normals at limit surface is not equal to number of vertex positions
Error: Position must be float3 to be subdivided. Actual type is %d
Assertion '%s' failed. C3DFramebufferCleanup - bad retain count
Assertion '%s' failed. can't render to texture if multisampled
Error: Could not issue extension for path: %s.
Assertion '%s' failed. program is of wrong type
Error: C3DResourceManagerMakeProgramResident failed to compile program - fallback on default program
Error: rendererContext is not tracked by the resource manager
Error: __ResourceManagerDeleteTexture: texture to be deleted not found, bail out
Error: _C3DResourceManagerDeleteTexture source does not match to any stored texture (no texture samplers associated)
Error: _C3DResourceManagerDeleteTexture can't find image source
Warning: C3DResourceManagerMakeImageResident invalid image
Warning: single texture is larger than memory limit
Assertion '%s' failed. Calling C3DRasterizerStatesCFFinalize outside of C3DReleaseRasterizerStates probably direct call to CFRelease
Assertion '%s' failed. RasterizerStates should be in the registry
Warning: Warning _lightNodes not NULL in C3DEnginePipelineSetup
Assertion '%s' failed. wrong notification type
Error: unexpected renderer element with no material/technique/program
Unreachable code: Unsupported node attribute '%@'
Assertion '%s' failed. no render elements have been created
Assertion '%s' failed. C3DTriangle3PointAtIndex: index out of bounds (%d)
Warning: C3DTriangle3BarycentricCoordinates: unable to solve the equation
Error: C3DRendererContextSetValueUniformAtLocation not implemented for this type (%d) yet
Error: uniform has incorrect type
Assertion '%s' failed. wrong length
Error: set transform not implemented on %@
Error: set world transform not implemented on %@
Error: set position not implemented on %@
Assertion '%s' failed. invalid iteration count
Error: OpenSubdiv unarchiver command buffer execution failed with status %d, error: %@
Unreachable code: Unsupported patch type
Assertion '%s' failed. GPU support for OpenSubdiv must not be enabled when there is a tessellator but the subdivision level is still 0.
Error: Invalidating OpenSubdiv runtime data of geometry %@
Assertion '%s' failed. %s called but there's no patch to draw.
Error: OpenSubdiv command buffer execution failed with status %d, error: %@
Assertion '%s' failed. Internal consistency error.
Error: OSD_MAX_VALENCE is set to %d and current mesh has a max valence of %d
Error: OpenSubdiv archiver dependency command buffer execution failed with status %d, error: %@
Error: OpenSubdiv archiver command buffer execution failed with status %d, error: %@
Error: C3DImageToMDLTexture not supported for image 3D
Warning: Failed to create cubemap from Model I/O texture
Assertion '%s' failed. Found in-between morph target with influence weight of %f
Warning: Warning: unable to flip non-float2 texture coordinates, skipping
Error: unknown MKGeometryType
Error: a MDLObject has more than 1 child mesh - not supported
Error: failed to find MKMaterial corresponding SCNMaterial
Error: Unknown Model I/O semantic %@
Assertion '%s' failed. C3DEffectCommonProfileGetHashCode: inconsistency error
Error: No function %@ in the common profile %@
Error: Could not deserialize the color %@
Error: C3DEffectCommonProfile DeserializeColor: No property for the key %@
Error: Common profile deserialization: could not read the property %@
Error: Common profile deserialization: property found for the key %@
Error: Could not deserialize the texture sampler %@
Assertion '%s' failed. Too many objects
Error: Cannot find the specified image
Error: Cannot find the image ID for the key %@ in the dictionary %@
Error: orphan effect common profile detected
Warning: __OpacityFromColorSlot:unexpected transparency mode %d
Assertion '%s' failed. LightingEnvironment not set on a Light or a Scene
Assertion '%s' failed. We do not support appending to really complicated interleavings
Error: C3DMeshSourceAppendVector3 - Type not supported
Error: C3DMeshSourceAppendVector2 - Type not supported
Error: C3DMeshSourceCreate: unsupported type
Assertion '%s' failed. Cannot set volatile data of a non volatile source
Assertion '%s' failed. Morph target has a vertex count different from the base geometry
Assertion '%s' failed. Internal consistency error, %@'s (%p) morph %p is not sparse
Error: AnimCodec - Failed to compress mesh
Error: AnimCodec - Failed to parse header
Error: AnimCodec - Failed to decompress animation
Error: AnimCodec - Can't decode metadata
Error: unsupported SH order
Assertion '%s' failed. _computeNeighbourIndexes - missing tetrahedron
Assertion '%s' failed. overwrite a neighbour index
Assertion '%s' failed. wrong data size for SH
Error: SH order unsupported : %d
Assertion '%s' failed. Should never have been outside the tetras
Error: _buildTetrahedrons - failed with first tetrahedron
Error: tetrahedrisation: index out of bounds
Assertion '%s' failed. will make an invalid tetrahedron valid
Assertion '%s' failed. validTetraCount > indexToRecycle
Assertion '%s' failed. _faceHasEdgeSharedWithMoreThanTwoOtherOpenFace
Assertion '%s' failed. memory smasher found in C3DEdgeArrayCreateFromMeshElement (%ld != %ld)
Assertion '%s' failed. C3DEdgeArrayGetEdgeAtIndex index out of bounds
Assertion '%s' failed. C3DTriangulationInfoCreateFromMeshElement - edge out of bounds
Error: C3DMeshElementEditorCreateWithMeshElement: mesh element is not a triangle array
Error: _C3DMeshElementEditorSetIndex unknown bytes per index
Error: C3DMeshElementEditorSubdivideTriangleAtIndex: triangleIndex out of bounds
Error: inconsistency - material count doesn't match - can't diff reference node
Error: inconsistency - material has custom properties - can't diff reference node
Error: inconsistency - hierarchy doesn't match - can't diff reference node
Error: inconsistency - hierarchy changed - can't diff reference node
Error: failed to parse key path %@ - missing '['
Error: failed to parse key path %@ - missing ']'
Error: failed to evaluate key path %@ - material index %d out of bounds (%d)
Error: failed to locate scene reference %@
Error: failed to resolve referenced scene (%@) cycle detected
Error: referenced animations can't be resolved without a SCNAssetCatalog
Error: referenced actions can't be resolved without a SCNAssetCatalog
Error: Index %ld out of range bounds [0...%ld]
Error: Index %ld out of bounds [0...%ld]
Error: Failed to deserialize an animation because it is of an unknown type (%@)
Unreachable code: C3DAnimationSetup - unknown animation class
Error: C3DSimpleAnimationEvaluate - invalid evaluation function
Error: SimpleAnimation deserialization: could not deserialize the animation
Error: _C3DSimpleAnimationInitWithPropertyList - no base type
Error: Failed to load IES profile : %@
Assertion '%s' failed. Light should be a IES
Error: While deserializing a light: could not decode the number for the key %@ (serializedData : %@)
Error: While deserializing a light: no value for the key %@ (serializedData : %@)
Error: While deserializing a light: could not decode the color
Error: While deserializing a light: could not decode the shadowcolor
Info: invalid zNear value (0) set to camera
Error: C3DProjectionInfosUnproject : invalid viewport dimension
Error: error in C3DProjectionInfosUnproject
Info: loaded camera has an invalid zNear value (0)
Error: CVMetalTextureCacheCreateTextureFromImage failed with status %d
Error: Could not get pixel buffer (CVPixelBufferRef)
Error: Could not create AVCaptureInput with error: %@
Error: Pixel buffer (CVPixelBufferRef) must be IOSurface-backed
Error: Invalid pixel buffer pixel format: %s
Error: Authoring pass can't find input depth pass.
Error: Unsupported draw instruction kC3DFXDrawGeometry
Error: Unsupported draw instruction kC3DFXDrawMetalCustom
Assertion '%s' failed. Unable to find dependency in previous techniques for pass %s
Unreachable code: Invalid render buffer type for attachment type
Unreachable code: Invalid render buffer type for attachment id
Assertion '%s' failed. attachementID out of bounds
Unreachable code: Invalid semantic for attachment id
Assertion '%s' failed. Render target not found
Assertion '%s' failed. need subdivision level
Assertion '%s' failed. child is already inserted in a tree
Assertion '%s' failed. prevChild is not parented to the right node
Warning: C3DNodeGetWorldMatrix - no transform tree
Assertion '%s' failed. Node should have a TT handle already
Assertion '%s' failed. layer index out of bound
Error: inconsistency in scene graph found in C3DNode finalize
Error: Could not read a matrix (serializedData: %@)
Error: Could not read a quaternion
Error: Could not read Euler
Error: Could not read the axis angle
Error: Could not read a matrix
Error: No data present to deserialize a rotation (serialized data : %@)
Error: Could not read a transform, position, scale and rotation have to be present (serializedData: %@)
Error: loading pivot from compressed collada file is not supported anymore - use SCN file format instead
Assertion '%s' failed. _serializeNodeAttribute lighmap not serialized
Error: Node deserialization: cannot retrieve the object ID
Warning: Node<->attribute inconsistency finalizing deserialization
Error: Node deserialization: cannot retrieve the lightmap image ID
Error: Node deserialization: cannot retrieve the lightmap image
Assertion '%s' failed. Node should already be in CullingSystem
Assertion '%s' failed. No double position sources allowed
Warning: Mesh '%@' : sources of redundant semantic '%@' will be ignored in rendering
Assertion '%s' failed. Mesh sources are not sorted correctly
Assertion '%s' failed. Mesh sources with same semantic non contiguous
Error: Mesh deserialization: cannot find the sources in %@
Info: Mesh deserialization: Skipped a source that will be recreated at runtime : %@
Error: Mesh deserialization: cannot find the specified source
Error: Mesh deserialization: cannot deserialize a source
Error: Mesh deserialization: cannot init a mesh element
Assertion '%s' failed. Can't copy bounding volumes from meshes with different element count
Assertion '%s' failed. Mesh sources are malformed
Assertion '%s' failed. Renderable data kind must not give a channel
Assertion '%s' failed. need to provide a valid channel index when adding a new source
Assertion '%s' failed. Could not find source with semantic %@ at index %d
Unreachable code: Internal consistency error in %s
Warning: Can only convert to lines or points element type
Warning: Can only convert from triangle array to another element type
Error: Cannot find the specified primary source
Error: Cannot find the specified source
Assertion '%s' failed. This accessor doesn't point back to the primary source
Error: Could not deserialize a source locator in %@
Assertion '%s' failed. Too many objects in the library
Assertion '%s' failed. This source should be a primary one
Warning: Can't add two position sources
Error: __C3DMeshCopy - unable to resolve interleaved mesh
Error: Failed to build renderable data for mesh %p
Assertion '%s' failed. Consistency error: there must be as many renderable elements as original elements
Warning: Mesh element %p of mesh %p has %d channels but they all define the same topology
Error: Deindexer failed - Source %p (%@) has no original data at index %u
Assertion '%s' failed. Deindexer failed - Hash value inconsistency
Assertion '%s' failed. Deindexing failed - Vertex count inconsistency
Warning: Mesh %p has multiple channels but deindexing didn't have any effect
Warning: Deindexing - Vertex at index %u of %u is not used by any geometry element
Assertion '%s' failed. Deindexing failed - Count of deindexed mesh sources does not match count of indexed mesh sources
Assertion '%s' failed. Deindexing failed - Count of deindexed mesh elements does not match count of indexed mesh elements
Unreachable code: Requested channel (%d) does not exist in element (%p)
Assertion '%s' failed. Two elements in the same mesh do not have the same number of index channels
Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)
Assertion '%s' failed. %s - Cannot create a renderable topology from indexed vertices
Error: %s - Invalid polygon edge count (%u)
Error: __C3DMeshElementCreateRenderablePrimitiveTypeCopy - polygon %u (%u vertices, indices [%u, %u]) does not fit in index buffer (%u elements)
Error: Inconsistent index count after triangulation.
Error: SCNAction: Custom actions can not be properly encoded, Objective-C blocks do not support NSSecureCoding.
Error: SCNAction: Custom actions can not be properly decoded, Objective-C blocks do not support NSCoding.
Assertion '%s' failed. invalid fill mode
Unreachable code: Blend mode not implemented.
Warning: Could not deserialize an effect
Assertion '%s' failed.  - Only vector3 type is supported.
Warning: Slider can only process triangles.
Warning: Occluder can only process triangles.
Warning: C3DSceneSetRootNode - old root node seems to be already connected to another scene
Assertion '%s' failed. Only %d layers are available, but layer %d requested
Warning: RootNode is not retained by the scene
Error: Could not read the animations manager
Error: C3DSceneRef _copySerializedHierarchy: lib entry not found
Warning: Some nodes failed to be deserialized
Error: ... and we do not even have a root node, so bailing out
Error: Scene deserialization : cannot finalize the deserialization of the animation manager
Error: Library could not remap the ID %@
Error: _deserializeHierarchy: could not find the specified node in the library
Error: _deserializeHierarchy: no nodeID specified!
Unreachable code: You can't change the sceneRef of a scene
Warning: %@: zNear of 0 is not allowed
Assertion '%s' failed. inconsistent physically-based camera settings
Error: failed to create a GL context with the pixelFormat %@
Warning: SCNCreateGLContext - failed to share our context with SpriteKit - fallback on a private context
Unreachable code: _setupMaterialProperty -- should not reach
Warning: can't prepare shadable animation with path %@
Error: Material : %@ is not an animatable path
Error: Failed to archive material's custom attributes. %@ %@
Assertion '%s' failed. cannot update matrix without affine
Assertion '%s' failed. cannot update affine without matrix
Error: attempt to add a parent node as a child node
Error: removeChildNodeAtIndex - index out of bounds
Unreachable code: error in removeObjectFromChildNodesAtIndex -> try to remove inconsitent node
Unreachable code: circular reference found when trying to add %@ as a child node of %@
Unreachable code: error in replaceObjectInChildNodesAtIndex -> index out of bounds
Unreachable code: error in replaceObjectInChildNodesAtIndex
Error: error in removeFromParentNode : inconsistent tree
Error: removing the root node of a scene from its scene is not allowed
Assertion '%s' failed. _updateFocusableCache - invoked on a non focusable node (waste of time)
Error: Physics body %@ 's owner (%@) should be %@
Error: Physics body %@ already has a owner: %@ that is not %@
Error: attempt to add a null particle system on %@
Assertion '%s' failed. removeObjectFromMaterialsAtIndex: index out of bounds
Error: error while transposing skeleton or morph target
Error: error while transposing animations to cloned tree
Assertion '%s' failed. bad type
Assertion '%s' failed. bad image type
Assertion '%s' failed. bad cull mode
Assertion '%s' failed. bad fill mode
Assertion '%s' failed. bad blend mode
Assertion '%s' failed. bad blend operation
Assertion '%s' failed. bad comparison func
Assertion '%s' failed. bad stencil op
Assertion '%s' failed. Polygon Array not supported in Metal
Assertion '%s' failed. Triangle Fan not supported in Metal
Assertion '%s' failed. Patch not supported in Metal
Warning: r8Unorm_sRGB variant is not supported on macOS for this hardware. Defaulting to r8Unorm.
Warning: rg8Unorm_sRGB variant is not supported on macOS for this hardware. Defaulting to rg8Unorm.
Error: Failed to create Metal pixel format for %@ [%d components, %d bits per component, bitmap info: %u (%@|%@), float components: %@, color space: %@]
Unreachable code: Kernel functions have no corresponding program stage
Warning: unsupported texture type %d
Warning: C3DValueWriteToMTLData - Unsupported data type %@
Warning: value unsupported %d of member %@
Error: Unexpected pixel format %lu
Unreachable code: Unexpected antialiasing mode (%d)
Error: [SCNScene root] is deprecated, use rootNode instead
Error: can't convert c3dImage to cgImage %@ (url=%@)
Error: _subnodeFromIndexPath - invalid keypath
Error: %@ is not in a scene yet
Assertion '%s' failed. _subnodeIndexPath - unexpected count (hierachy was mutated?)
Warning: failed to load scene at %@
Error: failed to unarchive SCNScene - (secureCoding compliance issue?)
Error: SCNTextureSource abstract method invoked %@
Error: SCNImageSource astract method invoked %@
Error: SCNTextureDelegateSource::textureProxy -> no delegate
Error: C3DTextureSourceGetSharedRendererContext: cannot create context error %d
Assertion '%s' failed. wrong target index
Warning: Unknown render buffer format %hhu
Error: C3DCoreProfileSlotToAttachmentID : unknown slot
Assertion '%s' failed. DrawNodes must output in color or depth as first outputs
Assertion '%s' failed. Can't get a valid projection info
Warning: MappingChannel %d needed but not available
Assertion '%s' failed. too many io texcoord needed
Assertion '%s' failed. bad redirection index after sort
Assertion '%s' failed. weld - bad index
Assertion '%s' failed. weld - bad redirection
Assertion '%s' failed. weld - redirection out of bounds
Assertion '%s' failed. weld - bad duplicated vertex count
Assertion '%s' failed. weld: bad index
Info: PrefersOpenGL key is set in the plist but Metal is requested programmatically. GL will be used
Error: Failed to create default Metal device.
Error: switchToCameraNamed: no camera named %@
Warning: SCNView -> can't create a valid pixel format
Error: Can't set the pixel format of a Metal-based SCNView
Error: Pixel format defines an unknown sample count : %d
Error: attaching a single wheel to multiple vehicle is not supported
Unreachable code: invalid spatial handle (%d) given
Assertion '%s' failed. invalid spatial handle (%d) given
Assertion '%s' failed. handle should not point to non existing index
Assertion '%s' failed. Background was already rendered in the main pass
Error: <FlushMappedBufferRange> unsupported on OpenGL Compatibility profile
Error: syntax error in the uniform declaration : %@
Error: SCNRenderer::init - no engine context
Assertion '%s' failed. Private renderer only supports SCNView, SCNLayer or SCNMetalLayer
Assertion '%s' failed. device context doesn't conform to MTLDevice protocol
Warning: _deleteGLFramebuffer - No context!
Assertion '%s' failed. _beginFrame - unexpected rendering API
Warning: _prepareGLRenderTarget - No context!
Assertion '%s' failed. invalid framebuffer state
Assertion '%s' failed. invalid renderer (3)
Error: failed to create a framebuffer
Error: framebuffer width must be > 0
Error: framebuffer width (%d) exceeds device's limit (%d), clamping
Error: framebuffer height must be > 0
Error: framebuffer height (%d) exceeds device's limit (%d), clamping
Error: autoenablesDefaultLighting: renderer has no context
Error: setAutoenablesDefaultLighting: renderer has no context
Assertion '%s' failed. can't set a presentation instance as a point of view
Error: SCNRenderer::setTechnique - no engine available yet - ignoring
Assertion '%s' failed. warmUpScene: no gl context
Error: prepareObject:shouldAbortBlock renderer has no GL context
Error: prepareObject:shouldAbortBlock failed to create a shared context
Assertion '%s' failed. invalid renderer (4)
Error: glError before rendering SceneKit contents: %x
Assertion '%s' failed. can't call renderAtTime:withEncoder:pass:commandQueue: with a GL context
Error: Starting iOS 13.0 and macOS 10.15, SceneKit uses reverseZ depth buffer to achieve better precision. You must clear your depth to 0.0 or everything will be discarded. To opt out of this new behavior you can set the SCNDisableReverseZ key to a boolean value of YES in your app's Info.plist file.
Error: Render pass descriptor misconfigured - missing drawable texture
Warning: createSnapshot: no GL context
Error: Failed to create snapshot with error %@
Error: Can only update lightProbe
Error: Can only update 'baked' lightProbes
Assertion '%s' failed. MTLBuffer containing the SH coefficients has not the expected size
Unreachable code: Unsupported probe type
Error: %s should only be called when using Metal
Error: %s should only be called on a private renderer, using -[SCNRenderer _addGPUFrameCompletedHandler:] instead
Error: %s should only be called on a private renderer, using -[SCNRenderer _discardPendingGPUFrameCompletedHandlers] instead
Assertion '%s' failed. framebuffer should be null
Assertion '%s' failed. multisampling framebuffer should be null
Assertion '%s' failed. invalid framebuffer size
Error: unable to create the shader cache folder at %@ (%@)
Unreachable code: Invalid resource type
Unreachable code: Not indices are bound!?!
Assertion '%s' failed. Bad stage
Error: Invalid index size (%d bytes per index)
Unreachable code: Invalid index size (%d bytes per index)
Error: unknown light type %@
Error: SCNEncodeAnimations unknown animation: %@
Error: can't deserialize animation %@
Error: failed to deserialize animation %@
Error: SCNEncodeAnimations failed to encode animation: %@
Error: SCNEncodeAnimations unknown animation type: %@
Error: SCNDecodemage: invalid archive
Warning: CGPath archiving: unknown path element type
Assertion '%s' failed. Only original data kind can have non 'GPU' primitive type
Assertion '%s' failed. Variable topology sample expects triangles
Unreachable code: Volatile meshes are not supported by the deformer stack
Unreachable code: Unsupported semantic %@
Warning: unable to infer the type of a basic animation: %@
Warning: unable to infer the type of a keyframed animation: %@
Error: animating between instances is not supported
Error: CAKeyframeAnimationToC3DAnimation :: too large value to animate : %d bytes
Error: CAKeyframeAnimation has no keyframe - skipping conversion
Error: can't add a NULL animation to %@
Assertion '%s' failed. SCNAddAnimationGroup target is not an entity
Assertion '%s' failed. SCNRemoveAnimation target is not an entity
Assertion '%s' failed. SCNFadeAndRemoveAnimation target is not an entity
Assertion '%s' failed. SCNRemoveAllAnimations target is not an entity
Assertion '%s' failed. SCNFadeAndRemoveAllAnimations target is not an entity
Assertion '%s' failed. _animationEvents should be nil
Unreachable code: Unknown animation type %@
Error: can't encode an animation that has never been attached to any target
Error: Loading animation %@ failed with %@
Error: failed to convert CAAnimation to SCNAnimation
Warning: default duration is zero - using default transaction duration
Unreachable code: SCNAnimation to CAAnimation: no animation data
Error: This animation can't be changed to additive. To make this animation additive first convert it to a CAAnimation, set it to additive and convert back to SCNAnimation
Error: This animation can't be changed to cumulative. To make this animation cumulative first convert it to a CAAnimation, set it to cumulative and convert back to SCNAnimation
Warning: failed to optimize keyframes
Error: unknown fill mode
Error: Unsupported CAPropertyAnimation subclass (%@)
Error: Unsupported CAAnimation class (%@)
Error: sub-animation %@ of %@ has no keyPath - ignoring
Error: C3DAnimationToCAAnimation: unsupported animation
Warning: SCNAnimationGroupToCAAnimationGroup - no target path
Warning: SCNSimpleAnimationToCABasicAnimation - can't convert startValue
Warning: SCNSimpleAnimationToCABasicAnimation - can't convert endValue
Warning: SCNSimpleAnimationToCABasicAnimation - can't convert byValue
Unreachable code: Unhandled SceneKit error code (%d)
Error: failed to unarchive data at %@ (%@)
Error: failed to unarchive scene at %@ - unknown decoded object class (%@)
Error: failed to unarchive scene at %@ (%@)
Error: entryWithUID:withClass: object with uid %@ exists but is not a geometry
Error: entryWithUID:withClass: object with uid %@ exists but is not a material
Error: entryWithUID:withClass: object with uid %@ exists but is not an animation
Error: entryWithUID:withClass: object with uid %@ exists but is not a node
Error: entryWithUID:withClass: object with uid %@ exists but is not a light
Error: entryWithUID:withClass: object with uid %@ exists but is not a camera
Error: entryWithUID:withClass: object with uid %@ exists but is not a scene
Error: entryWithUID:withClass: object with uid %@ exists but is not a skinner
Error: entryWithUID:withClass: object with uid %@ exists but is not a morpher
Error: entryWithUID:withClass: object with uid %@ exists but is not an image
Error: entrieswithClass: class %@ is not a known C3D class
Assertion '%s' failed. the c3dImage should have been cleared when setting a layer or a skscene
Error: slotName %d not found
Error: array for material property contents must have 6 elements
Warning: copyC3DImageFromImage: invalid sub-image
Assertion '%s' failed. inconsistency in SCNMaterialProperty::parentWillDie
Assertion '%s' failed. _updateMaterialAttachment: unexpected argument
Error: SKTexture not found - missing linkage with SpriteKit?
Error: unknown material property type for archiving
Error: unknown archived material property type
Error: C3DLibraryCreateEntryIdentifier - unknown type
Error: _remapInfos does not contain an entry %@
Error: library does not contain an entry %d with kind %d
Warning: C3DLibraryAddEntryWithUniqueID - object has no unique ID
Error: Library: could not deserialize the substorage for the type %@
Error: unknown type: %d
Error: type %d is not serializable
Assertion '%s' failed. inconsistent parameters
Error: Library deserialization: could not finalize the deserialization of a substorage
Error: Library Deserialization: cannot finalize the deserialization of %@
Warning: C3DLibraryGetMemoryUsageForKind found an image with no sampler
Error: __CreateMeshElement unexpected byte per index
Unreachable code: Geometry rendering not yet implemented
Error: ParticleSystem shaders missing : %@
Assertion '%s' failed. ParticleSystemInstance: wrong instance stored in rendererElement
Error: C3DFXTechniqueAppendPass out of capacity
Assertion '%s' failed. C3DFXTechniqueGetPassAtIndex index %ld is out of bounds (%ld)
Assertion '%s' failed. Must declare upfront
Assertion '%s' failed. Cannot declare twice the same symbol (%@)
Assertion '%s' failed. Assumed count is 1
Error: C3DFXTechniqueSetValueForSymbol - expect an image for paramName %@
Error: C3DFXTechniqueSetValueForSymbol - unknown param named %@
Error: C3DFXTechniqueGetValueForSymbol - unknown param named %@
Assertion '%s' failed. compiling a technique twice
Error: invalue description for input named %@ - expect a dictionary
Error: C3DFXTechniqueCompile - invalid description (sequence missing or empty) %@
Info: pass named %@ appears to be useless - skipping
Assertion '%s' failed. unexpected pass inputs in merge
Assertion '%s' failed. _customInitializeBlock not nil
Assertion '%s' failed. _customExecuteBlock not nil
Warning: SCNMTLSmoothNormalsDeformer can only process triangles and polygons
Assertion '%s' failed. indexed index overflow
Assertion '%s' failed. expecting at least triangles here
Assertion '%s' failed. splitted vertices should not have been decremented yet
Assertion '%s' failed. welded vertices should have been entirely decremented
Error: Can't create a vehicle with this chassis because it is not in the scene yet
Warning: Chassis should already have a body
Error: leaking materials array
Error: Cannot set edge creases element because its primitive type is not SCNGeometryPrimitiveTypeLine
Error: Cannot set edge creases source because its semantic is not SCNGeometrySourceSemanticEdgeCrease
Error: Failed to archive geometry's custom attributes. %@ %@
Warning: Found elements with different channel counts in the same geometry
Error: Missing channel for source at index %u
Error: Invalid channel (%d) for source at index %u
Error: Point of view has custom projection.
Assertion '%s' failed. Mesh type has to define a topology
Error: light node already has an authoring node - skip
Error: particle node already has an authoring node - skip
Error: camera node already has an authoring node - skip
Error: physicsField node already has an authoring node - skip
Error: FATAL ERROR : can't load library without a path
Error: FATAL ERROR : failed to load Metal shaders library %@, %@
Error: Failed to load common profile chache library : %@
Error: Compilation failed %@
Error: Only metal program are supported %@
Error: Failed to find pre-compiled combination %@ + %@
Error: Failed to collect shader: %@
Error: Failed to collect shader: additional file "%@" is not always the same
Error: FATAL ERROR : failed compiling shader:
%d: %@
Unreachable code: Unknown compilation mode %d
Error: Physically based lighting model is not supported by the OpenGL renderer, using Phong instead (3)
Error: failed to load vertex uber shader.
Error: failed to load fragment uber shader.
Error: Physically based lighting model is not supported by the OpenGL renderer, using Phong instead (2)
Warning: C3DSkinnerTransposeSkeleton - unable to transpose every joints
Warning: Cannot update the joints using node names: unammed joint found
Warning: Cannot update the joints using node names: can't find node named %@
Warning: _C3DSkinnerUpdateBoundingBox - skinned node has no geometry
Error: We did not succeed in locating all the joints, so do not update the geometry as it might be worse if we use the wrong bones.
Error: _C3DSkinnerUpdateBoundingBox invalid mesh source
Unreachable code: Unknown skinning calculation mode.
Assertion '%s' failed. New deformer pipeline should never have to call `__C3DSkinnerPrepareSkinnedMesh`
Assertion '%s' failed. flags not up to date
Assertion '%s' failed. Position source should be mutable
Assertion '%s' failed. Normal source should be mutable
Error: C3DSkinnerUpdateJointsAndBoundingBox skinner has no mesh
Assertion '%s' failed. CPU Skinning dst position source not created.
Assertion '%s' failed. CPU skinning: position not mutable
Assertion '%s' failed. CPU Skinning dst normal source not created.
Assertion '%s' failed. CPU skinning: normal not mutable
Unreachable code: It's up to SceneKit to decide if `kC3DSkinnerCalculationModeUpdateTransform` can be used.
Error: C3DSkinner serialization: lib entry not found
Warning: Skinner deserialization: cannot find the specified skeleton
Error: Skinner deserialization: cannot find a joint
Error: Skinner deserialization: cannot find the skin
Error: C3DSkinner deserialization: lib entry not found
Error: C3DSkinner deserialization: Could not get a valid number value
Assertion '%s' failed. We should have a compute command encoder open at this point
Assertion '%s' failed. We should have a blit command encoder open at this point
Assertion '%s' failed. Not enough space allocated
Warning: Failed to transpose skeleton
old skeleton: %@
new skeleton: %@
Error: SCNSkinner setBaseGeometry is deprecated on iOS10 and OS X 10.12 and has no effect
Error: SCNSkinner: there must be the same number of bone weights and bone indices
Error: SCNSkinner: bone weights must be of type `float`
Error: SCNSkinner: bone indices must be uint8 or uint16 (maximum of 2 bytes)
Error: SCNSkinner: bone indices stride must be equal to componentsPerVector * bytesPerComponent
Error: SCNSkinner: bone weights stride must be equal to componentsPerVector * bytesPerComponent
Error: skinner: invalid index (%d)
Error: mismatch between the vertex count and the number of bones per vertex
Assertion '%s' failed. skinner: invalid compressed data
Unreachable code: Unsupported bytes per weight
Error: can't create a skinner with no bones
Error: can't create a skinner with no base geometry
Error: bones count and bind transform count don't match
Assertion '%s' failed. boneIndices - failed to deindex
Assertion '%s' failed. boneIndices - failed to deindex (2)
Error: number of transforms (%d) doesn't match the number of joints (%d)
Error: Bones index too large for compressed representation : %d
Error: Unsupported skin weight format
Assertion '%s' failed. inconsistency in %s
Error: invalid skin indices
Info: Too many influencing joints (%ld > %d) on the vertex #%u, will cap to %d and renormalize
Error: No jointsCount in the skin %@
Error: Unable to read the jointsCount in the skin %@
Warning: No maxInfluences in the skin %@, defaulting to 4. Please re-convert your assets.
Warning: Unable to read the maxInfluences in the skin %@, defaulting to 4. Please re-convert your assets.
Error: No inverseBindMatrices in the skin %@
Error: No defaultShapeMatrix in the skin %@
Error: A vertex weight index does not fit on an int
Error: Skin: Could not remap the ID for geometry %d
Error: Skin deserialization: no weightsCount in %@
Error: Skin deserialization: no jointsForVertexWeights in %@
Error: Skin deserialization: no vertexWeights in %@
Error: Skin deserialization: invalid vertexWeights
Assertion '%s' failed. Fov is larger that 180 degrees. this can't be
Error: GenericSource deserialize => no data type
Error: GenericSource deserialize => no count, bailing out
Error: GenericSource deserialize => no comp/value, bailing out
Error: GenericSource deserialize => no padding, bailing out
Error: Could not serialize the accessor's type
Error: accessor->_count too big
Error: accessor->_offset too big
Error: accessor->_padding too big
Error: Accessor serialization failed
Error: Accessor deserialization: Could not find the source ID
Error: Accessor deserialization: Could not find a valid source type
Error: Accessor deserialization: Could not remap the ID for source %d
Error: Accessor deserialization: : no serialized data
Error: C3DSourceAccessorGetValuePtrAtIndex - index out of bounds : %d > %d
Error: C3DSourceAccessorGetValuePtrAtIndex - no data
Error: C3DSourceAccessorGetMutableValuePtrAtIndex - index out of bounds : %d > %d
Error: C3DSourceAccessorGetVolatileValuePtrAtIndex - index out of bounds : %d > %d
Assertion '%s' failed. cannot access volatile data on non volatile source
Error: The destination does not have enough room to copy this data
Error: error in C3DSourceAccessorCopyDataToAccessor
Assertion '%s' failed. You have to push frames before allocating memory.
Unreachable code: C3DStackAllocator: Max Restore Points reached!!!!
Assertion '%s' failed. C3DStackAllocator: You cannot pop frames without pushing first.
Assertion '%s' failed. We used to support only floats, but another type was encountered
Error: ERROR: GenericSource deserialize => no data type, bailing out
Error: ERROR: GenericSource deserialize => no count, bailing out
Error: ERROR: GenericSource deserialize => no stride, bailing out
Error: Could not deserialize an accessor
Error: Could not serialize an accessor
Error: Cannot finalize the deserialization of mesh source: accessor data missing
Warning: Cannot duplicate a Metal Buffer source. Create an empty data instead.
Assertion '%s' failed. cannot set data to volatile source
Assertion '%s' failed. cannot set data to MTL buffer
Assertion '%s' failed. cannot set volatile data to non volatile source
Assertion '%s' failed. cannot set volatile data to MTL buffer
Error: SCNMTLResourceManager initWithDevice : cannot create a command queue. Bailing out.
Assertion '%s' failed. cannot use volatile meshSource
Assertion '%s' failed. Semantic %d is not meant to be passed to shaders
Assertion '%s' failed. source should be present
Assertion '%s' failed. size mismatch in mutable buffers %u!=%u
Error: missing value for attachment "%@" [vertex: %d fragment: %d]
Error: incorrect buffer size  for attachments vertex [%d] fragments [%d]. Expected:%d Provided:%d
Error: Argument '%@' : failed to write value to Metal buffer (%@)
Error: Argument '%@' : mismatch between the NSData and the buffer size %ld != %ld
Error: Argument '%@' : only NSData and NSValue are supported for shadable value storage (found '%@'). Please make sure that your custom shader modifier uniform types match the custom properties of the shadable object
Assertion '%s' failed. only C3DValue are supported for partial struct storage
Warning: Missing texture value for %@
Unreachable code: Sampler are not yet implemented as separate bindings
Error: format %@ not convertible to MTLVertexFormat
Error: DeferredShadowPass Setup - no light
Error: failed to load audio source at %@
Error: can't archive audio data directly
Error: Animation group deserialization: could not deserialize the animation
Error: Could not deserialize an animation
Error: Could not deserialize a keyframe animation
Error: Could not deserialize an animation: animation not found in %@
Error: Could not deserialize an animation: targetPath not found in %@
Error: _C3DAnimationChannelCopyPropertyList - no target path
Error: unable to update the physics shape of %@
Warning: cannot change collision bit masks without physics world
Error: cannot apply force on a body that is not attached to a SCNNode
Error: cannot clear forces on a body that is not attached to a SCNNode
Assertion '%s' failed. SCNPhysicsBody is already attached to a SCNNode
Error: cannot attach a body to a null node %p
Error: SCNTextureSpriteKitSource::textureProxy -> no scene
Warning: SCNTextureSource unexpected SKScene
Unreachable code: -[SCNDisplayLink invalidate] must be called before -[SCNDisplayLink dealloc]
Error: Failed to create display link with error %d
Error: format %lu not supported for SH generation
Unreachable code: vm_allocate failed allocating %zu bytes
Error: [SCNAction group:] invoked with nil
Warning: changing the content of a physics shape is not expected
Assertion '%s' failed. Unsupported indices stride
Info: Non triangle list element type not yet supported in physics shape generation
Error: vertex format not supported for physics shape creation (%d)
Warning: Cannot create convex hull for entity %@
Error: Compound shapes cannot be created without shapes
Warning: SCNPhysicsShape does not support a SCNCone with TopRadius != 0.0
Warning: Physics shape construction does not support meshes with positions value type different from double or float. (%d)
Unreachable code: This is not yet implemented
Unreachable code: NOT IMPLEMENTED YET
Unreachable code: C3DParametricGeometryGetType - unknown type
Assertion '%s' failed. A parametric geometry with a mesh must also have a hash
Assertion '%s' failed. inconsistency in _C3DParametricGeometryReleaseCachedMesh
Assertion '%s' failed. inconsistency in _C3DParametricGeometryCacheIncrRetainCount
Error: C3DParticleModifier_PhysicsField - no aether
Assertion '%s' failed. Can't change max batch size while in batch
Warning: overflow the max batch size boundary
Assertion '%s' failed. Top level filtered node must have a filter
Assertion '%s' failed. Trying to access last element of empty Array.
Error: C3DGLSLProfileBindProfileInputs - profile has no technique
Error: wrong location returned for input named %@
Error: can't find input named %@
Warning: the same program is shared by two passes but indexed in a different manner
Error: failed to find texture target named %@
Error: declared type doesn't match the uniform named %@
Unreachable code: Metal renderer does not support other shaders than Metal
Error: Metal renderer does not support nil vertex function name
Error: Missing vertex function `%@`, error: %@
Error: Missing fragment function `%@`, error: %@
Error: Missing vertex function `%@`
Error: Missing fragment function `%@`
Info: Shaders without a vertex function are not allowed
Error: Compiler error while building render pipeline state for node %@:
Error: Failed to create compute function '%@', error: %@
Error: Failed to find compute function '%@'
Error: Failed creating ComputePipelineState, error: %@
Assertion '%s' failed. Caching requires a constant hash to be provided when using constants
Unreachable code: Unsupported pixel buffer format %s
Unreachable code: Unsupported pixel buffer YCbCr matrix %@
Error: Could not create color space from %@ and %@
Assertion '%s' failed. string to type conversion not supported
Assertion '%s' failed. C3DValueAdd - invalid arguments
Assertion '%s' failed. assertion in DDS loading
Info: SCNSceneSourceConvertUnitsToMetersKey and SCNSceneSourceConvertToYUpKey have no effect on compressed assets. Use Xcode's compression options instead
Warning: Safe mode enabled, denying the download of a network URL %@
Warning: Unable to find the image named %@ at the specified path (%@)
Warning: Invalid URL %@
Warning: light_map uv_set:%d is pointing to an invalid uv_set(no corresponding source) and was reset to 1
Unreachable code: __OptimizeMesh:bytesPerIndex != 1, 2, or 4 during conversion, this should not happen !!
Warning: invalid zRange detected (whole scene clipped)
Error: can't serize plist :%@
Error: Could not get the data for the serialized property list
Error: Could not zip the serialized property list
Error: failed to write scene
Error: This file cannot be opened (version is too old)
Error: This file cannot be opened (version of this c3d is too recent for this version of the framework)
Error: Could not find the zipped data
Error: Could not unzip the zipped data
Error: Error loading the unzipped data: %@
Error: cannot initialize library
Error: Cannot get the library in the serialized data
Error: cannot initialize scene
Error: cannot finalize scene deserialization
Warning: cannot finalize library deserialization
Unreachable code: _C3DEntityCFInit
Unreachable code: _C3DEntityCFFinalize
Assertion '%s' failed. CFTypeIsC3DEntity - dispatched twice
Assertion '%s' failed. C3DEntitySetAttribute failed to cache attribute
Assertion '%s' failed. missing attribute
Warning: adding a node that was just removed %p
Error: unknown notification name
Assertion '%s' failed. Override custom pass name if it doesn't have any fxPass
Assertion '%s' failed. Override custom pass execute if it doesn't have any fxPass
Error: Unsupported pixel format %@ (%u) in KTX encoder
Error: Unsupported texture type %@ (%u) in KTX encoder
Warning: KTX file seems too small or is not a KTX
Error: Only big endian ktx are supported
Error: Unsupported format in KTX file
Warning: Compression type %d not supported
Error: overflow reading mip[%d] (%zu > %zu)
Error: overflow reading slice[%d] / mip[%d] (%zu > %zu)
Assertion '%s' failed. C3DVertexAttribFromParameterSemantic channel out of bounds
Error: can't find program named %@
Assertion '%s' failed. ShadowMapPass::setup() - Light missing from light node
Assertion '%s' failed. ShadowMapPass::setup() - Light doesn't cast shadow
Assertion '%s' failed. It doesn't make sense to call C3DMeshElementCreateIntervalList for sources with different channels
Error: Could not create intervals for sparse morph target %d (this morph target is useless)
Error: Failed to create packed source %d for sparse morph target %d
Assertion '%s' failed. sparse target should only contain 1 mesh element
Assertion '%s' failed. sparse targets should be in additive mode
Error: No morphingType in the morph %@
Error: Unable to read the morphingType in the morph %@
Error: Could not remap the ID for mesh %d
Error: Could not remap the ID for weights source %d
Error: Morpher has %d targets weights, but has %d main targets (note: there are %d in-betweens and %d correctives)
Assertion '%s' failed. Morpher failed to update all its runtime weights
Error: Internal consistency error. There should be %d runtime morph target weights, but we the current morph weight index is %d.
Assertion '%s' failed. Morph of other type than float not yet implemented
Unreachable code: %s should never be called when using the new deformer pipeline
Error: Morpher deserialization: cannot find the morph
Error: C3DMorpher deserialization: lib entry not found
Error: C3DMorpher deserialization: Could not get a valid number value
Assertion '%s' failed. C3DFXContextGetCurrentPassInstance - invalid index
Warning: C3DFXContextGetFirstPassInstanceWithGroupID: failed to find pass instance with name (%@)
Error: _C3DFXSetupPasses : no context
Error: shadows are only supported by spot lights and directional lights
Assertion '%s' failed. C3DEngineContextRenderSubTechnique is already being rendered
Assertion '%s' failed. sub techniques of type draw scene is not supported
Assertion '%s' failed. Need one type of render context
Error: failed to bind program for pass %@
Assertion '%s' failed. unexpected subpass fbo
Error: pass %@ has no program set
Error: C3DFXRenderPassWillExecute: invalid framebuffer
Assertion '%s' failed. C3DFXContextSetCurrentColor invalid retainCount
Assertion '%s' failed. C3DFXContextSetCurrentDepth invalid retainCount
Error: can't share a SCNPhysicsField is already attached to a SCNNode
Assertion '%s' failed. SCNPhysicsField is already attached to a SCNNode
Assertion '%s' failed. Progress not current.
Assertion '%s' failed. Progress fraction is greater than 1.0
Assertion '%s' failed. To many calls to the unitCompletedBlock
Error: %@ setWeight:forTargetAtIndex:%d - index out of bounds (%d)
Assertion '%s' failed. Update can't be done in place
Error: invalid in-between buffer, ignoring in-betweens
Assertion '%s' failed. Invalid in-between count (out of bounds) passed to morpher initialization
Assertion '%s' failed. Expected %u in-betweens but found %u
Assertion '%s' failed. Invalid range
Assertion '%s' failed. Presentation instance query targets the wrong scene
Assertion '%s' failed. Internal consistency error 
 no free index
Assertion '%s' failed. offset should be exactly equal to size
Assertion '%s' failed. should have some index free
Assertion '%s' failed. subBuffer size overflow %d > %d
Assertion '%s' failed. __UpdateHashCodeWithTextureType:inconsistent textureType
Error: Too many uniform custom samplers given (Max is %d)
Error: invalid custom texture slot.
Assertion '%s' failed. effect slot hash out of bounds
Assertion '%s' failed. ProgramHashCode should be in the dictionary
Assertion '%s' failed. Count should be > 0
Assertion '%s' failed. C3DResourceManagerRegistryReleaseContext invalid retainCount
Error: SCNTextureCoreAnimationSource::textureProxy -> no layer
Error: Skinning internal consistency error - vertex count mismatch ('%d == %d' assertion failed)
Error: Skinning internal consistency error - out of range bone index ('%d < %d' assertion failed)
Assertion '%s' failed. Wrong vertex count for skinned positions
Assertion '%s' failed. Wrong vertex count for skinned normals
Assertion '%s' failed. Wrong vertex count for skinned tangents
Error: Unflushed transaction present.
Error: Transaction stack contains an uncommited transaction.
Assertion '%s' failed. Unflushed transaction present.
Warning: invalid keypath: %@ sent to object %@
Error: C3DTransactionCommit - transaction already committed
Error: Scene %@ is modified within a rendering callback of another scene (%@). This is not allowed and may lead to crash
Assertion '%s' failed. C3DTransactionRemoveChild inconsistency
Error: C3DTransactionRemoveChild - inconsistency
Assertion '%s' failed. Error in C3DTransactionPop -> stack empty
Error: unexpected transaction commit (missing begin?)
Assertion '%s' failed. C3DTransactionAnimationDidComplete inconsistent animation count
Assertion '%s' failed. C3DTransactionAnimationDidInterrupt inconsistent animation count
Unreachable code: Command enqueued by %@ was expected to be run in immediate mode
Unreachable code: Unsupported class %@
Error: geometrySourceWithData: interleaved buffers as doubles are not supported
Error: geometrySourceWithBuffer - invalid vertex format
Error: _geometrySourceWithSource - invalid vertex format
Error: Could not create mesh source
Assertion '%s' failed. SCNGeometrySource should only store a base type
Assertion '%s' failed. vImageEncodeVectorHalf only supports half2/3/4
Assertion '%s' failed. Consistenty check issue during conversion for vImageEncodeVectorHalf
Assertion '%s' failed. vImageEncodeVectorHalf failed to write bytes
Unreachable code: Unknown component type
Unreachable code: SCNGeometrySource should only store a base type
Unreachable code: Data is marked as compressed but does not contain half components
Unreachable code: vImageEncodeVectorHalf only supports half2/3/4
Assertion '%s' failed. Decoding failed
Error: Failed to decompress data because vImageDecodeVectorHalf is not available
Unreachable code: Geometry source has invalid bounds
Error: _geometrySourceWithSource - Conversion failed
Unreachable code: SCNGeometryPrimitiveTypePolygon not supported with MTLBuffers
Assertion '%s' failed. SCNGeometryElement initialization - Invalid data length
Error: SCNGeometryElement initialization - Invalid index size (%ld bytes)
Error: SCNGeometryElement initialization - Invalid polygon edge count (%ld)
Error: not able to get click origin
Warning: _beginTranslateAtLocation: invalid zRange
Warning: Warning: no C3DIntersectionRay3Plane
Error: setGimbalLockVector is deprecated
Warning: _computeTranslationOrigin3DFromPoint: invalid zRange
Error: Could not create service connection.
Error: Message error: %s
Error: [ResourcesSandboxing] Could not unarchive reply arguments.
Error: Could not create the XPC message object
Error: Could not create object from message arguments.
Error: Could not get resource list from reply message.
Error: Could not get extension at index: %d.
Error: Could not consume extension at index: %d.
Error: Unable to resolve URL %@
Assertion '%s' failed. You can't allocate a registry twice
Assertion '%s' failed. You can't deallocate a registry that wasn't allocated
Assertion '%s' failed. You can't register twice the same semantic
Assertion '%s' failed. You can't register twice the same argument name
Warning: arguments named %@ is reserved for type %d
Warning: unknown member in scn automated buffer : %@
Unreachable code: invalid program stage %d
Assertion '%s' failed. Argument with the same name cannot have different types (%d != %d)
Assertion '%s' failed. Argument with the same name cannot have different blocks
Assertion '%s' failed. Argument with the same name cannot have different class type
Assertion '%s' failed. Only supports pass buffer arguments as struct
Warning: struct member does not match pass description : %@
Assertion '%s' failed. buffers of the same name in different stages need to have the same type
Error: AVAssetWriter can't create a movie at %@ (error:%@)
Error: appendImage: failed to get a pixelBuffer from CVPixelBufferPoolRef
Error: append pixel buffer failed
Error: error while exporting movie: %@
Assertion '%s' failed. realloc has an allocation size of 0 bytes
Assertion '%s' failed. Cannot produce any additional triangle.
Error: C3DShapeConnectedComponentTriangulatePseudopolygon - neighbor index out of bounds
Error: C3DMeshCreateTextFrame: C3DTextFrameRef object is NULL, will create NULL mesh
Assertion '%s' failed. The set we are updating contains more elements than the number of positions we have in store, something it wrong (%d vs %d)
Unreachable code: Unknown manipulator action
Assertion '%s' failed. VDMC expects triangles
Warning: C3DIO(warn) _writeAnimationChannel: animation not supported - won't be exported
Error: can't find index of animated buffer component
Error: can't mix affine and matrices animations
Error: %@
Warning: _writeSource - shared source detected (not supported)
Warning: _writeSource - shared accessor detected (not supported)
Warning: _writeArrayWithWriterFunc: infinite double encountered
Warning: _writeArrayWithWriterFunc: infinite float encountered
Error: failed to generate a path for an image
Error: found a texture with no sampler
Warning: geometry is partially double sided - not supported at export
Warning: failed to find source of morph
Warning: invalid light map info - not exported
Error: too many blend states: max render target is %d
Warning: can't create a fbo description for pass %@ - can't find pass description with name %@
Assertion '%s' failed. C3DFXPassInitialize pass is already initialized
Error: failed to load program %@
Warning: Unable to find metal library named %@ in bundle %@
Warning: Technique for pass "%@" has a custom Metal library, but the "%@" fragment function is missing
Warning: Technique for pass "%@" has a custom Metal library, but the "%@" vertex function is missing
Warning: Technique for pass "%@" has a custom Metal library, but the "%@" and "%@" vertex and fragment functions are missing
Error: failed to load program %@ %@
Assertion '%s' failed. Unsuported shading language
Assertion '%s' failed. Sub technique should only have 1 pass
Assertion '%s' failed. unexpected error in C3DFXPassSetInputs
Assertion '%s' failed. unexpected error in C3DFXPassSetOutput
Error: unknown cull mode named %@
Error: unknown depth comparison function named %@
Error: unknown blend factor named %@
Error: unknown blend op named %@
Error: _bufferTypeFromName - unknown output type: %@
Warning: unknown depth texture format : %@
Warning: unknown texture format : %@
Assertion '%s' failed. attributes should have a semantic
Error: description for input named %@ is missing
Error: 'type' is required for symbol %@
Assertion '%s' failed. pass:_setupInput unexpected type
Warning: symbol named %@ should be in "targets" not "symbols"
Warning: _convertOutputsDescriptionToOutputs - can't find output named %@
Error: _convertOutputsDescriptionToOutputs - unknown output type: %@
Error: C3DRenderBufferGetSlotForOutputBufferType : unsupported type %d
Error: Could not find text resource named %@
Error: modifier without code is invalid
Error: unexpected value (%@)
Warning: SCNDefaultValueWithBaseType - unknwon base type %d
Error: unexpected returned value for property %@ of object %@
Error: can't generate implementation for property of type %d
Error: C3DConstraintApplyIK leef is not a child of root
Error: C3DConstraintApplyIK root and leaf nodes are the same node
Warning: unsupported ease out for contraint applied on base type %d
Error: C3DModelPathResolveCommonProfileProperty unknown path %@
Error: _C3DModelPathResolverRegistryResolvePathWithClassName unknown path %@
Unreachable code: Support for subscript model path is not implemented for %@
Assertion '%s' failed. Cannot register twice the same propertyName : %@
Error: _C3DModelPathResolveColor4 unknown path %@
Error: _C3DModelPathResolveCommonProfileTexture unknown path %@
Error: _C3DModelPathResolveMatrix unknown path %@
Error: _C3DModelPathResolveTransform unknown path %@
Error: _C3DModelPathResolveRotation unknown path %@
Error: _C3DModelPathResolveVector3 unknown path %@
Error: _C3DModelPathResolveVector4 unknown path %@
Assertion '%s' failed. _C3DModelPathResolveEntity inconsistent cftype
Error: _C3DModelPathResolveNode unknown path %@
Error: _C3DModelPathResolveDynamicParameter unknown path %@
Error: _C3DModelPathResolveCommonProfile unknown path %@
Error: _C3DModelPathResolveMorpher unknown path %@
Error: _C3DModelPathResolveMorpher unknown key subscript %@[%ld]
Error: _C3DModelPathResolveMorpher unknown key subscript %@[%@]
Warning: _C3DCreateAnimationTargetFromPath: can't resolve a path (null model)
Warning: _C3DCreateAnimationTargetFromPath: can't resolve a path
Error: Too many properties added to this ParticleSystem
Error: Cannot animate this particle semantic : %@
Error: Try to parametrize with a variable property not present : %@
Error: Unknown controller mode : %@
Error: Try to set a controller on a property not present : %@
Assertion '%s' failed. C3DModelValueStorageUpdateModelValueFromPresentationValue - unexpected class
Unreachable code: attempt to copy SCNConstraint that is a virtual class
Assertion '%s' failed. C3DAnimationEventsAddEvent - index out of bounds
Assertion '%s' failed. _C3DAnimationEventsTriggerEventsWithTimeChanges invalid time
Assertion '%s' failed. _C3DAnimationEventsTriggerEventAtIndex - index out of bounds
Assertion '%s' failed. RendererElement should not be in span already
Assertion '%s' failed. C3DRendererElementStoreDeallocateSpan - null span
Assertion '%s' failed. C3DRendererElementStoreDeallocateSpanForNodeGeometryLOD unexpected lod count
Assertion '%s' failed. wrong index in rendererElements span
Assertion '%s' failed. __AllocateSpansForNodeGeometryLOD unexpected lod count
Error: indexstore::_getNextFreeIndex - no more free index
Assertion '%s' failed. C3DIndexStoreGetOrderedIndexForKey index out of bounds
Error: Can't add dependency %s on %s
Error: Output buffer parameters for port %d isn't compatible with input port %d
Error: Output descriptor of pass %s at port %d: %s
Error: Input descriptor of pass %s at port %d: %s
Assertion '%s' failed. Pass %s has specific viewport but it's not specified for index : %d
Unreachable code: Layered rendering is lacking a multiple output vertex streams generator
Unreachable code: Multi-viewport rendering is lacking a multiple output vertex streams generator
Unreachable code: Invalid buffer type: %hhu
Assertion '%s' failed. Invalid sample count
Assertion '%s' failed. _graphDescription is nil
Assertion '%s' failed. Attachment ID not set for %s
Assertion '%s' failed. Mismatch between resource type and resource description type, forgot useInternally ?
Assertion '%s' failed. Missing output at index %d for stage %d
Assertion '%s' failed. Trying to add NULL pass
Assertion '%s' failed. Buffer pool allocator failed, buffer is NULL
Assertion '%s' failed. Texture pool allocator failed, texture is NULL
Assertion '%s' failed. Only color attachement can use drawable texture
Assertion '%s' failed. Depth resolved texture must have sample count 0 or 1
Assertion '%s' failed. Depth resolve texture type must not be multisampled
Assertion '%s' failed. Can't find first stage, all nodes have inputs.
Error: ** Cycle detected ** involving pass %s and input pass %s
Error: Pass %s has an unresolved dependency on input port %d with pass %s. Pass %s will be ignored
Error: Pass %s has an unresolved dependency from output port %d of pass %s. Pass %s will be ignored
Error: Pass %s has an unresolved dependency with pass %s. Pass %s will be ignored
Error: Pass %s is not linked to the rendering graph and will be ignored check it's input/output
Error: ReadWrite pass %s require input %zu:%s with load mode set to "Load", forcing it.
Error: ReadWrite pass %s must have compatible input/output.
Error: Input %s doesn't match output %s.
Assertion '%s' failed. Invalid pass
Error: Unresolved dependency between %s and %s
Assertion '%s' failed. Unresolved dependency
Error: Invalid output texture sampleCount %d for pass %s %d:%s, if no multisample needed, set it to 0
Assertion '%s' failed. Invalid pass parameter
Error: Invalid input texture sampleCount %d for pass %s %d:%s, if no multisample needed, set it to 0
Error: Invalid output parameter for pass %s
Error: Invalid output parameters for port %d: %s
Error: Invalid input parameter for pass %s
Error: Buffer input parameters for port %d: %s
Error: Compatibility mismatch between %s and %s
Assertion '%s' failed. Incompatible passes
Assertion '%s' failed. Multiple dependencies on the same input %zu on %s
Assertion '%s' failed. Unable to resolve dependency between %s and %s
Error: ReadWrite pass %s can't be the present on first stage since it will load it's input.
Assertion '%s' failed. Can't dispatch input to output with multiple output without a named input.
Assertion '%s' failed. Can't dispatch input to output, unable to find output named %s.
Assertion '%s' failed. Can't dispatchToOutput to output of different type
Assertion '%s' failed. Invalid used count for pass internal resource
Assertion '%s' failed. Invalid resource, texture is NULL
Assertion '%s' failed. Invalid resource, buffer is NULL
Assertion '%s' failed. Pass output resources should be allocated
Assertion '%s' failed. Readwrite pass %s has an initialised output at index %d:%s should be null
Assertion '%s' failed. Readwrite pass %s has an uninitialised input at index %d:%s should be null
Assertion '%s' failed. node output resource should match destination node input resource
Assertion '%s' failed. Pass %s resource at index %d:%s should not be tagged as "usedInternally"
Error: Resource allocated for output index %d:%s but resource is tagged as "used internally"
Unreachable code: 
Error: Dependency issue between source %s[%d]:%s and destination %s[%d]:%s
Error: Types mismatch %s <-> %s
Error: Texture width mismatch %hu <-> %hu
Error: Texture height mismatch %hu <-> %hu
Error: Texture depth mismatch %hu <-> %hu
Error: Texture type mismatch %@ <-> %@
Error: Texture storage mode mismatch %@ <-> %@
Error: Texture CPU cache mode mismatch %@ <-> %@
Error: Texture pixel format mismatch %@ <-> %@
Error: Texture mipmap count mismatch %d <-> %d
Error: Buffers have different length %lu <-> %lu
Info: |%s%s|width|height|depth|        pixelFormat      |arrayLength|storageMode|usage|cpuCacheMo|mipmapCount|sampleCount|usedForRes|         textureType      |
Info: |%s%s|%5d|%6d|%5d|%25s|%11d|%11d|%5d|%10d|%11d|%11d|%10d|%26s|
Info: |%s%slength : %lu
Info: |%stype : INVALID
Info: |%s%s|type|clearColor R|   G|   B|   A|attachmentType|loadMode|dispatchToOutput|usedInternally|registerTexture|registerResolveT|specificClearCol|readWrite|persistent|
Info: |%s%s|%4hhu|%12.1f|%4.1f|%4.1f|%4.1f|%14hhu|%8hhu|%16d|%14d|%15d|%16d|%16d|%9d|%10d|
Info: ###########################################################################################################
Info: ################################################ NEW FRAME ################################################
Info: ###########################################################################################################
Info: ######################################## STAGE %d ########################################
Info: |---------------------------  %s ---------------------------
Info: |---- %d INPUTS ---- 
Info: |-> %s ( %s )
Info: |
Info: |---- %d OUTPUTS ---- 
Info: |----------------------------%s----------------------------
Info: 
Info: 
Unreachable code: Vertex amplification shouldn't be active
Assertion '%s' failed. pop_back() on empty Array.
Assertion '%s' failed. Array capacity inconsistency
Error: ParticleSystem: mismatch in meshes and meshElements
Assertion '%s' failed. C3DTransformGetValue offset out of bounds
Error: C3DTransformGetValue - unexpected semantic
Assertion '%s' failed. C3DTransformSetValue unexpected size
Error: C3DTransformSetValue unexptected component index %d
Error: C3DTransformSetValue - unexpected semantic
Assertion '%s' failed. C3DTransformSetValue offset out of bounds
Assertion '%s' failed. _updateMatrix - no valid rep
Assertion '%s' failed. _updateMatrix - already valid
Assertion '%s' failed. _updateAffine - no valid rep
Assertion '%s' failed. _updateAffine - already valid
Assertion '%s' failed. _updateAffineScale - no valid rep
Assertion '%s' failed. _updateAffineScale - already valid
Assertion '%s' failed. _updateAffineRotation - no valid rep
Assertion '%s' failed. _updateAffineRotation - already valid
Error: C3DAllocatorDelete - unknown address
Assertion '%s' failed. C3DAnimatableParamControllerGetParamDescription - address out of bounds
Error: C3DProgramHashCodeStoreRegisterProgramForRendererElement - index out of capacity (%d > %d)
Assertion '%s' failed. C3DProgramHashCodeStoreRegisterProgramForRendererElement - programIndex out of uint32_t. will crash soon
Error: technique should not be null
Assertion '%s' failed. Invalid point of view
Unreachable code: Unsupported configuration
Assertion '%s' failed. Multiple viewport is for stero only
Assertion '%s' failed. leaking culling data
Error: type for key %@ is switching from %@ to %@, this will lead to improper animation
Error: %@ failed to create a library with error %@
Error: %@ can't provide a library for %@
Error: %@ can't provide a library hash
Assertion '%s' failed. Must call -[SCNShadableHelper ownerWillDie] before releasing it !
Error: Cannot use a program because shader modifiers are set
Error: ShaderModifiers - unkwnown supporting class '%@'
Error: Cannot use shader modifiers because a program is set
Warning: _updateC3DProgramInput can't find input named %@
Error: ShaderModifiers - unkwnown entrypoint '%@'
Assertion '%s' failed. index out of bounds
Unreachable code: CATextAlignmentModeFromC3DTextAlignmentMode unknown mode
Warning: Unknown alignment mode %@
Warning: Unknown truncation mode %@
Error: Could not load UsdKit
Assertion '%s' failed. Internal consistency error - unexpected sparse moprh target
Assertion '%s' failed. Vertex buffer has not been completely written to
Assertion '%s' failed. Sparse indices buffer has not been completely written to
Unreachable code: Unsupported index size for compute kernel
Unreachable code: Unsupported morph kind
Assertion '%s' failed. Buffer has not been completely written to
Assertion '%s' failed. renderStartIndex is not taken into account in this pass
Assertion '%s' failed. Type mismatch
Assertion '%s' failed. uniform %@ already set
Error: DOF pass: no point of view
Error: DOF pass: no camera
Unreachable code: SCNSceneDatabase is supposed to be unarchived with a SCNKeyedUnarchiver and a lookUpName set
Unreachable code: Could not find deformer class associated to meshless geometry
Assertion '%s' failed. Meshless deformers do not support deforming normals
Assertion '%s' failed. Meshless deformers do not support deforming tangents
Assertion '%s' failed. buffer overflow
Unreachable code: Can't create an interleaved buffer for the renderable topology, possible vector count mismatch between semantics
Assertion '%s' failed. Transform of dependency node is not available
Assertion '%s' failed. Frustum info for dependency node is not available
Assertion '%s' failed. Deformer stack failed to find buffer for shader argument "%@"
Unreachable code: Unsupported input
Unreachable code: Not implemented
softlink:r:path:/System/Library/Frameworks/ModelIO.framework/ModelIO
Textures
SCNMonitor
SCNTypeInspector
NSOutlineViewDataSource
NSObject
NSOutlineViewDelegate
NSControlTextEditingDelegate
SCNActionRepeat
SCNActionFade
SCNPrecomputedLightingEnvironment
NSSecureCoding
NSCoding
SCNMaterialPropertyPrivate_PrecomputedLightingEnvironment
MTLTexture
MTLResource
MTLAllocation
SCNWeakPointer
SCNBezierCurveGeometry
SCNMTLTessellator
SCNLowLatencyMetalLayer
SCNMetalBackingLayer
SCNBackingLayer
///'@
SCNActionPlaySound
SCNMTLBezierCurveDeformer
SCNMTLMeshlessDeformer
SCNMTLDeformer
SCNUIImagePicker
SCNActionSequence
SCNKeyedUnarchiver
SCNKeyedArchiver
C3DBinding
SCNCommonProfileProgramGeneratorMetal
C3DAnimationBinding
SCNAuthoringEnvironment
SCNPhysicsCharacter
SCNMTLRenderContext
SCNBufferStream
SCNActionJavaScript
SCNParticleSystem
NSCopying
SCNAnimatable
SCNRendererOptionsPanelController
SCNPhysicsWorld
SCNTransactionCommandObject
SCNMTLOpenSubdivComputeEvaluator
OpenSubdiv
SCN_DisplayLinkExtensions
SCNDisplayLinkARC
SCNRenderTarget
SCNLayer
SCNSceneRenderer
SCNTechniqueSupport
SCNRendererOptionsPanel
SCN_NSImageFromSlotContents
SCNCommonProfileProgramCache
SCNCommonProfileProgramGenerator
SCNSceneLoaderProtocol
SCNPhysicsBehavior
SCNManipulableItem
SCNNodeManipulableItem
SCNExtensions
SCNJitterer
SCNModelIO
MDLMorphDeformerComponent
MDLComponent
MDLSkinDeformerComponent
SceneKitAdditions
SCNTechniquePanelController
SCNRenderTargetView
SCNActionRunBlock
SCNReferenceNode
SCNNodeReference
SCNAnimationReference
SCNActionReference
SCNMetalLayer
SCNUIProperty
SCN_NSImageFromImageValue
SCNUID_ConstantTransformer
SCNUID_NumberTransformer
SCNUIDynamicInspector
SCNPhysicsConeTwistJoint
SCNParticlePropertyController
SCNAVPlayerSource
SCNCaptureDeviceSource
AVCaptureVideoDataOutputSampleBufferDelegate
SCNCaptureDeviceOutputConsumerSource
SCNCaptureDeviceOutputConsumer
SCNActionCustom
SCNActionWait
SCNActionRemove
SCNCamera
SCNAdditions
Core3DKitAdditions
SCNLight
SCNMaterial
SCNShadable
SCNNode
SCNActionable
SCNBoundingVolume
Transforms
SIMD
SCNScene
SCNTextureSource
SCNImageSource
SCNTextureOffscreenRenderingSource
SCNSourceRendererRegistry
SCNDelegateSource
SCNTextureDelegateSource
SCNGeometryWrapDeformerParameters
SCNGeometryWrapDeformer
SCNGeometryWrapDeformerInstance
SCNGeometryDeformerInstance
SCNActionPerformSelector
SCNUtils
SCNView
SCNPhysicsVehicleWheel
SCNMTLRenderContextSceneRendererMainPassCustomPostProcessHelper
_SCNSceneRendererMainPassCustomPostProcessHelper
SCNActionScale
SCNAction
Internal
SCNActionTargetState
SCNNodeComponent
SCNNodeWeakComponent
SCNRendererViewPoint
SCNRendererTransitionContext
MTLDevice
SCNRenderer
SCNMTLRenderContextCommandBufferStatusMonitor
SCNMTLRenderContextResourceManagerMonitor
SCNOffscreenRenderer
SCNAddition
SCNStatisticsProvider
SCNMTLBuffer
SCNMTLResourceBinding
SCNMTLSemanticResourceBinding
SCNMTLPassResourceBinding
SCNMTLShadable
SCNMTLRenderPipeline
SCNMTLComputePipeline
SCNMTLMesh
SCNMTLMeshElement
SCNPhysicsSliderJoint
SCNActionMove
SCNDeepCopy
SCNOrderedDictionary
SCNRecursiveLock
SCNGeometryVariableTopologySampleDeformer
SCNGeometryVariableTopologySampleDeformerMeshElementData
SCNGeometryVariableTopologySampleDeformerInstance
SCN_CAKeyframeAnimation
SCNAnimationEvent
SCNTimingFunction
SCNAnimation
SCNAnimationPlayer
SCNSceneSource
NSKeyedUnarchiverDelegate
SCNHitTestResult
SCNMaterialAttachment
SCNMaterialPropertyTextureProvider
SCNMaterialProperty
SCNFloor
SCNMTLSmoothNormalsDeformer
SCNPhysicsVehicle
SCNGeometry
SCNMutableGeometry
SCNSpriteKitEventHandler
SCNCameraController
SCNAuthoringEnvironment2
SCNMTLLibrary
3$0"0 0
SCNMTLLibraryManager
SCNCommonProfileProgramGeneratorGL
SCNMaterialPropertyTextureProviderSource
SCNMaterialPropertyTextureProviderHelper
SCNActionHide
SCNUIScrubberCell
SCNUIScrubber
SCNSkinner
C3DIONSZipFileArchive
SCN_DTAdditions
SCNMTLShadableKey
SCNMetalWireframeResource
MTLBuffer
SCNMTLResourceManager
SCNAudioPlayer
SCNAudioSource
SCNPhysicsContact
SCNPhysicsBody
SCNPlane
SCNBox
SCNPyramid
SCNSphere
SCNCylinder
SCNCone
SCNTube
SCNCapsule
SCNTorus
SCNSpriteKitSource
SCNTextureSpriteKitSource
SCNDisplayLink
SCNTechniquePanel
SCNActionRotate
SCNUISceneGraphView
SCNActionGroup
SCNPhysicsShape
1$0"0 0 0/$6
6%0"0 0 0/$6
3$0"0 0 0/$6
Compilation
SCNUIArrayEditor
SCNUIArrayEditorController
SCNUIHandleButton
SCNUIColorWell
SCNUIBindableView
SCNUIVector4TextField
SCNUIMatrix4TextField
SCNUIVector3TextField
SCNUIVector2TextField
SCNUIPopUpButton
SCNGeometryTessellator
SCNGeometryDeformer
C3DEngineNotificationQueueTransientWrapper
SCNPhysicsBallSocketJoint
SCNPhysicsField
SCNPhysicsLinearGravityField
SCNPhysicsRadialGravityField
SCNPhysicsSpringField
SCNPhysicsMagneticField
SCNPhysicsElectricField
SCNPhysicsDragField
SCNPhysicsCustomField
SCNPhysicsVortexField
SCNPhysicsNoiseField
SCNPhysicsTurbulenceField
_C3DProgressDebugger
SCNTechnique
SCNPassContext
SCNPass
SCNMorpher
SCNMTLBufferAllocatorSubBuffer
SCNFixedSizePage
SCNMTLBufferAllocator
SCNJSLayerJSExport
JSExport
SCN_JSSupport
SCNJSImageJSExport
SCNJSImage
SCNJSValueSExport
SCNJSValue
SCNJSExtensions
SCNJSValueTmpImp
SCNMaterialPropertyJSExport
SCNBoundingBoxJSExport
SCNBoundingSphereJSExport
SCNTransactionJSExport
SCNColorJSExport
SCNJSBasicAnimationJSExport
SCNJSAnimationGroupJSExport
SCNJSKeyframeAnimationJSExport
SCNViewJSExport
SCNMetalLayerJSExport
SCNPhysicsBehaviorJSExport
SCNParticlePropertyControllerJSExport
SCNPhysicsHingeJointJSExport
SCNPhysicsContactJSExport
SCNProgramJSExport
SCNTorusJSExport
SCNMorpherJSExport
SCNCapsuleJSExport
SCNLevelOfDetailJSExport
SCNRendererJSExport
SCNCylinderJSExport
SCNFloorJSExport
SCNNodeJSExport
SCNPlaneJSExport
SCNPhysicsBallSocketJointJSExport
SCNConeJSExport
SCNSphereJSExport
SCNGeometryJSExport
SCNConstraintJSExport
SCNPhysicsSliderJointJSExport
SCNLightJSExport
SCNMaterialJSExport
SCNParticleSystemJSExport
SCNHitTestResultJSExport
SCNTubeJSExport
SCNLookAtConstraintJSExport
SCNPhysicsShapeJSExport
SCNGeometryElementJSExport
SCNGeometrySourceJSExport
SCNShapeJSExport
SCNSceneSourceJSExport
SCNPyramidJSExport
SCNCameraJSExport
SCNIKConstraintJSExport
SCNTechniqueJSExport
SCNPhysicsWorldJSExport
SCNPhysicsBodyJSExport
SCNBoxJSExport
SCNTransformConstraintJSExport
SCNAnimationEventJSExport
SCNActionJSExport
SCNSceneJSExport
SCNPhysicsVehicleJSExport
SCNPhysicsVehicleWheelJSExport
SCNPhysicsFieldJSExport
SCNTextJSExport
SCNJSMediaTimingFunctionJSExport
SCNCoreAnimationSource
SCNTextureCoreAnimationSource
SCNMTLSkinDeformerReadOnlyBuffers
SCNMTLSkinDeformer
SCNBoundingBox
SCNBoundingSphere
SCNTransaction
SCNGeometrySource
SCNMutableGeometrySource
SCNGeometryElement
SCN3DConnexionDevice
SCNEventHandler
SCNCameraControlEventHandler
SCNCameraNavigationController
SCNCameraControlConfiguration
SCNCameraControllerDelegate
SCNUIDynamicInspectorConfiguration
SCNUIDynamicUI
SCNMTLArgumentBinder
SCNMTLShaderBindingsGenerator
SCNMovieExport
SCNExportAddition
SCNExportOperation
_SCNExportOperation
SCNMovieExportOperation
SCNCOLLADAExportOperation
SCNManipulator
SCNGeometryVDMCDeformer
SCNGeometryVDMCDeformerMeshElementData
SCNGeometryVDMCDeformerInstance
SCNActionRunAction
SCNConstraint
SCNLookAtConstraint
SCNDistanceConstraint
SCNReplicatorConstraint
SCNAccelerationConstraint
SCNSliderConstraint
SCNAvoidOccluderConstraint
SCNBillboardConstraint
SCNConstantScaleConstraint
SCNTransformConstraint
SCNIKJoint
SCNIKConstraint
/////////$2@
SCNBufferBinding
SCNProgramSemanticInfo
SCNProgram
SCNMetalLibraryProvider
SCNShadableHelper
_SCNShadableCompilationIssue
SCNText
USKHelper
USKToken_helper
USKObjectPath_helper
USKData_helper
SCNMTLMorphDeformer
SCNShape
SCNPhysicsHingeJoint
SCNLevelOfDetail
SCNAssetCatalogCacheEntry
SCNAssetCatalog
SCNSceneDatabase
SCNSceneLookUpUnarchiver
SCNMTLDeformerStack
SCNMTLDeformerInitComputeContext
SCNMTLDeformerUpdateComputeContext
SCNGeometryDeformerInstanceWrapper
SCNGeometryDeformerInitComputeContext
SCNGeometryDeformerUpdateComputeContext
CGColor
.cxx_destruct
MTLTextureCache
CGContext
SCNUI_unbindAll
CGLContext
SCNVector4Value
CGLPixelFormatObj
T@"<MTLBlitCommandEncoder>",R,N
GPUEndTime
T@"<SCNNodeRendererDelegate>",N
IDsOfEntriesWithClass:
T@"AVAudioNode",R,N,V_audioNode
JSONObjectWithData:options:error:
T@"MTLRenderPassDescriptor",R,N
NSSize
T@"NSArray",C,N
SCNJSExportProtocol
T@"NSColor",&,N
SCNPixelsHigh
T@"NSData",&,N,V_irradianceData
SCNUID_additionalProperties
T@"SCNNode",&,N
SCNUID_constantToStringForProperty:
T@"SCNNode",W,N
SCNUID_enumForProperty:
T@"SKScene",&,N
SCNUID_propertiesToFilterOut
T@,W,N,VweakRef
SCNUID_rangeForFloatProperty:min:max:
T@?,C,N
SCNUI_name
TQ,N,V_freeAxes
SCN_arrayWithSimdMatrix4:
Tc,N,GisEnabled
SCN_evaluateAtTime:reverse:to:
Tc,N,GisWrapped
SCN_setupDisplayLinkWithQueue:screen:policy:
Tc,N,V_readonly
SCN_valueWithCGPoint:
Tc,N,VusesEuler
T#,&,N,VobjectClass
Td,N,Vtimestamp
T,R,N
Tq,N,VmaterialModificationCount
T:,N,Vaction
T@"<MTLBuffer>",&,N,V_buffer
T@"<MTLBuffer>",R,N
T@"<MTLCommandBuffer>",R,N
__light
T@"<MTLComputeCommandEncoder>",R,N
__openGLContext
T@"<MTLDevice>",R,N
_action
T@"<MTLFunction>",&,N,V_vertexFunction
_aether
T@"<MTLLibrary>",R,N,V_library
_allSymbolsWithSceneKitSemantic
T@"<MTLRenderPipelineState>",&,N,V_state
_allowsCreation
T@"<MTLTexture>",R
_animationSpeed
T@"<SCNAuthoringEnvironmentDelegate>",N,V_delegate
_applyOverrides
T@"<SCNCameraControlConfiguration>",R,N
_availableCompiledLibrariesLock
T@"<SCNCameraNavigationControllerDelegate>",N,V_delegate
_bindingAdaptor
T@"<SCNPhysicsContactDelegate>",W
_bloomIntensity
T@"<SCNSceneRenderer>",R
_bloomThreshold
T@"<SCNShadable>",R,N,V_shadable
_buffer
T@"AVAudioEnvironmentNode",R,N
_cachedContents
T@"AVCaptureDevice",&,N
_cameraGeometry
T@"CAAnimation",&,N
_cgPath
T@"CAMediaTimingFunction",&
_charge
T@"MDLAnimatedScalarArray",R,N
_commandBufferCompletedHandlers
T@"MTLArgument",&,N,V_argument
_componentCount
T@"MTLVertexDescriptor",C,N,V_vertexDescriptor
_currentInitResourceBlitEncoder
T@"NSArray",C
_customSlotName
T@"NSArray",C,N,V_lightBufferBindings
_cylinderradius
T@"NSArray",C,N,V_passBufferBindings
_defaultLibrary
T@"NSArray",R
_defaultTexture
T@"NSButton",&,N,Vadd
_deindexedToOriginalTableBuffer
T@"NSData",&,N,V_radianceData
_didEndSelector
T@"NSData",R,C,N
_didTriggerRedrawWhileRendering
T@"NSDictionary",&,N,V_attributes
_drawShadowMaps
T@"NSDictionary",&,N,V_options
_enumerateChildNodesUsingBlock:
T@"NSDictionary",&,N,Voptions
_exposureOffset
T@"NSDictionary",C,N
_fadeInDuration
T@"NSDictionary",R
_filterCallback
T@"NSError",&,N,V_error
_fogEndDistance
T@"NSMutableArray",R,N
_frozen
T@"NSNumber",&,N
_geometryLoaded
T@"NSObjectController",W,N,V_objectController
_gimbalLockMode
T@"NSOpenGLContext",&,N,V_sourceContext
_grainIntensity
T@"NSOrderedSet",&,N
_handle
T@"NSString",&,N,V_lookUpKey
_hidden
T@"NSString",&,N,VkeyPathSrc
_inertiaRunning
T@"NSString",?,R,C
_innerLayerNode
T@"NSString",C,N
_installContext
T@"NSString",C,N,V_semantic
_irradianceData
T@"NSString",C,N,VreferenceSceneName
_isFocusableOrHasFocusableChild
T@"NSString",R,C
_isolateProgram
T@"NSString",R,N,V_effectiveModifier
_legacyUniforms
T@"NSString",R,N,V_message
_levelsOfDetail
T@"NSURL",&,N
_loadSourceCode
T@"NSURL",&,N,V_outputURL
_mappingChannel
T@"NSURL",R
_nextUpdateDate
T@"NSURL",R,N,V_catalogURL
_normal
T@"SCNAnimation",R,N,V_animation
_offset
T@"SCNAudioSource",R,N,V_audioSource
_opaque
T@"SCNCamera",&,N
_outerBindingSpaceVectorsBuffer
T@"SCNCameraController",R,N,V_cameraController
_owners
T@"SCNGeometry",R
_parent
T@"SCNGeometrySource",&,N
_particleCharge
T@"SCNGeometryTessellator",&,N
_passDescriptor
T@"SCNLight",R,N
_paused
T@"SCNManipulator",R,N
_player
T@"SCNMaterial",R,N
_positionBuffer
T@"SCNMorpher",&,N
_primitiveCount
T@"SCNNode",&,N,V_outgoingPointOfView
_referenceCount
T@"SCNNode",&,N,Vnode
_renderableCopy
T@"SCNNode",N,Vjoint
_renderingQueue
T@"SCNNode",R,N,V_freeViewCameraNode
_replicateScale
T@"SCNNodeComponent",&,N,Vnext
_runOnSubSprite
T@"SCNPhysicsBody",&,N
_scenes
T@"SCNPhysicsField",&,N
_selectRenderingAPIWithOptions:
T@"SCNPhysicsWorld",R,N
_setImagePath:withResolvedPath:
T@"SCNProgram",?,&,N
_setSurfaceBackedOpenGLContext:
T@"SCNScene",&,N
_setWheelIndex:
T@"SCNScene",&,N,V_scene
_showStatistics
T@"SCNTechnique",C,N
_snapToAlignOnY
T@"SCNView",&
_source
T@"SCNView",N,V_parentView
_spheregeodesic
T@"SCNView",R
_spotOuterAngle
T@"SKTransition",&,N,V_transition
_statisticsInfo
T@,&,N
_subdivPipeline
T@,&,N,V_lookUpFoundInstance
_syncObjCModel:
T@,&,N,Vcomponent
_targetDistance
T@,&,N,VrepresentedObject
_timingFunction
T@,&,N,Vtarget
_translateInCameraSpaceByX:Y:Z:
T@,C,N,V_bindBlock
_tuberadialSpan
T@,N,V_dataSource
_update
T@,R,N,V_referenceObject
_updateMaterialTextureProvider:
T@,W,N,Vdelegate
_userAttributes
T@,W,N,Vtarget
_velocityFactor
T@?,C,N,VwillStartPlayback
_vertexSamplers
TC,R,N
_volatileBuffer
TI,N,Vtarget
_wantsWideGamut
TI,R,N
_weight
_windowOcclusionStateDidChange:
TQ,N
_zArrow
TQ,N,V_offset
TQ,R
actions
TQ,R,N,V_bufferSize
addAudioPlayer:
TQ,R,N,V_type
allKeys
T^v,N,Vcontext
anchorA
T^{CGPath=}
angularVelocity
T^{SCNMTLComputeCommandEncoder=[31@][31Q][128@][16@]@@@^{SCNMTLBufferPool}I[2Q][1Q]},R,N
animationNamed:
T^{__IOSurface=},R
areaLightPrecomputedDataTexture
Tc,?,R
attributeNamed:
Tc,GisCumulative
Tc,GisRemovedOnCompletion
backgroundColor
Tc,N,GisActive
bloomBlurRadius
Tc,N,GisAdditive
bundleForClass:
Tc,N,GisAppliedOnCompletion
caction
Tc,N,GisCumulative
cameraDidChange
Tc,N,GisExclusive
canJump
Tc,N,GisHemispheric
capSegmentCount
Tc,N,GisIncremental
channelEncoding
Tc,N,GisLightingEnabled
clearCoatNormal
Tc,N,GisLocal
clickedPathItem
Tc,N,GisPaused
commitImmediate
Tc,N,GisRemovedOnCompletion
compressionType
Tc,N,GisTemporalAntialiasingEnabled
conformsToType:
Tc,N,V_autoSwitchToFreeCamera
contactDelegate
Tc,N,V_enableFreeCamera
containsString:
Tc,N,V_loops
context
Tc,N,V_shouldSnapToAlign
copyTo:
Tc,N,V_surroundToSelect
currentViewport
Tc,N,Vreadonly
customFieldWithEvaluationBlock:
Tc,R
dataWithDouble:
Tc,R,GareProgrammableSamplePositionsSupported
dataWithString:
Tc,R,GisDepth24Stencil8PixelFormatSupported
delegateWillDie
Tc,R,GisHeadless
didModifyRange:
Tc,R,GisLowPower
disableOverlays
Tc,R,GisShareable
dollyBy:onScreenPoint:viewport:
Tc,R,N,GhasInterleavedIndicesChannels
edgeCreaseCount
Tc,R,V_customAudioNode
enabled
enqueue
Td,N,V_continuousCollisionDetectionThreshold
evaluateScript:
Td,N,V_flyModeVelocity
falloffExponent
Td,N,V_rotationSensitivity
filters
Td,N,V_transitionStartTime
flyModeVelocity
Td,N,VmaxAllowedRotationAngle
framebufferOnly
Td,R
Td,R,N,V_gridUnit
geometrySources
Tf,N
getReturnValue:
Tf,N,Vrate
hasGobo
Tf,N,Vvolume
inBetweenCounts
Ti,R,N
influenceFactor
Tq,N
initTransformInWorld:withBlock:
Tq,N,V_frequency
initWithDevice:
Tq,N,V_loadingPolicy
initWithDrivingNode:parameters:
Tq,N,V_timeStamp
initWithLength:
Tq,N,V_yAlignment
initWithRenderer:sharedContext:
Tq,N,VbufferSize
initWithSource:
Tq,N,VsemanticsCount
initWithTarget:
Tq,R
interactionMode
Tq,R,N,V_line
isBaked
T{?=CCCC},R,N
isGizmo
T{?=[4]},N
isLocal
T{?=dddddd},N
isProxy
T{CATransform3D=dddddddddddddddd},N
isValid
T{CATransform3D=dddddddddddddddd},N,V_viewMatrix
isolate
T{CATransform3D=dddddddddddddddd},R,N
keyPath
T{CGRect={CGPoint=dd}{CGSize=dd}},N
latlongTextureForCubemap:pixelFormat:renderContext:needsMipmap:
T{CGSize=dd}
library
T{CGSize=dd},N,V_size
libraryProvider
T{CGSize=dd},R,N
localUp
T{SCNVector3=ddd}
lookAt:
T{SCNVector3=ddd},N,Vcenter
manipulatorNode
T{SCNVector3=ddd},N,Vmax
materialWithMDLMaterial:option:
T{SCNVector3=ddd},N,Vposition
T{SCNVector3=ddd},R
maxTransferRate
T{SCNVector4=dddd},N
maximumExposure
T{SCNVector4=dddd},R
message
URLByAppendingPathComponent:
minimumDistance
URLByDeletingLastPathComponent
momentOfInertia
URLByResolvingSymlinksInPath
moveToPosition:
URLForDirectory:inDomain:appropriateForURL:create:error:
newCommandQueue
URLForResource:withExtension:subdirectory:
newComputePipelineStateWithFunctionName:library:constantValues:
URLValue
newIndirectCommandBufferWithDescriptor:maxCommandCount:options:
UTF8String
newRenderPipelineStateWithDescriptor:options:completionHandler:
UUIDString
nodeRef
_IESProfileURL
numberWithChar:
__allocateContentTransformIfNeeded
objectInParticleSystemsAtIndex:
__aspectRatio
opacity
__createCFObject
options
__drawableSafeAreaInsets
outlineView:didDragTableColumn:
__geometry
outlineView:toolTipForCell:rect:tableColumn:item:mouseLocation:
__ibSceneName
particleSystems
__morpher
playing
__preparePixelFormat
present
__removeAnimation:forKey:
primitiveRanges
__renderLayer:withCARenderer:engineContext:viewport:atTime:forceUpdate:didUpdate:
profile
__renderSKScene:withSKSCNRenderer:engineContext:viewport:atTime:
programHashCode
__runtimeResolvedPath
pushDebugGroup:
__shadableHelper
__updateMutableMesh:withMetalMesh:
recycle
__updateTextureWithLayer:texture:engineContext:sampler:
reflectionResolutionScaleFactor
__viewport
remove:
_acceleration
removeBehavior:
_actionData
removeObserver:
_actions
render:
_activeBehaviors
rendererContext
_adaptativeEndFrame
rendererWithCGLContext:options:
_adaptativeState0
replicatesScale
_adaptive
representations
_addGPUFrameCompletedHandler:
reshape
_addGPUFrameScheduledHandler:
restart
_addToPhysicsWorld:definition:
rollingFriction
_adjustBackingLayerPixelFormat
runBlock:queue:
_affectedByGravity
sceneNamed:inDirectory:options:
_alignmentMode
sceneWithOptions:statusHandler:
_allocateElement
scrollingDeltaX
_allowDecodingCyclesInSecureMode
_allowGhostObjects
setAdditionalCompilerArguments:
_allowsResting
setAreaExtents:
_alternateMode
setAspectRatio:
_ambientOcclusion
setBlendFactor:
_angularVelocity
setBufferIndex:
_animation
setChamferMode:
_animationDidStop
setConstraints:
_animationPathForKey:
setCurrentTime:
_animations
setDisplayLink:
_appendFocusableNodesInRect:ofView:toFocusItems:
setDocumentURL:
_applyOnCompletion
setEulerAngles:
_applyUnsharing:alreadyShared:
setFloat2Value:
_arcHandleXY
setFloat4Value:
_arcHandleYZ
setForceAsyncShaderCompilation:
_arcball
setGeometryRef:
_areaLightPrecomputedDataTexture
setHemispheric:
_areaType
setIbSceneName:
_argument
setInnerRadius:
_arrayController
setInputsCount:
_arrowIndicesCount
setLitPerPixel:
_aspectRatio
setMaxVertexAmplificationCount:
_assetWriter
setNeedsDisplay
_assignComponent:toContainerWithType:
setObjectClass:
_associatedSCNNode
setOuterRadius:
_attenuationEndDistance
setPixelBuffer:
_attenuationStartDistance
setPointOfView:
_audioName
setRepeatCount:
_audioPlayer
setReverbBlend:
_audioURL
setSampleCount:
_authoringDisplayMask
setScaleOffset:
_authoringEnvironmentNode
setScissorRect:
_autoSwitchToFreeCamera
setScreenSpaceReflectionStride:
_automaticCameraTargetUpToDate
setSortingMode:
_automaticallyAdjustsShadowProjection
setStorageMode:
_automaticallyAdjustsZRange
setStringArray:
_avAdaptor
setTemperature:
_availableColorMatchingComputePipelines
setTessellator:
_availableComputePipelines
setVertexBuffer:offset:atIndex:
_availableDeformerStacks
set_bonesAndIndicesCompression:
_availableImageProxy
set_systemTime:
_availableIrradianceTextures
shadingLanguage
_availableLightingSystemReflectionProbeTextures
showsStatistics
_availableMeshSources
simdLocalNormal
_availableMorphDeformerReadOnlyBuffers
simdWorldNormal
_availablePipelineStates
skinner
_availableRadianceTextures
snapshotAtTime:
_availableSamplers
standardizedURL
_availableShadablesSearchKey
stringByAppendingPathExtension:
_availableStageDescriptors
stringFromByteCount:countStyle:
_availableWireframeMaterials
supportsMemorylessRenderTargets
_avoidsOverLighting
synchronizeTexture:slice:level:
_axle
targetDirection
_background2DProgram
texture
_backgroundCubeProgram
textureProvider
_backgroundRasterizerStates
timingFunctions
_backingLayer
torusWithRingRadius:pipeRadius:
_bakeNodes:folderPath:inVertex:bakeAO:quality:attenuation:geomSetter:terminateSetter:
typeOfProperty:
_bakeStochasticIrradianceTexture:forEnvironmentTexture:mipmapLevelForSampling:renderContext:
unlinkCustomPropertyWithParent:
_barycentricCoordsBuffer
update:
_baseGeometry
updateFieldNode:withSourceNode:
_baseNormalDataType
uppercaseString
_baseVertexCount
valueWithPoint:
_beginMouseMovedTracking
valueWithTransform3D:inContext:
_beginTranslateAtLocation:
vector3
_bezierCurveInfoBuffer
vertexArguments
_bindBlock
wakeUpAllBodies
_bindValueForSymbol:atLocation:programID:node:renderer:
weights
_bindingMode
wrapped
_bindingsGenerator
zoomBy:animate:
.cxx_construct
CGImage
CATransform3DValue
SCNMatrix4Value
CGImageForProposedRect:context:hints:
SCNVector3Value
CGLContextObj
CGPath
T@"<MTLHeap>",R
GPUStartTime
T@"<SCNPhysicsContactDelegate>"
IESProfileURL
T@"MTLRenderPassDescriptor",&,N
MTLTexture
T@"NSArray",&,N
SCNFixDPI
T@"NSArray",R,N
SCNMutableDeepCopy
T@"NSColor",C,N
SCNPixelsWide
T@"NSString",C,N,VreferenceName
SCNUID_classForElementOfArray:
T@"SCNNode",R,N
SCNUID_creationOptions
T@"SCNView",&,N
SCNUID_instanciateWithOption:
T@,N,V_delegate
SCNUID_propertyOrdering
SCNUID_viewForProperty:
T@?,C,N,V_block
SCN_CGPointValue
T^v,R,N
SCN_displayLinkCallback:
Tc,N,GisPlaying
SCN_safeHash
Tc,N,V_canceled
SCN_simdMatrix4Value
Tc,N,V_succeded
SCN_valueWithSimdMatrix4:
Td,N,V_progress
T#,R
Tq,N,VgeometryModificationCount
T:,N,V_didEndSelector
T{?=},N
T@"<MTLArgumentEncoder>",&,N,V_argumentEncoder
T@"<MTLBuffer>",R
T@"<MTLBuffer>",R,N,V_buffer
_3dView
T@"<MTLCommandQueue>",R,N
__nextFrameTime
T@"<MTLDevice>",R
__wantsSeparateGeometryElements
T@"<MTLFunction>",&,N,V_fragmentFunction
_active
T@"<MTLLibrary>",&,N
_affineUpToDate
T@"<MTLRenderCommandEncoder>",R,N
_allowHotReload
T@"<MTLResource>",R
_angularDamping
T@"<MTLTexture>",R,N
_animationsLock
T@"<SCNAvoidOccluderConstraintDelegate>",N
_argumentsNames
T@"<SCNCameraControllerDelegate>",N,V_delegate
_baseEntityName
T@"<SCNMaterialPropertyTextureProvider>",&,N
_birthDirection
T@"<SCNProgramDelegate>",N
_bloomIteration
T@"<SCNSceneRendererDelegate>",W,N
_bodies
T@"AVAudioEngine",R,N
_bufferBindings
T@"AVAudioPlayerNode",R,V_audioPlayer
_camera
T@"AVPlayer",&,N
_captureSession
T@"CALayer",&,N,V_layer
_chamferProfile
T@"CAMediaTimingFunction",C,N
_collisionShape
T@"MTLArchitecture",R
_commandBufferScheduledHandlers
T@"MTLStageInputOutputDescriptor",R,N
_copyImage:toTexture:desc:textureOptions:needsMipMapGeneration:
T@"NSArray",&,N,V_allTargetsFromAnimCodec
_custom
T@"NSArray",C,N,V_frameBufferBindings
_cylinderheight
T@"NSArray",C,N,V_nodeBufferBindings
T@"NSArray",C,N,V_shadableBufferBindings
_defaultProgram
T@"NSBezierPath",C,N
_deformDataKind
T@"NSButton",&,N,Vremove
_device
T@"NSData",R
_didMoveToView:
T@"NSData",R,N
_drawAtTimeLock
T@"NSDictionary",&,N,V_context
_encodeNodePropertiesWithCoder:
T@"NSDictionary",&,N,VconstantToString
_expand
T@"NSDictionary",?,C,N
_extrusionDepth
T@"NSDictionary",C,N,Voptions
_fields
T@"NSDictionary",R,N
_finishedExport
T@"NSFont",&,N
_fragmentShader
T@"NSMutableData",R,N
_fxPass
T@"NSNumber",?,&,N
_geometryShader
T@"NSOpenGLContext",&,N
_glTextureCache
T@"NSOpenGLPixelFormat",&,N
_grainIsColored
T@"NSPathControl",&,N,VstackControl
_height
T@"NSString",&,N,VkeyPathDst
_ignoreAnimationWhenCopying_tmp
T@"NSString",&,N,Vname
_innerBindingSpaceVectorsBuffer
T@"NSString",C
_inputs
T@"NSString",C,N,V_name
_installGLContextAndSetViewport
T@"NSString",C,N,VreferenceNodeName
_isDefaultShape
T@"NSString",R
_isInLiveResize
T@"NSString",R,N
_lastSystemTime
T@"NSString",R,N,V_entryPoint
_length
T@"NSTableView",&,N,Vtable
_libraryManager
T@"NSURL",&,N,V_documentURL
_loaded
T@"NSURL",C,N
_neighborBuffer
T@"NSURL",R,N
_noColorProgram
T@"NSValue",R,N,V_value
_normalTextInfo
T@"SCNAssetCatalog",&,N,V_assetCatalog
_onInertiaTimer
T@"SCNAuthoringEnvironment",R
_orange
T@"SCNCameraController",R,N
_outerLayerNode
T@"SCNGeometry",&,N
_panSensitivity
T@"SCNGeometryElement",&,N
_particleBounce
T@"SCNGeometrySource",R,N
_particleSystem
T@"SCNLight",&,N
_passes
T@"SCNMTLMesh",R,N
_physicsContact
T@"SCNMaterial",&,N
_pointOfCulling
T@"SCNMaterialProperty",R,N
_positionOffset
T@"SCNMorpher",R,N
_radius
T@"SCNNode",&,N,V_pointOfView
_renderPassDesc
T@"SCNNode",N
_renderingOrder
T@"SCNNode",R
_repeatedAction
T@"SCNNode",R,W,N
_result
T@"SCNParticleSystem",&,N
_samplerIndices
T@"SCNPhysicsBody",R,N
_script
T@"SCNPhysicsShape",&,N
_setAttributes:
T@"SCNProgram",&,N
_setQuaternion:
T@"SCNRenderer",&,N,V_renderer
_setTransforms:
T@"SCNScene",&,N,V_outgoingScene
_shadableHelper
T@"SCNSkinner",&,N
_snapToAlignOnX
T@"SCNTimingFunction",&,N
_snapToAlignOnZ
T@"SCNView",N
_sourceChannels
T@"SCNView",N,V_view
_spotInnerAngle
T@"SKScene",&,N,V_scene
_spreadingAngle
T@,&
_string
T@,&,N,V_delegate
_symbolToBinder
T@,&,N,V_texture
_target
T@,&,N,Vitem
_textureOptions
T@,&,N,VsourceObject
_transitionPass
T@,C,N
_truncationMode
T@,N
T@,R,N
_updateCorrectivesAndInBetween:
T@,W,N,Vcomponent
_updateRotation
T@,W,N,VmlDelegate
_valueForSymbol
T@?,C,N,VdidFinishPlayback
_vertexFunction
T@?,N
_vertexTextures
TI,N,VglID
_volatileMeshes
TI,R
_warmupDuration
TIFFRepresentation
_wheels
TQ,?,R
_yellow
TQ,N,V_antialiasingMode
_zFlags
TQ,N,VelementIndex
accessInstanceVariablesDirectly
TQ,R,N
TQ,R,N,V_elementSize
addUIForStringProperty:ofClass:
T^v,N,V_userInfo
ambient
T^{CGColorSpace=},R,N
anchorB
T^{CGPath=},R
animationEvents
T^{__C3DScene=},R,V_scene
archive:propertiesForEntryName:
argumentEncoder
Tc,GisAdditive
automaticTarget
Tc,GisPlaying
backFaceStencil
Tc,N
blendInDuration
Tc,N,GisAdaptive
Tc,N,GisAffectedByGravity
byValue
Tc,N,GisBlackPassEnabled
calculationMode
Tc,N,GisDoubleSided
canDraw
Tc,N,GisGeodesic
cancelSelection
Tc,N,GisHidden
categoryBitMask
Tc,N,GisJitteringEnabled
ciImage
Tc,N,GisLitPerPixel
clearInBetweens
Tc,N,GisOpaque
colorWithCalibratedWhite:alpha:
Tc,N,GisPositional,Vpositional
completionBlock
Tc,N,GisScreenSpace
computeFunction
Tc,N,GisVideoMirrored
connectToProxy:
Tc,N,V_automaticTarget
containsObject:
Tc,N,V_graphicalSelectionEnabled
content
Tc,N,V_shouldSnapOnGrid
control:textShouldBeginEditing:
Tc,N,V_shouldStream
currentProgress
Tc,N,V_syncTimeWithCoreAnimation
customAudioNode
Tc,N,VskipMorphTargets
damping
Tc,R,GareBarycentricCoordsSupported
dataWithLength:
Tc,R,GareRasterOrderGroupsSupported
dealloc
Tc,R,GisFramebufferOnly
depthAttachment
Tc,R,GisLoaded
diffuse
Tc,R,GisRemovable
display
Tc,R,N
dstNormalBuffer
Tc,R,N,GisInertiaRunning
elementPosition
Tc,V_completed
endTime
Td,N
evalAtLocation:
Td,N,V_endTime
fadeOutDuration
Td,N,V_panSensitivity
filterWithName:
Td,N,V_startTime
floatComponents
Td,N,V_truckSensitivity
focalBlurRadius
Td,N,Vradius
fresnelExponent
Td,R,N
geometrySourceWithColorData:colorSpace:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:
getBoundingSphereCenter:radius:
Tf,N,Vopacity
gravity
Tf,N,VreverbBlend
imageSequenceFrameRateVariation
Ti,N,Vtype
inertiaFriction
iniWithLibrary:
Tq,N,V_editingSpace
initWithCGPath:
Tq,N,V_interactionMode
initWithDouble:
Tq,N,V_referenceCount
initWithFormat:
Tq,N,V_xAlignment
initWithMatrix:
Tq,N,V_zAlignment
initWithResult:
Tq,N,VinputsCount
initWithString:
Tq,N,Vtype
initialVelocity
Tq,R,N
interleavedCopy
Tq,V_usedCount
isFront
T{?=QQQ},R
isJoint
T{?=[4]},R,N
isPremultiplied
T{?={?=[4]}{?=[4]}{?=[4]}},R,N
isTextureKnown:
T{CATransform3D=dddddddddddddddd},N,V_projectionMatrix
isVideoMirrored
T{CATransform3D=dddddddddddddddd},R
keyCode
T{CGRect={CGPoint=dd}{CGSize=dd}}
keyPathsForValuesAffectingScale
T{CGRect={CGPoint=dd}{CGSize=dd}},R,N
layouts
T{CGSize=dd},N
libraryForFile:
T{CGSize=dd},N,Vsize
lightingEnabled
T{MTLResourceID=Q},R
locationInNode:
T{SCNVector3=ddd},N
lowercaseString
T{SCNVector3=ddd},N,Veuler
T{SCNVector3=ddd},N,Vmin
matrix4
T{SCNVector3=ddd},N,Vscale
maxBufferLength
T{SCNVector3=ddd},R,N
maximumDistance
T{SCNVector4=dddd},N,Vrotation
members
T{_NSRange=QQ},N
URLByAppendingPathExtension:
minimumExposure
URLByDeletingPathExtension
morpher
URLByStandardizingPath
newBuffer:type:
URLForResource:withExtension:
newComputePipelineStateWithDescriptor:options:reflection:error:
URLOfResourceNamed:
newDynamicLibraryWithURL:error:
URLWithString:
newRenderPipelineStateWithDesc:
UUID
newSharedTextureWithDescriptor:
_3DConnexionIsPressed
numberWithBool:
__CFObject
numberWithLong:
__antialiasingMode
observedKeyPath
__camera
openGLContextWithCGLContextObj:
__didChangePointOfView
orientationMode
__engineStats
outlineView:shouldCollapseItem:
__ibPreferredRenderingAPI
outlineViewSelectionIsChanging:
__insertObject:inChildNodesAtIndex:
pixelBufferPool
__prepareFramebufferWithSize:withEngineContext:textureSampler:needsStencil:
prepareObject:shouldAbortBlock:
__prepareQueue
presentationBox
__removeObjectFromChildNodesAtIndex:
probeUpdateType
__renderLayerUsingMetal:withCARenderer:engineContext:viewport:atTime:forceUpdate:didUpdate:
program
__renderingQueue
propertyForKey:
__setTransitionContext:
pyramidWithWidth:height:length:
__skinner
recompilePasses
__updateTextureWithDelegate:engineContext:
referenceObject
__updateTextureWithSKScene:engineContext:sampler:
release
__willChangePointOfView
removeAllChilds
_accumulatedDrag
removeMaterial:
_actionKey
removeSourceRenderersForSource:
_activate
renderer:didRenderScene:atTime:
_activeBehaviorsValid
rendererOptions
_adaptativeFrameDuration
rendererWithMTLTexture:options:
_adaptativeTechniqueTimeStamp
replicatorConstraintWithTarget:
_addFieldToWorld:
requiredOutputs
_addGPUFramePresentedHandler:
resourceOptions
_addSkinnerWithMDLMesh:sceneNodes:
rightMouseDown:
_additive
runAction:onFirstChildWithName:
_aetherHandle
sceneDidChange:
_affectedByPhysicsFields
sceneWillChange
_allTargetsFromAnimCodec
screenSpaceAmbientOcclusionBias
_allocatorLock
scrollingDeltaY
_allowGPUBackgroundExecution
setAdd:
_allowsDefaultLightingEnvironmentFallback
setAnchorPoint:
_allowsTranslation
setArrayLength:
_ambient
setAverageGray:
_angularRestingThreshold
setBorderColor:
_angularVelocityFactor
setCastsShadow:
_animationDidStart
setConstantValue:type:withName:
_animationEvents
setControlSize:
_animationRef
setDestinationAlphaBlendFactor:
_antialiasingMode
setDisplayMask:
_appendToEntries:entriesWithType:passingTest:entryObjectConstructor:
setDoubleSided:
_applyOverride:forKeyPath:
setFieldOfView:
_applyWithEvent:
setFloat3Value:
_arcHandleXZ
setFocalLength:
_arcHandles
setFrameOrigin:
_areaExtents
setGroundColor:
_areaPolygonVertices
setHighDynamicRangeCompression:
_argUpdatePipeline
setIncremental:
_argumentEncoder
setInputOrigin:
_arrayLength
setKey:
_arrowIndicesOffset
setMax:
_assetCatalog
setMin:
_assetWriterInput
setNextKeyView:
_associatedMDLObject
setOrientation:
_asynchronousResizing
setPhysicsBody:
_attenuationFalloffExponent
setPixelFormat:
_attributes
setProbeOffset:
_audioNode
setRestitution:
_audioSource
setSRGBTexture:
_authEnv2
setSampleDistributedShadowMaps:
_authoringEnvironment
setSceneSource:
_autoCameraTarget
setScreenSpace:
_autoUpdate
setShadowColor:
_automaticTarget
setSpeedFactor:
_automaticallyAdjustsVideoMirroring
setStoreAction:
_autoreverses
setStringValue:
_availableBuffers
setTemporalAntialiasingEnabled:
_availableCompiledLibraries
setTextureType:
_availableComputePipelinesWithStageDescriptor
setWithObjects:
_availableIESTextures
set_commandBufferStatusMonitor:
_availableImages
shaderModifiers
_availableLibraries
sharedWorkspace
_availableMeshElements
simdEulerAngles
_availableMeshes
simdOrientation
_availableOpenSubdivComputeEvaluators
skScene
_availablePipelineStatesLock
skipFramesIfNoDrawableAvailable
_availableRasterizerStates
srcNormalBuffer
_availableShadables
stringByAppendingPathComponent:
_availableSkinDeformerReadOnlyBuffers
stringByResolvingSymlinksInPath
_availableTessellators
supportsFamily:
_averageGray
swizzle
_axis
tailSizeInBytes
_background
targets
_backgroundColor
textureForName:
_backgroundDidChange
timeSampleCount
_backgroundVideoProgram
toValue
_backingSize
triggerBindings
_bakeSphericalHamonicsBasedIrradianceTexture:forEnvironmentTexture:renderContext:applySH:
unbind:
_baked
unprojectPoint:
_baseBufferForComputeKernel
updateAndDrawStatisticsIfNeeded
_baseMesh
updateLightNode:withSourceNode:
_basePositionDataType
_beginFrame
valueWithRange:
_beginTime
vector2
_behaviors
vector4
_billboard
vignettingPower
_bindFramebuffer:
weakRef
_bindingData
worldUp
_bindings
zoomBy:
_birthLocation
_birthRate
_birthRateVariation
_blackPassEnabled
_bladeCount
_blendDenseIndexedPipeline
_blendDensePipeline
_blendMode
_blendSparsePipeline
_block
_bloomBlurRadius
_bloomIterationSpread
_blue
_body
_boldLogsInfo
_boldTextInfo
_boneIndexSize
_boneIndicesBuffer
_boneWeightsBuffer
_bonesAndIndicesCompression
_borderColor
_boundsSize
_boxchamferRadius
_boxchamferSegmentCount
_boxheight
_boxheightSegmentCount
_boxlength
_boxlengthSegmentCount
_boxprimitiveType
_boxwidth
_boxwidthSegmentCount
_browseMode
_browseScale
_browseScaleFactor
_bufferForData:bytesPerIndex:
_bufferForMTLBuffer:
_bufferPool
_bufferSize
_buffers
_buffersUsageMask
_buildBezierCurveInfoPipelineCubic
_buildBezierCurveInfoPipelineLinear
_buildBezierCurveInfoPipelineQuadratic
_buildMipmaps:
_buildQuadGeometryPipeline
_bytesPerIndex
_c3dAnimation
_c3dBackgroundColor
_c3dBackgroundColorDidChange
_c3dImage
_c3dShaderModifierCache
_caAnimationCache
_caReady
_cache
_cacheSceneSource:forURL:options:
_cachedObject
_cachedSceneSourceForURL:options:
_cachedTessellator
_caction
_calculationMode
_callbackWithTime:
_cameraController
_cameraFrustumGeometry
_cameraLoaded
_cameraNearPlaneGeometry
_cameraOriginalFieldOfView
_cameraOrthographicFrustumGeometry
_cameraRoot
_cameraTarget
_cameraTargetComputed
_camerasDictionary
_canJitter
_cancelJitterRedisplay
_cancelMouseMovedTracking
_canceled
_capOrientationAnglesToMaximum
_cappedTranslationDelta:
_capsuleShape
_capsulecapRadius
_capsulecapSegmentCount
_capsuleheight
_capsuleheightSegmentCount
_capsuleprimitiveType
_capsuleradialSegmentCount
_captureDevice
_cascadeDebugFactor
_castsShadow
_catalog
_catalogURL
_categoryBitMask
_centerOfMassOffset
_cglContext
_chainRootNode
_chamferMode
_chamferRadius
_characterController
_chassisBody
_checkAndUpdateDisplayLinkStateIfNeeded
_checkForAssociatedSamplerOnBinding:argument:
_checkSettingsConsistency
_childNodes
_childNodesPassingTest:recursively:output:
_childNodesWithAttribute:output:recursively:
_ciImage
_clearAppKitGLContext
_clearBackBuffer
_clearC3DCache
_clearCoat
_clearCoatNormal
_clearCoatRoughness
_clearContents
_clearSceneRef
_clearUnusedBindingPoints
_clickOrigin
_clientCommandBuffer
_clientCommandQueue
_clientRenderCommandEncoder
_clientRenderPassDescriptor
_clients
_cloneSet
_cloning
_coalescingSource
_collectCompilationErrors
_colliderNodes
_collisionBitMask
_collisionImpulse
_color
_colorAndTextureProgram
_colorBufferWriteMask
_colorFringeIntensity
_colorFringeStrength
_colorGrading
_colorOnlyProgram
_colorSpace
_commandBufferStatusMonitor
_commandQueue
_commonInit
_commonInit:
_commonProfileBuffersAllocator
_commonProfileCacheLibrary
_commonProfileCacheLibraryHasherBlock
_commonProfileCacheLibraryProviderBlock
_commonProfileIORange
_commonProfilePrecompiledFunctions
_compilationErrors
_compilationIssues
_completed
_componentType
_components
_compositeRendering
_computeACMR
_computeAutomaticTargetPointIfNeeded
_computeBoundingSphereOmittingFloorsForNode:sphere:
_computeEvaluator
_computeFunction
_computeNextFrameTime
_computePipeline
_computePipelineStateForKernel:constants:constantsHash:threadGroupSizeIsMultipleOfThreadExecutionWidth:
_computeStickyAxisIfNeeded:
_computeTranslationOrigin3DFromPoint:
_computeUsageForArguments:function:
_computedLightingEnvironmentMapsPath
_conebottomRadius
_coneheight
_coneheightSegmentCount
_coneprimitiveType
_coneradialSegmentCount
_conetopRadius
_configBufferChain
_configureComputePipeline:withDescriptor:
_connectionPosition
_consoleLineCount
_constantBufferPools
_constraint
_constraintRef
_contact
_contactDelegate
_contactNormal
_contactPoint
_contactTestBitMask
_contactWithManifold:index:
_containsAlpha
_contentScaleFactor
_contentTransform
_contentType
_contents
_contentsScaleFactor
_context
_contextIsDoubleBuffered
_continuousCollisionDetectionThreshold
_contrast
_controller
_controllers
_convertRotationFromWorldToPointOfView:
_convertToCA
_copyAnimationsFrom:
_copyAttributes:
_copyAttributesTo:
_copyBaseBufferPipeline
_copyC3DImageFromImageData:typeID:
_copyDefinition:
_copyImageFromC3DImage:
_copyPassDescription
_copyPerformanceStatistics
_copyRecursively
_copyRenderGraphDescription
_copySnapshot:
_cornerRadius
_cornerSegmentCount
_correctiveDriverCounts
_correctiveDriverIndices
_correctiveInBetweenCounts
_correctiveInBetweenInfluenceWeights
_correctivesAndInBetweens
_counterVector
_counters
_createBackgroundColorImageWithSize:
_createBody
_createDisplayLinkIfNeeded
_createDynamicWorldIfNeeded
_createField
_createFramebufferWithEngineContext:size:
_createOffscreenFramebufferIfNeeded
_createPipelineStateWithDescriptor:desc:pipeline:
_createPrepareFramebufferIfNeeded
_createResourceCommandBufferIfNeeded
_createSceneRefWithOptions:statusHandler:
_createSkinnerWithBones:boneWeights:boneIndices:baseGeometry:
_createSkinnerWithCompressedData:bonesCount:vertexCount:
_createSnapshotAtTime:withSize:antialiasingMode:
_createSnapshotAtTime:withSize:antialiasingMode:error:
_createWheel:
_cullMode
_cumulative
_current
_currentAllocatorPage
_currentCommandBuffer
_currentFrameHash
_currentFrameIndex
_currentFrustumInfo
_currentInitRenderContext
_currentPass
_currentRenderContext
_currentRenderPassDescriptor
_currentResourceManager
_currentSceneTime
_currentSeekStep
_currentStickyAxis
_currentStreamBufferIndices
_currentSystemTime
_currentTransforms
_currentUpdateBuffers
_currentUpdateComputeCommandEncoder
_currentUpdateComputeEncoder
_currentUpdateComputeEncoderProvider
_currentUpdateFrustumInfo
_currentUpdateRenderContext
_currentUpdateTransforms
_curveControlPointCount
_curveInfo
_curveToGeometryTransform
_customAudioNode
_customContainerFrame
_customDecodingOfSCNAudioSource:
_customDecodingOfSCNAvoidOccluderConstraint:
_customDecodingOfSCNDistanceConstraint:
_customDecodingOfSCNFloor:
_customDecodingOfSCNGeometry:
_customDecodingOfSCNIKConstraint:
_customDecodingOfSCNLight:
_customDecodingOfSCNLookAtConstraint:
_customDecodingOfSCNMaterial:
_customDecodingOfSCNMaterialProperty:
_customDecodingOfSCNMorpher:
_customDecodingOfSCNNode:
_customDecodingOfSCNParticlePropertyController:
_customDecodingOfSCNParticleSystem:
_customDecodingOfSCNPhysicsShape:
_customDecodingOfSCNPhysicsVehicle:
_customDecodingOfSCNPhysicsWorld:
_customDecodingOfSCNProgram:
_customDecodingOfSCNReplicatorConstraint:
_customDecodingOfSCNScene:
_customDecodingOfSCNShadableHelper:
_customDecodingOfSCNShape:
_customDecodingOfSCNTechnique:
_customDecodingOfSCNText:
_customDeformerToInstances
_customEncodingOfSCNAudioSource:
_customEncodingOfSCNAvoidOccluderConstraint:
_customEncodingOfSCNCamera:
_customEncodingOfSCNDistanceConstraint:
_customEncodingOfSCNGeometry:
_customEncodingOfSCNIKConstraint:
_customEncodingOfSCNLevelOfDetail:
_customEncodingOfSCNLight:
_customEncodingOfSCNLookAtConstraint:
_customEncodingOfSCNMaterial:
_customEncodingOfSCNMaterialProperty:
_customEncodingOfSCNMorpher:
_customEncodingOfSCNNode:usePresentationInstance:
_customEncodingOfSCNParticlePropertyController:
_customEncodingOfSCNParticleSystem:
_customEncodingOfSCNPhysicsShape:
_customEncodingOfSCNPhysicsWorld:
_customEncodingOfSCNProgram:
_customEncodingOfSCNReplicatorConstraint:
_customEncodingOfSCNScene:
_customEncodingOfSCNShadableHelper:
_customEncodingOfSCNShape:
_customEncodingOfSCNTechnique:
_customEncodingOfSCNText:
_customMainPassPostProcessUsesExtraRenderTargetForRenderer:pixelFormat:
_customSlot
_cvDisplayLink
_cyan
_cylinderheightSegmentCount
_cylinderprimitiveType
_cylinderradialSegmentCount
_cylinderradialSpan
_damping
_dampingFactor
_data
_dataKind
_dataKindForComputeKernel
_dataOffset
_dataSource
_dataStride
_datasource
_debug
_debugDrawer
_debugOptions
_decelerationDistance
_defaultBackgroundColor
_defaultCubeTexture
_defaultDepthStencilState
_defaultLightingEnvironmentIrradianceTexture
_defaultLightingEnvironmentRadianceTexture
_defaultPOVForScene:
_defaultPixelFormat
_defaultPixelFormatWithAPI:sampleCount:stencil:
_defaultProgramForTessellation
_defaultSamplerState
_defaultTargetForScene:
_defaultTexture3D
_defaultVehicleRayCaster
_definition
_deformNormalBuffer
_deformNormalStageInputOutputDescriptorInfo
_deformPositionBuffer
_deformPositionStageInputOutputDescriptorInfo
_deformTangentBuffer
_deformTangentStageInputOutputDescriptorInfo
_deformedIndexBuffer
_deformedMesh
_deformedNode
_deformedPrimitiveCountBuffer
_deformedPrimitiveCountBufferOffset
_deformedToDrivingBindingTransform
_deformer
_deformerStackDidChange:
_deformerStackWillDie:
_deformers
_deindexedToFirstDeindexedTableBuffer
_deindexedToFirstDeindexedTableBufferIndexSize
_deindexedToOriginalTableBufferIndexSize
_delegate
_delegationConformance
_deleteGLFramebuffer
_deleteOriginalData
_deltaTime
_depthAndStencilStateWithReadWriteDepthDisabled
_depthOffCullOffStates
_depthOffCullOnStates
_depthOnCullOffStates
_depthOnCullOnStates
_depthPrePass
_desc
_description
_destination
_deviceQueue
_dictionaryForFrequency:
_didDecodeSCNCamera:
_didDecodeSCNIKConstraint:
_didDecodeSCNLevelOfDetail:
_didDecodeSCNLight:
_didDecodeSCNMaterialProperty:
_didDecodeSCNMorpher:
_didDecodeSCNNode:
_didDecodeSCNPhysicsBody:
_didDecodeSCNPhysicsWorld:
_didDecodeSCNScene:
_didDecodeSCNShadableHelper:
_didDragTo:
_didEncodeSCNScene:
_didEverFocusNode
_didInstallInEngineContext:
_didMutate
_didRenderScene:
_diffNode:with:path:
_diffObject:with:path:
_diffuse
_direction
_directionForScreenPoint:viewport:
_disableLinearRendering
_disableOverlays
_discardOriginalTopology
_discardPendingGPUFrameCompletedHandlers
_discardPendingGPUFramePresentedHandlers
_discardPendingGPUFrameScheduledHandlers
_discretizedStraightLineMaxLength
_displacement
_displayID
_displayLink
_displayLinkCreationRequested
_displayLinkStatsTack
_displayLinkStatsTick
_displayMask
_displayScaleFactor
_distance
_documentURL
_dofIntensity
_doubleSided
_downSamplePipeline
_draw
_drawAtTime:
_drawAtTime:WithContext:
_drawDebugInAuthoringEnvironment:
_drawForJittering
_drawInBackingLayerWithCGLContext:atTime:
_drawIndexedPrimitivesIndirectBuffer
_drawIndexedPrimitivesIndirectBufferOffset
_drawOnMainThreadPending
_drawOverlaySceneAtTime:
_drawPBRTextures
_drawScale
_drawScene:
_drawSceneWithLegacyRenderer:
_drawSceneWithNewRenderer:
_drawWithJitteringPresentationMode
_drawable
_drawablePresentedHandlers
_drawableSafeAreaInsets
_drawsArea
_drivenBydefaultNavigationCameraController
_dump:
_dumpNodeTree:tab:
_dumpToDisk
_dumpTree
_duration
_dynamicLinesInfo
_dynamicLinesNoDepthTestInfo
_dynamicTrianglesInfo
_edgeCreasesElement
_edgeCreasesSource
_edgeTessellationFactor
_editingSpace
_effectiveFeatures
_effectiveIndexCount
_effectiveIndexOffset
_effectiveModifier
_effectiveStickyAxis
_elapsedTime
_elementData
_elementSize
_elements
_emission
_emissionDuration
_emissionDurationVariation
_emitterShape
_emittingDirection
_enableARMode
_enableFreeCamera
_enabled
_encodeCustomMainPassPostProcessForRenderer:atTime:helper:
_encodeDataAsHalf
_endDraggingWithVelocity:
_endFrame
_endTime
_engineContext
_enqueueCopyFromTexture:toTexture:blitEncoder:generateMipMaps:
_entryPoint
_enumerateDependencyNodesUsingBlock:
_environment
_error
_euler
_eventBlock
_eventTime
_exclusive
_executeDrawCommand:
_expandItem:
_explicitMomentOfInertia
_exportAsMovieOperationWithDestinationURL:size:attributes:delegate:didEndSelector:userInfo:
_exposureAdaptationBrighteningSpeedFactor
_exposureAdaptationDarkeningSpeedFactor
_exposureAdaptationDuration
_exposureAdaptationHistogramRangeHighProbability
_exposureAdaptationHistogramRangeLowProbability
_exposureAdaptationMode
_fStop
_fadeOutDuration
_falloffExponent
_features
_field
_fieldGeometry
_fieldOfView
_fieldOfViewZoomFactor
_fillBackward
_fillForward
_fillMode
_fillNodeA:nodeB:
_fillNodeA:nodeB:contactPoint:collisionImpulse:distance:hitFraction:
_fillVertexDescriptor:withMeshSource:semantic:inputSet:bufferIndex:
_fillVertexDescriptor:withSemantic:inputSet:bufferIndex:vertexFormat:offset:stride:
_filterChannel
_finalDataKind
_finalMesh
_finalMeshDataKind
_finalMeshVertexCount
_finalNormalBuffer
_finalPositionBuffer
_finalTangentBuffer
_finalizeComputePipeline
_findComponentWithType:
_findFieldAttachedToNode:
_fired
_firstDrawDone
_firstMaterial
_firstSimulationDone
_fixedBoundingBoxExtrema
_fixedTimeStep
_flatness
_flyModeVelocity
_focalBlurSampleCount
_focalLength
_focusBehavior
_focusDistance
_focusFrameInView:
_fogColor
_fogDensityExponent
_fogStartDistance
_font
_forceAsyncShaderCompilation
_forceSystemTime
_forcesBackFaceCasters
_fraction
_fragmentBuffers
_fragmentFunction
_fragmentFunctionName
_fragmentSamplers
_fragmentTextures
_frameBindings
_frameBufferBindings
_frameConstantBufferPool
_frameTexturePool
_frameUniforms
_frameVolatileBufferPool
_framebuffer
_framebufferInfo
_framebufferSize
_frameworkLibrary
_freeAxes
_freeCameraActivated
_freeIndices
_freeViewCameraNode
_freeVolatileMeshElements
_frequency
_fresnelExponent
_friction
_frictionSlip
_generateLock
_generatedTexturePath
_geometry
_geometryByAddingSourcesOfSkinner:
_geometryByRemovingSkinnerSources
_geometryByUnifyingNormalsWithCreaseThreshold:
_geometryByWeldingVerticesWithThreshold:normalThreshold:
_geometrySourceWithData:semantic:vectorCount:componentType:componentCount:dataOffset:dataStride:
_geometrySourceWithSource:vertexFormat:
_geometryWillDie:
_getDeformedMeshBoundingBox:
_getFrameIndex
_ghostObject
_ghostPairCallback
_gimbalLockEnabled
_glContext
_glContextDidChange
_gobo
_gpuHandlersLock
_grainScale
_grainSlice
_grainTexture
_graphicalSelectionEnabled
_gravity
_grayDark
_grayLight
_grayMedium
_green
_gridUnit
_halfExtent
_handleCreateIfNeeded:
_handlingInteraction
_hasActiveFields
_hasAutomaticCameraTarget
_hasComponentBitmask
_hasDefaultValues
_hasFired
_hasFixedBoundingBoxExtrema
_hasLighting
_hasPivot
_heightSegmentCount
_hidManager
_highlightNode
_hitTest:viewport:options:
_ibNoMultisampling
_ibPreferredRenderingAPI
_ibSceneName
_ibWantsMultisampling
_idleDuration
_idleDurationVariation
_ignoreGravity
_ikTarget
_image
_imagePathWithSceneDocumentURL:originalImageURL:
_imagePathWithSceneDocumentURL:originalImageURL:error:
_imageProxyWillDie:
_imageSequenceAnimationMode
_imageSequenceColumnCount
_imageSequenceFrameRate
_imageSequenceFrameRateVariation
_imageSequenceInitialFrame
_imageSequenceInitialFrameVariation
_imageSequenceRowCount
_imageWillDie:
_inBetweenCounts
_inBetweenInfluenceWeights
_inFlightSemaphore
_inRenderQueueForLayerBackedGLRendering
_incremental
_incrementalAddPipeline
_incrementalInitPipeline
_indexBuffer
_indexCount
_indexOfRefraction
_indexPathForNode:
_indexType
_indices
_indicesChannelCount
_inertia
_inertiaVelocity
_influenceFactor
_initChildNodesArray
_initWithEngineContext:
_initWithOptions:isPrivateRenderer:privateRendererOwner:clearsOnDraw:context:renderingAPI:
_initialBuffersStageInputDescriptor
_initialInputLocation
_initialMatrix
_initialNormalBuffer
_initialNormalStageInputOutputDescriptorInfo
_initialPoint
_initialPointOfViewWorldPosition
_initialPositionBuffer
_initialPositionStageInputOutputDescriptorInfo
_initialSelection
_initialTangentBuffer
_initialTangentStageInputOutputDescriptorInfo
_initialTime
_initialZoom
_initializeWheelsArray
_injectionPointRanges
_innerBindingOffsetsBuffer
_innerLayerInfluencesBuffer
_inputBias
_inputLocation
_inputMode
_inputOrigin
_inputProperty
_inputScale
_insideTessellationFactor
_inspector
_installFreeViewCameraIfNeeded
_installViewport
_instance
_instanceCount
_integrateModelKitComputedMaps:withGeometry:node:texturePathProvider:vertexAttributeNamed:materialPropertyNamed:filePath:
_intensity
_interactionMode
_interleavedIndicesChannels
_invalidateFramebuffer
_invalidated
_isAReference
_isAnimating
_isCommonProfileProperty
_isDefault
_isDirty
_isEditor
_isEffectivelyHidden
_isFront
_isGLLayerBacked
_isHidden
_isInertiaRunning
_isInvalidated
_isJoint
_isLayerBacked
_isLayerPrivateRenderer
_isLegacySingleLayerDeformer
_isLocal
_isLocationValid:inViewport:
_isMetalSupported
_isMouseDown
_isNameUnique:
_isNodeInsideFrustum:withPointOfView:viewport:
_isOpaque
_isOrbiting
_isPresentationInstance
_isPrivateRenderer
_isRenderingForJittering
_isRunningInExtension
_isSceneBoundingSphereComputed
_isUsingSparseTargets
_isValid
_isValidationEnabled
_isViewPrivateRenderer
_isViewedObjectSphereComputed
_iteration
_jitterAtStep:updateMainFramebuffer:redisplay:jitterer:
_jitterRedisplayWithContext:
_jitterer
_jitteringEnabled
_jointsPerNode
_keepTargetDirection
_keyPath
_keyValues
_keyboard
_keys
_kvoKeysForwardedToRenderer
_lastDeformedCurveControlPointsBuffer
_lastDisplayLinkTime
_lastDragLocation
_lastDragTime
_lastFramePositionBuffer
_lastFrameTime
_lastGridDistance
_lastInputLocation
_lastKeyInputTime
_lastLoadedScene
_lastModifierFlags
_lastMorpherIncrementalPassState
_lastOptions
_lastRenderedTime
_lastRotationAngle
_lastSimulationTime
_lastUpdate
_layer
_layerDidChange:
_layerRoot
_layerRootNode
_layerTarget
_layoutLocked
_legacyDeformedNodeUVChannel
_legacyDrivingNode
_legacyDrivingNodeUVChannel
_legacyFov
_legacyOffsetsOrTransformsBuffer
_lensShift
_library
_libraryHash
_libraryProvider
_libraryURL
_light
_lightBindings
_lightBufferBindings
_lightEmissionRadiusFactor
_lightGeometry
_lightLoaded
_lightProbesInfo
_lightProbesProgram
_lightRoot
_lighting
_lightingEnabled
_lightingInjectionPointRanges
_lightingModelName
_lightsData
_lightsDictionary
_line
_linearRestingThreshold
_litPerPixel
_load
_loadReferencedSceneWithURL:catalog:
_loadURLWithBundle:
_loadWithCatalog:
_loadWithURL:
_loadWithURL:catalog:
_loadingPolicy
_localFront
_lock
_locksAmbientWithDiffuse
_lod
_logLightingInformation
_logsInfo
_lookUpFoundInstance
_lookUpKey
_loops
_magnificationFilter
_mainContext
_mainTargetNamesToIndexes
_mainTargets
_mainTargetsAndInBetweens
_mainView
_manager
_manipulator
_mapToSphere:inViewport:
_mass
_material
_materialPropertyClass
_materialWillDie:
_materialWithName:
_materials
_maxAnisotropy
_maxLevel
_maxTrianglesAtLevel
_maximumAngles
_maximumDirectionAngle
_maximumDistance
_maximumEdgeLength
_maximumExposure
_maximumLinearAcceleration
_maximumLinearVelocity
_maximumPointScreenSpaceRadius
_maximumShadowDistance
_maximumSuspensionForce
_maximumSuspensionTravel
_meshElement
_meshElementData
_meshElementWillDie:
_meshSource
_meshSourceWillDie:
_meshWillDie:
_meshlessDeformer
_message
_metalness
_minificationFilter
_minimumAngles
_minimumDistance
_minimumExposure
_minimumLanguageVersion
_minimumPointScreenSpaceRadius
_mipFilter
_mirrored
_mkSemantic
_mode
_modeSensitivity
_modelInspectors
_modelPath
_modelPathComponents
_modelViewContainer
_momentOfInertia
_morphDeformer
_morphKind
_morphNormals
_morphTargetCount
_morphTargetNormalDataType
_morphTargetPositionDataType
_morphTargets
_morphTargetsSparseIndicesBuffer
_morphTargetsVertexBuffer
_morphWillDie:
_morpher
_morpherLoaded
_motionBlurIntensity
_mouseDown
_mouseIsDown
_movability
_mtkTextureLoader
_mtlBuffer
_mtlTexture
_mtlTextureCache
_mtlVertexFormat
_multiply
_mutabilityTimestamp
_mutex
_mycaction
_name
_names
_navigationCameraController
_needSuperSampling
_needsRedraw
_needsRedrawAsap
_needsRedrawForJittering
_needsRenderResource
_needsRepetitiveRedraw
_newComputeDescriptorForPipelineDesc:library:
_newMTLBufferFromPoolWithLength:
_newProgramWithHashCode:engineContext:introspectionDataPtr:
_newProgramWithHashCodeWithFunctionConstants:engineContext:introspectionDataPtr:
_newSubBuffer
_nextFrameTime
_nibLoaded
_node
_nodeA
_nodeB
_nodeBindings
_nodeBufferBindings
_nodeRef
_nodeUniforms
_nodeWithIndexPath:
_nodesInsideFrustumWithPointOfView:viewport:
_notifyNextDirtyState
_objectController
_occluder
_opacity
_openGLContext
_openGLContextDidChange:
_openGLContextIfAny
_operateOnDataUsingCompressionAlgorithm:operation:
_optimizeKeyframesWithTarget:
_optimizeTriangleIndices
_optimizedGeometryElementWithData:primitiveType:primitiveCount:bytesPerIndex:
_options
_optionsForSymbol:
_orientationDirection
_orientationForMode
_orientationMode
_orientationOffset
_orientationState
_originalData
_originalDataCount
_originalFovX
_originalFovY
_originalIndexBuffer
_originalLightingSourceCode
_originalMouseLocation
_originalOrthoScale
_originalPrimitiveCount
_originalRenderPassDescriptor
_originalSourceCode
_originalToFirstDeindexedTableBuffer
_originalToFirstDeindexedTableBufferIndexSize
_orthographicScale
_orthographicScaleForZoomFactor:
_orthographicViewSpaceTranslationForZoomAtScreenPoint:scaleDelta:viewport:
_orthographicZoomFactor
_orthographicZoomFactorForProposedZoomFactor:
_outerBindingOffsetsBuffer
_outgoingPointOfView
_outgoingScene
_outlineView
_outputURL
_overlayDynamicLinesInfo
_overlayDynamicTriangleInfo
_overlayLayerRoot
_overlayRenderer
_overlayScene
_overlaysDidUpdate:
_overrides
_ownedCommandQueue
_owner
_ownerWillDie
_pages
_paleBlue
_paleGreen
_panel
_parallaxCenterOffset
_parallaxCorrectionEnabled
_parallaxExtentsFactor
_parameters
_parentPage
_parentView
_parseAndSetShaderModifier:
_parseArguments:function:renderPipeline:
_particleAngle
_particleAngleVariation
_particleAngularVelocity
_particleAngularVelocityVariation
_particleBounceVariation
_particleChargeVariation
_particleColor
_particleColorVariation
_particleDiesOnCollision
_particleFriction
_particleFrictionVariation
_particleGeometries
_particleImage
_particleIntensity
_particleIntensityVariation
_particleLifeSpan
_particleLifeSpanVariation
_particleMass
_particleMassVariation
_particleSize
_particleSizeVariation
_particleSystems
_particleVelocity
_particleVelocityVariation
_particlesDictionary
_particlesGeometry
_particlesRoot
_partitionMode
_pass
_passBindings
_passBufferBindings
_passWillDie:
_path
_pause
_pauseAnimation:forKey:pausedByNode:
_pauseDisplayLink
_pauseDisplayLinkIfPossible
_pausedByInheritance
_pausedForEditing
_pendingAllocationListener
_pendingGPUFrameCount
_perVertexTrianglesIndices
_perVertexTrianglesOffsets
_physicsCollisionsEnabled
_physicsFieldsDictionary
_physicsFieldsRoot
_physicsShape
_physicsWorld
_physicsWorldCreateIfNeeded:
_pinchShouldMoveCamera
_pink
_pipeline
_pipelineStateHashForMeshElement:patchType:
_pixelFormatByDefaultingIfNeeded
_planarTranslationHandleXY
_planarTranslationHandleXZ
_planarTranslationHandleYZ
_planarTranslationHandles
_planarTranslationLayout
_plane
_play
_playerRef
_playing
_pointIndicesBuffer
_pointOfView
_pointOfViewIsSelected
_pointOfViewOrthographicScale
_pointOfViewUsesOrthographicProjection
_pointOfViewWasSet
_pointSize
_pointsOfViewRoot
_position
_postCommandWithBlock:
_postMorphingDeformerInstances
_postProjectionTransformScale
_postProjectionTransformTranslation
_postSkinningDeformerInstances
_preTick:
_precomputedLightingEnvironmentWillDie:
_preferredFramePerSeconds
_preferredFrameRate
_preloadRenderer
_preloadResource:abortHandler:
_prepareForTransition:outgoingScene:outgoingPointOfView:completionHandler:
_prepareFreeViewCamera
_prepareGLRenderTarget
_prepareMaterialTextures:
_prepareObject:shouldAbortBlock:
_preparePixelFormat
_preparePreloadRenderer:
_prepareRenderTarget
_prepareSKRenderer
_prepareSnapToAlignData:minOffset:maxOffset:
_prepareUpdate
_presentFramebuffer
_presentationInstance
_presentationMappingChannel
_presentationWeightForTargetAtIndex:token:
_preserveScale
_prettifyForPreview
_preventWarmup
_primitiveRanges
_primitiveType
_printData
_privateOpenGLContext
_privateOpenGLContextIfAny
_privateRendererOwner
_privateRendererOwnerDelegationConformance
_probeEnvironment
_probeExtents
_probeOffset
_probeType
_probeUpdateType
_processedJoints
_processingContext
_profile
_program
_programDidChange:
_programFromPassAtIndex:
_programHashCodeWillDie:
_programMutex
_programWillDie:
_progress
_projectPoint:viewport:
_projectPoints:count:viewport:
_projectionDirection
_projectionMatrix
_projectionTransform
_properties
_property:
_propertyControllers
_propertyType
_provider
_pyramidheight
_pyramidheightSegmentCount
_pyramidlength
_pyramidlengthSegmentCount
_pyramidprimitiveType
_pyramidwidth
_pyramidwidthSegmentCount
_quadMesh
_quadPositionsBuffer
_quadTexcoordsBuffer
_quadrantIndicesCount
_quadrantIndicesOffset
_quadrantRingIndicesCount
_quadrantRingIndicesOffset
_quaternion
_queue
_queuedFrameCount
_radianceData
_rasterizerStateDidDie:
_rate
_rayTestWithSegmentFromPoint:toPoint:options:
_readSubdivCacheForHash:
_readonly
_readsFromDepthBuffer
_recordWithoutExecute
_recordingPointOfViewEvents
_recycleMTLBufferToPool:
_red
_reduceStatsOfConstantBuffer:
_referenceName
_referenceObject
_referenceURL
_reflectionCategoryBitMask
_reflectionFalloffEnd
_reflectionFalloffStart
_reflectionResolutionScaleFactor
_reflectionSampleCount
_reflective
_reflectivity
_registerAsObserver
_registry
_releaseCachedSourcesAndElements
_releasePreloadRenderer
_reliesOnFrustum
_reliesOnTransforms
_reloadDebugOptions
_reloadWithScene:
_removeAction:forKey:
_removeButton
_removeCachedSceneSourceIfNeededForURL:
_removeComponentWithType:
_removeDeadParticleSystem:
_removeFieldFromWorld:
_removeMatchingProgram:pass:
_removeOwner
_removedOnCompletion
_renderAtTime:
_renderAtTime:viewport:encoder:passDescriptor:commandQueue:commandBuffer:
_renderContext
_renderContextMetal
_renderEncoder
_renderGraph
_renderGraphFrameRecordingAtPath:withCompletion:
_renderOptions
_renderPassParameters
_renderSceneWithEngineContext:sceneTime:
_renderSize
_renderThreadPriority
_renderer
_renderer:didApplyAnimationsAtTime:
_renderer:didApplyConstraintsAtTime:
_renderer:didBuildSubdivDataForHash:dataProvider:
_renderer:didRenderScene:atTime:
_renderer:didSimulatePhysicsAtTime:
_renderer:inputTimeForCurrentFrameWithTime:
_renderer:subdivDataForHash:
_renderer:updateAtTime:
_renderer:willRenderScene:atTime:
_rendererContextGL
_rendererDelegate
_renderers
_renderingAPI
_renderingMode
_renderingPrepare
_renderingSnapshot
_rendersContinuously
_rendersIntoMaterial
_repeatCount
_replicateOrientation
_replicatePosition
_reserved
_reserved2
_reset
_resetBrowseScaleFactor
_resetContentsScaleFactor
_resetFreeViewCamera
_resetLightAuthoringWithContainerNode:source:light:
_resetOrientationState
_resetSceneTimeRange
_reshape
_resizeLayer:toSize:updateLayer:updateTransform:caRenderer:
_resizeLayer:toSize:updateLayer:updateTransform:caRenderer:isMainThread:
_resolveAndDiscardGL
_resolveURL
_resourceBlitEncoder
_resourceCommandBuffer
_resourceComputeEncoder
_resourceGroup
_resourceManager
_resourceManagerMonitor
_resourceQueue
_restartSource
_restartSourceIsSuspended
_restitution
_resumeDisplayLink
_resumeDisplayLinkForDelayedFrame
_resumeDisplayLinkIfNeeded
_resyncObjCModelOfPerTypeParameters
_reverseZ
_rightMouseIsDown
_rollingFriction
_rootNode
_rotateByX:Y:
_rotateWithDrag:mode:stickyAxis:
_rotation
_rotationHandles
_rotationRepresentation
_rotationSensitivity
_roughness
_runFPSTestWithDuration:
_runningInExtension
_runningLock
_runtimeResolvedPath
_sRGB
_sampleCount
_sampleDistributedShadowMaps
_samplerInput
_samplersUsageMask
_saturation
_saveOriginalData
_scale
_scaleNode
_scaleOffset
_scaleSceneBy:
_scene
_sceneBoundingSphere
_sceneBuffer
_sceneDidUpdate:
_sceneGraph
_sceneLoaded
_sceneRenderer
_sceneRendererDelegate
_sceneRendererDelegateDelegationConformance
_sceneRendererIsSCNView
_sceneSource
_sceneSourceOptions
_sceneUniforms
_sceneWithClass:options:statusHandler:
_scnAnimationForKey:
_scnBindings
_scnUpdateContentsGravity
_scnView
_scnlayerBackedOpenGLContext
_scope
_screenSize
_screenSpace
_screenSpaceAmbientOcclusion
_screenSpaceReflectionMaxRayDistance
_screenSpaceReflectionSampleCount
_screenSpaceReflectionStride
_screenSpaceRotation
_screenTransform
_scrollWheelModifiers
_scrollWheelMultiplier
_searchArguments:forArgumentNamed:type:
_seed
_selectedAxis
_selectedNodes
_selecting
_selection
_selectionIsReadonly
_selectionP0
_selectionP1
_selector
_selfDelegationConformance
_selfIllumination
_selfIlluminationOcclusion
_semantic
_semanticInfos
_semantics
_sensorSize
_setAnimation:
_setAnimationRef:
_setAuthoringEnvironment:
_setBackingSize:
_setBaseGeometry:
_setC3DImageRef:
_setC3DProgram
_setC3DProgramDelegate
_setColor:
_setComponent:withType:
_setContentsScaleFactor:
_setDisplayScaleFactor:
_setEngineStats:
_setGeometryRef:
_setHasFocusableChild
_setInertiaRunning:
_setLayerBackedOpenGLContext:
_setNeedsDisplay
_setOpenGLContext:madeWithPixelFormat:
_setOwner:
_setParent:
_setParticleImagePath:withResolvedPath:
_setPausedOrPausedByInheritance:
_setPointOfViewOrthographicScale:
_setPosition:
_setRootNode:
_setScale:
_setSceneTime:
_setSkeleton:
_setSourceURL:
_setVehicle:
_setWorld:
_setupAuthoringEnv2:
_setupCommonProperties
_setupContentsFromC3DImage
_setupDuration
_setupFrom:
_setupGeometryElements
_setupGeometrySources
_setupMaterialProperty:
_setupMovieToWritableFile:
_setupObjCModelFrom:
_setupOffscreenRendererWithSize:
_setupPasses
_setupSKRendererIfNeeded
_setupShadableHelperIfNeeded
_setupUpVector
_setupWithGeometry:thresholdMode:value:
_shadable
_shadableBindings
_shadableBufferBindings
_shadableSetValue:forUndefinedKey:
_shaderCompilationGroup
_shaderModifiers
_shaders
_shadowBias
_shadowCascadeCount
_shadowCascadeDebugFactor
_shadowCascadeSplittingFactor
_shadowColor
_shadowKernelBuffer
_shadowMapSize
_shadowRadius
_shadowSampleCount
_shapeHandleWithShape:owner:
_sharedIndexBufferOffset
_shiftBuffer
_shininess
_shouldBakeDirectLighting
_shouldBakeIndirectLighting
_shouldCacheWithOptions:
_shouldDelegateARCompositing
_shouldDeleteFramebuffer
_shouldForwardSceneRendererDelegationMessagesToPrivateRendererOwner
_shouldForwardSceneRendererDelegationMessagesToSelf
_shouldIgnoreMomentumEvents
_shouldInheritContentsScale:
_shouldPostUpdate
_shouldPresentAfterMinimumDuration
_shouldPresentWithTransaction
_shouldRecycle
_shouldSnapOnGrid
_shouldSnapToAlign
_shouldStream
_shouldUpdateTarget
_showAuthoringEnvironment
_showsAuthoringEnvironment
_size
_skCompositing
_skSceneDidChange:
_skeleton
_skinDeformer
_skinNormals
_skinTangents
_skinWillDie:
_skinner
_skinnerLoaded
_skinnerWithBaseGeometry:skinnableGeometry:bones:boneInverseBindTransforms:bindMatrix:
_skipFramesIfNoDrawableAvailable
_sliceTextures
_smoothNormalsDeformer
_smoothNormalsPipeline
_smoothingMode
_smoothness
_snapPositionToAlign:original:unit:axisMove:rayStart:rayDir:didSnap:snapIndexes:
_snapToAlignCount
_snapXIndexes
_snapYIndexes
_snapZIndexes
_snapshotImageData
_snapshotImageDataLength
_snapshotRenderer
_softParticlesEnabled
_sortingMode
_sourceContext
_sourceDocumentURL
_sourceFile
_sourceURL
_sources
_specular
_specularDFGDiffuseHammonTexture
_speed
_speedFactor
_speedKmHour
_spherehemispheric
_sphereprimitiveType
_sphereradialSpan
_sphereradius
_spheresegmentCount
_sphericalHarmonics
_splatDeformedToFinalPipeline
_splatPipeline
_splatUniforms
_spotFalloffExponent
_spriteKitEventHandler
_stack
_stageDescriptor
_stageDescriptorsLock
_stageInputOutputDescriptors
_startBrowsingIfNeeded:
_startObservingProgram
_startTime
_state
_statisticsTimeStamp
_steeringAxis
_step:
_stickyAxis
_stickyDirection
_stickyMove
_stop
_stopInertia
_stopObservingProgram
_strength
_stretchFactor
_subSpriteKey
_subdivIndexBuffer
_subdivMesh
_subdivMeshInfoBuffer
_subdivVertexBuffer
_subdividedCopyWithSubdivisionLevel:
_subdividedVertexStartIndex
_subdivisionIsAdaptive
_subdivisionLevel
_subdivisionSettings
_subnodeFromIndexPath:
_succeded
_superSamplingFactor
_supersampling
_supportsJitteringSyncRedraw
_surfaceBackedOpenGLContext
_surroundToSelect
_suspensionCompression
_suspensionDamping
_suspensionRestLength
_suspensionStiffness
_switchToFreeViewCamera
_symbolToUnbinder
_syncEntityObjCModel
_syncObjCAnimations
_syncObjCModel
_syncObjCModelAfterC3DIOSceneLoadingWithNodeRef:
_syncTimeWithCoreAnimation
_systemSpawnedOnCollision
_systemSpawnedOnDying
_systemSpawnedOnLiving
_systemTime
_systemTimeAnimationStarted:
_targetDirection
_targetOffset
_targetRelativeToPointOfViewParent
_targetView
_targetedFrameInterval
_targets
_targetsProxy
_technique
_temperature
_temporalAntialiasingEnabled
_tessellationControlShader
_tessellationEvaluationShader
_tessellationFactorBuffer
_tessellationFactorScale
_tessellationVertexDescriptor
_tessellationVertexDescriptorHash
_tessellator
_tessellatorValueForGeometry:
_textInfo
_texture
_textureCache
_textureComponents
_textureDescriptorFromImage:needsMipMap:textureOptions:
_textureProvider
_textureTarget
_textureWithEngineContext:textureSampler:nextFrameTime:
_texturesUsageMask
_timeOffset
_timeStamp
_timeStep
_timedRecordingBuffer
_timedRecordingBufferEnd
_timedRecordingBufferStart
_timedRecordingExpirationTime
_toruspipeRadius
_toruspipeSegmentCount
_torusprimitiveType
_torusradialSpan
_torusringRadius
_torusringSegmentCount
_totalDragWithInertia
_touchMap
_trackedResourcesToHashcode
_transform
_transformUpToDate
_transforms
_transition
_transitionContext
_transitionStartTime
_translateHandles
_translateTo:
_translateToViewPoint:
_translationAllowed
_translationCoef
_translationOrigin
_transparency
_transparencyMode
_transparent
_triangleBufferChain
_triangleCounterBuffer
_truckSensitivity
_tubeheight
_tubeheightSegmentCount
_tubeinnerRadius
_tubeouterRadius
_tubeprimitiveType
_tuberadialSegmentCount
_type
_typeInspector
_unbindFramebuffer:
_unbindValueForSymbol:atLocation:programID:node:renderer:
_uniforms
_unifyNormal
_unifyNormals
_uninterleaveData:count:srcOffset:srcStride:dstStride:
_unprojectPoint:viewport:
_upDir
_upDirIsSet
_upVector
_update:
_updateActionWithEvent:
_updateAffine
_updateAllC3DProgramInputs
_updateArcballOrientation
_updateAssociatedSCNNodeWithGeometrySetter:texturePathProvider:vertexAttributeNamed:materialPropertyNamed:
_updateBackingSize
_updateC3DImageWithContents:
_updateC3DProgramInput:forSymbol:
_updateC3DProgramInputForSymbol:
_updateCloneStateWithEvent:
_updateContentsScaleFactor
_updateCount
_updateEngineCallbacks
_updateFieldOfView
_updateFocalLength
_updateFocusableCache
_updateInertiaAtTime:
_updateMaterialAVPlayer:
_updateMaterialAttachment:
_updateMaterialBorderColor:
_updateMaterialCaptureDevice:
_updateMaterialCaptureDeviceOutputConsumerSource:
_updateMaterialColor:
_updateMaterialFilters
_updateMaterialImage:
_updateMaterialLayer:
_updateMaterialMTLTexture:
_updateMaterialNumber:
_updateMaterialProceduralContents:
_updateMaterialPropertyTransform:
_updateMaterialSKScene:
_updateMaterialSKTexture:
_updateOpacity
_updateParticleC3DImage:
_updatePhysicsFieldsTransforms
_updatePointOfView
_updatePrecomputedLightingEnvironment:
_updateProbes:withProgress:
_updateProjectionMatrixForOrthographicSkyboxRenderingIfNeeded:
_updateResourceManager
_updateRootsVisibility
_updateSelectionWithSelectionFrame:
_updateSystemTimeAndDeltaTimeWithCurrentTime:
_updateTargetsAndInBetween:
_updateTransform
_updateWithManifold:index:point:
_updateWithSystemTime:
_useCustomContainerFrame
_useFallbackCopyKernel
_useFunctionConstants
_useSparseTargets
_usedCount
_usedResources
_usedVolatileMeshElements
_userAnimation
_userDefinedPixelFormat
_userInfo
_userInfoLock
_usesCustomScaleFactor
_usesDeferredShadows
_usesEllipsoidalExtent
_usesIOSurface
_usesModulatedMode
_usesOrthographicProjection
_usesSceneTimeBase
_usesSpecificMainPassClearColorForRenderer:clearColor:
_value
_valueForKey
_valueForKeyLock
_valueForSymbolLock
_valueTransformer
_valuesForUndefinedKeys
_valuesForUndefinedKeysLock
_vectorCount
_vehicle
_vehicleRayCaster
_velocity
_vertexBuffers
_vertexCount
_vertexCountForComputeKernel
_vertexDescriptor
_vertexDescriptorHash
_vertexFunctionName
_vertexShader
_vertexWeightIndexSize
_vertexWeightIndicesBuffer
_videoMirrored
_view
_viewIsOffscreen
_viewLocked
_viewMatrix
_viewedObjectSphere
_viewpointCoordinateSpace
_viewpoints
_viewport
_vignettingIntensity
_vignettingPower
_visibleManipulableItems
_volatileBufferPools
_waitForKeyedAction
_wantsCustomMainPassPostProcessForRenderer:
_wantsExposureAdaptation
_wantsHDR
_wantsSceneRendererDelegationMessages
_wantsScreenSpaceReflection
_wantsSeparateGeometryElements
_weightCount
_weightIndexForTargetNamed:
_weights
_wheelIndex
_white
_whiteBalanceTemperature
_whiteBalanceTint
_whitePoint
_width
_widthSegmentCount
_willBeginInteraction
_willRemoveFromPhysicsWorld
_willRemoveFromPhysicsWorld:
_willRenderScene:
_windowBackingDidChange:
_wireframeProgram
_wireframeRenderer
_world
_worldInitialMatrix
_worldMatrix
_wrapS
_wrapT
_wrapped
_writeSubdivCacheForHash:dataProvider:
_writesToDepthBuffer
_xAlignment
_xAxisToZAxisTransform
_xFov
_xyPlaneToXZPlaneTransform
_xyPlaneToYZPlaneTransform
_yAlignment
_yAxisToZAxisTransform
_yFov
_zAlignment
_zFar
_zFarForSkyboxRenderingProjectionMatrix:defaultZFar:
_zNear
_zoomFactor
absoluteString
acceleration
accelerationConstraint
accelerationStructureSizesWithDescriptor:
acceptsFirstMouse:
acceptsFirstResponder
accessibilityDescription
action
actionForKey:
actionKeys
actionNamed:
activateBackground:
activateFreeCamera
active
adaptativeFrameRate
adaptive
add:
addAnimation:
addAnimation:forKey:
addAnimationPlayer:forKey:
addBehavior:
addCameraNode:
addChild:
addChildNode:
addClient:
addClonesToScene
addCompletedHandler:
addDebugMarker:range:
addEntriesFromDictionary:
addIndex:
addIndexes:
addInput:
addInstance:withName:class:
addItemWithTitle:
addItemWithTitle:action:keyEquivalent:
addItems:toScene:
addLightNode:
addModifierForProperties:atStage:withBlock:
addNodeToSelection:
addNormalsWithAttributeNamed:creaseThreshold:
addObject:
addObjectsFromArray:
addObserver:forKeyPath:options:context:
addObserver:selector:name:object:
addOutput:
addOverride:forKeyPath:
addParticleSystem:
addParticleSystem:withTransform:
addParticlesNode:
addPassResourceBindingsForArgument:
addPhysicsBody:nodeRef:colGroup:colMask:colTest:
addPhysicsFieldNode:
addPresentedHandler:
addRepresentation:
addResourceBindingsForArgument:frequency:needsRenderResource:block:
addSceneAnimation:forKey:target:
addScheduledHandler:
addSubview:
addTrackingArea:
addUIForArrayProperty:ofClass:
addUIForBoolProperty:
addUIForColorProperty:
addUIForContentsProperty:
addUIForFloatProperty:ofClass:
addUIForImageProperty:
addUIForIntProperty:ofClass:
addUIForMat4Property:
addUIForObjectProperty:
addUIForProperty:ofClass:instance:
addUIForVec2Property:
addUIForVec3Property:
addUIForVec4Property:
addUpdateRect:
addedNode:
additive
adjustViewportForRendering:
adjustsShadowProjection
affectedByGravity
affectedByPhysicsFields
alignmentMode
allBehaviors
allObjects
allTargetsFromAnimCodec
allValues
alloc
allocateRegistry
allocatedSize
allocationMenuForClass:propertyName:
allowGPUOptimizedContents
allowedClasses
allowsCameraControl
allowsCreation
allowsResting
allowsReverseTransformation
allowsTranslation
alphaComponent
alternateTitle
ambientOcclusion
anchorPoint
angularDamping
angularRestingThreshold
angularSleepingThreshold
angularVelocityFactor
animation
animationDidStart
animationDidStart:
animationDidStop
animationDidStop:finished:
animationDuration
animationEventWithKeyTime:block:
animationForKey:
animationFromScene:
animationKeys
animationManager
animationPlayerForKey:
animationPlayerRef
animationPlayerWithAnimation:
animationPlayerWithAnimationPlayerRef:
animationPlayerWithSCNAnimation:
animationRef
animationSpeed
animationTimingFunction
animationWithC3DAnimation:
animationWithCAAnimation:
animationWithContentsOfURL:
animationWithKeyPath:
animationWithMDLTransform:
animationWithSCNAnimation:
animations
antialiasingLevels
antialiasingMode
anyObject
aperture
apertureBladeCount
appendBytes:length:
appendData:
appendFormat:
appendImage:withPresentationTime:usingAdaptor:
appendPixelBuffer:withPresentationTime:
appendString:
appliedOnCompletion
applyBlock:
applyBrakingForce:forWheelAtIndex:
applyEngineForce:forWheelAtIndex:
applyForce:atPosition:impulse:
applyForce:impulse:
applyFunction:withContext:
applyTorque:impulse:
applyType:
architecture
archive:contentsForEntryName:
archive:streamForEntryName:
archiveData
archiveStream
archiveToDesktop:
archivedDataWithRootObject:options:
archivedDataWithRootObject:requiringSecureCoding:error:
areBarycentricCoordsSupported
areProgrammableSamplePositionsSupported
areRasterOrderGroupsSupported
areSoftParticlesEnabled
areaExtents
areaPolygonVertices
areaType
argument
argumentBuffersSupport
array
array:didSelect:atIndex:
arrayByAddingObject:
arrayByAddingObjectsFromArray:
arrayEditor
arrayLength
arrayOwnerPath
arrayType
arrayWithCapacity:
arrayWithObject:
arrayWithObjects:
arrayWithObjects:count:
aspectRatio
asset
assetCatalog
assetCatalogForResourceURL:
assetCatalogNamed:
assetCatalogWithURL:
assetWithSCNNode:
assetWithSCNNode:bufferAllocator:
assetWithSCNScene:
assetWithSCNScene:bufferAllocator:
asynchronousResizing
attachment
attenuationEndDistance
attenuationFalloffExponent
attenuationStartDistance
attribute:atIndex:effectiveRange:
attributeForKey:
attributeIndex
attributes
attributesOfItemAtPath:error:
audioBufferFormat
audioEngine
audioEnvironmentNode
audioListener
audioNode
audioPlayer
audioPlayerWithAVAudioNode:
audioPlayerWithSource:
audioPlayers
audioSource
audioSourceNamed:
audioSourceWithAVAudioPCMBuffer:
authoringCamera:
authoringCameraNodes
authoringCameraType
authoringDisplayMask
authoringEnvironment
authoringEnvironment2
authoringEnvironment:didCloneSelection:
authoringEnvironment:didMoveItems:fromTransform:
authoringEnvironment:selectionDidUpdateWithProposedSelection:
authoringEnvironmentCompanionNode
authoringEnvironmentForScene:
authoringEnvironmentForScene:createIfNeeded:
authoringEnvironmentForSceneRenderer:
authoringEnvironmentForSceneRenderer:createIfNeeded:
authoringEnvironmentNode
authoringEnvironmentPresentationNode
authoringLayer
authoringOverlayLayer
autoAdjustCamera
autoSwitchToFreeCamera
autoenablesDefaultLighting
automaticCameraTarget
automaticallyAdjustsShadowProjection
automaticallyAdjustsVideoMirroring
automaticallyAdjustsZRange
automaticallyNotifiesObserversForKey:
autorelease
autoreverses
avPlayer
averageGray
avoidOccluderConstraint
avoidOccluderConstraint:didAvoidOccluder:forNode:
avoidOccluderConstraint:shouldAvoidOccluder:forNode:
avoidOccluderConstraintWithTarget:
avoidsOverLighting
awakeFromNib
axis
axisA
axisB
axle
background
backingScaleFactor
backingSizeForBoundSize:
barycentricCoordsSupported
baseGeometry
baseGeometryBindTransform
becomeCurrentWithPendingUnitCount:
becomeFirstResponder
begin
beginEditingNode:
beginEditingNodes:
beginFrameAtTime:timeStamp:
beginInteraction:withViewport:
beginOrbiting
beginSheetModalForWindow:completionHandler:
beginTime
benchResult
bezierPathWithCGPath:
bezierPathWithOvalInRect:
bias
biasValues
billboardConstraint
bind:toObject:withKeyPath:options:
bindAnimatablePath:toObject:withKeyPath:options:
bindBlock
bindTo:withKeyPath:valueTransformerName:
bindingMode
birthDirection
birthLocation
birthRate
birthRateVariation
blackColor
blackPassEnabled
blendFactor
blendMode
blendOutDuration
blitCommandEncoder
block
bloomIntensity
bloomIteration
bloomIterationCount
bloomIterationSpread
bloomThreshold
blueComponent
bodyA
bodyB
bodyWithType:shape:
boneIndices
boneInverseBindTransforms
boneNode
boneWeights
bones
boolForKey:
boolValue
borderColor
borderColor4
bottomRadius
boundingRectWithSize:options:attributes:
bounds
boxWithWidth:height:length:chamferRadius:
boxWithWidth:height:length:cornerRadius:options:
brightness
btVehicle
buffer
bufferAtIndices:
bufferBytesPerRow
bufferDataSize
bufferDataType
bufferForCommonProfileArgumentNamed:
bufferIndex
bufferOffset
bufferSize
bufferStructType
buildTessellationVertexDescriptorIfNeeded
builtinProperties
bundlePath
bundleURL
bundleWithIdentifier:
bytes
bytesPerComponent
bytesPerIndex
c3dAnimation
c3dDataRepresentation
c3dTimingFunction
cStringUsingEncoding:
caAnimation
cacheObject:withTimestamp:forKey:
cachedTextureWithURL:token:
cachedTextureWithURL:token:didFallbackToDefaultTexture:
camera
cameraAutomaticTargetPoint
cameraControlConfiguration
cameraController
cameraFrustumGeometry
cameraGeometry
cameraInertiaDidEndForController:
cameraInertiaWillStartForController:
cameraNearPlaneGeometry
cameraOrthographicFrustumGeometry
cameraRef
cameraTarget
cameraWillChange
cameraWithCameraRef:
cameraWithMDLCamera:
cameraWithSCNCamera:
canAddChildNode:
canBecomeFocused
canBecomeKeyWindow
canBecomeMainWindow
canDrawConcurrently
canDrawInCGLContext:pixelFormat:forLayerTime:displayTime:
canDrawInOpenGLContext:pixelFormat:forLayerTime:displayTime:
canExportToColladaWithNoDataLoss
canImportFileExtension:
canImportFileUTI:
canRepresentDisplayGamut:
cancel
cancelEdition
cancelPreviousPerformRequestsWithTarget:selector:object:
canceled
capRadius
capitalizedString
capsuleWithCapRadius:height:
capsuleWithRadius:height:options:
capture:
captureDevice
captureDeviceOutputConsumer
captureDeviceOutputConsumerSource
captureDeviceOutputConsumerWithOptions:
captureOutput:didDropSampleBuffer:fromConnection:
captureOutput:didOutputSampleBuffer:fromConnection:
caseInsensitiveCompare:
castsShadow
catalogURL
cell
center
centerOfMassOffset
chainRootNode
chamferMode
chamferProfile
chamferRadius
chamferSegmentCount
changeColor:
channelTargetCounts
channelTargetWeights
charValue
characterAtIndex:
characterIsMember:
characterSetWithCharactersInString:
charactersIgnoringModifiers
charge
chassisBody
checkBounds:
checkResourceIsReachableAndReturnError:
checkUncommittedTransactions
childNodeWithName:
childNodeWithName:recursively:
childNodes
childNodesPassingTest:
childNodesPassingTest:recursively:
childNodesWithAttribute:recursively:
children
class
classNamed:
cleanup:
clear
clearAllForces
clearCache
clearCaches
clearCoat
clearCoatRoughness
clearColor
clearCompiledLibraries
clearCorrectives
clearDepth
clearDrawable
clearRoll
clearSnapIndexes
clearValue
clickCount
clientWillDie:
clone
cloneForManipulators
close
close:
collectOverrides
collectShaderForProgram:hashCode:newVertexFunctionName:newFragmentFunctionName:sourceCodeBlock:additionalFileBlock:
collectedShadersForPid:
colliderNodes
collisionBitMask
collisionCategoryBitMask
collisionImpulse
color
color4
color::::
colorAttachments
colorBufferWriteMask
colorChanged:
colorFringeIntensity
colorFringeStrength
colorGrading
colorMatchBiPlanarPixelBufferWithFormatType:pixelBufferYCbCrMatrix:pixelBufferColorPrimaries:pixelBufferTransferFunction:sourceTextureY:sourceTextureCbCr:sourceColorSpace:destinationColorSpace:destinationTexture:renderContext:
colorMatchSourceTexture:sourceColorSpace:destinationColorSpace:destinationTexture:renderContext:
colorMatchingComputePipelineStateForBiPlanarPixelBufferWithFormatType:pixelBufferYCbCrMatrix:pixelBufferColorPrimaries:pixelBufferTransferFunction:sourceColorSpace:destinationColorSpace:renderContext:
colorMatchingComputePipelineStateForSourceColorSpace:destinationColorSpace:renderContext:
colorPixelFormat
colorSpace
colorUsingColorSpace:
colorWithAlphaComponent:
colorWithCGColor:
colorWithRed:green:blue:alpha:
comboBox:objectValueForItemAtIndex:
commandBuffer
commandBufferDidCompleteWithError:
commandBufferWithDescriptor:
commandQueue
commit
commitConfiguration
commitsOnCompletion
commonInit
commonProfile
commonProfileCacheLibrary
compare:
completed
completedUnitCount
completionHandler
component
componentConformingToProtocol:
componentsJoinedByString:
componentsPerVector
componentsSeparatedByCharactersInSet:
componentsSeparatedByString:
componentsWithURL:resolvingAgainstBaseURL:
computeAutomaticTargetPoint
computeBoundingSphereOmittingFloorsForNode:sphere:
computeCommandEncoder
computeEvaluatorWithContext:srcDesc:dstDesc:duDesc:dvDesc:
computePipelineStateForKernel:
computePipelineStateForKernel:constants:constantsHash:
computePipelineStateForKernel:threadGroupSizeIsMultipleOfThreadExecutionWidth:
computePipelineStateForKernel:withStageDescriptor:stageDescriptorUpdateBlock:constants:constantsHash:
coneWithHeight:topRadius:bottomRadius:options:
coneWithTopRadius:bottomRadius:height:
configureStageInputOutputDescriptor:withDeformerFunction:
conformsToProtocol:
connectionPosition
constantDataAtIndex:
constantPopupChanged:
constantScaleConstraint
constantToString
constrainedEdgeLengthTessellationDrawMeshElement:forMesh:instanceCount:renderContext:
constraintRef
constraints
consumeExtensions:
contactNormal
contactPoint
contactTestBetweenBody:andBody:options:
contactTestBitMask
contactTestWithBody:options:
containerFrame
containsAlpha
containsValueForKey:
contentLayer
contentSize
contents
contentsChanged:
contentsForEntryName:
contentsOfDirectoryAtPath:error:
contentsScale
contentsTransform
contextWithCGLContext:pixelFormat:colorSpace:options:
contextWithMTLDevice:
continueInteraction:withViewport:sensitivity:
continuityValues
continuousCollisionDetection
continuousCollisionDetectionThreshold
contrast
control:didFailToFormatString:errorDescription:
control:didFailToValidatePartialString:errorDescription:
control:isValidObject:
control:textShouldEndEditing:
control:textView:completions:forPartialWordRange:indexOfSelectedItem:
control:textView:doCommandBySelector:
controlTextDidBeginEditing:
controlTextDidChange:
controlTextDidEndEditing:
controller
controllerWithAnimation:
convertPoint:fromView:
convertPointToBacking:
convertPosition:fromNode:
convertPosition:toNode:
convertSizeToBacking:
convertSparsePixelRegions:toTileRegions:withTileSize:alignmentMode:numRegions:
convertSparseTileRegions:toPixelRegions:withTileSize:numRegions:
convertTime:fromLayer:
convertToAdditiveWithBaseGeometry:
convertToSparseWithBaseGeometry:
convertTransform:fromNode:
convertTransform:toNode:
convertVector:fromNode:
convertVector:toNode:
convexSweepTestWithShape:fromTransform:toTransform:options:
copy
copyAnimationChannelForKeyPath:animation:
copyAnimationChannelForKeyPath:property:
copyAnimationPathForKeyPath:animation:
copyC3DImageFromImage:
copyC3DImageFromImage:textureOptions:
copyC3DImageFromImage:textureOptions:wasCached:
copyCGLContextForPixelFormat:
copyCGLPixelFormatForDisplayMask:
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyImageFromC3DImage:
copyItemAtPath:toPath:error:
copyJointBindTransformsInto:maxCount:
copyModifiersFrom:
copyPixelBufferForItemTime:itemTimeForDisplay:
copyPropertiesAtIndex:options:
copyPropertiesFrom:
copyShaderModifiersAndLanguageVersionFrom:
copyTextureByConvertingToCubeMapIfApplicable:engineContext:needsMipmap:
copyWeakRef
copyWithZone:
cornerRadius
cornerSegmentCount
correctiveDriverCountForCorrectiveAtIndex:
correctiveDriverCounts
correctiveDriverIndices
correctiveDriverIndicesForCorrectiveAtIndex:
correctiveInBetweenCounts
correctiveInBetweenWeights
correctives
correctivesAndInBetween
count
countByEnumeratingWithState:objects:count:
countOfChildNodes
countOfMaterials
countOfParticleSystems
countOfScenes
counterSets
cpuCacheMode
createDirectoryAtPath:withIntermediateDirectories:attributes:error:
createDirectoryAtURL:withIntermediateDirectories:attributes:error:
createSnapshot:error:
createSparseIndicesBufferForMorphTarget:withSetupTarget:indicesBuffer:indicesBufferOffset:indexSize:originalToFirstDeindexedTable:computeContext:
createVertexBufferForMorphTarget:withSetupTarget:vertexBuffer:vertexBufferOffset:indicesBuffer:indicesBufferOffset:indexSize:originalToFirstDeindexedTable:computeContext:
cullMode
cumulative
currentAllocatedSize
currentBlitEncoder
currentCommandBuffer
currentComputeEncoder
currentContext
currentEvent
currentFrameHash
currentHandler
currentItem
currentRenderCommandEncoder
currentRenderPassDescriptor
currentState
currentTexture
currentThread
currentTime
currentTransforms
customActionWithDuration:actionBlock:
customMaterialAttributeNames
customMaterialAttributes
customMaterialProperties
customMaterialPropertyNames
cylinderWithRadius:height:
cylinderWithRadius:height:options:
dampingFactor
data
dataByConvertingColorData:colorSpace:newColorSpace:vectorCount:componentsPerVector:bytesPerComponent:dataOffset:dataStride:newDataOffset:newDataStride:
dataByConvertingDoublesToFloats:count:
dataForType:
dataNoCopy
dataOffset
dataSource
dataStart
dataStride
dataType
dataUsingEncoding:
dataWithBytes:length:
dataWithBytesNoCopy:length:
dataWithBytesNoCopy:length:freeWhenDone:
dataWithCapacity:
dataWithContentsOfFile:
dataWithContentsOfFile:options:error:
dataWithContentsOfURL:
dataWithContentsOfURL:options:error:
dataWithInt:
dataWithPointArray:count:bytesPerComponent:
dataWithPropertyList:format:options:error:
dataWithToken:
dataWithVector3Array:count:bytesPerComponent:
deallocateElementAtOffset:
deallocateRegistry
debugDescription
debugOptions
debugQuickLookData
debugQuickLookObject
debugQuickLookObjectWithPointOfView:
decelerationDistance
decimalDigitCharacterSet
decodeArrayOfObjectsOfClass:forKey:
decodeArrayOfObjectsOfClasses:forKey:
decodeBoolForKey:
decodeBytesForKey:returnedLength:
decodeDictionaryWithKeysOfClass:objectsOfClass:forKey:
decodeDictionaryWithKeysOfClasses:objectsOfClasses:forKey:
decodeDoubleForKey:
decodeFloatForKey:
decodeInt32ForKey:
decodeIntForKey:
decodeIntegerForKey:
decodeObjectOfClass:forKey:
decodeObjectOfClasses:forKey:
decodePropertyListForKey:
decrementUsedCount
defaultAuthoringDisplayMask
defaultCStringEncoding
defaultCameraController
defaultCenter
defaultCubeTexture
defaultLibrary
defaultLightingEnvironmentIrradianceTexture
defaultLightingEnvironmentRadianceTexture
defaultManager
defaultProgramUsingTessellation:
defaultShapeForGeometry:
defaultTexture
defaultTexture3D
defaultUICatalogForBundle:
deformedMeshReliesOnFrustum
deformedMeshReliesOnTransforms
deformerClassForMeshlesshGeometry:
deformsControlPointsForMeshlessGeometry:
deindexedToFirstDeindexedTableBufferWithBlitEncoder:indexSizeOut:
deindexedToOriginalTableBufferWithBlitEncoder:indexSizeOut:
del:
delegate
deltaX
deltaY
dependency0NormalBuffer
dependency0PositionBuffer
dependency0TangentBuffer
dependency1NormalBuffer
dependency1PositionBuffer
dependency1TangentBuffer
dependencyBufferForInput:dependencyMesh:
dependencyBufferForInput:dependencyStack:
dependencyNodeAtIndex:
depth
depth24Stencil8PixelFormatSupported
depthPixelFormat
description
destinationTexture
device
deviceDescription
deviceForOptions:
deviceQueue
deviceRef
dictionary
dictionaryRepresentation
dictionaryWithCapacity:
dictionaryWithContentsOfURL:
dictionaryWithDictionary:
dictionaryWithObject:forKey:
dictionaryWithObjects:forKeys:count:
dictionaryWithObjectsAndKeys:
didChangePointOfView
didChangeValueForKey:
didEndSelector
didFinishPlayback
didInstanciateNewElementInArray:
dimensions
direction
disableActions
disablePassesToggle:
disableScreenUpdatesUntilFlush
discretizedStraightLineMaxLength
dispatchThreadgroups:threadsPerThreadgroup:
dispatchThreads:threadsPerThreadgroup:
displacement
displayIDDidChange:
displayLink
displayLinkCallbackShouldReturnImmediately
displayLinkPolicy
displayMask
displayOptions
distanceConstraint
distanceConstraintWithTarget:
distantFuture
documentEnclosingURL
documentURL
doesNotRecognizeSelector:
dofIntensity
dollyToTarget:
doubleClick:
doubleSided
doubleValue
drag
dragField
draggingEntered:
draggingPasteboard
draggingUpdated:
drain
draw:
drawAtPoint:
drawAtPoint:fromRect:operation:fraction:
drawImage:inRect:fromRect:
drawInCGLContext:pixelFormat:forLayerTime:displayTime:
drawInContext:
drawInContext:atTime:
drawInOpenGLContext:pixelFormat:forLayerTime:displayTime:
drawInRect:
drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:
drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset:
drawLineFromPoint:toPoint:color:
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:
drawPrimitives:vertexStart:vertexCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:
drawRect:
drawSceneBackgroundUsingEncoder:commandBuffer:renderPassDescriptor:
drawString:atPoint:color:
drawWithFrame:inView:
drawableResizesAsynchronously
drawableSize
drawsArea
drivenByDefaultNavigationCameraController
drivingNode
dstPositionBuffer
dstTangentBuffer
dump
duration
durationRange
dvt_supportedTypesForPropertyContents
dynamicBody
edgeCreaseIndices
edgeCreases
edgeCreasesElement
edgeCreasesSource
edgeTessellationFactor
editingModeEnabled
editingSpace
editingSpaceChanged
effectSlot
effectSlotCreateIfNeeded:
effectiveEditingSpace
effectiveModifier
electricField
elementCount
elementIndex
elementSize
elementType
emission
emissionDuration
emissionDurationVariation
emitterShape
emittingDirection
emptyShaderCache
enableFreeCamera
enableInertia
enableVBL:
enclosingScrollView
encodeBool:forKey:
encodeBytes:length:forKey:
encodeCommandsInNewCommandBufferUsingBlock:
encodeDouble:forKey:
encodeFloat:forKey:
encodeInt32:forKey:
encodeInt:forKey:
encodeInteger:forKey:
encodeObject:forKey:
encodeToCommandBuffer:sourceTexture:destinationTexture:
encodeWithCoder:
encodedData
encodedLength
endDragging
endDraggingWithVelocity:
endEncoding
endFrame
endFrameForEngineContext:
endInteraction:withViewport:velocity:
endOrbiting
engineNotificationQueue
enqueueCommandForObject:immediateTransactionBlock:
entity
entriesPassingTest:
entryNames
entryPoint
entryWithID:withClass:
entryWithIdentifier:withClass:
enumerateBodiesUsingBlock:
enumerateChildNodesUsingBlock:
enumerateHierarchyUsingBlock:
enumerateKeysAndObjectsUsingBlock:
enumerateLinesUsingBlock:
enumerateNodesUsingBlock:
enumerateObjectsUsingBlock:
enumeratorAtPath:
error
errorWithDomain:code:userInfo:
euler
eulerAngles
eventBlock
eventHandler
eventHandlerWantsRedraw
exception
exclusive
executionHandler
expandItem:
exportAs:
exportAsCOLLADAOperationWithDestinationURL:attributes:delegate:didEndSelector:userInfo:
exportAsMovieOperationWithDestinationURL:size:attributes:delegate:didEndSelector:userInfo:
exportAssetToURL:error:
exposure
exposureAdaptationBrighteningSpeedFactor
exposureAdaptationDarkeningSpeedFactor
exposureAdaptationDuration
exposureAdaptationHistogramRangeHighProbability
exposureAdaptationHistogramRangeLowProbability
exposureAdaptationMode
exposureOffset
extendedSRGBColorSpace
extent
extraLayerMeshesWithDrivingMesh0:drivingMesh1:
extrusionDepth
fStop
fStopAnimation
faceCount
faceIndex
faceIndexing
faceTopology
fadeInDuration
fadeInWithDuration:
fadeOpacityBy:duration:
fadeOpacityTo:duration:
fadeOutWithDuration:
farVisibilityDistance
features
field
fieldGeometry
fieldOfView
fieldOfViewOrientation
fileExistsAtPath:
fileName
fileSystemRepresentation
fileURLWithPath:
fileURLWithPath:isDirectory:
fill
fillMode
fillsBackward
fillsForward
filterPropertyName:ofClass:
filteringMode
finalMesh
finalizeDecodeConstraint:
finishDecoding
finishEncoding
finishWritingWithCompletionHandler:
finished
firstIndex
firstMaterial
firstMipmapInTail
firstObject
firstResponder
fixedTimeStep
flagsChanged:
flatness
flattenedClone
flattenedCopy
float3Value
float4Value
floatForKey:
floatValue
floor
floorRef
floorWithOptions:
flush
flushBuffer
flushGraphics
focalBlurSampleCount
focalDistance
focalDistanceAnimation
focalLength
focalLengthAnimation
focalSize
focusBehavior
focusDistance
focusNode:
focusNodes:
fogColor
fogDensityExponent
fogEndDistance
fogStartDistance
font
fontName
fontWithName:size:
forceAsyncShaderCompilation
forceBackFaceCasters
forcesBackFaceCasters
format
formatDescriptions
fractionCompleted
fragmentArguments
fragmentFunction
fragmentFunctionName
fragmentShader
frame
frameA
frameB
frameBufferBindings
frameNodes:
frameRate
frameworkLibrary
freeAxes
freeCamera
freezeButton
frequency
friction
frictionSlip
fromValue
frontFaceStencil
frontVector
frontVectorWithPointOfView:
frozen
functionNames
functionType
functionWithCAMediaTimingFunction:
functionWithControlPoints::::
functionWithName:
functionWithTimingMode:
fxContext
gamma
generateAmbientOcclusionTextureWithQuality:attenuationFactor:objectsToConsider:vertexAttributeNamed:materialPropertyNamed:
generateAmbientOcclusionVertexColorsWithQuality:attenuationFactor:objectsToConsider:vertexAttributeNamed:
generateBindingsForPipeline:withReflection:program:material:geometry:pass:
generateLightMapTextureWithQuality:lightsToConsider:objectsToConsider:vertexAttributeNamed:materialPropertyNamed:
generateLightMapVertexColorsWithLightsToConsider:objectsToConsider:vertexAttributeNamed:
generateMipmapsForTexture:
generatorWithProfile:allowingHotReload:
geodesic
geometry
geometryBindTransform
geometryDescription
geometryElementAtIndex:
geometryElementCount
geometryElementWithBuffer:primitiveType:primitiveCount:bytesPerIndex:
geometryElementWithBuffer:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:
geometryElementWithData:primitiveType:primitiveCount:bytesPerIndex:
geometryElementWithData:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:
geometryElementWithMDLSubmesh:
geometryElementWithMeshElementRef:
geometryElements
geometryForLightType:
geometryIndex
geometryModificationCount
geometryRef
geometryShader
geometrySourceChannels
geometrySourceForSemantic:
geometrySourceWithBuffer:vertexFormat:semantic:vertexCount:dataOffset:dataStride:
geometrySourceWithColorComponents:count:hasAlpha:colorSpace:
geometrySourceWithData:semantic:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:
geometrySourceWithMDLVertexAttribute:mesh:
geometrySourceWithMeshSourceRef:
geometrySourceWithNormals:count:
geometrySourceWithTextureCoordinates:count:
geometrySourceWithVertices:count:
geometrySourcesForSemantic:
geometryType
geometryWithGeometryRef:
geometryWithMDLMesh:
geometryWithMDLMesh:options:
geometryWithMDLMesh:submesh:options:
geometryWithSources:elements:
geometryWithSources:elements:sourceChannels:
getBackgroundGPUPriority
getBoundingBox
getBoundingBoxMin:max:
getBoundingSphere
getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:
getBytes:bytesPerRow:fromRegion:mipmapLevel:
getC3DImageRef
getControlPointAtIndex:values:
getDefaultSamplePositions:count:
getDouble4x4Array:maxCount:
getFloat3Array:maxCount:
getFloat4x4Array:maxCount:
getFloatArray:maxCount:
getFloatArray:maxCount:atTime:
getFloatQuaternionArray:maxCount:
getFrustum:withViewport:
getObjects:range:
getRed:green:blue:alpha:
getTimes:maxCount:
getUniqueStageDescriptor:
getValue:size:
getValues:forAttribute:forVirtualScreen:
gimbalLockEnabled
gimbalLockMode
gimbalLockVector
glID
glTextureCache
glTextureId
globalGLSharedContext
globalMetalDevice
globalObject
gobo
gpuAddress
gpuResourceID
grainIntensity
grainIsColored
grainScale
grainSlice
grainTexture
graphicalSelectionEnabled
graphicsContextWithBitmapImageRep:
graphicsContextWithCGContext:flipped:
greenComponent
gridUnit
groundAlbedo
groundColor
group:
groupWithActions:
halfExtent
handleBindingOfBufferNamed:frequency:usingBlock:
handleBindingOfSymbol:usingBlock:
handleEvent:forProperties:withBlock:
handleFailureInFunction:file:lineNumber:description:
handleFailureInMethod:object:file:lineNumber:description:
handleReport:data:
handleUnbindingOfSymbol:usingBlock:
hardwareFilter
hasActions
hasAlpha
hasCommonProfilePrecompiledFunctions
hasCustomProjectionTransform
hasFreeElementsLeft
hasInterleavedIndicesChannels
hasNewPixelBufferForItemTime:
hasPreciseScrollingDeltas
hasPrefix:
hasReferenceToPhysicsBody:
hasSuffix:
hasUnifiedMemory
hash
hashCodeForSource:macros:
hazardTrackingMode
headless
heap
heapAccelerationStructureSizeAndAlignWithDescriptor:
heapAccelerationStructureSizeAndAlignWithSize:
heapBufferSizeAndAlignWithLength:options:
heapOffset
heapTextureSizeAndAlignWithDescriptor:
height
heightSegmentCount
hemispheric
hidden
hide
hideSpriteKitOverlaysToggled:
highDynamicRangeCompression
hitTest:
hitTest:options:
hitTestResultsFromHitTestResultRef:
hitTestWithSegmentFromPoint:toPoint:options:
horizonElevation
horizontalMaximumAngle
ibPreferredRenderingAPI
ibSceneName
ibWantsMultisampling
identifier
identifiersOfEntriesWithClass:
idleDuration
idleDurationVariation
iesTextureForProfile:renderContext:
image
imageContentsWithPasteboard:
imageFromTexture
imageNamed:
imageRepWithCIImage:
imageRepWithData:
imageSequenceAnimationMode
imageSequenceColumnCount
imageSequenceFrameRate
imageSequenceInitialFrame
imageSequenceInitialFrameVariation
imageSequenceRowCount
imageToEncodeForProposedImage:userInfo:
imageWithPath:
imageWithURL:
immediateMode
immediateModeRestrictedContext
inBetweenTargetsForCorrectiveAtIndex:
inBetweenTargetsForTargetAtIndex:
inBetweenWeights
inBetweenWeightsForCorrectiveAtIndex:
inBetweenWeightsForTargetAtIndex:
incrementUsedCount
incremental
index
indexAtPosition:
indexBuffer
indexBufferIndex
indexCount
indexGreaterThanIndex:
indexOfChildNode:
indexOfObject:
indexOfObjectPassingTest:
indexOfRefraction
indexOfSelectedItem
indexSet
indexSetWithIndex:
indexType
indexesOfObjectsPassingTest:
indicesChannelCount
inertiaEnabled
inertiaRunning
infoDictionary
infoWithSemantic:options:
iniWithBlock:
iniWithLibraryURL:
init
initAllowingHotReload:
initByReferencingFile:
initByReferencingURL:
initForJavascript:
initForReadingFromData:error:
initForReadingWithData:secure:
initForWritingWithMutableData:
initOrientationInWorldSpace:withBlock:
initParametersIfNeededForDeformedNode:
initParametersIfNeededWithDrivingNodeRef:deformedNodeRef:
initParametersIfNeededWithInnerLayerNodeRef:outerLayerNodeRef:deformedNodeRef:
initPositionInWorld:withBlock:
initPresentationCameraWithCameraRef:
initPresentationGeometryWithGeometryRef:
initPresentationLightWithLightRef:
initPresentationMaterialPropertyWithModelProperty:
initPresentationMaterialWithMaterialRef:
initPresentationMorpherWithMorphRef:
initPresentationNodeWithNodeRef:
initPresentationParametricGeometryWithParametricGeometryRef:
initPresentationShapeGeometryWithShapeGeometryRef:
initPresentationSystemWithSystemRef:
initPresentationTechniqueWithTechniqueRef:
initPresentationTextGeometryWithTextGeometryRef:
initRequiringSecureCoding:
initThroughSCNKitBridgeWithURL:options:error:
initThroughSCNKitBridgeWithURL:preserveTopology:error:
initWithAVAudioNode:
initWithAVAudioPCMBuffer:
initWithAnimationPlayerRef:
initWithArray:
initWithAssetWriterInput:sourcePixelBufferAttributes:
initWithAttributes:
initWithBitmapDataPlanes:pixelsWide:pixelsHigh:bitsPerSample:samplesPerPixel:hasAlpha:isPlanar:colorSpaceName:bytesPerRow:bitsPerPixel:
initWithBlock:frequency:needsRenderResource:
initWithBody:anchor:
initWithBody:axis:anchor:
initWithBody:frame:
initWithBodyA:anchorA:bodyB:anchorB:
initWithBodyA:axisA:anchorA:bodyB:axisB:anchorB:
initWithBodyA:frameA:bodyB:frameB:
initWithBuffer:elementSize:
initWithBuffer:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:
initWithBuffer:vertexFormat:semantic:vertexCount:dataOffset:dataStride:
initWithBufferAllocator:
initWithBytes:length:encoding:
initWithBytesNoCopy:length:
initWithBytesNoCopy:length:freeWhenDone:
initWithC3DAnimation:
initWithCAAnimation:
initWithCGImage:
initWithCGImage:size:
initWithCGPath:transform:
initWithCString:encoding:
initWithCachedObject:options:
initWithCameraRef:
initWithCapacity:
initWithChainRootNode:
initWithCharacter:
initWithChassisBody:wheels:
initWithCoder:
initWithContent:options:
initWithContentsOfURL:options:error:
initWithData:
initWithData:options:
initWithData:options:error:
initWithData:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:
initWithData:semantic:colorSpace:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:
initWithData:semantic:vectorCount:componentType:componentCount:dataOffset:dataStride:
initWithData:topLeftOrigin:name:dimensions:rowStride:channelCount:channelEncoding:isCube:
initWithDelegate:
initWithDescription:size:arrayLength:
initWithDevice:error:
initWithDevice:fixedSizeElement:buffersize:name:
initWithDevice:sigma:
initWithDeviceRef:
initWithDictionary:copyItems:
initWithDrivingNode:deformedNode:bindingMode:bindingTransform:drivingNodeUVChannel:deformedNodeUVChannel:
initWithEntryNames:contents:properties:options:
initWithEntryNames:dataProvider:options:
initWithFXPass:technique:
initWithFileNamed:
initWithFileNamed:inBundle:
initWithFloorGeometryRef:
initWithFormat:arguments:
initWithFormat:shareContext:
initWithFrame:
initWithFrame:options:
initWithGeometry:resourceManager:
initWithGeometry:thresholdMode:lod:
initWithGeometry:thresholdMode:thresholdValue:
initWithGeometryRef:
initWithIndexes:length:
initWithIndexesInRange:
initWithInnerLayerNode:outerLayerNode:deformedNode:bindingMode:bindingTransform:
initWithInnerLayerNode:outerLayerNode:parameters:
initWithInt:
initWithKeyOptions:valueOptions:capacity:
initWithLayer:
initWithLightRef:
initWithMTLTexture:options:
initWithMaterialRef:
initWithMediaType:outputSettings:
initWithMeshElement:
initWithMeshSource:
initWithMeshlessGeometry:outputs:deformDataKind:finalDataKind:resourceManager:computeContext:
initWithMorphRef:
initWithName:channelEncoding:textureDimensions:turbidity:sunElevation:upperAtmosphereScattering:groundAlbedo:
initWithName:indexBuffer:indexCount:indexType:geometryType:material:topology:
initWithName:scatteringFunction:
initWithName:semantic:
initWithNibName:bundle:
initWithNodeRef:
initWithObjects:
initWithObjects:count:
initWithObjectsAndKeys:
initWithOptions:
initWithOwner:
initWithPage:allocator:
initWithParametricGeometryRef:
initWithParent:andCustomName:
initWithParent:propertyType:
initWithParticleSystemRef:
initWithPasteboard:
initWithPath:manager:
initWithPath:options:error:
initWithPixelBufferAttributes:
initWithProfile:
initWithQueue:screen:policy:block:
initWithRect:options:owner:userInfo:
initWithRenderer:size:attributes:outputURL:
initWithSCNAnimation:
initWithScene:
initWithScene:attributes:outputURL:
initWithSceneRef:
initWithServiceName:
initWithShareContext:
initWithSize:
initWithSkinnerRef:
initWithString:attributes:
initWithTechniqueRef:
initWithTextGeometryRef:
initWithTexture:size:flipped:colorSpace:
initWithTimingFunctionRef:
initWithTitle:
initWithTitle:action:keyEquivalent:
initWithToken:
initWithType:component:
initWithType:data:
initWithType:shape:
initWithURL:
initWithURL:fileType:error:
initWithURL:offset:length:
initWithURL:options:
initWithURL:resolvingAgainstBaseURL:
initWithUTF8String:
initWithVertexBuffers:vertexCount:descriptor:submeshes:
initWithView:
initializationHandler
initialize
innerConeAngle
innerRadius
inputBias
inputMode
inputOrigin
inputProperty
inputScale
inputStreamWithData:
inputTextureWithName:
inputsCount
insertChildNode:atIndex:
insertMaterial:atIndex:
insertObject:atIndex:
insertObject:inChildNodesAtIndex:
insertObject:inMaterialsAtIndex:
insertObject:inParticleSystemsAtIndex:
insertString:atIndex:
insideTessellationFactor
inspectCamera:
instance
instanceDidChange
instanceMethodSignatureForSelector:
instanceNewElementInArray:withPropertyName:
instanceWillChange
instancesRespondToSelector:
intValue
integerForKey:
integerValue
intensity
interfaceWithProtocol:
interleavedIndicesChannels
invalidate
invalidateCameraTarget
inverseKinematicsConstraintWithChainRootNode:
invocationWithMethodSignature:
invokeWithTarget:
iosurface
iosurfacePlane
irradianceData
irradianceTextureForEnvironmentTexture:renderContext:applySH:
irradianceTextureForPrecomputedLightingEnvironment:
isARepeat
isASTCPixelFormatsSupported
isAborting
isAbsolutePath
isActive
isAdaptive
isAdditive
isAffectedByGravity
isAliasable
isAnimated
isAnimationForKeyPaused:
isAppliedOnCompletion
isAsynchronous
isBlackPassEnabled
isCancelled
isCube
isCumulative
isCustom
isDepth24Stencil8PixelFormatSupported
isDirectionInvertedFromDevice
isDoubleSided
isDragging
isDrawableAvailable
isEditingSubComponent
isEnabled
isEqual:
isEqualTo:
isEqualToDictionary:
isEqualToString:
isExclusive
isFileURL
isFocusInteractionEnabled
isFramebufferOnly
isFull
isGeodesic
isHandlingKeyboard
isHeadless
isHemispheric
isHidden
isHittable
isIncremental
isInertiaRunning
isJitteringEnabled
isKindOfClass:
isLightingEnabled
isLitPerPixel
isLoaded
isLowPower
isMainThread
isMemberOfClass:
isNodeInsideFrustum:withPointOfView:
isNodeManipulator
isOpaque
isPaused
isPausedForEditing
isPausedOrPausedByInheritance
isPlaying
isPositional
isPresentationInstance
isReadyForMoreMediaData
isRelative
isRemovable
isRemovedOnCompletion
isResting
isRotated
isScreenSpace
isSelectedForSegment:
isShareable
isSparse
isSubclassOfClass:
isTemporalAntialiasingEnabled
isUndefined
isUserInteractionEnabled
isVertexAmplificationEnabled
isWrapped
isolate:
issueWithShadable:entryPoint:effectiveModifier:message:line:type:
item
itemArray
itemAtRow:
itemTimeForHostTime:
ivarsOfItem:
javaScriptActionWithDuration:script:
javaScriptActionWithScript:duration:
jitter
jitteringEnabled
joint
jointAnimation
jointBindTransforms
jointForNode:
jointPaths
jointRestTransforms
jointWithBody:anchor:
jointWithBody:axis:anchor:
jointWithBody:frame:
jointWithBodyA:anchorA:bodyB:anchorB:
jointWithBodyA:axisA:anchorA:bodyB:axisB:anchorB:
jointWithBodyA:frameA:bodyB:frameB:
joints
jsChildNodesWithAttribute:
jsConstructor
jump
jumpSpeed
keepTargetDirection
keyDown:
keyForNodeAttributes
keyPathDst
keyPathSrc
keyPathsForValuesAffectingEulerAngles
keyPathsForValuesAffectingFieldOfView
keyPathsForValuesAffectingFocalLength
keyPathsForValuesAffectingOrientation
keyPathsForValuesAffectingPosition
keyPathsForValuesAffectingRotation
keyPathsForValuesAffectingTransform
keyPathsForValuesAffectingValueForKey:
keyTimes
keyUp:
keys
kinematicBody
label
lastFrameTime
lastItem
lastObject
lastPathComponent
launch
launchImagePicker
launchMonitor:
layer
layer:shouldInheritContentsScale:fromWindow:
layerContentsScaleFactor
layerSizeInPixels
layerToFocusForRenderedLayer:
layout
lazyMTKTextureLoader
length
lengthSegmentCount
lensShift
levelOfDetailWithGeometry:screenSpaceRadius:
levelOfDetailWithGeometry:worldSpaceDistance:
levelsOfDetail
libraryForDevice:
libraryForProgramDesc:completionHandler:
libraryForSourceCode:options:
light
lightBufferBindings
lightEmissionRadiusFactor
lightProbeWithSCNLight:node:
lightRef
lightType
lightWithLightRef:
lightWithMDLLight:
lightWithMDLLightProbe:
lightWithSCNLight:
lightingEnvironment
lightingModelName
line
lineRangeForRange:
linearGravityField
linearRestingThreshold
linearSleepingThreshold
linkCustomPropertyWithParent:andCustomName:
litPerPixel
load
loadAction
loadIfNeeded
loadNibNamed:owner:topLevelObjects:
loadSceneAtURL:options:withReply:
loadTextures
loaded
loadingPolicy
local
localCoordinates
localFront
localNormal
localRight
localRotateBy:
localTranslateBy:
localizedDescription
localizedStringForKey:value:table:
location
locationInWindow
locationNumber
lock
lockFocusIfCanDraw
lockLayout
locksAmbientWithDiffuse
logs
longValue
lookAt:up:localFront:
lookAtConstraintWithTarget:
lookAtWith:target:
lookUpFoundInstance
lookUpKey
lookUpKeyForObjectNamed:class:
loops
lowLatency
lowPower
magFilter
magneticField
magnification
magnificationFilter
magnifyWithEvent:
main
mainBundle
mainPassColorTextureAtIndex:
mainScreen
makeAliasable
makeBackingLayer
makeCurrentContext
makeFirstResponder:
makeKeyAndOrderFront:
makeReadOnlyBuffersWithBaseGeometry:baseMesh:blitEncoder:
manipulator
mappingChannel
markAsFinished
mass
matchesDescription:size:arrayLength:
matchesInString:options:range:
matchesRenderPassDescriptor:
material
materialAttachmentWithGLKTextureInfo:
materialFace
materialModificationCount
materialNamed:
materialPropertyWithContents:
materialRef
materialRefCreateIfNeeded
materialWithColor:
materialWithContents:
materialWithMDLMaterial:
materialWithMDLMaterial:options:
materialWithMaterialRef:
materialWithName:
materialWithSCNMaterial:
materials
matrix
matrixWithNoRoll:
maxAllowedRotationAngle
maxAllowedRotationAngleForJoint:
maxAnisotropy
maxArgumentBufferSamplerCount
maxTessellationFactor
maxTextureHeight2D
maxTextureWidth2D
maxThreadgroupMemoryLength
maxThreadsPerThreadgroup
maxTotalThreadsPerThreadgroup
maxValue
maxViewportCount
maximumAngularLimit
maximumAngularLimit1
maximumAngularLimit2
maximumConcurrentCompilationTaskCount
maximumDrawableCount
maximumEdgeLength
maximumHorizontalAngle
maximumLinearAcceleration
maximumLinearLimit
maximumLinearVelocity
maximumPointScreenSpaceRadius
maximumShadowDistance
maximumSuspensionForce
maximumSuspensionTravel
maximumTime
maximumTwistAngle
maximumVerticalAngle
menu
menuItemForInstance:propertyName:
meshBindTransform
meshElement
meshForDeformedTopology
meshSource
meshWithSCNGeometry:
meshWithSCNGeometry:bufferAllocator:
metalDevice
metalLayer
metalTexture
metalTextureWithEngineContext:textureSampler:nextFrameTime:status:
metalness
minFilter
minValue
minificationFilter
minimumAngularLimit
minimumHorizontalAngle
minimumLanguageVersion
minimumLinearLimit
minimumLinearTextureAlignmentForPixelFormat:
minimumPointScreenSpaceRadius
minimumTextureBufferAlignmentForPixelFormat:
minimumTime
minimumVerticalAngle
mipFilter
mipmapLevelCount
mkSemantic
mlDelegate
modelTransform
modelTypeChanged:
modifierFlags
momentumPhase
monospacedSystemFontOfSize:weight:
morphIncrementallyWithComputeContext:positions:normals:
morphRef
morphSparseWithComputeContext:positions:normals:
morpherWithMDLMesh:
morpherWithMorphRef:
motionBlurIntensity
motorMaximumForce
motorMaximumTorque
motorTargetAngularVelocity
motorTargetLinearVelocity
mouseDown:
mouseDragged:
mouseLocation
mouseLocationOutsideOfEventStream
mouseMoved:
mouseUp:
movabilityHint
moveBy:duration:
moveByX:y:z:duration:
moveItemAtPath:toPath:error:
moveItemAtURL:toURL:error:
moveTo:duration:
moveToTransform:
moveToX:y:z:duration:
mtlTexture
multiply
mutableBytes
mutableChildNodes
mutableCopy
mutableCopyWithZone:
mutableData
mutableGeometrySourcesForSemantic:
mutableMaterials
mutateGeometrySourcesWithSemantics:usingBlock:
name
namedTextureWithName:scaleFactor:
navigationCameraController
nearVisibilityDistance
needsRenderResource
needsUpdate
newAccelerationStructureWithDescriptor:
newAccelerationStructureWithSize:
newArgumentEncoderWithArguments:
newArgumentEncoderWithBufferBinding:
newBinaryArchiveWithDescriptor:error:
newBufferForDataKind:meshSource:dataType:forStageInputOutputDescriptor:usePrivateStorageMode:outStride:
newBufferForDataKind:positionSource:normalSource:positionDataType:normalDataType:forStageInputOutputDescriptor:usePrivateStorageMode:outStride:outPositionOffset:outNormalOffset:
newBufferWithBytes:length:options:
newBufferWithBytesNoCopy:length:options:deallocator:
newBufferWithData:type:
newBufferWithLength:options:
newCommandQueueWithDescriptor:
newCommandQueueWithMaxCommandBufferCount:
newComputePipelineStateForDesc:library:
newComputePipelineStateWithDescriptor:options:completionHandler:
newComputePipelineStateWithFunction:completionHandler:
newComputePipelineStateWithFunction:error:
newComputePipelineStateWithFunction:options:completionHandler:
newComputePipelineStateWithFunction:options:reflection:error:
newComputePipelineStateWithFunctionName:
newComputePipelineStateWithFunctionName:constantValues:
newComputePipelineStateWithFunctionName:library:
newCounterSampleBufferWithDescriptor:error:
newCubemapTextureForLatlongTexture:pixelFormat:engineContext:needsMipmap:
newDefaultLibrary
newDefaultLibraryWithBundle:error:
newDeformerInstanceForNode:outputs:computeVertexCount:context:
newDepthStencilStateWithDescriptor:
newDynamicLibrary:error:
newEvent
newFence
newFunctionWithName:
newFunctionWithName:constantValues:error:
newHeapWithDescriptor:
newIOCommandQueueWithDescriptor:error:
newIOFileHandleWithURL:compressionMethod:error:
newIOFileHandleWithURL:error:
newIOHandleWithURL:compressionMethod:error:
newIOHandleWithURL:error:
newInstanceMenuClicked:
newLibraryWithData:error:
newLibraryWithFile:error:
newLibraryWithSource:options:completionHandler:
newLibraryWithSource:options:error:
newLibraryWithStitchedDescriptor:completionHandler:
newLibraryWithStitchedDescriptor:error:
newLibraryWithURL:error:
newLogStateWithDescriptor:error:
newNodeAtPath:type:
newPipelineStateConfiguratorForMeshElement:patchType:device:
newPropertyWithName:type:role:
newRadianceTextureForEnvironmentTexture:engineContext:cpuAccessible:commandBuffer:
newRasterizationRateMapWithDescriptor:
newRemoteBufferViewForDevice:
newRemoteTextureViewForDevice:
newRenderPipelineStateWithDescriptor:completionHandler:
newRenderPipelineStateWithDescriptor:error:
newRenderPipelineStateWithDescriptor:options:reflection:error:
newRenderPipelineStateWithMeshDescriptor:options:completionHandler:
newRenderPipelineStateWithMeshDescriptor:options:reflection:error:
newRenderPipelineStateWithTileDescriptor:options:completionHandler:
newRenderPipelineStateWithTileDescriptor:options:reflection:error:
newResidencySetWithDescriptor:error:
newSamplerStateWithDescriptor:
newSceneWithURL:
newSharedEvent
newSharedEventWithHandle:
newSharedTextureHandle
newSharedTextureWithHandle:
newSubBufferForAllocator:
newSubBufferWithBytes:length:renderContext:
newSubmeshWithGeometryData:indexBufferLength:interleaved:channelCount:channelIdx:bytesPerIndex:indexType:geometryType:allocator:indexCount:topology:
newSubmeshWithSCNGeometryElement:bufferAllocator:
newSubmeshWithSCNGeometryElement:bufferAllocator:positionSourceChannel:
newSubmeshWithUniquedIndexData:andSCNGeometryElement:bufferAllocator:
newTextureForDevice:
newTextureUsingMTKTextureLoaderWithData:options:
newTextureUsingMTKTextureLoaderWithURL:options:
newTextureViewWithPixelFormat:
newTextureViewWithPixelFormat:textureType:levels:slices:
newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:
newTextureWithContentsOfURL:options:error:
newTextureWithData:options:error:
newTextureWithDescriptor:
newTextureWithDescriptor:iosurface:plane:
newTextureWithDescriptor:offset:bytesPerRow:
newTextureWithName:scaleFactor:bundle:options:error:
newlineCharacterSet
next
nextDrawable
nextEventMatchingMask:untilDate:inMode:dequeue:
nextFrameTime
nextKeyView
nextObject
node
node:propertyWithName:type:role:
nodeA
nodeAtPoint:recursive:
nodeB
nodeBufferBindings
nodeManipulatorItemWithNode:screenSize:
nodeWithGeometry:
nodeWithMDLAsset:
nodeWithMDLAsset:options:
nodeWithMDLObject:
nodeWithMDLObject:masterObjects:sceneNodes:skinnedMeshes:skelNodesMap:asset:options:
nodeWithMDLObject:options:
nodeWithNodeRef:
nodesInsideFrustumWithPointOfView:
noiseFieldWithSmoothness:animationSpeed:
normal
null
numberOfItemsInComboBox:
numberOfRows
numberWithDouble:
numberWithFloat:
numberWithInt:
numberWithInteger:
numberWithShort:
numberWithUnsignedChar:
numberWithUnsignedInt:
numberWithUnsignedInteger:
numberWithUnsignedLong:
numberWithUnsignedLongLong:
numberWithUnsignedShort:
objCType
object
objectAtIndex:
objectAtIndexedSubscript:
objectClass
objectController
objectForKey:
objectForKeyedSubscript:
objectHandleClicked:
objectInAllBehaviorsAtIndex:
objectInChildNodesAtIndex:
objectInChildNodesWithAttribute:firstOnly:
objectInChildNodesWithName:
objectInMaterialsAtIndex:
objectPathWithString:
objectWithName:class:
objectWithSCNNode:
objectWithSCNNode:bufferAllocator:
observeValueForKeyPath:ofObject:change:context:
observer
occluderCategoryBitMask
offscreenRendererWithContext:size:
offscreenRendererWithDevice:sceneRendererDelegate:size:
offscreenRendererWithDevice:size:
offset
opaque
open
openFile:
openGLContext
openGLContextForPixelFormat:
openGLPixelFormatForDisplayMask:
orangeColor
orderFrontColorPanel:
orderedSet
orderedSetWithCapacity:
orderedSetWithObject:
orientation
orientationConstraintInWorldSpace:withBlock:
orientationDirection
orientationOffset
originalToFirstDeindexedTableBufferWithBlitEncoder:indexSizeOut:
orthographicScale
outerConeAngle
outerRadius
outgoingPointOfView
outgoingScene
outlineView:acceptDrop:item:childIndex:
outlineView:child:ofItem:
outlineView:dataCellForTableColumn:item:
outlineView:didAddRowView:forRow:
outlineView:didClickTableColumn:
outlineView:didRemoveRowView:forRow:
outlineView:draggingSession:endedAtPoint:operation:
outlineView:draggingSession:willBeginAtPoint:forItems:
outlineView:heightOfRowByItem:
outlineView:isGroupItem:
outlineView:isItemExpandable:
outlineView:itemForPersistentObject:
outlineView:mouseDownInHeaderOfTableColumn:
outlineView:namesOfPromisedFilesDroppedAtDestination:forDraggedItems:
outlineView:nextTypeSelectMatchFromItem:toItem:forString:
outlineView:numberOfChildrenOfItem:
outlineView:objectValueForTableColumn:byItem:
outlineView:pasteboardWriterForItem:
outlineView:persistentObjectForItem:
outlineView:rowViewForItem:
outlineView:selectionIndexesForProposedSelection:
outlineView:setObjectValue:forTableColumn:byItem:
outlineView:shouldEditTableColumn:item:
outlineView:shouldExpandItem:
outlineView:shouldReorderColumn:toColumn:
outlineView:shouldSelectItem:
outlineView:shouldSelectTableColumn:
outlineView:shouldShowCellExpansionForTableColumn:item:
outlineView:shouldShowOutlineCellForItem:
outlineView:shouldTrackCell:forTableColumn:item:
outlineView:shouldTypeSelectForEvent:withCurrentSearchString:
outlineView:sizeToFitWidthOfColumn:
outlineView:sortDescriptorsDidChange:
outlineView:tintConfigurationForItem:
outlineView:typeSelectStringForTableColumn:item:
outlineView:updateDraggingItemsForDrag:
outlineView:userCanChangeVisibilityOfTableColumn:
outlineView:userDidChangeVisibilityOfTableColumns:
outlineView:validateDrop:proposedItem:proposedChildIndex:
outlineView:viewForTableColumn:item:
outlineView:willDisplayCell:forTableColumn:item:
outlineView:willDisplayOutlineCell:forTableColumn:item:
outlineView:writeItems:toPasteboard:
outlineViewColumnDidMove:
outlineViewColumnDidResize:
outlineViewItemDidCollapse:
outlineViewItemDidExpand:
outlineViewItemWillCollapse:
outlineViewItemWillExpand:
outlineViewSelectionDidChange:
outputTextureWithName:
outputURL
overlaySKScene
overrides
owner
ownerWillDie
panSensitivity
panel
parallaxCenterOffset
parallaxCorrectionEnabled
parallaxExtentsFactor
parameters
params
parent
parentForItem:
parentItem
parentNode
parentRelativeLevel
parentRelativeSlice
parentTexture
parentView
parentWillDie:
parseSpecialKey:withPath:intoDestination:
parseSpecialKey:withPath:intoDestination:remainingPath:
particleAngle
particleAngleVariation
particleAngularVelocity
particleAngularVelocityVariation
particleBounce
particleBounceVariation
particleCharge
particleChargeVariation
particleColor
particleColorVariation
particleDiesOnCollision
particleFriction
particleFrictionVariation
particleGeometries
particleImage
particleIntensity
particleIntensityVariation
particleLifeSpan
particleLifeSpanVariation
particleMass
particleMassVariation
particlePropertyControllerWithAnimation:
particleSize
particleSizeVariation
particleSystem
particleSystemNamed:
particleSystemNamed:inDirectory:
particleSystemRef
particleSystemWithParticleSystemRef:
particleVelocity
particleVelocityVariation
particlesGeometry
passAtIndex:
passBufferBindings
passDescriptor
patchFont:
patchType
path
pathByAppendingPropertyComponent:
pathByMakingURLRelativeToCatalog:
pathComponents
pathControlClicked:
pathControlItemForInstance:
pathExtension
pathForResource:ofType:
pathForResource:ofType:inDirectory:
pathItems
pause
pause:
pauseAnimationForKey:
pauseDisplayLink
paused
pausesIncomingScene
pausesOutgoingScene
peerCount
peerGroupID
peerIndex
penetrationDistance
performConsistencyCheck
performDragOperation:
performPresentationInstanceQueriesInScene:usingBlock:
performSelector:
performSelector:onTarget:
performSelector:withObject:
performSelector:withObject:afterDelay:
performSelector:withObject:withObject:
performanceStatisticsForPid:
phase
physicsBody
physicsCollisionsEnabled
physicsField
physicsShape
physicsWorld
physicsWorld:didBeginContact:
physicsWorld:didEndContact:
physicsWorld:didUpdateContact:
pipeRadius
pipeSegmentCount
pipelineStateHashForMeshElement:patchType:
pivot
pixelFormat
pixelsHigh
pixelsWide
planeWithWidth:height:
planeWithWidth:height:options:
play
play:
playAudioSource:waitForCompletion:
playbackSpeed
player
pointOfCulling
pointOfCullingComboBox
pointOfView
pointOfViewComboBox
pointSize
pointValue
pointerValue
popDebugGroup
popUpContextMenu:withEvent:forView:
popupChanged:
position
positionConstraintInWorldSpace:withBlock:
positionOffset
positional
postCommandWithContext:object:applyBlock:
postCommandWithContext:object:key:applyBlock:
postCommandWithContext:object:key:subscriptIndex:derivedKeyPath:applyBlock:
postCommandWithContext:object:key:subscriptKey:derivedKeyPath:applyBlock:
postCommandWithContext:object:keyPath:applyBlock:
postMorphingDeformers
postNotificationName:object:
postNotificationName:object:userInfo:
postProjectionTransform
postSkinningDeformers
precomputedLightingEnvironment
precomputedLightingEnvironmentContentsWithData:error:
precomputedLightingEnvironmentContentsWithURL:error:
precomputedLightingEnvironmentDataForContents:device:error:
preferredFilenameExtension
preferredFrameRate
preferredFramesPerSecond
prefersGL3
prepareContentOfPopUpButton
prepareForDragOperation:
prepareObjects:withCompletionHandler:
prepareRendererAtIndex:withScene:renderSize:pointOfView:parentRenderer:
prepareScene:
prepareSnapToAlignData
prepareSnapToAlignDataIfNeeded
prepareWithTarget:implicitDuration:
preprocessorMacros
presentDrawable:
presentDrawable:afterMinimumDuration:
presentScene:withTransition:incomingPointOfView:completionHandler:
presentationCamera
presentationCapsule
presentationCone
presentationCylinder
presentationGeometry
presentationInstance
presentationLight
presentationMaterial
presentationMaterialProperty
presentationMorpher
presentationNode
presentationPlane
presentationPyramid
presentationSphere
presentationTorus
presentationTube
presentsWithTransaction
preserveScale
pressureChangeWithEvent:
primitiveCount
primitiveRange
primitiveType
privateFunctions
privateRendererOwner
probeEnvironment
probeExtents
probeOffset
probeType
proceduralContents
processInfo
processName
program:bindValueForSymbol:atLocation:programID:renderer:
program:handleError:
program:unbindValueForSymbol:atLocation:programID:renderer:
programIsOpaque:
programWithHashCode:engineContext:trackedResource:introspectionDataPtr:
programWithLibrary:
programWithNode:withMaterial:
programmableSamplePositionsSupported
progress
progressWithTotalUnitCount:
projectPoint:
projectPoints:count:
projection
projectionDirection
projectionMatrix
projectionTransform
projectionTransformWithViewportSize:
properties
propertiesForEntryName:
propertyControllers
propertyListWithData:options:format:error:
propertyName
propertyNamed:
propertyType
propertyWithSemantic:
pvrtcData
pyramidWithWidth:height:length:options:
quaternion
query
queryItems
queuedFrameCount
radialGravityField
radialSegmentCount
radialSpan
radianceData
radianceTextureForEnvironmentTexture:engineContext:commandBuffer:
radianceTextureForPrecomputedLightingEnvironment:
radius
range
rangeAtIndex:
rangeOfString:
rangeOfString:options:
rangeOfString:options:range:
rangeValue
rasterOrderGroupsSupported
rasterizationRateMap
rate
ratioForTime:
rayTestWithSegmentFromPoint:toPoint:options:
reParsePasses
readWriteTextureSupport
readonly
readsFromDepthBuffer
reason
recommendedMaxWorkingSetSize
reconfigureIfNeededWithContext:programHashCodeRequirements:
recordGraph
recordGraph:
recordGraphInView:
rectValue
recursivePathsForResourcesOfType:inDirectory:
redComponent
referenceCount
referenceName
referenceNodeName
referenceNodeWithURL:
referenceSceneName
referenceURL
reflectionCategoryBitMask
reflectionFallOffEnd
reflectionFallOffStart
reflectionFalloffEnd
reflectionFalloffStart
reflectionSampleCount
reflective
reflectivity
registerArgument:frequency:block:
registerArgument:frequency:needsRenderResource:block:
registerForDraggedTypes:
registerPlayerIfNeeded:
registerSemantic:withBlock:
registerShadableArgumentBindingBlockForBuffers:textures:samplers:
registerUserBlockTrampoline:
registryID
regularExpressionWithPattern:options:error:
rejectFirstResponder
relativePath
releaseProgramForResource:
reloadData
reloadPipelinesIfNeeded
remoteObjectProxy
remoteStorageBuffer
remoteStorageTexture
removable
remove
removeActionForKey:
removeAllActions
removeAllAnimations
removeAllAnimationsWithBlendOutDuration:
removeAllAudioPlayers
removeAllBehaviors
removeAllBindings
removeAllDebugMarkers
removeAllIndexes
removeAllItems
removeAllMaterials
removeAllModifiers
removeAllObjects
removeAllOverrides
removeAllParticleSystems
removeAnimationForKey:
removeAnimationForKey:blendOutDuration:
removeAnimationForKey:fadeOutDuration:
removeAudioPlayer:
removeButton
removeCameraNode:
removeClient:
removeClonesFromScene
removeForKeyPath:
removeFromParentNode
removeFromSuperview
removeIndex:
removeIndexes:
removeItemAtPath:error:
removeItemAtURL:error:
removeItemsFromScene:
removeLastObject
removeLightNode:
removeMaterialAtIndex:
removeModifiersOfStage:
removeObject:
removeObjectAtIndex:
removeObjectClicked:
removeObjectForKey:
removeObjectFromChildNodesAtIndex:
removeObjectFromMaterialsAtIndex:
removeObjectFromParticleSystemsAtIndex:
removeObjectsAtIndexes:
removeObserver:forKeyPath:
removeObserver:forKeyPath:context:
removeObserver:name:object:
removeOutput:
removeParticleSystem:
removeParticlesNode:
removePhysicsBody:handle:
removePhysicsFieldNode:
removeSourceRenderersForEngineContext:
removeTrackingArea:
removedNode:
removedOnCompletion
render
render:toMTLTexture:commandBuffer:bounds:colorSpace:
renderAndAppendWithPresentationTime:usingAdaptor:metalTextureCache:cvQueue:completionBlock:
renderAtTime:
renderAtTime:commandBuffer:viewPoints:
renderAtTime:encoder:commandQueue:passDescriptor:viewPoints:
renderAtTime:encoder:commandQueue:passDescriptor:viewPoints:coordinateSpace:
renderAtTime:viewport:commandBuffer:passDescriptor:
renderAtTime:viewport:encoder:passDescriptor:commandQueue:
renderBufferFormat
renderCommandEncoder
renderCommandEncoderWithDescriptor:
renderContext:commandBufferDidCompleteWithError:
renderContext:didFallbackToDefaultTextureForSource:message:
renderDebugOptions
renderGraphUtils
renderInContext:
renderMovieToURL:size:antialiasingMode:attributes:error:
renderNode:renderer:arguments:
renderPassDescriptor
renderResourceForDeformerStack:node:dataKind:
renderResourceForEffectSlot:withEngineContext:didFallbackToDefaultTexture:
renderResourceForImage:sampler:options:engineContext:didFallbackToDefaultTexture:
renderResourceForImageProxy:sampler:engineContext:didFallbackToDefaultTexture:
renderResourceForMorpher:baseMesh:dataKind:provider:
renderResourceForProgramDesc:renderPassDescriptor:
renderResourceForSkinner:baseMesh:dataKind:provider:
renderTargetArrayLength
renderToFramebuffer:shouldClear:
renderToTexture:commandQueue:
renderToTexture:computeCommandHandler:blitCommandHandler:completionHandler:helper:
renderToTexture:computeCommandHandler:blitCommandHandler:helper:
renderTransition:withInputTexture:outputTexture:inputTextureSize:outputTextureSize:time:
renderTransition:withInputTexture:outputTexture:time:encoder:pass:commandQueue:
renderWithCommandBuffer:viewPoints:
renderWithCommandBuffer:viewpoints:coordinateSpace:
renderWithEncoder:pass:commandQueue:
renderWithEngineContext:textureSampler:nextFrameTime:
renderWithEngineContext:textureSampler:nextFrameTime:status:
renderWithViewport:commandBuffer:passDescriptor:
renderer
renderer:commandBufferDidCompleteWithError:
renderer:didApplyAnimationsAtTime:
renderer:didApplyConstraintsAtTime:
renderer:didFallbackToDefaultTextureForSource:message:
renderer:didSimulatePhysicsAtTime:
renderer:updateAtTime:
renderer:willRenderScene:atTime:
rendererContextForTextureSourceWithEngineContext:
rendererDelegate
rendererDidChange:
rendererForSceneRenderer:
rendererOptionsPanelForView:
rendererWithContext:options:
rendererWithDevice:options:
renderingAPI
renderingAPIForOptions:
renderingAlgorithm
renderingMode
renderingOrder
rendersContinuously
rendersIntoMaterial
repeatAction:count:
repeatActionForever:
repeatCount
repeatDuration
replaceBytesInRange:withBytes:
replaceCharactersInRange:withString:
replaceChildNode:with:
replaceMaterial:with:
replaceMaterialAtIndex:withMaterial:
replaceObjectAtIndex:withObject:
replaceObjectInChildNodesAtIndex:withObject:
replaceObjectInMaterialsAtIndex:withObject:
replaceObjectInParticleSystemsAtIndex:withObject:
replaceOccurrencesOfString:withString:options:range:
replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:
replaceRegion:mipmapLevel:withBytes:bytesPerRow:
replicatesOrientation
replicatesPosition
replicatorConstraint
representationUsingType:properties:
representedObject
requestMediaDataWhenReadyOnQueue:usingBlock:
requiredInputs
requiresMainThreadUpdates
requiresSecureCoding
reset
resetToTransform:
resetTransform
resetVolatileMeshElements
resetVolatileMeshes
resignCurrent
resignFirstResponder
resolveInsideArchiveWithAssetNamed:
resolveInstanceMethod:
resolveTexture
resolvedBackgroundColorDidChange:
resolver
resourcePath
respondsToCollision
respondsToSelector:
restitution
restoreGraphicsState
resume
resumeAnimationForKey:
resumeDisplayLink
retain
retainCount
reverbBlend
reverseObjectEnumerator
reverseTransformedValue:
reversedAction
rightMouseDragged:
rightMouseUp:
ringRadius
ringSegmentCount
rollAroundTarget:
rollBy:aroundScreenPoint:viewport:
rollCameraSpaceBy:withPoint:viewport:
root
rootNode
rootNodeForLayer:
rootResource
rotateBy:aroundTarget:
rotateByAngle:aroundAxis:duration:
rotateByX:Y:
rotateByX:y:z:duration:
rotateOf:
rotateToAxisAngle:
rotateToAxisAngle:duration:
rotateToX:y:z:duration:
rotateToX:y:z:duration:shortestUnitArc:
rotateWithEvent:
rotateWithVector:mode:
rotation
rotationRepresentation
rotationSensitivity
rotations
roughness
rowForItem:
runAction:
runAction:afterActionWithKey:
runAction:completionHandler:
runAction:forKey:
runAction:forKey:completionHandler:
runAction:onChildNodeWithName:
runBench:
runBlock:
runModal
sRGBColorSpace
sRGBTexture
sWrapMode
sampleCount
sampleDistributedShadowMaps
sampleTimestamps:gpuTimestamp:
samplerAtIndices:
saturation
save
saveAndCreateUSDZPackageWithURL:
saveGraphicsState
saveInitialSelection
savePanel
scale
scaleBy:duration:
scaleMode
scaleOffset
scaleTo:duration:
scales
scatteringFunction
scene
scene:nodeAtPath:type:
sceneAtIndex:options:
sceneAtIndex:options:error:
sceneCount
sceneDatabase
sceneDidChange
sceneFileTypes
sceneNamed:
sceneNamed:options:
sceneRef
sceneRenderer
sceneSource
sceneSourceOptions
sceneSourceRef
sceneSourceWithData:options:
sceneSourceWithURL:options:
sceneTime
sceneTypes
sceneWillDie
sceneWithClass:options:error:
sceneWithClass:options:statusHandler:
sceneWithData:atIndex:options:
sceneWithData:options:
sceneWithMDLAsset:
sceneWithMDLAsset:options:
sceneWithOptions:error:
sceneWithSceneRef:
sceneWithURL:
sceneWithURL:atIndex:options:
sceneWithURL:options:
sceneWithURL:options:error:
scheduledTimerWithTimeInterval:repeats:block:
scheme
scn_C3DColorIgnoringColorSpace:success:
scn_backingLayer
scn_colorComponentsForModelIO
scn_colorWithC3DColor:
scn_colorWithLinearDisplayP3Red:green:blue:alpha:
scn_colorWithLinearSRGBRed:green:blue:alpha:
scn_colorWithModelIORed:green:blue:alpha:options:
scn_compressedDataUsingCompressionAlgorithm:
scn_decodeArrayOfObjectsOfClass:containingNestedContainersForKey:
scn_decodeArrayOfObjectsOfClass:forKey:
scn_decodeArrayOfObjectsOfClasses:containingNestedContainersForKey:
scn_decodeArrayOfObjectsOfClasses:forKey:
scn_decodeDictionaryWithKeysOfClass:objectsOfClass:containingNestedContainersForKey:
scn_decodeDictionaryWithKeysOfClass:objectsOfClass:forKey:
scn_decodeDictionaryWithKeysOfClasses:objectsOfClasses:containingNestedContainersForKey:
scn_decodeDictionaryWithKeysOfClasses:objectsOfClasses:forKey:
scn_enumerateKeysAndValuesUsingBlock:
scn_inLiveResize
scn_indexedDataDecodingDeltaWithBytesPerIndex:
scn_indexedDataDecodingHighWatermarkWithBytesPerIndex:
scn_indexedDataDecodingTrianglePairsWithBytesPerIndex:
scn_indexedDataEncodingDeltaWithBytesPerIndex:
scn_indexedDataEncodingHighWatermarkWithBytesPerIndex:
scn_indexedDataEncodingTrianglePairsWithBytesPerIndex:
scn_setBackingLayer:
scn_stringByReplacingCharactersInRanges:withStrings:
scn_uncompressedDataUsingCompressionAlgorithm:
scope
screen
screenSize
screenSpace
screenSpaceAdaptiveTessellationDrawMeshElement:forMesh:instanceCount:renderContext:
screenSpaceAmbientOcclusionDepthThreshold
screenSpaceAmbientOcclusionDownSample
screenSpaceAmbientOcclusionIntensity
screenSpaceAmbientOcclusionNormalThreshold
screenSpaceAmbientOcclusionRadius
screenSpaceAmbientOcclusionSampleCount
screenSpaceRadius
screenSpaceReflectionDepthThreshold
screenSpaceReflectionMaximumDistance
screenSpaceReflectionSampleCount
screenSpaceReflectionStride
scrollPoint:
scrollRowToVisible:
scrollWheel:
seed
seekSlider
seekStep
seekStepper
segmentCount
selectAuthoringDisplayMask:
selectCamera:
selectInstance:propertyName:
selectItemAtIndex:
selectNode:
selectNodes:
selectPass:
selectPointOfCulling:
selectRenderingDebugOptions:
selectRowIndexes:byExtendingSelection:
selectTarget:
selectedItem
selectedItems
selectedNode
selectedNodes
selectedRow
selecting
selection
selectionDidChange:
selectionIsReadonly
selectionShouldChangeInOutlineView:
selectionWillChange
self
selfIllumination
selfIlluminationOcclusion
semantic
semanticForSymbol:
semanticsCount
sendAction:to:
sensorAspect
sensorHeight
sensorVerticalAperture
sequence:
sequenceWithActions:
setAcceleration:
setAccessibilityDescription:
setAction:
setActive:
setAdaptativeFrameRate:
setAdaptive:
setAdditive:
setAdjustsShadowProjection:
setAffectedByGravity:
setAffectedByPhysicsFields:
setAlignment:
setAlignmentMode:
setAllTargetsFromAnimCodec:
setAllowedFileTypes:
setAllowsBrowsing:
setAllowsCameraControl:
setAllowsCreation:
setAllowsResting:
setAllowsTickMarkValuesOnly:
setAllowsTranslation:
setAlphaBlendOperation:
setAlternateMode:
setAlternateTitle:
setAnchorA:
setAnchorB:
setAngularDamping:
setAngularRestingThreshold:
setAngularSleepingThreshold:
setAngularVelocity:
setAngularVelocityFactor:
setAnimation:
setAnimationDidStart:
setAnimationDidStop:
setAnimationDuration:
setAnimationEvents:
setAnimationSpeed:
setAnimationTimingFunction:
setAnimations:
setAntialiasingLevel:
setAntialiasingMode:
setAperture:
setApertureBladeCount:
setAppliedOnCompletion:
setAreaPolygonVertices:
setAreaType:
setArgument:
setArgument:atIndex:
setArgumentBuffer:offset:
setArgumentEncoder:
setArguments:
setAssetCatalog:
setAsynchronous:
setAsynchronousLoading:
setAsynchronousResizing:
setAttachment:
setAttenuationEndDistance:
setAttenuationFalloffExponent:
setAttenuationStartDistance:
setAttribute:forKey:
setAttributedTitle:
setAttributes:
setAudioListener:
setAuthoringCamera:forView:
setAuthoringCameraType:
setAuthoringDisplayMask:
setAuthoringEnvironmentCompanionNode:
setAuthoringEnvironmentNode:
setAuthoringEnvironmentPresentationNode:
setAutoAdjustCamera:
setAutoSwitchToFreeCamera:
setAutoenablesDefaultLighting:
setAutoenablesItems:
setAutomaticCameraTarget:
setAutomaticTarget:
setAutomaticallyAdjustsShadowProjection:
setAutomaticallyAdjustsVideoMirroring:
setAutomaticallyAdjustsZRange:
setAutoresizingMask:
setAutoreverses:
setAvPlayer:
setAvoidsOverLighting:
setAxisA:
setAxisB:
setAxle:
setBackgroundColor:
setBackgroundGPUPriority:
setBackingScaleFactor:
setBaked:
setBaseGeometry:
setBaseGeometryBindTransform:
setBeginTime:
setBezelStyle:
setBias:
setBiasValues:
setBindBlock:
setBirthDirection:
setBirthLocation:
setBirthRate:
setBirthRateVariation:
setBlackPassEnabled:
setBlendColorRed:green:blue:alpha:
setBlendInDuration:
setBlendMode:
setBlendOutDuration:
setBlendingEnabled:
setBlock:
setBloomBlurRadius:
setBloomIntensity:
setBloomIteration:
setBloomIterationCount:
setBloomIterationSpread:
setBloomThreshold:
setBoneInverseBindTransforms:
setBones:
setBoolValue:
setBordered:
setBottomRadius:
setBoundingBoxMin:max:
setBounds:
setBoxType:
setBrightness:
setBuffer:
setBuffer:offset:atIndex:
setBufferOffset:atIndex:
setBufferSize:
setBuffers:offsets:withRange:
setButtonType:
setByAddingObject:
setByAddingObjectsFromArray:
setByAddingObjectsFromSet:
setByValue:
setBytes:length:atIndex:
setC3dAnimation:
setCGLContextObj:
setCalculationMode:
setCamera:
setCameraTarget:
setCanDrawConcurrently:
setCanceled:
setCapRadius:
setCapSegmentCount:
setCaptureDevice:
setCaptureDeviceOutputConsumerSource:
setCategoryBitMask:
setCenter:
setCenterOfMassOffset:
setChainRootNode:
setChamferProfile:
setChamferRadius:
setChamferSegmentCount:
setChannelTargetCounts:
setChannelTargetWeights:
setCharge:
setClass:forClassName:
setClearColor:
setClearDepth:
setClipsToBounds:
setColliderNodes:
setCollisionBitMask:
setCollisionCategoryBitMask:
setColor:
setColorBufferWriteMask:
setColorFringeIntensity:
setColorFringeStrength:
setColorSpace:
setColorspace:
setCommitsOnCompletion:
setCompleted:
setCompletedUnitCount:
setCompletionBlock:
setComponent:
setComputeFunction:
setComputePipelineState:
setConnectionPosition:
setConnectionWithTargetPaths:
setConstantToString:
setConstantValue:type:atIndex:
setConstraintRef:
setContactDelegate:
setContactTestBitMask:
setContainerFrame:
setContent:
setContents:
setContentsScale:
setContentsTransform:
setContext:
setContinuityValues:
setContinuousCollisionDetectionThreshold:
setContrast:
setController:
setCornerRadius:
setCornerSegmentCount:
setCppAction:
setCpuCacheMode:
setCullMode:
setCumulative:
setCurrentContext:
setCurrrentPass:
setDamping:
setDampingFactor:
setData:
setDataSource:
setDebugOptions:
setDecelerationDistance:
setDecodingFailurePolicy:
setDefaults
setDelegate:
setDepth:
setDepthAttachment:
setDepthAttachmentPixelFormat:
setDepthBias:slopeScale:clamp:
setDepthClipMode:
setDepthCompareFunction:
setDepthFailureOperation:
setDepthResolveFilter:
setDepthStencilPassOperation:
setDepthStencilState:
setDepthWriteEnabled:
setDestinationRGBBlendFactor:
setDevice:
setDictionaryMetadataWithKey:dictionaryKey:value:
setDidEndSelector:
setDidFinishPlayback:
setDirection:
setDisableActions:
setDisableOverlays:
setDiscretizedStraightLineMaxLength:
setDisplaysWhenScreenProfileChanges:
setDofIntensity:
setDouble3Value:
setDouble4x4Array:count:
setDouble4x4Value:
setDouble4x4Value:atTime:
setDoubleAction:
setDrawableResizesAsynchronously:
setDrawableSize:
setDrawsArea:
setDrivenByDefaultNavigationCameraController:
setDuration:
setDurationRange:
setEdgeCreasesElement:
setEdgeCreasesSource:
setEdgeMode:
setEdgeTessellationFactor:
setEditable:
setEditingModeEnabled:
setEditingSpace:
setElementIndex:
setEmissionDuration:
setEmissionDurationVariation:
setEmitterShape:
setEmittingDirection:
setEnableFreeCamera:
setEnableInertia:
setEnabled:
setEndTime:
setEngineNotificationQueue:
setEntity:
setError:
setErrorOptions:
setEuler:
setEventBlock:
setEventHandler:
setException:
setExclusive:
setExecutionHandler:
setExpectsMediaDataInRealTime:
setExposure:
setExposureAdaptationBrighteningSpeedFactor:
setExposureAdaptationDarkeningSpeedFactor:
setExposureAdaptationDuration:
setExposureAdaptationHistogramRangeHighProbability:
setExposureAdaptationHistogramRangeLowProbability:
setExposureAdaptationMode:
setExposureOffset:
setExtrusionDepth:
setFStop:
setFaceCount:
setFaceTopology:
setFadeInDuration:
setFadeOutDuration:
setFalloffExponent:
setFarVisibilityDistance:
setFastMathEnabled:
setFeatures:
setFieldOfViewOrientation:
setFillMode:
setFillsBackward:
setFillsForward:
setFilterChannel:
setFilters:
setFinished:
setFirstMaterial:
setFixedTimeStep:
setFlatness:
setFloat2Array:count:
setFloat3Array:count:
setFloat3Array:count:atTime:
setFloat3Value:atTime:
setFloatArray:count:
setFloatArray:count:atTime:
setFloatValue:
setFloatValue:atTime:
setFlyModeVelocity:
setFocalBlurRadius:
setFocalBlurSampleCount:
setFocalDistance:
setFocalSize:
setFocusBehavior:
setFocusDistance:
setFogColor:
setFogDensityExponent:
setFogEndDistance:
setFogStartDistance:
setFont:
setForceBackFaceCasters:
setForcesBackFaceCasters:
setFormat:
setFormatter:
setFragmentBuffer:offset:atIndex:
setFragmentBufferOffset:atIndex:
setFragmentBytes:length:atIndex:
setFragmentFunction:
setFragmentFunctionName:
setFragmentLinkedFunctions:
setFragmentSamplerState:atIndex:
setFragmentShader:
setFragmentTexture:atIndex:
setFragmentTextures:withRange:
setFrame:
setFrameA:
setFrameB:
setFrameBufferBindings:
setFrameRate:
setFrameSize:
setFramebufferOnly:
setFreeAxes:
setFrequency:
setFresnelExponent:
setFriction:
setFrictionSlip:
setFromValue:
setFrontFacingWinding:
setFrozen:
setGamma:
setGeodesic:
setGeometry:
setGeometryModificationCount:
setGeometryShader:
setGimbalLockEnabled:
setGimbalLockMode:
setGimbalLockVector:
setGizmo:
setGlID:
setGlTextureCache:
setGlobalGLSharedContext:
setGlobalMetalDevice:
setGrainIntensity:
setGrainIsColored:
setGrainScale:
setGrainSlice:
setGrainTexture:
setGraphicalSelectionEnabled:
setGravity:
setHalfExtent:
setHeight:
setHeightSegmentCount:
setHidden:
setHittable:
setHorizonElevation:
setHorizontalMaximumAngle:
setIESProfileURL:
setIESProfileURL:resolvedURL:
setIbPreferredRenderingAPI:
setIbWantsMultisampling:
setIdentifier:
setIdleDuration:
setIdleDurationVariation:
setImage:
setImageFrameStyle:
setImageSequenceAnimationMode:
setImageSequenceColumnCount:
setImageSequenceFrameRate:
setImageSequenceFrameRateVariation:
setImageSequenceInitialFrame:
setImageSequenceInitialFrameVariation:
setImageSequenceRowCount:
setImmediateMode:
setImmediateModeRestrictedContext:
setIndexOfRefraction:
setInertiaEnabled:
setInertiaFriction:
setInfluenceFactor:
setInitializationHandler:
setInnerConeAngle:
setInputBias:
setInputMode:
setInputPrimitiveTopology:
setInputProperty:
setInputScale:
setInsideTessellationFactor:
setInstance:
setIntArray:count:
setIntensity:
setInteractionMode:
setInterruptionHandler:
setInvalidationHandler:
setIrradianceData:
setIsFront:
setIsJoint:
setIsLocal:
setItem:
setJitteringEnabled:
setJoint:
setJumpSpeed:
setKeepTargetDirection:
setKeyCodeConfiguration:
setKeyPath:
setKeyPathDst:
setKeyPathSrc:
setKeyTimes:
setLabel:
setLanguageVersion:
setLastFrameTime:
setLaunchPath:
setLayer:
setLayerContentsPlacement:
setLength:
setLengthSegmentCount:
setLensShift:
setLevel:
setLevelsOfDetail:
setLibrary:
setLibraryProvider:
setLight:
setLightBufferBindings:
setLightEmissionRadiusFactor:
setLightType:
setLightingEnabled:
setLightingModelName:
setLineBreakMode:
setLinearRestingThreshold:
setLinearSleepingThreshold:
setLoadAction:
setLoadingPolicy:
setLocal:
setLocalFront:
setLocksAmbientWithDiffuse:
setLookUpFoundInstance:
setLookUpKey:
setLoops:
setMTLTextureCache:
setMagFilter:
setMagnificationFilter:
setMappingChannel:
setMass:
setMaterial:
setMaterialFace:
setMaterialModificationCount:
setMaterials:
setMatrix4:
setMatrix:
setMaxAllowedRotationAngle:
setMaxAllowedRotationAngle:forJoint:
setMaxAnisotropy:
setMaxTessellationFactor:
setMaxValue:
setMaximumAngularLimit1:
setMaximumAngularLimit2:
setMaximumAngularLimit:
setMaximumCircleOfConfusion:
setMaximumDistance:
setMaximumEdgeLength:
setMaximumExposure:
setMaximumHorizontalAngle:
setMaximumLinearAcceleration:
setMaximumLinearLimit:
setMaximumLinearVelocity:
setMaximumPointScreenSpaceRadius:
setMaximumShadowDistance:
setMaximumSuspensionForce:
setMaximumSuspensionTravel:
setMaximumTwistAngle:
setMaximumVerticalAngle:
setMetadataWithKey:value:
setMinFilter:
setMinificationFilter:
setMinimumAngularLimit:
setMinimumDistance:
setMinimumExposure:
setMinimumHorizontalAngle:
setMinimumLanguageVersion:
setMinimumLinearLimit:
setMinimumPointScreenSpaceRadius:
setMinimumVerticalAngle:
setMipFilter:
setMipmapLevelCount:
setMkSemantic:
setMlDelegate:
setMomentOfInertia:
setMorpher:
setMotionBlurIntensity:
setMotorMaximumForce:
setMotorMaximumTorque:
setMotorTargetAngularVelocity:
setMotorTargetLinearVelocity:
setMovabilityHint:
setMovableByWindowBackground:
setMtlTexture:
setName:
setNameFieldStringValue:
setNavigationCameraController:
setNearVisibilityDistance:
setNeedsDisplay:
setNeedsDisplayOnBoundsChange:
setNeedsRenderResource:
setNext:
setNode:
setNodeBufferBindings:
setNodeRef:
setNumberOfTickMarks:
setObject:atIndexedSubscript:
setObject:forKey:
setObject:forKeyedSubscript:
setObjectController:
setObjectPath:
setObjectPathArray:
setOccluderCategoryBitMask:
setOffset:
setOpacity:
setOpaque:
setOpenGLContext:
setOptions:
setOrientationDirection:
setOrientationMode:
setOrientationOffset:
setOrthographicScale:
setOuterConeAngle:
setOutgoingPointOfView:
setOutgoingScene:
setOutputURL:
setOverlaySKScene:
setOverride:forKeyPath:
setOverrides:
setOwnerWithIdentity:
setPanSensitivity:
setParallaxCenterOffset:
setParallaxCorrectionEnabled:
setParallaxExtentsFactor:
setParentView:
setParticleAngle:
setParticleAngleVariation:
setParticleAngularVelocity:
setParticleAngularVelocityVariation:
setParticleBounce:
setParticleBounceVariation:
setParticleCharge:
setParticleChargeVariation:
setParticleColor:
setParticleColorVariation:
setParticleDiesOnCollision:
setParticleFriction:
setParticleFrictionVariation:
setParticleGeometries:
setParticleImage:
setParticleIntensity:
setParticleIntensityVariation:
setParticleLifeSpan:
setParticleLifeSpanVariation:
setParticleMass:
setParticleMassVariation:
setParticleSize:
setParticleSizeVariation:
setParticleVelocity:
setParticleVelocityVariation:
setPassBufferBindings:
setPassDescriptor:
setPath:
setPathItems:
setPaused:
setPaused:nextFrameTimeHint:lastUpdate:
setPausedForEditing:
setPhysicsCollisionsEnabled:
setPhysicsField:
setPhysicsShape:
setPipeRadius:
setPipeSegmentCount:
setPivot:
setPixelBuffer:fromDevice:
setPlaybackSpeed:
setPlayer:
setPlaying:
setPointOfCulling:
setPointOfView:animate:
setPointOfView:updateUpTransform:
setPointSize:
setPosition:
setPositionOffset:
setPositional:
setPostMorphingDeformers:
setPostProjectionTransform:
setPostProjectionTransformScale:
setPostProjectionTransformTranslation:
setPostSkinningDeformers:
setPrecomputedLightingEnvironment:
setPreferredFrameRate:
setPreferredFramesPerSecond:
setPrefersOpenGL:
setPreprocessorMacros:
setPreserveScale:
setPrimitiveRange:
setPrimitiveRanges:
setPrimitiveType:
setPrivateFunctions:
setProbeExtents:
setProbeType:
setProbeUpdateType:
setProceduralContents:
setProgram:
setProgress:
setProjection:
setProjectionDirection:
setProjectionMatrix:
setProjectionTransform:
setPropertyControllers:
setPurgeableState:
setQuaternion:
setQuatfArray:count:atTime:
setQuatfValue:
setQuatfValue:atTime:
setQuery:
setRAddressMode:
setRadialSegmentCount:
setRadialSpan:
setRadianceData:
setRadius:
setRasterSampleCount:
setRasterizationRateMap:
setRate:
setReadMask:
setReadonly:
setReadsFromDepthBuffer:
setReferenceCount:
setReferenceName:
setReferenceNodeName:
setReferenceObject:
setReferenceSceneName:
setReferenceURL:
setReflectionCategoryBitMask:
setReflectionFallOffEnd:
setReflectionFallOffStart:
setReflectionFalloffEnd:
setReflectionFalloffStart:
setReflectionResolutionScaleFactor:
setReflectionSampleCount:
setReflectivity:
setRemoteObjectInterface:
setRemove:
setRemoveButton:
setRemovedOnCompletion:
setRenderPipelineState:
setRenderTargetArrayLength:
setRenderer:
setRendererDelegate:
setRenderingMode:
setRenderingOrder:
setRendersContinuously:
setRendersIntoMaterial:
setRepeatDuration:
setReplicatesOrientation:
setReplicatesPosition:
setReplicatesScale:
setRepresentedObject:
setRequiresSecureCoding:
setResolveSlice:
setResolveTexture:
setResource:ofType:atIndices:
setResourceOptions:
setResourcePath:
setResting:
setRgbBlendOperation:
setRingRadius:
setRingSegmentCount:
setRollingFriction:
setRootNode:
setRootNode:forLayer:
setRotation:
setRotationSensitivity:
setSAddressMode:
setSCNView:
setSampleBuffer:
setSampleBuffer:fromDevice:
setSampleBufferDelegate:queue:
setSamplerState:atIndex:
setSaturation:
setScale:
setScene:
setScene:completionHandler:
setSceneTime:
setScissorRects:count:
setScope:
setScreenSize:
setScreenSpaceAmbientOcclusionBias:
setScreenSpaceAmbientOcclusionDepthThreshold:
setScreenSpaceAmbientOcclusionDownSample:
setScreenSpaceAmbientOcclusionIntensity:
setScreenSpaceAmbientOcclusionNormalThreshold:
setScreenSpaceAmbientOcclusionRadius:
setScreenSpaceAmbientOcclusionSampleCount:
setScreenSpaceReflectionDepthThreshold:
setScreenSpaceReflectionMaximumDistance:
setScreenSpaceReflectionSampleCount:
setSeed:
setSeekStep:
setSegmentCount:
setSelected:forSegment:
setSelecting:
setSelectionIsReadonly:
setSelector:
setSelfIlluminationOcclusion:
setSemantic:
setSemantic:forSymbol:
setSemantic:forSymbol:options:
setSemanticInfos:
setSemanticsCount:
setSensorAspect:
setSensorHeight:
setSensorVerticalAperture:
setShadableBufferBindings:
setShaderModifiers:
setShadowBias:
setShadowCascadeCount:
setShadowCascadeSplittingFactor:
setShadowMapSize:
setShadowMode:
setShadowRadius:
setShadowSampleCount:
setShininess:
setShouldBakeDirectLighting:
setShouldBakeIndirectLighting:
setShouldClearCPUDataAfterUpload:
setShouldMaximizeConcurrentCompilation:
setShouldMorphNormals:
setShouldSnapOnGrid:
setShouldSnapToAlign:
setShouldStream:
setShowsAlpha:
setShowsStatistics:
setSimdEulerAngles:
setSimdOrientation:
setSimdPivot:
setSimdPosition:
setSimdProjectionMatrix:
setSimdRotation:
setSimdScale:
setSimdTarget:
setSimdTransform:
setSimdUp:
setSimdViewMatrix:
setSimdWorldOrientation:
setSimdWorldPosition:
setSimdWorldTransform:
setSize:
setSkScene:
setSkTexture:
setSkeleton:
setSkinner:
setSkipFramesIfNoDrawableAvailable:
setSkipMorphTargets:
setSlice:
setSmoothingMode:
setSmoothness:
setSoftParticlesEnabled:
setSourceAlphaBlendFactor:
setSourceContext:
setSourceFile:
setSourceObject:
setSourceRGBBlendFactor:
setSpeed:
setSpeed:forAnimationKey:
setSphericalHarmonicsCoefficients:
setSpotFalloffExponent:
setSpotInnerAngle:
setSpotOuterAngle:
setSpreadingAngle:
setStackControl:
setStageInRegion:
setStageInputDescriptor:
setStageInputOutputBuffersToComputeEncoder:
setStageInputOutputBuffersToCurrentComputeEncoder
setStageInputOutputBuffersToEncoder:
setStartDelay:
setStartTime:
setState:
setSteeringAngle:forWheelAtIndex:
setSteeringAxis:
setStencilAttachment:
setStencilAttachmentPixelFormat:
setStencilCompareFunction:
setStencilFailureOperation:
setStencilReferenceValue:
setStencilResolveFilter:
setStepFunction:
setStepRate:
setStickyAxis:
setStrength:
setStretchFactor:
setStride:
setString:
setSubdivisionLevel:
setSucceded:
setSuperSampling:
setSurroundToSelect:
setSuspensionCompression:
setSuspensionDamping:
setSuspensionRestLength:
setSuspensionStiffness:
setSwizzle:
setSyncTimeWithCoreAnimation:
setSystemSpawnedOnCollision:
setSystemSpawnedOnDying:
setSystemSpawnedOnLiving:
setTAddressMode:
setTable:
setTarget:
setTargetDirection:
setTargetOffset:
setTargetPosition:
setTargets:
setTargets:withInBetweenTargetCounts:inBetweenWeights:
setTargetsAndInBetweens:inBetweenCounts:inBetweenWeights:correctives:driverCounts:driverIndices:inBetweenCounts:inBetweenWeights:
setTechnique:
setTensionValues:
setTessellationControlPointIndexType:
setTessellationControlShader:
setTessellationEvaluationShader:
setTessellationFactorBuffer:offset:instanceStride:
setTessellationFactorFormat:
setTessellationFactorScale:
setTessellationFactorScaleEnabled:
setTessellationFactorStepFunction:
setTessellationOutputWindingOrder:
setTessellationPartitionMode:
setTexture:
setTexture:atIndex:
setTextureComponents:
setTextureProvider:
setTextureSamplerValue:
setTextures:withRange:
setThreadGroupSizeIsMultipleOfThreadExecutionWidth:
setThreadgroupMemoryLength:atIndex:
setTime:
setTimeOffset:
setTimeStamp:
setTimeStep:
setTimestamp:
setTimingFunction:
setTimingFunctions:
setTimingMode:
setTitle:
setToValue:
setTokenArray:
setTokenValue:
setToolTip:
setTopRadius:
setTransform:
setTransition:
setTransitionStartTime:
setTransparency:
setTransparencyMode:
setTriangleFillMode:
setTruckSensitivity:
setTruncationMode:
setType:
setURLValue:
setUnifiesNormals:
setUp:
setUpAxis:
setUpVector:
setUsage:
setUsedCount:
setUserInfo:
setUsesDefaultMomentOfInertia:
setUsesDeferredShadows:
setUsesDepthPrePass:
setUsesEllipsoidalExtent:
setUsesEuler:
setUsesModulatedMode:
setUsesOrthographicProjection:
setUsesReverseZ:
setUsesSceneTimeBase:
setValue:
setValue:forKey:
setValue:forKeyPath:
setValue:forPassPropertyKey:
setValue:forProperty:
setValue:forSymbolNamed:
setValue:forUndefinedKey:
setValueForKey:optionKey:options:
setValueTransformer:forName:
setValues:
setValues:forParameter:
setVector2:
setVector3:
setVector4:
setVelocity:
setVelocityFactor:
setVertexAmplificationCount:viewMappings:
setVertexAmplificationEnabled:
setVertexBufferOffset:atIndex:
setVertexBuffers:offsets:withRange:
setVertexDescriptor:
setVertexFunction:
setVertexFunctionName:
setVertexLinkedFunctions:
setVertexSamplerState:atIndex:
setVertexShader:
setVertexTexture:atIndex:
setVertexTextures:withRange:
setVerticalMaximumAngle:
setVideoMirrored:
setVideoSettings:
setView:
setViewMatrix:
setViewport:
setViewports:count:
setVignettingIntensity:
setVignettingPower:
setVolume:
setWalkingDirection:
setWantsAdaptiveSubdivision:
setWantsBestResolutionOpenGLSurface:
setWantsDepthOfField:
setWantsExposureAdaptation:
setWantsHDR:
setWantsLayer:
setWantsScreenSpaceReflection:
setWarmupDuration:
setWeakRef:
setWeight:
setWeight:atTargetIndex:
setWeight:forTargetAtIndex:
setWeight:forTargetNamed:
setWeightIncrementalThreshold:
setWeights:
setWhiteBalanceTemperature:
setWhiteBalanceTint:
setWhitePoint:
setWidth:
setWidthSegmentCount:
setWillStartPlayback:
setWithArray:
setWithCapacity:
setWithObject:
setWithSet:
setWorldOrientation:
setWorldPosition:
setWorldTransform:
setWorldUp:
setWrapS:
setWrapT:
setWrapped:
setWriteMask:
setWritesToDepthBuffer:
setXAlignment:
setXFov:
setXMag:
setYAlignment:
setYFov:
setYMag:
setZAlignment:
setZFar:
setZNear:
setZoomFactor:
set_allowsDefaultLightingEnvironmentFallback:
set_antialiasingMode:
set_aspectRatio:
set_collectCompilationErrors:
set_computedLightingEnvironmentMapsPath:
set_deltaTime:
set_disableLinearRendering:
set_drawableSafeAreaInsets:
set_encodeDataAsHalf:
set_ibPreferredRenderingAPI:
set_ibSceneName:
set_ibWantsMultisampling:
set_nextFrameTime:
set_preparePixelFormat:
set_recordWithoutExecute:
set_renderOptions:
set_resourceManagerMonitor:
set_screenTransform:
set_shadowCascadeDebugFactor:
set_shouldForwardSceneRendererDelegationMessagesToPrivateRendererOwner:
set_showsAuthoringEnvironment:
set_sphericalHarmonics:
set_subdivisionSettings:
set_superSamplingFactor:
set_viewport:
set_wantsSceneRendererDelegationMessages:
set_wantsSeparateGeometryElements:
settingsForTransition:atTime:renderIncomingToTexture:renderOutgoingToTexture:renderIncomingToScreen:renderOutgoingToScreen:
setup
setupAuthoringEnv2
setupAuthoringEnvironment
setupClones
setupDisplayLinkOutputHandler:
setupFinalMeshFromBaseMeshWithInfo:
setupFinalMeshFromMeshlessBaseGeometryWithInfo:
setupInitialBuffersWithBasePositionSourceProvider:baseNormalSourceProvider:baseTangentSourceProvider:info:
setupMorphTargetsWithComputeContext:
setupNode
setupParticleMeshEmitter:authoringNode:
setupWithActions:
setupWithComputeContext:
shFromCPU:commandBuffer:
shadable
shadableBufferBindings
shaderCompilationGroup
shaderModifiersArgumentsNames
shadowBias
shadowCascadeCount
shadowCascadeSplittingFactor
shadowColor
shadowMapSize
shadowMode
shadowRadius
shadowSampleCount
shapeSetTargetCounts
shapeSetTargetWeights
shapeWithGeometry:options:
shapeWithNode:options:
shapeWithPath:extrusionDepth:
shapeWithShapes:transforms:
shareable
sharedColorPanel
sharedRegistry
shininess
shortValue
shouldBakeDirectLighting
shouldBakeIndirectLighting
shouldClearCPUDataAfterUpload
shouldFlip
shouldMaximizeConcurrentCompilation
shouldMorphNormals
shouldObserveApplicationStateToPreventBackgroundGPUAccess
shouldSnapOnGrid
shouldSnapToAlign
shouldStream
showManipulators
showModelInspector:
simdConvertPosition:fromNode:
simdConvertPosition:toNode:
simdConvertTransform:fromNode:
simdConvertTransform:toNode:
simdConvertVector:fromNode:
simdConvertVector:toNode:
simdGetBoundingSphereCenter:radius:
simdLocalCoordinates
simdLocalFront
simdLocalRight
simdLocalRotateBy:
simdLocalTranslateBy:
simdLocalUp
simdLookAt:
simdLookAt:up:localFront:
simdModelTransform
simdPivot
simdPosition
simdProjectionMatrix
simdRotateBy:aroundTarget:
simdRotation
simdScale
simdTarget
simdTransform
simdUp
simdViewMatrix
simdWorldCoordinates
simdWorldFront
simdWorldOrientation
simdWorldPosition
simdWorldRight
simdWorldTransform
simdWorldUp
size
sizeValue
skTexture
skeleton
skinnerRef
skinnerWithBaseGeometry:bones:boneInverseBindTransforms:boneWeights:boneIndices:
skinnerWithSkinnerRef:
skipExecute
skipMorphTargets
sliderConstraint
slotName
smoothingMode
smoothness
snapGuideIndexesOnAxis:
snapInfoAtIndex:axis:
snapshot
snapshotAtTime:withSize:antialiasingMode:
snapshotAtTime:withSize:antialiasingMode:error:
snapshotRendererWithSize:
softParticlesEnabled
sortUsingComparator:
sortedArrayUsingComparator:
sortedArrayUsingSelector:
sortingMode
sourceContext
sourceFile
sourceObject
sourceRendererForEngineContext:source:textureSource:targetTexture:
sourceStatus
sparseTileSizeInBytes
sparseTileSizeInBytesForSparsePageSize:
sparseTileSizeWithTextureType:pixelFormat:sampleCount:
sparseTileSizeWithTextureType:pixelFormat:sampleCount:sparsePageSize:
specular
specularDFGDiffuseHammonTextureWithRenderContext:
speed
speedFactor
speedInKilometersPerHour
sphereWithRadius:
sphereWithRadius:options:
sphericalHarmonicsCoefficients
sphericalHarmonicsForEnvironmentTexture:order:commandBuffer:
sphericalHarmonicsLevel
splitInputOutputStructsIfNeededForSourceCode:generatedFromReplacementStrings:perPixelLighting:clipDistanceCount:
spotFalloffExponent
spotInnerAngle
spotOuterAngle
spreadingAngle
springField
srcPositionBuffer
srcTangentBuffer
stackControl
stackSelectionChanged:
stageInputAttributes
stageInputDescriptor
standardUserDefaults
startCollectingPerformanceStatisticsForPid:
startDelay
startRunning
startSessionAtSourceTime:
startTime
startWriting
state
staticBody
status
steeringAxis
stencilAttachment
stencilPixelFormat
stepFunction
stepRate
stickyAxis
stiffness
stop
stop:
stopCollectingPerformanceStatisticsForPid:
stopIfNeeded
stopInertia
stopRunning
stopWithBlendOutDuration:
stopWithFadeOutDuration:
storageMode
storeAction
streamForEntryName:
strength
stretchFactor
stride
string
stringByAppendingFormat:
stringByAppendingString:
stringByDeletingLastPathComponent
stringByDeletingPathExtension
stringByExpandingTildeInPath
stringByReplacingCharactersInRange:withString:
stringByReplacingMatchesInString:options:range:withTemplate:
stringByReplacingOccurrencesOfString:withString:
stringByStandardizingPath
stringValue
stringWithCString:encoding:
stringWithCapacity:
stringWithContentsOfFile:encoding:error:
stringWithContentsOfURL:encoding:error:
stringWithFormat:
stringWithString:
stringWithUTF8String:
strongToStrongObjectsMapTable
structType
subAnimations
subarrayWithRange:
subdataWithRange:
subdivisionLevel
subdivisionScheme
subdivisionSurfaceTessellationDraw:
sublayers
submeshWithSCNGeometryElement:
submeshWithSCNGeometryElement:bufferAllocator:
submeshWithSCNGeometryElement:bufferAllocator:positionSourceChannel:
submeshWithUniquedIndexData:andSCNGeometryElement:bufferAllocator:
submeshes
substringFromIndex:
substringToIndex:
substringWithRange:
subviews
succeded
sunElevation
superclass
supportedFileUTIsForExport
supportedFileUTIsForImport
supportedOutputs
supports32BitFloatFiltering
supports32BitMSAA
supportsBCTextureCompression
supportsBaseVertexInstanceDrawing
supportsCounterSampling:
supportsDepthClipMode
supportsDirection
supportsDynamicLibraries
supportsFeatureSet:
supportsFunctionPointers
supportsFunctionPointersFromRender
supportsLayeredRendering
supportsMSAADepthResolve
supportsMSAAStencilResolve
supportsMetal
supportsNonUniformThreadgroupSize
supportsOffset
supportsPrimitiveMotionBlur
supportsPullModelInterpolation
supportsQueryTextureLOD
supportsRasterizationRateMapWithLayerCount:
supportsRaytracing
supportsRaytracingFromRender
supportsReadWriteTextureCubeArguments
supportsRenderDynamicLibraries
supportsSecureCoding
supportsShaderBarycentricCoordinates
supportsTessellation
supportsTextureCubeArray
supportsTextureSampleCount:
supportsTextureSwizzle
supportsUnalignedVertexFetch
supportsVertexAmplificationCount:
surroundToSelect
suspensionCompression
suspensionDamping
suspensionRestLength
suspensionStiffness
sweepTestFraction
switchToCameraNamed:
switchToNextCamera
syncTimeWithCoreAnimation
synchronizeResource:
systemFontOfSize:
systemFontSizeForControlSize:
systemSpawnedOnCollision
systemSpawnedOnDying
systemSpawnedOnLiving
tWrapMode
table
tableColumns
target
targetOffset
targetPosition
targetShapes
targetsAndInBetween
technique
techniqueBySequencingTechniques:
techniquePanelForView:
techniqueRef
techniqueWithDictionary:
techniqueWithTechniqueRef:
techniquesDidUpdate:
temperature
temporalAntialiasingEnabled
temporaryDirectory
tensionValues
tessellationControlShader
tessellationEvaluationShader
tessellationFactorScale
tessellationPartitionMode
tessellator
tessellatorValueDidChange
tessellatorValueDidChangeForClient:
text
textSize
textWithString:extrusionDepth:
texture2DDescriptorWithPixelFormat:width:height:mipmapped:
textureAtIndices:
textureComponents
textureCoordinate
textureCoordinatesWithMappingChannel:
textureCubeDescriptorWithPixelFormat:size:mipmapped:
textureForSliceIndex:
textureID
textureRect
textureSampler
textureSamplerValue
textureSize
textureSource
textureTarget
textureType
textureWithEngineContext:textureSampler:nextFrameTime:
textureWithName:scaleFactor:bundle:options:error:
threadDictionary
threadExecutionWidth
thresholdMode
thresholdValue
time
timeIntervalSinceReferenceDate
timeJumpWithTarget:timeOffset:
timeOffset
timeStamp
timeStep
timestamp
timingFunction
timingMode
title
toBool
toDouble
toString
toTransform3D
toVector3
toVector4
toggleRetina:
tokenWithString:
topRadius
topology
torusWithRingRadius:pipeRadius:options:
trackingAreas
tracksWithMediaCharacteristic:
transform
transformAnimation
transformConstraintInWorldSpace:withBlock:
transformedValue:
transformedValueClass
transforms
transition
transitionPass
transitionStartTime
translateByX:Y:Z:
translateInCameraSpaceByX:Y:Z:
translateInScreenSpaceTo:viewport:
translations
transparency
transparencyMode
transparent
truckSensitivity
truncationMode
tubeWithInnerRadius:outerRadius:height:
tubeWithInnerRadius:outerRadius:height:options:
turbidity
turbulenceFieldWithSmoothness:animationSpeed:
type
typeWithFilenameExtension:
typeWithIdentifier:
types
unarchiveObjectWithData:
unarchivedObjectOfClass:fromData:error:
unarchivedObjectOfClasses:fromData:error:
unarchiver:cannotDecodeObjectOfClassName:originalClasses:
unarchiver:didDecodeObject:
unarchiver:willReplaceObject:withObject:
unarchiverDidFinish:
unarchiverWillFinish:
unbind
unbindAnimatablePath:
unhide
unhighlightSelectedNode
unifiesNormals
uniformTessellationDrawMeshElement:forMesh:instanceCount:renderContext:
unload
unlock
unlockLayout
unregisterManagerForDevice:
unregisterPlayer:
unrolledWorldOrientation:
unsignedCharValue
unsignedIntValue
unsignedIntegerValue
unsignedLongValue
unsignedShortValue
unstageTexture:commandBuffer:
upAxis
upVector
update
updateAtTime:
updateBounds
updateBrowseScaleFactor
updateCameraNode:withSourceNode:
updateCollisionPairs
updateConstrainedEdgeLengthTessellator:parameters:
updateCurrentTimeIfPlayingWithSystemTime:
updateDependencyBuffersInBufferArray:forDeformer:
updateGlobalScale:
updateInertiaAtTime:
updateItemsPosition
updateItemsRotation:
updateItemsScale:
updateKeyboardStateAndRedrawIfNeeded:
updateLightTypeForNode:source:light:screenspaceScalingFactor:
updateManipulatorComponents
updateManipulatorNode
updateManipulatorPosition:
updateParticlesNode:withSourceNode:
updateProbes:atTime:
updateSceneGraph
updateScreenSpaceAdaptiveTessellator:parameters:
updateSeek
updateStackControl
updateSubdivisionSurfaceTessellator:parameters:
updateTargets
updateTexture
updateUniformTessellator:
updateWithComputeContext:buffers:
updateWithContext:
updateWithRenderer:
updateWithTarget:forTime:
upperAtmosphereScattering
usage
useLegacyFov
useOrbitInteractionMode
useResource:usage:
usedCount
usedResources
userAnimation
userInfo
usesDefaultMomentOfInertia
usesDeferredShadows
usesDepthPrePass
usesEllipsoidalExtent
usesEuler
usesMipmaps
usesModulatedMode
usesOrthographicProjection
usesReverseZ
usesSceneTimeBase
usesSeparateWorkGroup
validateAndCommitValueInEditor:editingIsEnding:errorUserInterfaceHandled:
validateClone
validateClones
value
valueForKey:
valueForKeyPath:
valueForPassPropertyKey:
valueForProperty:
valueForSymbolNamed:
valueForUndefinedKey:
valueWithBytes:objCType:
valueWithCATransform3D:
valueWithMatrix4:
valueWithObject:inContext:
valueWithPointer:
valueWithRect:
valueWithSCNMatrix4:
valueWithSCNVector3:
valueWithSCNVector4:
valueWithSize:
valueWithVector3:
valueWithVector3:inContext:
valueWithVector4:
valueWithVector4:inContext:
values
vectorCount
vectorWithValues:count:
vectorWithX:Y:Z:W:
vehicleWithChassisBody:wheels:
velocity
velocityFactor
vertexAmplificationEnabled
vertexAttributeDataForAttributeNamed:
vertexBuffers
vertexBuffersUsageMask
vertexCount
vertexCreaseCount
vertexCreaseIndices
vertexCreases
vertexDescriptor
vertexFunction
vertexFunctionName
vertexShader
verticalMaximumAngle
verticesCount
videoMirrored
view
viewDidDrawAtTime:
viewDidEndLiveResize
viewDidMoveToWindow
viewMatrix
viewWillDrawAtTime:
viewWillMoveToWindow:
viewWillStartLiveResize
viewedObjectSphere
viewport
viewportDependant
viewportMousePosition
vignettingIntensity
volatileOffset
volatileSize
volatileStride
volume
vortexField
waitForDuration:
waitForDuration:withRange:
waitForShadersCompilation
waitUntilCompleted
waitUntilExit
wantsAdaptiveSubdivision
wantsBestResolutionOpenGLSurface
wantsDepthOfField
wantsExposureAdaptation
wantsHDR
wantsLayer
wantsRedraw
wantsScreenSpaceReflection
warmupDuration
wasAddedToTarget:atTime:
wasPausedWithTarget:atTime:
wasRemovedFromTarget:atTime:
weakToStrongObjectsMapTable
weight
weightAtTargetIndex:
weightForTargetAtIndex:
weightForTargetNamed:
weightIncrementalThreshold
weightIndexStringForIndex:
wheelAtIndex:
wheelWithNode:
wheels
whiteBalanceTemperature
whiteBalanceTint
whiteColor
whitePoint
width
widthSegmentCount
willBeShown
willChangePointOfView
willChangeValueForKey:
willMoveFromView:
willResumeWithTarget:atTime:
willStartPlayback
willStartWithTarget:atTime:
window
windowChangedScreen:
windowWillClose:
workingColorSpace
worldCoordinates
worldFront
worldNormal
worldOrientation
worldPosition
worldRight
worldSpaceDistance
worldTransform
wrapS
wrapT
writeBytes:length:
writeContentsForEntryName:toFile:options:error:
writeImage:withSceneDocumentURL:originalImageURL:
writeToFile:atomically:
writeToFile:options:error:
writeToURL:
writeToURL:atomically:
writeToURL:atomically:encoding:error:
writeToURL:options:
writeToURL:options:delegate:progressHandler:
writeToURL:options:error:
writeToURLWithUSDKit:
writesToDepthBuffer
xAlignment
xFov
xMag
yAlignment
yFov
yMag
zAlignment
zFar
zNear
zone
zoomFactor
@16@0:8
@24@0:8@16
@40@0:8@16@24@?32
v48@0:8@16@24Q32@40
v48@0:8@16@24@32@?40
@44@0:8@16^{__C3DEngineContext=}24c32@36
@40@0:8@16^{__C3DEngineContext=}24@32
@36@0:8@16^{__C3DEngineContext=}24c32
@32@0:8@16@24
v44@0:8@16@24^{SCNMTLBlitCommandEncoder=@@}32c40
@32@0:8^{__C3DImage=}16c24i28
c48@0:8^{__C3DImage=}16@24@32i40c44
@44@0:8@16Q24^{__C3DEngineContext=}32c40
@44@0:8@16Q24@32c40
@40@0:8^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture}^v)b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}16^{__C3DEngineContext=}24*32
@48@0:8^{__C3DImageProxy={__CFRuntimeBase=QAQ}{?=^?^?^?^?}^vC}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24^{__C3DEngineContext=}32*40
@52@0:8^{__C3DImage=}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24i32^{__C3DEngineContext=}36*44
v56@0:8@16^{CGColorSpace=}24^{CGColorSpace=}32@40@48
v92@0:8I16@20@28@36@44@52^{CGColorSpace=}60^{CGColorSpace=}68@76@84
v20@0:8i16
v16@0:8
v24@0:8@16
^{__C3DScene=}16@0:8
v48@0:8@16@24@32^v40
@"NSView"
[10@"NSView"]
@"SCNView"
c24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
c16@0:8
c24@0:8#16
c24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
c24@0:8@"Protocol"16
@"NSString"16@0:8
q32@0:8@16@24
@40@0:8@16q24@32
c32@0:8@16@24
@40@0:8@16@24@32
v48@0:8@16@24@32@40
v32@0:8@16@24
v56@0:8@16@24{CGPoint=dd}32@48
v56@0:8@16@24{CGPoint=dd}32Q48
c40@0:8@16@24@32
Q48@0:8@16@24@32q40
c48@0:8@16@24@32q40
q32@0:8@"NSOutlineView"16@24
@40@0:8@"NSOutlineView"16q24@32
c32@0:8@"NSOutlineView"16@24
@40@0:8@"NSOutlineView"16@"NSTableColumn"24@32
v48@0:8@"NSOutlineView"16@24@"NSTableColumn"32@40
@32@0:8@"NSOutlineView"16@24
v32@0:8@"NSOutlineView"16@"NSArray"24
@"<NSPasteboardWriting>"32@0:8@"NSOutlineView"16@24
v56@0:8@"NSOutlineView"16@"NSDraggingSession"24{CGPoint=dd}32@"NSArray"48
v56@0:8@"NSOutlineView"16@"NSDraggingSession"24{CGPoint=dd}32Q48
c40@0:8@"NSOutlineView"16@"NSArray"24@"NSPasteboard"32
v32@0:8@"NSOutlineView"16@"<NSDraggingInfo>"24
Q48@0:8@"NSOutlineView"16@"<NSDraggingInfo>"24@32q40
c48@0:8@"NSOutlineView"16@"<NSDraggingInfo>"24@32q40
@"NSArray"40@0:8@"NSOutlineView"16@"NSURL"24@"NSArray"32
v40@0:8@16@24@32
c40@0:8@16@24:32
@64@0:8@16@24@32{_NSRange=QQ}40^q56
v24@0:8@"NSNotification"16
c32@0:8@"NSControl"16@"NSText"24
c40@0:8@"NSControl"16@"NSString"24@"NSString"32
v40@0:8@"NSControl"16@"NSString"24@"NSString"32
c32@0:8@"NSControl"16@24
c40@0:8@"NSControl"16@"NSTextView"24:32
@"NSArray"64@0:8@"NSControl"16@"NSTextView"24@"NSArray"32{_NSRange=QQ}40^q56
v40@0:8@16@24q32
@72@0:8@16@24^{CGRect={CGPoint=dd}{CGSize=dd}}32@40@48{CGPoint=dd}56
d32@0:8@16@24
@48@0:8@16@24@32@40
c48@0:8@16@24@32@40
d32@0:8@16q24
c40@0:8@16q24q32
@"NSView"40@0:8@"NSOutlineView"16@"NSTableColumn"24@32
@"NSTableRowView"32@0:8@"NSOutlineView"16@24
v40@0:8@"NSOutlineView"16@"NSTableRowView"24q32
c40@0:8@"NSOutlineView"16@"NSTableColumn"24@32
c24@0:8@"NSOutlineView"16
@"NSIndexSet"32@0:8@"NSOutlineView"16@"NSIndexSet"24
c32@0:8@"NSOutlineView"16@"NSTableColumn"24
v32@0:8@"NSOutlineView"16@"NSTableColumn"24
@"NSString"72@0:8@"NSOutlineView"16@"NSCell"24^{CGRect={CGPoint=dd}{CGSize=dd}}32@"NSTableColumn"40@48{CGPoint=dd}56
d32@0:8@"NSOutlineView"16@24
@"NSTintConfiguration"32@0:8@"NSOutlineView"16@24
@"NSString"40@0:8@"NSOutlineView"16@"NSTableColumn"24@32
@48@0:8@"NSOutlineView"16@24@32@"NSString"40
c40@0:8@"NSOutlineView"16@"NSEvent"24@"NSString"32
c48@0:8@"NSOutlineView"16@"NSCell"24@"NSTableColumn"32@40
@"NSCell"40@0:8@"NSOutlineView"16@"NSTableColumn"24@32
d32@0:8@"NSOutlineView"16q24
c40@0:8@"NSOutlineView"16q24q32
@48@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16
@"NSOutlineView"
@"NSMutableDictionary"
@32@0:8@16Q24
@24@0:8^{_NSZone=}16
^{SCNCActionRepeat=^^?d@?@BdddddBB@?^{__CFString}qdddd^{SCNCAction}QQdc}
@"SCNAction"
@32@0:8d16d24
@24@0:8d16
^{SCNCActionFade=^^?d@?@BdddddBB@?^{__CFString}qddddfffc}
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
@"NSData"
@32@0:8@16^@24
@40@0:8@16@24^@32
Q24@0:8Q16
i20@0:8I16
v24@0:8@"NSString"16
@"<MTLDevice>"16@0:8
@"<MTLHeap>"16@0:8
v104@0:8^v16Q24Q32{?={?=QQQ}{?=QQQ}}40Q88Q96
v104@0:8{?={?=QQQ}{?=QQQ}}16Q64Q72r^v80Q88Q96
v88@0:8^v16Q24{?={?=QQQ}{?=QQQ}}32Q80
v88@0:8{?={?=QQQ}{?=QQQ}}16Q64r^v72Q80
@24@0:8Q16
@64@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48
@68@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64
^{__IOSurface=}16@0:8
q16@0:8
{MTLResourceID=Q}16@0:8
{?=CCCC}16@0:8
@"<MTLTexture>"24@0:8Q16
@"<MTLTexture>"64@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48
@"MTLSharedTextureHandle"16@0:8
@"<MTLTexture>"24@0:8@"<MTLDevice>"16
@"<MTLTexture>"68@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64
@"<MTLResource>"16@0:8
@"<MTLTexture>"16@0:8
@"<MTLBuffer>"16@0:8
@24@0:8^{CGPath=}16
@88@0:8^{CGPath=}16{?=[4]}24
^{CGPath=}16@0:8
@24@0:8q16
v24@0:8q16
^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16@0:8
^{CGPath=}
{?="columns"[4]}
@32@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16@24
{?=b2b2b2b1}28@0:8@16C24
C28@0:8@16C24
@?36@0:8@16C24@28
v48@0:8{?=@@^{?}IB}16
v72@0:8{?=^{__C3DMesh}@^{__C3DMeshElement}@I@C}16
v40@0:8{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}16
v72@0:8{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}16{?=@@^{?}IB}40
^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}
@"SCNMTLResourceManager"
{?="type"C"tessellationFactorScale"f"tessellationPartitionMode"I"tessellationSmoothingMode"C"parameters"(?="uniform"{?="edgeTessellationFactor"f"insideTessellationFactor"f}"screenSpaceAdaptive"{?="projectedEdgeLength"f}"constrainedEdgeLength"{?="maximumEdgeLength"f}"subdivisionSurface"{?="tessellationLevel"C"allowSingleCreasePatch"b1"useScreenSpaceTessellation"b1})}
@"<MTLBuffer>"
@20@0:8I16
v24@0:8^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16
c48@0:8@16@24d32r^{?=IiqQdq{CVSMPTETime=ssIIIssss}QQ}40
v48@0:8@16@24d32r^{?=IiqQdq{CVSMPTETime=ssIIIssss}QQ}40
v24@0:8^{CGContext=}16
@28@0:8@16c24
^{SCNCPlaySound=^^?d@?@BdddddBB@?^{__CFString}qddddcc@}
c24@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16
Q32@0:8@16r^{?=@@@@@@@@@@@@}24
Q32@0:8@"<SCNMTLDeformerUpdateComputeContext>"16r^{?=@@@@@@@@@@@@}24
@56@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16Q24C32C36@40@48
@56@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16Q24C32C36@"SCNMTLResourceManager"40@"<SCNMTLDeformerInitComputeContext>"48
@"SCNMTLMesh"16@0:8
{?="segmentCountLinear"S"segmentCountQuadratic"S"segmentCountCubic"S"segmentInfoOffsetLinear"S"segmentInfoOffsetQuadratic"S"segmentInfoOffsetCubic"S"controlPointIndicesOffset"S}
@"SCNMTLMesh"
@"SCNMTLComputePipeline"
v48@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16
Q24@0:8@16
:16@0:8
v24@0:8:16
@"NSImage"
@"NSArray"
@"NSURL"
@"NSDictionary"
@"SCNAssetCatalog"
@"NSString"
v20@0:8c16
i16@0:8
@20@0:8c16
^{__C3DFXProgram=}40@0:8^{__C3DProgramHashCode=}16^{__C3DEngineContext=}24^{?=q^{?}[4{?=qq}][4{?=qq}][4q]^v^vB}32
@44@0:8@16@24c32Q36
v64@0:8^{__C3DFXMetalProgram=}16@24@32@40@?48@?56
{_NSRange="location"Q"length"Q}
^{__C3DModelTarget={__CFRuntimeBase=QAQ}^v^vscCCB^?^?}
@24@0:8^{__C3DEngineContext=}16
{CATransform3D=dddddddddddddddd}16@0:8
v24@0:8Q16
v72@0:8{SCNVector3=ddd}16{SCNVector3=ddd}40@64
v48@0:8@16{CGPoint=dd}24@40
d16@0:8
^{__C3DEngineContext=}
@"<SCNSceneRenderer>"
^{__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}
{?="weakProgram"^{__C3DFXProgram}"baseIndex"I"baseVertex"I"vertexSize"I"allocatedVerticesSize"I"allocatedIndicesSize"I"textureImage"^{__C3DImage}"texture"^{__C3DTexture}"drawMode"C"orthographic"B"clearDepthBuffer"B"enableDepthTest"B"enableCulling"B"isDynamic"B"mesh"^{__C3DMesh}"meshElement"^{__C3DMeshElement}"_cache"{?="verticesStride"Q"colorsStride"Q"uvsStride"Q"verticesData"*"colorsData"*"uvsData"*}"_usedMeshes"@"NSMutableSet""_freeMeshes"@"NSMutableSet""_usedMeshElements"@"NSMutableSet""_freeMeshElements"@"NSMutableSet"}
{?="textureInfo"{?="texture"^{__C3DImage}"textureSize"{CGSize="width"d"height"d}"isRetina"B}"lineHeight"d"characterWidth_texture"s"characterWidth_typography"^d"characterHeight_texture"s"symbolRects"^{?}}
^{__C3DRasterizerStates=}
@"NSMutableSet"
[64000C]
@"NSSet"
@"NSMutableOrderedSet"
@"NSMutableArray"
{?="initialized"B"showFullStatistics"B"showRenderOptionsPanel"B"fps"f"waitDisplayLinkTime"f"pressedButtonIndex"q"fpsString"^{__CFString}"shortString"^{__CFString}"internalString"^{__CFString}"lightingStatistics"[9I]"stats"{__C3DEngineStats="verticesProcessed"I"primitivesProcessed"I"drawCount"I"drawStep"I"frameCount"I"fboSwitches"I"vboSwitches"I"attSwitches"I"attEnabling"I"iboSwitches"I"vaoSwitches"I"prgSwitches"I"texSwitches"I"rssSwitches"I"getCount"I"uniformFloatSent"I"uniformIntSent"I"uniformVector2Sent"I"uniformVector3Sent"I"uniformVector4Sent"I"uniformMatrix4Sent"I"vboUploaded"I"iboUploaded"I"texUploaded"I"cpuTime"d"cstrTime"d"phyTime"d"prtTime"d"animTime"d"skinTime"d"mrphTime"d"rendTime"d"twoDTime"d"delegateTime"d"glFlushTime"d"waitDisplayLinkTime"d"drawableWaitTime"d"gpuTime"d"lastDisplayLinkTime"d"prgCount"I"texCount"I"fboCount"I"vboCount"I"rboCount"I"iboCount"I"cboCount"I"vaoCount"I"fboMemory"I"rboMemory"I"vboMemory"I"iboMemory"I"cboMemory"I"texMemory"I"backBufferMemory"I"depthBuffersMemory"I"onlineShaderCount"I"onlineShaderCompilationTime"d"renderPipelineCount"I"renderPipelineCompilationTime"d"computePipelineCount"I"computePipelineCompilationTime"d"frmAvgTime"d"frmMinTime"d"frmMaxTime"d"frameTimeHistory"[60d]"frameTimeCurrentIndex"I"startTime"d"lastFrameTime"d}}
@"SCNAuthoringEnvironment2"
v40@0:8{SCNVector3=ddd}16
v24@0:8d16
v24@0:8^{?=[296C]}16
v320@0:8@16{?=[296C]}24
{?="characterBody"@"SCNPhysicsBody""direction"{SCNVector3="x"d"y"d"z"d}"velocity"d"jumpSpeed"d}
^{btCharacterControllerInterface=^^?}
^{btOverlapFilterCallback=^^?}
^{btCapsuleShape=^^?i^v{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffi}
@"SCNPhysicsWorld"
v32@0:8r^v16Q24
v24@0:8^(C3DMatrix4x4=[16f][4]{?=[4]})16
f28@0:8r^(C3DMatrix4x4=[16f][4]{?=[4]})16f24
v24@0:8^{__C3DMaterial=}16
v96@0:8{?=^{__C3DFXMetalProgram}^{__C3DMaterial}^{__C3DGeometry}^{__C3DNode}^{__C3DMesh}^{__C3DMeshElement}{?=[8C]}^{__C3DFXPass}^IBBBBBb3}16
^{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIdddddddddddddddIIIIIIIIIIIIIIIIIdIdIdddd[60d]Idd}
{CATransform3D="m11"d"m12"d"m13"d"m14"d"m21"d"m22"d"m23"d"m24"d"m31"d"m32"d"m33"d"m34"d"m41"d"m42"d"m43"d"m44"d}
@"<MTLDevice>"
@"<MTLCommandQueue>"
@"NSObject<OS_dispatch_semaphore>"
{atomic<int>="__a_"{__cxx_atomic_impl<int, std::__cxx_atomic_base_impl<int>>="__a_value"Ai}}
@"<MTLTexture>"
@"CAMetalLayer"
@"<CAMetalDrawable>"
@"MTLRenderPassDescriptor"
@"<MTLCommandBuffer>"
^{SCNMTLRenderCommandEncoder=BQQQQBBBBIICBB[31{?=@Q}][128@][16@][31{?=@Q}][128@][16@]@@@^{SCNMTLBufferPool}[2Q][2Q]}
{SCNMTLBlitCommandEncoder="_encoder"@"<MTLBlitCommandEncoder>""_commandBuffer"@"<MTLCommandBuffer>"}
{SCNMTLComputeCommandEncoder="_buffers"[31@"<MTLBuffer>"]"_offsets"[31Q]"_textures"[128@"<MTLTexture>"]"_samplers"[16@"<MTLSamplerState>"]"_computePipelineState"@"<MTLComputePipelineState>""_encoder"@"<MTLComputeCommandEncoder>""_commandBuffer"@"<MTLCommandBuffer>""_bufferPool"^{SCNMTLBufferPool}"_features"I"_texturesToBind"[2Q]"_buffersToBind"[1Q]}
{?="renderSliceIndex"C"eyeCount"C"renderMode"C"multiVertexOutputStreamGenerator"C"isMainPass"B"isFinalTechnique"B}
{?="vertexIndex"c"fragmentIndex"c}
[3^{SCNMTLBufferPool}]
@"<MTLDepthStencilState>"
@"<MTLSamplerState>"
[3^{__C3DFXMetalProgram}]
^{__C3DFXMetalProgram={__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}[2^{__CFString}]^{__CFString}^{__CFString}^{__CFDictionary}^{__CFSet}^v^{__CFDictionary}i@?@?QI}
@"NSObject<OS_dispatch_queue>"
@"NSObject<OS_dispatch_group>"
{?="passInstance"^{__C3DFXPassInstance}"lightingSystem"^{__C3DLightingSystem}"dynamicBatchingSystem"^{__C3DDynamicBatchingSystem}"pass"^{__C3DFXPass}"renderGraphPass"^v"passRequiresLighting"c"transformTree"^{__C3DTransformTree}}
[6{SCNSceneBuffer="viewTransform"{float4x4="columns"[4]}"inverseViewTransform"{float4x4="columns"[4]}"projectionTransform"{float4x4="columns"[4]}"viewProjectionTransform"{float4x4="columns"[4]}"viewToCubeTransform"{float4x4="columns"[4]}"lastFrameViewProjectionTransform"{float4x4="columns"[4]}"ambientLightingColor""fogColor""fogParameters""inverseResolution""time"f"sinTime"f"cosTime"f"random01"f"motionBlurIntensity"f"environmentIntensity"f"inverseProjectionTransform"{float4x4="columns"[4]}"inverseViewProjectionTransform"{float4x4="columns"[4]}"nearFar""viewportSize""inverseTransposeViewTransform"{float4x4="columns"[4]}"clusterScale"}]
{?="buffer"@"<MTLBuffer>""offset"Q}
{?="buffer"@"<MTLBuffer>""offset"Q"size"Q"shadowMaps"[256@"<MTLTexture>"]"textureMaps"[256@"<MTLTexture>"]"samplerStates"[256@"<MTLSamplerState>"]}
{?="modelTransform"{float4x4="columns"[4]}"lastFrameModelTransform"{float4x4="columns"[4]}"normalTransforms"[6{float4x4="columns"[4]}]"modelViewTransforms"[6{float4x4="columns"[4]}]"modelViewProjectionTransforms"[6{float4x4="columns"[4]}]"boundingBox"{float2x3="columns"[2]}"worldBoundingBox"{float2x3="columns"[2]}"instanceNode"^{__C3DNode}"flags"I"probeCacheIndex"^I}
{?="currentLightingSet"{?="lights"[8C]}"currentShadowMaps"[8@"<MTLTexture>"]"currentGoboMaps"[8@"<MTLTexture>"]"frameLightingSetDatas"{unordered_map<unsigned long long, SCNMTLLightSetData, std::hash<unsigned long long>, std::equal_to<unsigned long long>, std::allocator<std::pair<const unsigned long long, SCNMTLLightSetData>>>="__table_"{__hash_table<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::__unordered_map_hasher<unsigned long long, std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::hash<unsigned long long>, std::equal_to<unsigned long long>>, std::__unordered_map_equal<unsigned long long, std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::equal_to<unsigned long long>, std::hash<unsigned long long>>, std::allocator<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<unsigned long long, std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::hash<unsigned long long>, std::equal_to<unsigned long long>>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<unsigned long long, std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::equal_to<unsigned long long>, std::hash<unsigned long long>>>="__value_"f}}}"currentLightingHashKey"Q"currentLightingDesc"{?="count"q"lights"[8^{__C3DLight}]"lightsData"[8^{__C3DLightRuntimeData}]}"currentLightingSpace"{?="columns"[4]}"currentLightingSpaceShadow"{?="columns"[4]}"needLightingSpaceTransformation"B"clusterSystem"{SCNMTLClusterSystem="clustersCount""tileSize""selectedDebugClusterIndex""_debugClusterTilesPipeline"@"SCNMTLRenderPipeline""_debugLightIndicesBufferPipeline"@"SCNMTLRenderPipeline""_debugClusterSlicesPipeline"@"SCNMTLRenderPipeline""_debugProgram"[7^{__C3DFXMetalProgram}]"_debugShapes"[7^{__C3DMesh}]}"clusterInfo"{Info="clusterBuffer"{?="memory"*"buffer"@"<MTLBuffer>""offset"Q}"clusterTexture"@"<MTLTexture>""lightIndicesBuffer"@"<MTLBuffer>""lightIndicesBufferOffset"I"lightIndicesBufferSize"I"cellSize""clusterScale""cellPixelSize""omniLightsRange""spotLightsRange""probeLightsRange""lightsBuffer"{?="memory"*"buffer"@"<MTLBuffer>""offset"Q}"lightsBufferLightCount"I"shadowTextures"[8@"<MTLTexture>"]"iesOrGoboTextures"[8@"<MTLTexture>"]"samplerStates"[8@"<MTLSamplerState>"]"areaBuffer"@"<MTLBuffer>""areaBufferOffset"Q"areaBufferOffsets"[8Q]}"reflectionProbesTextureArray"@"<MTLTexture>"}
{Cache="rasterizerStates"^{__C3DRasterizerStates}"mesh"^{__C3DMesh}"metalMesh"@"SCNMTLMesh""meshElement"^{__C3DMeshElement}"metalMeshElement"@"SCNMTLMeshElement""program"^{__C3DFXMetalProgram}"material"^{__C3DMaterial}"geometry"^{__C3DGeometry}"metalShadable"@"SCNMTLShadable""commonProfile"^{__C3DEffectCommonProfile}"blendStates"^{__C3DBlendStates}"colorBufferWriteMask"C"primitiveTopologyClass"C"node"^{__C3DNode}"deformers"^{__C3DDeformerStack}"vertexDescriptorHash"Q"tessellationPipelineStateHash"C"renderPipeline"@"SCNMTLRenderPipeline"}
[2{?="hash"Q"pipeline"@"SCNMTLRenderPipeline"}]
@"SCNMTLRenderPipeline"
{?="backgroundTexture"@"<MTLTexture>""overlayTexture"@"<MTLTexture>""stencilDepthTexture"@"<MTLTexture>"}
{?="pixelFormat"Q"sampleCount"Q"displayCubemapPipeline"@"SCNMTLRenderPipeline""displayTexture2DPipeline"@"SCNMTLRenderPipeline""displayDepth2DPipeline"@"SCNMTLRenderPipeline""displayDepthCubePipeline"@"SCNMTLRenderPipeline"}
{?="collectEnabled"c"errors"@"NSMutableDictionary"}
{?="modelTransformBindingCount"I"modelViewTransformBindingCount"I"normalTransformBindingCount"I"nodeOpacityBindingCount"I}
{?="passHash"Q"material"^{__C3DMaterial}}
@"<SCNMTLRenderContextResourceManagerMonitor>"
@"<SCNMTLRenderContextCommandBufferStatusMonitor>"
{os_unfair_lock_s="_os_unfair_lock_opaque"I}
@"<MTLRenderCommandEncoder>"
@32@0:8d16@24
@24@0:8^{__C3DParticleSystem=}16
v32@0:8@16d24
v32@0:8d16@24
v32@0:8@"<SCNAnimation>"16@"NSString"24
v32@0:8@"SCNAnimationPlayer"16@"NSString"24
v32@0:8@"NSString"16d24
@"SCNAnimationPlayer"24@0:8@"NSString"16
@"CAAnimation"24@0:8@"NSString"16
v32@0:8d16@"NSString"24
c24@0:8@"NSString"16
@"NSArray"16@0:8
^v16@0:8
^{__C3DAnimationManager=}16@0:8
v32@0:8c16@20c28
^{__C3DParticleSystem=}16@0:8
s24@0:8@16
{SCNVector3=ddd}16@0:8
{SCNVector4=dddd}16@0:8
v48@0:8{SCNVector4=dddd}16
v40@0:8q16@24@?32
v40@0:8@16q24@?32
^{__C3DParticleSystem=}
@"SCNOrderedDictionary"
@"SCNGeometry"
{SCNVector3="x"d"y"d"z"d}
@"NSColor"
{SCNVector4="x"d"y"d"z"d"w"d}
@"SCNParticleSystem"
^{__C3DEngineContext=}16@0:8
^{__C3DRendererContext={__CFRuntimeBase=QAQ}iIIIIfI^{__C3DTexture}^{__C3DStack}^vBBBBB^{__CFDictionary}I^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}{C3DColor4=(?=[4f]{?=ffff})}^vq^{__C3DFXProgramObject}{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIdddddddddddddddIIIIIIIIIIIIIIIIIdIdIdddd[60d]Idd}{Cache=[16I]Ii^{__C3DBlendStates}I^{__C3DRasterizerStates}^{__C3DMesh}^{__C3DMeshElement}IIiI^viii}{?=[5I][5i][46{?=iII}][46I]^?^?^?^?^?^?^?^?^?^?}[2{VolatileObject=^{__C3DArray}II^{__CFArray}}]^{__C3DArray}I^{__CFDictionary}}16@0:8
@32@0:8@16q24
q24@0:8@16
@"SCNRendererOptionsPanel"
@"NSPopUpButton"
@"NSTextField"
@"NSSlider"
@"NSStepper"
@"NSButton"
@"SCNUIDynamicInspector"
@"NSComboBox"
c40@0:8@16@24^@32
@72@0:8{SCNVector3=ddd}16{SCNVector3=ddd}40@64
@56@0:8{btVector3=(?=[4f])}16{btVector3=(?=[4f])}32@48
@288@0:8@16{CATransform3D=dddddddddddddddd}24{CATransform3D=dddddddddddddddd}152@280
v24@0:8@?16
^{btVehicleRaycaster=^^?}16@0:8
v24@0:8^v16
v56@0:8@16^{__C3DNode=}24Q32Q40Q48
v32@0:8@16^v24
^{btOverlappingPairCallback=^^?}
^{btVehicleRaycaster=^^?}
^{btC3DDebugDraw=^^?if^v}
{c3dAether="_fields"{vector<c3dPhysicsField *, std::allocator<c3dPhysicsField *>>="__begin_"^^{c3dPhysicsField}"__end_"^^{c3dPhysicsField}"__end_cap_"{__compressed_pair<c3dPhysicsField **, std::allocator<c3dPhysicsField *>>="__value_"^^{c3dPhysicsField}}}"_activeFields"{vector<c3dPhysicsField *, std::allocator<c3dPhysicsField *>>="__begin_"^^{c3dPhysicsField}"__end_"^^{c3dPhysicsField}"__end_cap_"{__compressed_pair<c3dPhysicsField **, std::allocator<c3dPhysicsField *>>="__value_"^^{c3dPhysicsField}}}"_lastOverrideIndex"I}
@"<SCNPhysicsContactDelegate>"
@"SCNPhysicsContact"
@"SCNScene"
^{MTLComputeEvaluator=@@@i}
@56@0:8^{MTLContext=@@@@}16r^{BufferDescriptor=iii}24r^{BufferDescriptor=iii}32r^{BufferDescriptor=iii}40r^{BufferDescriptor=iii}48
@40@0:8@16@24Q32
v24@0:8^{__CVDisplayLink=}16
@40@0:8^{?=CCCb1b1b1b1b1b1[4C]}1624Q32
C16@0:8
c40@0:8^{?=CCCb1b1b1b1b1b1[4C]}1624Q32
{?="format"C"sampleCount"C"textureUsage"C"renderToTexture"b1"forceTextureRect"b1"viewportDependant"b1"renderToIOSurface"b1"mipmapped"b1"textureCube"b1"padding"[4C]}
@"CIImage"
@40@0:8{CGPoint=dd}16@32
{SCNVector3=ddd}40@0:8{SCNVector3=ddd}16
c32@0:8@16@?24
v32@0:8@16@?24
^{CGColorSpace=}16@0:8
{CGRect={CGPoint=dd}{CGSize=dd}}16@0:8
v48@0:8@"SCNScene"16@"SKTransition"24@"SCNNode"32@?<v@?>40
@"NSArray"40@0:8{CGPoint=dd}16@"NSDictionary"32
c32@0:8@"SCNNode"16@"SCNNode"24
@"NSArray"24@0:8@"SCNNode"16
c32@0:8@16@?<c@?>24
v32@0:8@"NSArray"16@?<v@?c>24
@"SCNScene"16@0:8
v24@0:8@"SCNScene"16
@"<SCNSceneRendererDelegate>"16@0:8
v24@0:8@"<SCNSceneRendererDelegate>"16
@"SCNNode"16@0:8
v24@0:8@"SCNNode"16
@"SKScene"16@0:8
v24@0:8@"SKScene"16
@"<MTLRenderCommandEncoder>"16@0:8
@"MTLRenderPassDescriptor"16@0:8
@"<MTLCommandQueue>"16@0:8
@"AVAudioEngine"16@0:8
@"AVAudioEnvironmentNode"16@0:8
@"SCNTechnique"16@0:8
v24@0:8@"SCNTechnique"16
@32@0:8@16^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}24
v32@0:8^{SCNVector3=ddd}16Q24
v24@0:8^{CGColor=}16
^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16@0:8
^{_CGLPixelFormatObject=}20@0:8I16
^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}24@0:8^{_CGLPixelFormatObject=}16
c48@0:8^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16^{_CGLPixelFormatObject=}24d32r^{?=IiqQdq{CVSMPTETime=ssIIIssss}QQ}40
v48@0:8^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16^{_CGLPixelFormatObject=}24d32r^{?=IiqQdq{CVSMPTETime=ssIIIssss}QQ}40
@"SCNJitterer"
@"SCNRenderer"
^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}
@"SCNRendererOptionsPanelController"
^{__C3DFXProgram=}
^{__CFSet=}
@24@0:8i16c20
^{__C3DFXProgram=}48@0:8^{__C3DProgramHashCode=}16^{__C3DEngineContext=}24@32^{?=q^{?}[4{?=qq}][4{?=qq}][4q]^v^vB}40
^{__CFDictionary=}
v40@0:8@16@24@?32
v24@0:8@"NSArray"16
v40@0:8@"NSURL"16@"NSDictionary"24@?<v@?@"NSData"@"NSError">32
v144@0:8{CATransform3D=dddddddddddddddd}16
@"SCNNode"
@32@0:8@16d24
@32@0:8#16@24
@40@0:8#16#24@32
@"<SCNJittererDelegate>"
@"NSObject<OS_dispatch_source>"
@100@0:8@16Q24B32Q36Q44Q52Q60q68@76Q84@92
@"MDLAnimatedScalarArray"16@0:8
Q32@0:8^{?=[4]}16Q24
{?=[4]}16@0:8
@"NSData"16@0:8
v64@0:8@16@24c32c36f40f44@?48@?56
@72@0:8@16@24@32@40^v48@56@64
@72@0:8@16@24@32@?40@48@56@64
v48@0:8@?16@?24@32@40
^{__C3DFXContext=}16@0:8
^{__C3DTexture=}16@0:8
@"SCNTechniquePanel"
@"SCNRenderTargetView"
v24@0:8^{__C3DTexture=}16
v40@0:8@16@24d32
^{__C3DTexture=}
@"SCNPlane"
@"NSOpenGLContext"
@32@0:8@?16@24
@"SCNDisplayLink"
v24@0:8#16
@32@0:8@16#24
@40@0:8@16#24@32
v40@0:8@16@24Q32
@"SCNUIArrayEditor"
@"NSObjectController"
@"NSPathControl"
@288@0:8@16{CATransform3D=dddddddddddddddd}24@152{CATransform3D=dddddddddddddddd}160
@152@0:8@16{CATransform3D=dddddddddddddddd}24
{?="bodyA"@"SCNPhysicsBody""frameA"{CATransform3D="m11"d"m12"d"m13"d"m14"d"m21"d"m22"d"m23"d"m24"d"m31"d"m32"d"m33"d"m34"d"m41"d"m42"d"m43"d"m44"d}"bodyB"@"SCNPhysicsBody""frameB"{CATransform3D="m11"d"m12"d"m13"d"m14"d"m21"d"m22"d"m23"d"m24"d"m31"d"m32"d"m33"d"m34"d"m41"d"m42"d"m43"d"m44"d}"maximumAngularLimit1"d"maximumAngularLimit2"d"maximumTwistAngle"d}
^{btConeTwistConstraint=^^?ii(?=i^v)fBBi^{btRigidBody}^{btRigidBody}ff^{btJointFeedback}[3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}]{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}ffffffff{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffffffBBBBff{btVector3=(?=[4f])}BB{btQuaternion=(?=[4f])}f{btVector3=(?=[4f])}ifff}
@"CAAnimation"
v24@0:8^{__C3DImageProxy=}16
v24@0:8^{__C3DRendererContext={__CFRuntimeBase=QAQ}iIIIIfI^{__C3DTexture}^{__C3DStack}^vBBBBB^{__CFDictionary}I^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}{C3DColor4=(?=[4f]{?=ffff})}^vq^{__C3DFXProgramObject}{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIdddddddddddddddIIIIIIIIIIIIIIIIIdIdIdddd[60d]Idd}{Cache=[16I]Ii^{__C3DBlendStates}I^{__C3DRasterizerStates}^{__C3DMesh}^{__C3DMeshElement}IIiI^viii}{?=[5I][5i][46{?=iII}][46I]^?^?^?^?^?^?^?^?^?^?}[2{VolatileObject=^{__C3DArray}II^{__CFArray}}]^{__C3DArray}I^{__CFDictionary}}16
@48@0:8^{__C3DEngineContext=}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24^d32^{?=BB}40
@"AVPlayer"
{?="videoOutput"@"pixelBuffer"^{__CVBuffer}"mtlTextureForRenderer"@"<MTLTexture>""mtlTextureColorMatched"@"<MTLTexture>""mtlTextureColorForColorMatchingComputeKernel"@"<MTLTexture>""pixelBufferColorSpace"^{CGColorSpace}}
^{__CVMetalTextureCache=}
v40@0:8@16^{opaqueCMSampleBuffer=}24@32
v40@0:8@"AVCaptureOutput"16^{opaqueCMSampleBuffer=}24@"AVCaptureConnection"32
@"AVCaptureDevice"
@"AVCaptureSession"
v24@0:8^{opaqueCMSampleBuffer=}16
v24@0:8^{__CVBuffer=}16
v32@0:8^{opaqueCMSampleBuffer=}16@24
v32@0:8^{__CVBuffer=}16@24
v32@0:8^{opaqueCMSampleBuffer=}16@"AVCaptureDevice"24
v32@0:8^{__CVBuffer=}16@"AVCaptureDevice"24
@32@0:8d16@?24
^{SCNCActionWait=^^?d@?@BdddddBB@?^{__CFString}qdddd}
@24@0:8^{__C3DCamera={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}{?=b1b1b1b1b1b1b1dddfd(C3DMatrix4x4=[16f][4]{?=[4]}){?=[4]}dd}ffffiib1b1b1b1b1C(C3DMatrix4x4=[16f][4]{?=[4]})ffffffffffffiffffffffffffff{?=fffffii}^{__C3DEffectSlot}Q^{__C3DFXTechnique}^vf}16
f16@0:8
v20@0:8f16
16@0:8
v24@0:816
{CGAffineTransform=dddddd}16@0:8
v64@0:8{CGAffineTransform=dddddd}16
^{__C3DCamera={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}{?=b1b1b1b1b1b1b1dddfd(C3DMatrix4x4=[16f][4]{?=[4]}){?=[4]}dd}ffffiib1b1b1b1b1C(C3DMatrix4x4=[16f][4]{?=[4]})ffffffffffffiffffffffffffff{?=fffffii}^{__C3DEffectSlot}Q^{__C3DFXTechnique}^vf}16@0:8
{CATransform3D=dddddddddddddddd}32@0:8{CGSize=dd}16
^{__C3DCamera={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}{?=b1b1b1b1b1b1b1dddfd(C3DMatrix4x4=[16f][4]{?=[4]}){?=[4]}dd}ffffiib1b1b1b1b1C(C3DMatrix4x4=[16f][4]{?=[4]})ffffffffffffiffffffffffffff{?=fffffii}^{__C3DEffectSlot}Q^{__C3DFXTechnique}^vf}
@"SCNTechnique"
@"SCNMaterialProperty"
{?="intensity"f"radius"f"bias"f"depthThreshold"f"normalThreshold"f"sampleCount"q"downSample"q}
{C3DColor4=(?=[4f]{?=ffff})}28@0:8c16*20
@48@0:8d16d24d32d40
@56@0:8d16d24d32d40@48
@24@0:8r^{C3DColor4=(?=[4f]{?=ffff})}16
@80@0:8{?=[4]}16
{CGPoint=dd}16@0:8
@32@0:8{CGPoint=dd}16
@40@0:8{SCNVector3=ddd}16
@48@0:8{SCNVector4=dddd}16
@144@0:8{CATransform3D=dddddddddddddddd}16
@24@0:8^{__C3DLight=}16
^{__C3DLight=}16@0:8
{CGSize=dd}16@0:8
v32@0:8{CGSize=dd}16
v32@0:816
^{__C3DLight=}
{CGSize="width"d"height"d}
@24@0:8^{__C3DMaterial=}16
v32@0:8@"NSString"16@?<v@?II@"SCNNode"@"SCNRenderer">24
@"SCNProgram"16@0:8
v24@0:8@"SCNProgram"16
@"NSDictionary"16@0:8
v24@0:8@"NSDictionary"16
@"NSNumber"16@0:8
v24@0:8@"NSNumber"16
^{__C3DMaterial=}16@0:8
^{__C3DEffectCommonProfile={__CFRuntimeBase=QAQ}^{__C3DMaterial}i^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}fffffCqBBb1b1b1b1b1b1b1b1b1b13}16@0:8
v24@0:8^@16
@24@0:8^@16
^{__C3DMaterial=}
@"SCNShadableHelper"
@24@0:8^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}16
v24@0:8@"SCNAction"16
v32@0:8@"SCNAction"16@?<v@?>24
v32@0:8@"SCNAction"16@"NSString"24
v40@0:8@"SCNAction"16@"NSString"24@?<v@?>32
@"SCNAction"24@0:8@"NSString"16
c32@0:8^{SCNVector3=ddd}16^{SCNVector3=ddd}24
v32@0:8^{SCNVector3=ddd}16^{SCNVector3=ddd}24
c32@0:8^{SCNVector3=ddd}16^d24
c36@0:8@?16c24@28
@28@0:8@?16c24
@24@0:8@?16
c24@0:8@?16
v36@0:8#16@24c32
@28@0:8#16c24
v32@0:8@16q24
^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}16@0:8
{?=}16@0:8
v32@0:8{?=}16
v24@0:8^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}16
v32@0:8@16Q24
v32@0:8Q16@24
c40@0:8^{?=[6(?={?=ffff})]}1624
{CGRect={CGPoint=dd}{CGSize=dd}}24@0:8@16
v64@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16@48@56
v24@0:8^{__C3DParticleSystem=}16
{SCNVector3=ddd}48@0:8{SCNVector3=ddd}16@40
{CATransform3D=dddddddddddddddd}152@0:8{CATransform3D=dddddddddddddddd}16@144
v28@0:8@16c24
^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}
(?="eulerAngles""axisAngle""quaternion"{?="vector"})
@"SCNNodeComponent"
^{SCNVector3=ddd}
v88@0:8{SCNVector3=ddd}16{SCNVector3=ddd}40{SCNVector3=ddd}64
v72@0:8{SCNVector4=dddd}16{SCNVector3=ddd}48
c32@0:8^16^f24
v80@0:8{?=[4]}16
40@0:816@32
{?=[4]}88@0:8{?=[4]}16@80
v64@0:8163248
v48@0:8{?=}1632
@24@0:8^{__C3DScene=}16
v28@0:8@16i24
@20@0:8i16
c48@0:8@16@24@32@?40
v152@0:8@16{CATransform3D=dddddddddddddddd}24
^{__C3DScene=}
@"SCNSceneSource"
[4@"SCNNode"]
@"SCNAuthoringEnvironment"
^{__C3DRendererContext={__CFRuntimeBase=QAQ}iIIIIfI^{__C3DTexture}^{__C3DStack}^vBBBBB^{__CFDictionary}I^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}{C3DColor4=(?=[4f]{?=ffff})}^vq^{__C3DFXProgramObject}{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIdddddddddddddddIIIIIIIIIIIIIIIIIdIdIdddd[60d]Idd}{Cache=[16I]Ii^{__C3DBlendStates}I^{__C3DRasterizerStates}^{__C3DMesh}^{__C3DMeshElement}IIiI^viii}{?=[5I][5i][46{?=iII}][46I]^?^?^?^?^?^?^?^?^?^?}[2{VolatileObject=^{__C3DArray}II^{__CFArray}}]^{__C3DArray}I^{__CFDictionary}}24@0:8^{__C3DEngineContext=}16
^{__C3DTexture=}40@0:8^{__C3DEngineContext=}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24^d32
v40@0:8^{__C3DEngineContext=}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24^d32
v40@0:8^{__C3DEngineContext=}16{CGSize=dd}24
^{__C3DTexture=}52@0:8{CGSize=dd}16^{__C3DEngineContext=}32^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}40c48
v24@0:8^{__C3DEngineContext=}16
^{__C3DFramebuffer=}
@48@0:8^{__C3DEngineContext=}16@24@32@40
v32@0:8@16^{__C3DEngineContext=}24
@120@0:8@16@24Q32{?=[4]}40Q104Q112
@112@0:8@16@24@32Q40{?=[4]}48
v32@0:8^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}16^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}24
v40@0:8^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}16^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}24^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}32
@32@0:8^{__C3DMesh=}16^{__C3DMesh=}24
{?="pointIndices"^v"pointIndicesStride"Q"pointIndicesFormat"Q"barycentricCoords"^v"barycentricCoordsStride"Q"barycentricCoordsFormat"Q"innerLayerInfluences"^f"innerLayerInfluencesLength"Q"innerLayerTNBs"^f"outerLayerTNBs"^f"tnbMatricesLength"Q"innerLayerOffsets"^f"outerLayerOffsets"^f"offsetsLength"Q"legacyOffsetsOrTransforms"^f"legacyOffsetsOrTransformsLength"Q}
c24@0:8^{?=}16
@48@0:8@16Q24Q32@40
@"SCNGeometryWrapDeformerParameters"
Q24@0:8@"<SCNGeometryDeformerUpdateComputeContext>"16
{?="vertexCount"I"innerLayerToDeformedTransform"{?="columns"[4]}"outerLayerToDeformedTransform"{?="columns"[4]}}
{?="vertexCount"I"driverToDeformedTransform"{?="columns"[4]}}
@36@0:8Q16Q24c32
@56@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16@48
c20@0:8f16
{CGSize=dd}32@0:8{CGSize=dd}16
v32@0:8d16^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}24
d24@0:8d16
v32@0:8^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16d24
@"NSOpenGLPixelFormat"
@"CALayer"
@"SCNRecursiveLock"
@"<SCNEventHandler>"
@"SCNSpriteKitEventHandler"
@"SCNPhysicsVehicle"
v40@0:8@"<MTLRenderCommandEncoder>"16@"<MTLCommandBuffer>"24@"MTLRenderPassDescriptor"32
@"<MTLCommandBuffer>"16@0:8
v24@0:8^{MainPassCustomPostProcessPass=^^?^{Pass}^{__C3DEngineContext}^{RenderGraph}{PassDescriptor=iSSSSIB^{PassIODescriptor}^{PassIODescriptor}SS}{PassResource=^^{RefCountedResource}^^{RefCountedResource}SS}I{Parameters=CCCCCCCBBB[6]I}BQB^{MainPassCustomPostProcessPassResource}}16
@"SCNMTLRenderContext"
^{MainPassCustomPostProcessPass=^^?^{Pass}^{__C3DEngineContext}^{RenderGraph}{PassDescriptor=iSSSSIB^{PassIODescriptor}^{PassIODescriptor}SS}{PassResource=^^{RefCountedResource}^^{RefCountedResource}SS}I{Parameters=CCCCCCCBBB[6]I}BQB^{MainPassCustomPostProcessPassResource}}
^{SCNCActionScale=^^?d@?@BdddddBB@?^{__CFString}qddddfffffcc}
@48@0:8{SCNVector3=ddd}16d40
@56@0:8d16{SCNVector3=ddd}24d48
@56@0:8{SCNVector4=dddd}16d48
@52@0:8d16d24d32d40c48
@?16@0:8
^{SCNCAction=^^?d@?@BdddddBB@?^{__CFString}qdddd}16@0:8
^{SCNCAction=^^?d@?@BdddddBB@?^{__CFString}qdddd}
@32@0:8q16@24
{?=dddddd}16@0:8
v64@0:8{?=dddddd}16
{?="originX"d"originY"d"width"d"height"d"znear"d"zfar"d}
^{__C3DFXPass=}16@0:8
@60@0:8i16@20{CGSize=dd}28@44@52
@"SKTransition"
^{__C3DFXPass=}
[2@"SCNOffscreenRenderer"]
{?=QQ}24@0:8@16
{?=QQ}32@0:8Q16Q24
@32@0:8Q16Q24
@40@0:8r^v16Q24Q32
@48@0:8^v16Q24Q32@?40
@40@0:8@16^{__IOSurface=}24Q32
@48@0:8@16Q24^@32^@40
v40@0:8@16Q24@?32
c24@0:8Q16
c24@0:8q16
v32@0:8^{?=ff}16Q24
@40@0:8@16Q24Q32
@40@0:8@16q24^@32
{?=QQQ}40@0:8Q16Q24Q32
Q24@0:8q16
{?=QQQ}48@0:8Q16Q24Q32q40
v32@0:8^Q16^Q24
{?=QQQ}24@0:8@16
{?=QQ}24@0:8Q16
{?=QQQ}16@0:8
I16@0:8
v72@0:8r^{?={?=QQQ}{?=QQQ}}16^{?={?=QQQ}{?=QQQ}}24{?=QQQ}32Q56Q64
v64@0:8r^{?={?=QQQ}{?=QQQ}}16^{?={?=QQQ}{?=QQQ}}24{?=QQQ}32Q56
@"<MTLLogState>"32@0:8@"MTLLogStateDescriptor"16^@24
@"<MTLCommandQueue>"24@0:8Q16
@"<MTLCommandQueue>"24@0:8@"MTLCommandQueueDescriptor"16
{?=QQ}24@0:8@"MTLTextureDescriptor"16
@"<MTLHeap>"24@0:8@"MTLHeapDescriptor"16
@"<MTLBuffer>"32@0:8Q16Q24
@"<MTLBuffer>"40@0:8r^v16Q24Q32
@"<MTLBuffer>"48@0:8^v16Q24Q32@?<v@?^vQ>40
@"<MTLDepthStencilState>"24@0:8@"MTLDepthStencilDescriptor"16
@"<MTLTexture>"24@0:8@"MTLTextureDescriptor"16
@"<MTLTexture>"40@0:8@"MTLTextureDescriptor"16^{__IOSurface=}24Q32
@"<MTLTexture>"24@0:8@"MTLSharedTextureHandle"16
@"<MTLSamplerState>"24@0:8@"MTLSamplerDescriptor"16
@"<MTLLibrary>"16@0:8
@"<MTLLibrary>"32@0:8@"NSBundle"16^@24
@"<MTLLibrary>"32@0:8@"NSString"16^@24
@"<MTLLibrary>"32@0:8@"NSURL"16^@24
@"<MTLLibrary>"32@0:8@"NSObject<OS_dispatch_data>"16^@24
@"<MTLLibrary>"40@0:8@"NSString"16@"MTLCompileOptions"24^@32
v40@0:8@"NSString"16@"MTLCompileOptions"24@?<v@?@"<MTLLibrary>"@"NSError">32
@"<MTLLibrary>"32@0:8@"MTLStitchedLibraryDescriptor"16^@24
v32@0:8@"MTLStitchedLibraryDescriptor"16@?<v@?@"<MTLLibrary>"@"NSError">24
@"<MTLRenderPipelineState>"32@0:8@"MTLRenderPipelineDescriptor"16^@24
@"<MTLRenderPipelineState>"48@0:8@"MTLRenderPipelineDescriptor"16Q24^@32^@40
v32@0:8@"MTLRenderPipelineDescriptor"16@?<v@?@"<MTLRenderPipelineState>"@"NSError">24
v40@0:8@"MTLRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLComputePipelineState>"32@0:8@"<MTLFunction>"16^@24
@"<MTLComputePipelineState>"48@0:8@"<MTLFunction>"16Q24^@32^@40
v32@0:8@"<MTLFunction>"16@?<v@?@"<MTLComputePipelineState>"@"NSError">24
v40@0:8@"<MTLFunction>"16Q24@?<v@?@"<MTLComputePipelineState>"@"MTLComputePipelineReflection"@"NSError">32
@"<MTLComputePipelineState>"48@0:8@"MTLComputePipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLComputePipelineDescriptor"16Q24@?<v@?@"<MTLComputePipelineState>"@"MTLComputePipelineReflection"@"NSError">32
@"<MTLFence>"16@0:8
@"<MTLRenderPipelineState>"48@0:8@"MTLTileRenderPipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLTileRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLRenderPipelineState>"48@0:8@"MTLMeshRenderPipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLMeshRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLArgumentEncoder>"24@0:8@"NSArray"16
@"<MTLRasterizationRateMap>"24@0:8@"MTLRasterizationRateMapDescriptor"16
@"<MTLIndirectCommandBuffer>"40@0:8@"MTLIndirectCommandBufferDescriptor"16Q24Q32
@"<MTLEvent>"16@0:8
@"<MTLSharedEvent>"16@0:8
@"<MTLSharedEvent>"24@0:8@"MTLSharedEventHandle"16
@"<MTLIOFileHandle>"32@0:8@"NSURL"16^@24
@"<MTLIOCommandQueue>"32@0:8@"MTLIOCommandQueueDescriptor"16^@24
@"<MTLIOFileHandle>"40@0:8@"NSURL"16q24^@32
@"<MTLCounterSampleBuffer>"32@0:8@"MTLCounterSampleBufferDescriptor"16^@24
@"<MTLArgumentEncoder>"24@0:8@"<MTLBufferBinding>"16
@"<MTLDynamicLibrary>"32@0:8@"<MTLLibrary>"16^@24
@"<MTLDynamicLibrary>"32@0:8@"NSURL"16^@24
@"<MTLBinaryArchive>"32@0:8@"MTLBinaryArchiveDescriptor"16^@24
{?=QQQ}24@0:8@"MTLAccelerationStructureDescriptor"16
@"<MTLAccelerationStructure>"24@0:8Q16
@"<MTLAccelerationStructure>"24@0:8@"MTLAccelerationStructureDescriptor"16
{?=QQ}24@0:8@"MTLAccelerationStructureDescriptor"16
@"<MTLResidencySet>"32@0:8@"MTLResidencySetDescriptor"16^@24
@"MTLArchitecture"16@0:8
@32@0:8^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16@24
v32@0:8@"SCNMTLRenderContext"16@"<MTLCommandBuffer>"24
v40@0:8@"SCNMTLRenderContext"16@24@"NSString"32
@56@0:8@16c24@28c36^v40Q48
32@0:816
v64@0:8^{SCNVector3=ddd}16Q24{SCNVector4=dddd}32
{SCNVector3=ddd}72@0:8{SCNVector3=ddd}16{SCNVector4=dddd}40
v24@0:8^{__C3DScene=}16
@56@0:8{CGPoint=dd}16{CGSize=dd}32@48
c64@0:8@16@24{SCNVector4=dddd}32
@56@0:8@16{SCNVector4=dddd}24
v32@0:8^{__C3DEngineContext=}16d24
c24@0:8^{__C3DScene=}16
v72@0:8d16{CGRect={CGPoint=dd}{CGSize=dd}}24@56@64
v88@0:8d16{CGRect={CGPoint=dd}{CGSize=dd}}24@56@64@72@80
v80@0:8d16{CGRect={CGPoint=dd}{CGSize=dd}}24@56@64@72
v56@0:8d16@24@32@40@48
v64@0:8d16@24@32@40@48Q56
v40@0:8d16@24@32
^{CGImage=}32@0:8d16^@24
^{CGImage=}32@0:8{CGSize=dd}16
@48@0:8d16{CGSize=dd}24Q40
@56@0:8d16{CGSize=dd}24Q40^@48
^{CGImage=}48@0:8d16{CGSize=dd}24Q40
^{CGImage=}56@0:8d16{CGSize=dd}24Q40^@48
@32@0:8{CGSize=dd}16
v40@0:8Q16c24c28@32
{?="frameBuffer"^{__C3DFramebuffer}"multisamplingFrameBuffer"^{__C3DFramebuffer}"drawableSize"{CGSize="width"d"height"d}}
@"SCNRendererTransitionContext"
{?="supportsUpdate"b1"supportsDidApplyAnimations"b1"supportsDidSimulatePhysics"b1"supportsDidApplyConstraints"b1"supportsWillRender"b1"supportsDidRender"b1"supportsInputTime"b1"supportsReadSubdivCache"b1"supportsWriteSubdivCache"b1"supportsMainPassCustomPostProcess"b1}
{C3DColor4=""(?="rgba"[4f]""{?="r"f"g"f"b"f"a"f}"simd")}
@"__SKSCNRenderer"
@"<_SCNSceneRendererResourceManagerMonitor>"
@"<_SCNSceneCommandBufferStatusMonitor>"
@40@0:8^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16{CGSize=dd}24
@40@0:8@16{CGSize=dd}24
@48@0:8@16@24{CGSize=dd}32
c32@0:8@16^24
v40@0:8@16d24@32
@"<_SCNSceneRendererDelegate><_SCNSceneRendererDelegateSPI>"
i20@0:8i16
@"MTLArgument"
@"<MTLArgumentEncoder>"
^{?=@?II}
^{?=^{__C3DFXPassInput}II}
^{__C3DFXPassInput=}
v34@0:8@16Q24{?=cc}32
@18@0:8{?=cc}16
[31@]
[16@]
^{__C3DFXMetalProgram=}
{?="colorFormat"[8Q]"depthFormat"Q"stencilFormat"Q"sampleCount"C}
[2I]
@"<MTLRenderPipelineState>"
@"MTLVertexDescriptor"
@"<MTLFunction>"
@"<MTLComputePipelineState>"
@"MTLStageInputOutputDescriptor"
@"SCNMTLBuffer"
@128@0:8@16{SCNVector3=ddd}24{SCNVector3=ddd}48@72{SCNVector3=ddd}80{SCNVector3=ddd}104
@72@0:8@16{SCNVector3=ddd}24{SCNVector3=ddd}48
{?="bodyA"@"SCNPhysicsBody""bodyB"@"SCNPhysicsBody""axisA"{SCNVector3="x"d"y"d"z"d}"anchorA"{SCNVector3="x"d"y"d"z"d}"axisB"{SCNVector3="x"d"y"d"z"d}"anchorB"{SCNVector3="x"d"y"d"z"d}"minLinearLimit"d"maxLinearLimit"d"minAngularLimit"d"maxAngularLimit"d"motorTargetLinearVelocity"d"motorMaximumForce"d"motorTargetAngularVelocity"d"motorMaximumTorque"d}
^{btSliderConstraint=^^?ii(?=i^v)fBBi^{btRigidBody}^{btRigidBody}ff^{btJointFeedback}BB{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}BffffffffffffffffffffffffffffBBi[3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}][3f][3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}]f{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffBfffBfff}
^{SCNCActionMove=^^?d@?@BdddddBB@?^{__CFString}qdddddcc}
v32@0:8^?16^v24
{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}
^{__C3DKeyframedAnimation=}16@0:8
v24@0:8^{__C3DKeyframedAnimation=}16
^{__C3DKeyframedAnimation=}
c36@0:8d16c24^v28
@24@0:8^{__C3DTimingFunction=}16
^{__C3DTimingFunction=}16@0:8
^{__C3DTimingFunction=}
@24@0:8^{__C3DAnimation=}16
v24@0:8^{__C3DAnimation=}16
^{__C3DAnimation=}16@0:8
^{__C3DAnimation=}
@"SCNTimingFunction"
@24@0:8^{__C3DAnimationPlayer=}16
^{__C3DAnimationPlayer=}16@0:8
^{__C3DAnimationPlayer=}
@"SCNAnimation"
#40@0:8@16@24@32
#40@0:8@"NSKeyedUnarchiver"16@"NSString"24@"NSArray"32
@32@0:8@"NSKeyedUnarchiver"16@24
v40@0:8@"NSKeyedUnarchiver"16@24@32
v24@0:8@"NSKeyedUnarchiver"16
@32@0:8Q16@24
@40@0:8Q16@24^@32
^{__C3DScene=}32@0:8@16@?24
@40@0:8#16@24@?32
@32@0:8@16@?24
@40@0:8#16@24^@32
^{__C3DSceneSource=}16@0:8
^{__C3DLibrary=}16@0:8
@24@0:8#16
c48@0:8@16Q24@?32@?40
^{__C3DSceneSource=}
@24@0:8^{__CFArray=}16
@24@0:8^{__C3DHitTestResult=}16
{CGPoint=dd}24@0:8q16
^{__C3DHitTestResult=}
v20@0:8I16
v48@0:8@16@?24@?32@40
v56@0:8@16@?24@?32@?40@48
v48@0:8@"<MTLTexture>"16@?<v@?@?<v@?@"<MTLComputeCommandEncoder>">>24@?<v@?@?<v@?@"<MTLBlitCommandEncoder>">>32@"<SCNMaterialPropertyTextureProviderHelper>"40
v56@0:8@"<MTLTexture>"16@?<v@?@?<v@?@"<MTLComputeCommandEncoder>">>24@?<v@?@?<v@?@"<MTLBlitCommandEncoder>">>32@?<v@?@?<v@?@"<MTLCommandBuffer>">>40@"<SCNMaterialPropertyTextureProviderHelper>"48
^{__C3DImage=}32@0:8@16Q24
^{__C3DImage=}36@0:8@16i24*28
^{__C3DImage=}28@0:8@16i24
^{__C3DImage=}24@0:8@16
@24@0:8^{__C3DImage=}16
^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture}^v)b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}20@0:8c16
v24@0:8^{__C3DImage=}16
{C3DColor4=(?=[4f]{?=ffff})}16@0:8
^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture}^v)b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}16@0:8
^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}16@0:8
v80@0:8(C3DMatrix4x4=[16f][4]{?=[4]})16
^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture}^v)b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}
^{__C3DImage=}
^{CATransform3D=dddddddddddddddd}
@40@0:8d16d24@32
@48@0:8d16d24d32@40
@24@0:8^{__C3DFloor={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}ffffifffQ}16
^{__C3DFloor={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}ffffifffQ}16@0:8
v32@0:8d16q24
@"SCNPhysicsBody"
@24@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16
v24@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16
c48@0:8@16@24^@32^@40
{?=cCCC}16@0:8
v20@0:8{?=cCCC}16
{?="enableVertexWeldingAtImport"c"boundaryInterpolationRule"C"faceVaryingInterpolationRule"C"normalSmoothingMode"C}
@"SCNGeometrySource"
@"SCNGeometryElement"
@"SCNGeometryTessellator"
@"SKScene"
v28@0:8f16f20f24
v48@0:8{CGPoint=dd}16{CGSize=dd}32
v24@0:8f16f20
v52@0:8f16{CGPoint=dd}20{CGSize=dd}36
{?=}24@0:8o^f16
{?=[4]}48@0:81632
v56@0:8{CGPoint=dd}16{CGSize=dd}32d48
v64@0:8{CGPoint=dd}16{CGSize=dd}32{CGPoint=dd}48
48@0:8{CGPoint=dd}16{CGSize=dd}32
{?=}32@0:8{?=}16
c48@0:8{CGPoint=dd}16{CGSize=dd}32
v32@0:8{CGPoint=dd}16
{?="angles""initialAbsoluteAngles""initialTransformWorld"{?="columns"[4]}"initialOrientationWorld"{?="vector"}}
{?="start""current""last"}
{?="localArcballAdjustement""sphereLocationStart""sphereLocationCurrent"}
{?="inertiaEnabled"B"inertiaRunning"B"lastSimulationTime"d"friction"f"rotationSensitivity"f"translationSensitivity"f"velocity""timer"@"NSTimer"}
@"<SCNCameraControllerDelegate>"
44@0:816f24{CGSize=dd}28
v44@0:8@16@24@32f40
v32@0:8q16@24
@"SCNManipulator"
@"SCNMTLLibraryManager"
@"<MTLLibrary>"
v24@0:8^{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIdddddddddddddddIIIIIIIIIIIIIIIIIdIdIdddd[60d]Idd}16
v128@0:8{?=^{__C3DFXMetalProgram}^{__C3DMaterial}^{__C3DGeometry}^{__C3DFXPass}^{__C3DFXPass}@^{__C3DBlendStates}^{__C3DNode}CCCCCC@{?=C@?}Q}16@?120
@"SCNMTLLibrary"
@"NSMapTable"
@40@0:8@16^@24*32
@"<MTLTexture>"32@0:8@"NSURL"16^@24
@"<MTLTexture>"40@0:8@"NSURL"16^@24*32
@"<SCNMaterialPropertyTextureProvider>"
^{SCNCActionHide=^^?d@?@BdddddBB@?^{__CFString}qddddc}
v56@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16@48
f20@0:8f16
{CGPoint="x"d"y"d}
@24@0:8^{__C3DSkinner=}16
^{__C3DSkinner=}48@0:8@16@24@32@40
^{__C3DSkinner=}40@0:8@16Q24Q32
@56@0:8@16@24@32@40@48
@176@0:8@16@24@32@40{CATransform3D=dddddddddddddddd}48
^{__C3DSkinner=}16@0:8
^{__C3DSkinner=}
@40@0:8@16Q24^@32
@48@0:8@16@24@32Q40
c48@0:8@16@24Q32^@40
c40@0:8@16Q24^@32
{__zFlags="providerSuppliesContents"b1"providerSuppliesStreams"b1"providerSuppliesProperties"b1"noContentsCaching"b1"fileOpen"b1"reserved"b27}
[5^v]
v32@0:8{_NSRange=QQ}16
v40@0:8@16{_NSRange=QQ}24
@"<MTLTexture>"40@0:8@"MTLTextureDescriptor"16Q24Q32
v40@0:8@"NSString"16{_NSRange=QQ}24
@"<MTLBuffer>"24@0:8@"<MTLDevice>"16
v52@0:8@16^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}24c32q36q44
v68@0:8@16c24q28q36Q44Q52Q60
v24@0:8r^v16
v32@0:8^{__C3DFXMetalProgram={__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}[2^{__CFString}]^{__CFString}^{__CFString}^{__CFDictionary}^{__CFSet}^v^{__CFDictionary}i@?@?QI}16^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[8{?=CCCb1b1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}[9f]^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}C^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}@?@?^{__CFDictionary}^v}24
@24@0:8^v16
@32@0:8^{__CFData=}16Q24
v32@0:8^{__C3DMesh=}16@24
@36@0:8^{__C3DDeformerStack=}16^{__C3DNode=}24C32
@44@0:8^{__C3DSkinner=}16^{__C3DMesh=}24C32@?36
@44@0:8^{__C3DMorpher={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DGeometry}^{__C3DMorph}^{__C3DMesh}II^fII}16^{__C3DMesh=}24C32@?36
@"SCNMTLShaderBindingsGenerator"
@"SCNMTLBufferAllocator"
{?="registry"@"NSMapTable""lock"{os_unfair_lock_s="_os_unfair_lock_opaque"I}}
@"SCNMTLShadableKey"
@"MTKTextureLoader"
v24@0:8^{__C3DNode=}16
^{__C3DNode=}16@0:8
@"AVAudioNode"
@"AVAudioPlayerNode"
@"SCNAudioSource"
^{__C3DNode=}
@32@0:8r^{btPersistentManifold=i[4{btManifoldPoint={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffiiii^vBfffffffi{btVector3=(?=[4f])}{btVector3=(?=[4f])}}]^{btCollisionObject}^{btCollisionObject}iffiii^{c3dContactCallback}}16q24
v96@0:8@16@24{SCNVector3=ddd}32{SCNVector3=ddd}56d80d88
v40@0:8r^{btPersistentManifold=i[4{btManifoldPoint={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffiiii^vBfffffffi{btVector3=(?=[4f])}{btVector3=(?=[4f])}}]^{btCollisionObject}^{btCollisionObject}iffiii^{c3dContactCallback}}16q24r^{btManifoldPoint={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffiiii^vBfffffffi{btVector3=(?=[4f])}{btVector3=(?=[4f])}}32
^{btCollisionShape=^^?i^v}32@0:8@16@24
v44@0:8{SCNVector3=ddd}16c40
v68@0:8{SCNVector3=ddd}16{SCNVector3=ddd}40c64
v52@0:8{SCNVector4=dddd}16c48
@"SCNPhysicsShape"
@24@0:8^{__C3DParametricGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=ffffffffffffiiiiiiiiiiiI}{?=^?^?^?^?^?^?}^{__CFData}}16
v24@0:8^{__C3DParametricGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=ffffffffffffiiiiiiiiiiiI}{?=^?^?^?^?^?^?}^{__CFData}}16
@40@0:8d16d24d32
v64@0:8@16@24^{__C3DEngineContext=}3240d56
d40@0:8@16^{__C3DEngineContext=}24^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}32
@48@0:8@16@24Q32@?40
c36@0:8c16d20d28
^{__CVDisplayLink=}
^{SCNCActionRotate=^^?d@?@BdddddBB@?^{__CFString}qddddfccccc}
@40@0:8@16Q24@32
@24@0:8i16i20
@32@0:8^v16@24
^{btCollisionShape=^^?i^v}16@0:8
^{btCollisionShape=^^?i^v}
@128@0:8{?=^{__C3DFXMetalProgram}^{__C3DMaterial}^{__C3DGeometry}^{__C3DFXPass}^{__C3DFXPass}@^{__C3DBlendStates}^{__C3DNode}CCCCCC@{?=C@?}Q}16@120
^{__C3DFXMetalProgram=}20@0:8c16
v376@0:8@16{?={?=^{__C3DFXMetalProgram}^{__C3DMaterial}^{__C3DGeometry}^{__C3DFXPass}^{__C3DFXPass}@^{__C3DBlendStates}^{__C3DNode}CCCCCC@{?=C@?}Q}@{?=[8Q]QQC}^{__C3DBlendStates}[8Q]C@@@@@@@?CBBB}24@368
@360@0:8{?={?=^{__C3DFXMetalProgram}^{__C3DMaterial}^{__C3DGeometry}^{__C3DFXPass}^{__C3DFXPass}@^{__C3DBlendStates}^{__C3DNode}CCCCCC@{?=C@?}Q}@{?=[8Q]QQC}^{__C3DBlendStates}[8Q]C@@@@@@@?CBBB}16
@64@0:8{?=@@@@?BBB}16@56
@44@0:8@16@24@32c40
@56@0:8@16@24@?32@40@48
@40@0:8^{CGColorSpace=}16^{CGColorSpace=}24@32
@68@0:8I16@20@28@36^{CGColorSpace=}44^{CGColorSpace=}52@60
@"NSArrayController"
@"NSObject"
@"NSTableView"
@"NSValue"
@"SCNUIVector4TextField"
{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}24@0:8@16
v24@0:8^{__C3DEngineNotificationQueue={__CFRuntimeBase=QAQ}^{__CFDictionary}^{__CFDictionary}{os_unfair_lock_s=I}dBBB^v}16
^{__C3DEngineNotificationQueue={__CFRuntimeBase=QAQ}^{__CFDictionary}^{__CFDictionary}{os_unfair_lock_s=I}dBBB^v}16@0:8
@80@0:8@16{SCNVector3=ddd}24@48{SCNVector3=ddd}56
@48@0:8@16{SCNVector3=ddd}24
{?="bodyA"@"SCNPhysicsBody""bodyB"@"SCNPhysicsBody""anchorA"{SCNVector3="x"d"y"d"z"d}"anchorB"{SCNVector3="x"d"y"d"z"d}}
^{btPoint2PointConstraint=^^?ii(?=i^v)fBBi^{btRigidBody}^{btRigidBody}ff^{btJointFeedback}[3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}]{btVector3=(?=[4f])}{btVector3=(?=[4f])}iffB{btConstraintSetting=fff}}
^{c3dPhysicsField=^^?{?=[4]}{?=[4]}fffIBBBBf}16@0:8
^{c3dPhysicsField=^^?{?=[4]}{?=[4]}fffIBBBBf}
@24@0:8^{__C3DFXTechnique={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}qq^^{__C3DFXPass}b1b1b1b1b1I^{?}^{__CFDictionary}^{__C3DNode}^{__CFArray}^{__C3DFXTechnique}^v^{__CFString}^{__CFString}}16
^{__C3DFXTechnique={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}qq^^{__C3DFXPass}b1b1b1b1b1I^{?}^{__CFDictionary}^{__C3DNode}^{__CFArray}^{__C3DFXTechnique}^v^{__CFString}^{__CFString}}16@0:8
^{__C3DFXTechnique={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}qq^^{__C3DFXPass}b1b1b1b1b1I^{?}^{__CFDictionary}^{__C3DNode}^{__CFArray}^{__C3DFXTechnique}^v^{__CFString}^{__CFString}}
^{?=^{__C3DFXPass}^{__C3DFXTechnique}^v^{__C3DEngineContext}^{__C3DCullingContext}^{__C3DFXProgramObject}d^v^{__C3DRendererElement}qCC}
@32@0:8^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[8{?=CCCb1b1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}[9f]^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}C^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}@?@?^{__CFDictionary}^v}16@24
^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[8{?=CCCb1b1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}[9f]^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}C^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}@?@?^{__CFDictionary}^v}
@24@0:8^{__C3DMorph=}16
#24@0:8@16
^{__C3DMorph=}16@0:8
d24@0:8@16
v32@0:8d16Q24
d24@0:8Q16
d32@0:8Q16r^v24
v80@0:8@16@24@32@40@48@56@64@72
^{__C3DMorph=}
@"SCNFixedSizePage"
@"NSMutableIndexSet"
@40@0:8r^v16Q24@32
@"CALayer"16@0:8
@24@0:8@"NSString"16
@56@0:8{SCNVector4=dddd}16@48
@48@0:8{SCNVector3=ddd}16@40
@152@0:8{CATransform3D=dddddddddddddddd}16@144
v32@0:8@"CAAnimation"16@"NSString"24
v32@0:8@16@"NSString"24
@"CAMediaTimingFunction"16@0:8
v24@0:8@"CAMediaTimingFunction"16
@"NSColor"48@0:8d16d24d32d40
v24@0:8^{CGPath=}16
@"<SCNCameraControlConfiguration>"16@0:8
@"SCNCameraController"16@0:8
@"CAAnimation"16@0:8
v24@0:8@"CAAnimation"16
@24@0:8@"CAAnimation"16
@"SCNPhysicsBody"16@0:8
@128@0:8@"SCNPhysicsBody"16{SCNVector3=ddd}24{SCNVector3=ddd}48@"SCNPhysicsBody"72{SCNVector3=ddd}80{SCNVector3=ddd}104
@72@0:8@"SCNPhysicsBody"16{SCNVector3=ddd}24{SCNVector3=ddd}48
v40@0:8@"NSString"16q24@?<v@?@"<SCNBufferStream>"@"SCNNode"@"<SCNShadable>"@"SCNRenderer">32
v40@0:8@"NSString"16@"NSString"24@"NSDictionary"32
@"NSString"24@0:8@"NSString"16
@"<SCNProgramDelegate>"16@0:8
v24@0:8@"<SCNProgramDelegate>"16
v24@0:8@"<MTLLibrary>"16
d24@0:8q16
@"SCNMorpher"16@0:8
@"SCNGeometry"16@0:8
@32@0:8@"SCNGeometry"16d24
v72@0:8d16{CGRect={CGPoint=dd}{CGSize=dd}}24@"<MTLCommandBuffer>"56@"MTLRenderPassDescriptor"64
v64@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16@"<MTLCommandBuffer>"48@"MTLRenderPassDescriptor"56
v32@0:8@"NSArray"16d24
@32@0:8^v16@"NSDictionary"24
@32@0:8@"<MTLDevice>"16@"NSDictionary"24
v24@0:8@"SCNAudioPlayer"16
v32@0:8@"SCNNode"16Q24
v32@0:8@"SCNNode"16@"SCNNode"24
@"SCNNode"28@0:8@"NSString"16c24
@"NSArray"24@0:8@?<c@?@"SCNNode"*>16
v24@0:8@?<v@?@"SCNNode"*>16
{SCNVector3=ddd}48@0:8{SCNVector3=ddd}16@"SCNNode"40
{CATransform3D=dddddddddddddddd}152@0:8{CATransform3D=dddddddddddddddd}16@"SCNNode"144
@"NSArray"72@0:8{SCNVector3=ddd}16{SCNVector3=ddd}40@"NSDictionary"64
v24@0:8@"SCNParticleSystem"16
@"SCNNode"24@0:8@"NSString"16
@"SCNLight"16@0:8
v24@0:8@"SCNLight"16
@"SCNCamera"16@0:8
v24@0:8@"SCNCamera"16
v24@0:8@"SCNGeometry"16
@"SCNSkinner"16@0:8
v24@0:8@"SCNSkinner"16
v24@0:8@"SCNMorpher"16
v24@0:8@"SCNPhysicsBody"16
@"SCNPhysicsField"16@0:8
v24@0:8@"SCNPhysicsField"16
@"<SCNNodeRendererDelegate>"16@0:8
v24@0:8@"<SCNNodeRendererDelegate>"16
@"SCNNode"24@0:8@"SCNGeometry"16
@24@0:8@"MDLObject"16
@80@0:8@"SCNPhysicsBody"16{SCNVector3=ddd}24@"SCNPhysicsBody"48{SCNVector3=ddd}56
@48@0:8@"SCNPhysicsBody"16{SCNVector3=ddd}24
v32@0:8@"SCNMaterial"16Q24
v32@0:8Q16@"SCNMaterial"24
@"SCNMaterial"24@0:8@"NSString"16
@"NSArray"24@0:8@"NSString"16
@"SCNGeometryElement"24@0:8q16
@"SCNMaterial"16@0:8
v24@0:8@"SCNMaterial"16
@"SCNGeometryTessellator"16@0:8
v24@0:8@"SCNGeometryTessellator"16
@"SCNGeometryElement"16@0:8
v24@0:8@"SCNGeometryElement"16
@"SCNGeometrySource"16@0:8
v24@0:8@"SCNGeometrySource"16
@32@0:8@"NSArray"16@"NSArray"24
@40@0:8@"NSArray"16@"NSArray"24@"NSArray"32
@24@0:8@"MDLMesh"16
@"SCNMaterialProperty"16@0:8
@"NSURL"16@0:8
v24@0:8@"NSURL"16
@24@0:8@"MDLLight"16
@24@0:8@"MDLMaterial"16
v40@0:8q16@"NSArray"24@?<v@?^^v^Q^Iq>32
v40@0:8@"NSArray"16q24@?<v@?^^v^Qqqf>32
@"SCNParticleSystem"16@0:8
@32@0:8@"NSString"16@"NSString"24
@24@0:8@"SCNNode"16
@32@0:8@"SCNGeometry"16@"NSDictionary"24
@32@0:8@"SCNNode"16@"NSDictionary"24
{_NSRange=QQ}16@0:8
@60@0:8@16q24q32q40c48q52
@48@0:8@16q24q32q40
@60@0:8@"NSData"16q24q32q40c48q52
@48@0:8@"NSData"16q24q32q40
@24@0:8@"MDLSubmesh"16
@76@0:8@16@24q32c40q44q52q60q68
@32@0:8r^{SCNVector3=ddd}16q24
@32@0:8r^{CGPoint=dd}16q24
@76@0:8@"NSData"16@"NSString"24q32c40q44q52q60q68
@"SCNScene"32@0:8@"NSDictionary"16@?<v@?fq@"NSError"*>24
@"SCNScene"32@0:8@"NSDictionary"16^@24
@32@0:8@"NSString"16#24
@"NSArray"24@0:8#16
@"NSArray"24@0:8@?<c@?@@"NSString"*>16
@32@0:8@"NSURL"16@"NSDictionary"24
@32@0:8@"NSData"16@"NSDictionary"24
@24@0:8@"MDLCamera"16
v32@0:8d16@"SCNNode"24
d24@0:8@"SCNNode"16
v32@0:8@16@"<NSCopying>"24
@"SCNTechnique"24@0:8@"NSDictionary"16
@"SCNTechnique"24@0:8@"NSArray"16
v24@0:8@"SCNPhysicsBehavior"16
@"NSArray"40@0:8@"SCNPhysicsBody"16@"SCNPhysicsBody"24@"NSDictionary"32
@"NSArray"32@0:8@"SCNPhysicsBody"16@"NSDictionary"24
@"NSArray"288@0:8@"SCNPhysicsShape"16{CATransform3D=dddddddddddddddd}24{CATransform3D=dddddddddddddddd}152@"NSDictionary"280
@"<SCNPhysicsContactDelegate>"16@0:8
v24@0:8@"<SCNPhysicsContactDelegate>"16
@"SCNPhysicsShape"16@0:8
v24@0:8@"SCNPhysicsShape"16
@32@0:8q16@"SCNPhysicsShape"24
@28@0:8c16@?20
@28@0:8c16@?<{CATransform3D=dddddddddddddddd}@?@"SCNNode"{CATransform3D=dddddddddddddddd}>20
@28@0:8c16@?<{SCNVector3=ddd}@?@"SCNNode"{SCNVector3=ddd}>20
@28@0:8c16@?<{SCNVector4=dddd}@?@"SCNNode"{SCNVector4=dddd}>20
@32@0:8d16@?<v@?@"<SCNAnimation>"@c>24
@"SCNAction"16@0:8
@?<f@?f>16@0:8
v24@0:8@?<f@?f>16
@"SCNAction"48@0:8d16d24d32d40
@"SCNAction"48@0:8{SCNVector3=ddd}16d40
@"SCNAction"52@0:8d16d24d32d40c48
@"SCNAction"56@0:8d16{SCNVector3=ddd}24d48
@"SCNAction"56@0:8{SCNVector4=dddd}16d48
@"SCNAction"32@0:8d16d24
@"SCNAction"24@0:8@"NSArray"16
@"SCNAction"32@0:8@"SCNAction"16Q24
@"SCNAction"24@0:8@"SCNAction"16
@"SCNAction"24@0:8d16
@"SCNAction"24@0:8@?<v@?@"SCNNode">16
@"SCNAction"32@0:8@?<v@?@"SCNNode">16@"NSObject<OS_dispatch_queue>"24
@"SCNAction"32@0:8@"NSString"16d24
@"SCNAction"32@0:8d16@?<v@?@"SCNNode"d>24
v152@0:8@"SCNParticleSystem"16{CATransform3D=dddddddddddddddd}24
c48@0:8@"NSURL"16@"NSDictionary"24@"<SCNSceneExportDelegate>"32@?<v@?f@"NSError"*>40
@"SCNPhysicsWorld"16@0:8
@40@0:8@"NSString"16@"NSString"24@"NSDictionary"32
@40@0:8@"NSURL"16@"NSDictionary"24^@32
@24@0:8@"MDLAsset"16
@32@0:8@"SCNPhysicsBody"16@"NSArray"24
@"SCNPhysicsField"32@0:8d16d24
@"SCNPhysicsField"24@0:8@?<{SCNVector3=ddd}@?{SCNVector3=ddd}{SCNVector3=ddd}ffd>16
v48@0:8^{__C3DEngineContext=}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24^d32^{?=BB}40
B16@0:8
v60@0:8@16{CGSize=dd}24c40c44@48c56
v56@0:8@16{CGSize=dd}24c40c44@48
d76@0:8@16@24^{__C3DEngineContext=}3240d56c64*68
d48@0:8@16@24^{__C3DEngineContext=}32^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}40
@40@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16^{__C3DMesh=}24@32
v40@0:8^{__C3DScene=}16@24@?32
v48@0:8^{__C3DScene=}16@24@32@?40
v64@0:8^{__C3DScene=}16@24@32Q40@48@?56
v64@0:8^{__C3DScene=}16@24@32@40@48@?56
@24@0:8^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}16
@32@0:8r^d16q24
@40@0:8r^{SCNVector3=ddd}16q24^q32
@40@0:8r^{CGPoint=dd}16q24^q32
@68@0:8@16@24q32s40Q44q52q60
@44@0:8r^f16q24c32^{CGColorSpace=}36
@76@0:8@16^{CGColorSpace=}24q32c40q44q52q60q68
@64@0:8@16Q24@32q40q48q56
@84@0:8@16@24^{CGColorSpace=}32q40c48q52q60q68q76
@96@0:8@16^{CGColorSpace=}24^^{CGColorSpace}32q40q48q56q64q72^q80^q88
s16@0:8
^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}16@0:8
@56@0:8@16Q24Q32Q40Q48
^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}
^{CGColorSpace=}
@24@0:8^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}II^{__C3DMeshElement}CCC{?=c^{__CFData}I^I^{?}SCB}^vfff^v^{__C3DMeshSource}[2]^{?}I}16
^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}II^{__C3DMeshElement}CCC{?=c^{__CFData}I^I^{?}SCB}^vfff^v^{__C3DMeshSource}[2]^{?}I}16@0:8
^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}II^{__C3DMeshElement}CCC{?=c^{__CFData}I^I^{?}SCB}^vfff^v^{__C3DMeshSource}[2]^{?}I}
@24@0:8^{__IOHIDDevice=}16
v28@0:8I16@20
^{__IOHIDDevice=}
^{__IOHIDManager=}
24@0:8@16
{CATransform3D=dddddddddddddddd}144@0:8{CATransform3D=dddddddddddddddd}16
v24@0:8f16c20
v40@0:816q32
c32@0:8^{__C3DNode=}16^{C3DSphere=}24
{C3DSphere=}16@0:8
v48@0:8{CGPoint=dd}16q32Q40
(C3DMatrix4x4="components"[16f]"m"[4]"simd"{?="columns"[4]})
{C3DSphere="vector"}
c24@0:8@"NSEvent"16
@"SCNView"16@0:8
v24@0:8@"SCNView"16
v24@0:8@"SCNCameraController"16
(?={?=ffff})16@0:8
(?="vector""center"""{?="x"f"y"f"z"f"radius"f})
{?="stickyMoveEnabled"B"direction""pickedAxis"Q"userStickyAxis"Q}
{?="automaticLocationUpToDate"B"hasAutomatic"B}
{?="lastDragLocation"{CGPoint="x"d"y"d}"velocity"{CGPoint="x"d"y"d}"lastDragTime"d}
{?="lock"{os_unfair_lock_s="_os_unfair_lock_opaque"I}"keyCodeConfiguration"@"NSDictionary""keyDown"{set<unsigned short, std::less<unsigned short>, std::allocator<unsigned short>>="__tree_"{__tree<unsigned short, std::less<unsigned short>, std::allocator<unsigned short>>="__begin_node_"^v"__pair1_"{__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<unsigned short, void *>>>="__value_"{__tree_end_node<std::__tree_node_base<void *> *>="__left_"^v}}"__pair3_"{__compressed_pair<unsigned long, std::less<unsigned short>>="__value_"Q}}}"forward"{vector<unsigned short, std::allocator<unsigned short>>="__begin_"^S"__end_"^S"__end_cap_"{__compressed_pair<unsigned short *, std::allocator<unsigned short>>="__value_"^S}}"backward"{vector<unsigned short, std::allocator<unsigned short>>="__begin_"^S"__end_"^S"__end_cap_"{__compressed_pair<unsigned short *, std::allocator<unsigned short>>="__value_"^S}}"left"{vector<unsigned short, std::allocator<unsigned short>>="__begin_"^S"__end_"^S"__end_cap_"{__compressed_pair<unsigned short *, std::allocator<unsigned short>>="__value_"^S}}"right"{vector<unsigned short, std::allocator<unsigned short>>="__begin_"^S"__end_"^S"__end_cap_"{__compressed_pair<unsigned short *, std::allocator<unsigned short>>="__value_"^S}}}
{?="hasShift"B"hasOption"B}
@"SCNCameraController"
@"<SCNCameraNavigationControllerDelegate>"
c32@0:8@16#24
c40@0:8@16^d24^d32
@32@0:8@?16i24c28
v36@0:8@16i24@?28
v40@0:8@16i24c28@?32
v40@0:8@?16@?24@?32
q40@0:8@16@24Q32
v64@0:8@16@24^{__C3DFXMetalProgram={__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}[2^{__CFString}]^{__CFString}^{__CFString}^{__CFDictionary}^{__CFSet}^v^{__CFDictionary}i@?@?QI}32^{__C3DMaterial=}40^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}48^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[8{?=CCCb1b1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}[9f]^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}C^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}@?@?^{__CFDictionary}^v}56
{?="stage"i"arguments"@"NSArray""customBlocks"@"NSDictionary""pass"^{__C3DFXPass}}
c64@0:8@16{CGSize=dd}24Q40@48^@56
@72@0:8@16{CGSize=dd}24@40@48:56^v64
@56@0:8@16@24@32:40^v48
@"NSError"
@56@0:8@16{CGSize=dd}24@40@48
v56@0:8^{CGImage=}16{?=qiIq}24@48
v72@0:8{?=qiIq}16@40^{__CVMetalTextureCache=}48@56@?64
@"AVAssetWriterInput"
@"AVAssetWriterInputPixelBufferAdaptor"
@"AVAssetWriter"
@120@0:8{?=@@{CGPoint=dd}{CGPoint=dd}{SCNVector3=ddd}{SCNVector3=ddd}d}16
v120@0:8{?=@@{CGPoint=dd}{CGPoint=dd}{SCNVector3=ddd}{SCNVector3=ddd}d}16
c120@0:8{?=@@{CGPoint=dd}{CGPoint=dd}{SCNVector3=ddd}{SCNVector3=ddd}d}16
r^{?=f^vf}32@0:8Q16Q24
v52@0:8S162036
116@0:816{SCNVector3=ddd}32d56B646884^B100^q108
@"NSOrderedSet"
(?="axisMove"{?="originalPosition""axisDirection""mouseDeltaVector"}"planeMove"{?="originalPosition""planeNormal""pointInPlane""mouseDeltaVector"}"axisRotate"{?="rotationSign"f"originalRotation"})
{?="positions"^"orientations"^"originalLocalMatrix"^{CATransform3D}"scales"^}
^{?=f^vf}
@"SCNBillboardConstraint"
^{__C3DConstraint={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__CFString}fBB{?=^?^?^?^?^?^?}^v}16@0:8
v24@0:8^{__C3DConstraint={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__CFString}fBB{?=^?^?^?^?^?^?}^v}16
^{__C3DConstraint={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__CFString}fBB{?=^?^?^?^?^?^?}^v}
@"<SCNMetalLibraryProvider>"
@"<MTLLibrary>"24@0:8@"<MTLDevice>"16
c48@0:8@16I24I28@32@40
v48@0:8@16I24I28@32@40
^{__C3DFXTechnique=}16@0:8
^{__C3DFXGLSLProgram=}24@0:8q16
v32@0:8^{__C3DFXGLSLProgram=}16@24
@"SCNProgram"
@"NSNumber"
@64@0:8@16@24@32@40q48Q56
@"<SCNShadable>"
v24@0:8^{__C3DTextGeometry={__C3DShapeGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__C3DMesh}[16C]}{?=^{__CTFrame}^v^viiBBB{CGRect={CGPoint=dd}{CGSize=dd}}}}16
@24@0:8^{__C3DTextGeometry={__C3DShapeGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__C3DMesh}[16C]}{?=^{__CTFrame}^v^viiBBB{CGRect={CGPoint=dd}{CGSize=dd}}}}16
{?={?=cddid^v^v}^v^viiBB{CGRect={CGPoint=dd}{CGSize=dd}}d}16@0:8
@"NSBezierPath"
@"NSFont"
{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}
v88@0:8^{?=fIIQQ}16^{?=I^{__C3DGeometry}^{__C3DMeshSource}^{__C3DMeshSource}Q}24*32Q40*48Q56Q64^I72@80
v72@0:8^{?=fIIQQ}16^{?=I^{__C3DGeometry}^{__C3DMeshSource}^{__C3DMeshSource}Q}24*32Q40Q48^I56@64
Q40@0:8@16@24@32
^{__C3DMorpher={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DGeometry}^{__C3DMorph}^{__C3DMesh}II^fII}
^{?=fIIQQ}
v24@0:8^{__C3DShapeGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__C3DMesh}[16C]}16
@24@0:8^{__C3DShapeGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__C3DMesh}[16C]}16
{?=cddid^v^v}16@0:8
{?="bodyA"@"SCNPhysicsBody""bodyB"@"SCNPhysicsBody""anchorA"{SCNVector3="x"d"y"d"z"d}"anchorB"{SCNVector3="x"d"y"d"z"d}"axisA"{SCNVector3="x"d"y"d"z"d}"axisB"{SCNVector3="x"d"y"d"z"d}}
^{btHingeConstraint=^^?ii(?=i^v)fBBi^{btRigidBody}^{btRigidBody}ff^{btJointFeedback}[3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}][3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}]{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}ff{btAngularLimit=fffffffB}ffffBBBBBfifff}
v40@0:8@16q24d32
@40@0:8@16q24^{__C3DLOD=}32
^{__C3DLOD=}
v40@0:8@16@24#32
@32@0:8@16^Q24
@48@0:8C16^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}20s28c32c36^Q40
@76@0:8C16^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}20^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}28s36s40c44c48^Q52^Q60^Q68
@"<MTLBuffer>"32@0:8@"<MTLBlitCommandEncoder>"16^Q24
@"<MTLBuffer>"48@0:8C16^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}20s28c32c36^Q40
@"<MTLBuffer>"76@0:8C16^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}20^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}28s36s40c44c48^Q52^Q60^Q68
@"<MTLBlitCommandEncoder>"16@0:8
@"MTLStageInputOutputDescriptor"16@0:8
v24@0:8^{SCNMTLComputeCommandEncoder=[31@][31Q][128@][16@]@@@^{SCNMTLBufferPool}I[2Q][1Q]}16
{?={?=[4]}{?=[4]}{?=[4]}}16@0:8
^{SCNMTLComputeCommandEncoder=[31@][31Q][128@][16@]@@@^{SCNMTLBufferPool}I[2Q][1Q]}16@0:8
v24@0:8@?<v@?@"<MTLCommandBuffer>">16
^{__CFString=}16@0:8
#24@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16
v46@0:8@?16@?24@?32{?=cccccc}40
v20@0:8{?=cccc}16
v25@0:8@16{?=B}24
{?=[6]}16@0:8
v32@0:8^{?=@@@@@@@@@@@@}16@24
^{__C3DDeformerStack=}
^{__C3DMesh=}
{?="isActive"c"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}
{?="maxIndex"I}
@"<MTLBlitCommandEncoder>"
{?="modelViewTransform"{?="columns"[4]}"modelViewProjectionTransform"{?="columns"[4]}"projectionTransform"{?="columns"[4]}}
{?="screenResolution""worldPlanes"[6]}
^{SCNMTLComputeCommandEncoder=[31@][31Q][128@][16@]@@@^{SCNMTLBufferPool}I[2Q][1Q]}
{?="srcPositions"@"<MTLBuffer>""dstPositions"@"<MTLBuffer>""srcNormals"@"<MTLBuffer>""dstNormals"@"<MTLBuffer>""srcTangents"@"<MTLBuffer>""dstTangents"@"<MTLBuffer>""dependency0Positions"@"<MTLBuffer>""dependency0Normals"@"<MTLBuffer>""dependency0Tangents"@"<MTLBuffer>""dependency1Positions"@"<MTLBuffer>""dependency1Normals"@"<MTLBuffer>""dependency1Tangents"@"<MTLBuffer>"}
@"SCNMTLMorphDeformer"
@"SCNMTLSkinDeformer"
@"<SCNMTLMeshlessDeformer>"
@"SCNMTLSmoothNormalsDeformer"
v32@0:8@"MTLStageInputOutputDescriptor"16@"<MTLFunction>"24
@"<MTLComputeCommandEncoder>"16@0:8
@"SCNMTLDeformerStack"
@"SCNGeometryDeformer"
@"<SCNGeometryDeformerInstance>"
{?="srcPositions"{?="isActive"c"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"dstPositions"{?="isActive"c"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"srcNormals"{?="isActive"c"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"dstNormals"{?="isActive"c"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"srcTangents"{?="isActive"c"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"dstTangents"{?="isActive"c"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"dependency0Positions"{?="isActive"c"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"dependency0Normals"{?="isActive"c"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"dependency0Tangents"{?="isActive"c"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"dependency1Positions"{?="isActive"c"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"dependency1Normals"{?="isActive"c"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"dependency1Tangents"{?="isActive"c"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}}
@"<MTLComputeCommandEncoder>"
ABGR
ARGB
ABGR
AhGR
AfGR
7> }#>
X=&RX
@(#)PROGRAM:SceneKit  PROJECT:SceneKit-602
?BxM@
?A.}?
\\CR+
?b]\BR+
!BR+
?rF\AR+
;A9)
!A '
,>I
u^@Jb
?p[M@8g
g&X=b
!!J=
fl(=7
)z =;
?pA6
7R6<<
yj?%
Mh?Z
#=;
xC%]
/A%]
|@%]
/@%]
|?5]
P?%]
/?%]
?hQ;A6
@!@F
g>h]
@>1^
?@%@!:D
?#,*
 {}=
u?|`G
#q<A
?`vo?
lI<U
nj?v
?MMf?
b?0b
~?cC[Cw
B[Bw
!A@
~?op
/[A^
~?lh
~?vl]@\U
L@e4
ywt>n
W'7>
!\!>
n=9{
?o*r?
?^Lo?
JDx<4
y;B<
5h?'
CGv}?
DCGv}?
DBGv}?
AGv}?
DAGv}?g*
@Gv}?QNZBC
@Gv}?Mc BC
@Gv}?/
D@Gv}?
@Gv}?v(
?Wv}?+
?Wv}?
?Wv}?
?hv}?
I Ae
?hv}?
_~_?yv}?
v}?oG
-?!w}?
y}?%x
w}??+
x}?T
=@)>
-AV>
SXI>
~?g|
>k+~?
>S@~?
?MKl
cCw=
K;5=
?sex?X
l? Aq
?6;j?
4f?}
?2td?
|?V4
|?^;
|?AM
+nA@
|?WF
|?:&
X?A|?
-?75|?D4
|?(`[@
.@u:
>hA|?
>-y|?
B[^>
}?m6
0>l$}?,
&>9G}?B
~?[C
=G;~?
=Qg~?
R||=eR
?SYl?
?Igd?
58D@Pz?\
C@Pz?q
B@Pz?
B@Pz?%
A@Pz?
-;A@Pz?
A@Pz?%b
@@Pz?
@@Pz?9
og@PPz?
&;@PPz?
@aPz?
@rPz?
Pz?+
?]Qz?
f?d[z?0v
lz?@
?XVz?
\z?.
?*pz?:wI@
:@s,
-@:"
z??T"@C
}_>I
{?=H
.8S>
<>^K|?
>&8}?
w}?@
j~?%Z
?!g
~?kI
?!;{?
8ho=
?G=t?2
n?Dj
?> l?
g?C9Q
f?hz
Rd?r7
Gx?f
Gx?<
t3@(Hx?
@IHx?
@kHx?^
Hx?3
Ix?k
Lx?r
?%\x?
A*q?e
G<5?DQx?
%?:[x?
cX@m
yx?\
x?K?9@G
>,ay?
>Y3z?
pz?c
tg>[
5^Z>e
M>=H{?
{?6!
=|?gC
|?4f
&~?A
=&m~?
~?F#w?~
?K:n?
?5Ad?;
u?nK
u?jP
RH+A
@#fF
u?za
Bv?{I
w?ZJv?W\
%a?a5v?c
v?%$i@9
<v?\
?J]v?
@xC:
v?eT@
>q<w?Zg
?c^'
%x?k
>lvx?
OZx>
~y?l
y??p
/3\>RHz?
A>2 {?
%\(>T
>#h|?mX
}?%]
~?Xps?
N&n=
?Swi?
Rs?h
jV?B
Rs?Z
BB%^
Ss?i
@.Ss?
AG ^
@PSs?
cyAv
IG?@
"@~Ts?
x}@
Us?y
@S@Z
\{?L
f@:w[
}s?ccT@L
N|A?%
`s2?_
s?h!)@b
@x*P
Ht?3
>`tu?E
>F}v?
>Ww?
y?m7
XVJ>
CU<>w
.>t}{?
=`=~?
m?zq"
`=0f
@k?`
,,8=W
?W]g?
e?UlL
ip?Q
ip?@
ip?u
@]jp?
R@Hkp?n^0Aj
@t|t
?Cpp?28
?Oyp?
p?{ 
p?A+d@W[q
,aU?
A@pCl
5$6?8,q?/3'@v
q?hz
q?dw
?)#r?$
qr?_
>yxs?bJ
?`ZD
t?F
du?p
5]_>
|z?J
Q|?v
|?t}?K
u?ZI
=tD~?
o?y\T
j?tF
?_%g?
?1{e?
cb? 
8m?Y
8m?`WLC
8m?n
A"9m?H
@u9m?
9m?a
@`:m?
;m?s
;m?Z
(@2=m?
>m?W
@-Bm?
?/Qm?
m?p\?@m
n?[|
?9}m
o?((
?SXi
p?*W
>)uq?
?1|4
>zru?
8v?h
w?;8
YR>shy?
>[@|?
u?>y
}?WCr?
l?->E
}X/=V
?8Ke?
r%<n
?RDb?
WICz5
6lxB;
VIB+4
oAt'
~+A7
?(Fj?a
?GVj?pP
?gCj?
aL@jk
<@#J
"@Y5
9?Idk?
?T:l?
?*ow
n?G9
?\tR
?uv2
av?I+
Sw?E
>x?f
9aR>
f11>
L|?l
x?B\
~?${l?v
~?ZJj?
|r=II
?l[h?
J='
e?p_
?B%b?j
f?q&FC
f?;!FB2
f?>{
M*@'
@EKf?
}f?M
f?d>I@
9@oF
[,@U
if?yYg?F\ @
jG?]
Hh?9
?-|i?
?[j?
?9*w
m?]1
n?=c
?FzQ
s?C7
?C86
6u>?
y?1~
y?Q/
"5->
w|?r
=$)}?
q?pa
=/P~?n
l?mTg
?vmc?
t@PA
BA7o
N5@2
@Zeb?1
E@2:
?v7c?<
&ru?K
$:?f
e?]R
ze?|+
f?bg
?;og?
?J)h?
>@jo?
?jL8
Mhr>7
9>%$z?
{?gdt?
q}?,En?
k?Q/x
\=bf
Gc?*
]?t`BL
a_\A
]?$ZcA
F\@C
@K>^?
@Mh^?
MB@HO
5_?<
&@>=
o`?\
M/E?
$?!;c?B
k?jK
?6!-
u?dv
2x?b
E>Yy?
pz?yxw?n
>]O|?
Yk?_
g~?8,i?
~?.Wg?H5,
duk=
rQ-=
?fld?-z
`"^<
a?RI
_Y?{
_Y?=:;C
1B `Y?,
A1`Y?:8;B
LA$cY?
gY?A1;A
g@zrY?
&Z?C~
?gCZ?U3v@
Z?vo>@
,0@v
[#@0
?BZ[?d 
S[~?{
[?h$
W\?~V
O?t]?
ByC?
&8?)
?[^y
j?% 
?g|o
>Zl?Q
>74q?0d
?H67
O |>
e>37w?/
 B<>
v?|(
{?8gp?
y=i:
?>xe?
L8=y
17C0
T?]+7B-
T?O=
hU?i
@V?of:@
W?h^
Z?p]Y?
Ig,?
?! _?
a?of
>]Oh?
uo?y
?w1M
0s><2v?
dx\>
Cz? $s?k
>Va{?
<}?_
`h?L8t
c? 
?->a?Z
9()
O?+X
2B6"
N}Al
O?)}
O?~{
&8}@l
P?{i
nQ?]
E@d\
^R?9
S?R&
AV?l
U?)"
y J?
*?Q1Z?
?5}^?
a?l\
? }c
`s?_B
>u"u?{/~?
gh>"
Q>(Hx??Tv?
l?%t
|?o.j?@
=Sz~?
8f?\TK
d?2r
M= y
^b?(
J?<t
hnID0
hICA
J?Gp{B
J?Qg{A
J?PE
hK?3
R@9^
?(,M?
?_AN?{
4G?|
dY?,F
?OYm
?:ZE
N~[>
az?4/o?
Pl?]
=&R~?5
O!W=<k
E6rE?
cPDGrE?ER
`PCGrE?
BXrE?
w_PB
sE?<
vE?}(
yE?|
A(}E?
`JAk
dF?$Q
`@80
?8.G?
?%xG?
G?aR-@cc
H?nR
?kfI?'i
K?;R
L?u;
N?|`O?
@R?0
i6'?
b? )
>)wg?k
Al?Gq
n?)_
t?T5y?&W!
voe>g
v?6ru?HR
]x?8
>j.{?
S}?G:g?
=R)~?wge?
a%C}
@?'(nB
@?N!nA
Ap>
@[%@?
@y<A?
<B?@
6@5z
?`WC?Y
?{gD?
?VHE?
o~?2ZG?
xCb?
&V?x
\?I
>jKe?z
>t~j?
do?@
q?F"|?it7
<>TTy?
3%>i
j=3N
RcEd
E8e:?
\D8e:?+
\CIe:?
BZe:?Q
e:?1&gB`
B4f:?
AAg:?7
i:?q
k:?3
o:?D.gA
t:?;
|:?l
U{@I
S;?+O
#@p"
>?31
?`;@?l=
?ULA?'J
? zB?
ui?!"E?~S
Q?l!H?M
o/=?
N?OW
TP?Z
>A+`?
>,gk?l?
GD>`
Zz?Q
~?;5c?
?m6b?
_?RI
_\ESX
 bC'
4?!N
4?\*9A
763@&
 @9'6?
PM@.
?|d7?
f8?!u
8?l[
>?pA
bJp?
i@?q
c}'?
'O?9
W?Aa
q?oHw?l@4
J&g>jNv?n
K>}<x?
|m?~
.?XY
.?\E
%p6A
%3AP
.??G
.??D
i/?)
iog@m
K!M@
yy$@\r0?
J1?R
W2?/
5?Bz
d=?;4
S?jKA?O
$?;pN?
tQ?P
e?*o
?-@{
>h"h?Z
>b,k?
p?+lv?
%8>c{y?
4j?*
`e?m
=-|}?
=Dj~?UOb?-]A
?W]_?{i
LkDY
h%kB
SQBY
UQAHm
-A~Q
(?/b
@g))?
s:@l>*?
GS@7
j0?s
1B|?b
LTc?
:?` 
<KD?
?`#U?
X?1C
>f.\?/
_?5$
>o)c?
f?mU~?
r?l>.
=XS}?
=sL~?]
,`?;
FEen
yA9B
"?q"A
@_)#?
zz@)
f=@wI$?7Pa@
JF*@Y
J)?lC
?5+?Ve
?aq,?
h?t%6?M
o??9
/6?&9D?
z$?4
?/PR?9
Y?>{
]?/0
Ph?]Qz?
x?\;i?d
=[$}?
ia?{JN
oAMe
o Ak,
?@cD
2@@L
A#@:
@zo ?f
?o+!?
$?c+
?g'?
PnW?
:?,}@?
W?~5
>W|[?
d{?J
>sLj?
p?9Cq?hA8
9J>K!x?
!f?d
c?jP
|?)#b?
?Mg_?
E^?A
>tD;:
+UtC~:
LtB6;
S:Be
LKtA=I
AA&R
?)]:AO
,Y@2
A@T6
-`.@
?,b ?
}#?J
%?S]
}?X;*?
rq?0
('f?
~s[?,
2?8e
cY?<
>2wa?H
y?O=
>gce?
o>aUu?
>9`{?
c`?g,Z
rSC=M
c\Ap
eyBA
?Sxx@
$@-w
"?>>
`%?y
-(?V
K_? _.?k
uwU?
Q9?v
=?c_
y\0?
?W^N?z6
z}?n
OW?p
y?lC
_?Z)x?
c?@1v?*
8t?+
o?FDA
*u>~
U>;5w?
g7>uXy?^
e?Zb
> ${?
_?F&`
H=J{
^?!w
p]?()
=_wC%
|^wB!
*BBC
n?:
x?9{#?h
E?$c5?rS
GG?(
L|?
z?/j
Jy?D
>dvb?
s?KXk
gj??6q?
8q?K[l?
2V{>w.t?
{d?(
z?wKb?
^?>v
M=%t
?Y) E
?7I~C
xCM1
@~B2
wB{2
?7H~A
CAeR
b@'P
J@sf
i8E@
5%@)Z
p?="?Eh
3nR?*
-6?`
:?nR}?GU
D?%yz?p_
BN?4
S?(*w?fO
>UPe?K
>;Vi?
Sv?;pf?
>8H|?
^?Xtk
>tBs@
W@81
Hj1@
?o~?
ms?y
p$L?DO.?j
Qz?z
Pu?b
q?ZI
>QNh?
8l?_
m?1&M
xze>
2D>%Xx?
|{W=ge
hUwCj
eBEF
ZswB*
PcwA
a5A%
isCA
t\@'
>yW7@
"1@V
$D @D
wk?6r
#s?N
)O?*:r?
j?wI<
|r?q
g?Kw'
i>;qu?
Re?>
)>A-z?rm`?
?^f\?d>
z[?8
O9()
aYDq
#RvD
>Z7YC
aUw@B'
>.:B@
-@3k
D@0g
j0@s
}?:A
l#Z?<
C=Q?
e'?m
#H?hw,?
p?Ec
8.??U
KY6?
T5-?
k<?F
W?\Xo?_^
n?}=
j?HQk?BxT
hn?,Fi?
g?NE*
P}?p
\?i7z
Z?0e
TtDT
v]tC
MtB!
%@/@
?kz?5
?(~?
r?|c
?vnn?
RS?}
$?"6l?
q=J?@M)?B>l?
{8?cF4?
Hm?D
m?x^
?R_V?_|m?
i?TWj?
^q?@Pf?,F-
c?|E
bw?vka?&W
{?5@]?\
[?O?(
d=HQ
?4/[?
Rq?{O
z?B|?
#k?Y5
q?s*
[i?0d
g?d!
?Ich? D
^?LT
Fg?`!
iL?6;&?
Cg?@
DNC?
1?{gh?
1?$|7?S
x(?5c=?!
?bfC?
j?B$
/k?M
?;TO?p[k?
xk?6
z_?m
k?+m
>qVd?
 j?>
PS>(
y?qs^?-
>R}{?
`~?c
Z?AD*
4Cro
GlAPT
4A[B
>S>O@l
Yjp@
>r4"@2
>@S@
>h=l?
e?h$
B#|?YL
gr?6<
h?gb
V?;q
]c?UN
T:<?1(/?j
Gt3?
e?pB
K;?K
`A?%
tc?X
>\!h?-
hb?t
>2V{?=
.Z?3O.
u*kD}x
kC%y
%AR@
DN)@p?
z?,
>o-c?
]?I,
U4j?/
[?('
>vO?
M ?Ii^?
G?tz&?
t_?z
`?]5
c?AJ
E?/5f?R
Ig?g
?k'R?i
{]?k-h?
Y~>Xps?
[Y>$
\?#1
>b,{?W
=kF~?
mY?xE0
o=%>
?)$Y?
TX?Ug59
fD5y
fCcz
v?j.
#]?S
>2!V?-
U?. 
B$k?
Ib?@
4X?+
?H?
??_\*?
v6?P
f7?3
V?||f?
>k?]
>O[o?Fc?
S9>m
{?l]Z?
Psr=
0bD[
Q5bCE
>A`>
oH5@
qW#@-
O?7Q
?&rQ?o
<S?g
B!R?
?`#U?
[?p%
_?Af
B?t\a?
2I? 
c?[C
[?*7e?
PS;>
[?Sw
z?d\Y?1
|?2>X?: 
)~?o
\D76
\C"7
N~.A
M@hu
^@lZ
~;1@<
>34z?
d?%\
vH?k
?tzJ?
4/S?
U?ys
lA?k*_?Q2
H?x
T?,cc?
d?Qkz
^r?F
uw=>}zx?
YW?#
<x=0,
U?M.F9{i
VA9c
y#@r
Tqv@
4Y@:x
@?[#
{?XW
A?IG
?~9G?$
I?zQ
S?PQ
+kK?
?vmO?s
#?_\R?
W?nl
Z?ca
uM?v
`?Xq
c_?[
d?8Nb?(Ig
ta?p]Q
>D0n?
c>:yu?
[?9G
|?_{V?>
E28j>.
.PD28j>
apPC
:j>(
B.=j>
Ej>9
OlPAc
q@[]
y;@u
r?J_
>?UY?
W8?*T
>Zg8?
>Eg9?
;?0G
g|k?
c?Jb
!B?Q
\!\?4
IcT?
1?KW0?n
>?hyZ?
Ga?w
#d?^+a?
k`?v
e>NFu?
/x?^
vU?*
|=h#
T?w,
nIDK U>
pICd"U>
kIBs.U>
A2uW>er[@
[>%\
G`>l
 L@;9c>
?_\z>
o?t~
3?/k
P1?:
3?,+
5?29
Dc?q8
@?s-
-CD?
+O?Qi
.?=IR?
rQ)?cD6?
U?x%
*?5
?EGR?
9^?/
T^?Z
_?R(k
Xm?8
>|}q?%
u?B{Y?4
x?]5W?
q|?{gT?
#|Dg&
Am:B>
@cGC>
jD>[#'@
7_@F`L>$
@>%W>
1k?1
C?6t
>*o'?
'?p}
>+Q*?T
d,?Z
2?[&
H5?e
5`T?
?of@?
?)<D?
nH?D
><?t`%?
9E3?
O?we
O=*?M
l<? 
Z?ip
>Qjc?hu^?Uik
]?P9V
 >{iz?
T?X7
g|?tbS?
R?y]
EG8->
=->Q
:B|G->
]->~O
:AI+.>
2@tb
1>8J
@"U4>
Su@l
2WV@
>9>b
Dm(@
@>Ig
?bhU>
G?qq
? cn>h
>h[)?:
M1o?}<
S?yv
<?<2
@L? 
*?_~3?
1\!?
;;?O
S?v3
cW?(H\?>
w]?b
c?W@]?
>*8h?
AE>K
&">WCz?
>Oy@@
j@36$>|
K>3Q,?
?Dku>x
I*{?2W
cat?q
>"U$?W
+?*o
4?oI
R?kH?tA9?
uYD?H
?I+B?
"?7RF?
8*?V
T?J@
?9)P?nRY?
[?-@k
>v6|?
eP?Z
@D% 
3z\A
Y*@%
@4C@
!u?`
|!>O
J?(c
:?.q
 Z> 
?-!
1l?=G
~#?1\
e?4f
6#_?
$1?.
?(|:?
?d:H?
?$aO?
Z?h\
X?X:?
j>k~t?a
3E>J
>^0|?
}?_DO?
O?u"
?:>N?
*-D&
b^PA,
=x%8@[_
t@DN
>o/q?
>kcX?Pn
>EID?vq
?nn,>
YY>m
?1h>
Vx>kD
JEW?b
-?,~
P?*p
2?kJ
7?Kr
?6\<?
);?K
H63?-])?.UE?
U"?{k8?
P?<J
X?dxl
>wig?TUX?
p?YnU?
aE>
O?>>
lN?G
L?0b
LIBB
=>iIA`
CA,
|,?p"
\>B%
Zy?w
?. 
-\?1#
?^g/?F
`H?j
lA?y
C?B`
M?T6T?
ra?kdW?k
.T?4
'P?FA
>S>|?u"M?
L?B@>
4L?H
FK?I
+Ce6
l,B\8
=Fu,Az5
AOy
{@q9
]4:@i
2L?u
?Nd&>
mb>2
?&nu>
Hkp?
>io?/
o`?1
]Z?ZF
HkT?
TVG?
!Y@?%v
mE?5'
?;9G?
(p?a
F>h]w?@
5|?:\K?
*gA
F]G@
E?Cs
?y=(>Re
?f3G>D
}?Tt
%h?i
bL?!
[?1T?+
S?BxD
@kn>
BO?@
iy=y;
Bmuy=)
@Y@x_u
TAFx{=
~=y;
>RF|
->lv
x?I,
j?`>
`?Di
[?XU
N)W?
?j4!?/
?~T'?
-?Yl
=?8j
RH6?N
8?>]
$G&?j
wA?9
,I?&
[L?;
[?-&R?
>]Ra?
>_@k?*VQ?
hs?J
qG>V
H?tB
G?K;
B['^
Ao.^
@b-^
AR(K=
K=ur.@
~?YR^
S?Tr^
r'@5
>Lkc
>LRi
]}?W
^>_$
]x?C
s?5}
o?@j
2^?B%
I?2Y
*?x(
W0?[
e??'
^G?$
?6!I?
{V?s
(b?^
)p?k(M?L
s?!VK?
}?cAE?J
Q*+BH
9!=~
5<wA
n+Amp"=
/$=^
Z&=S
F~y@
?O@w
>whH
>gDI
>\WL
?O#m=
>>\R
>c'\
{?Z)D>
v?LmY>
zpo?
g?2u
`? `
[?EH
":?t
]o+?
v8?4
u=?rp
I?3QH?z
b?7qN?
L?3P9
B>rjw?u?G?
+4 >J
%D?wh
mB?6[
QA?:
o@VJ/
@0,/
?n1/
?I=D
>]P?
>XtK
Pq?XrU>V
g?rR
c?}x
?{K
O?*6
bK?O<
, ?{
C??H
L8?~
,?p|
1?LU"?
/1?-
B?$BC?
-J?g}F?
!Q?|
Tm?k
gq?~
>Vfz?
=Ed|?
B?,G
0@W'
2?RG
w>A(
?S[*=
-c>n
=&Se>
>3Qd
;p~?
iWy?
;h?6
e?y 
M?5}
\;I?h
vo=?
\6?
*?vl4?
N ?EJ3?g
?RC;?
=?GW
gJ?taD?
>DoQ?
c?K>J?
m?<OH?
q?p{F?0
\>h[u?
9>GTx?
?.v;?
X}<`
X}<6t
3tA{2
<pB]?
<|ds>
&=`t9>
<>_%
I>W`8
<fx?
Xt?YN
Y?((
]oS?a
E?!#
54?U4
q-?SB
<^?%
H?XSY
tY>r
u?9bA?
75>n
z?Mj<?
};?8.c
=1_~?
[Z=Ee
r"<*
I$DB
#<@1
8G? $
@>"&<
f:<b1
!F<bIY>82
?,go<
.=nm!>
(>HR"
<X>K
=zpg>
|Eg?
=Umw>k
b?SA%>7m
Q>IM
M.2?
P,?#
"?-!+?.r
4?V,
[;?,a9?=C
XJ?f2@?
EQ?1
FE?}
h?h=D?L
B?Bv.
su?9
<?vp
1>Pqx?g
z?`x9?
|?tF8?
7?wf
5?9&
tR:D
6)<G
I<RF
E}?*
k#=y
mD=y
+>dw1
d?LP
Q1b?
{;>G
P4W?
-@W?
lCU?
<jT?d
<?d\
)!0?
tD*?
6?'1
=?=I
??n2
>QfW?.
A?dx\
>D5m?
Z=?G
(S>k
|?}v4?
=b1~?}
 1?E
_#'C)
AE/#;
8R>u
%L;s
GI<R
?rk?
&U? 
 :>%>G
PnS?6Y
$T?I
v7S?
Q?29U>.
S?g{
K?0e
6wH?
j.?=
 ? &
&?S!
2?Tq/?
:?14?
B?:>6?
?^JI?
=?sK
Rb?*
(8?MM"
S6?q
3>/jw?
74? 
2?p[
+?=C
rSyC
#:g&,@
@@QY:\
hxw?
8$=N
kGm?%
_=~p~
_\^?
jhS?
N?F_
. =%Z
$^J?r
C=gG
1[J?`:
(eJ?
^*J?
=By?>
>UMP>
*>1xx>j
!L?e
zpK?
/A?5
B/?\Y
2'?H
1?TU
?{0A?6;2?
.9?N
x8?4
f[?>
>7?N
mf?i
>_)k?Z
}>p_o?
zX>W#s?F
7>[av?
,?em
=PS{?
;.VT
t?zl
<O<'
/4o?
;RcB=
T=nl
1?5_
+k3?
p=xC
1??S
8?d[
MI:?
F<?z
,>Ovc>7
KY>?
Z>|B
@?Ab
e??.
98?G
,4?Q
0?EG
"?Id
*?o-
?(G9?
?/N@?
|_?*
.?~tZ
ji?z
1*?'
Z>V~q?.u0?
u?->)?
+|?iR"?F?
Pr@_\z?
?BxM@m
>@,dv?
@(Gq?
?=ae?
?8hC?
?%#3?
?A.}?
r?9B
j?}[
Vh?L
d?fk
h\AX
Pr@d[z?
?5|M@
1@'1t?
?D0R?
?tM?
?w0>?
?#/3?
?5Dy?Q
r?9B
d?;m
?6}\B
k\Ai
@/Pn?
?5~M?
?u"}?p
Cy?T
?3Qh?:"
i\A&
@D2|?
Pr@zRz?
?cDb?
?YnM?
??:y?7
yj?B
?\}\B
@cc~?
@Xs|?
?XSM?
?! 3?
?o/y?
o?GX
?Xuj?
?gEh?|{
If?'
@p&~?
Tr@\>z?
?]NM?
?seH?
?8j-?
u?kG
>h?E
?ud?
?-h\A~
@fN{?
@t~z?
@<ln?
?K>b?
?u[V?
?fg-?
|?I.
?}]r?
vo? 
?M0h?
6f?&
?/md?
@Xuz?
?<k1@
@3lp?
@oEn?
?>"b?
?Qg^?
y?Gs
?!Wj?d
?Z+f?[{
?>Zd?
?'hr@
?<g1@
@/Rp?
?*Re?
?"S^?
?>$H?
?vl8?
xu?M
Hr?3
?[`o?-|
Lj?3
?"m1@Z
?Y3Z?
?-Ar?
?9Bj?
?Fe\A
j1@D
@JDp?
@AGk?
@{kh?
?$%e?
?|D8?
x?Y
d?ys
?Kg\A
@%\|?
>@l>v?
@L8p?
?V~a?
cu?U3
?4,r?!
?}#j?
g?t~
?Lf\A
@-y|?
?>%_@
M@~ow?
?>]a?
?x_=?
?_au?G
?p}l?
j?QN
?S%b?
f\AL
@!V{?
+_@9Dx?
M@cGw?
? }%@
@y"p?
?{hG?
?h^B?
?i8=?
?du'?
a?"r
@nR}?
`r@s
?o/_@
`1@E.t?
?c{%@
?&4Y?
?%g\A
?kf1@+
@1_j?
@HQg?
?<k'?
r?DR
o?(}
ue?b
?,~c?
?he\AI
@lZ}?
@sG{?
_@R+x?
>@p]u?
n1@<
?}y%@O
@B@j?
?P92?
?[`'?
|?>Y
?ZGu?
?zSe?S
?iUc?
ra?RI
?3e\A
@<L{?
^@S>x?
?!#N@
?1x%@y
?(d7?
?z9?
?rMu?B
n?9&
i?_y
Rg?U
?Dh\A
@UK~?
?6u%@'jq?
?&o?
?Hh\A
@=E~?
@0K{?
N@GZv?
?2r1@0
?A+<?
?CV'?
y?$b
Fu?Ho
ii?0
?:i\A
@S<~?
@%=|?
@ZE{?
?@uYt?
?>z1@
?>y%@
@HNf?
?{2_?
?]m}?
?t&y?
?1Eu?
?mVi?y
`?#,
~\B7
h\A5
@hB{?
~%@C
@Efn?
?/1J?
?+Ny?
?kfu?bL
n?,D
?w1i?
f?GX
?}v\C
@j/~?
@{2{?
%@r3p?
?~Qb?
}?hx
?Miy?
n?hw
i?Ym
?~~\C
?]~\B
?9}^@#Ix?
>@>$t?
@ywh?
@Ife?
?dvV?
?N*N?
?e6@?
?Sw1?
1~?K
ju?~r
?<hf?
?Ti\A
@S!~?
M@;Uv?
%@~so?
?Y6;?
?c_6?
?Nc'?
y?1$
n?p%
h?cd
?l>f?
?5]_?
?Kh\A
@wj~?
@[^}?
?Sv^@
v1@w
z?_$
?~pn?`
?ock?
h\A!
?is^@`
?Na1@
@YPl?
?cdY?
?E.D?
?sI1?
Mz?Y
u?O?
?MLk?
?YQc?(
^?r3
|\BL
"At^
@5{|?
q@"9y?
s^@0
?ur%@
@XWi?
?QO??
?Tp,?
?K>n?
?!>h?
e?)#
?)B^?
?@~\C
?F~\B;
"AB?
@}[|?
@tb{?
?+k^@
~M@D
91@} q?
?R`%@
?x`P?
?,.n?[y
h?Ig
?UM`?
?${\B
h\A+
?Pr^@.Sw?
}M@0
?pw>@'ls?
?nM%@
@I-h?
@nme?
@/ob?
?&6_?
?+kG?
?)z,?
Ov?-
n?%]
?+m]?
@R~~?
@;m}?
?Sw^@j
>@S s?
!1@;
?G9%@3
?H2[?
?@1:?
? &1?
?|{#?
Rv?/
d?is
?jg\A
q@1]x?
?e5%@|
?b0S?
?gG>?
?;71?
?+5{?^
v?#2
m?LT
?huj?B
jd?w
|\B?
i\A>
!"A,
@.:}?
@1{y?
^@mpv?
?}x>@
?d"%@
@?9j?
?$^V?
?4L1?
?Bx(?
Ha?8f
;A33
@LO|?
?&8Y?
?B!R?
?HRN?
?;QF?
?1`1?
{?Qk
`?O 
?_z[?
?&p\AN
@C7{?
@p&z?
r@XYw?
@% f?
?t{5?
?px1?
?dsm?
?XYc?>
?Sx`?
?s~\B3
%"Ai
@#g}?
?#2r@
@k'b?
?B]T?
?%<!?
?1\m?
?Bwi?P
/]?g}
?{JZ?
?("A
A|e~?
@xD}?
@=(x?
Lr@%
%@@jk?
?8HP?
~\B7
+"As
AbL~?
@Hp{?
M@$Gr?
!1@G
?BBL?
?`".?
?]Q*?
Oe?%Y
^?+j
?6H\C
@;9w?
>@|`o?
%@@1j?
?J|2?
?Xo|?
v?u
?Hkh?s
?2wa?fJ
?AJX?_
0"AU
@oe}?
?_D_@
$@}ui?
?`>A?
?.=:?
?%>/?
? }+?
?nn ?
q?~6
l?5y
?[x\C
?X:"A
@Gt{?
?.u_@
?[A1@
l?\8
?2p\C
?3 <A
@82w?
?AGN@Dio?
?P:1@
}|?)
v?D5
.g?9|
?5Fc?
2Y?X
?2}\B
?)%<A
?3["A
3%@Y
@T8^?
?JE'?
f?`u
]X?c{
?>0<A.s~?
AY0}?
@%X|?
@tyw?
M%@.
@xFc?
@Ae`?
@BzZ?
?W"T?
?2!>?
?=H;?
?h#/?
?]7%?
x|? ]
Bf?D
b?e7
H^?~
D<Aj/~?
r"AV
@(cx?
?p>?@
?'l%@
@&Vb?
??sJ?
?NDG?
?J{#?
}|?73
?Iiv?
?Crj?/R?
"ANa}?
@N+y?
?J`?@
1@uvf?
@2Xa?
?<j(?
?8/v?S
d??n
z`?Z-
Q?`X
h<AT
Ad>|?
#t@/
N@b-j?
1@AIe?
@%][?
?:>V?
?MLK?
?^fH?
u?ip
?Umo?
qT?SX
?i~\B
]A_&~?
@REy?
`@.8k?
?&4&@
@k`_?
?l|N?
?*tF?
?x(>?
?q9&?
?S?#?
{?k(
?:WdE
?3s[C
?|0]A
AxB{?
@yx?
?t}t@l!l?
?uUO@
@o,\?
?B!J?
?'3b?$
h\BJ
`@$Eh?
}O@;
?^i@@
@KuY?
?`sF?
?oK<?
?;n4?
?k2?
?WB{?
?x%m?
?uXa?S
OX?|
L?i5
.\C~
?fV\B
?Ac]Ac`}?
@:Wx?
O@Wwd?
?G!@
?t)R?
?<KP?
?8eN?
?o~C?
?NC4?
{?&r%?
9`?R~
g[?a
?v3O?
|\BL
?Wj#Aw
@K9w?
tA@'
~4@h
@!@Z?
?2uC?
?rN<?
?H27?
?I0-?
?t(s?A
k?^c#?
M?]5
I?Ul
?hG)E
A7n}?
]A@i|?
?hU=A
@W_q?
?urQ@
?<g??
?9}5?
?TSr?
?]kc?ob$?
O?cD
=Aq=z?
@IHt?
@kdo?
@ Dj?
?Iev@
C@,d^?
?[y!@!
?Yn9?
?40R?;
I?l@
?4~^B
?f0"B
Ak+~?
?aP$A/
@erj?
E@W_]?
-@Wx[?
s#@2
@?6Y?
?%?V?
?SXU?
?O@O?
?]jH?
?9cD?
?1x`?k
DP?M
?r."BS
A}\{?
@-#m?
?eU;@k
?P8W?
?${D?
?[@@?
?(av?:u9?
]X?[
?|FN?
E?U4&?
?|CA?
\B$a
?]OY@*
?Lm3@
@HRZ?
?lAW?
?aPV?
?kGI?
?0fC?
}?2XA?
t?X:??
?zlG?
A&5|?
AhAx?
?H1`A&
?]}?A
?qV%A
@Wzi?
@HPd?
@UN_?
@u[^?
?]jB@9
?BB\?
?@j[?
?=eQ?
r?LqE?
i?x|C?
S?,e=?
N?EJ;?
H?l$9?
?;nD?
?-z;?
?&|!B
A5`x?
?qN%A
A=bh?
?!\r@s
?-]T@
rG@{
;@7R^?
?-@1@
?V~]?
?J%\?
dJ?~9C?
E?XWA?
Au:x?
?Rf%A
@^I^?
i@]P_?
?\qa?
?a3\?
rR?C
?R'L?f-M?
=?TtH?
u8?>
3?V-E?
?gtdB
O@AZ
@6V^?
@R}_?
r@t)b?
?_@V@
R)@U
@)ye?
@;me?
?B'd?
=?%YS?
"/?yxO?
G^Cc
AKYf?
KdAZc`?
,AF}^?
@`ta?
@sHf?
1o@r
F@y=h?
@M/i?
@EHi?
@zSi?
@@Qi?
?cAi?
?l$i?
?P7h?
?X f?
?w.|?
?0.q?C
?r1Z?T
R?F\`?
?(|J?
63?r3\?
?OgyCi
@l&g?
?T9P@
9@I,m?
@xzm?
?4gm?
?P:m?
?5*l?
?H5x?7mj?
?y"`?5
V?CXi?
?G!M?
>?t#h?
`2?JEg?
 "?~
?+l1B.
sC0*m?
?\:iA
A0.q?
?]F+ADPq?
AUgq?
?8fs@_
?Ii'@
av?'
N?p|q?
D?Jyq?
?]66?
?zS1?Doq?
?p}$?
?Adq?
?c`q?
'JjV1:
'N1;
fff?
?fff?fff?
L>fff?
Mb`?
6<Z(
h?d]
?Dio
MbP?
)037
'1<GTer
+4>D
FFFFL
 ,9NN
 ,9NN
333?333?333?
fff?
>333?
fff?
fff?
>333?
?fff?333?
MbP?
>333?
>fff?
FMT[
?(BE(
?ffffff
?fff?fff?fff?
?333333
L=fff?
 >4E44
UUUUUU
p]?q=
333?
333?
333?
33s?aa
FF!(
]bl{
fmw~
(2<eeFeeeeeenee
intensities.
333?G &?C
 #&),
#)/5;AJX
 &,28?EL
8?Sx
tWxCE
Ga==
?33s?333?
&-4<CJ
!#J%')+-/135
&(*,.02468
 5"$&(*,.02
 "$&(*,.02468:<>@B`
DFHJLNPRTVXZ\
lorux
=@CF
ILORU
dgjm
DQdt--------
---------
(5555555-551
***
@ffffff
 ,9NN
)@@@@@@@.@@3@8@@<
!$'*------47:=MP
,:IXg
ffffff
333333
#%')+
ffffff
',149<D
KTX 11
J0J>
333333
?ffffff
?333333
?333333
?ff&?RGBA
&;>
*3?M\`\\f
X\`dhlptxCC|
 */25
 $(,048<@DPTX]k]o
VUU
VUU
i\)7.
blnOq
sy2-
i\)7.
blnOq
sy2-
UUUUUU
>T=t<?Xf?
Q?m7
>|eV?
+?xE`?
|?M2
>~qi>
OV?*
?".
j<F^
g?K"
>G<i>py|?
=?$b
>]Km=
Sq=~7}>K
M:>}
bx?`
> @?
>{1p?
Q?}=_>
ty?*s
s?lx
?)yM?GO{=o
 d=/Pf?
b?f-
>caH?,f
>To)?
1!?&7j>
4m?<l:?%
h?|3
|8>@K
=:#Z>
H?-AF>D4
c;=g
F?Mf
N:?r4
>Kuq>N*B?q
>an_?
>,..>
Ij?mtz?
cU?l
{>;V
?h%=?XT
?mSL>
9$?e
I/>=
j?9}%?
>S}"=x
:b?<1;>
GT?&
?W$&>
AU>6Z
>pyH?
et?=
Z>g&
ld? 
=akf>
rx?Aa
?@/|>
O?;s
H>:y
=?\r
}=?I
>2rN?
<m?!!
%n?VHI>O>E?
M?LOH>
=O\z?
M?3Q
?uUh?
?{Ke?
2?:y
k:>N
O'?L
n?*wz<
Z>]S4?
>~R%?
+:?JC
~?8IC?\
E?l&o?
y!?9DH?%t
>uX?
8>_&
l?3o
?a8W?
:V?#
M?*X
U=6Y
?TR7>
A??0,
?fKb?
N?2Xu?
L'>:>.?@hA?2F
hG>H
J?P9
>E*?
cF?sH
>t}[?
CG=N
&4?S S>k
v9?`
_R?O
z?Qg
<g?}
'?,df?3
m?JE
:==%
>O#->
j?gc
>B{1?
=sIm?
;.Tb?
= $k?
YJ?t
ZQ?1z
^](knNff
&&*-&&4&6&&R
`>9?
`>9?
8-0?
8-0?
Z&>X
Z&>X
5?33
333?
fff?
?333?
?333?
=fff@
US]CQ
^(BM
kZ;&
C3DTransformsArray
v8@?0
transformsArray
transform
identifier
<C3DTransformsArray %p>
C3DFXOutline.plist
Outline-pickedObjects
C3DFXOutlineRetina.plist
C3DFXAuthoring.plist
--OutlineMaterial--
PickedObject.glsl
SCNDefaultIrradiance
_defaultLightingEnvironmentIrradianceTexture.textureType == MTLTextureTypeCube
_defaultLightingEnvironmentIrradianceTexture.pixelFormat == MTLPixelFormatRGBA16Float
SCNDefaultRadiance
_defaultLightingEnvironmentRadianceTexture.textureType == MTLTextureTypeCube
_defaultLightingEnvironmentRadianceTexture.pixelFormat == MTLPixelFormatRGBA16Float
irradianceTexture.textureType == MTLTextureTypeCube
irradianceTexture.pixelFormat == MTLPixelFormatRGBA16Float
radianceTexture.textureType == MTLTextureTypeCube
radianceTexture.pixelFormat == MTLPixelFormatRGBA16Float
compute_diffusePreIntegrated_texture2d
v16@?0@"<MTLCommandBuffer>"8
scn_draw_fullscreen_quad_vertex
cubemap_from_sh
compute_specularPreIntegratedLD_texture2d
compute_specularPreIntegratedLD_texturecube
compute_specularPreIntegratedDFG_diffuseHammon
loader
loadedMipMapCount <= desc.mipmapLevelCount
v20@?0C8r*12
compute_cube_from_equi_views
compute_cube_from_equi
compute_equi_from_cube
sourceImage
Unable to find texture for source %@
sliceCount == SCNMTLComputeTextureSliceCount(dstTexture)
_encoder == nil
commandBuffer != nil
srcTexture.width == dstTexture.width
srcTexture.height == dstTexture.height
srcTexture.depth == dstTexture.depth
_encoder != nil
_computePipelineState
firstIndexOfRange == UINT_MAX
keyCount
!isnan(t)
keyIndex == (int)keyCount
valueWrt == kf->_values + (totalValueSize * keyCount)
source
dest
C3DAnimationClusterKeyframes
<C3DAnimationClusterKeyframes %p>
C3DAnimationCluster
<C3DAnimationCluster %p>
object
CFGetTypeID(animation) == C3DKeyframedAnimationGetTypeID()
kf->_keytimes[index+1] >= (float)time
scene
SCNMonitor
SCNKitError : can't load nib named : SCNMonitor
SCNKitTypeInspector
can't load nib named : SCNKitTypeInspector
selection
name
address
type
semantic
childs
error in SCNTypeInspectorView : returned object is not a dictionary
instance
NULL
%@ 0x%p
true
false
[%f, %f]
[%f, %f, %f]
[%f, %f, %f, %f]
identity
[%f, %f, %f, %f][%f, %f, %f, %f][%f, %f, %f, %f][%f, %f, %f, %f]
/[], 
_timesToRepeat
_timesRepeated
_repeatedAction
_forever
_opacityTarget
_opacityTargetReversed
_lastOpacity
_isRelative
v28@?0I8^^{__C3DNode}12^^{__C3DLight}20
type < kC3DLightEffectiveTypeCount
C3DLightGetProbeType(light) == kC3DLightProbeTypeIrradiance
C3DLightGetProbeType(light) == kC3DLightProbeTypeRadiance
C3DLightingSystem
node
light
lightingSpaceMatrix
((rInd > 0) && (rInd <= pipelineData->_runtimeLightsCount)) || (rInd == kDefaultRuntimeIndex)
v36@?0I8^^{__C3DNode}12^^{__C3DLight}20^(?={?=ffff})28
v36@?0I8^^{__C3DNode}12^^{__C3DLight}20^28
v36@?0I8^^{__C3DNode}12^^{__C3DLight}20^{?=ffff}28
lightingSystem
lightNode
shadowInd <= kMaxRuntimeShadows
casterIndex > 0
casterIndex <= kMaxRuntimeShadows
<C3DLightingSystem %p>
triggerOptionsForRealtimeViewer
kSceneSourceAutoLimitMemoryForImages
kSceneSourceInvertMaterialOpacity
kSceneSourceCreateCameraIfAbsent
kSceneSourceForceInProcess
kSceneSourceLoadingFromExternalProcess
kSceneSourceCreateLightIfAbsent
kSceneSourceCreateNormalsIfAbsent
kSceneSourceAdjustInvalidClippingPlanes
kSceneSourceFlattenScene
kSceneSourceSplitMeshesForGLES
kSceneSourceConvertToYUpIfNeeded
kSceneSourceConvertToUnit
kSceneSourceAnimationLoadingMode
keepSeparate
playRepeatedly
playOnce
playUsingSceneTime
kSceneSourceCleanupMeshes
kSceneSourceRemoveConstantAnimations
kSceneSourceRemoveAllLights
kSceneSourceRemoveColorArrays
kSceneSourceInterleaveSources
kSceneSourceDeinterleaveSources
kSceneSourceMakeSourcesCheaper
kSceneSourceSkipConsistencyCheck
kSceneSourceCheckConsistency
kC3DIOSceneSourceWasExportedBySceneKit
kSceneSourceUseSafeMode
kSceneSourceAssetDirectoryURLs
kSceneSourceOverrideAssetURLs
kSceneSourceStrictConformanceKey
kSceneSourceVerboseMode
kSceneSourceFormatHint
kSceneSourceProcessIsSandboxed
kSceneSourceSkipSandboxValidation
kSceneSourceSkipImagePathResolution
contributors
created
modified
up_axis
unit
authoring_tool
author
unitName
unitMeter
com.apple.SceneKit
kEnclosingDirectoryURL
C3DSceneSource
Unknown or missing file
Could not load the scene
The document does not appear to be a valid COLLADA file. Please check that is has not been corrupted.
The document does not appear to be valid. Please re-create it from your original COLLADA assets.
<C3DSceneSource >
org.khronos.collada.digital-asset-exchange
C3DParticleModifier
<C3DParticleModifierRef>
version
radiance
irradiance
slot
GaussianBlurPass-Y
GaussianBlurPass-X
scn_draw_fullscreen_triangle_vertex
bloom_blur_%sfrag_%d
smp_
!texture || [texture conformsToProtocol:@protocol(MTLTexture)]
SCNMTLDeviceSupportsDepthClipMode(_encoder.device)
_ptr != NULL
Bloom
CompositePass
COLOR
DOF-Final
AverageLuminance
enableBloom
enableVignetting
enableColorGrading
enableSaturation
enableContrast
enableColorFringe
enableDebug
enableExposure
enableFrameLuminanceAutoExposure
enableHistogramAutoExposure
enableDepthOfField
DOFSampleCount
enableVR
enableAR
enableGrain
grainIsColored
enableWhiteBalance
scn_draw_fullscreen_triangle_VR_uv_uvNorm_vertex
scn_postprocess
color
trcOther == trc
B108@?0{CGColorConversionIteratorData=Iqqqqqq^^{CGColorTRCData}^^{CGColorMatrixData}^^{CGColorNxMTransformData}}8q84q92^q100
B100@?0{CGColorConversionIteratorData=Iqqqqqq^^{CGColorTRCData}^^{CGColorMatrixData}^^{CGColorNxMTransformData}}8q84q92
count * readStride <= read_length
count * writeStride <= write_length
none
float
bool
char
double
C3DFloat
float2
float3
float4
float4x4
float3x3
color4
short
half
uchar
ushort
int2
int3
int4
ucharn
charn
10a2n
u10a2n
uchar4
char4
uchar4n
char4n
ushort2
ushort3
ushort4
short2
short3
short4
ushortn
ushort2n
ushort3n
ushort4n
short2n
short3n
short4n
half2
half3
half4
type < kC3DBaseTypeCount
unknown type
kC3DBaseTypeUnsignedChar
kC3DBaseTypeUnsignedCharNormalized
kC3DBaseTypeChar
kC3DBaseTypeCharNormalized
kC3DBaseTypeUnsignedShort
kC3DBaseTypeUnsignedShortNormalized
kC3DBaseTypeShort
kC3DBaseTypeShortNormalized
kC3DBaseTypeHalf
kC3DBaseTypeFloat
kC3DBaseTypeInteger
componentCount == 1
bytesPerComponent && componentsCount && floatComponents
_dst
string
v32@?0@8@16^B24
hw.optional.sse2
hw.optional.sse3
hw.optional.supplementalsse3
hw.optional.sse4_1
hw.optional.sse4_2
hw.optional.avx1_0
hw.optional.fma
/bin/rm
SCNDisableLinearSpaceRendering
SCNDisableWideGamut
SCNEnableWideGamut
length
(order * order * sizePerCoeff) == length
SKESceneDocument
SKEDocumentSanitizer
v24@?0q8r^v16
sampler1D
sampler2D
sampler3D
samplerCube
vec2
vec3
vec4
ivec2
ivec3
ivec4
mat4
mat44
texture1d
texture2d
texture3d
texturecube
#define %@ %@
SSAORaytracePass
SSAO-DepthNormal
SSAO-MinMaxOffset
SSAOSampleCount
SSAODownSample
SSAOCameraOrtho
SSAOVRRendering
scn_ssao_compute
!geometry->_trackedNodes || !CFSetGetCount(geometry->_trackedNodes)
<%@:%p "%@"
  mesh: %@
  mat%d: %@
serializedData
bindInfos
mesh
overrideMaterial
materials
levelsOfDetail
sceneRef
input
geometry
material
!CFSetContainsValue(geometry->_trackedNodes, node)
geometry->_trackedNodes && CFSetContainsValue(geometry->_trackedNodes, node)
geometry->_trackedNodes
C3DGeometry
path
v16@?0d8
meshElement
elements
channel >= 0 && channel < channelCount
C3DMeshElementGetIndexCountPerPrimitive
indexCount % channelCount == 0
C3DMeshElementGetChannelsDefineSameTopology
C3DMeshElement.c
indicesDataLength > topologyIndicesLength
v32@?0I8^I12I20^B24
CHANNEL %ld/%ld
%4u : %4u %4u %4u
%4u : %4u %4u
%4u : %4u
%2u : [Polygon %4u]
 %4u
C3DMeshElement
<C3DMeshElement %p type:%@ primCount:%d channels:%d indexBytes:%d offset:%d acmr:%f inst:%d dataSize:%d shared:%p>
triangles
triangleStrip
lines
points
polygons
triangleFan
patch
invalid
_C3DMeshElementInitWithPropertyList
doubleSided
linesArray
trianglesArray
pointsArray
trianglesStrip
polygonsArray
indexes
subElementsCount
bytesPerIndex
primitiveNormals
bbox[0]
bbox[1]
__readIndexInBuffer
v16@?0@"MTLRenderPipelineDescriptor"8
Compute SCNGeometryScreenSpaceAdaptiveTessellator tessellation factors
compute_tessellation_factors_screeenspace_adaptive_uint16
compute_tessellation_factors_screeenspace_adaptive_uint32
Compute kC3DGeometryTessellatorTypeConstrainedEdgeLength tessellation factors
compute_tessellation_factors_constrained_edge_uint16
compute_tessellation_factors_constrained_edge_uint32
C3DHitTestResult
result
pointOfView
auth
groupIndex == meshElement->_primitiveGroupCount
ctx->_currentIndicesContent.indicesOffset == 0 && ctx->_currentIndicesContent.indicesStride == 1
__ProcessTriangleRange_Mask_Ind16VrtFloat3CullBack
__ProcessTriangleRange_Ind16VrtFloat3CullBack
boneIndicesSrc
v48@?0I8^I12I20I24I28I32I36^B40
vectorCount == 3
q16@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}8
segment
v24@?0^^{__C3DNode}8q16
<C3DHitTestResult %@ %f,%f,%f>
library
output
sphere
transformedSphere
modelMatrix
normalMatrix
couple1
couple2
%@-splitContainer
splitContainer
vramResource
VRAMResource
sourceChannels
D!=-1 && E!=-1 && F !=-1
B8@?0
B16@?0@?<v@?>8
enginePipeline
positionSource
normalSource
uvSource
v24@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}8q16
v32@?0^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}8c16q20C28
default camera
shortestPosition <= farthestPosition
SceneKit
element
material == elt->material
componentsCount!=0
%@-split%d
oldIndexToNewIndex[sourceIndex]
w == count * indexCountPerPrimitive
w == dataLength
faceVertexCount >= 3
_audioSource
_wait
q16@?0^{__C3DNode=}8
AuthoringPass
DEPTH
scn_clear_z_reversed
scn_clear_z
scn_clear_z_dummy_frag
scn_draw_fullscreen_fragment
debug_probe_vert
debug_probe_frag_cube_array
debug_probe_frag_2d_array
Authoring
allocator
-[SCNMTLBezierCurveDeformer initWithMeshlessGeometry:outputs:deformDataKind:finalDataKind:resourceManager:computeContext:]
SCNMTLBezierCurveDeformer.mm
offset <= UINT16_MAX
deformer_bezier_build_quad_geometry
deformer_bezier_build_info_linear
deformer_bezier_build_info_quadratic
deformer_bezier_build_info_cubic
scn_bezier_curve_data
scn_bezier_curve_controlPoints
C3DList
list
<C3DList %p: head %p, tail %p, %ld objects>
_actions
_mycaction->_animIndex
v16@?0^{__C3DParticleSystemInstance={__CFRuntimeBase=QAQ}^{__C3DParticleEmitter}IIi^{__C3DNode}^{__C3DParticleSystem}^{__C3DParticleManager}^{__C3DScene}d{?=[32^v][21^v][21^v]{__C3DParticleArrayLayout=[32I][32^?]I[21C][21C]}}IIIIIBdf{?=}{?={?=SS}I}^{__CFArray}^{__CFArray}}8
C3DLightGetProbeType(lights[i]) == kC3DLightProbeTypeRadiance
v36@?0I8^^{__C3DNode}12^^{__C3DLight}20^{?={?=[3]}}28
C3DLightGetType(light) == kC3DLightTypeProbe
outData->parameters.probe.index >= 0
shadowMapName
ctx.packedIndices.data[fl - 1] == li
pl != 0
ctx.packedIndices.data[pl - 1] == li
ctx.nextIndex[i] <= newIndicesCount
ctx.nextIndex[i] <= indicesCount
SCNMTLClusterSystem.mm
clusterCellSize == sizeof(simd_ushort2)
__compactLightIndices
count > 0
Omni:%d Spot:%d Indices:%luu
debug_omni_vert
debug_light_frag
debug_spot_vert
debug_cluster_frag
scn_draw_fullscreen_quad_VR_pos_vertex
debug_light_indices_8_buffer_frag
debug_cluster_slices_frag
i < lightRange.y
Texture
Buffer
Invalid
Invalid - wrong value
texture: {
width
height
depth
arrayLength
textureType
storageMode
usage
cpuCacheMode
pixelFormat
mipmapLevelCount
sampleCount
C3D::PassBufferParameter [
] : 
index < _inputCount
index < _outputCount
this != dep
_renderGraph
parent
index < _descriptor.inputCount()
index < _descriptor.outputCount()
outputResource
default
%s%p
passNameCache
com.apple.scenekit
C3DTransformTree
transformTree
hnd != kC3DTransformHandleInvalid
handle.level < transformTree->_levelCount
<C3DTransformTree %p>
handle.index != kC3DTransformIndexInvalid
countToMove >= 0
(handle + offset + countToMove) <= _capacity
startParentHandle < _count
newHandle.level == (parentHandle.level + 1)
firstChild.index != kC3DTransformIndexInvalid
lastChild.index != kC3DTransformIndexInvalid
lastChild.level == firstChild.level
lastChild.index >= firstChild.index
firstChildToRemainAfterDeletion != INT32_MAX
_handles[ node->_transformHandle ].level == l
_handles[ node->_transformHandle ].index >= minIndexToDestroyPerLevel[ l ]
firstHandle.level == lastHandle.level
firstHandle.index <= lastHandle.index
handle.level < _levelCount
v32@?0^{__C3DNode=}8q16^B24
callbacks
point
normal
v16@?0^{__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}8
CFTypeIsC3DEntity(object)
SCNSourceURLForCurrentlyUnarchivedScene
center
C3DStack
stack
stack->_currentLevel != 0
stack->_elementSize == sizeof(void*)
<C3DStack>
C3D-Standard.metal
#import "scn_metal"
#import "scn_util.h"
#import "scn_standard_lighting.h"
#import "scn_standard_constants.h"
#import "C3D-PBR.metal"
__ExtraVaryingsDecl__
__ShaderModifiersDecl__
__VertexExtraArguments__
__DoGeometryModifier__
__VertexExtraArgumentsPostTessellation__
__DoGeometryModifierPostTessellation__
__FragmentExtraArguments__
__DoSurfaceModifier__
__DoFragmentModifier__
C3D-Lighting.metal
_originalLightingSourceCode
__SurfaceExtraDecl__
__LightModifierExtraDecl__
__DoLightModifier__
range.rangeValue.length > 0
C3D-CommonProfile.metal
#import "scn_tessellation.h"
__TexcoordDecl__
#import "C3D-Lighting.metal"
__OpenSubdivDeclPerGeometry__
__OpenSubdivDeclPerPatchType__
__OpenSubdivDeclShared__
__VertexDoVertexOnlyTexcoord__
__VertexDoLighting__
__VertexDoTexcoord__
__FragmentDoTexcoord__
__LightModifierCopyDecl__
__FragmentDoLighting__
} commonprofile_io;
typedef struct {
_originalSourceCode
%@ %@;
texture
sampler
, device %@ %@
, constant %@& %@
, %@ %@
, %@<float> %@
_lightingContribution.%@=%@;
%@<float> %@;
modifier
v32@?0@"NSString"8@"NSString"16^B24
%@%@%@
C3D-OpenSubdiv-Utils.h
C3D-OpenSubdiv-Utils.metal
scn_metal
scn_util.h
scn_standard_lighting.h
scn_standard_constants.h
C3D-PBR.metal
USE_VERTEX_EXTRA_ARGUMENTS
USE_FRAGMENT_EXTRA_ARGUMENTS
USE_SHADER_MODIFIERS
METAL
////////////////////////////////////////////////
// CommonProfile Shader v%d
USE_POSITION
USE_MULTIPLE_RENDERING
USE_VERTEX_AMPLIFICATION
USE_INSTANCING
USE_LAYERED_RENDERING
USE_MULTIPLE_VIEWPORTS_RENDERING
USE_MODIFIER_FRAMEBUFFER_COLOR0
C3D_SUPPORTS_PROGRAMMABLE_BLENDING
USE_CLIP_DISTANCE3
USE_CLIP_DISTANCE_COUNT
USE_CLIP_DISTANCE2
USE_CLIP_DISTANCE1
USE_CLIP_DISTANCE0
USE_SPECULAR
USE_VIEW
USE_SHININESS
USE_PBR
USE_SHADOWONLY
C3DLightIndexType
C3D_SUPPORT_CUBE_ARRAY
C3D_USE_REFLECTION_PROBES
SCNLightingModelCustom
LIGHTING_MODEL
USE_CLUSTERED_LIGHTING
C3D_USE_TEXTURE_FOR_LIGHT_INDICES
USE_FOG
USE_SSAO
USE_FRESNEL
USE_NORMAL
AVOID_OVERLIGHTING
USE_AMBIENT_LIGHTING
USE_PROBES_LIGHTING
USE_LIGHTING
USE_PER_PIXEL_LIGHTING
USE_MODULATE
USE_PER_VERTEX_LIGHTING
HAS_NORMAL
HAS_VERTEX_COLOR
USE_VERTEX_COLOR
USE_POINT_RENDERING
DISABLE_LINEAR_RENDERING
DISABLE_SPECULAR
USE_MOTIONBLUR
USE_SKINNING
USE_COLOR1_OUTPUT
USE_NORMALS_OUTPUT
USE_REFLECTANCE_ROUGHNESS_OUTPUT
USE_RADIANCE_OUTPUT
USE_OUTLINE
USE_MODELTRANSFORM
USE_AMBIENT_AS_AMBIENTOCCLUSION
USE_TANGENT
USE_BITANGENT
USE_TRANSPARENT
USE_TRANSPARENCY_RGBZERO
USE_PBR_TRANSPARENCY
USE_PBR_LAMBERTIAN_REFLECTION
LOCK_AMBIENT_WITH_DIFFUSE
USE_DOUBLE_SIDED
USE_TRANSPARENCY
USE_NODE_OPACITY
DIFFUSE_PREMULTIPLIED
    float2 %@Texcoord;
    _surface.%@Texcoord = in.texcoord%d;
USE_DISCARD
USE_MODELVIEWTRANSFORM
USE_MODELVIEWPROJECTIONTRANSFORM
float2 bezierCurveUV [[ sample_perspective ]];
, device void const *scn_bezier_curve_data
, device packed_float3 const *scn_bezier_curve_controlPoints
NEED_IN_TEXCOORD0
IS_BEZIER_CURVE
USE_SURFACE_EXTRA_DECL
USE_EXTRA_VARYINGS
USE_OPENSUBDIV
HAS_OR_GENERATES_NORMAL
USE_TESSELLATION
scn_tessellation.h
TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE
TESSELLATION_SMOOTHING_MODE_PHONG
#import
%@%@
%@%@
#if 1 // SHADER_COLLECTION_PREFERS_MONOLITHIC_FILES
#else // SHADER_COLLECTION_PREFERS_MONOLITHIC_FILES
#endif // SHADER_COLLECTION_PREFERS_MONOLITHIC_FILES
#generate "__OpenSubdivDeclShared__.metal"
#generate "__OpenSubdivDeclShared__patchType%d.metal"
USE_REVERSE_Z
DEBUG_PIXEL
USE_ARGUMENT_BUFFERS
v32@?0@"NSValue"8Q16^B24
    float clipDistance [[clip_distance]] [%d];
} commonprofile_io_vert;
vertex commonprofile_io
commonprofile_io out;
commonprofile_io_vert out;
vertex commonprofile_io_vert
commonprofile_io in;
commonprofile_io io
commonprofile_io_vert in;
commonprofile_io_vert io
_import/%@
#import "%@"
#generate
-[SCNCommonProfileProgramGeneratorMetal collectShaderForProgram:hashCode:newVertexFunctionName:newFragmentFunctionName:sourceCodeBlock:additionalFileBlock:]
SCNCommonProfileProgramGeneratorMetal.m
 -D%@
 -D%@=%@
 -U%@
_unifdef/%@.h
USE_GEOMETRY_MODIFIER
USE_SURFACE_MODIFIER
USE_FRAGMENT_MODIFIER
USE_LIGHT_MODIFIER
v16@?0^{__CFString=}8
v24@?0r^v8r^v16
C3DShaderModifierGetEntryPoint(shaderModifier) == entryPoint
v32@?0@"NSString"8@16^B24
scn_node.
USE_
, depthcube<float> u_shadowTexture%d
, depth2d_array<float> u_shadowTexture%d
, depth2d<float> u_shadowTexture%d
, texture2d<half> u_goboTexture%d
, sampler u_goboTexture%dSampler
, texture2d<half> u_iesTexture%d
, device packed_float2* u_areaPolygonPositions%d
USE_MULTIPLE_RENDERING * %d + amplificationID
USE_MULTIPLE_RENDERING * %d + in.sliceIndex
USE_MULTIPLE_RENDERING * %d + out.sliceIndex
_lightingContribution.add_directional(scn_lights[%@], u_goboTexture%d, u_goboTexture%dSampler, %s);
_lightingContribution.add_directional(scn_lights[%@], u_shadowTexture%d, %d, %s, u_shadowKernel, %d, %s);
_lightingContribution.add_directional(scn_lights[%@], u_shadowTexture%d, %d);
_lightingContribution.add_directional(scn_lights[%@], u_shadowTexture%d, u_shadowKernel, %d);
_lightingContribution.add_directional(scn_lights[%@], u_shadowTexture%d);
_lightingContribution.add_directional(scn_lights[%@]);
_lightingContribution.add_omni(scn_lights[%@], u_shadowTexture%d, u_shadowKernel, %d);
_lightingContribution.add_omni(scn_lights[%@]);
_lightingContribution.add_spot(scn_lights[%@], u_shadowTexture%d, u_shadowKernel, %d, u_goboTexture%d, u_goboTexture%dSampler);
_lightingContribution.add_spot(scn_lights[%@], u_goboTexture%d, u_goboTexture%dSampler, %s);
_lightingContribution.add_spot(scn_lights[%@], u_shadowTexture%d, u_shadowKernel, %d);
_lightingContribution.add_spot(scn_lights[%@]);
_lightingContribution.add_ies(scn_lights[%@], u_iesTexture%d, u_shadowTexture%d, u_shadowKernel, %d);
_lightingContribution.add_ies(scn_lights[%@], u_iesTexture%d);
_lightingContribution.add_area_rectangle(scn_lights[%@], u_areaLightBakedDataTexture);
_lightingContribution.add_area_polygon(scn_lights[%@], u_areaLightBakedDataTexture, u_areaPolygonPositions%d);
_lightingContribution.add_area_line(scn_lights[%@], u_areaLightBakedDataTexture);
_lightingContribution.add_area_ellipse(scn_lights[%@], u_areaLightBakedDataTexture);
_lightingContribution.add_area_ellipsoid(scn_lights[%@], u_areaLightBakedDataTexture);
float2 _%@Texcoord = (scn_commonprofile.textureTransforms[%d] * float4(_geometry.texcoords[%d], 0., 1.)).xy;
float2 _%@Texcoord = _geometry.texcoords[%d].xy;
out.texcoord%d = (scn_commonprofile.textureTransforms[%d] * float4(_geometry.texcoords[%d], 0., 1.)).xy;
out.texcoord%d = _geometry.texcoords[%d].xy;
USE_TEXCOORD
TEXTURE_TRANSFORM_COUNT
kSCNTexcoordCount
float2 texcoord0;
float2 texcoord1;
float2 texcoord2;
float2 texcoord3;
float2 texcoord4;
float2 texcoord5;
float2 texcoord6;
float2 texcoord7;
NEED_IN_TEXCOORD1
NEED_IN_TEXCOORD2
NEED_IN_TEXCOORD3
NEED_IN_TEXCOORD4
NEED_IN_TEXCOORD5
NEED_IN_TEXCOORD6
NEED_IN_TEXCOORD7
location
initFromPath
relativePath
runtimePath
vertexCount
componentsPerValue
componentsType
valuesCount
data
kGeometrySourceSemanticVertex
kGeometrySourceSemanticNormal
kGeometrySourceSemanticColor
kGeometrySourceSemanticTexcoord
stride
offset
padding
sourceID
sourceTypeID
vertex
position
texcoord
textangent
joints
weights
commonProfile
geometryID
materialsID
facesCount
kAnimationsKey
kBindingsKey
kActionsKey
kLightKey
kDeformerStackKey
kCameraKey
kSplineKey
kConstraints
kParticleSystem
kLightmapInfoKey
kRenderingPriorityKey
kShaderModifiers
kShadableMinimumMTLLanguageVersionKey
kPivotKey
libraryStorage
kMeshKey
rendererDelegate
kFilterKey
geometryElement
geometryElements
geometrySource
genericSource
effect
image
keyframedAnimations
animation
camera
skin
morph
linear
easeIn
easeOut
easeInEaseOut
function
avoidsOverlighting
double sided
cullMode
cullBack
cullFront
constant
lambert
phong
blinn
physicallyBased
shadowOnly
emission
ambient
diffuse
specular
reflective
transparent
filter
ambientOcclusion
selfIllumination
metalness
roughness
displacement
clearCoat
clearCoatRoughness
clearCoatNormal
emissionColor
ambientColor
diffuseColor
specularColor
reflectiveColor
transparentColor
normalColor
filterColor
emissionImageID
ambientImageID
diffuseImageID
specularImageID
reflectiveImageID
transparentImageID
filterImageID
normalImageID
shininessImageID
emissionTextureSampler
ambientTextureSampler
diffuseTextureSampler
specularTextureSampler
reflectiveTextureSampler
transparentTextureSampler
filterTextureSampler
normalTextureSampler
shininessTextureSampler
emissionUVSet
ambientUVSet
diffuseUVSet
specularUVSet
reflectiveUVSet
transparentUVSet
normalUVSet
filterUVSet
shininessUVSet
ambientOcclusionUVSet
selfIlluminationUVSet
shininess
reflectivity
transparency
indexOfRefraction
fresnelExponent
transparencyMode
A_ONE
RGB_ZERO
minFilter
magFilter
mipFilter
wrapS
wrapT
wrapP
anisotropy
SCNKitErrorDomain
frustumCulling
defaultLight
defaultCamera
probeRendering
debugRendering
rootNode
mirrorNode
kHitTestFirstFoundOnly
kHitTestSearchMode
kHitTestSortResults
kHitTestClipToZRange
kHitTestSkipTransparentNode
kHitTestSkipHiddenNode
kHitTestCategoryBitMask
kHitTestBackFaceCulling
kHitTestBoundingBoxOnly
kHitTestIgnoreChildNodes
kHitTestRootNode
kHitTestAllLayers
kHitTestLayerMask
kHitTestShowDebugInfo
kHitTestResultIgnoreLightArea
kC3DNotificationMeshSourceWillDie
kC3DNotificationMeshElementWillDie
kC3DNotificationImageWillDie
kC3DNotificationImageProxyWillDie
kC3DNotificationProgramWillDie
kC3DNotificationGeometryWillDie
kC3DNotificationMorphWillDie
kC3DNotificationSkinWillDie
kC3DNotificationDeformerStackWillDie
kC3DNotificationDeformerStackDidChange
kC3DNotificationMaterialWillDie
kC3DNotificationMeshWillDie
kC3DNotificationNodeWillDie
kC3DNotificationPassWillDie
kC3DNotificationRasterizerStatesDidDie
kC3DNotificationEngineContextInvalidatePasses
kC3DNotificationEngineContextPassesDidUpdate
kC3DNotificationProfileWillDie
kC3DNotificationEntityAttributeDidChange
kC3DNotificationRendererElementWillDie
kC3DNotificationProgramHashCodeWillDie
kC3DNotificationPrecomputedLightingEnvironmentWillDie
kC3DSceneDidUpdateNotification
opacity
hidden
attributes
matrix
translation
rotation
orientation
scale
eulerAngles
quaternion
pivot
filters
focalDistance
dofIntensity
focalSize
aperture
apertureBladeCount
xFov
yFov
orthographicScale
zFar
projectionTransform
zNear
firstMaterial
selfIlluminationOcclusion
multiply
litPerPixel
lockAmbientWithDiffuse
contents
contentsTransform
borderColor
intensity
shadowColor
shadowRadius
gobo
probeEnvironment
attenuationStart
attenuationEnd
attenuationFalloffExponent
spotInnerAngle
spotOuterAngle
spotFalloffExponent
morpher
shaderModifiers
background
environment
customProperty
animations
a_position
a_normal
a_tangent
a_color
a_skinningJoints
a_skinningWeights
a_texCoord0
a_texCoord1
a_texCoord2
a_texCoord3
a_texCoord4
a_texCoord5
a_texCoord6
a_texCoord7
vertexCrease
edgeCrease
meshSource
componentCount <= 4
bse.ptr
tgt.ptr
dlt.ptr
baseSource
intervalList
ind.type == kC3DMeshElementTypeLinesArray
%4d : %3d %3d %3d %3d
%4d : %+.2f %+.2f
%4d : %+.2f %+.2f %+.2f
%4d : %+.2f %+.2f %+.2f %+.2f
type debugging not implemented
C3DMeshSource
<C3DMeshSource %p(%@) data:(%p) mut:%d count:%ld type:%@ divisor:%d mtl:%d offset:%d stride:%d
_C3DMeshSourceInitWithPropertyList
mkSemantic
accessor
C3DFramebufferRegistry
registry
v16@?0^{__C3DRenderTarget={__CFRuntimeBase=QAQ}{?=CCCb1b1b1b1b1b1[4C]}^{__C3DTexture}Iq^vQIII}8
registry->_currentFramebuffer
renderTarget
targetName
retainCount > 0
<C3DFramebufferRegistry>
(null)
nameIndex!=0
manager
animationNode
target
CFGetTypeID(animationNode) != C3DAnimationClusterNodeGetTypeID()
manager->_mute == false
animationManager
manager->_constantStackCount >= 0
stackCount >= animationManager->_constantStackCount
root
rootObject
storage
v32@?0@8Q16^B24
SCNBindingValueTransformerKey
B32@?0@8Q16^B24
C3DAnimationManager
<C3DAnimationManager %p>
CFDictionaryContainsKey(manager->_targetAddressToStackIndex, (void*)key) == false
animationNode->_target->_semantic != kC3DTypeSemanticNone
modelValueStorage
CFDictionaryContainsKey(manager->_targetAddressToStackIndex, (void*)key) == true
removedIndex
lastIndex
stackItem->_modelValueItem
manager->_applying == false
manager->_applying==false
middle >= 0
controller
controller->_values
controller->_evaluate
controller->_keyCount > 0
C3DKeyframeController
<C3DKeyframeController %p>
keyframeVersion
keyframeType
keyCount == (int)(length/keyStride)
keyframes
keytimes
keytimes-data
values
values-data
timingFunctions
timingFunctions-data
interpolationModes
interpolationModes-data
tensionValues
tensionValues-data
continuityValues
continuityValues-data
biasValues
biasValues-data
inTangents
inTangents-data
outTangents
outTangents-data
count
interpolationMode
calculationMode
CFGetTypeID(value) == CFNumberGetTypeID()
CFGetTypeID(value) == CFBooleanGetTypeID()
0.12
C3D-wireframe
ManipulatorWireframe_vert
ManipulatorWireframe_frag
glInfo->mesh != NULL
authoringEnvironment->_timedRecordingExpirationTime == 0
start != end
C3DMeshElementGetIndicesChannelCount(creaseElement) == 1
C3DAuthoringEnvironmentDrawStats
SCNAuthoringEnvironment.m
rendererContext
SceneKit - Draw Statistics
v32@?0^q8^{CGSize=dd}16^^{?}24
v24@?0{CGSize=dd}8
Animations
Physics
Constraints
Particles
Delegate
Rendering
GL flush
--- ms
%2.1f s
%2.1f ms
BGRA8Unorm_sRGB
BGRA8Unorm
RGBA16Float
RGBA32Float
unknown
$4$ %@  $5$ %@
%dfps
GL %dfps
AuthEnvDraw
u_modelViewProjectionTransform
u_sampler
glInfo->baseVertex == 0
glInfo->baseIndex == 0
C3DManipulatorColorAndTexture
C3DManipulatorColorOnly
C3DManipulatorLightProbe
ManipulatorColorAndTexture_vert
ManipulatorColorAndTexture_frag
ManipulatorColorOnly_vert
ManipulatorColorOnly_frag
ManipulatorLightProbe_vert
ManipulatorLightProbe_frag
glInfo->weakProgram != nil
glInfo->textureImage != nil
glInfo->textureImage == nil
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
Menlo
%2.1fms
Menlo-Bold
%.3gK
%.3gM
%.3gG
_C3DTimingFunctionInitWithPropertyList
timingFunc
C3DTimingFunction
<C3DTimingFunction>
animationStack->_valid == false
animationStack
animationStack->_valid == true
CFGetTypeID(animationNode) == C3DAnimationClusterNodeGetTypeID()
animationCluster->_keyframes->_valueSize[index] == C3DSizeOfBaseType(target->_baseType)
com.apple.scenekit.resourceCPUQueue
FrameConstant
Volatile
background_2D_vertid
background_2D_frag
background_cube_vertid
background_cube_frag
background_video_vertid
background_video_frag
background_2D_multiple_viewports_vertid
background_2D_multiple_viewports_frag
background_cube_multiple_viewports_vertid
background_cube_multiple_viewports_frag
background_2D_layered_vertid
background_2D_layered_frag
background_cube_layered_vertid
background_cube_layered_frag
Clear binding points
v16@?0@"<MTLDrawable>"8
SCNDefaultRadiance.ktx
SCNDefaultIrradiance.ktx
ResourceComputeEncoder
v16@?0@"<MTLBuffer>"8
LightingSet: uploaded count: %d
  LightingSet: uploaded size %d bytes
setMask
element.indexType == MTLIndexTypeUInt32 || element.indexType == MTLIndexTypeUInt16
element.primitiveType == MTLPrimitiveTypeTriangle
SceneKit - Draw scene background
currentPassInstance
SceneKit - Draw video background
!C3DMeshIsVolatile(mesh) || (renderMesh.volatileBuffer != nil)
!programHashCode || C3DProgramHashCodeUseDynamicBatching(programHashCode)
_processingContext.passInstance
engineIterationContext->engineContext == _engineContext
v24@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}8^{__C3DLightRuntimeData=If[4{?=[4]}]^v^{__C3DTextureSampler}^v^{__C3DTextureSampler}}16
dynamicBatchCount < 2
meshElement == NULL
C3DGeometryGetMeshElementCountForDeformerBasedDynamicMesh(geometry) == 1
_cache.metalMeshElement
No registered texture for binding %@ and symbol "%@" in pass or render graph.
Pass: %s (%p)
Render graph: %p
No texture or image provided for binding %@ by sampler %@.
Texture: %@
Image: %@
No sampler found for binding %@ and input %@
No pass storage for binding %@
v24@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}8*16
resourceBinding.bindBlock
_engineContext
SceneKit - Draw wireframe
modelTransform
v36@?0^v8I16@"SCNMTLRenderContext"20I28I32
inverseModelTransform
modelViewTransform
lightIndices
size == C3D_MAX_LIGHTS
inverseModelViewTransform
normalTransform
modelViewProjectionTransform
lastFrameModelTransform
motionBlurIntensity
inverseModelViewProjectionTransform
boundingBox
worldBoundingBox
nodeOpacity
shCoefficients
size == sizeof(coefs)
v24@?0@"SCNMTLResourceBinding"8@"SCNMTLRenderContext"16
Unable to find texture for binding %@ and shadable %@
scn_lights
scn_lights_count
scn_shCoefficients
3 == C3DLightProbesSystemGetSphericalHarmonicsOrder(probesSystem)
scn_commonprofile
scn_pointSize
u_clusterTexture
u_lightIndicesBuffer
u_areaLightBakedDataTexture
u_shadowKernel
v28@?0c8@"SCNMTLResourceBinding"12@"SCNMTLRenderContext"20
Unable to find texture for binding %@ and effect slot %@
u_%@Texture
u_reflectiveCubeTexture
u_shadowTexture%d
Unable to find IES or gobo texture for binding %@
u_goboTexture%d
u_iesTexture%d
u_iesCubeTexture%d
color%d
position%d
direction%d
right%d
up%d
iesMatrix%d
attenuation%d
spotAttenuation%d
shadowMatrix%d
size <= (sizeof(simd_float4x4) * C3D_MAX_CASCADE_COUNT)
shadowRadius%d
shadowColor%d
goboMatrix%d
projectorColor%d
u_areaPolygonPositions%d
buffer
u_specularDFGDiffuseHammonTexture
u_radianceTexture
u_irradianceTexture
u_reflectionProbeTexture
u_ssaoTexture
SSAO-Final
Unable to find "SSAO-Final" texture in render graph for binding %@
deformers
v32@?0@"SCNBufferBinding"8@"MTLArgument"16@"SCNMTLShaderBindingsGenerator"24
metalMesh.volatileStride != 0
sub.buffer != nil
mtlBuffer != nil
metalMeshElement.indexBuffer == nil
quad_vertex
quad_display_cube_equirectangular
quad_display_texture2D
quad_display_depth2D
quad_display_depth_cube
scn_draw_fullscreen_fragment_sk
scn_draw_fullscreen_gamma_fragment
SpriteKit - NonLinear Encoding
rendererElement
C3DRendererElementIsHidden(rendererElement) != true
theNode==NULL || C3DNodeGetOpacity(theNode) > 0 || (rendererElement->_renderableAttributeKind == kC3DRenderableAttributeKindParticleSystem)
commandBuffer
commandEncoder
HDRAverageLuminancePass
FrameLuminance
fixed_lum
sliding_lum
adaptative_lum
SceneKit-spotShadowDepth-%p
SceneKit-spotShadowDepth
^{__CFString=}16@?0^{__CFString=}8
C3DFXDeferredShadowPass.json
C3DFXForwardShadowPass.json
SceneKit_renderSceneFromLight
SceneKit_applyDeferredShadows
--ShadowMaterial--
lightDepthSampler
cascadeCount
cascadeBlending
debugCascades
isSpotLight
reverseZ
deferredShadow_vert
deferredShadowCascades_frag
deferredShadow_frag
C3D-spotShadow
#define MAX_SAMPLE %d
#define unshareIndex %d
#define SPOT_SHADOW 1
#define USE_PCF 1
C3D-u_lightPos-symbol
C3D-u_lightDir-symbol
C3D-u_lightSpotAtt-symbol
C3D-light_MVP-symbol
C3D-cascadeScale-symbol
C3D-cascadeBias-symbol
C3D-shadowCascadeDebugFactor-symbol
C3D-camera_MVP_i-symbol
C3D-shadowRadius-symbol
C3D-shadowColor-symbol
C3D-shadowKernel-symbol
anim
outputAddress
C3DKeyframedAnimation
<C3DKeyframedAnimation %p>
keyframeController
keyframedAnimation
_allocate
C3DHash.hpp
(new_size & (new_size - 1)) == 0
child
node->_cumulativeCache
animationGroup
animationCluster
C3DAnimationNode
node->_completionItem == NULL
<C3DAnimationNode %p>
C3DAnimationClusterNode
<C3DAnimationClusterNode %p>
SSRRaytracePass
ColorDownSampled
Normals
DepthDownSampled
lobeFootprint
SSRReverseZ
SSRDownSample
SSREnableFog
scn_ssr_raytrace_vert
scn_ssr_raytrace_frag
DownsamplePass
scn_supersampling_vertex
scn_supersampling_fragment
BloomUpSamplePass
scn_bloom_upsample
script
JSContext
elapsedTime
Position
Angle
RotationAxis
Velocity
AngularVelocity
Life
Color
Opacity
Size
Frame
FrameRate
Bounce
Friction
Charge
ContactPoint
ContactNormal
-[SCNParticleSystem setName:]
CFTypeIsC3DEntity(cfObject)
animations.%@.speed
scnp
failed to unarchive particle data at %@ (%@)
-[SCNParticleSystem setParticleGeometries:]
-[SCNParticleSystem setColliderNodes:]
-[SCNParticleSystem setPropertyControllers:]
-[SCNParticleSystem setParticleImage:]
-[SCNParticleSystem _setParticleImagePath:withResolvedPath:]
-[SCNParticleSystem setOrientationDirection:]
orientationDirection
-[SCNParticleSystem setLightEmissionRadiusFactor:]
fixedTimeStep
-[SCNParticleSystem setAffectedByGravity:]
affectedByGravity
-[SCNParticleSystem setAffectedByPhysicsFields:]
-[SCNParticleSystem setBirthDirection:]
-[SCNParticleSystem setBirthLocation:]
-[SCNParticleSystem setBirthRate:]
birthRate
-[SCNParticleSystem setBirthRateVariation:]
birthRateVariation
-[SCNParticleSystem setBlackPassEnabled:]
-[SCNParticleSystem setBlendMode:]
-[SCNParticleSystem setDampingFactor:]
dampingFactor
-[SCNParticleSystem setEmissionDuration:]
emissionDuration
-[SCNParticleSystem setEmissionDurationVariation:]
emissionDurationVariation
-[SCNParticleSystem setEmitterShape:]
-[SCNParticleSystem setFixedTimeStep:]
-[SCNParticleSystem setFresnelExponent:]
-[SCNParticleSystem setIdleDuration:]
idleDuration
-[SCNParticleSystem setIdleDurationVariation:]
idleDurationVariation
-[SCNParticleSystem setImageSequenceAnimationMode:]
-[SCNParticleSystem setImageSequenceColumnCount:]
imageSequenceColumnCount
-[SCNParticleSystem setImageSequenceFrameRate:]
imageSequenceFrameRate
-[SCNParticleSystem setImageSequenceFrameRateVariation:]
imageSequenceFrameRateVariation
-[SCNParticleSystem setImageSequenceInitialFrame:]
imageSequenceInitialFrame
-[SCNParticleSystem setImageSequenceInitialFrameVariation:]
imageSequenceInitialFrameVariation
-[SCNParticleSystem setImageSequenceRowCount:]
imageSequenceRowCount
-[SCNParticleSystem setIsLocal:]
isLocal
-[SCNParticleSystem setLightingEnabled:]
-[SCNParticleSystem setLoops:]
loops
-[SCNParticleSystem setOrientationMode:]
-[SCNParticleSystem setParticleAngle:]
particleAngle
-[SCNParticleSystem setParticleAngleVariation:]
particleAngleVariation
-[SCNParticleSystem setParticleAngularVelocity:]
particleAngularVelocity
-[SCNParticleSystem setParticleAngularVelocityVariation:]
particleAngularVelocityVariation
-[SCNParticleSystem setParticleBounce:]
particleBounce
-[SCNParticleSystem setParticleBounceVariation:]
particleBounceVariation
-[SCNParticleSystem setParticleCharge:]
particleCharge
-[SCNParticleSystem setParticleChargeVariation:]
particleChargeVariation
-[SCNParticleSystem setParticleColor:]
particleColor
-[SCNParticleSystem setParticleDiesOnCollision:]
-[SCNParticleSystem setParticleFriction:]
particleFriction
-[SCNParticleSystem setParticleFrictionVariation:]
particleFrictionVariation
-[SCNParticleSystem setParticleLifeSpan:]
particleLifeSpan
-[SCNParticleSystem setParticleLifeSpanVariation:]
particleLifeSpanVariation
-[SCNParticleSystem setParticleMass:]
particleMass
-[SCNParticleSystem setParticleMassVariation:]
particleMassVariation
-[SCNParticleSystem setParticleSize:]
particleSize
-[SCNParticleSystem setParticleSizeVariation:]
particleSizeVariation
-[SCNParticleSystem setParticleVelocity:]
particleVelocity
-[SCNParticleSystem setParticleVelocityVariation:]
particleVelocityVariation
-[SCNParticleSystem setPhysicsCollisionsEnabled:]
-[SCNParticleSystem setRenderingMode:]
-[SCNParticleSystem setSeed:]
-[SCNParticleSystem setSoftParticlesEnabled:]
-[SCNParticleSystem setSortingMode:]
-[SCNParticleSystem setSpeedFactor:]
speedFactor
-[SCNParticleSystem setSpreadingAngle:]
spreadingAngle
-[SCNParticleSystem setStretchFactor:]
stretchFactor
-[SCNParticleSystem setSystemSpawnedOnCollision:]
-[SCNParticleSystem setSystemSpawnedOnDying:]
-[SCNParticleSystem setSystemSpawnedOnLiving:]
-[SCNParticleSystem setWarmupDuration:]
warmupDuration
-[SCNParticleSystem setWritesToDepthBuffer:]
-[SCNParticleSystem setParticleIntensity:]
particleIntensity
-[SCNParticleSystem setParticleIntensityVariation:]
particleIntensityVariation
-[SCNParticleSystem setParticleColorVariation:]
particleColorVariation
-[SCNParticleSystem setEmittingDirection:]
emittingDirection
-[SCNParticleSystem setAcceleration:]
acceleration
particleImage
referenceName
emitterShape
birthLocation
birthDirection
affectedByPhysicsFields
physicsCollisionsEnabled
lightingEnabled
softParticlesEnabled
particleDiesOnCollision
blackPassEnabled
writesToDepthBuffer
systemSpawnedOnCollision
systemSpawnedOnDying
systemSpawnedOnLiving
seed
blendMode
renderingMode
orientationMode
imageSequenceAnimationMode
particleGeometries
colliderNodes
propertyControllers
sortingMode
image->_sourceType == kC3DImageSourceTypeCatalogTexture
size
MDLMemoryMappedData
missingMaterialImage
image->_bitmapContext==NULL
isAttachment
image->_textureRawData == NULL
C3DImage
<C3DImage %p src:%@ [%fx%f]>
<C3DImage %p src:%p [%fx%f]>
_C3DImageInitWithPropertyList
imageData
imageRelativePath
distantImageURL
file
cgImage
clientImage
bitmap
hasAlpha
SCNRendererOptions
SCNKitError : can't load nib named : SCNRendererOptions
~/%@-snapshot-%d.scn
archiving to %@
B24@?0@"SCNNode"8^B16
index < (NSInteger)[cameras count]
untitled
None
%.1f fps
usda
usdc
tiff
v24@?0@"SCNNode"8^B16
Scene
[Root node]
<No name>
minificationFilter
magnificationFilter
%f %f %f %f
maxAnisotropy
textureSampler
C3DTextureSampler
<C3DTextureSampler>
_C3DTextureSamplerInitWithPropertyList
nearest
clamp
repeat
clampToBorder
collisionBitMask
results
backfaceCulling
closest
v24@?0@"SCNPhysicsBody"8^B16
ccdPenetration
C3DNodeIsHidden(nodeRef) == false
behaviors
gravity
speed
timeStep
_implementDidUpdateContact
_implementDidEndContact
v16@?0r^v8
engineContext
Resource Manager Flush
Environment cube
C3D-EnvMap2D
textureSampler0
u_textureMatrix
C3D-EnvMapCube
u_mvp
u_zfar
C3DEngineContext
context
glContext
context->_pointOfView
Quad
index < C3DRenderingEyeMaxCount
eye < C3DRenderingEyeMaxCount
viewport.z > 0 && viewport.w > 0
engineContext->_viewport[0].z > 0 && engineContext->_viewport[0].w > 0
<C3DEngineContext>
C3DConvexPolyhedron
<C3DConvexPolyhedron %p>
dst.count == src.count
srcType < kC3DBaseTypeCount
i48@?0^{__CVDisplayLink=}8r^{?=IiqQdq{CVSMPTETime=ssIIIssss}QQ}16r^{?=IiqQdq{CVSMPTETime=ssIIIssss}QQ}24Q32^Q40
C3DBezierCurve
v16@?0r^{CGPathElement=i^{CGPoint}}8
v24@?0^S8^16
<C3DBezierCurve:%p (curve segments: %d linear, %d quadratic, %d cubic)>
C3DBezierCurveGeometry
Format: %@ ; Size: %gx%g[%d] ; Texture: <%p> ; [rc:%ld/ts:%ld]
Name: %@ ; %@
-[SCNRenderTarget textureForSliceIndex:]
SCNRenderTarget.m
_sliceTextures != nil
C3DSpanAllocator
span.count > 0
(freeSpan->start.index + freeSpan->count) <= page->capacity
page->freeCapacity
spanSize <= page->freeMaxSpan
span.start.index + span.count <= page->capacity
page->pageIndex == span.start.page
handle.page < allocator->_pageCount
(page->pageIndex == handle.page) && (handle.index < page->capacity)
<C3DSpanAllocator %p>
DrawQuadPass
pointOfCulling.scene
<%@: %p | scene=%@ sceneTime=%f frame=%@ pointOfView=%@>
cgl_ctx
sceneTime
playing
autoenablesDefaultLighting
jitteringEnabled
technique
renderer.%@
C3DRendererElementState
rendererElementState
C3DRendererElementStateBeginProcessing
C3DRendererElementState.c
C3DRendererElementStateEndProcessing
__UpdateMatrixUniforms
CFArrayGetCount(shaderModifiers)
C3DRendererElementStateDrawRendererElement
passInstance
C3DRendererElementStateProcessRendererElement
C3DEngineContextGetRendererContextGL(engineContext)
theNode==NULL || C3DNodeGetOpacity(theNode) > 0 || rendererElement->_renderableAttributeKind == kC3DRenderableAttributeKindParticleSystem
<C3DRendererElementState>
v24@?0^{__CFString=}8^v16
uv_set
programObject
C3DCreateProgram
C3DGLUtils.m
_create_compile_and_attach_shader
renderer
_create_and_compile_shader
%3ld | %@
#version 150
#define attribute in
#define varying out
#define texture2D texture
#version 150
#define varying in
#define gl_FragColor FragColor
#define texture2D texture
out vec4 FragColor;
#version 120
^(\w+):\s[0-9]+:([0-9]+):\s(.+)$
error
frame.scn_record
v16@?0^{__CFDictionary=}8
v16@?0q8
C3DRendererContext
C3DRendererContextSetupCommonPipeline
C3DRendererContextGL.c
C3DRendererContextClear
C3DRendererContextIsEnabled
C3DRendererContextSetEnable
C3DRendererContextResetToDefaultStates
Reset all states
C3DRendererContextSetMatrix4x4UniformAtLocation
C3DRendererContextSetColor4UniformAtLocation
C3DRendererContextSetVector4UniformAtLocation
C3DRendererContextSetVector3UniformAtLocation
C3DRendererContextSetVector2UniformAtLocation
C3DRendererContextSetIntUniformAtLocation
C3DRendererContextSetInt2UniformAtLocation
C3DRendererContextSetInt3UniformAtLocation
C3DRendererContextSetInt4UniformAtLocation
C3DRendererContextSetFloatUniformAtLocation
C3DRendererContextBindProgramObject
C3DRendererContextUnbindProgramObject
effectSlot
C3DRendererContextSetupResidentMeshSourceAtLocation
%02x
program
C3DRendererContextCreateProgramObjectForProgram
C3DRendererContextDeleteProgramObject
bufferObject
C3DRendererContextApplyTextureSampler
_C3DRendererContextComputeInternalSize
_C3DRendererContextComputeRenderBufferInternalSize
C3DRendererContextBindTexture
C3DRendererContextDeleteTexture
C3DRendererContextCreateTextureWithImage
idTexture != 0
C3DCreateTextureFromIOSurface
C3DRendererContextCreateRenderTargetWithDescription
description.sampleCount == C3DFramebufferGetSampleCount(fbo)
C3DRendererContextSetupFramebuffer
_C3DRendererContextBindFramebuffer
C3DRendererContextUnbindFramebuffer
currentFBO->_inUse==true
C3DRendererContextResolveFramebuffer
_C3DRendererContextDeleteRenderBuffer
C3DRendererContextDeleteFramebuffer
C3DRendererContextGetViewport
C3DRendererContextSetViewport
C3DRendererContextSetViewportForExternal2D
C3DRendererContextSetLight
rendererContext->_bindedProgram
lightIndex < C3D_MAX_LIGHTS
*currentTextureUnit <= 7
C3DRendererContextBindCommonProfile
C3DRendererContextUnbindCommonProfile
C3DRendererContextSetFrontFace
C3DRendererContextGetFrontFace
C3DRendererContextSetEnableWriteToDepth
C3DRendererContextSetEnableReadsFromDepth
C3DRendererContextAllocateBufferObject
C3DRendererContextCreateBufferObjectForMeshSource
C3DRendererContextCreateBufferObjectForMeshElement
C3DRendererContextUnbindTexture
C3DRendererContextUnbindTextureUnits
rendererContext->_meshElementsVBOs != NULL
_C3DRendererContextBindTextureGL
_C3DRendererContextUnbindTextureGL
__ReserveAndBindVolatileVBO
C3DRendererContextMapVolatileMesh
C3DRendererContextUnmapVolatileMesh
indicesCount != 0
C3DRendererContextMapVolatileMeshElement
C3DRendererContextUnmapVolatileMeshElement
C3DMeshElementIsVolatile(meshElement)
C3DRendererContextResetVolatileObjects
C3DRendererContextPushGroupMarker
C3DRendererContextPopGroupMarker
<C3DRendererContext>
__FillProgramObjectLocations
nextFreeIndex < bufferCount
_C3DRendererContextCreateTextureWithSize
v24@?0C8^{__CFArray=}12I20
v20@?0I8r*12
C3DRenderContextAttachRenderTargetToFramebuffer
__drawCall
__SetupCommonProfileEffectProperty
C3DRendererContextDeleteVertexArrayObject
C3DBufferObject
<C3DBufferObject vbo:%ld addr:%p lockCount:%d target:%d retainCount:%d>
DOFBlurCoCYPass
DOFCoCBlurred
dof_coc_blurH
!newIndex && !oldIndex
customEnvResource
probeIndex != (uint32_t)kProbeSliceIndexInvalid
i < size()
spec_level.float
FCOLLADA
double_sided
entity
vertex4
kNodeToSIDKey
kMorphingImportKey
kSkinningImportKey
kSkinningUsedGeometriesKey
No data or file to load from
/dev/null
An error occurred while parsing the COLLADA file. Please check that it has not been corrupted.
Failed to retrieve scene from XPC service.
start
nodeToTransformArray
TEXCOORD
materialsSemantic
domUVSetToSource
visibility
renderingOrder
! skeletonURI.isExternalReference()
lookedUp
jointNames
jointNamesAreIDs
SCNDetailedErrorsKey
SCNConsistencyElementTypeErrorKey
SCNConsistencyElementIDErrorKey
This <%s> does not have a <%s> descendant
This <%s> does not have a <%s> attribute
Unable to resolve the URI %s
Unable to find an element with the ID "%s"
(type=
, no ID found)
, no ID found, closest ancestor with ID = 
, ID=
The number of elements in the <%s> tag (%lld) should be %lld.
Offset too large
VERTEX
The %dth <p> element has less than %d vertices
The number of vertices in the %dth <p> element should be a multiple of %d
vertices
POSITION
binding not found for material symbol
vcount
OpenCL
computed_float_array
The stride of this source should at least be %llu
The number of items in this source is %llu but should at least be %llu.
Found %d elements with the same ID "%s"
UseIOStrictMode
source_data
layer
init_from
xs:ID
xs:NCName
library_images
library_effects
library_materials
technique_common
text
extra
library_physics_models
library_physics_scenes
instance_physics_scene
annotate
'sid'
is not a valid value of the atomic type 'xs:NCName'
'url'
is not a valid value of the atomic type 'xs:anyURI'
visual_scene
'id'
'name'
subject
asset
canvas_aspect
SCNConsistencyLineNumberErrorKey
JOINT
INV_BIND_MATRIX
There must be one inverse bind matrix per joint
Cannot find a node with the SID "%s"
A skin must have either a name array or an IDREF array to store its joints.
Circular reference between nodes detected
Invalid node array
Invalid instance node array
create
conditionerBase.cpp
SkinInfo
deindexer_core.cpp
vindex == vnumber
matrix4x4
constant_ambient
constant_diffuse
bump.texture
shininess.texture
shader.use_self_illum_color
ambient_diffuse_lock
extendedLightingModel
invertCulling
avoidsOverLighting
readsFromDepthBuffer
fresnelExponent.float
intensities
The meshes in the document appear to be corrupted.
The document does not have a scene. Please check that it has not been corrupted.
%.1f %.1f %.1f
%FT%T%z
SketchUp
Blender
start_time
end_time
MAX3D
frame_rate
clVertexProgram
vertex_program
%s-%d
animation-%d
INPUT
OUTPUT
IN_TANGENT
OUT_TANGENT
INTERPOLATION
inTangent
outTangent
interpolation
parentGroup
grandParentGroup
ANGLE
ambient.color
diffuse.color
specular.color
emission.color
transparent.color
reflective.color
focal_depth
ALPHA
DOUBLE_SIDED
(0)(0)
(0)(1)
(0)(2)
(1)(0)
(1)(1)
(1)(2)
(2)(0)
(2)(1)
(2)(2)
(3)(0)
(3)(1)
(3)(2)
sample_radius
hotspot_beam
falloff
LINEAR
STEP
BEZIER
unnamed animation #%d
shadow_attributes.type
use_far_attenuation
far_attenuation_end
attenuation_far_end
far_attenuation_start
attenuation_far_start
near_attenuation_start
attenuation_near_start
shadow
enable
spotParameters
outerAngle
falloffExponent
innerAngle
constant_ambient.texture
constant_diffuse.texture
multiply.texture
HANNEL
CHANNEL1
ANNEL
CHANNEL2
NNEL
CHANNEL3
CHANNEL4
CHANNEL5
CHANNEL6
CHANNEL
CHANNEL0
kSceneSourcePreserveOriginalTopology
COLLADA_MeshSource
COLLADA_MeshElement
c3dlibrary
user_properties
lightmap_path
The count element of domVertexWeights does not match the vertex count. Please ensure the document has been checked for consistency
C3DSkinGetJointsCount(skin) == 1
nodes
COLLADASchema
http://www.w3.org/2001/03/xml.xsd
rewriteURI
geometry processing
deindexer
polygons2triangles
No input with the semantic "%s" found
The "count" attribute of the <%s> tag (%llu) should be %llu.
The URI %s should point to a <%s> but points to a <%s>
applyDeindexing
newsource
FloatSourcePair
elementSize == sizeof(double)
commonprofile_frag
commonprofile_vert
standard_frag
standard_vert
standard_post_tessellation_vert
hashcode
trackedResource
USE_%@
USE_%@_COLOR
USE_%@_INTENSITY
USE_%@_TEXTURE_COMPONENT
USE_%@TEXCOORD
USE_%@_MAP
USE_%@_CUBEMAP
CFEqual(name, kC3DNotificationProfileWillDie)
SceneKit-CI-nodetree-color-
SceneKit-CI-effect-color-
SceneKit_renderCINodeTree-
SceneKit-CI-nodetree-depth
SceneKit_ApplyCIFilter
SceneKit_renderCIQuad
C3D-CIFilter_middleZ
C3D-CIFilter_extent
SceneKit-CI-nodetree-color
SceneKit-CI-effect-color
SceneKit_renderCINodeTree
C3DFXCIFilterPassMetal.json
C3DFXCIFilterPass.json
NSNumber
CICrop
inputRectangle
C3DTextureGetTargetMode(texture) == GL_TEXTURE_RECTANGLE_EXT
C3D-CIFilter_modelMatrix
I16@?0^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}8
v12@?0I8
C3DGeometryInitSubdivTopologyInfoIfNeeded
C3DGeometryOpenSubdivSupportInternal.cpp
(int32_t)vertexCountPerFaceCurrentIndex == topologyInfo->topologyDescriptor.numFaces
vertIndicesPerFaceCurrentIndex == topologyInfo->totalIndexCount
topologyInfo
C3DMeshElementGetIndicesChannelCount(creasesElement) == 1
currentIndex == topologyInfo->totalIndexCount
overallVertexIndex == topologyInfo->totalIndexCount
subdividedElementIndexForFace < subdividedElementCount
C3DSubdivCreateMesh
faceVertexIndices.size() == 4
indexBufferIndex == indexBufferIndexCount
C3DSubdivSourceSemanticCanBePrimvar(semantic, inputSet, isCPUSubdiv)
level <= _finalLevel
Interpolate
primvarRefiner.h
level>0 && level<=(int)_refiner._refinements.size()
interpFromEdges
refinement.getNumChildVerticesFromFaces() > 0
Vtr::IndexIsValid(cVertOfFace)
interpFromVerts
vMask.AreFaceWeightsForFaceCenters()
assignSmoothMaskForVertex
catmarkScheme.h
vertex.GetNumFaces() == vertex.GetNumEdges()
CombineVertexVertexMasks
scheme.h
this->AreFaceWeightsForFaceCenters() == dst.AreFaceWeightsForFaceCenters()
InterpolateVarying
InterpolateFaceVarying
interpFVarFromEdges
eFaceIndex == i
interpFVarFromVerts
pSibling == cSibling
srcContent.componentCount <= 4
_interpolationMode == kC3DSubdivPrimvarDataInterpolationModeInterpolateVertex
subdividedDataCount == refiner.GetLevel(refiner.GetMaxLevel()).GetNumVertices()
CreateMeshSources
faceVertexCount == 4
Failure in PrimvarRefiner::Limit() -- last level of refinement does not include full topology.
limit
tan1Mask.GetNumFaceWeights() == tan2Mask.GetNumFaceWeights()
tan1Mask.GetNumEdgeWeights() == tan2Mask.GetNumEdgeWeights()
assignSmoothLimitMask
loopScheme.h
valence != 2
C3DFramebuffer
framebuffer
renderTarget->_fboRetainCount > 0
description
description->depthDescription.renderToTexture == false
description->colorsDescription[i].renderToTexture == false
rgba
rgba8
rgba8unorm
rgba8snorm
rgba8s
rgba8uint
rgba8ui
rgba8sint
rgba8i
rgba16
rgba16unorm
rgba16snorm
rgba16s
rgba16uint
rgba16ui
rgba16sint
rgba16i
rgba16float
rgba16f
rgba32
rgba32uint
rgba32ui
rgba32sint
rgba32i
rgba32float
rgba32f
rg8unorm
rg8snorm
rg8s
rg8uint
rg8ui
rg8sint
rg8i
rg16
rg16unorm
rg16snorm
rg16s
rg16uint
rg16ui
rg16sint
rg16i
rg16float
rg16f
rg32
rg32uint
rg32ui
rg32sint
rg32i
rg32float
rg32f
r8unorm
r8snorm
r8uint
r8ui
r8sint
r16unorm
r16snorm
r16s
r16uint
r16ui
r16sint
r16i
r16float
r16f
r32uint
r32ui
r32sint
r32i
r32float
r32f
bgra8unorm
bgra8
depth16unorm
depth16
depth24unorm
depth24
depth32float
depth32f
depth24unorm_stencil8
depth32float_stencil8
stencil8
framebufferColor
r8Unorm
r8Snorm
r8Uint
r8Sint
r16Unorm
r16Snorm
r16Uint
r16Sint
r16Float
r32Uint
r32Sint
r32Float
rg8Unorm
rg8Snorm
rg8Uint
rg8Sint
rg16Unorm
rg16Snorm
rg16Uint
rg16Sint
rg16Float
rg32Uint
rg32Sint
rg32Float
bgra8Unorm
rgba8Unorm
rgba8Snorm
rgba8Uint
rgba8Sint
rgba16Unorm
rgba16Snorm
rgba16Uint
rgba16Sint
rgba16Float
rgba32Uint
rgba32Sint
rgba32Float
depth16Unorm
depth24Unorm
depth32Float
depth24Unorm_stencil8
depth32Float_stencil8
slot%d: %@ 
<C3DFramebuffer %p: color=%@ - depth=%@ color-samples=%d depth-samples=%d renderTargets:%@>
com.apple.scenekit.SCNSceneLoader
unable to load %@
can't launch loader for %@
failed to unarchive data at %@ (%@)
failed to unarchive scene at %@ - unknown decoded object class (%@)
failed to unarchive scene at %@ (%@)
v24@?0@"NSData"8@"NSError"16
u_color
u_transform
commonProfileHashCode
CFGetTypeID(program) == C3DFXMetalProgramGetTypeID()
C3DFXMetalProgram
<C3DFXMetalProgram %p [vertex:`%@` fragment:`%@` macros:%@]>
v24@?0^{__CFString=}8r^v16
SSAODepthNormalPass
--DepthAndNormalMaterial--
#pragma body
_output.color = float4(_surface.normal.xyz, _surface.position.z);
resourceManager
C3DResourceManager
com.apple.scenekit.resourceManagerDeletionQueue
textures
proxy
<C3DResourceManager>
textureProxy
kResourceManagerPendingMeshElementRemoval
kResourceManagerPendingImageRemoval
kResourceManagerPendingImageProxyRemoval
kResourceManagerPendingProgramRemoval
kResourceManagerPendingMeshRemoval
kResourceManagerPendingMeshSourceRemoval
meshSourceData
value
C3DRasterizerStates
states
!scn_mutex_trylock(&s_RasterizerStatesRegistryLock)
CFSetContainsValue(s_RasterizerStatesRegistry, cf)
<C3DRasterizerStates %p> ZRead:%d ZWrite:%d ZFunc:%d cull:%d fill:%d
C3DTexture
<C3DTexture>
C3DImageProxy
imageProxy
imageProxy->_callbacks.getCaptureDeviceInfo
C3DTextureProxy
<C3DImageProxy>
<C3DTextureProxy>
C3DEnginePipeline
attribute
v16@?0^{__C3DEngineContext=}8
notifications._eventType == kC3DNotificationEventType_Node
notifications._eventType == kC3DNotificationEventType_Material
notifications._eventType == kC3DNotificationEventType_Geometry
notifications._eventType == kC3DNotificationEventType_Light
engineIterationContext
name == kC3DNotificationNodeWillDie
pipeline
<C3DEnginePipeline %p>
v28@?0^{__C3DDeformerStack=}8^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}16C24
index < 3
HDRFrameLuminancePass
scn_draw_fullscreen_triangle_VR_uv_vertex
scn_hdr_luminance_frag
*oLength > 0
lifeArray
invLifeSpan
birthTimeArray
invMassArray
sizeArray
bounceArray
frictionArray
chargeArray
colorsArray
rotAxisArray
valueArray
C3DFXGLSLProgramObject
<C3DFXGLSLProgramObject %p>
com.apple.scenekit.jitteringUpdateQueue
_iteration <= C3DJitteringIterationCount
C3DFXProgramDelegate
programDelegate
introspectionDataPtr
<C3DFXProgramDelegate %p>
C3DSubdivisionOsdGPURuntimeData
commandQueue
coarseVertexCount
vertexPatchTable
fvarPatchTables
legacyGregoryPatchTable
patchRangesTable
vertexRefiner
fvarRefiners
skinMorphSubdivIndexToMetalIndexBuffer
synchronizeCoarsePositionsPipeline.functionName
fvarChannelDescriptorsBuffer
fvarChannelsPackedDataBuffer
C3DSubdivisionOsdGPUGetPerPatchTypeSources
C3DGeometryOpenSubdivSupport_Metal.mm
OSD_IS_ADAPTIVE
OSD_PATCH_QUADS
OSD_PATCH_TRIANGLES
OSD_PATCH_REGULAR
CONTROL_POINTS_PER_PATCH
OSD_PATCH_GREGORY
OSD_PATCH_GREGORY_BASIS
OSD_PATCH_GREGORY_BOUNDARY
struct OsdInputVertexType { 
    metal::packed_float3 position; 
    metal::packed_float2 texcoord
    metal::packed_float4 color; 
#define OSD_USER_VARYING_DECLARE                             
float2 texcoord
float4 color; 
#define OSD_USER_VARYING_DECLARE_PACKED                             
metal::packed_float2 texcoord
metal::packed_float4 color; 
#define OSD_USER_VARYING_PER_VERTEX(in, out)                 
out.texcoord
 = in.texcoord
out.color = in.color; 
#define OSD_USER_VARYING_PER_CONTROL_POINT(in, out)          
#define OSD_USER_VARYING_PER_EVAL_POINT(UV, a, b, c, d, out) 
 = mix(mix(a.texcoord
, b.texcoord
, UV.x), mix(c.texcoord
, d.texcoord
, UV.x), UV.y); 
out.color = mix(mix(a.color, b.color, UV.x), mix(c.color, d.color, UV.x), UV.y); 
#define OSD_USER_VARYING_DECLARE_ATTRIBUTE                   
 [[attribute(
)]]; 
float4 color [[attribute(
VERTEX_BUFFER_INDEX
PATCH_INDICES_BUFFER_INDEX
CONTROL_INDICES_BUFFER_INDEX
OSD_PATCHPARAM_BUFFER_INDEX
OSD_PERPATCHVERTEXBEZIER_BUFFER_INDEX
OSD_PERPATCHTESSFACTORS_BUFFER_INDEX
OSD_VALENCE_BUFFER_INDEX
OSD_QUADOFFSET_BUFFER_INDEX
TRANSFORMS_BUFFER_INDEX
TESSELLATION_LEVEL_BUFFER_INDEX
INDICES_BUFFER_INDEX
QUAD_TESSFACTORS_INDEX
OSD_PERPATCHVERTEXGREGORY_BUFFER_INDEX
OSD_PATCH_INDEX_BUFFER_INDEX
OSD_DRAWINDIRECT_BUFFER_INDEX
OSD_KERNELLIMIT_BUFFER_INDEX
OSD_PATCH_ENABLE_SINGLE_CREASE
OSD_FRACTIONAL_EVEN_SPACING
OSD_FRACTIONAL_ODD_SPACING
OSD_MAX_TESS_LEVEL
USE_STAGE_IN
USE_PTVS_FACTORS
USE_PTVS_SHARPNESS
THREADS_PER_THREADGROUP
CONTROL_POINTS_PER_THREAD
VERTEX_CONTROL_POINTS_PER_PATCH
OSD_MAX_VALENCE
OSD_NUM_ELEMENTS
OSD_ENABLE_BACKPATCH_CULL
OSD_USE_PATCH_INDEX_BUFFER
OSD_ENABLE_SCREENSPACE_TESSELLATION
OSD_ENABLE_PATCH_CULL
NEEDS_BARRIER
OSD_FVAR_WIDTH
OSD_FVAR_USES_MULTIPLE_CHANNELS
OSD_FVAR_DATA_BUFFER_INDEX
OSD_FVAR_INDICES_BUFFER_INDEX
OSD_FVAR_PATCHPARAM_BUFFER_INDEX
OSD_FVAR_PATCH_ARRAY_BUFFER_INDEX
OSD_FVAR_CHANNELS_CHANNEL_COUNT_INDEX
OSD_FVAR_CHANNELS_CHANNEL_DESCRIPTORS_INDEX
OSD_FVAR_CHANNELS_PACKED_DATA_BUFFER_INDEX
OSD_FVAR_CHANNELS_PATCH_ARRAY_INDEX_BUFFER_INDEX
OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING
OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING
OSD_COLOR_INTERPOLATION_MODE
OSD_TEXCOORD0_INTERPOLATION_MODE
OSD_TEXCOORD1_INTERPOLATION_MODE
OSD_TEXCOORD2_INTERPOLATION_MODE
OSD_TEXCOORD3_INTERPOLATION_MODE
OSD_TEXCOORD4_INTERPOLATION_MODE
OSD_TEXCOORD5_INTERPOLATION_MODE
OSD_TEXCOORD6_INTERPOLATION_MODE
OSD_TEXCOORD7_INTERPOLATION_MODE
C3D_OPTIMIZE_OPENSUBDIV_STORAGE
geometry->_subdivInfo.subdivisionLevel > 0
v20@?0@"<MTLCommandBuffer>"8B16
osdRuntimeData->skinMorphContext.synchronizeCoarsePositionsPipeline
__C3DSubdivisionOsdGPUHasPatchOfType(osdRuntimeData, c3dPatchType)
C3DSubdivisionOsdGPUDraw
vertexDataBuffer
<C3DSubdivisionOsdGPURuntimeDataRef %p>
Vertex patch table:
  - Patch arrays (%@):
    - %d x %@
  - Data buffer: %p (%@)
  - Patch index buffer: %p (%@)
  - Patch param buffer: %p (%@)
FVar patch table (channel %zu):
Legacy Gregory patch table:
  - Vertex valence buffer: %p (%@)
  - Quad offsets buffer: %p (%@)
  - Vertex stencil table (%d stencils)
    - Sizes buffer: %p (%@)
    - Offsets buffer: %p (%@)
    - Indices buffer: %p (%@)
    - Weights buffer: %p (%@)
  - Vertex evalutor input
    - Src buffer: [offset:%d length:%d stride:%d] %p (%@)
    - Dst buffer: [offset:%d length:%d stride:%d] %p (%@)
v16@?0r^{?={?=@@@@i}{?=@@{BufferDescriptor=iii}{BufferDescriptor=iii}}@}8
Vertex Refiner:
  - Skin/morph indexing table: %p (%@)
Total memory usage: %@
QUADS
TRIANGLES
REGULAR
GREGORY
GREGORY BOUNDARY
GREGORY BASIS
C3DGetPatchTypeDescription
.patchArrays
.dataBufferOffset
.dataBufferCoarseDataSize
.dataBufferFullDataSize
.patchIndexBuffer
.patchParamBuffer
.dataBuffer
.count
.[%d]
.vertexValenceBuffer
.quadOffsetsBuffer
.quadOffsetsBaseGregory
.quadOffsetsBaseGregoryBoundary
.elementCount
.patchArrayCount
.[%d][%d]
.stencilTable
.evaluatorInput
.sizesBuffer
.offsetsBuffer
.indicesBuffer
.weightsBuffer
.numStencils
.srcDesc
.dstDesc
__C3DSubdivisionOsdGPURuntimeDataDecodeEvaluatorInput
srcLength == sizeof(OpenSubdiv::Osd::BufferDescriptor)
dstLength == sizeof(OpenSubdiv::Osd::BufferDescriptor)
 -w 
compute_opensubdiv
C3DPatchTypeFromOsdPatchType
C3D-OpenSubdiv_compute.metal
C3DPatchTypeToOsdPatchType
fvarChannelCount == fvarPrimvarCount
^{__CFData=}8@?0
v24@?0{?=qq}8
%@-%s
Mesh
mesh.h
_refiner
initializeContext
{MTLContext=@@@@}8@?0
mtlBlitContext.computeCommandEncoder
mtlBlitContext.commandBuffer
__C3DSubdivisionOsdGPURuntimeDataEncodeMTLBuffer
encodedLength <= buffer.length
scn_osd_synchronize_coarse_positions_no_argument_buffer
scn_osd_synchronize_indexed_coarse_positions_no_argument_buffer
osdRuntimeData->coarseVertexCount == remappingTableSize
refiner->computeEvaluator
evaluatorDidSucceed
aoCoord
lightmapCoord
bitangent
kMDLAssetDefaultUSDColorSpace
usdz
SCN_MDLCurrentAssetResolver
While creating SCNSkinner: Could not find SCNNode %@
influenceWeightNumber.floatValue < 1.f
morpher.weights[%d]
SCNSceneKitAssociatedObject
B32@?0@"SCNGeometrySource"8Q16^B24
blendShape%d
normal%d
textureCoordinate%d
baseColor
metallic
%@_%d
AO_%@_%@.png
@"NSString"16@?0@"SCNNode"8
v32@?0@"SCNNode"8@"SCNGeometry"16@"NSArray"24
aoTexture
lightmapTexture
/tmp/ModelKit_AO_%@.png
fieldOfView
fstop
MDLAssetLoadingOption getMDLAssetLoadingOptionDefaultUSDColorSpace()
SCNModelIOPrivate.mm
MDLAssetLoadingOptionDefaultUSDColorSpace
void *ModelIOLibrary()
/System/Library/Frameworks/ModelIO.framework/Contents/MacOS/ModelIO
/%@.position
/%@.orientation
/%@.scale
Bad joint path detected for joint: %@
positionAttribute
offset=%d&size=%d
Error: ranges and strings arrays must be of the same size
Error: ranges must be ordered
Error: incorrect ranges : cumulated size larger than the original string
SCNTechniqueView
SCNKitError : can't load nib named : SCNTechniqueView
_surface.emission.rgb = vec3(_surface.emission.a);
_surface.emission.a = 1.0;
_surface.emission.rgb *= vec3(%d.0, %d.0, %d.0);
_surface.emission.a = 1.0;
shader
stage
C3DFXShader
<C3DFXShader %@>
SCNLightingModelConstant
SCNLightingModelLambert
SCNLightingModelPhong
SCNLightingModelBlinn
SCNLightingModelNone
SCNLightingModelShadowOnly
SCNLightingModelPhysicallyBased
SCNLightingModelInvalid
commonProfile->_lightingModel < C3DLightingModelCount && C3DLightingModelCount < 15
C3DEffectCommonProfile
<C3DEffectCommonProfile %p :
 lightingModel:%@
 perPixelLit:%d
 isOpaque:%d
 transparencyMode:%d
Emission
Ambient
Diffuse
Specular
Reflective
Transparent
Filter
Normal
Ambient Occlusion
Self Illumination
Metalness
Roughness
ClearCoat
ClearCoatRoughness
ClearCoatNormal
Displacement
Shininess
Reflectivity
Transparency
Fresnel
[%@] texture:%d xform:%d
_C3DEffectCommonProfileInitWithPropertyList
versionNumber
ambientIntensity
diffuseIntensity
specularIntensity
emissionIntensity
multiplyIntensity
transparentIntensity
normalIntensity
ambientOcclusionIntensity
selfIlluminationIntensity
displacementIntensity
reflectiveIntensity
locksAmbientWithDiffuse
Intensity
imageID < INT_MAX
entryID
lightingModel
imagesCount
typeID == C3DSceneGetTypeID()
C3DEffectSlot
<C3DEffectSlot>
mtltexture
precomputedLightingEnvironment
transforms
uvSet
SCNAction: Run block actions can not be properly encoded, Objective-C blocks do not support NSSecureCoding.
SCNAction: Run block actions can not be properly decoded, Objective-C blocks do not support NSSecureCoding.
threshold
thresholdType
C3DLOD
<C3DLOD>
SSRCompositePass
Radiance
ReflectanceRoughness
scn_ssr_composite_frag
C3DSpline
spline
<C3DSpline %p>
(size_t)CFDataGetLength(data) == stride * C3DSourceAccessorGetCount(accessor)
C3DMeshSourceIsVolatile(source)
BoxBlurPass
box_blur_frag_%d
copy_frag
SSRDownSampleColorDepthPass
BackDepth
scn_ssr_downsample_depth
vertexCount == CFIndex(baseMesh.pointCount())
C3DMorphIsUsingSparseTargets(morph) == true
morpherCompressedData
morpherMetaData
SCNDecodeMorpherUsingAnimCodec
SCNMorpherAnimCodecSupport.mm
morpherMetaData.length >= (2+targetCount)
Mesh.h
index < pointCount()
setPoint
setPolygonSize
j < polygonCount()
setIndex
i < indexCount()
C3DSortSystem
<C3DSortSystem %p>
C3DLightProbesSystem
probesSystem->_probesCapacity
probesSystem->_probesPositions
tetrahedronIndexes
_tetrahedrons[tetraderonIndex].neighbourIndexes[otherTetraderonFaceIndex] == -1
sh_sizeof(shOrder) == (size_t)CFDataGetLength(irradianceSH)
lastIndex != (uint32_t)-1
cacheIndex
sh_sizeof(shOrder) == (size_t)shLength
<C3DLightProbesSystem %p>
tetrahedronIsValid[indexValid]
validTetraCount <= (uint32_t)indexToRecycle
vCount <=2
ManipulatorPass
C3DEdgeArray
edges
edgeCount == edges->_count
index < edges->_count
array
C3DTriangulationInfo
edgeIndexesPerFaceCounter[j] <= 2
info
<C3DEdgeArray>
<C3DTriangulationInfo>
com.apple.sceneKit.forceGL
com.apple.sceneKit.forceMetal
com.apple.sceneKit.showsStatistics
com.apple.sceneKit.enableCameraControl
com.apple.sceneKit.batchMaxCount
com.apple.sceneKit.forceNoAA
com.apple.sceneKit.disableLinearSpaceRendering
com.apple.sceneKit.disableWideGamut
com.apple.sceneKit.enableWideGamut
com.apple.sceneKit.enablePostMorphUnifyNormals
com.apple.sceneKit.enableStandardShadersWithFunctionConstants
com.apple.sceneKit.forceNMOSBehavior
com.apple.sceneKit.forceOS2019Behavior
com.apple.sceneKit.forceOS2018Behavior
com.apple.sceneKit.forceOS2017Behavior
com.apple.sceneKit.forceOS2016Behavior
com.apple.sceneKit.verbose
com.apple.sceneKit.useOneCommandQueuePerDevice
com.apple.sceneKit.disableReverseZ
com.apple.sceneKit.isolateCacheMissShader
C3DMeshElementEditor
MeshElementEditor
editor
<C3DMeshElementEditor>
hash
debugDescription
overrides
ide_
ske_
simd
geometry.materials[%d]
particleSystems[0]
[%d]
SCNReferenceLoadingStack
referenceRoot
<%@: %p url=%@>
referenceURL
loadingPolicy
childNodes
repeatCount
repeatDuration
usesSceneTimeBase
{CATransform3D=dddddddddddddddd}
DOFFinalBlurPass
DofColorCoC
dof_blur
dof_compute_kernel
OutlinePass
COLOR_OUTLINE
outline_vert
outline_frag
DrawBackgroundPass
BACKGROUND
SubdivideMidPoint
VMesh.cpp
end < shifts[a + 1]
preprocess() 
 LOD[
InterpolateNormals
neighbor.a >= 0 && neighbor.a < int32_t(normals.size())
neighbor.b >= 0 && neighbor.b < int32_t(normals.size())
loadBaseMeshFromVectors
pointVec.size() > 0
uvVec.size() == pointCountInVec
normalVec.size() == pointCountInVec
(idxVec.size() % 3) == 0
triangle
VMesh.hpp
InterpolateMidPoint
neighbor.a >= 0 && neighbor.a < int32_t(signal.size())
neighbor.b >= 0 && neighbor.b < int32_t(signal.size())
neighborsStartIndex
neighborsEndIndex
<%@: %p | scene=%@ sceneTime=%f pointOfView=%@>
Jittering is not supported on SCNMetalLayer
animationPlayer
C3DAnimationPlayer
<C3DAnimationPlayer %p>
blendFactor
C3DIndexSet
indexSet 
(no index)
[number of indexes: %lu (in %lu ranges), indexes: (
-%lu
DOFBlurCoCXPass
dof_coc_blurV
%@: %@
objectController.selection%@.%@
selectedValue
vector2
vector3
vector4
matrix4
selectedIndex
%@[%d]
failed to instanciate a %@ with option %@
New %@
failed to instanciate a %@
%@.%@
imageSequence
%@%@
screenSpaceAmbientOcclusion
ssao
{CGPoint=dd}
{CGSize=dd}
{SCNVector3=ddd}
{SCNVector4=dddd}
@"NSString"
@"NSColor"
@"NSArray"
@"SCN
olor
ontent
mage
_C3DAnimationInitWithPropertyList
duration
autoreverses
additive
cumulative
isAnimationClip
removeOnCompletion
sceneTimeBased
fillModeMask
timeOffset
beginTime
fadeInDuration
fadeOutDuration
timingFunction
simpleAnimation
C3DSimpleAnimation
<C3DSimpleAnimation>
baseType
startValue
byValue
endValue
light->_type == kC3DLightTypeIES
projInfoOut
C3DLightAddLightSHContribution
C3DLight.c
C3DLight
<C3DLight %p> Type:%@ CastsShadow(Samples:%d Cascade:%d)
<C3DLight %p> Type:%@
Directional
Omni
Spot
Irradiance
Area[Rectangle]
Area[Polygon]
Area[Line]
Area[Ellipse]
Area[Ellipsoid]
Unknown
attenuationEndDistance
attenuationStartDistance
shadowBias
temperature
shadowCascadeDebugFactor
_C3DLightInitWithPropertyList
property3
property4
castShadow
znear
zfar
shadowSoftenFactor
category
shadowMapSize
directionalExtent
shadowMaxSampleCount
categoryBitMask
Area light - Rectangle
Area light - Polygon
Area Light - Line
Area Light - Ellipse
Area Light - Ellipsoid
area_shape_vert
area_shape_ellipse_frag
halfExtents
area_shape_ellipsoid_frag
sh_eval_direction
sh_math.h
order < kSHMinOrder || order > kSHMaxOrder
sh_accumulate_omni_light
jointDef->bodyA
bodyA
bodyB
infos
C3DCamera
<C3DCamera:%p "%@" custom, [%.3f %.3f %.3f %.3f ; %.3f %.3f %.3f %.3f ; %.3f %.3f %.3f %.3f ; %.3f %.3f %.3f %.3f]>
<C3DCamera:%p "%@" ortho, near:%.3f far:%.3f scale: %.3f>
<C3DCamera:%p "%@" persp, near:%.3f far:%.3f %s-fov:%.3f>
horizontal
vertical
fStop
aspectRatio
sensorHeight
lensShift
postProjectionTransformTranslation
postProjectionTransformScale
averageGray
bloomBlurRadius
bloomIntensity
bloomThreshold
bloomIteration
bloomIterationSpread
colorFringeStrength
colorFringeIntensity
contrast
grainIntensity
grainScale
exposureAdaptationBrighteningSpeedFactor
exposureAdaptationDarkeningSpeedFactor
exposureAdaptationDuration
exposureAdaptationHistogramRangeHighProbability
exposureAdaptationHistogramRangeLowProbability
exposureOffset
focusDistance
focalLength
maximumExposure
minimumExposure
saturation
vignettingIntensity
vignettingPower
whitePoint
screenSpaceAmbientOcclusionIntensity
screenSpaceAmbientOcclusionRadius
screenSpaceAmbientOcclusionBias
screenSpaceAmbientOcclusionDepthThreshold
screenSpaceAmbientOcclusionNormalThreshold
screenSpaceAmbientOcclusionSampleCount
screenSpaceAmbientOcclusionDownSample
whiteBalanceTemperature
whiteBalanceTint
_C3DCameraInitWithPropertyList
ortho
letterbox
fovHorizontal
customProj
autoZRange
xfov
yfov
xMag
bladeCount
dofSampleCount
sensorSize
orthoScale
inputMode
inputScale
inputBias
inputOrigin
inputProperty
SCNCaptureDeviceOutputConsumerOptionContainsAlpha
BloomDownSamplePass
scn_bloom_downsample
FinalPass
lastPassOutputingDepth
mainPassLastPassColorOutputDescriptor
mainDepthDesc
finalPass
dependencyFound
param.name
Vertex
Texcoord
Tangent
ModelViewProjectionTransform
ModelViewTransform
ModelTransform
ViewTransform
ProjectionTransform
NormalTransform
ModelViewProjectionInverseTransform
ModelViewInverseTransform
ModelInverseTransform
ViewInverseTransform
ProjectionInverseTransform
NormalInverseTransform
InverseResolution
SystemTime
COLOR0
COLOR1
COLOR2
COLOR3
attachmentID < fboDesc->colorsDescriptionCount
inputIndex < passOutput.size()
kSkinnerKey
kMorpherKey
subdivisionLevel > 0
child->_nextSibling == NULL
child->_parent == NULL
prevSibling->_parent == node
prevChild
node->_transformHandle != kC3DTransformHandleInvalid
nodeID
attributeName
ancestor
arrayOfNodes
layer < C3D_MAX_LAYERS
C3DNode
<C3DNode:%p "%@"
  geometry: %@
  light: %@
  camera: %@
  skinner: %@
  morpher: %@
_C3DNodeInitWithPropertyList
alpha
isJoint
euler
axisAngle
kC3D
libID!=0
firstChild
nextSibling
skinner
sphereOut
v32@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}8q16^B24
!C3DNodeShouldBePutInCullingSystem(root) || (root->_cullingHandle != kC3DCullingHandleInvalid)
!C3DNodeShouldBePutInCullingSystem(child) || (child->_cullingHandle != kC3DCullingHandleInvalid)
semantic != kC3DMeshSourceSemanticPosition || data->sourcesSemanticInfos[semantic].count == 0
semantic > currentSemantic
data->sourcesSemanticInfos[semantic].index == -1
mesh->_renderableData.sources
mesh->_renderableData.elements
sources
primarySourcesInfo
srcCount == dstCount
sourceIndex < oldSourceCount
(dataKind != kC3DMeshDataKindRenderable) || (channel == kC3DSharedRenderableIndexChannel)
channel != kAutomaticChannelIndex
mesh->_originalData.sourceChannels
sourceIndex != kCFNotFound
mesh->_originalData.elements
C3DMeshGetIndexOfElement
C3DMeshGetElementAtIndex
C3DMeshGetMeshElements
subIDs
C3DSourceAccessorGetSource(accessor) == (C3DGenericSourceRef) primarySource
C3DMesh
<C3DMesh %p "%@"
  element%d: %@
  source %@%d (channel:%d) : %@
  source %@ (channel:%d) : %@
  renderable element%d: %@
  renderable source %@%d: %@
  renderable source %@: %@
_C3DMeshInitWithPropertyList
baseSourceLocators
verticesMask
sourceID <= INT_MAX
C3DGenericSourceIsPrimary(primarySource)
boundingSphere
meshElements
__meshDataForDataKind
sourceIndex < CFArrayGetCount(meshData->sources)
renderableElement
elementCount == CFArrayGetCount(deindexedTriangleElements)
value == sourceInfo.dataVectorCount
overallVertexIndex == (CFIndex)indexCount
sourceCount == CFArrayGetCount(deindexedSources)
elementCount == CFArrayGetCount(deindexedElements)
channelCount == C3DMeshElementGetIndicesChannelCount(rhs.element)
__writeIndexInBuffer
channelCount == 1
__C3DMeshElementCreateRenderablePrimitiveTypeCopy
effectID
fillMode == kC3DFillModeFill || fillMode == kC3DFillModeLines
material->_commonProfile
oBlendColor
C3DMaterial
<C3DMaterial %p : "%@", 
common profile %@
custom %@
_C3DMaterialInitWithPropertyList
__library__
enableWriteInDepthBuffer
enableReadsFromDepthBuffer
fillMode
C3DConstraintSlider
v28@?0f8r^{Triangle=}12r^20
B20@?0^8I16
vertices.type == kC3DBaseTypeVector3
vertexCountPerPolygon >= 3
C3DConstraintAvoidOccluder
positions.type == kC3DBaseTypeVector3
<C3DConstraintAcceleration>
<C3DConstraintAvoidOccluder %p>
_hasFired
nodeConstraints-%p
originator
C3DScene
<C3DScene>
fogColor
fogDensityExponent
fogEndDistance
fogStartDistance
wantsScreenSpaceReflection
screenSpaceReflectionSampleCount
screenSpaceReflectionMaximumDistance
screenSpaceReflectionStride
_C3DSceneInitWithPropertyList
startTime
endTime
frameRate
upAxis
nodeTree
libID < INT_MAX
playbackSpeed
kSCNFreeViewCameraName
<%@: %p '%@'>
<%@: %p>
-[SCNCamera setName:]
-[SCNCamera setScreenSpaceAmbientOcclusionIntensity:]
-[SCNCamera setScreenSpaceAmbientOcclusionRadius:]
-[SCNCamera setScreenSpaceAmbientOcclusionBias:]
-[SCNCamera setScreenSpaceAmbientOcclusionDepthThreshold:]
-[SCNCamera setScreenSpaceAmbientOcclusionNormalThreshold:]
-[SCNCamera setScreenSpaceAmbientOcclusionSampleCount:]
-[SCNCamera setScreenSpaceAmbientOcclusionDownSample:]
-[SCNCamera setAutomaticallyAdjustsZRange:]
-[SCNCamera setAverageGray:]
-[SCNCamera setBloomBlurRadius:]
-[SCNCamera setBloomIntensity:]
-[SCNCamera setBloomThreshold:]
-[SCNCamera setBloomIterationCount:]
-[SCNCamera setBloomIterationSpread:]
-[SCNCamera setCategoryBitMask:]
-[SCNCamera setColorFringeStrength:]
-[SCNCamera setColorFringeIntensity:]
-[SCNCamera setContrast:]
-[SCNCamera setGrainIntensity:]
-[SCNCamera setGrainScale:]
-[SCNCamera setGrainIsColored:]
-[SCNCamera setGrainSlice:]
-[SCNCamera setGrainTexture:]
-[SCNCamera setWhiteBalanceTemperature:]
-[SCNCamera setWhiteBalanceTint:]
-[SCNCamera setExposureAdaptationBrighteningSpeedFactor:]
-[SCNCamera setExposureAdaptationDarkeningSpeedFactor:]
-[SCNCamera setExposureAdaptationDuration:]
-[SCNCamera setExposureAdaptationHistogramRangeHighProbability:]
-[SCNCamera setExposureAdaptationHistogramRangeLowProbability:]
-[SCNCamera setExposureAdaptationMode:]
-[SCNCamera setExposureOffset:]
-[SCNCamera setDofIntensity:]
-[SCNCamera setMaximumExposure:]
-[SCNCamera setMinimumExposure:]
-[SCNCamera setMotionBlurIntensity:]
-[SCNCamera setOrthographicScale:]
-[SCNCamera setSaturation:]
-[SCNCamera setUsesOrthographicProjection:]
-[SCNCamera setVignettingIntensity:]
-[SCNCamera setVignettingPower:]
-[SCNCamera setWantsExposureAdaptation:]
-[SCNCamera setWantsHDR:]
-[SCNCamera setWhitePoint:]
-[SCNCamera setXFov:]
-[SCNCamera setYFov:]
-[SCNCamera setZFar:]
-[SCNCamera setZNear:]
-[SCNCamera setLensShift:]
-[SCNCamera setPostProjectionTransform:]
-[SCNCamera setPostProjectionTransformTranslation:]
-[SCNCamera setPostProjectionTransformScale:]
fabs(_focalLength - focalLength) < 1e-3
_focalLength == 0.f
-[SCNCamera setFieldOfView:]
-[SCNCamera setSensorHeight:]
-[SCNCamera setFocalLength:]
-[SCNCamera setFStop:]
-[SCNCamera setApertureBladeCount:]
-[SCNCamera setFocalBlurSampleCount:]
-[SCNCamera setFocusDistance:]
-[SCNCamera setProjectionTransform:]
usesOrthographicProjection
automaticallyAdjustsZRange
projectionDirection
lensShiftX
lensShiftY
postProjectionTransformTranslationX
postProjectionTransformTranslationY
postProjectionTransformScaleX
postProjectionTransformScaleY
focalBlurSampleCount
exposureAdaptationMode
colorGrading
wantsHDR
wantsExposureAdaptation
focalBlurRadius
{CGRect={CGPoint=dd}{CGSize=dd}}
{?=[4]}
SCNMultisamplingDefaultSampleCount
SKGlobalSharedContextRegistry
C3DRendererContextRetainContext
SCNKitUtils.m
renderContext
C3DRendererContextReleaseContext
SCNLightAttenuationStartKey
SCNLightAttenuationEndKey
SCNLightAttenuationFalloffExponentKey
SCNLightSpotInnerAngleKey
SCNLightSpotOuterAngleKey
SCNLightSpotFalloffExponentKey
SCNLightShadowNearClippingKey
SCNLightShadowFarClippingKey
SCNLightGoboProjectShadows
SCNLightConstantAttenuationKey
SCNLightLinearAttenuationKey
SCNLightQuadraticAttenuationKey
SCNLightFallOffAngleKey
SCNLightFallOffExponentKey
SCNLightHotspotBeamKey
omni
directional
spot
probe
area
<%@: %p '%@' | type=%@>
<%@: %p | type=%@>
-[SCNLight setName:]
-[SCNLight setAttenuationEndDistance:]
-[SCNLight setAttenuationFalloffExponent:]
-[SCNLight setAttenuationStartDistance:]
-[SCNLight setBaked:]
-[SCNLight setCastsShadow:]
-[SCNLight setCategoryBitMask:]
-[SCNLight setColor:]
-[SCNLight setIntensity:]
-[SCNLight setOrthographicScale:]
-[SCNLight setShadowBias:]
-[SCNLight setShadowColor:]
-[SCNLight setShadowMapSize:]
-[SCNLight setShadowRadius:]
-[SCNLight setShadowSampleCount:]
-[SCNLight setSpotFalloffExponent:]
-[SCNLight setSpotInnerAngle:]
-[SCNLight setSpotOuterAngle:]
-[SCNLight setTechnique:]
-[SCNLight setTemperature:]
-[SCNLight setType:]
-[SCNLight setUsesDeferredShadows:]
-[SCNLight setUsesModulatedMode:]
-[SCNLight setZFar:]
-[SCNLight setZNear:]
-[SCNLight setShadowCascadeCount:]
-[SCNLight setAutomaticallyAdjustsShadowProjection:]
-[SCNLight setMaximumShadowDistance:]
-[SCNLight setForcesBackFaceCasters:]
-[SCNLight setSampleDistributedShadowMaps:]
-[SCNLight setShadowCascadeSplittingFactor:]
-[SCNLight set_shadowCascadeDebugFactor:]
usesDeferredShadows
lightCategoryBitMask
spotFallOffExponent
probeType
probeUpdateType
parallaxCorrectionEnabled
probeExtentsX
probeExtentsY
probeExtentsZ
probeOffsetX
probeOffsetY
probeOffsetZ
parallaxOffsetX
parallaxOffsetY
parallaxOffsetZ
parallaxExtentsFactorX
parallaxExtentsFactorY
parallaxExtentsFactorZ
maximumShadowDistance
autoShadowProjection
shadowCascadeCount
shadowCascadeSplittingFactor
forcesBackFaceCasters
sampleDistributedShadowMaps
castsShadow
usesModulatedMode
baked
shouldBakeDirectLighting
shouldBakeIndirectLighting
sphericalHarmonics
scncolor
scnShadowColor
shadowSampleCount
shadowSampleCount2
IESProfileURL
areaType
areaExtentsX
areaExtentsY
areaExtentsZ
areaPolygonVertices
drawsArea
FloorPass
floor
SceneKit-floor-color-
SceneKit-floor-depth-
offsetX
offsetY
mappingChannel
-[SCNMaterial setName:]
<%@: %p
 '%@'
  %@=%@
.color
content
-[SCNMaterial _shadableSetValue:forUndefinedKey:]
shaderModifiers.
customMaterialProperties
customMaterialAttributes
-[SCNMaterial setShaderModifiers:]
-[SCNMaterial copyShaderModifiersAndLanguageVersionFrom:]
-[SCNMaterial setMinimumLanguageVersion:]
-[SCNMaterial setProgram:]
valuesForUndefinedKeys
lightingModelName
shadableHelper
colorBufferWriteMask
GridPass
C3D_grid_vert
C3D_grid_frag
kProjectionTransform
kModelTransform
kViewTransform
kModelViewProjectionTransform
kModelViewTransform
kNormalTransform
kRenderPassName
-[SCNNode setName:]
%s%s {
dump node tree (%@)
------------------------------------------------------
%@%@
<%p>
_affineUpToDate
_transformUpToDate
-[SCNNode _setQuaternion:]
-[SCNNode _setPosition:]
-[SCNNode _setScale:]
-[SCNNode setMovabilityHint:]
-[SCNNode setCastsShadow:]
-[SCNNode setUsesDepthPrePass:]
-[SCNNode setCategoryBitMask:]
-[SCNNode setHidden:]
-[SCNNode setOpacity:]
-[SCNNode setRenderingOrder:]
 pos(%f %f %f)
 rot(%f %f %f %f)
 scale(%f %f %f)
 light=%@
 camera=%@
 geometry=%@
 | no child
 | 1 child
 | %d children
filters.
-[SCNNode setValue:forUndefinedKey:]
_isFocusableOrHasFocusableChild
index < [self._particleSystems count]
system
postMorphingDeformers
postSkinningDeformers
constraints
physicsBody
physicsField
particleSystem
fixedBoundingBoxExtrema[0]
fixedBoundingBoxExtrema[1]
paused
focusBehavior
action-keys
actions
clientAttributes
failed to archive node's client attributes. %@ %@
movabilityHint
depthPrePass
-[SCNNode(SIMD) setSimdPivot:]
-[SCNNode(SIMD) setSimdTransform:]
-[SCNNode(SIMD) setSimdRotation:]
mode <= C3DWrapModeMirror
mode <= kC3DFilterModeLinear
type < kC3DImageCount
cull <= kC3DCullNone
fillMode == kC3DFillModeLines || fillMode == kC3DFillModeFill
blend < kC3DBlendFactorCount
blendOp < kC3DBlendOpCount
func < kC3DComparisonFuncCount
op < kC3DStencilOpCount
format < sizeof(__SCNMTLVertexFormatToC3DBaseTypeArray) / sizeof(__SCNMTLVertexFormatToC3DBaseTypeArray[0])
float2x2
float2x3
float2x4
float3x2
float3x4
float4x2
float4x3
half2x2
half2x3
half2x4
half3x2
half3x3
half3x4
half4x2
half4x3
half4x4
uint
uint2
uint3
uint4
bool2
bool3
bool4
A8Unorm
R8Sint
R8Snorm
R8Uint
R8Unorm
R8Unorm_sRGB
R16Float
R16Sint
R16Snorm
R16Uint
R16Unorm
R32Float
R32Sint
R32Uint
RG8Sint
RG8Snorm
RG8Uint
RG8Unorm
RG8Unorm_sRGB
RG16Float
RG16Sint
RG16Snorm
RG16Uint
RG16Unorm
RG32Float
RG32Sint
RG32Uint
BGR10_XR
BGR10_XR_sRGB
BGRA10_XR
BGRA10_XR_sRGB
BGR10A2Unorm
RGBA8Sint
RGBA8Snorm
RGBA8Uint
RGBA8Unorm
RGBA8Unorm_sRGB
RGB10A2Uint
RGB10A2Unorm
RGBA16Sint
RGBA16Snorm
RGBA16Uint
RGBA16Unorm
RGBA32Sint
RGBA32Uint
Depth16Unorm
Depth32Float
Stencil8
Depth24Unorm_Stencil8
Depth32Float_Stencil8
MTLPixelFormat
MTLStorageModeShared
MTLStorageModeManaged
MTLStorageModePrivate
MTLStorageModeMemoryless
Unkown
MTLCPUCacheModeDefaultCache
MTLCPUCacheModeWriteCombined
MTLTextureType1D
MTLTextureType1DArray
MTLTextureType2D
MTLTextureType2DArray
MTLTextureType2DMultisample
MTLTextureTypeCube
MTLTextureTypeCubeArray
MTLTextureType3D
MTLTextureType2DMultisampleArray
MTLTextureTypeTextureBuffer
shaderRead
shaderWrite
pixelFormatView
MTLTextureUsageShaderRead
MTLTextureUsageShaderWrite
MTLTextureUsageRenderTarget
MTLTextureUsagePixelFormatView
MTLTextureUsageUnknown
mtlBuffer
mtlVertexFormat
byteOrderDefault(Big)
byteOrder16Little
byteOrder32Little
byteOrder16Big
byteOrder32Big
byteOrderUnknown
alphaNone
alphaPremultipliedLast
alphaPremultipliedFirst
alphaLast
alphaFirst
alphaNoneSkipLast
alphaNoneSkipFirst
alphaOnly
alphaUnknown
kSceneStartTimeAttributeKey
kSceneEndTimeAttributeKey
kSceneFrameRateAttributeKey
kSceneUpAxisAttributeKey
scnz
com.apple.scenekit.scene
com.apple.scenekit.scene.zip
com.pixar.universal-scene-description-mobile
public.polygon-file-format
public.geometry-definition-format
public.standard-tesselated-geometry-format
com.pixar.universal-scene-description
%@_textures
%@_texture%d.png
B24@?0^@8@?<B@?@"NSURL"^@>16
B24@?0@"NSURL"8^@16
MDLAsset
sceneDump%d.scn
dumping scene to %@
children[
wr == 0
physicsWorld
userAttributes
sourceURL
SCNLayerTreeDidChange
C3DEngineContextGetRenderContext(engineContext)
-[SCNTextureOffscreenRenderingSource _buildMipmaps:]
SCNTextureSource.m
SKSCNRenderer
C3DBlendStates
renderTargetIndex < states->_targetCount
srcColor
(1 - srcColor)
srcAlpha
(1 - srcAlpha)
dstColor
(1 - dstColor)
dstAlpha
(1 - dstAlpha)
blendColor
(1 - blendColor)
blendAlpha
(1 - blendAlpha)
srcAlphaSat
<C3DBlendStates %p targetCount:%d needsBlendColor:%d
  blend:%s col[(src * %@) %@ (dst * %@)] alpha[(src * %@) %@ (dst * %@)]
  blend:%s col[(src * %@) %@ (dst * %@)]
bindingMode
bindingPointIndicesStride
bindingBarycentricCoordsStride
bindingPointIndicesFormat
bindingBarycentricCoordsFormat
bindingPointIndices
bindingBarycentricCoords
isLegacySingleLayerDeformer
bindingOffsetsOrTransforms
bindingOffsetsOrTransformsLength
bindingInnerLayerInfluences
bindingInnerLayerInfluencesLength
bindingInnerTNBs
bindingOuterTNBs
bindingSpaceVectorsLength
bindingInnerOffsets
bindingOuterOffsets
bindingOffsetsLength
-[SCNGeometryWrapDeformerParameters initWithCoder:]
SCNGeometryWrapDeformer.mm
decodedLength == bindingPointIndicesLength
decodedLength == bindingBarycentricCoordsLength
decodedLength == _bindingData.legacyOffsetsOrTransformsLength
decodedLength == _bindingData.innerLayerInfluencesLength
decodedLength == _bindingData.tnbMatricesLength
decodedLength == _bindingData.offsetsLength
driverTexcoordSource
deformedTexcoordSource
parameters
-[SCNGeometryWrapDeformerInstance initWithNode:drivingNode:deformer:outputs:computeVertexCount:context:]
parameters->_vertexCount == computeVertexCount
v24@?0@"<MTLFunction>"8@"MTLStageInputOutputDescriptor"16
deformer_wrap_legacy_absolute
deformer_wrap_legacy_relative
-[SCNGeometryWrapDeformerInstance initWithNode:innerLayerNode:outerLayerNode:deformer:outputs:computeVertexCount:context:]
deformer_wrap_absolute
deformer_wrap_relative
C3DCoreProfileVertexAttribDivisor
C3DGL_macOS_CoreProfile.c
C3DCoreProfileBlitFramebuffer
C3DCoreProfileBindVertexArray
C3DCoreProfileGenVertexArrays
C3DCoreProfileDeleteVertexArrays
C3DCoreProfileMapBufferRange
C3DCoreProfileFlushMappedBufferRange
C3DCoreProfileUnmapBufferRange
C3DCoreProfileSetPatchControlPointCount
DrawNodesPass
DrawNodeDefault
out0.attachmentType == TextureAttachmentType::Color || out0.attachmentType == TextureAttachmentType::Depth
_cullingContext.scene
visibleElements
*texcoord_io_index < kSCNTexcoordCount
normals
indexRedirection[index] <= index
index>0
indexes[index] < count - weldCount
offset == weldCount
elementDataWrt[index] < count - weldCount
((uint16_t*)elementDataWrt)[index] < count - weldCount
((uint32_t*)elementDataWrt)[index] < count - weldCount
SCNPreferredRenderingAPIKey
SCNPreferredDeviceKey
SCNPreferLowPowerDeviceKey
PrefersOpenGL
PrefersLowPowerGPU
com.apple.sceneKit.preferLowPowerDevice
com.apple.sceneKit.preferRemovableDevice
ibPreferredRenderingAPI
ibWantsMultisampling
temporalAntialiasingEnabled
allowsCameraControl
backgroundColor
ibSceneName
background.contents
kSCNViewObservingContext
com.apple.sceneKit.forceSeparateWorkGroup
SceneKit - SCNView Draw
SCNView::setAsynchronousLoading is deprecated
Can't set an OpenGL context on a Metal-based SCNView
antialiasingMode
NSScreenNumber
vehicle
wheelIndex
suspensionStiffness
suspensionCompression
suspensionDamping
maximumSuspensionTravel
frictionSlip
maximumSuspensionForce
connectionPosition
steeringAxis
axle
radius
suspensionRestLength
isFront
C3DCullingSystem
cullingSystem
handle >= 0 && ((uint32_t)handle < cullingSystem->_handles.size())
<C3DCullingSystem %p>
handle >= 0 && ((uint32_t)handle < _handles.size())
indexToRemove < _count
(start & kSOALaneMask) == 0
_currentPass->mainPassUsesSpecificClearColor(NULL)
MainPassCustomPostProcessPass
!line.empty()
IESNA:LM-63-1995
IESNA91
IESNA:LM-63-2002
TILT=NONE
TILT= NONE
TILT =NONE
TILT = NONE
TILT=
TILT =
anglesCount > 0
start != index
end != index - 1
x < anglesNumH
y < anglesNumV
width > 0 && height > 0
channelCount == 1 || channelCount == 4
channelSize == 1 || channelSize == 2 || channelSize == 4
C3DLegacyProfileVertexAttribDivisor
C3DGL_macOS_LegacyProfile.c
C3DLegacyProfileBlitFramebuffer
C3DLegacyProfileBindVertexArray
C3DLegacyProfileGenVertexArrays
C3DLegacyProfileDeleteVertexArrays
C3DLegacyProfileMapBufferRange
C3DLegacyProfileUnmapBufferRange
_lastRatio
_scaleTarget
_scaleTargetReversed
_deltaScale
_isReversed
uniform
#pragma opaque
#pragma transparent
#pragma declaration
#pragma arguments
#pragma varyings
#pragma body
scn_node
scn_frame
<null>
<%@ %@>
_duration
_timingMode
_beginTime
_pausedTime
_isRunning
_finished
SCNActionCacheKey
SCNRendererOffscreenSampleCount
transition pass
[privateRendererOwner isKindOfClass:[SCNView class]] || [privateRendererOwner isKindOfClass:[SCNLayer class]] || [privateRendererOwner isKindOfClass:[SCNMetalLayer class]]
com.apple.scenekit.renderingQueue.%@%p
[(id)context conformsToProtocol:@protocol(MTLDevice)]
<%@ %p: scene = %@, pointOfView = %@, sceneTime = %f, context = %p>
SceneKit - Delete Framebuffer
_renderingAPI == SCNRenderingAPIMetal
_shouldDeleteFramebuffer == NO
_isPrivateRenderer
SceneKit - Create Framebuffer
[pov isPresentationInstance] == 0
camera.xFov
camera.yFov
camera.fieldOfView
camera.orthographicScale
camera.lensShift
camera.postProjectionTransformTranslation
camera.postProjectionTransformScale
camera.
_recordWithoutExecute
_glContext!=NULL
com.apple.scenekit.prepareQueue.%@%p
SCNRenderer.m
We should have an engine context at this stage
No C Scene associated with %@
Metal implementation not done
SpriteKit - Draw Overlay
SceneKit - Flush
_isViewPrivateRenderer
-[SCNRenderer _drawSceneWithLegacyRenderer:]
[_renderContext isKindOfClass:[SCNMTLRenderContext class]]
self.scene
shBuffer.length == ((shOrder * shOrder) * 3 * sizeof(float))
SceneKit - Jitter
-[SCNRenderer _addGPUFrameScheduledHandler:]
-[SCNRenderer _addGPUFrameCompletedHandler:]
-[SCNRenderer _addGPUFramePresentedHandler:]
-[SCNRenderer _discardPendingGPUFrameScheduledHandlers]
-[SCNRenderer _discardPendingGPUFrameCompletedHandlers]
-[SCNRenderer _discardPendingGPUFramePresentedHandlers]
-[SCNRenderer _allowGPUBackgroundExecution]
info->frameBuffer == NULL
info->multisamplingFrameBuffer == NULL
vecSize.x > 0.0 && vecSize.y > 0.0
SCN_ENABLE_COLLECTION
scenekit.fps
scenekit.primcnt
scenekit.frmtime
scenekit.phytime
scenekit.prttime
scenekit.animtime
scenekit.clientTime
scenekit.consttime
scenekit.rendertime
scenekit.cpuidletime
scenekit.cawaittime
scenekit.deviceutil
scenekit.rendererutil
scenekit.tilerutil
IOAccelerator
PerformanceStatistics
__scnPerformanceData
v24@?0{_CSTypeRef=QQ}8
scenekit.shaderCompilationTime
scenekit.shaderGenerationCount
Device Utilization %
Renderer Utilization %
SceneKitShaderCache
com.apple.sceneKit.traceResources
containerPath
commonProfile_
metal
can't create symbolicator for pid
__scnDebuggingInfo
can't find symbol __scnDebuggingInfo
can't mmap memory for symbol __scnDebuggingInfo
can't get mem rangefor symbol __scnDebuggingInfo
failed to read memory for symbol __scnDebuggingInfo
applicationContainerPath not set
_buffer
<%@: %p> "%@"
<state: %@>
FrameBuffer bindings:
Node bindings:
Pass bindings:
Shadable bindings:
Light bindings:
stage < kC3DFXMetalProgramStageCount
_vertexDescriptor
<SCNMTLMesh: %p
buffer[%d] : %@
element[%d] : %@
<SCNMTLMeshElement: %p | type: %d, index buffer: %@ (%d indices), indirect buffer: %@, effective count: %d, offset: %d>
<SCNMTLMeshElement: %p | type: %d, index buffer: %@ (%d indices), effective count: %d, offset: %d>
axisA
axisB
anchorA
anchorB
minLinearLimit
maxLinearLimit
minAngularLimit
maxAngularLimit
motorTargetLinearVelocity
motorMaximumForce
motorTargetAngularVelocity
motorMaximumTorque
_posTarget.x
_posTarget.y
_posTarget.z
_posTargetReversed.x
_posTargetReversed.y
_posTargetReversed.z
_posStart.x
_posStart.y
_posStart.z
entityID
basic
keyframe
group
class
keyPath
animation-players
animation-keys
sourceObject
keyPathSrc
keyPathDst
bindings
/Contents/Resources/
imageNamed
imageNamed://
MDLSkyCubeTexture
imageNamed://%@
turbidity
sunElevation
upperAtmosphereScattering
groundAlbedo
horizonElevation
gamma
exposure
brightness
channelEncoding
dimensions.x
dimensions.y
highDynamicRangeCompression.x
highDynamicRangeCompression.y
groundColor
<%@: %p
    "%@" = "%@"
flatness
deformer_variabletopologysample_any_order
dataKind == kC3DMeshDataKindOriginal
C3DMeshElementGetType(meshElement) == kC3DMeshElementTypeTrianglesArray
deformer_variabletopologysample_any_order_finalize
UInt%d-UInt%d
v32@?0@"SCNGeometryVariableTopologySampleDeformerMeshElementData"8Q16^B24
Variable topology sample deformer
SCNAnimationCommitOnCompletion
SCN_CAKeyframeAnimation %p (duration=%f, keyPath:%@)
c3dAnimation
commitsOnCompletion
removedOnCompletion
CAKeyframeAnimation based on CGPath are not supported
CFTypeIsC3DEntity(rootCF)
SCNAnimationAnimatesUsingSceneTimeKey
SCNAnimationFadeInDurationKey
SCNAnimationFadeOutDurationKey
SCNAnimationEventsKey
c3dTimingFunction
_animationEvents == NULL
c3dAnimationType
applyOnCompletion
fillForward
fillBackward
userInfo
failed to archive animation's userinfo. %@ %@
appliedOnCompletion
scna
<%@: %p, keyPath=%@ duration=%f repeatCount=%f>
weight
<SCNAnimationPlayer(%p) animation=%@>
q24@?0@"SCNAnimationEvent"8@"SCNAnimationEvent"16
C3DDeformerStack
<C3DDeformerStack %p>
<C3DDeformerStack %p (geometry: %p)
  morpher: %p
  %@: %p
  skinner: %p
v40@?0Q8@"SCNNode"16Q24^B32
geometryMemory
textureMemory
SCNSceneSourceUseModelIOToLoadDAEFiles
kSceneSourceCacheScenesByURLKey
kSceneSourceSceneIndexKey
kSceneSourceForceMorphNormals
SCNSceneSourceLoadTexturesInCPUMemory
kSceneSourceFormat
SCNSceneSourceInputSource
SCNSceneExportDestinationURL
SCNSceneExportUTIKey
SCNSceneExportCompressGeometryElements
SCNSceneExportCompressMorphTargets
SCNSceneExportEmbedImages
SCNSceneExportEmbedReferences
SCNSceneExportPresentationTree
[SCNSceneSource scenesSourceWithURL:] nil URL
<%@: %p | URL='%@'>
The document "%@" could not be opened.
The document data could not be read.
v32@?0f8i12^{__CFError=}16^B24
v36@?0f8q12@"NSError"20^B28
@16@?0^v8
bplist
VertexCache
C3DMeshElement_Tools.cpp
cacheSize < kMaxCacheSize
textureCoordinate is deprecated - use textureCoordinateWithMappingChannel instead
<%@: %p <%f,%f,%f> | geometryIndex=%d node=%@ bone=%@>
invalid wrapS value: %d
invalid wrapT value: %d
_contentType != SCNContentTypeLayer && _contentType != SCNContentTypeSKScene
SKScene
SKTexture
GLKTextureInfo
AVPlayer
AVCaptureDevice
-[SCNMaterialProperty setContentsTransform:]
<%@: %p | contents=%@>
<data %p>
parent == _parent
attachment == NULL || [(id) attachment isKindOfClass:[SCNMaterialAttachment class]]
imageArray
skscene
sktexture
textureComponents
attachment
isCommonProfileProperty
propertyType
customSlotName
sRGB
.<>?:/|&^*/+-=%!~
String
a_vertexColor
a_TexTangent
a_diffuseTexcoord
a_ambientTexcoord
a_specularTexcoord
a_emissionTexcoord
a_filterTexcoord
a_transparentTexcoord
a_normalTexcoord
a_lightmapTexcoord
u_cameraPosition
u_nodeOpacity
u_skinningJointMatrices
u_materialShininess
u_ambientColor
u_ambientIntensity
u_ambientTexture
u_ambientTextureMatrix
u_diffuseColor
u_diffuseIntensity
u_diffuseTexture
u_diffuseTextureMatrix
u_specularColor
u_specularIntensity
u_specularTexture
u_specularTextureMatrix
u_emissionColor
u_emissionIntensity
u_emissionTexture
u_emissionTextureMatrix
u_multiplyColor
u_multiplyIntensity
u_multiplyTexture
u_multiplyTextureMatrix
u_transparency
u_transparentColor
u_transparentIntensity
u_transparentTexture
u_transparentTextureMatrix
u_normalTexture
u_normalIntensity
u_normalTextureMatrix
u_shininessTexture
u_shininessTextureMatrix
u_lightmapTexture
u_reflectiveColor
u_reflectiveIntensity
u_reflectiveTexture
u_reflectiveTextureMatrix
u_fresnel
u_ambientLightColor
u_shCoefficients
u_fogColor
u_fogParameters
u_light%d_attenuation
u_light%d_spotAttenuation
u_light%d_color
u_light%d_position
u_light%d_direction
u_light%d_up
u_light%d_right
u_light%d_gobo
u_light%d_goboMatrix
u_light%d_goboIntensity
u_light%d_iesMatrix
u_light%d_iesTex
u_light%d_shadow
u_light%d_shadowMatrix
u_light%d_shadowRadius
u_light%d_shadowColor
u_zRange
u_orientationPreserved
C3DLibrarySubStorage
uniqueID
documentIDRef
documentID
<C3DLibrarySubStorage>
C3DLibrary
<C3DLibrary>
object == lib
library->_storage
entryToSerializedData
lib->_entries
C3DParticleManager
ParticleSystem_MeshElement
C3D-ParticleSystem_Trail
C3D-ParticleSystem
C3D-ParticleSystem_PointSprite
%@%1d%1d%c%c%c%c%c%c%c%c%c%c%c%1dO%1d%c%c
enableLighting
enableColorRamp
enableCubeMap
enableStretch
enableAnimation
enableFog
enableMultipleViewport
enableLayeredRendering
useVertexAmplification
eyeCount
ARMode
animationMode
uberparticle_stereo_vert
uberparticle_vert
uberparticleCube_frag
uberparticle_frag
.vsh
.fsh
#define mediump 
#define ENABLE_LIGHTING
#define ENABLE_COLOR_RAMP
#define ENABLE_CUBE_MAP
#define ENABLE_STRETCH
#define ENABLE_BILLBOARD_VIEW
#define ENABLE_ORIENTATION_FREE
#define ENABLE_BILLBOARD_Y
#define ENABLE_BILLBOARD_SCREEN
#define ENABLE_FOG
#define ENABLE_ANIMATION %d
#define ENABLE_SOFT
BlackPass
viewTransform
u_viewToCubeWorld
u_fresnelExponent
u_lightPosition0
u_lightColor0
u_colorRamp
u_stretchFactor
u_frameSize
u_softParameters
u_invProj
u_depthSampler0
u_projectionTransform
u_textureSampler0
<C3DParticleManagerRef>
cullingContext
CFGetTypeID(instance) == C3DParticleSystemInstanceGetTypeID()
pass
index < technique->_count
symbolName
technique->_parameterStorage == NULL || technique->_parameterStorage->storage == NULL
CFDictionaryGetValue(technique->_parameterStorage->parameters, symbolName) == 0
paramName
count == 1
technique->_isCompiled==false
bundle
metalLibraryName
sequence
passes
symbols
metalLibraryFile
metalVertexShader
metalFragmentShader
clientProgram
inputs
owners
outputs
subtechnique
C3DFXDefault_velocity.plist
C3DFXDefaultPass.plist
C3DFXTechnique
<C3DFXTechnique>
pass %d
plist
targets
sourcePass->_inputCount == dstPass->_inputCount
!dstPass->_customInitializeBlock
!dstPass->_customExecuteBlock
self
kPrimitiveGenerateMappingCoordinates
kPrimitiveVertexTransformation
kPrimitiveWidthSegments
kPrimitiveHeightSegments
kPrimitiveLengthSegments
kPrimitiveChamferSegments
kPrimitiveRotationSegments
kPrimitiveCapSegments
kPrimitiveRingSegments
kPrimitivePipeSegments
kPrimitiveSphereType
kPrimitiveSphereSegments
kPrimitiveTypeSphere
kPrimitiveTypeGeosphere
widthSegmentCount
heightSegmentCount
lengthSegmentCount
chamferSegmentCount
segmentCount
radialSegmentCount
ringSegmentCount
pipeSegmentCount
-[SCNFloor setReflectionResolutionScaleFactor:]
-[SCNFloor setReflectionCategoryBitMask:]
-[SCNFloor setWidth:]
-[SCNFloor setLength:]
-[SCNFloor setReflectionFalloffEnd:]
reflectionFalloffEnd
-[SCNFloor setReflectionFalloffStart:]
reflectionFalloffStart
-[SCNFloor setReflectionSampleCount:]
-[SCNFloor setReflectivity:]
reflectionCategoryBitMask
reflectionResolutionScaleFactor
include
C3DTokenizer.hpp
mpSource
C3DFloor
<C3DFloor>
_C3DFloorInitWithPropertyList
resolutionScaleFactor
reflectionBitMask
indicesCount >= 3
vertexIndex < originalVertexCount
perVertexTriangleCount[vertexIndex] > 0
perVertexTriangleCount[weldedVertexIndex] == 0
unify_u16
unify_u32
v32@?0@"SCNPhysicsVehicleWheel"8Q16^B24
wheel
chassisBody
wheels
-[SCNGeometry setName:]
%@: %p '%@'
%@: %p
 | %d elements
<%@>
geometrySourceForSemantic is deprecated - use geometrySourcesForSemantic instead
-[SCNGeometry setBoundingBoxMin:max:]
index < [_materials count]
materials[
q24@?0@8@16
-[SCNGeometry _shadableSetValue:forUndefinedKey:]
-[SCNGeometry setShaderModifiers:]
-[SCNGeometry copyShaderModifiersAndLanguageVersionFrom:]
-[SCNGeometry setMinimumLanguageVersion:]
-[SCNGeometry setProgram:]
subdivisionLevel
wantsAdaptiveSubdivision
edgeCreasesSource
edgeCreasesElement
subdivisionSettings
tessellator
SCNErrorDomain
v16@?0@"NSTimer"8
C3DMeshElementTypeDefinesTopology(meshType)
_layerRoot
_overlayLayerRoot
_lightRoot
_cameraRoot
_particlesRoot
_physicsFieldRoot
_pointsOfViewRoot
Perspective
Bottom
Left
Right
Front
Back
_authoringCamera%s
lightAuth
particlesAuth
cameraAuth
cameraFrustumAuth
cameraNearPlaneAuth
fieldAuth
SCNDebugLightTypeKey
SCNDebugLightSubTypeKey
lightInnerAuth
lightOuterAuth
lightArrowAuth
lightShadowAuth
lightSpotAuth
probeGeometry
lightProbeExtents
scn_probesphere_from_sh_vertex
scn_probesphere_from_sh_fragment
v40@?0@"<SCNBufferStream>"8@"SCNNode"16@"<SCNShadable>"24@"SCNRenderer"32
lightAreaAuth
disabled
oa:%f ia:%f s:%f e:%f
AuthEnvHash
sourceShape
metallib
com.apple.scenekit.device
scenekit
Q8@?0
@"<MTLLibrary>"8@?0
com.apple.scenekit.shader-collection-queue
commonProfile_%@.metal
v16@?0@"NSString"8
v24@?0@"NSString"8@"NSString"16
v24@?0@"NSString"8^B16
v24@?0@"<MTLLibrary>"8@"NSError"16
^(.*)$
program_source:([0-9]+):[0-9]+:\s(.+):\s(.+)$
^<program source>:([0-9]+):[0-9]+:\s(.+):\s(.+)$
\[SCN_(\w+)\((\d+)\)\]
Geometry
Surface
Fragment
LightingModel
texture1D
texture2D
textureCube
texture3D
SCNShaderLightDecl.glsl
float __shadow2DProj(sampler2DShadow tex, vec4 coord) {return textureProj( tex, coord );}
float __shadow2DProj(sampler2DShadow tex, vec4 coord) {return shadow2DProj( tex, coord ).x;}
uniform vec4 u_shadowKernel[%d];
SCNShaderSurfaceDecl.glsl
USE_EMISSION_AS_SELFILLUMINATION
    vec2 %@Texcoord;
    _surface.%@Texcoord = v_texcoord%d;
} _surface;
varying vec2 v_texcoord%d;
uniform mat4 u_%@TextureMatrix;
v_texcoord%d = (u_%@TextureMatrix * vec4(_geometry.texcoords[%d], 0., 1.)).xy;
v_texcoord%d = _geometry.texcoords[%d];
NEED_IN_TEXCOORD%d
C3D-UberShader.vsh
SCNShaderGeometryDecl.glsl
struct SCNShaderLightingContribution {vec3 ambient; vec3 diffuse; vec3 specular; vec3 modulate;} _lightingContribution;
u_modelViewTransform
SEPARATE_PROJECTION
u_normalTransform
__DoTexcoord__
#define kSCNTexcoordCount %ld
MAX_BONE_INFLUENCES
__DoLighting__
varying
C3D-UberShader.fsh
u_light%hu
    SCNShaderLight _light;
    _light.intensity = vec4(1.);
uniform vec4 %@_color;
    _light.intensity = %@_color;
uniform vec4 %@_direction;
    _light.direction = %@_direction.xyz;
uniform vec4 %@_position;
    vec3 _D = %@_position.xyz - _surface.position;
    _light.dist = length(_D);
    _light.direction = _D / _light.dist;
    _light.direction = normalize(%@_position.xyz - _surface.position);
    _light.dir = %@_direction.xyz;
//Unsupported
    _light._att = 1.;
uniform vec4 %@_attenuation;
    vec3 _att = %@_attenuation.xyz;
    _light._att *= step(_light.dist, _att.x);
    _light._att *= clamp(_light.dist * _att.x + _att.y, 0.0, 1.0);
    float _dstatt = clamp(_light.dist * _att.x + _att.y, 0.0, 1.0);
    _light._att *= (_dstatt  * _dstatt);
    _light._att *= pow(clamp(_light.dist * _att.x + _att.y, 0.0, 1.0), _att.z);
uniform vec4 %@_spotAttenuation;
    vec3 _spot = %@_spotAttenuation.xyz;
    _light._att *= step(_spot.x, dot(_light.direction, _light.dir));
    _light._att *= clamp(dot(_light.direction, _light.dir) * _spot.x + _spot.y, 0.0, 1.0);
    float _sptatt = clamp(dot(_light.direction, _light.dir) * _spot.x + _spot.y, 0.0, 1.0);
    _light._att *= _sptatt * _sptatt;
    _light._att *= pow(clamp(dot(_light.direction, _light.dir) * _spot.x + _spot.y, 0.0, 1.0), _spot.z);
uniform sampler2DShadow %@_shadow;
uniform mat4 %@_shadowMatrix;
uniform float %@_shadowRadius;
    float _shadowingTerm = 0.0;
    vec4 _lightScreen = (%@_shadowMatrix * vec4(_surface.position, 1.));
    float _filteringSizeFactor = %@_shadowRadius * _lightScreen.w;
    for(int i=0; i < %d; i++){
        _shadowingTerm += __shadow2DProj(%@_shadow, _lightScreen + (u_shadowKernel[i] * _filteringSizeFactor));
    }
    _shadowingTerm /= float(%d);
    float _shadowingTerm = __shadow2DProj(%@_shadow, (%@_shadowMatrix * vec4(_surface.position, 1.)));
uniform vec4 %@_shadowColor;
    _light._att *= (1. - _shadowingTerm * %@_shadowColor.a);
    _light._att *= (1. - _shadowingTerm);
uniform sampler2D %@_gobo;
uniform mat4 %@_goboMatrix;
uniform float %@_goboIntensity;
    _light.intensity *= mix(vec4(1.), texture2DProj(%@_gobo, (%@_goboMatrix * vec4(_surface.position, 1.))), %@_goboIntensity);
    _light.intensity *= %@_goboIntensity * texture2DProj(%@_gobo, (%@_goboMatrix * vec4(_surface.position, 1.)));
modCode
    _lightingContribution.modulate *= _light._att * _light.intensity.rgb;
    _light.intensity.rgb *= _light._att * max(0.0, dot(_surface.normal, _light.direction));
    _lightingContribution.diffuse += _light.intensity.rgb;
    vec3 _R = reflect(-_light.direction, _surface.normal);
    _lightingContribution.specular += pow(max(0.0, dot(_R, _surface.view)), _surface.shininess) * _light.intensity.rgb;
    vec3 _halfVector = normalize(_light.direction + _surface.view);
    _lightingContribution.specular += pow(max(0.0, dot(_surface.normal, _halfVector)), _surface.shininess) * _light.intensity.rgb;
  vec4 %@;
uniform %@ %@;
skinnedMesh
C3DMeshGetSourceWithSemanticAtIndex(skinnedMesh, kC3DMeshSourceSemanticSkinningJoints, 0, kC3DMeshDataKindRenderable)
C3DMeshGetSourceWithSemanticAtIndex(skinnedMesh, kC3DMeshSourceSemanticSkinningWeights, 0, kC3DMeshDataKindRenderable)
joint
needPrepare == false
skinner->_meshIsCPUReady
C3DMeshSourceIsMutable(C3DMeshGetPositionSource(skinnedMesh, kC3DMeshDataKindRenderable))
!C3DMeshGetNormalSource(skinnedMesh, kC3DMeshDataKindRenderable) || C3DMeshSourceIsMutable(C3DMeshGetNormalSource(skinnedMesh, kC3DMeshDataKindRenderable))
calculationMode == kC3DSkinnerCalculationModeGPUComputeKernel || skinner->_meshIsGPUVertexReady
currentPositionSource && currentPositionSource != originalPositionSource
C3DMeshSourceIsMutable(currentPositionSource)
currentNormalSource != originalNormalSource
C3DMeshSourceIsMutable(currentNormalSource)
Loose
_DYN
ownerNode
%@ - Skinned
C3DSkinner
<C3DSkinner %p skeleton:%p jointCount:%d cpuReady:%d gpuReady:%d
  skin:%p skinnedMesh:%p calcMode:%d
  JointBbox[%d] {%f,%f,%f} {%f,%f,%f}
skeletonID
skinID
skeleton
meshCreated
bboxDirty
verticesJointsMatrices[%d]
normalsJointsMatrices[%d]
MBFinalBlurPass
VELOCITY
MB-TileMax
scn_draw_fullscreen_triangle_VR_pos_uv_uvNorm_vertex
scn_motionblur_blur
scn_motionblur_blur_resize
SCNMaterialPropertyTextureProviderHelper could not find texture for %@
scnComputeEncoder->isEncoding()
v16@?0@?<v@?@"<MTLComputeCommandEncoder>">8
scnBlitEncoder->isEncoding()
v16@?0@?<v@?@"<MTLBlitCommandEncoder>">8
v16@?0@?<v@?@"<MTLCommandBuffer>">8
SSAOUpSamplePass
scn_ssao_upsampling
_hide
CIFilterPass
outputTex
CIFilterDrawNodesPass
_allocator
sequence->count + count <= sequence->allocatedCount
skinCompressedData.count == 1
r <= C3DSkinGetWeightsCount(skin)
w == numberOfInfluence * vertexCount
baseGeometry
baseGeometryBindTransform
bones
compressedSkinData
boneWeights
boneIndices
baseGeometryBindTransform-%d
 %f %f %f %f
skin->_inverseBindMatrices
count == dstJoints.count && (!dstWeights.ptr || (count == dstWeights.count))
C3DSkinFillJointWeightsBuffers
C3DSkin
<C3DSkin %p name:%@ joint:%d weight:%d vertexCount:%d
  maxInf:%d morpher:%p
defaultShapeMatrix
inverseBindMatrix
_C3DSkinInitWithPropertyList
jointsCount
maxInfluences
inverseBindMatrices
defaultShapeMatrix
baseMeshID
weightsCount
vertexWeightIndices
jointsForVertexWeights
vertexWeights
maxInfluencesPerVertex
influencingMorpher
vertexWeightIndices[%d]
vertexWeights[%d]
jointsForVertexWeights[%d]
C3DIONSZipFileArchiveHeaderOffset
C3DIONSZipFileArchiveCompressionType
C3DIONSZipFileArchiveCRC
C3DIONSZipFileArchiveCompressedLength
C3DIONSZipFileArchiveUncompressedLength
1.2.12
C3DFXFloorPass.plist
SceneKit_renderMirroredScene
SceneKit_renderFloor
u_floorReflectionColor
SceneKit-floor-color-%p
u_floorReflectionDepth
SceneKit-floor-depth-%p
u_floorNormal
u_floorTangent
u_floorCenter
u_floorExtent
u_floor_viewport
u_floorReflectivity
u_floorFalloffStart
u_floorFalloff
u_floorPlane
u_floorMVP_i
d > 0
FloorGeomImpl.glsl
FloorGeomImpl-metal.h
USE_FALLOFF
USE_FALLOFF_START
FloorImpl.glsl
FloorImpl-metal.h
_C3DSourceAccessorInitWithPropertyList
accessor->_source->_dataIsVolatile
C3DSourceAccessor
<C3DSourceAccessor %lx>
componentsCountPerValue
__allocateChunk
C3DStackAllocator.cpp
chunk
chunk->data
C3DStackAllocator
allocator->_framesCount > 0
C3DStackAllocatorAllocateAligned
allocator->_currentChunck
<C3DStackAllocator>
SSAOBlurPass-Y
SSAOBlurPass-X
scn_ssao_blur_y
scn_ssao_blur_x
<C3DGenericSource %lx>
_C3DGenericSourceInitWithPropertyList
(numberType == kCFNumberFloatType) || (numberType == kCFNumberFloat32Type)
!genericSource->_dataIsVolatile
genericSource->_mtlVertexFormat == 0
genericSource->_dataIsVolatile
C3DSourceAccessorGetSource(accessor) == (C3DGenericSourceRef) genericsource
listener
C3DGenericSource
SCNMaterialData
debug_frag
debug_vert
debug_post_tessellation_vert
debug_isolate_frag
v32@?0@8@"NSMapTable"16^B24
C3DMeshSourceIsVolatile(meshSource) != true
attribute != kC3DVertexAttrib_None
[metalMesh.buffers indexOfObject:buf] != NSNotFound
dataSize == buf.length
textureMatrix
Unable to find texture for binding %@ ("%@") and effect slot %@ derived from value %@ (geometry=%@, material=%@)
v32@?0@8@"SCNMTLDeformerStack"16^B24
DeferredShadowPass
SceneKit-spotShadowDepth-
enableARMode
deferredShadow_VR_vert
caff
aiff
volume
rate
reverbBlend
positional
shouldStream
C3DResourceCache
resourceCache
cache
resource
<C3DResourceCache 0x%lx>
AnimationGroup
C3DAnimationGroup
<C3DAnimationGroup %p animations:%@>
channels
targetPath
subAnimations
 point(%f %f %f)
 normal(%f %f %f)
 impulse(%f)
 distance:%f
!_node || _body == 0
mass
charge
friction
restitution
rollingFriction
ccdThreshold
physicsShape
damping
angularVelocity
angularDamping
linearRestingThreshold
angularRestingThreshold
velocityFactor
angularVelocityFactor
velocity
ignoreGravity
explicitMomentOfInertia
momentOfInertia
centerOfMassOffset
contactTestBitMask
allowsResting
isDefaultShape
linearSleepingThreshold
angularSleepingThreshold
v40@?0q8q16q24q32
v24@?0d8f16f20
v28@?0f8f12f16f20f24
-[SCNPlane setCornerRadius:]
cornerRadius
-[SCNPlane setCornerSegmentCount:]
cornerSegmentCount
-[SCNPlane setHeight:]
-[SCNPlane setHeightSegmentCount:]
-[SCNPlane setPrimitiveType:]
-[SCNPlane setWidth:]
-[SCNPlane setWidthSegmentCount:]
<%@ | width=%.3f height=%.3f>
primitiveType
-[SCNBox setChamferRadius:]
chamferRadius
-[SCNBox setChamferSegmentCount:]
-[SCNBox setHeight:]
-[SCNBox setHeightSegmentCount:]
-[SCNBox setLength:]
-[SCNBox setLengthSegmentCount:]
-[SCNBox setPrimitiveType:]
-[SCNBox setWidth:]
-[SCNBox setWidthSegmentCount:]
<%@ | width=%.3f height=%.3f length=%.3f chamferRadius=%.3f>
boxwidth
boxheight
boxlength
boxchamferRadius
boxwidthSegmentCount
boxheightSegmentCount
boxlengthSegmentCount
boxchamferSegmentCount
boxprimitiveType
-[SCNPyramid setHeight:]
-[SCNPyramid setHeightSegmentCount:]
-[SCNPyramid setLength:]
-[SCNPyramid setLengthSegmentCount:]
-[SCNPyramid setPrimitiveType:]
-[SCNPyramid setWidth:]
-[SCNPyramid setWidthSegmentCount:]
<%@ | width=%.3f height=%.3f length=%.3f>
pyramidwidth
pyramidheight
pyramidlength
pyramidwidthSegmentCount
pyramidheightSegmentCount
pyramidlengthSegmentCount
pyramidprimitiveType
-[SCNSphere setGeodesic:]
-[SCNSphere setHemispheric:]
-[SCNSphere setPrimitiveType:]
-[SCNSphere setRadialSpan:]
radialSpan
-[SCNSphere setRadius:]
-[SCNSphere setSegmentCount:]
<%@ | radius=%.3f>
sphereradius
sphereradialSpan
spheresegmentCount
sphereprimitiveType
spheregeodesic
spherehemispheric
-[SCNCylinder setHeight:]
-[SCNCylinder setHeightSegmentCount:]
-[SCNCylinder setPrimitiveType:]
-[SCNCylinder setRadialSegmentCount:]
-[SCNCylinder setRadialSpan:]
-[SCNCylinder setRadius:]
<%@ | radius=%.3f height=%.3f>
cylinderradius
cylinderheight
cylinderradialSpan
cylinderheightSegmentCount
cylinderradialSegmentCount
cylinderprimitiveType
-[SCNCone setBottomRadius:]
bottomRadius
-[SCNCone setHeight:]
-[SCNCone setHeightSegmentCount:]
-[SCNCone setPrimitiveType:]
-[SCNCone setRadialSegmentCount:]
-[SCNCone setTopRadius:]
topRadius
<%@ | topRadius=%.3f bottomRadius=%.3f height=%.3f>
conetopRadius
conebottomRadius
coneheight
coneheightSegmentCount
coneradialSegmentCount
coneprimitiveType
-[SCNTube setHeight:]
-[SCNTube setHeightSegmentCount:]
-[SCNTube setInnerRadius:]
innerRadius
-[SCNTube setOuterRadius:]
outerRadius
-[SCNTube setPrimitiveType:]
-[SCNTube setRadialSegmentCount:]
-[SCNTube setRadialSpan:]
<%@ | innerRadius=%.3f outerRadius=%.3f height=%.3f>
tubeinnerRadius
tubeouterRadius
tubeheight
tuberadialSpan
tubeheightSegmentCount
tuberadialSegmentCount
tubeprimitiveType
-[SCNCapsule setCapRadius:]
capRadius
-[SCNCapsule setCapSegmentCount:]
capSegmentCount
-[SCNCapsule setHeight:]
-[SCNCapsule setHeightSegmentCount:]
-[SCNCapsule setPrimitiveType:]
-[SCNCapsule setRadialSegmentCount:]
<%@ | capRadius=%.3f height=%.3f>
capsulecapRadius
capsuleheight
capsuleheightSegmentCount
capsuleradialSegmentCount
capsulecapSegmentCount
capsuleprimitiveType
-[SCNTorus setPipeRadius:]
pipeRadius
-[SCNTorus setPipeSegmentCount:]
-[SCNTorus setPrimitiveType:]
-[SCNTorus setRadialSpan:]
-[SCNTorus setRingRadius:]
ringRadius
-[SCNTorus setRingSegmentCount:]
<%@ | ringRadius=%.3f pipeRadius=%.3f>
torusringRadius
toruspipeRadius
torusradialSpan
torusringSegmentCount
toruspipeSegmentCount
torusprimitiveType
C3DAvoidOccluderConstraintDelegate
objcConstraint
delegate
<C3DAvoidOccluderConstraintDelegate %p>
stats
srcStats && dstStats
_axisRot
_rotX
_rotY
_rotZ
_lastRotX
_lastRotY
_lastRotZ
_isAxisAngle
_isUnitArc
_qRot
SCNSceneGraphSelectedNodeDidChange
SCNKitSceneGraphView
can't load nib named : SCNKitSceneGraphView
Visibility
Bbox
local:%@ (valid:%d)
<inf. box>
<%.2f,%.2f,%.2f %.2f,%.2f,%.2f>
%@-node
[%@]-node
(N/A)
%p %@
OverlayPass
compute_sh%d_from_cubemap_threadgroup_mem
compute_sh%d_from_cubemap
sum_sh%d
-[NSData(SCNExtensions) scn_indexedDataEncodingHighWatermarkWithBytesPerIndex:]
NSData+SCNExtensions.m
-[NSData(SCNExtensions) scn_indexedDataDecodingHighWatermarkWithBytesPerIndex:]
-[NSData(SCNExtensions) scn_indexedDataEncodingDeltaWithBytesPerIndex:]
-[NSData(SCNExtensions) scn_indexedDataDecodingDeltaWithBytesPerIndex:]
Allocate
C3DScratchAllocator.cpp
last_chunk
VMAllocateChunk
!chunk->next
Cube
Equirectangular
DualParaboloid
ConvertCubePass-%sTo%s
scn_draw_fullscreen_cube
scn_draw_fullscreen_cube_no_base
scn_draw_fullscreen_cube_layered
cube
equi
dual
scn_convert_%s_from_%s_frag
SCNPhysicsShapeTypeKey
SCNPhysicsShapeKeepAsCompoundKey
SCNPhysicsShapeScaleKey
SCNPhysicsShapeCollisionMarginKey
convexHull
concaveMesh
v32@?0@"SCNPhysicsShape"8Q16^B24
convexDecomposition
transformsCount
transform%d
referenceObject
options
physicsShape[%f,%f,%f]
btTriangleInfoData
btTriangleInfoMapData
SCNDefaultPhysicsShape
hasMesh == (hash != NULL)
parametricgeometry
parametricGeometry
retainCount>0
_C3DParametricGeometryCreateCacheHash_not_thread_safe
C3DParametricGeometry.c
size <= sizeof(C3DParametricGeometryType) + sizeof(C3DParametricGeometryParameters)
C3DParametricGeometry
Pyramid
Cylinder
Cone
Tube
Capsule
Torus
Sphere
Plane
<%@<%@>:%p "%@"
callBacks
retainCount != 0
CompositeARPass
renderWithViewpoints
shouldDelegateARCompositing
scn_postprocess_AR_vertex
scn_postprocess_AR_fragment
C3DDynamicBatchingSystem
dynamicBatchingSystem->_currentBatchInstancesCount == 0
<C3DDynamicBatchingSystem %p>
ScenePass
previousFilterPass
topLevelFilterNode->_hasFilter
!empty()
_bindInput
C3DGLSLProfileInterpreter.c
C3DGLSLGetUniformType
C3DGL.c
mat3
localHash.vertexDescriptorHash
v16@?0@"<MTLFunction>"8
scn_is_inside_bezier_curve
renderPipeline
v24@?0@"<MTLRenderPipelineState>"8@"NSError"16
v32@?0@"<MTLRenderPipelineState>"8@"MTLRenderPipelineReflection"16@"NSError"24
constants == nil || constantsHash != nil
stageDescriptor
needsInputTRC
needsColorMatrix
needsOutputTRC
inputTRC_type
inputTRC_gamma
inputTRC_a
inputTRC_b
inputTRC_c
inputTRC_d
inputTRC_e
inputTRC_f
colorMatrixColumn0
colorMatrixColumn1
colorMatrixColumn2
outputTRC_type
outputTRC_gamma
outputTRC_a
outputTRC_b
outputTRC_c
outputTRC_d
outputTRC_e
outputTRC_f
biPlanarTextureChromaSubsampling
biPlanarTextureYCbCrMatrix
color_matching_kernel_biplanar
color_matching_kernel
vec2(
vec3(
vec4(
type == C3DValueGetType(b)
type == C3DValueGetType(output)
C3DValue
<C3DValue %p - %@ ptr:%p >
!(xSize & (xSize-1))
!(ySize & (ySize-1))
hdr.dwFlags & DDSD_PITCH
hdr.sPixelFormat.dwRGBBitCount == 8
size == xSize * ySize * ddsInfo->_blockBytes
TemporalAA
temporal_aa
arrangedObjects
arrangedObjects.SCNUI_name
insertObject:in%@AtIndex:
removeObjectFrom%@AtIndex:
objectIn%@AtIndex:
object of class %@ doesn't implement %@
SCNUIArrayInspector
%.2f
tessellationFactorScale
maximumEdgeLength
edgeTessellationFactor
insideTessellationFactor
adaptive
screenSpace
tessellationPartitionMode
smoothingMode
<%@: %p, screen space (maximum edge length: %.3f px)>
<%@: %p, local space (maximum edge length: %.3f)>
<%@: %p, uniform (inside: %.3f, edge: %.3f)>
C3DFXSampler
<C3DFXSampler>
preferredExtensions
/System
B24@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}8^B16
nodeFromflattenedMesh
0.10
0.11
kEnclosingFolderURL
kSceneSourceInputLibrary
kC3DIOSerializationExportDelegate
kCreatePropertyListShouldZipOption
kCreatePropertyListShouldKeepReferencesToFilesOption
readerMinimumRequiredVersion
Could not get the data for the serialized property list
Could not zip the serialized property list
zippedData
zipped
meter
kIDKey
kNameKey
C3DEntityInitWithPropertyList
entity-name
entity-ID
_kvc
_cfTypeRegistry == NULL
action
propertyName
C3DEntity
<C3DEntity:%p>
CFGetRetainCount(dict) >= 2
MBTileMaxPass
scn_motionblur_tilemax
C3DEngineNotificationQueue
notificationQueue
queue
<C3DEngineNotificationQueue %p>
_fxPass
CustomPass
C3D-DefaultProgram
CFGetTypeID(program) == C3DFXGLSLProgramGetTypeID()
uniformName
channelIndex < 8
C3DFXGLSLProgram
<C3DFXGLSLProgram %p>
vertexShader
tessellationControlShader
tessellationEvaluationShader
geometryShader
fragmentShader
attributeNamesToIndexes
uniformNamesToIndexes
C3DLightGetCastsShadow(light)
ShadowMapPass
astc
cube_blur_h%d
cube_blur_v%d
CubeBlurPass
SSAOMinMaxOffsetPass
scn_ssao_downsample
channels[i] == channels[0]
C3DMeshGetElementsCount(targetMesh) == 1
morph->_calculationMode == kC3DMorpherCalculationModeAdditive
C3DMorph
<C3DMorph %p "%@"
  calc:%d morphNrm:%d targets:%ld
[%ld] weight:%f %@
_C3DMorphInitWithPropertyList
morphingType
weightsID
targetIDs
weightsData
<unnamed %d>
overallRuntimeTargetIndex == totalMorphTargetCount
dst.componentType == kC3DBaseTypeFloat
C3D-GaussianBlur
#define unshareIndex %d
#define MAX_SAMPLE %d
#define COMPONENT %c
GaussianBlur_vert
GaussianBlur_frag
C3D-blur-radiusH
C3D-blur-radiusV
C3D-blur-offsets
C3D-blur-weights
C3D-blur-samples
_C3DMorpherPrepareMorphedMesh
C3DMorpher
<C3DMorpher %p baseGeom:%p morphedMesh:%p state:%d
  morph:%@
morphID
C3DFXContext
fxContext
fxContext->_currentPassIndex<fxContext->_renderPassCount
technique->_isBeingRendered==false
pass->_drawInstruction != kC3DFXDrawScene
renderContext || rendererContextGL
<C3DFXContext>
%d - %@
 (resolve)
 (%dx)
__C3DEngineContextRenderPassInstance
C3DFXContext.m
rendererContextGL
NoName
fbo == NULL
u_inverseResolution
u_time
C3DFXContextBindFramebufferForPass
rendererGL
store
authoring-overlay
fxContext->_currentColorTarget->_referenceCount>0
fxContext->_currentDepthTarget->_referenceCount>0
enabled
!_node || _field == 0
halfExtent
strength
minimumDistance
active
scope
usesEllipsoidalExtent
exclusive
direction
smoothness
animationSpeed
SceneKit: C3DProgressDebugger fractionCompleted > 1.0
progress == nil || (progress == [NSProgress currentProgress])
progress.fractionCompleted <= 1.0
completedUnits <= units
fractionCompleted
PreFiltered Radiance
failed to load technique from dictionary: %@
-[SCNTechnique setValue:forSymbolNamed:]
valueForSymbol
C3DRendererDelegate
render
<C3DRendererDelegate %p>
C3DNotificationCenter
<C3DNotificationCenter %p>
-[SCNMorpher setName:]
<SCNMorpher %p>
weights[%d]
-[SCNMorpher setWeight:forTargetAtIndex:]
oldTargetsAndInBetweens.count == targetsAndInBetweens.count
_correctivesAndInBetweens.count == correctivesAndInBetweens.count
inBetweenIndex < targetsAndInBetweens.count
inBetweenWeights.count == inBetweenCountValidation
q24@?0@"NSNumber"8@"NSNumber"16
-[SCNMorpher setCalculationMode:]
v32@?0^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}8^{__C3DMeshSource=}16^{__C3DMeshSource=}24
weights[
-[SCNMorpher setValue:forUndefinedKey:]
weightID
useSparseTargets
inBetweenCounts
inBetweenInfluenceWeights
correctives
correctiveDriverCounts
correctiveDriverIndices
correctiveInBetweenCounts
correctiveInBetweenInfluenceWeights
shouldMorphNormals
channelTargetCounts
channelTargetWeights
range.location + range.length <= targets.count
token->sceneRef == scene
DownSampleBloomCoCPass
downsample_2x_bloom
downsample_2x_dof
downsample_2x_bloom_dof
downsample_4x_bloom
downsample_4x_dof
downsample_4x_bloom_dof
SceneKit-CI-effect-depth-
C3D-CIFilter_reverseZ
SceneKit-CI-effect-depth
C3DFXCIFilterPassMetalRenderGraph.json
%@%p
_freeIndices.count > 0
firstFreeIndex != NSNotFound
(offset % _elementSize) == 0
mtlBuffer.offset != NSNotFound
length <= _elementSize
C3DProgramHashCode
textureType < 7
index < C3D_MAX_TEXCOORD
programHashCode->_desc.effectSlotsHash[i] <= ((1 << (kC3DEffectSlotHashIndexMax + 1)) - 1)
com.apple.scenekit.programHashCodeQueue
CFDictionaryContainsKey(s_ProgramHashCodeDictionary, programHashCode->_hashCodeHash)
programHashCode->_hashCodeHash
<C3DProgramHashCode %p : 
SM_Mat,
SM_Geo,
SM(%@),
Aone,
Acst,
opq,
tgt,
lgh,
amb,
prob,
fog,
dynB,
pntR,
Constant
Lambert
Phong
Blinn
ShadowOnly
[%@:
PerPix|
Double|
OverLght|
WrNrm|
Nrmliz|
WriteDepth|
LinDepth|
LockAmb|
TrspA
TrspRGB
TrspSL
TrspDL
[Node:
skn(%d)|
LightMap|
VrtCol|
Tess|
PNTriangles|
Phong|
OSD|
SingleCrease|
ScreenSpace|
PrimvarData=%d|
AmbientOcclusion
SelfIllumination
Tex|
rgb0|
rgb1|
flt0|
texA|
int|
comp|
mat|
(1D)
(2D)
(3D)
(Cube)
[Lighting:
Soft(%d)
JitteringPass
pingPongTex
scn_jittering_color_attachment
scn_jittering_texture
scn_jittering_color_attachment_drawable
scn_jittering_texture_drawable
DOFDownsampleCoCPass
dof_coc_downsample4
RenderRadianceTo%sPass
scn_radiance_%s_%s_frag
MainPass
retainCount >= 0
JSValue
toVector4
toVector3
toTransform3D
valueWithVector3:inContext:
valueWithVector4:inContext:
valueWithTransform3D:inContext:
_SceneKitIsLoaded
SCNLayer
SCNAntialiasingModeMultisampling8X
SCNAntialiasingModeMultisampling16X
SCNMaterialProperty
SCNBoundingBox
SCNBoundingSphere
SCNTransaction
SCNColor
CAMediaTimingFunction
CABasicAnimation
CAAnimationGroup
CAKeyframeAnimation
CALayer
SCNImage
SCNValue
SCNView
SCNMetalLayer
SCNNode
SCNGeometry
SCNPhysicsWorld
SCNPhysicsBody
SCNTransformConstraint
SCNLookAtConstraint
SCNLight
SCNCylinder
SCNGeometryElement
SCNIKConstraint
SCNRenderer
SCNTube
SCNParticleSystem
SCNMorpher
SCNBox
SCNCamera
SCNLevelOfDetail
SCNMaterial
SCNProgram
SCNParticlePropertyController
SCNConstraint
SCNPlane
SCNCone
SCNPhysicsBehavior
SCNPhysicsHingeJoint
SCNPhysicsField
SCNGeometrySource
SCNTorus
SCNScene
SCNPhysicsShape
SCNCapsule
SCNFloor
SCNShape
SCNText
SCNTechnique
SCNPyramid
SCNSceneSource
SCNSphere
SCNPhysicsBallSocketJoint
SCNPhysicsSliderJoint
SCNPhysicsContact
SCNHitTestResult
SCNAnimationEvent
SCNPhysicsVehicle
SCNPhysicsVehicleWheel
SCNAction
SCNActionTimingModeLinear
SCNActionTimingModeEaseIn
SCNActionTimingModeEaseOut
SCNActionTimingModeEaseInEaseOut
SCNEditingLocalSpace
SCNEditingParentSpace
SCNEditingWorldSpace
SCNEditingScreenSpace
SCNManipulatorPositionCenter
SCNManipulatorPositionMin
SCNManipulatorPositionMax
SCNAuthoringDisplayBoundingBoxes
SCNAuthoringDisplayBoundingSpheres
SCNAuthoringDisplayCameraFrustum
SCNAuthoringDisplayLightExtents
SCNAuthoringDisplayCameraPosition
SCNAuthoringDisplayLightPosition
SCNAuthoringDisplayPhysics
SCNAuthoringDisplayPhysicsFields
SCNAuthoringDisplayGrid
SCNAuthoringDisplayLightProbes
SCNAuthoringDisplayWireframe
SCNAuthoringDisplaySkeletons
SCNAuthoringDisplayConstraints
SCNAuthoringDisplayCreases
SCNAuthoringDisplayLightInfluence
SCNAuthoringCameraPerspective
SCNAuthoringCameraTop
SCNAuthoringCameraBottom
SCNAuthoringCameraLeft
SCNAuthoringCameraRight
SCNAuthoringCameraFront
SCNAuthoringCameraBack
SCNCameraProjectionDirectionVertical
SCNCameraProjectionDirectionHorizontal
SCNInteractionModeFly
SCNInteractionModeOrbitTurntable
SCNInteractionModeOrbitAngleMapping
SCNInteractionModeOrbitCenteredArcball
SCNInteractionModeOrbitArcball
SCNInteractionModePan
SCNInteractionModeTruck
SCNCameraFieldOfViewOrientationVertical
SCNCameraFieldOfViewOrientationHorizontal
SCNCameraExposureAdaptationModeFrameLuminance
SCNCameraExposureAdaptationModeHistogramLuminance
SCNCameraFillModeFill
SCNCameraFillModeLetterbox
SCNGeometryPrimitiveTypeTriangles
SCNGeometryPrimitiveTypeTriangleStrip
SCNGeometryPrimitiveTypeLine
SCNGeometryPrimitiveTypePoint
SCNGeometryPrimitiveTypePolygon
SCNTessellationSmoothingModeNone
SCNTessellationSmoothingModePNTriangles
SCNTessellationSmoothingModePhong
SCNSubdivisionBoundaryInterpolationRuleNone
SCNSubdivisionBoundaryInterpolationRuleEdgeOnly
SCNSubdivisionBoundaryInterpolationRuleEdgeAndCorner
SCNSubdivisionFaceVaryingInterpolationRuleLinearNone
SCNSubdivisionFaceVaryingInterpolationRuleLinearCornersOnly
SCNSubdivisionFaceVaryingInterpolationRuleLinearCornersPlus1
SCNSubdivisionFaceVaryingInterpolationRuleLinearCornersPlus2
SCNSubdivisionFaceVaryingInterpolationRuleLinearBoundaries
SCNSubdivisionFaceVaryingInterpolationRuleLinearAll
SCNSubdivisionNormalSmoothingModeCrossTriangle
SCNSubdivisionNormalSmoothingModeCrossQuad
SCNSubdivisionNormalSmoothingModeLimit
SCNHitTestSearchModeClosest
SCNHitTestSearchModeAll
SCNHitTestSearchModeAny
SCNLevelOfDetailThresholdModeWorldSpaceDistance
SCNLevelOfDetailThresholdModeScreenSpaceRadius
SCNShadowModeForward
SCNShadowModeDeferred
SCNShadowModeModulated
SCNMorpherCalculationModeNormalized
SCNMorpherCalculationModeAdditive
SCNMovabilityHintFixed
SCNMovabilityHintMovable
SCNChamferModeBoth
SCNChamferModeFront
SCNChamferModeBack
SCNParticleSortingModeNone
SCNParticleSortingModeProjectedDepth
SCNParticleSortingModeDistance
SCNParticleSortingModeOldestFirst
SCNParticleSortingModeYoungestFirst
SCNParticleBlendModeAdditive
SCNParticleBlendModeSubtract
SCNParticleBlendModeMultiply
SCNParticleBlendModeScreen
SCNParticleBlendModeAlpha
SCNParticleBlendModeReplace
SCNParticleOrientationModeBillboardScreenAligned
SCNParticleOrientationModeBillboardViewAligned
SCNParticleOrientationModeFree
SCNParticleOrientationModeBillboardYAligned
SCNParticleBirthLocationSurface
SCNParticleBirthLocationVolume
SCNParticleBirthLocationVertex
SCNParticleBirthDirectionConstant
SCNParticleBirthDirectionSurfaceNormal
SCNParticleBirthDirectionRandom
SCNParticleImageSequenceAnimationModeRepeat
SCNParticleImageSequenceAnimationModeClamp
SCNParticleImageSequenceAnimationModeAutoReverse
SCNParticleInputModeOverLife
SCNParticleInputModeOverDistance
SCNParticleInputModeOverOtherProperty
SCNParticleModifierStagePreDynamics
SCNParticleModifierStagePostDynamics
SCNParticleModifierStagePreCollision
SCNParticleModifierStagePostCollision
SCNParticleEventBirth
SCNParticleEventDeath
SCNParticleEventCollision
SCNParticleRenderingModeSprite
SCNParticleRenderingModePointSprite
SCNParticleRenderingModeTrail
SCNParticleRenderingModeBeam
SCNParticleRenderingModeGeometry
SCNReferenceLoadingPolicyImmediate
SCNReferenceLoadingPolicyOnDemand
SCNAntialiasingModeNone
SCNAntialiasingModeMultisampling2X
SCNAntialiasingModeMultisampling4X
SCNRenderingAPIMetal
SCNRenderingAPIOpenGLLegacy
SCNRenderingAPIOpenGLCore32
SCNRenderingAPIOpenGLCore41
SCNSceneSourceStatusParsing
SCNSceneSourceStatusValidating
SCNSceneSourceStatusProcessing
SCNSceneSourceStatusComplete
SCNSceneSourceStatusError
SCNCullBack
SCNCullFront
SCNBufferFrequencyPerFrame
SCNBufferFrequencyPerNode
SCNBufferFrequencyPerShadable
SCNFillModeFill
SCNFillModeLines
SCNCullModeBack
SCNCullModeFront
SCNTransparencyModeAOne
SCNTransparencyModeRGBZero
SCNTransparencyModeSingleLayer
SCNTransparencyModeDualLayer
SCNTransparencyModeDefault
SCNBlendModeAlpha
SCNBlendModeAdd
SCNBlendModeSubtract
SCNBlendModeMultiply
SCNBlendModeScreen
SCNBlendModeReplace
SCNBlendModeMax
SCNFilterModeNone
SCNFilterModeNearest
SCNFilterModeLinear
SCNWrapModeClamp
SCNWrapModeRepeat
SCNWrapModeClampToBorder
SCNWrapModeMirror
SCNPhysicsBodyTypeStatic
SCNPhysicsBodyTypeDynamic
SCNPhysicsBodyTypeKinematic
SCNPhysicsFieldScopeInsideExtent
SCNPhysicsFieldScopeOutsideExtent
SCNJS%@JSExport
SCN%@JSExport
%@JSExport
baseMesh
basePositionSource
@"SCNMTLSkinDeformerReadOnlyBuffers"8@?0
needNormal
needTangent
weight_index_size
bone_index_size
skin_var
Int%d_Int%d_%c%c
skin_copy_as_fallback
%c%c
_baseVertexCount == effectiveDstPosCount
effectiveDstPosCount == normalBuffer.length / (3 * sizeof(float))
effectiveDstPosCount <= tangentBuffer.length / (4 * sizeof(float))
bbox %p - min:[%f %f %f] max:[%f %f %f]
bsphere %p - center:[%f %f %f] radius:%f
C3DTransaction
(count == 1)
applyBlock
transaction
<C3DTransaction>
com.apple.scenekit.scnview-renderer
UITrackingRunLoopMode
com.apple.scenekit.main-thread-implicit-transaction-flush
transition-0x
t->childTransactions
child->parentTransaction == t
(count >= 2)
t->pendingAnimationCount>0
MBNeighborMaxPass
scn_motionblur_neighbormax_x
scn_motionblur_neighbormax_y
animationTimingFunction not implemented for Javascript
kGeometrySourceSemanticTangent
kGeometrySourceSemanticVertexCrease
kGeometrySourceSemanticEdgeCrease
kGeometrySourceSemanticBoneWeights
kGeometrySourceSemanticBoneIndices
<%@: %p | semantic=%@ vectors=%d %@x%d>
_geometrySourceWithSource - Conversion failed
_componentType == C3DBaseTypeGetComponentType(_componentType)
_componentCount >= 2 && _componentCount <= 4
halfSource
encodedComponentType == kC3DBaseTypeHalf
compressedSize > 0
cdata
vectorCount
floatComponents
bytesPerComponent
componentType
componentsPerVector
dataOffset
dataStride
colorSpace
decompressedSize == decompressedDataCapacity
<%@: %p | %u x %@, %u channels, %@ indices>
data.length >= (NSUInteger)(primitiveCount * bytesPerIndex)
compressedElementData
elementData
primitiveCount
primitiveRangeLocation
primitiveRangeLength
indicesChannelCount
interleavedIndicesChannels
ptSize
minimumPointScreenSpaceRadius
maximumPointScreenSpaceRadius
pointSize
triangle strip
line
polygon
VendorID
ProductID
MaxInputReportSize
IOHIDManagerOpen failed - %d
setGimbalLockVector is deprecated
Camera
NSScrollWheelMultiplier
kC3DColladaResourcesServiceRequestArgumentsKey
kC3DColladaResourcesServiceReplyArgumentsKey
kC3DColladaResourcesCoordinatorRequestURLKey
kC3DColladaResourcesCoordinatorRequestExtensionKey
kC3DColladaResourcesCoordinatorRequestAssetDirectoryURLsKey
kC3DColladaResourcesCoordinatorRequestImagePathsKey
kC3DColladaResourcesCoordinatorReplyExtensionsKey
SCNFlyCameraControllerForwardKeyCodeKey
SCNFlyCameraControllerBackwardKeyCodeKey
SCNFlyCameraControllerLeftKeyCodeKey
SCNFlyCameraControllerRightKeyCodeKey
com.apple.SceneKit.C3DColladaResourcesCoordinator
v16@?0^v8
An error occurred while locating the resources needed to open this COLLADA file. Please check that it has not been corrupted.
extension
uniform 
uvec2
uvec3
uvec4
mat2
mat2x4
mat3x2
mat3x3
mat4x2
mat3x4
scn_frame.time
u_viewTransform
scn_frame.viewTransform
u_inverseViewTransform
scn_frame.inverseViewTransform
scn_frame.projectionTransform
u_inverseProjectionTransform
scn_frame.inverseProjectionTransform
scn_frame.cameraPosition
scn_frame.viewToCubeWorld
scn_frame.inverseResolution
u_modelTransform
scn_node.modelTransform
u_inverseModelTransform
scn_node.inverseModelTransform
scn_node.modelViewTransform
u_inverseModelViewTransform
scn_node.inverseModelViewTransform
scn_node.normalTransform
scn_node.modelViewProjectionTransform
u_inverseModelViewProjectionTransform
scn_node.inverseModelViewProjectionTransform
u_boundingBox
scn_node.boundingBox
u_worldBoundingBox
scn_node.worldBoundingBox
discard
discard_fragment()
gl_FragCoord
in.fragmentPosition
gl_FragColor
_output.color
gl_FrontFacing
isFrontFacing
filter::linear
texture1DProj
texture1DLod
texture1DProjLod
texture2DLod
textureLod
texture2DProj
texture2DProjLod
texture3DProj
texture3DLod
texture3DProjLod
textureCubeLod
shadow1D
shadow1DProj
shadow1DLod
shadow1DProjLod
shadow2D
shadow2DProj
shadow2DLod
shadow2DProjLod
C3DShaderConverter.mm
ParseUniform
mToken.str() == "uniform"
body
Parse
mpTokenizer == nullptr
#pragma arguments
#pragma body
#pragma declaration
.sample(
Sampler
, level(
, bias(
float2(
float3(
float4(
sampler 
Sampler
http
superclass
niceDescription
presentation
mirror
empty
particleSystems
constaints
empty node
static
dynamic
kinematic
hinge
ballSocket
slider
drag
vortex
linear gravity
radial gravity
noise
turbulence
springField
electricField
magneticField
Shader source
back
front
aOne
zero
single layer
dual layer
shadowonly
physically based
plane
pyramid
cylinder
cone
tube
capsule
torus
Hello!
perspective
wantsDepthOfField
bloomIterationCount
_shadowCascadeDebugFactor
__semanticRegistry == NULL
__semanticRegistry != NULL
[__semanticRegistry objectForKey:semanticName] == nil
[__argumentRegistry objectForKey:argumentName] == nil
vertexBuffer.
osdIndicesBuffer
osdTessellationLevel
osdVertexBuffer
osdFaceVaryingData
osdFaceVaryingIndices
osdFaceVaryingPatchParams
osdFaceVaryingPatchArray
osdFaceVaryingChannelCount
osdFaceVaryingChannelDescriptors
osdFaceVaryingPatchArrayIndex
osdFaceVaryingChannelsPackedData
vertexBuffer
indexBuffer
patchParamBuffer
perPatchVertexBuffer
patchTessBuffer
scn_nodes
scn_frame_multi
bufferBinding.type == argument.type
(SCNArgumentBindingBlock)bufferBinding.bindBlock == block
[bufferBinding isKindOfClass:[SCNMTLPassResourceBinding class]]
(SCNArgumentBindingBlock)bufferBinding.bindBlock == nil
argument.bufferDataType == MTLDataTypeStruct
(NSUInteger)bufferBinding.bufferSize == argument.bufferDataSize
kExportPointOfViewAttribute
SCNExportSceneIdentifier
SCNExportMovieMirrored
SCNExportMovieSupersamplingFactor
SCNExportMovieFrameRate
SCNExportOperation : error not implemented
QTAddImageCodecType
QTMovieRateAttribute
SCNExport.m
SceneKit: Couldn't create pixel buffer
serial assetwriter input queue
v28@?0f8^{__CFError=}12^B20
FillTexturePass
B24@?0^{__C3DShapeBoundary=^{__C3DShapeVertex}IIddddi}8^{__C3DShapeBoundary=^{__C3DShapeVertex}IIddddi}16
v24@?0^{__C3DShapeBoundary=^{__C3DShapeVertex}IIddddi}8^{__C3DShapeBoundary=^{__C3DShapeVertex}IIddddi}16
v24@?0^{__C3DShapeBoundary=^{__C3DShapeVertex}IIddddi}8i16i20
boundaryCount > 1
C3DAppendPointToPath
C3DShapeUtils.c
origin != C3DShapeVertexOriginCurveStart
C3DShapeTriangulation.c
triangulation->triangleCount < triangulation->maxTriangleCount
C3DShapeTriangulationTriangleContainingPoint
C3DLinkIndexFromTriangleToTriangle
C3DVertexNotSharedByTriangles
C3DShapeConnectedComponentTriangulatePseudopolygon
list->count > 1
C3DShapeTriangulationAddEdge
recycledTriangles.count == 0
C3DGlyph
C3DGlyphCreate
C3DGlyph.c
shapeParams.cgPath == NULL
<C3DGlyph '%@' in '%@'>
C3DTextLine
<C3DTextLine>
C3DTextFrame
<C3DTextFrame>
profilePath.points
v28@?0c8I12*16I24
v140@?0{__C3DShapeVertex={CGPoint=dd}{CGPoint=dd}{CGPoint=dd}{CGPoint=dd}dBi}8{CGPoint=dd}88f104{CGPoint=dd}108{CGPoint=dd}124
setToApplyTo.count <= _originalDataCount
_prepareSnapToAlignDataForAxis - unexpected axis
C3DSpokeCreate
C3DShapeStraightSkeleton.c
CGPointEqualToPoint(origin, prev) == false
CGPointEqualToPoint(origin, next) == false
!isnan(spoke.direction.x)
!isnan(spoke.direction.y)
intersectionForSpokeAndSpoke
fabs(CGPointNorm(spoke1->direction) - 1) < epsilon
fabs(CGPointNorm(spoke2->direction) - 1) < epsilon
intersectionForSpokeAndEdge
spoke != edgeStart
spoke != edgeEnd
splitJoinFace
event.type == C3DStraightSkeletonEventSplit
spoke->boundaryOfVerticesIndex != INVALID_INDEX
other->boundaryOfVerticesIndex != INVALID_INDEX
d != INVALID_INDEX
f != INVALID_INDEX
bestSplitEvents
C3DOffsetBuild
newFace.boundaries == NULL
C3DFXJitteringPassFloat.plist
SceneKit_JitterCopyFirstFrame
SceneKit_JitterToEven
SceneKit_JitterToOdd
SceneKit_JitterResolve
Copy_vert
Copy_frag
C3D-Copy
Add_vert
Add_frag
C3D-Add
C3D-jitter-factor-resolve
Mult_vert
Mult_frag
C3D-Mult_float
SSRBlurPass-Y
SSRBlurPass-X
scn_ssr_blur_x
scn_ssr_blur_y
Original mesh has %d triangles, will reach a maximum of %d after %d levels of subdivision
[VDMC] ConfigBuffer%d
[VDMC] TriangleBuffer%d
VMeshAtomicSubdivisionKernel
VMeshUpdateCountersAndArgumentsKernel
VDMC deformer
Error creating the xml writer
utf-8
Error at xmlTextWriterStartDocument
COLLADA
xmlns
http://www.collada.org/2005/11/COLLADASchema
1.4.1
Error at xmlTextWriterEndDocument
contributor
SceneKit Collada Exporter v1.0
Y_UP
Z_UP
X_UP
yyyy-MM-dd'T'HH:mm:ss'Z'
library_animations
library_animation_clips
effect_
%@%d
(%ld)
can't mix euler and axisangle rotations
transform animation not supported
_copyComponentForColor4Address
C3DIOColladaExport.c
offset<4
_copyComponentForMatrixAddress
offset<16
(%zd)(%zd)
_copyComponentForVector3Address
offset<3
_copyComponentForVector4Address
float_array
int_array
Name_array
%s-array
_writeArrayWithWriterFunc
ccpv == 1
_writeArrayWithWriterFunc: unknown array type
#%s-array
TIME
TRANSFORM
_writeAccessor
cpv <= sizeof(XYZWNames) / sizeof(char*)
cpv <= sizeof(RGBANames) / sizeof(char*)
cpv <= sizeof(STPQNames) / sizeof(char*)
cpv <= 1
param
HERMITE
_writeKeyframeAnimation: can't resolve animation path (root)
_writeKeyframeAnimation: can't resolve animation path
channel
%s/%s%s
SID_%d
animation_clip
instance_animation
library_cameras
optics
orthographic
xmag
library_lights
%g %g %g
constant_attenuation
linear_attenuation
quadratic_attenuation
falloff_angle
falloff_exponent
profile
%g %g %g %g
probeParameters
tmpProbe
./no-path-found
instance_effect
#effect_%s
effect_%s
profile_COMMON
common
index_of_refraction
bump
newparam
_surface
%s_%s
surface
CUBE
CLAMP
WRAP
BORDER
MIRROR
wrap_s
wrap_t
NONE
NEAREST
minfilter
magfilter
mipfilter
opaque
CHANNEL%d
library_geometries
%s-vertices
NORMAL
tristrips
TEXTANGENT
WEIGHT
#%s-vertices
%ld 
library_controllers
method
NORMALIZED
RELATIVE
%s-targets
IDREF_array
%s-targets-array
#%s-targets-array
MORPH_TARGET
IDREF
#%s-targets
MORPH_WEIGHT
bind_shape_matrix
vertex_weights
%d %ld 
%.7g 
library_visual_scenes
instance_visual_scene
instance_camera
instance_light
lightmap_path=%s
uv_set=%d
translate
rotate
0 0 1 %g
0 1 0 %g
1 0 0 %g
instance_controller
instance_geometry
bind_material
instance_material
symbol
bind_vertex_input
input_semantic
input_set
scratchAllocator
fxPass
draw
ignoreFloors
onlyShadowCasters
onlyMovableNodes
hasConstantAlpha
installViewport
isViewDependant
overridesCustomProgram
layerMask
includeCategoryMask
excludeCategoryMask
viewport
samples
colorStates
clearColor
sceneBackground
clear
depthStates
enableWrite
enableRead
func
stencilStates
behavior
backFaceBehavior
blendStates
inputName
context->pass->_setup==0
@8@?0
C3DFXTechniqueGetPassCount(subTechnique) == 1
fxPass->_inputCount == count
(CFIndex)fxPass->_outputCount <= count
C3DFXPassInput
<C3DFXPassInput %@>
C3DFXPass
<C3DFXPass %@>
nameToInput
draw_scene
draw_node
draw_main_scene
draw_nodes
draw_geometry
draw_quad
metal_custom
draw_none
custom
preDraw
preFX
preToneMap
postFX
cullNone
never
always
equal
notEqual
less
lessEqual
greater
greaterEqual
depthFail
fail
readMask
writeMask
referenceValue
keep
replace
increment
decrement
invert
incrementWrap
decrementWrap
colorSrc
colorDst
alphaSrc
alphaDst
colorOp
alphaOp
oneMinusSrcColor
oneMinusSrcAlpha
oneMinusDstColor
oneMinusDstAlpha
constantColor
oneMinusConstantColor
constantAlpha
oneMinusConstantAlpha
alphaSaturate
substract
reverseSubstract
scaleFactor
mipmapped
%fx%f
texture_rectangle
color0
color1
color2
color3
stencil
format
input->_semantic != kC3DFXSemanticNone
typeTest == input->_baseType
tangent
modelViewProjectionInverseTransform
modelViewInverseTransform
modelInverseTransform
viewInverseTransform
projectionInverseTransform
normalInverseTransform
global
persistent
pass->_overridedRendererElementsProgramHashcodes
C3DRenderTarget
<C3DRenderTarget %p - texture:%@ rbo:%d>
C3DFXCopyPass.plist
C3DFXPostProcess_depth.json
C3DFXPostProcess.json
C3DFXDOFPass_deprecated.plist
C3DFXSSAO.json
C3DFXMotionBlur.plist
C3DFXJitteringPass.plist
C3D-Add.vsh
C3D-dof-downSample4x.fsh
C3D-ParticleSystem.fsh
C3D-OutlineRetina.vsh
C3D-Copy.vsh
C3D-EnvMap2D.vsh
C3D-Mult_float.fsh
C3D-GaussianBlurAlpha.vsh
C3D-ParticleSystem_Trail.fsh
C3D-dof-Blur5x5.vsh
C3DManipulatorColorAndTexture.fsh
C3DManipulator.fsh
C3D-CIFilterComposite.fsh
C3DManipulatorColorOnly.fsh
C3D-dof-ComputeNearCoc.vsh
C3DManipulatorLightProbe.vsh
C3D-DefaultProgram.fsh
C3D-IncrementalAverage.vsh
C3D-PickedObjects.fsh
C3D-EnvMapCube.fsh
C3D-OutlineMax.vsh
C3D-BlendAuthoring.fsh
C3D-dof-generateNearCoc.fsh
C3D-spotShadow.fsh
C3D-Outline.vsh
C3D-GaussianBlur.fsh
C3D-WarmupTexture.fsh
C3D-dof-Resolve.fsh
C3D-wireframe.vsh
C3DManipulator.vsh
C3DManipulatorColorAndTexture.vsh
C3D-CIFilterComposite.vsh
C3D-dof-downSample4x.vsh
C3D-ParticleSystem.vsh
C3D-OutlineRetina.fsh
C3D-Add.fsh
C3D-Copy.fsh
C3D-Mult_float.vsh
C3D-EnvMap2D.fsh
C3D-dof-Blur5x5.fsh
C3D-ParticleSystem_Trail.vsh
C3D-GaussianBlurAlpha.fsh
C3D-EnvMapCube.vsh
C3D-PickedObjects.vsh
C3D-BlendAuthoring.vsh
C3D-dof-generateNearCoc.vsh
C3D-OutlineMax.fsh
C3D-GaussianBlur.vsh
C3D-Outline.fsh
C3D-spotShadow.vsh
C3D-wireframe.fsh
C3D-WarmupTexture.vsh
C3D-dof-Resolve.vsh
C3DManipulatorColorOnly.vsh
C3DManipulatorLightProbe.fsh
C3D-dof-ComputeNearCoc.fsh
SCNShaderLightingContribution.glsl
C3D-IncrementalAverage.fsh
C3D-DefaultProgram.vsh
scn_deformer
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_copy</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_copy</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-Copy</string>
<key>clientProgram</key>
<false/>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
</dict>
</dict>
</dict>
</plist>
  "passes" : {
    "SceneKit_renderSceneFromLight" : {
      "outputs" : {
        "depth" : "SceneKit-spotShadowDepth"
      },
      "depthStates" : {
        "clear" : true
      },
      "isViewDependant" : false,
      "samples" : 1,
      "onlyShadowCasters" : true,
      "pointOfView" : "self",
      "ignoreFloors" : true,
      "draw" : "DRAW_SCENE"
    }
  },
  "sequence" : [
    "SceneKit_renderSceneFromLight"
  ],
  "targets" : {
    "SceneKit-spotShadowDepth" : {
      "global" : true,
      "type" : "depth"
    }
  "sequence" : [
                "SceneKit_renderCINodeTree",
                "SceneKit_ApplyCIFilter",
                "SceneKit_renderCIQuad"
                ],
  "targets" : {
    "SceneKit-CI-nodetree-depth" : {
      "type" : "depth"
    },
    "SceneKit-CI-nodetree-color" : {
      "type" : "color",
      "format" : "rgba",
    },
    "SceneKit-CI-effect-color" : {
      "type" : "color",
      "format" : "rgba",
      "usage" : ["shaderWrite", "shaderRead"]
    }
  },
  "symbols" : {
    "C3D-CIFilter_middleZ" : {
      "type" : "float"
    },
    "C3D-CIFilter_extent" : {
      "type" : "vec4"
    }
  },
  "passes" : {
    "SceneKit_renderCIQuad" : {
      "inputs" : {
        "u_color" : {
          "target" : "SceneKit-CI-effect-color",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        },
        "u_middleZ" : "C3D-CIFilter_middleZ",
        "u_extent" : "C3D-CIFilter_extent",
        "u_depth" : {
          "target" : "SceneKit-CI-nodetree-depth",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        }
      },
      "hasConstantAlpha" : false,
      "colorStates" : {
        "clear" : false
      },
      "depthStates" : {
        "clear" : false
      },
      "cullMode" : "none",
      "metalVertexShader" : "scn_filterCompositeVert",
      "metalFragmentShader" : "scn_filterCompositeFrag",
      "draw" : "none",
      "clientProgram" : false,
      "blendStates" : {
        "enable" : true,
        "colorDst" : "oneMinusSrcAlpha",
        "colorSrc" : "one"
      }
    },
    "SceneKit_ApplyCIFilter" : {
      "outputs" : {
        "color" : "SceneKit-CI-effect-color"
      },
      "inputs" : {
        "myInput1" : "SceneKit-CI-nodetree-color"
      },
      "draw" : "CUSTOM"
    },
    "SceneKit_renderCINodeTree" : {
      "draw" : "DRAW_NODE",
      "node" : "self",
      "ignoreFloors" : true,
      "outputs" : {
        "depth" : "SceneKit-CI-nodetree-depth",
        "color" : "SceneKit-CI-nodetree-color"
      },
      "colorStates" : {
        "clear" : true
      },
      "depthStates" : {
        "clear" : true
      },
      
    }
    "sequence" : [ "SceneKit_PostProcess"],
    "passes" : {
        "SceneKit_PostProcess" : {
            "outputs" : {
                "color" : "COLOR"
            },
            "inputs" : {
                "colorBuffer" : "COLOR",
                "depthBuffer" : "DEPTH"
            },
            "draw" : "DRAW_QUAD",
            "clientProgram" : "NO",
            "program" : "C3D-GLSL-UNAVAILABLE",
        }
    },
    "symbols" : {
    },
  "passes" : {
    "SceneKit_renderSceneFromLight" : {
      "outputs" : {
        "depth" : "SceneKit-spotShadowDepth"
      },
      "depthStates" : {
        "clear" : true
      },
      "isViewDependant" : false,
      "samples" : 1,
      "onlyShadowCasters" : true,
      "pointOfView" : "self",
      "ignoreFloors" : true,
      "draw" : "DRAW_SCENE"
    },
    "SceneKit_applyDeferredShadows" : {
      "outputs" : {
        "color" : "COLOR"
      },
      "inputs" : {
          "light_MVP" : "C3D-light_MVP-symbol",
          "viewTransform" : "C3D-camera_view-symbol",
          "depthSampler" : {
          "target" : "DEPTH",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        },
        "u_kernel" : "C3D-shadowKernel-symbol",
        "lightDepthSampler" : {
          "target" : "SceneKit-spotShadowDepth",
          "sampler" : {
            "wrapS" : "clamp",
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest",
            "wrapT" : "clamp"
          }
        },
        "shadowColor" : "C3D-shadowColor-symbol",
        "colorSampler" : "COLOR",
        "camera_MVP_i" : "C3D-camera_MVP_i-symbol",
        "cascadeScale" : "C3D-cascadeScale-symbol",
        "cascadeBias" : "C3D-cascadeBias-symbol",
        "cascadeDebugFactor" : "C3D-shadowCascadeDebugFactor-symbol",
        "u_lightPos" : "C3D-u_lightPos-symbol",
        "u_lightDir" : "C3D-u_lightDir-symbol",
        "shadowRadius" : "C3D-shadowRadius-symbol",
        "u_lightSpotAtt" : "C3D-u_lightSpotAtt-symbol"
      },
      "metalFragmentShader" : "shadowMap_frag",
      "draw" : "DRAW_QUAD",
      "clientProgram" : false,
      "metalVertexShader" : "shadowMap_vert"
    }
  },
  "sequence" : [
    "SceneKit_renderSceneFromLight",
    "SceneKit_applyDeferredShadows"
  ],
  "symbols" : {
    "C3D-u_lightSpotAtt-symbol" : {
      "type" : "vec3"
    },
    "C3D-shadowColor-symbol" : {
      "type" : "vec4"
    },
    "C3D-camera_MVP_i-symbol" : {
      "type" : "mat4"
    },
    "C3D-camera_view-symbol" : {
      "type" : "mat4"
    },
    "C3D-u_lightPos-symbol" : {
      "type" : "vec3"
    },
    "C3D-zMapFactor-symbol" : {
      "type" : "float"
    },
    "C3D-light_MVP-symbol" : {
      "type" : "mat4"
    },
    "C3D-shadowRadius-symbol" : {
      "type" : "float"
    },
    "C3D-shadowCascadeDebugFactor-symbol" : {
      "type" : "float"
    },
    "C3D-shadowKernel-symbol" : {
      "type" : "vec4[128]"
    },
    "C3D-cascadeScale-symbol" : {
      "type" : "vec3[4]"
    },
    "C3D-cascadeBias-symbol" : {
      "type" : "vec3[4]"
    },
    "C3D-u_lightDir-symbol" : {
      "type" : "vec3"
    }
  },
  "targets" : {
    "SceneKit-spotShadowDepth" : {
      "type" : "depth"
    }
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>symbols</key>
<dict>
<key>a_position-symbol</key>
<dict>
<key>semantic</key>
<string>vertex</string>
</dict>
<key>color</key>
<dict>
<key>semantic</key>
<string>none</string>
</dict>
</dict>
<key>sequence</key>
<array>
<string>authoring-overlay</string>
<string>authoringBlend</string>
</array>
<key>targets</key>
<dict>
<key>authoring-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba</string>
</dict>
<key>authoring-depth</key>
<dict>
<key>type</key>
<string>depth</string>
</dict>
</dict>
<key>passes</key>
<dict>
<key>authoring-overlay</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>authoring-color</string>
<key>depth</key>
<string>authoring-depth</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>layerMask</key>
<integer>4</integer>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clearColor</key>
<string>0 0 0 0</string>
<key>clear</key>
<true/>
</dict>
</dict>
<key>authoringBlend</key>
<dict>
<key>clientProgram</key>
<string>NO</string>
<key>program</key>
<string>C3D-BlendAuthoring</string>
<key>metalVertexShader</key>
<string>blendAuthoring_vert</string>
<key>metalFragmentShader</key>
<string>blendAuthoring_frag</string>
<key>inputs</key>
<dict>
<key>authoringColor</key>
<string>authoring-color</string>
<key>sceneColor</key>
<string>COLOR</string>
</dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>depthStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>sceneBackground</string>
</dict>
</dict>
</dict>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>Outline-pickedObjects</string>
<string>Outline-outline</string>
</array>
<key>passes</key>
<dict>
<key>Outline-pickedObjects</key>
<dict>
<key>outputs</key>
<dict>
<key>depth</key>
<string>pickedObjects-depth</string>
<key>color</key>
<string>pickedObjects-color</string>
</dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>u_modelViewProjectionTransform</key>
<string>u_modelViewProjectionTransform-symbol</string>
<key>u_modelTransform</key>
<string>u_modelTransform-symbol</string>
</dict>
<key>draw</key>
<string>DRAW_NODES</string>
<key>samples</key>
<integer>1</integer>
<key>overridesCustomProgram</key>
<true/>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>&quot;0. 0. 0. 1.&quot;</string>
</dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
</dict>
<key>Outline-outline</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>pickedColorBuffer</key>
<string>pickedObjects-color</string>
<key>pickedDepthBuffer</key>
<string>pickedObjects-depth</string>
<key>colorBuffer</key>
<string>COLOR</string>
<key>depthBuffer</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-Outline</string>
<key>clientProgram</key>
<string>NO</string>
<key>metalVertexShader</key>
<string>outline_vert</string>
<key>metalFragmentShader</key>
<string>outline_frag</string>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>a_position-symbol</key>
<dict>
<key>semantic</key>
<string>vertex</string>
</dict>
<key>u_modelViewProjectionTransform-symbol</key>
<dict>
<key>semantic</key>
<string>modelViewProjectionTransform</string>
</dict>
<key>u_modelTransform-symbol</key>
<dict>
<key>semantic</key>
<string>modelTransform</string>
</dict>
<key>color</key>
<dict>
<key>semantic</key>
<string>none</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>pickedObjects-depth</key>
<dict>
<key>type</key>
<string>depth</string>
<key>format</key>
<string>depth24</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
<key>pickedObjects-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>r8</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
</dict>
</dict>
</plist>
    "sequence" : [ "SceneKit_PostProcess"],
    "passes" : {
        "SceneKit_PostProcess" : {
            "outputs" : {
                "color" : "COLOR"
            },
            "inputs" : {
                "colorBuffer" : "COLOR"
            },
            "draw" : "DRAW_QUAD",
            "clientProgram" : "NO",
            "program" : "C3D-GLSL-UNAVAILABLE",
        }
    },
    "symbols" : {
    },
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>Outline-pickedObjects</string>
<string>Outline-outline</string>
<string>Outline-max</string>
</array>
<key>passes</key>
<dict>
<key>Outline-pickedObjects</key>
<dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>u_modelViewProjectionTransform</key>
<string>u_modelViewProjectionTransform-symbol</string>
<key>u_modelTransform</key>
<string>u_modelTransform-symbol</string>
</dict>
<key>outputs</key>
<dict>
<key>depth</key>
<string>pickedObjects-depth</string>
<key>color</key>
<string>pickedObjects-color</string>
</dict>
<key>draw</key>
<string>DRAW_NODES</string>
<key>samples</key>
<integer>1</integer>
<key>overridesCustomProgram</key>
<true/>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>&quot;0. 0. 0. 1.&quot;</string>
</dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
</dict>
<key>Outline-outline</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>outline-color</string>
</dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>pickedColorBuffer</key>
<string>pickedObjects-color</string>
<key>pickedDepthBuffer</key>
<string>pickedObjects-depth</string>
<key>colorBuffer</key>
<string>COLOR</string>
<key>depthBuffer</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-OutlineRetina</string>
<key>clientProgram</key>
<string>NO</string>
<key>metalVertexShader</key>
<string>outlineRetina_vert</string>
<key>metalFragmentShader</key>
<string>outlineRetina_frag</string>
</dict>
<key>Outline-max</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>outlineColorBuffer</key>
<string>outline-color</string>
<key>colorBuffer</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-OutlineMax</string>
<key>clientProgram</key>
<string>NO</string>
<key>metalVertexShader</key>
<string>outlineMax_vert</string>
<key>metalFragmentShader</key>
<string>outlineMax_frag</string>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>a_position-symbol</key>
<dict>
<key>semantic</key>
<string>vertex</string>
</dict>
<key>u_modelViewProjectionTransform-symbol</key>
<dict>
<key>semantic</key>
<string>modelViewProjectionTransform</string>
</dict>
<key>u_modelTransform-symbol</key>
<dict>
<key>semantic</key>
<string>modelTransform</string>
</dict>
<key>color</key>
<dict>
<key>semantic</key>
<string>none</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>outline-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>r8</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
<key>pickedObjects-depth</key>
<dict>
<key>type</key>
<string>depth</string>
<key>format</key>
<string>depth24</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
<key>pickedObjects-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>r8</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
</dict>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_downSample4x</string>
<string>SceneKit_DOF_generateNearCoc</string>
<string>SceneKit_DOF_blurCoc_H</string>
<string>SceneKit_DOF_blurCoc_V</string>
<string>SceneKit_blurColor4x_H</string>
<string>SceneKit_blurColor4x_V</string>
<string>SceneKit_DOF_computeNearCoc</string>
<string>SceneKit_DOF_smallBlur</string>
<string>SceneKit_DOF_resolve</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_downSample4x</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-color-downSample4x</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<string>COLOR</string>
<key>depthSampler</key>
<string>DEPTH</string>
<key>CocScaleBias</key>
<string>C3D-dof-cocScaleBias</string>
<key>u_inversePixelSize</key>
<string>C3D-dof-invertPixelSize</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-downSample4x</string>
<key>clientProgram</key>
<false/>
<key>metalVertexShader</key>
<string>DownSample4x_vert</string>
<key>metalFragmentShader</key>
<string>DownSample4x_frag</string>
</dict>
<key>SceneKit_DOF_generateNearCoc</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-color-nearCoc</string>
</dict>
<key>inputs</key>
<dict>
<key>downSampler</key>
<dict>
<key>target</key>
<string>SceneKit-color-downSample4x</string>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
</dict>
<key>depthSampler</key>
<dict>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
<key>target</key>
<string>DEPTH</string>
</dict>
<key>CocScaleBias</key>
<string>C3D-dof-cocScaleBias</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-generateNearCoc</string>
<key>metalVertexShader</key>
<string>GenerateNearCoc_vert</string>
<key>clientProgram</key>
<false/>
<key>metalFragmentShader</key>
<string>GenerateNearCoc_frag</string>
</dict>
<key>SceneKit_DOF_blurCoc_H</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_DOF_blurCoc_H_output</string>
</dict>
<key>inputs</key>
<dict>
<key>radius</key>
<string>C3D-blur-radiusH</string>
<key>textureSampler0</key>
<string>SceneKit-color-nearCoc</string>
<key>offsets</key>
<string>C3D-blur-offsets</string>
<key>weights</key>
<string>C3D-blur-weights</string>
<key>n_sample</key>
<string>C3D-blur-samples</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_DOF_blurCoc_V</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_DOF_blurCoc_V_output</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>SceneKit_DOF_blurCoc_H_output</string>
<key>radius</key>
<string>C3D-blur-radiusV</string>
<key>offsets</key>
<string>C3D-blur-offsets</string>
<key>weights</key>
<string>C3D-blur-weights</string>
<key>n_sample</key>
<string>C3D-blur-samples</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_blurColor4x_H</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_blurColor4x_H_output</string>
</dict>
<key>inputs</key>
<dict>
<key>radius</key>
<string>C3D-blur-radiusH</string>
<key>textureSampler0</key>
<string>SceneKit-color-downSample4x</string>
<key>offsets</key>
<string>C3D-blur-offsets</string>
<key>weights</key>
<string>C3D-blur-weights</string>
<key>n_sample</key>
<string>C3D-blur-samples</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_blurColor4x_V</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_blurColor4x_V_output</string>
</dict>
<key>inputs</key>
<dict>
<key>radius</key>
<string>C3D-blur-radiusV</string>
<key>textureSampler0</key>
<string>SceneKit_blurColor4x_H_output</string>
<key>offsets</key>
<string>C3D-blur-offsets</string>
<key>weights</key>
<string>C3D-blur-weights</string>
<key>n_sample</key>
<string>C3D-blur-samples</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_DOF_computeNearCoc</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_DOF_computeNearCoc-output</string>
</dict>
<key>inputs</key>
<dict>
<key>downSampler</key>
<dict>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
<key>target</key>
<string>SceneKit-color-nearCoc</string>
</dict>
<key>blurSampler</key>
<dict>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
<key>target</key>
<string>SceneKit_DOF_blurCoc_V_output</string>
</dict>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-ComputeNearCoc</string>
<key>clientProgram</key>
<false/>
<key>metalVertexShader</key>
<string>ComputeNearCoc_vert</string>
<key>metalFragmentShader</key>
<string>ComputeNearCoc_frag</string>
</dict>
<key>SceneKit_DOF_smallBlur</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_DOF_smallBlur-ouput</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<dict>
<key>target</key>
<string>SceneKit_DOF_computeNearCoc-output</string>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
</dict>
<key>u_inversePixelSize</key>
<string>C3D-dof-invertPixelSize</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-Blur5x5</string>
<key>clientProgram</key>
<false/>
<key>metalVertexShader</key>
<string>Blur5x5_vert</string>
<key>metalFragmentShader</key>
<string>Blur5x5_frag</string>
</dict>
<key>SceneKit_DOF_resolve</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<string>COLOR</string>
<key>depthSampler</key>
<string>DEPTH</string>
<key>smallBlurSampler</key>
<string>SceneKit_DOF_smallBlur-ouput</string>
<key>largeBlurSampler</key>
<string>SceneKit_blurColor4x_V_output</string>
<key>CocScaleBias</key>
<string>C3D-dof-cocScaleBias</string>
<key>dofLerpScale</key>
<string>C3D-dof-lerpScale</string>
<key>dofLerpBias</key>
<string>C3D-dof-lerpBias</string>
<key>u_inversePixelSize</key>
<string>C3D-dof-invertPixelSize</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-Resolve</string>
<key>clientProgram</key>
<false/>
<key>metalVertexShader</key>
<string>ResolveDOF_vert</string>
<key>metalFragmentShader</key>
<string>ResolveDOF_frag</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>SceneKit-color-downSample4x</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit-color-nearCoc</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_DOF_blurCoc_H_output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_DOF_blurCoc_V_output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_blurColor4x_H_output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_blurColor4x_V_output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_DOF_computeNearCoc-output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_DOF_smallBlur-ouput</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>C3D-dof-cocScaleBias</key>
<dict>
<key>type</key>
<string>vec3</string>
</dict>
<key>C3D-dof-invertPixelSize</key>
<dict>
<key>type</key>
<string>vec2</string>
</dict>
<key>C3D-dof-lerpScale</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>C3D-dof-lerpBias</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>C3D-blur-radiusV</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>C3D-blur-radiusH</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>C3D-blur-offsets</key>
<dict>
<key>type</key>
<string>vec2[31]</string>
</dict>
<key>C3D-blur-weights</key>
<dict>
<key>type</key>
<string>float[31]</string>
</dict>
<key>C3D-blur-samples</key>
<dict>
<key>type</key>
<string>int</string>
</dict>
</dict>
</dict>
</plist>
    "sequence": [
                 "SceneKit_SSAO_DEPTH",
                 "SceneKit_SSAO"
                 ],
    "passes": {
        "SceneKit_SSAO_DEPTH": {
            "outputs": {
                "depth": "depth-target",
                "color": "ssao-depth"
            },
            "depthStates": {
                "clear": true
            },
            "colorStates": {
                "clear": true,
                "clearColor": "-100000. -100000. -100000. -100000."
            },
            "samples": 1,
            "__clientProgram": "NO",
            "draw": "DRAW_SCENE",
        },
        "SceneKit_SSAO": {
            "outputs": {
                "color": "COLOR"
            },
            "inputs": {
                "color": "COLOR"
            },
            "draw": "DRAW_QUAD",
            "clientProgram": "NO",
            "program": "C3D-GLSL-UNAVAILABLE"
        }
    },
    "symbols": {},
    "targets": {
        "depth-target": {
            "type": "depth",
        },
        "ssao-depth": {
            "format": "rgba16f",
            "type": "color",
            "global": true,
            "mipmapped": true,
            "scaleFactor": 1.0
        }
    }
  "passes" : {
    "SceneKit_ApplyCIFilter" : {
      "outputs" : {
        "color" : "SceneKit-CI-effect-color"
      },
      "inputs" : {
        "myInput1" : "SceneKit-CI-nodetree-color"
      },
      "draw" : "CUSTOM"
    },
    "SceneKit_renderCINodeTree" : {
      "outputs" : {
        "depth" : "SceneKit-CI-nodetree-depth",
        "color" : "SceneKit-CI-nodetree-color"
      },
      "ignoreFloors" : true,
      "draw" : "DRAW_NODE",
      "node" : "self"
    },
    "SceneKit_renderCIQuad" : {
      "inputs" : {
        "u_m" : "C3D-CIFilter_modelMatrix",
        "u_color" : {
          "target" : "SceneKit-CI-effect-color",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        },
        "u_middleZ" : "C3D-CIFilter_middleZ",
        "u_depth" : {
          "target" : "SceneKit-CI-nodetree-depth",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        }
      },
      "hasConstantAlpha" : false,
      "colorStates" : {
        "clear" : false
      },
      "depthStates" : {
        "clear" : false
      },
      "program" : "C3D-CIFilterComposite",
      "draw" : "none",
      "clientProgram" : false,
      "blendStates" : {
        "enable" : true,
        "colorDst" : "oneMinusSrcAlpha",
        "colorSrc" : "one"
      }
    }
  },
  "sequence" : [
    "SceneKit_renderCINodeTree",
    "SceneKit_ApplyCIFilter",
    "SceneKit_renderCIQuad"
  ],
  "symbols" : {
    "C3D-CIFilter_middleZ" : {
      "type" : "float"
    },
    "C3D-CIFilter_modelMatrix" : {
      "type" : "mat4"
    }
  },
  "targets" : {
    "SceneKit-CI-effect-color" : {
      "type" : "color"
    },
    "SceneKit-CI-nodetree-color" : {
      "target" : "texture_rectangle",
      "type" : "color"
    },
    "SceneKit-CI-nodetree-depth" : {
      "type" : "depth"
    }
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>computeVelocity</string>
<string>blur1</string>
<string>blur2</string>
<string>renderMovableNodes</string>
</array>
<key>passes</key>
<dict>
<key>blur1</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<string>COLOR</string>
<key>velocitySampler</key>
<string>VELOCITY</string>
<key>intensity</key>
<string>C3D-MotionBlur-Intensity-symbol</string>
</dict>
<key>program</key>
<string>C3D-GLSL-UNAVAILABLE</string>
<key>clientProgram</key>
<string>NO</string>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>metalFragmentShader</key>
<string>scn_motionblur_blur_6taps</string>
<key>metalVertexShader</key>
<string>scn_motionblur_vert</string>
</dict>
<key>blur2</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<string>COLOR</string>
<key>velocitySampler</key>
<string>VELOCITY</string>
<key>intensity</key>
<string>C3D-MotionBlur-Intensity-symbol</string>
</dict>
<key>program</key>
<string>C3D-GLSL-UNAVAILABLE</string>
<key>clientProgram</key>
<string>NO</string>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>metalFragmentShader</key>
<string>scn_motionblur_blur_12taps</string>
<key>metalVertexShader</key>
<string>scn_motionblur_vert</string>
</dict>
<key>renderMovableNodes</key>
<dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>onlyMovableNodes</key>
<true/>
<key>samples</key>
<integer>1</integer>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>a_position-symbol</key>
<dict>
<key>semantic</key>
<string>vertex</string>
</dict>
<key>C3D-MotionBlur-Intensity-symbol</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>C3D-oldViewProjectionTransform-symbol</key>
<dict>
<key>type</key>
<string>mat4</string>
</dict>
<key>C3D-viewProjectionInverseTransform-symbol</key>
<dict>
<key>type</key>
<string>mat4</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>VELOCITY</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba16f</string>
<key>scaleFactor</key>
<real>0.25</real>
</dict>
<key>blur-target</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
</dict>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_JitterCopyFirstFrame</string>
<string>SceneKit_JitterToEven</string>
<string>SceneKit_JitterToOdd</string>
<string>SceneKit_JitterResolve</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_JitterCopyFirstFrame</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-even</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterToOdd</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-odd</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler1</key>
<string>SceneKit-jitter-even</string>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterToEven</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-even</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler1</key>
<string>SceneKit-jitter-odd</string>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterResolve</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>SceneKit-jitter-odd</string>
<key>factor</key>
<string>C3D-jitter-factor-resolve</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
</dict>
<key>targets</key>
<dict>
<key>SceneKit-jitter-odd</key>
<dict>
<key>type</key>
<string>color</string>
<key>persistent</key>
<true/>
<key>format</key>
<string>rgba32f</string>
</dict>
<key>SceneKit-jitter-even</key>
<dict>
<key>type</key>
<string>color</string>
<key>persistent</key>
<true/>
<key>format</key>
<string>rgba32f</string>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>C3D-jitter-factor-resolve</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
</dict>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_JitterCopyFirstFrame</string>
<string>SceneKit_JitterToEven</string>
<string>SceneKit_JitterToOdd</string>
<string>SceneKit_JitterResolve</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_JitterCopyFirstFrame</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-even</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterToOdd</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-odd</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler1</key>
<string>SceneKit-jitter-even</string>
<key>factor</key>
<string>C3D-jitter-factor</string>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterToEven</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-even</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler1</key>
<string>SceneKit-jitter-odd</string>
<key>textureSampler0</key>
<string>COLOR</string>
<key>factor</key>
<string>C3D-jitter-factor</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterResolve</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>SceneKit-jitter-odd</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>clientProgram</key>
<false/>
</dict>
</dict>
<key>targets</key>
<dict>
<key>SceneKit-jitter-odd</key>
<dict>
<key>type</key>
<string>color</string>
<key>persistent</key>
<true/>
</dict>
<key>SceneKit-jitter-even</key>
<dict>
<key>type</key>
<string>color</string>
<key>persistent</key>
<true/>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>C3D-jitter-factor</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
</dict>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_renderMirroredScene</string>
<string>SceneKit_renderFloor</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_renderMirroredScene</key>
<dict>
<key>outputs</key>
<dict>
<key>depth</key>
<string>SceneKit-Floor-depth</string>
<key>color</key>
<string>SceneKit-Floor-color</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
</dict>
<key>SceneKit_renderFloor</key>
<dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>inputs</key>
<dict>
<key>u_floorReflectionDepth</key>
<string>SceneKit-Floor-depth</string>
<key>u_floorReflectionColor</key>
<string>SceneKit-Floor-color</string>
<key>u_floorNormal</key>
<string>u_floorNormal</string>
<key>u_floorTangent</key>
<string>u_floorTangent</string>
<key>u_floorCenter</key>
<string>u_floorCenter</string>
<key>u_floorExtent</key>
<string>u_floorExtent</string>
<key>u_floorReflectivity</key>
<string>u_floorReflectivity</string>
<key>u_floor_viewport</key>
<string>u_floor_viewport</string>
<key>u_floorMVP_i</key>
<string>u_floorMVP_i</string>
<key>u_floorPlane</key>
<string>u_floorPlane</string>
<key>u_floorFalloff</key>
<string>u_floorFalloff</string>
<key>u_floorFalloffStart</key>
<string>u_floorFalloffStart</string>
</dict>
<key>draw</key>
<string>DRAW_GEOMETRY</string>
<key>installViewport</key>
<false/>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>u_floorNormal</key>
<dict>
<key>type</key>
<string>vec3</string>
</dict>
<key>u_floorTangent</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>u_floorCenter</key>
<dict>
<key>type</key>
<string>vec3</string>
</dict>
<key>u_floorExtent</key>
<dict>
<key>type</key>
<string>vec2</string>
</dict>
<key>u_floor_viewport</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>u_floorReflectivity</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>u_floorMVP_i</key>
<dict>
<key>type</key>
<string>mat4</string>
</dict>
<key>u_floorPlane</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>u_floorFalloff</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>u_floorFalloffStart</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>SceneKit-Floor-depth</key>
<dict>
<key>type</key>
<string>depth</string>
</dict>
<key>SceneKit-Floor-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba</string>
</dict>
</dict>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>targets</key>
<dict>
<key>VELOCITY</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba16f</string>
<key>scaleFactor</key>
<integer>1</integer>
<key>global</key>
<true/>
<key>clearColor</key>
<string>0. 0. 0. 999999999.</string>
</dict>
</dict>
<key>sequence</key>
<array>
<string>SceneKit_renderScene</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_renderScene</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>color1</key>
<string>VELOCITY</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>sceneBackground</string>
</dict>
</dict>
</dict>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_renderScene</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_renderScene</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>layerMask</key>
<integer>3</integer>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>sceneBackground</string>
</dict>
</dict>
</dict>
</dict>
</plist>
  "sequence" : [
                "SceneKit_renderCIQuad"
                ],
  "targets" : {
    "SceneKit-CI-effect-depth" : {
      "type" : "depth"
    },
    "SceneKit-CI-effect-color" : {
      "type" : "color",
      "format" : "rgba",
      "usage" : ["shaderWrite", "shaderRead"]
    }
  },
  "symbols" : {
    "C3D-CIFilter_middleZ" : {
      "type" : "float"
    },
    "C3D-CIFilter_extent" : {
      "type" : "vec4"
    },
    "C3D-CIFilter_reverseZ" : {
        "type" : "float"
    }
  },
  "passes" : {
    "SceneKit_renderCIQuad" : {
      "inputs" : {
        "u_color" : {
          "target" : "SceneKit-CI-effect-color",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        },
        "u_middleZ" : "C3D-CIFilter_middleZ",
        "u_extent" : "C3D-CIFilter_extent",
        "u_reverseZ" : "C3D-CIFilter_reverseZ",
        "u_depth" : {
          "target" : "SceneKit-CI-effect-depth",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        }
      },
      "hasConstantAlpha" : false,
      "colorStates" : {
        "clear" : false
      },
      "depthStates" : {
        "clear" : false
      },
      "cullMode" : "none",
      "metalVertexShader" : "scn_filterCompositeVert",
      "metalFragmentShader" : "scn_filterCompositeFrag",
      "draw" : "none",
      "clientProgram" : false,
      "blendStates" : {
        "enable" : true,
        "colorDst" : "oneMinusSrcAlpha",
        "colorSrc" : "one"
      }
    },
attribute vec3 a_position;
varying vec2 TexCoord;
void main(void)
gl_Position = vec4(a_position, 1.0);
TexCoord = (a_position.xy + 1.0) * 0.5;
uniform vec3 CocScaleBias;
uniform sampler2D colorSampler;
uniform sampler2D depthSampler;
uniform vec2 u_inversePixelSize;
varying vec2 v_tcColor0;
varying vec2 v_tcColor1;
varying vec2 v_tcDepth0;
varying vec2 v_tcDepth1;
varying vec2 v_tcDepth2;
varying vec2 v_tcDepth3;
vec4 saturate(vec4 val)
    return clamp(val, vec4(0.), vec4(1.));
void main (void)
    
    vec4 dofRowDelta = vec4(0., 1., 2., 3.) * u_inversePixelSize.y * 0.25;
    vec2 rowOfs[4];
    rowOfs[0] = dofRowDelta.xx; 
    rowOfs[1] = dofRowDelta.xy;
    rowOfs[2] = dofRowDelta.xz;
    rowOfs[3] = dofRowDelta.xw;
    
    
    vec3 color;
    color  = texture2D( colorSampler, v_tcColor0.xy ).rgb;
    color += texture2D( colorSampler, v_tcColor1.xy ).rgb;
    color += texture2D( colorSampler, v_tcColor0.xy + rowOfs[2] ).rgb;
    color += texture2D( colorSampler, v_tcColor1.xy + rowOfs[2] ).rgb;
    color *= 0.25;
    
    vec4 depth;
    depth[0] = texture2D( depthSampler, v_tcDepth0.xy + rowOfs[0] ).r;
    depth[1] = texture2D( depthSampler, v_tcDepth1.xy + rowOfs[0] ).r;
    depth[2] = texture2D( depthSampler, v_tcDepth2.xy + rowOfs[0] ).r;
    depth[3] = texture2D( depthSampler, v_tcDepth3.xy + rowOfs[0] ).r;
    vec4 coc = abs(depth * CocScaleBias.x + CocScaleBias.y);
    depth[0] = texture2D( depthSampler, v_tcDepth0.xy + rowOfs[1] ).r;
    depth[1] = texture2D( depthSampler, v_tcDepth1.xy + rowOfs[1] ).r;
    depth[2] = texture2D( depthSampler, v_tcDepth2.xy + rowOfs[1] ).r;
    depth[3] = texture2D( depthSampler, v_tcDepth3.xy + rowOfs[1] ).r;
    coc 
 = max(coc, abs(depth * CocScaleBias.x + CocScaleBias.y));
    
    depth[0] = texture2D( depthSampler, v_tcDepth0.xy + rowOfs[2] ).r;
    depth[1] = texture2D( depthSampler, v_tcDepth1.xy + rowOfs[2] ).r;
    depth[2] = texture2D( depthSampler, v_tcDepth2.xy + rowOfs[2] ).r;
    depth[3] = texture2D( depthSampler, v_tcDepth3.xy + rowOfs[2] ).r;
    coc 
 = max(coc, abs(depth * CocScaleBias.x + CocScaleBias.y));
    
    depth[0] = texture2D( depthSampler, v_tcDepth0.xy + rowOfs[3] ).r;
    depth[1] = texture2D( depthSampler, v_tcDepth1.xy + rowOfs[3] ).r;
    depth[2] = texture2D( depthSampler, v_tcDepth2.xy + rowOfs[3] ).r;
    depth[3] = texture2D( depthSampler, v_tcDepth3.xy + rowOfs[3] ).r;
    coc 
 = max(coc, abs(depth * CocScaleBias.x + CocScaleBias.y));
    float maxCoc = max( max( coc.x, coc.y ), max( coc.z, coc.w ) );
    
    
gl_FragColor = vec4(color, maxCoc);
#ifdef ENABLE_CUBE_MAP
uniform samplerCube u_textureSampler0;
uniform float u_fresnelExponent;
varying vec4 v_normal;
#ifdef ENABLE_FOG
uniform vec4 u_fogColor;
#endif
#else 
uniform sampler2D u_textureSampler0;
#endif
varying vec4 v_vertexColor;
#ifdef ENABLE_ANIMATION
varying vec3 v_uv0;
varying vec2 v_uv1;
#else
varying vec2 v_uv0;
#endif
#if __VERSION__ > 120 
#ifndef texture2D
#define texture2D(tex,coord) texture( tex, coord )
#endif
#define textureCube(tex,coord) texture( tex, coord )
#endif
#ifdef ENABLE_SOFT
uniform sampler2D u_depthSampler0;
uniform vec4 u_softParameters; 
uniform mat4 u_invProj; 
varying float v_eyeLinearZ;
float ComputeSoftFactor()
    vec2 normalizedFragCoord = gl_FragCoord.xy * u_softParameters.zw;
float depthValue = texture2D(u_depthSampler0, gl_FragCoord.xy * u_softParameters.zw).x;
    
    vec3 screenPos = vec3(normalizedFragCoord, depthValue);
vec4 viewPos = u_invProj * vec4(screenPos * 2. - 1., 1.);
viewPos /= viewPos.w;
    
    float factor = clamp((v_eyeLinearZ - viewPos.z) * u_softParameters.x ,0. , 1.);
    
    
    
    return factor;
#endif
void main(){
#ifdef ENABLE_CUBE_MAP
    vec2 p = v_uv0 * 2. - 1.;
    float r = dot(p,p); 
    vec4 tex = textureCube(u_textureSampler0, v_normal.xyz) * clamp(9.6 - 10. * r, 0., 1.0);
    
    tex.rgb *= pow(r, u_fresnelExponent);
#else 
#ifdef ENABLE_ANIMATION 
    vec4 tex = mix(texture2D(u_textureSampler0, v_uv0.xy),
                   texture2D(u_textureSampler0, v_uv1.xy), v_uv0.z);
#else
    vec4 tex = texture2D(u_textureSampler0, v_uv0);
#endif 
#endif 
#ifdef ENABLE_SOFT
    tex *= ComputeSoftFactor();
#endif
    
    
#ifdef ENABLE_CUBE_MAP
    gl_FragColor.a = v_vertexColor.a * tex.a; 
#ifdef ENABLE_FOG
    gl_FragColor.rgb = mix(v_vertexColor.rgb + tex.rgb, u_fogColor.rgb, v_normal.a) * gl_FragColor.a; 
#else
    gl_FragColor.rgb = (v_vertexColor.rgb + tex.rgb) * gl_FragColor.a; 
#endif 
#else
    gl_FragColor = v_vertexColor * tex; 
#endif
attribute vec4 a_position;
varying vec2 uv;
void main(void)
    gl_Position = a_position;
    uv = (a_position.xy + 1.0) * 0.5;
attribute vec3 a_position;
varying vec2 TexCoord;
uniform mat4 u_textureMatrix;
void main(void)
gl_Position = vec4(a_position, 1.0);
    TexCoord = (u_textureMatrix * vec4(a_position.xy, 0., 1.)).xy * 0.5 + 0.5;
TexCoord.y = 1.0 - TexCoord.y;
uniform sampler2D textureSampler0;
uniform float factor;
varying vec2 TexCoord;
void main (void)
gl_FragColor =
texture2D(textureSampler0,TexCoord) * factor;
uniform sampler2D u_textureSampler0;
varying vec2 v_uv0;
varying vec4 v_vertexColor;
void main(){
    vec4 tex = texture2D(u_textureSampler0, v_uv0);
    tex.rgb *= tex.a; 
    
    vec4 col = v_vertexColor * tex;
gl_FragColor = vec4(col);
struct SCNShaderGeometry
vec4 position;
vec3 normal;
vec4 tangent;
vec4 color;
vec2 texcoords[8]; 
} _geometry;
attribute vec4 a_position;
uniform vec2 u_inversePixelSize;
varying vec4 v_texCoord;
void main(void)
gl_Position = a_position;
    vec2 tc = (a_position.xy + 1.0) * 0.5;
    vec4 offset = vec4(-0.5, 0.5, -0.5, 0.5);
    v_texCoord = tc.xxyy + offset * u_inversePixelSize.xyxy;
struct SCNShaderLight
vec4 intensity; 
vec3 direction; 
    
    
    float _att;
    vec3 dir; 
    float dist; 
varying vec4 v_vertexColor;
varying vec2 v_texCoord;
uniform sampler2D u_sampler;
void main()
    vec4 mask = texture2D(u_sampler, v_texCoord);
    gl_FragColor = v_vertexColor * mask;
varying vec4 v_vertexColor;
void main()
    gl_FragColor = v_vertexColor;
uniform sampler2D u_color;
uniform sampler2D u_depth;
uniform float     u_middleZ;
varying vec2 TexCoord;
void main (void)
gl_FragColor = texture2D(u_color,TexCoord);
    
#ifndef GL_ES
    gl_FragDepth = texture2D(u_depth,TexCoord).r;
    
    if(gl_FragDepth == 1.0){
        gl_FragDepth = u_middleZ;
    }
#endif
    
    
    
    
attribute vec4 a_position;
varying vec2 v_texCoord;
void main(void)
gl_Position = a_position;
    v_texCoord = (a_position.xy + 1.0) * 0.5;
uniform mat4 u_modelViewProjectionTransform;
attribute vec3 a_position;
void main()
    gl_Position = u_modelViewProjectionTransform * vec4(a_position, 1.);
uniform float u_floorReflectivity;
uniform sampler2D u_floorReflectionColor;
uniform vec4 u_floor_viewport;
#ifdef USE_FALLOFF
uniform mat4 u_floorMVP_i;
uniform vec4 u_floorPlane;
uniform float u_floorFalloff;
#ifdef USE_FALLOFF_START
uniform float u_floorFalloffStart;
#endif
uniform sampler2D u_floorReflectionDepth;
vec3 floorUnprojectPoint(vec3 screenPos)
    vec4 pTmp;
    pTmp.xyz = (2.0 * screenPos.xyz) - 1.0;
    pTmp.w = 1.0;
    pTmp = u_floorMVP_i * pTmp;
    pTmp /= pTmp.w;
    return vec3(pTmp);
#endif 
#pragma body
vec2 normalizedFragCoord = gl_FragCoord.xy * u_floor_viewport.zw;
normalizedFragCoord.xy += 0.2 * _surface._normalTS.xy;
vec4 floorColor = texture2D(u_floorReflectionColor, normalizedFragCoord);
float reflectionFactor = u_floorReflectivity;
#ifdef USE_FALLOFF
float floorDepth = texture2D(u_floorReflectionDepth, normalizedFragCoord).x;
vec3  floorPW = floorUnprojectPoint(vec3(normalizedFragCoord, floorDepth));
float floorDist = - dot(vec4(floorPW.xyz, 1.0), u_floorPlane);
#ifdef USE_FALLOFF_START
floorDist -= u_floorFalloffStart; 
#endif 
reflectionFactor *= 1.0 - clamp(floorDist / u_floorFalloff, 0.0, 1.0);
#endif 
floorColor *= reflectionFactor; 
_output.color.rgb *= (1. - floorColor.a); 
_output.color.rgba += floorColor.rgba; 
void main (void)
gl_FragColor =
vec4(1.0,0.0,1.0,1.0);
float hash(vec2 p)
    p  = fract(p * vec2(443.8975,397.2973));
    p += dot(p.xy, p.yx+19.19);
    return fract(p.x * p.y);
#pragma body
float x = hash(u_modelTransform[3].xy);
_output.color = vec4(x+1./255.);
#ifdef USE_PER_VERTEX_LIGHTING
varying vec3 v_diffuse;
#ifdef USE_SPECULAR
varying vec3 v_specular;
#endif
#endif
#if defined(USE_POSITION) && (USE_POSITION == 2)
varying vec3 v_position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2)
varying vec3 v_normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
varying vec3 v_tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
varying vec3 v_bitangent;
#endif
#ifdef USE_AMBIENT_LIGHTING
uniform vec4 u_ambientLightColor;
#endif
#ifdef USE_DIFFUSE_MAP
uniform sampler2D u_diffuseTexture;
#ifdef USE_DIFFUSE_INTENSITY
uniform float u_diffuseIntensity;
#endif
#elif defined(USE_DIFFUSE_COLOR)
uniform vec4 u_diffuseColor;
#endif
#ifdef USE_NORMAL_MAP
uniform sampler2D u_normalTexture;
#ifdef USE_NORMAL_INTENSITY
uniform float u_normalIntensity;
#endif
#endif
#ifdef USE_SHININESS
uniform float u_materialShininess;
#endif
#ifdef USE_SPECULAR
#ifdef USE_SPECULAR_MAP
uniform sampler2D u_specularTexture;
#ifdef USE_SPECULAR_INTENSITY
uniform float u_specularIntensity;
#endif
#elif defined(USE_SPECULAR_COLOR)
uniform vec4 u_specularColor;
#endif
#endif 
#ifdef USE_AMBIENT_MAP
uniform sampler2D u_ambientTexture;
#ifdef USE_AMBIENT_INTENSITY
uniform float u_ambientIntensity;
#endif
#elif defined(USE_AMBIENT_COLOR)
uniform vec4 u_ambientColor;
#endif
#ifdef USE_REFLECTIVE_MAP
uniform sampler2D u_reflectiveTexture;
#elif defined(USE_REFLECTIVE_COLOR)
uniform vec4 u_reflectiveColor;
#endif
#if defined(USE_REFLECTIVE_CUBEMAP)
uniform samplerCube u_reflectiveTexture;
#endif
#if defined(USE_REFLECTIVE_CUBEMAP)
uniform mat4 u_viewToCubeWorld;
#endif
#ifdef USE_REFLECTIVE_INTENSITY
uniform float u_reflectiveIntensity;
#endif
#ifdef USE_FRESNEL
uniform vec3 u_fresnel; 
#endif
#ifdef USE_EMISSION_MAP
uniform sampler2D u_emissionTexture;
#ifdef USE_EMISSION_INTENSITY
uniform float u_emissionIntensity;
#endif
#elif defined(USE_EMISSION_COLOR)
uniform vec4 u_emissionColor;
#endif
#ifdef USE_MULTIPLY_MAP
uniform sampler2D u_multiplyTexture;
#ifdef USE_MULTIPLY_INTENSITY
uniform float u_multiplyIntensity;
#endif
#elif defined(USE_MULTIPLY_COLOR)
uniform vec4 u_multiplyColor;
#endif
#ifdef USE_TRANSPARENT_MAP
uniform sampler2D u_transparentTexture;
#ifdef USE_TRANSPARENT_INTENSITY
uniform float u_transparentIntensity;
#endif
#elif defined(USE_TRANSPARENT_COLOR)
uniform vec4 u_transparentColor;
#endif
#ifdef USE_VERTEX_COLOR
varying vec4 v_vertexColor;
#endif
#ifdef USE_NODE_OPACITY 
uniform float u_nodeOpacity;
#endif
#ifdef USE_TRANSPARENCY 
uniform float u_transparency;
#endif
#ifdef USE_DOUBLE_SIDED
uniform float u_orientationPreserved;
#endif
#ifdef USE_TIME
uniform float u_time;
#endif
#ifdef USE_FOG
uniform vec4 u_fogColor;
uniform vec3 u_fogParameters; 
#endif
float saturate(float x) {
    return clamp(x, 0., 1.);
vec2 saturate(vec2 x) {
    return clamp(x, vec2(0.), vec2(1.));
vec3 saturate(vec3 x) {
    return clamp(x, vec3(0.), vec3(1.));
vec4 saturate(vec4 x) {
    return clamp(x, vec4(0.), vec4(1.));
vec4 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)
    vec4 color = vec4(0.,0.,0., surface.diffuse.a);
    
    vec3 D = lighting.diffuse;
#ifdef USE_AMBIENT_LIGHTING
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    D += lighting.ambient * surface.ambientOcclusion;
#elif defined(LOCK_AMBIENT_WITH_DIFFUSE)
    D += lighting.ambient;
#endif
#endif 
#ifdef USE_EMISSION_AS_SELFILLUMINATION
    D += surface.emission.rgb;
#endif
    
    
    
    color.rgb = surface.diffuse.rgb * D;
#if 1 
#ifdef USE_SPECULAR
    vec3 S = lighting.specular;
#elif defined(USE_REFLECTIVE)
    vec3 S = vec3(0.);
#endif
#ifdef USE_REFLECTIVE
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    S += surface.reflective.rgb * surface.ambientOcclusion;
#else
    S += surface.reflective.rgb;
#endif
#endif
#ifdef USE_SPECULAR
    S *= surface.specular.rgb;
#endif
#if defined(USE_SPECULAR) || defined(USE_REFLECTIVE)
    color.rgb += S;
#endif
#else
#ifdef USE_SPECULAR
    color.rgb += surface.specular.rgb * lighting.specular;
#endif
#ifdef USE_REFLECTIVE
    color.rgb += surface.reflective.rgb * (lighting.diffuse + lighting.ambient);
#endif
#endif 
#if defined(USE_AMBIENT) && !defined(USE_AMBIENT_AS_AMBIENTOCCLUSION)
    color.rgb += surface.ambient.rgb * lighting.ambient;
#endif
#if defined(USE_EMISSION) && !defined(USE_EMISSION_AS_SELFILLUMINATION)
    color.rgb += surface.emission.rgb;
#endif
#ifdef USE_MULTIPLY
    color.rgb *= surface.multiply.rgb;
#endif
#ifdef USE_MODULATE
    color.rgb *= lighting.modulate;
#endif
    return color;
struct SCNOutput
    vec4 color;
} _output;
void main(void)
#ifdef USE_TEXCOORD
    __DoTexcoord__
#endif
    
    _surface.ambientOcclusion = 1.0;
    
    
#ifdef USE_AMBIENT_MAP
    _surface.ambient = texture2D(u_ambientTexture, _surface.ambientTexcoord);
#ifdef USE_AMBIENT_INTENSITY
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    _surface.ambientOcclusion = mix(1., _surface.ambient.r, u_ambientIntensity);
#else
    _surface.ambient *= u_ambientIntensity;
#endif
#endif
#elif defined(USE_AMBIENT_COLOR)
    _surface.ambient = u_ambientColor;
#elif defined(USE_AMBIENT)
    _surface.ambient = vec4(0.);
#endif
#if defined(USE_AMBIENT) && defined(USE_VERTEX_COLOR)
    _surface.ambient *= v_vertexColor;
#endif
    
    
#ifdef USE_DIFFUSE_MAP
    _surface.diffuse = texture2D(u_diffuseTexture, _surface.diffuseTexcoord);
#ifdef USE_DIFFUSE_INTENSITY
    _surface.diffuse.rgb *= u_diffuseIntensity;
#endif
#elif defined(USE_DIFFUSE_COLOR)
    _surface.diffuse = u_diffuseColor;
#elif defined(USE_DIFFUSE)
    _surface.diffuse = vec4(0.,0.,0.,1.);
#endif
#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)
    _surface.diffuse *= v_vertexColor;
#endif
    
    
#ifdef USE_SPECULAR_MAP
    _surface.specular = texture2D(u_specularTexture, _surface.specularTexcoord);
#ifdef USE_SPECULAR_INTENSITY
    _surface.specular *= u_specularIntensity;
#endif
#elif defined(USE_SPECULAR_COLOR)
    _surface.specular = u_specularColor;
#elif defined(USE_SPECULAR)
    _surface.specular = vec4(0.);
#endif
    
    
#ifdef USE_EMISSION_MAP
    _surface.emission = texture2D(u_emissionTexture, _surface.emissionTexcoord);
#ifdef USE_EMISSION_INTENSITY
    _surface.emission *= u_emissionIntensity;
#endif
#elif defined(USE_EMISSION_COLOR)
    _surface.emission = u_emissionColor;
#elif defined(USE_EMISSION)
    _surface.emission = vec4(0.);
#endif
    
    
#ifdef USE_MULTIPLY_MAP
    _surface.multiply = texture2D(u_multiplyTexture, _surface.multiplyTexcoord);
#ifdef USE_MULTIPLY_INTENSITY
    _surface.multiply = mix(vec4(1.), _surface.multiply, u_multiplyIntensity);
#endif
#elif defined(USE_MULTIPLY_COLOR)
    _surface.multiply = u_multiplyColor;
#elif defined(USE_MULTIPLY)
    _surface.multiply = vec4(1.);
#endif
    
    
#ifdef USE_TRANSPARENT_MAP
    _surface.transparent = texture2D(u_transparentTexture, _surface.transparentTexcoord);
#ifdef USE_TRANSPARENT_INTENSITY
    _surface.transparent *= u_transparentIntensity;
#endif
#elif defined(USE_TRANSPARENT_COLOR)
    _surface.transparent = u_transparentColor;
#elif defined(USE_TRANSPARENT)
    _surface.transparent = vec4(1.);
#endif
    
    
#if (defined USE_NORMAL) && (USE_NORMAL == 2)
#ifdef USE_DOUBLE_SIDED
    _surface.normal = normalize(v_normal.xyz) * u_orientationPreserved * ((float(gl_FrontFacing) * 2.0) - 1.0);
#else
    _surface.normal = normalize(v_normal.xyz);
#endif
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    _surface.tangent = v_tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    _surface.bitangent = v_bitangent;
#endif
#if (defined USE_POSITION) && (USE_POSITION == 2)
    _surface.position = v_position;
#endif
#if (defined USE_VIEW) && (USE_VIEW == 2)
    _surface.view = normalize(-v_position);
#endif
#ifdef USE_NORMAL_MAP
    mat3 ts2vs = mat3(_surface.tangent, _surface.bitangent, _surface.normal);
    _surface._normalTS = texture2D(u_normalTexture, _surface.normalTexcoord).rgb * 2. - 1.;
    
#ifdef USE_NORMAL_INTENSITY
    _surface._normalTS = mix(vec3(0., 0., 1.), _surface._normalTS, u_normalIntensity);
#endif
    
    _surface.normal.rgb = normalize(ts2vs * _surface._normalTS);
#else
    _surface._normalTS = vec3(0., 0., 0.);
#endif
    
    
#ifdef USE_REFLECTIVE_MAP
    vec3 refl = reflect( -_surface.view, _surface.normal );
    float m = 2.0 * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.0)*(refl.z+1.0));
    _surface.reflective = texture2D(u_reflectiveTexture,vec2(vec2(refl.x,-refl.y) / m) + 0.5) ;
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective.rgb *= u_reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_CUBEMAP)
    vec3 refl = reflect( _surface.position, _surface.normal );
    _surface.reflective = textureCube(u_reflectiveTexture, mat3(u_viewToCubeWorld) * refl); 
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective.rgb *= u_reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_COLOR)
    _surface.reflective = u_reflectiveColor;
#elif defined(USE_REFLECTIVE)
    _surface.reflective = vec4(0.);
#endif
#ifdef USE_FRESNEL
    _surface.fresnel = u_fresnel.x + u_fresnel.y * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), u_fresnel.z);
    _surface.reflective *= _surface.fresnel;
#endif
#ifdef USE_SHININESS
    _surface.shininess = u_materialShininess;
#endif
    
    
    
    
#ifdef USE_SURFACE_MODIFIER
__DoSurfaceModifier__
#endif
    
    
    
#ifdef USE_AMBIENT_LIGHTING
    _lightingContribution.ambient = u_ambientLightColor.rgb;
#elif defined(USE_AMBIENT)
    _lightingContribution.ambient = vec3(0.);
#endif
    
#ifdef USE_LIGHTING
#ifdef USE_PER_PIXEL_LIGHTING
    _lightingContribution.diffuse = vec3(0.);
#ifdef USE_MODULATE
    _lightingContribution.modulate = vec3(1.);
#endif
#ifdef USE_SPECULAR
    _lightingContribution.specular = vec3(0.);
#endif
    
    __DoLighting__
    
#else 
    _lightingContribution.diffuse = v_diffuse;
#ifdef USE_SPECULAR
    _lightingContribution.specular = v_specular;
#endif
#endif
    
    
#ifdef AVOID_OVERLIGHTING
    _lightingContribution.diffuse = clamp(_lightingContribution.diffuse, vec3(0.), vec3(1.));
#ifdef USE_SPECULAR
    _lightingContribution.specular = clamp(_lightingContribution.specular, vec3(0.), vec3(1.));
#endif 
#endif 
#else 
    _lightingContribution.diffuse = vec3(1.);
#endif 
    
    
    _output.color = illuminate(_surface, _lightingContribution);
    
#ifdef USE_FOG
    float fogFactor = pow(clamp(length(_surface.position.xyz) * u_fogParameters.x + u_fogParameters.y, 0., u_fogColor.a), u_fogParameters.z);
    _output.color.rgb = mix(_output.color.rgb, u_fogColor.rgb * _output.color.a, fogFactor);
#endif
    
#ifndef DIFFUSE_PREMULTIPLIED
    _output.color.rgb *= _surface.diffuse.a;
#endif
    
#ifdef USE_TRANSPARENT 
    
#ifdef USE_TRANSPARENCY
    _surface.transparent *= u_transparency;
#endif
    
#ifdef USE_TRANSPARENCY_RGBZERO
#ifdef USE_NODE_OPACITY
    _output.color *= u_nodeOpacity;
#endif
    
    _surface.transparent.a = (_surface.transparent.r * 0.212671) + (_surface.transparent.g * 0.715160) + (_surface.transparent.b * 0.072169);
    _output.color *= (vec4(1.) - _surface.transparent);
#else 
    _output.color *= _surface.transparent.a;
#endif
#else
#ifdef USE_TRANSPARENCY 
    _output.color *= u_transparency;
#endif
#endif
    
#ifdef USE_FRAGMENT_MODIFIER
__DoFragmentModifier__
#endif
    
#ifdef USE_DISCARD
    if (_output.color.a == 0.) 
        discard;
#endif
    
    gl_FragColor = _output.color;
uniform mat4 u_modelTransform;
#define MOD2 vec2(443.8975,397.2973)
float hash(vec2 p)
    p  = fract(p * MOD2);
    p += dot(p.xy, p.yx+19.19);
    return fract(p.x * p.y);
void main()
    float x = hash(u_modelTransform[3].xy);
gl_FragColor = vec4(vec3(x+1./255.),1.);
uniform samplerCube textureSampler0;
varying vec3 TexCoord;
#if __VERSION__ > 120 
#define textureCube(tex,coord) texture( tex, coord )
#endif
void main (void)
    
gl_FragColor = textureCube(textureSampler0,TexCoord);
struct SCNShaderSurface
vec3 view; 
vec3 position; 
vec3 normal; 
vec3 tangent; 
vec3 bitangent; 
float shininess;
    float fresnel;
    float ambientOcclusion;
vec3 _normalTS; 
uniform sampler2D sceneColor;
uniform sampler2D authoringColor;
varying vec2 uv;
void main()
    vec4 scene = texture2D(sceneColor, uv);
    vec4 authoring = texture2D(authoringColor, uv);
    
    gl_FragColor = mix(scene, authoring, authoring.a);
uniform sampler2D downSampler;
uniform sampler2D depthSampler;
uniform vec3 CocScaleBias;
varying vec2 v_texCoord;
void main (void)
    vec4 down = texture2D( downSampler, v_texCoord);
    float depth = texture2D( depthSampler, v_texCoord).r;
    float coc = step(0., (depth * CocScaleBias.x + CocScaleBias.y)); 
gl_FragColor = vec4(down.rgb, coc * down.a);
    
    
#ifdef USE_PCF
#ifdef GL_EXT_shadow_samplers 
#extension GL_EXT_shadow_samplers : require
#endif
#endif
#if MAX_SAMPLE > 1
uniform vec4 u_kernel[MAX_SAMPLE];
#endif
uniform vec4 shadowColor;
uniform sampler2D colorSampler;
uniform sampler2D depthSampler;
#ifdef USE_PCF
#ifdef GL_EXT_shadow_samplers 
    uniform sampler2DShadow lightDepthSampler;
    #define __shadow2DProj(tex,coord) shadow2DProjEXT( tex, coord )
#elif __VERSION__ <= 120 
    uniform sampler2DShadow lightDepthSampler;
    #define __shadow2DProj(tex,coord) shadow2DProj( tex, coord ).x
#else 
    uniform sampler2DShadow lightDepthSampler;
    #define __shadow2DProj(tex,coord) textureProj( tex, coord )
#endif
#else 
    uniform sampler2D lightDepthSampler;
    #define __shadow2DProj(tex, coord) clamp(coord.z - texture2DProj(tex, coord).x * coord.w, 0.0, 1.0);
#endif
uniform mat4  camera_MVP_i;
uniform mat4  light_MVP;
uniform vec3  u_lightPos;
uniform vec3  u_lightDir;
uniform vec3  u_lightSpotAtt;
uniform float shadowRadius;
#ifndef TARGET_OS_IPHONE
    #ifdef SPOT_SHADOW
        #define USE_SPOT_ATTENUATION 1
    #else
        #define USE_SPOT_ATTENUATION 0
    #endif
#else
    #define USE_SPOT_ATTENUATION 0
#endif
varying vec2 TexCoord;
vec3 unprojectPoint(vec3 screenPos)
vec4 pTmp;
    pTmp.xyz = (2.0 * screenPos.xyz) - 1.0;
pTmp.w = 1.0;
pTmp = camera_MVP_i * pTmp;
    pTmp /= pTmp.w;
return vec3(pTmp);
void main (void)
    
    vec4 color = texture2D(colorSampler, TexCoord);
    
float depthValue = texture2D(depthSampler, TexCoord).x;
vec3 worldPos = unprojectPoint(vec3(TexCoord, depthValue));
vec4 lightScreen =  light_MVP * vec4(worldPos, 1.0);
    
    
#if USE_SPOT_ATTENUATION
    vec3 lightToFragment = normalize(u_lightPos - worldPos);
    
    
    float att;
    if (u_lightSpotAtt.z == 0.0)
        att = step(u_lightSpotAtt.x, dot(lightToFragment, u_lightDir) + 0.00004);
    else
        att = pow(clamp(dot(lightToFragment, u_lightDir) * u_lightSpotAtt.x + u_lightSpotAtt.y, 0.0, 1.0), u_lightSpotAtt.z);
    
    if (att == 0.) {
        gl_FragColor = color.rgba;
        return;
    }
#endif 
    
    
#if MAX_SAMPLE == 1
    float shadow = __shadow2DProj(lightDepthSampler, lightScreen);
#else
    
    float filteringSizeFactor = shadowRadius * lightScreen.w;
    
    
    float totalAccum = 0.0;
    for(int i=0; i<MAX_SAMPLE; i++){
        totalAccum += __shadow2DProj(lightDepthSampler, lightScreen + (u_kernel[i] * filteringSizeFactor));
    }
    
    float shadow = totalAccum / float(MAX_SAMPLE);
#endif
    
#if !USE_SPOT_ATTENUATION
    shadow *= step(0., lightScreen.w);
#endif
    
    
    
    shadow *= shadowColor.a;
#if USE_SPOT_ATTENUATION
    shadow = shadow * att;
#endif
    
    
    gl_FragColor = mix(color.rgba, vec4(shadowColor.rgb, 1.0),  shadow);
varying vec2 TexCoord;
uniform sampler2D textureSampler0;
uniform vec2 offsets[MAX_SAMPLE];
uniform float weights[MAX_SAMPLE];
uniform int n_sample;
void main (void)
    int i;
    vec4 accum = vec4(0.0);
    for(i=0;i<n_sample;i++){
        accum += texture2D(textureSampler0, TexCoord+offsets[i]) *  weights[i];
    }
gl_FragColor = accum;
#extension GL_ARB_shader_texture_lod : enable
uniform sampler2D textureSampler0;
varying vec2 TexCoord;
void main (void)
gl_FragColor =
texture2DLod(textureSampler0,TexCoord, 0.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 1.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 2.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 3.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 4.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 5.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 6.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 7.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 8.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 9.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 10.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 11.0);    
    gl_FragColor /= 12.0;
uniform sampler2D colorSampler;
uniform sampler2D smallBlurSampler;
uniform sampler2D largeBlurSampler;
uniform sampler2D depthSampler;
uniform vec2 u_inversePixelSize;
uniform vec4 dofLerpScale;
uniform vec4 dofLerpBias;
uniform vec3 CocScaleBias;
varying vec2 v_texCoord;
float saturate(float val)
    return clamp(val, 0., 1.);
vec4 saturate(vec4 val)
    return clamp(val, vec4(0.), vec4(1.));
vec4 tex2Doffset(sampler2D s, vec2 tc, vec2 offset )
  return texture2D( s, tc + offset * u_inversePixelSize );
vec3 GetSmallBlurSample( vec3 unblur, vec2 tc )
    
    
    
    vec3 sum = tex2Doffset( colorSampler, tc, vec2(+0.5, -1.5) ).rgb;
    sum += tex2Doffset( colorSampler, tc, vec2(-1.5, -0.5) ).rgb;
    sum += tex2Doffset( colorSampler, tc, vec2(-0.5, +1.5) ).rgb;
    sum += tex2Doffset( colorSampler, tc, vec2(+1.5, +0.5) ).rgb;
    return (4.0 * sum + unblur) / 17.;
vec4 InterpolateDof( vec3 unblur, vec3 small, vec3 med, vec3 large, float t )
    
    
    
    
    
    
    
    
    vec4 weights = saturate( t * dofLerpScale + dofLerpBias );
    weights.yz = min( weights.yz, 1. - weights.xy );
    
    
    
    
    vec3 color = weights.x * unblur + weights.y * small + weights.z * med + weights.w * large;
    return vec4(color, 1.);
    
    
    
    
#define DEBUG 0
void main (void)
    vec3 unblur = texture2D( colorSampler, v_texCoord ).rgb;
    vec3 small 
= GetSmallBlurSample(unblur, v_texCoord );
    vec4 med 
= texture2D( smallBlurSampler, v_texCoord );
    vec3 large 
= texture2D( largeBlurSampler, v_texCoord ).rgb;
    float nearCoc = med.a;
    float depth = texture2D( depthSampler, v_texCoord ).r;
    
    
    float farCoc = saturate( - (CocScaleBias.x * depth + CocScaleBias.y) );
    float coc;
    
    
    
    
    {
        
        coc = max( nearCoc, farCoc  );
    }
    gl_FragColor = InterpolateDof( unblur, small, med.rgb, large.rgb, coc );
#if DEBUG
    if (v_texCoord.x < 0.15) {
        gl_FragColor = vec4(unblur, 1.);
    } else if (v_texCoord.x < 0.3) {
        gl_FragColor = vec4(small, 1.);
    } else if (v_texCoord.x < 0.45) {
        gl_FragColor = med;
    } else if (v_texCoord.x < 0.6) {
        gl_FragColor = vec4(large, 1.);
        
    } else if (v_texCoord.x < 0.70) {
        gl_FragColor = vec4(nearCoc, nearCoc, nearCoc, 1.);
    } else if (v_texCoord.x < 0.8){
        gl_FragColor = vec4(farCoc, farCoc, farCoc, 1.);
    }
#endif
    
uniform mat4 u_modelViewProjectionTransform;
attribute vec4 a_position;
attribute vec4 a_color;
varying vec3 v_vertexCenter;
void main()
    vec3 pos = a_position.xyz;
    int id = int(a_position.w); 
    gl_Position = (u_modelViewProjectionTransform * vec4(pos, 1.0));
    
    float s = 1.;
    mat3 centers = mat3(vec3(s, 0. ,0.), vec3(0., s, 0.), vec3(0., 0., s));
    v_vertexCenter = centers[id];
  uniform vec3 u_floorNormal;
  uniform vec4 u_floorTangent;
  uniform vec3 u_floorCenter;
  uniform vec2 u_floorExtent;
#pragma body
  vec3 floorBitangent =  normalize(cross(u_floorTangent.xyz, u_floorNormal));
  _geometry.position.xyz = u_floorCenter.xyz + u_floorExtent.x * (_geometry.position.x * u_floorTangent.xyz) + u_floorExtent.y * (_geometry.position.y * floorBitangent);
  _geometry.normal = u_floorNormal;
  _geometry.tangent = u_floorTangent;
  vec2 tc;
  if (u_floorNormal.y != 0.)
    tc = _geometry.position.xz * 0.01;
  else if (u_floorNormal.z != 0.)
    tc = _geometry.position.xy * 0.01;
  else
    tc = _geometry.position.yz * 0.01;
  for (int i = 0; i < kSCNTexcoordCount; ++i)
    _geometry.texcoords[i] = tc;
uniform mat4 u_modelViewProjectionTransform;
uniform mat4 u_transform;
uniform vec4 u_color;
attribute vec3 a_position;
varying vec4 v_vertexColor;
void main()
    gl_Position = u_modelViewProjectionTransform * u_transform * vec4(a_position, 1.);
    v_vertexColor = u_color;
uniform mat4 u_modelViewProjectionTransform;
attribute vec3 a_position;
attribute vec4 a_color;
attribute vec2 a_texCoord0;
varying vec4 v_vertexColor;
varying vec2 v_texCoord;
void main()
    gl_Position = u_modelViewProjectionTransform * vec4(a_position, 1.);
    v_vertexColor = a_color;
    v_texCoord = a_texCoord0;
attribute vec3 a_position;
uniform mat4 u_m;
varying vec2 TexCoord;
void main(void)
gl_Position = u_m * vec4(a_position, 1.0);
TexCoord = (gl_Position.xy + 1.0) * 0.5;
attribute vec4 a_position;
uniform vec2 u_inversePixelSize;
varying vec2 v_tcColor0;
varying vec2 v_tcColor1;
varying vec2 v_tcDepth0;
varying vec2 v_tcDepth1;
varying vec2 v_tcDepth2;
varying vec2 v_tcDepth3;
void main(void)
gl_Position = a_position;
    vec2 tc = (a_position.xy + 1.0) * 0.5;
    v_tcColor0 = tc + vec2( -1.5, -1.5) * u_inversePixelSize * 0.25;
    v_tcColor1 = tc + vec2( +0.5, -1.5) * u_inversePixelSize * 0.25;
    v_tcDepth0 = tc + vec2( -2., -2. ) * u_inversePixelSize * 0.25;
    v_tcDepth1 = tc + vec2( -1., -2. ) * u_inversePixelSize * 0.25;
    v_tcDepth2 = tc + vec2( +0., -2. ) * u_inversePixelSize * 0.25;
    v_tcDepth3 = tc + vec2( +1., -2. ) * u_inversePixelSize * 0.25;
attribute vec2 a_texCoord1; 
attribute vec4 a_position; 
attribute vec3 a_texCoord0; 
attribute vec4 a_color; 
#ifdef ENABLE_STRETCH
attribute vec4 a_texCoord2; 
uniform float u_stretchFactor;
#elif defined(ENABLE_ORIENTATION_FREE)
attribute vec4 a_texCoord2; 
mat3 axisangle_to_matrix(vec4 axis_angle)
float c = cos(axis_angle.w);
    float s = sin(axis_angle.w);
    float t = 1. - c;
    
    mat3 m;
    m[0][0] = c + axis_angle.x * axis_angle.x * t;
    m[1][1] = c + axis_angle.y * axis_angle.y * t;
    m[2][2] = c + axis_angle.z * axis_angle.z * t;
    
float tmp1 = axis_angle.x * axis_angle.y * t;
    float tmp2 = axis_angle.z * s;
    m[1][0] = tmp1 + tmp2;
    m[0][1] = tmp1 - tmp2;
    
    tmp1 = axis_angle.x * axis_angle.z * t;
    tmp2 = axis_angle.y * s;
    m[2][0] = tmp1 - tmp2;
    m[0][2] = tmp1 + tmp2;
    
    tmp1 = axis_angle.y*axis_angle.z*t;
    tmp2 = axis_angle.x*s;
    m[2][1] = tmp1 + tmp2;
    m[1][2] = tmp1 - tmp2;
    return m;
#endif
#ifdef ENABLE_FOG
uniform mediump vec4 u_fogColor;
uniform vec3 u_fogParameters; 
#endif
#ifdef ENABLE_SOFT
varying float v_eyeLinearZ;
#endif
#ifdef ENABLE_CUBE_MAP
uniform mat4 u_viewToCubeWorld;
varying vec4 v_normal;
#endif
#ifdef ENABLE_ANIMATION
#define REPEAT 0
#define CLAMP 1
#define AUTOREVERSE  2
uniform vec4 u_frameSize; 
float __modf(float value, out float intValue)
float fracValue = fract(value);
intValue = value - fracValue;
return fracValue;
vec4 ComputeUVS(vec2 iNormUV, float iFrame)
vec4 outUV;
#if ENABLE_ANIMATION == CLAMP
    
    iFrame = clamp(iFrame, 0., u_frameSize.w - 1.); 
    
    float intFrame;
    float frameFrac = __modf(iFrame, intFrame);
    vec2 frame;
    frame.x = __modf(intFrame * u_frameSize.x, frame.y);
    frame.y *= u_frameSize.y;
    
    outUV.xy = frame + iNormUV * u_frameSize.xy;
    outUV.w = frameFrac;
    outUV.z = ((frame.x + u_frameSize.x) == 1.)?1.:0.; 
#elif ENABLE_ANIMATION == REPEAT
    
    float tmp = iFrame * u_frameSize.x;
    
    vec2 frame;
    frame.y = tmp - fract(tmp);
    frame.x = fract(tmp) * u_frameSize.z;
    
    float frameFrac = fract(frame.x);
    frame.x -= frameFrac;
    
    outUV.xy = (frame + iNormUV) * u_frameSize.xy;
    outUV.w = frameFrac;
    outUV.z = (frame.x == (u_frameSize.z - 1.))?1.:0.; 
#else 
    
    float invFrameCount = u_frameSize.x * u_frameSize.y;
    float normFrame = iFrame * invFrameCount;
    float lastFrame = u_frameSize.w - 1.;
    float frameIndex = fract(normFrame) * u_frameSize.w;
    if (fract(normFrame * 0.5) > 0.5) {
        frameIndex = (lastFrame-frameIndex);
    }
    frameIndex = clamp(frameIndex, 0., lastFrame); 
    
    float tmp = frameIndex * u_frameSize.x;
    
    vec2 frame;
    frame.y = tmp - fract(tmp);
    
    frame.x = fract(tmp) * u_frameSize.z;
    
    float frameFrac = fract(frame.x);
    frame.x -= frameFrac;
    
    outUV.xy = (frame + iNormUV) * u_frameSize.xy;
    
    outUV.w = frameFrac;
    outUV.z = (frame.x == (u_frameSize.z - 1.))?1.:0.; 
#endif
return outUV;
#endif
uniform mat4 viewTransform; 
uniform mat4 u_projectionTransform;
#ifdef ENABLE_LIGHTING
uniform vec3 u_lightPosition0; 
uniform vec4 u_lightColor0;
#endif
#ifdef ENABLE_COLOR_RAMP
uniform sampler2D u_colorRamp;
#endif
#ifdef ENABLE_ANIMATION
varying vec3 v_uv0;
varying vec2 v_uv1;
#else
varying vec2 v_uv0;
#endif
varying vec4 v_vertexColor;
void main()
    
    vec4 viewPos = viewTransform * vec4(a_position.xyz, 1);
#ifdef ENABLE_STRETCH
    
    vec4 viewDir = viewTransform * vec4(a_texCoord2.xyz, 0);
    viewDir *= u_stretchFactor;
    
    
    viewPos.xyz += (a_texCoord1.y > 0.) ? viewDir.xyz : vec3(0.);
    
    
    vec2 u = normalize(viewDir.xy); 
    vec2 r = vec2(-u.y, u.x);
    vec2 off = r * a_texCoord1.x + u * a_texCoord1.y ; 
    viewPos.xy += off * a_texCoord0.y; 
    vec3 N = normalize(vec3(-off.x, -off.y, -2));
    
#else 
    
    
    float sn = sin(a_position.w);
    float cs = cos(a_position.w);
    
    vec2 dir = vec2( a_texCoord1.x * cs - a_texCoord1.y * sn,  a_texCoord1.y * cs + a_texCoord1.x * sn);
    dir *= a_texCoord0.y;
#ifdef ENABLE_ORIENTATION_FREE
    
    
    mat3 vt = mat3(viewTransform[0].xyz, viewTransform[1].xyz, viewTransform[2].xyz);
    mat3 mat = vt * axisangle_to_matrix(a_texCoord2); 
    
#ifdef ENABLE_CUBE_MAP
    vec3 N = mat[0] * dir.x + mat[1] * dir.y + mat[2];
    viewPos.xy += dir;
#else
    vec3 off = mat[0] * dir.x + mat[1] * dir.y;
    viewPos.xyz += off;
#endif
    
    
#elif defined(ENABLE_BILLBOARD_VIEW)
    vec3 u = vec3(0,1,0);
    vec3 r = normalize(cross(u, -viewPos.xyz));
    vec3 off = dir.x * r + dir.y * u;
    viewPos.xyz += off;
    vec3 N = normalize(vec3(-off.x/a_texCoord0.y, -off.y/a_texCoord0.y, -2));
#elif defined(ENABLE_BILLBOARD_Y)
    vec3 u = (viewTransform * vec4(0, 1, 0, 0)).xyz;
    vec3 r = normalize(cross(u, vec3(0,0,1))); 
    vec3 off = dir.x * r + dir.y * u;
    viewPos.xyz += off;
    vec3 N = normalize(vec3(-off.x/a_texCoord0.y, -off.y/a_texCoord0.y, -2));
    
#else 
    viewPos.xy += dir;
    vec3 N = normalize(vec3(-dir.x, -dir.y, -2));
    
#endif 
#endif 
#ifdef ENABLE_CUBE_MAP
#ifdef ENABLE_ORIENTATION_FREE
    v_normal.xyz = N;
#else
    vec3 refl = reflect( viewPos.xyz, N );
    v_normal.xyz = mat3(u_viewToCubeWorld) * refl;
#endif 
#endif
#ifdef ENABLE_COLOR_RAMP
    v_vertexColor = a_color * texture2D(u_colorRamp, a_texCoord0.xx);
#else 
    v_vertexColor = a_color;
#endif
    
#ifndef ENABLE_BLACKPASS
#ifdef ENABLE_LIGHTING
    vec3 L = normalize(viewPos.xyz - u_lightPosition0);
#if defined(ENABLE_ORIENTATION_FREE) && !defined(ENABLE_CUBE_MAP)
    
    
    vec3 N = sign(dot(mat[2], viewPos.xyz)) * mat[2];
    
    float NdotL = dot(N, L);
    vec3 diff = u_lightColor0.rgb * (max(0.0, NdotL) + 0.3 * (1. - abs(NdotL)));
    
    float _shininess = 100.0;
    vec3 halfVector = normalize(L + viewPos.xyz);
    float spec = max(0.0, pow(max(0.0, dot(N, halfVector)), _shininess));
    v_vertexColor.rgb *= diff;
    v_vertexColor.rgb += spec;
#else
    
    vec3 diff = vec3(max(0.0, dot(N, L))) * u_lightColor0.rgb;
    
    
    
    
    
    v_vertexColor.rgb *= diff;
#endif 
#endif 
#endif 
    
#ifdef ENABLE_ANIMATION
    vec4 animUVS = ComputeUVS(a_texCoord1.xy * vec2(0.5, -0.5) + 0.5, a_texCoord0.z);
    v_uv0 = animUVS.xyw;
    v_uv1 = animUVS.xy + u_frameSize.xy * vec2(1.0, animUVS.z);
#else
    v_uv0 = a_texCoord1.xy * vec2(0.5, -0.5) + 0.5;
#endif
    
#ifndef ENABLE_BLACKPASS
    #ifdef ENABLE_FOG
        float fogFactor = pow(clamp(viewPos.z * u_fogParameters.x + u_fogParameters.y, 0.0, u_fogColor.a), u_fogParameters.z);
        #ifdef ENABLE_CUBE_MAP
            v_normal.a = fogFactor;
        #else
            
            v_vertexColor.rgb = mix(v_vertexColor.rgb, u_fogColor.rgb * v_vertexColor.a, fogFactor);
        #endif 
    #endif 
#endif 
#ifdef ENABLE_SOFT
    v_eyeLinearZ = viewPos.z;
#endif
    
    gl_Position = u_projectionTransform * viewPos;
uniform sampler2D colorBuffer;
uniform sampler2D pickedColorBuffer;
uniform sampler2D depthBuffer;
uniform sampler2D pickedDepthBuffer;
uniform vec2 u_inverseResolution;
varying vec2 uv;
void main()
    
    float texels[9];
    texels[0] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, -u_inverseResolution.y)).r;
    texels[1] = texture2D(pickedColorBuffer, uv + vec2(                0., -u_inverseResolution.y)).r;
    texels[2] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, -u_inverseResolution.y)).r;
    
    texels[3] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, 0.)).r;
    
    texels[5] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, 0.)).r;
    
    texels[6] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, u_inverseResolution.y)).r;
    texels[7] = texture2D(pickedColorBuffer, uv + vec2(                0., u_inverseResolution.y)).r;
    texels[8] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, u_inverseResolution.y)).r;
    
    
    
    vec3 a = vec3(texels[0],texels[3],texels[6]);
    vec3 b = vec3(texels[2],texels[5],texels[7]);
    bvec3 tmp = equal(a,b);
    vec3 retLin = mix( vec3(tmp), vec3(not(tmp)), vec3(equal(b,vec3(0.))) );
    
    
    a = vec3(texels[0],texels[1],texels[2]);
    b = vec3(texels[6],texels[7],texels[8]);
    tmp = equal(a,b);
    vec3 retCol = mix( vec3(tmp), vec3(not(tmp)), vec3(equal(b,vec3(0.))) );
    
    
    vec4 last = step(vec4(0.002), vec4(texels[5],texels[7],texels[8], min(retLin.x, retCol.x)) );
    
    
    float x = last.w + 2.*retLin.y + retLin.z - retCol.z - 2.*last.x - last.z;
    float y = last.w + 2.*retCol.y + retCol.z - retLin.z- 2.*last.y - last.z;
    float magnitude = sqrt( x*x + y*y );
    
    
    
    
    float depth = 1.;
    for(int i=-1; i<2; i++)
    for(int j=-1; j<2; j++)
        depth = min(depth, texture2D(pickedDepthBuffer, uv + u_inverseResolution*vec2(i,j)).r);
    
    
    
    if( texture2D(depthBuffer, uv).x < depth-0.0000001 &&  texture2D(pickedColorBuffer, uv).r > 0.  )
        gl_FragColor = vec4(.25);
    else
        gl_FragColor = vec4( min(magnitude/4.,1.) );
    
uniform sampler2D textureSampler0;
uniform sampler2D textureSampler1;
varying vec2 TexCoord;
void main (void)
gl_FragColor = texture2D(textureSampler0,TexCoord) + texture2D(textureSampler1,TexCoord);
uniform sampler2D textureSampler0;
varying vec2 TexCoord;
void main (void)
gl_FragColor =
texture2D(textureSampler0,TexCoord);
uniform sampler2D colorSampler;
varying vec4 v_texCoord;
void main (void)
    
    vec4 color;
    color  = texture2D( colorSampler, v_texCoord.xz );
    color += texture2D( colorSampler, v_texCoord.yz );
    color += texture2D( colorSampler, v_texCoord.xw );
    color += texture2D( colorSampler, v_texCoord.yw );
    color *= 0.25;
    
gl_FragColor = vec4(color);
attribute vec4 a_position;
attribute vec4 a_texCoord0; 
attribute vec4 a_texCoord1; 
attribute vec4 a_color; 
uniform mat4 viewTransform; 
uniform mat4 u_projectionTransform;
varying vec2 v_uv0;
varying vec4 v_vertexColor;
void main()
    
    vec4 viewPos = viewTransform * vec4(a_position.xyz, 1);
    vec2 dir0 = normalize((viewTransform * vec4(normalize(a_texCoord1.xyz), 0)).xy);
    vec2 tangent = vec2(-dir0.y, dir0.x);
    
    viewPos.xy += tangent * a_texCoord0.y * a_texCoord1.w;
    v_vertexColor = a_color;
    v_uv0 = vec2(a_texCoord0.x, a_texCoord1.w * 0.5 + 0.5);
    
    gl_Position = u_projectionTransform * viewPos;
varying vec2 TexCoord;
uniform sampler2D textureSampler0;
uniform vec2  offsets[MAX_SAMPLE];
uniform float weights[MAX_SAMPLE];
uniform int n_sample;
const float alphaThreshold = 0.9;
void main (void)
    int i;
    vec4 accum = vec4(0.0);
    float total = 0.0;
    for(i=0;i<n_sample;i++){
        vec4 c = texture2D(textureSampler0, TexCoord+offsets[i]);
        c.rgb *= c.a;
        accum += c * weights[i];
        total += weights[i] * c.a;
    }
    accum /= total;
gl_FragColor = accum;
attribute vec3 a_position;
uniform mat4 u_mvp;
uniform float u_zfar;
varying vec3 TexCoord;
void main()
gl_Position = (u_mvp * vec4(a_position * u_zfar, 1.)).xyww;
TexCoord = vec3(a_position.x, a_position.y, -a_position.z);
attribute vec4 a_position;
uniform mat4 u_modelViewProjectionTransform;
void main()
    gl_Position = u_modelViewProjectionTransform * a_position;
uniform sampler2D colorBuffer;
uniform sampler2D outlineColorBuffer;
uniform vec2 u_inverseResolution;
varying vec2 uv;
void main()
    float alpha = 0.;
    for(int i=-1; i<2; i++)
    for(int j=-1; j<2; j++)
    {
        alpha += texture2D(outlineColorBuffer, uv+vec2(i,j)*u_inverseResolution).r;
    }
    alpha /= 9.;
    
    
    gl_FragColor = mix( texture2D(colorBuffer, uv), vec4(1.,.6,.2,1.), vec4(min(alpha*2.,1.)) );
uniform sampler2D colorBuffer;
uniform sampler2D pickedColorBuffer;
uniform sampler2D depthBuffer;
uniform sampler2D pickedDepthBuffer;
uniform vec2 u_inverseResolution;
varying vec2 uv;
void main()
    
    float texels[9];
    texels[0] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, -u_inverseResolution.y)).r;
    texels[1] = texture2D(pickedColorBuffer, uv + vec2(                0., -u_inverseResolution.y)).r;
    texels[2] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, -u_inverseResolution.y)).r;
    
    texels[3] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, 0.)).r;
    
    texels[5] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, 0.)).r;
    
    texels[6] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, u_inverseResolution.y)).r;
    texels[7] = texture2D(pickedColorBuffer, uv + vec2(                0., u_inverseResolution.y)).r;
    texels[8] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, u_inverseResolution.y)).r;
    
    
    
    vec3 a = vec3(texels[0],texels[3],texels[6]);
    vec3 b = vec3(texels[2],texels[5],texels[7]);
    bvec3 tmp = equal(a,b);
    vec3 retLin = mix( vec3(tmp), vec3(not(tmp)), vec3(equal(b,vec3(0.))) );
    
    
    a = vec3(texels[0],texels[1],texels[2]);
    b = vec3(texels[6],texels[7],texels[8]);
    tmp = equal(a,b);
    vec3 retCol = mix( vec3(tmp), vec3(not(tmp)), vec3(equal(b,vec3(0.))) );
    
    
    vec4 last = step(vec4(0.002), vec4(texels[5],texels[7],texels[8], min(retLin.x, retCol.x)) );
    
    
    float x = last.w + 2.*retLin.y + retLin.z - retCol.z - 2.*last.x - last.z;
    float y = last.w + 2.*retCol.y + retCol.z - retLin.z- 2.*last.y - last.z;
    float magnitude = sqrt( x*x + y*y );
    
    
    
    
    float depth = 1.;
    for(int i=-2; i<3; i++)
    for(int j=-2; j<3; j++)
        depth = min(depth, texture2D(pickedDepthBuffer, uv + u_inverseResolution*vec2(i,j)).r);
    
    
    
    vec3 outline = vec3(1.,.6,.2);
    if( texture2D(depthBuffer, uv).x < depth-0.0000001 &&  texture2D(pickedColorBuffer, uv).r > 0.  )
        gl_FragColor = mix( texture2D(colorBuffer, uv), vec4(outline,1.), .25);
    else
        gl_FragColor = mix( texture2D(colorBuffer, uv), vec4(outline,1.), min(magnitude/4.,1.) );
#extension GL_OES_standard_derivatives : enable
precision highp float; 
uniform vec4 u_color;
varying vec3 v_vertexCenter;
#if 0
vec3 smooth(vec3 edge0, vec3 edge1, vec3 x);
vec3 smooth(vec3 edge0, vec3 edge1, vec3 x)
    vec3 t = clamp((x - edge0)/(edge1 - edge0), vec3(0.), vec3(1));
    return t * t * (3. - 2. * t);
#endif
void main()
    vec3 d = fwidth(v_vertexCenter);
    vec3 a3 = smoothstep(vec3(0.0), d * 1.5, v_vertexCenter);
    
    float edge =  min(min(a3.x, a3.y), a3.z);
    if (edge >= 1.0)
        discard;
    gl_FragColor = u_color * (1.0 - edge) * 0.95;
uniform mat4 u_modelViewProjectionTransform;
attribute vec3 a_position;
attribute vec4 a_color;
varying vec4 v_vertexColor;
void main()
    gl_Position = u_modelViewProjectionTransform * vec4(a_position, 1.);
    v_vertexColor = a_color;
void main()
    gl_FragColor = vec4(1.,0.,0.,1.);
uniform sampler2D downSampler;
uniform sampler2D blurSampler;
varying vec2 v_texCoord;
void main (void)
    vec4 down = texture2D( downSampler, v_texCoord);
    vec4 blur = texture2D( blurSampler, v_texCoord);
    float coc = max( down.a, 2. * blur.a - down.a );
gl_FragColor = vec4(down.rgb, coc);
    
    
struct SCNShaderLightingContribution
vec3 ambient;
vec3 diffuse;
vec3 specular;
} _lightingContribution;
uniform sampler2D textureSampler0;
uniform sampler2D textureSampler1;
uniform float factor;
varying vec2 TexCoord;
void main (void)
    vec4 newFragment = texture2D(textureSampler0,TexCoord);
    vec4 oldColor = texture2D(textureSampler1,TexCoord);
    
    gl_FragColor = (factor-1.0)*(oldColor/factor) + newFragment/factor;
attribute vec4 a_position;
uniform mat4 u_modelViewProjectionTransform;
void main(void)
gl_Position = u_modelViewProjectionTransform * a_position;
#ifdef USE_SKINNING
uniform vec4 u_skinningJointMatrices[60];
attribute vec4 a_skinningWeights;
attribute vec4 a_skinningJoints;
#endif
attribute vec4 a_position;
#ifdef USE_NORMAL
attribute vec3 a_normal;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
attribute vec4 a_tangent;
#endif
#ifdef NEED_IN_TEXCOORD0
attribute vec2 a_texCoord0;
#endif
#ifdef NEED_IN_TEXCOORD1
attribute vec2 a_texCoord1;
#endif
#ifdef NEED_IN_TEXCOORD2
attribute vec2 a_texCoord2;
#endif
#ifdef NEED_IN_TEXCOORD3
attribute vec2 a_texCoord3;
#endif
#ifdef NEED_IN_TEXCOORD4
attribute vec2 a_texCoord4;
#endif
#ifdef NEED_IN_TEXCOORD5
attribute vec2 a_texCoord5;
#endif
#ifdef NEED_IN_TEXCOORD6
attribute vec2 a_texCoord6;
#endif
#ifdef NEED_IN_TEXCOORD7
attribute vec2 a_texCoord7;
#endif
#ifdef USE_VERTEX_COLOR
attribute vec4 a_color;
varying vec4 v_vertexColor;
#endif
#ifdef USE_PER_VERTEX_LIGHTING
varying vec3 v_diffuse;
#ifdef USE_SPECULAR
varying vec3 v_specular;
#endif
#endif
#if defined(USE_POSITION) || defined(USE_VIEW)
varying vec3 v_position;
#endif
#ifdef USE_NORMAL
varying vec3 v_normal;
#endif
#ifdef USE_TANGENT
varying vec3 v_tangent;
#endif
#ifdef USE_BITANGENT
varying vec3 v_bitangent;
#endif
#if defined(USE_SPECULAR) && defined(USE_PER_VERTEX_LIGHTING)
uniform float u_materialShininess;
#endif
void main(void)
  _geometry.position = a_position;
  #ifdef USE_NORMAL
  _geometry.normal = a_normal;
  #endif
  #if defined(USE_TANGENT) || defined(USE_BITANGENT)
  _geometry.tangent = a_tangent;
  #endif
  #ifdef NEED_IN_TEXCOORD0
  _geometry.texcoords[0] = a_texCoord0;
  #endif
  #ifdef NEED_IN_TEXCOORD1
  _geometry.texcoords[1] = a_texCoord1;
  #endif
  #ifdef NEED_IN_TEXCOORD2
  _geometry.texcoords[2] = a_texCoord2;
  #endif
  #ifdef NEED_IN_TEXCOORD3
  _geometry.texcoords[3] = a_texCoord3;
  #endif
  #ifdef NEED_IN_TEXCOORD4
  _geometry.texcoords[4] = a_texCoord4;
  #endif
  #ifdef NEED_IN_TEXCOORD5
  _geometry.texcoords[5] = a_texCoord5;
  #endif
  #ifdef NEED_IN_TEXCOORD6
  _geometry.texcoords[6] = a_texCoord6;
  #endif
  #ifdef NEED_IN_TEXCOORD7
  _geometry.texcoords[7] = a_texCoord7;
  #endif
#ifdef USE_VERTEX_COLOR
  _geometry.color = a_color;
#endif
  #ifdef USE_SKINNING
    vec3 pos = vec3(0.);
    #ifdef USE_NORMAL
    vec3 nrm = vec3(0.);
    #endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    vec3 tgt = vec3(0.);
    #endif
    for (int i = 0; i < MAX_BONE_INFLUENCES; ++i) {
#if MAX_BONE_INFLUENCES == 1
        float weight = 1.0;
#else
        float weight = a_skinningWeights[i];
        
#endif
      int idx = int(a_skinningJoints[i]) * 3;
      mat4 jointMatrix = mat4(u_skinningJointMatrices[idx], u_skinningJointMatrices[idx+1], u_skinningJointMatrices[idx+2], vec4(0., 0., 0., 1.));
            pos += (_geometry.position * jointMatrix).xyz * weight;
      #ifdef USE_NORMAL
            nrm += _geometry.normal * mat3(jointMatrix) * weight;
      #endif
      #if defined(USE_TANGENT) || defined(USE_BITANGENT)
            tgt += _geometry.tangent.xyz * mat3(jointMatrix) * weight;
      #endif
    }
    
    _geometry.position.xyz = pos;
    #ifdef USE_NORMAL
    _geometry.normal = nrm;
    #endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _geometry.tangent.xyz = tgt;
    #endif
  #endif
  #ifdef USE_GEOMETRY_MODIFIER
__DoGeometryModifier__
  #endif
  #ifdef USE_POSITION
  _surface.position = (u_modelViewTransform * _geometry.position).xyz;
  #endif
  #ifdef USE_NORMAL
  _surface.normal = normalize(mat3(u_normalTransform) * _geometry.normal);
  #endif
  #if defined(USE_TANGENT) || defined(USE_BITANGENT)
  _surface.tangent = normalize(mat3(u_normalTransform) * _geometry.tangent.xyz);
  _surface.bitangent =  cross(_surface.tangent, _surface.normal); 
    
  #endif
  #ifdef USE_VIEW
    _surface.view = normalize(-_surface.position);
  #endif
  #ifdef USE_PER_VERTEX_LIGHTING
  _lightingContribution.diffuse = vec3(0.);
  #ifdef USE_SPECULAR
  _lightingContribution.specular = vec3(0.);
  _surface.shininess = u_materialShininess;
  #endif
__DoLighting__
  v_diffuse = _lightingContribution.diffuse;
  #ifdef USE_SPECULAR
  v_specular = _lightingContribution.specular;
  #endif
  #endif
  #if defined(USE_POSITION) && (USE_POSITION == 2)
  v_position = _surface.position;
  #endif
  #if defined(USE_NORMAL) && (USE_NORMAL == 2)
  v_normal = _surface.normal;
  #endif
  #if defined(USE_TANGENT) && (USE_TANGENT == 2)
  v_tangent = _surface.tangent;
  #endif
  #if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
  v_bitangent = _surface.bitangent;
  #endif
  #ifdef USE_VERTEX_COLOR
  v_vertexColor = _geometry.color;
  #endif
#ifdef USE_TEXCOORD
__DoTexcoord__
#endif
    
  #if defined(SEPARATE_PROJECTION) && SEPARATE_PROJECTION
  gl_Position = u_projectionTransform * vec4(_surface.position, 1.);
  #else
  gl_Position = u_modelViewProjectionTransform * _geometry.position;
  #endif
#ifdef __METAL_VERSION__ 
#define DECLARE_BOOL(a) constant bool a [[ function_constant( __COUNTER__ ) ]];
#define DECLARE_INT(a) constant int a [[ function_constant( 1000 + __COUNTER__ ) ]];
#define DECLARE_UINT(a) constant uint a [[ function_constant( 2000 + __COUNTER__ ) ]];
#define DECLARE_OPT_INT(a) constant int a [[ function_constant( 3000 + __COUNTER__ ) ]];
#define DECLARE_OPT_UINT(a) constant uint a [[ function_constant( 4000 + __COUNTER__ ) ]];
#else
#if !defined(DECLARE_BOOL) || !defined(DECLARE_INT) || !defined(DECLARE_UINT) || !defined(DECLARE_OPT_INT) || !defined(DECLARE_OPT_UINT)
#error Need to declare DECLARE_BOOL and DECLARE_INT macros
#endif
#endif
#define kSCNTexcoordCount 8
DECLARE_BOOL(need_vertex_color)
DECLARE_BOOL(need_position)
DECLARE_BOOL(need_normal)
DECLARE_BOOL(need_tangent)
DECLARE_BOOL(need_texcoord0)
DECLARE_BOOL(need_texcoord1)
DECLARE_BOOL(need_texcoord2)
DECLARE_BOOL(need_texcoord3)
DECLARE_BOOL(need_texcoord4)
DECLARE_BOOL(need_texcoord5)
DECLARE_BOOL(need_texcoord6)
DECLARE_BOOL(need_texcoord7)
DECLARE_BOOL(use_io_vertex_color)
DECLARE_BOOL(use_io_position)
DECLARE_BOOL(use_io_normal)
DECLARE_BOOL(use_io_view)
DECLARE_BOOL(use_ambient)
DECLARE_BOOL(use_diffuse)
DECLARE_BOOL(use_specular)
DECLARE_BOOL(use_emission)
DECLARE_BOOL(use_multiply)
DECLARE_BOOL(use_reflective)
DECLARE_BOOL(use_transparent)
DECLARE_BOOL(use_diffuse_map)
DECLARE_BOOL(use_normal_map)
DECLARE_BOOL(use_transparent_map)
DECLARE_BOOL(use_emission_map)
DECLARE_BOOL(use_ambient_map)
DECLARE_BOOL(use_multiply_map)
DECLARE_BOOL(use_specular_map)
DECLARE_BOOL(use_reflective_map)
DECLARE_BOOL(use_reflectivecube_map)
DECLARE_BOOL(use_roughness_map)
DECLARE_BOOL(use_metalness_map)
DECLARE_OPT_INT(diffuse_texture_component)
DECLARE_OPT_INT(normal_texture_component)
DECLARE_OPT_INT(transparent_texture_component)
DECLARE_OPT_INT(emission_texture_component)
DECLARE_OPT_INT(ambient_texture_component)
DECLARE_OPT_INT(multiply_texture_component)
DECLARE_OPT_INT(specular_texture_component)
DECLARE_OPT_INT(reflective_texture_component)
DECLARE_OPT_INT(roughness_texture_component)
DECLARE_OPT_INT(metalness_texture_component)
DECLARE_BOOL(use_diffuse_intensity)
DECLARE_BOOL(use_normal_intensity)
DECLARE_BOOL(use_transparent_intensity)
DECLARE_BOOL(use_emission_intensity)
DECLARE_BOOL(use_ambient_intensity)
DECLARE_BOOL(use_multiply_intensity)
DECLARE_BOOL(use_specular_intensity)
DECLARE_BOOL(use_reflective_intensity)
DECLARE_BOOL(use_roughness_intensity)
DECLARE_BOOL(use_metalness_intensity)
DECLARE_BOOL(use_fresnel)
DECLARE_BOOL(use_transparency)
DECLARE_BOOL(use_transparency_rgbzero)
DECLARE_INT(diffuse_channel)
DECLARE_INT(normal_channel)
DECLARE_INT(transparent_channel)
DECLARE_INT(emission_channel)
DECLARE_INT(ambient_channel)
DECLARE_INT(multiply_channel)
DECLARE_INT(specular_channel)
DECLARE_INT(roughness_channel)
DECLARE_INT(metalness_channel)
DECLARE_OPT_INT(diffuse_texcoord_io_index)
DECLARE_OPT_INT(normal_texcoord_io_index)
DECLARE_OPT_INT(transparent_texcoord_io_index)
DECLARE_OPT_INT(emission_texcoord_io_index)
DECLARE_OPT_INT(ambient_texcoord_io_index)
DECLARE_OPT_INT(multiply_texcoord_io_index)
DECLARE_OPT_INT(specular_texcoord_io_index)
DECLARE_OPT_INT(roughness_texcoord_io_index)
DECLARE_OPT_INT(metalness_texcoord_io_index)
DECLARE_OPT_INT(diffuse_transform_index)
DECLARE_OPT_INT(normal_transform_index)
DECLARE_OPT_INT(transparent_transform_index)
DECLARE_OPT_INT(emission_transform_index)
DECLARE_OPT_INT(ambient_transform_index)
DECLARE_OPT_INT(multiply_transform_index)
DECLARE_OPT_INT(specular_transform_index)
DECLARE_OPT_INT(roughness_transform_index)
DECLARE_OPT_INT(metalness_transform_index)
DECLARE_BOOL(use_emission_as_selfIllumination)
DECLARE_BOOL(use_ambient_as_ambientOcclusion)
DECLARE_BOOL(use_texture_transforms)
DECLARE_BOOL(use_point_rendering)
DECLARE_BOOL(diffuse_premultiplied)
DECLARE_BOOL(use_discard)
DECLARE_BOOL(use_instancing)
DECLARE_INT(lighting_model)
DECLARE_BOOL(use_lighting) 
DECLARE_BOOL(use_ambient_lighting)
DECLARE_BOOL(use_modulate_lighting)
DECLARE_BOOL(use_per_vertex_lighting)
DECLARE_BOOL(avoid_overlighting) 
DECLARE_BOOL(use_double_sided)
DECLARE_BOOL(use_probes_lighting)
DECLARE_OPT_UINT(use_light0);
DECLARE_OPT_UINT(use_light1);
DECLARE_OPT_UINT(use_light2);
DECLARE_OPT_UINT(use_light3);
DECLARE_BOOL(use_node_opacity)
DECLARE_BOOL(use_fog)
DECLARE_BOOL(use_ssao)
DECLARE_INT(io_texcoord_count)
#undef DECLARE_BOOL
#undef DECLARE_INT
#undef DECLARE_UINT
#undef DECLARE_OPT_INT
#undef DECLARE_OPT_UINT
#define LIGHT_TYPE(a)           ((a      ) & 0x7)
#define LIGHT_DIST_ATT(a)       ((a >> 3) & 0x7)
#define LIGHT_SPOT_ATT(a)       ((a >> 6) & 0x7)
#define LIGHT_HAS_GOBO(a)       (a & (1 << 9))
#define LIGHT_HAS_SHADOW(a)     (a & (1 << 10))
#define LIGHT_IS_MODULATE(a)    (a & (1 << 12))
#define LIGHT_IES_TYPE(a)       ((a >> 13) & 0x3)
#define LIGHT_SHADOW_SAMPLE(a)  ((a >> 15) & 0x1f)
#if defined(__METAL_VERSION__) 
enum C3DLightAttenuationType
    kC3DLightAttenuationTypeNone,
    kC3DLightAttenuationTypeConstant,
    kC3DLightAttenuationTypeLinear,
    kC3DLightAttenuationTypeQuadratic,
    kC3DLightAttenuationTypeExponent,
    kC3DLightAttenuationTypePhysicallyBased,
enum C3DLightType
    kC3DLightTypeAmbient,
    kC3DLightTypeDirectional,
    kC3DLightTypeOmni,
    kC3DLightTypeSpot,
    kC3DLightTypeProbe,
    kC3DLightTypeIES,
    kC3DLightTypeArea
enum C3DLightIESType
    kC3DLightIESType1D,
    kC3DLightIESType2D,
    kC3DLightIESTypeCubemap,
    kC3DLightIESTypeNone
#endif
struct SCNLightData {
    float4 color; 
    float4 pbrColor; 
    
    
    float3 position;  
    float3 direction; 
    float3 up; 
    float3 right; 
    
    float3 distanceAttenuation; 
    float3 spotAttenuation; 
    float shadowRadius; 
    float4x4 shadowMatrix; 
struct scn_floor_t {
    float3 u_floorNormal;
    float4 u_floorTangent;
    float3 u_floorCenter;
    float2 u_floorExtent;
#pragma arguments
    scn_floor_t scn_fg
#pragma body
    float3 u_floorNormal = scn_fg.u_floorNormal;
    float4 u_floorTangent = scn_fg.u_floorTangent;
    float3 u_floorCenter = scn_fg.u_floorCenter;
    float2 u_floorExtent = scn_fg.u_floorExtent;
    float3 floorBitangent =  normalize(cross(u_floorTangent.xyz, u_floorNormal));
    _geometry.position.xyz = u_floorCenter.xyz + u_floorExtent.x * (_geometry.position.x * u_floorTangent.xyz) + u_floorExtent.y * (_geometry.position.y * floorBitangent);
    _geometry.normal = u_floorNormal;
    _geometry.tangent = u_floorTangent;
    
    float2 tc;
    if (u_floorNormal.y != 0.)
        tc = _geometry.position.xz * 0.01;
    else if (u_floorNormal.z != 0.)
        tc = _geometry.position.xy * 0.01;
    else
        tc = _geometry.position.yz * 0.01;
    for (int i = 0; i < kSCNTexcoordCount; ++i)
        _geometry.texcoords[i] = tc;
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
struct SCNTessellatorTransforms {
    float4x4 modelViewTransform;
    float4x4 modelViewProjectionTransform;
    float4x4 projectionTransform;
#if OSD_IS_ADAPTIVE
kernel void compute_opensubdiv(
                               constant SCNTessellatorTransforms&     transforms                     [[ buffer(TRANSFORMS_BUFFER_INDEX) ]],
                               constant float&                        tessellationLevel              [[ buffer(TESSELLATION_LEVEL_BUFFER_INDEX) ]],
                               unsigned                               thread_position_in_grid        [[ thread_position_in_grid ]],
                               unsigned                               thread_position_in_threadgroup [[ thread_position_in_threadgroup ]],
                               unsigned                               threadgroup_position_in_grid   [[ threadgroup_position_in_grid ]],
                               OsdPatchParamBufferSet                 osdBuffers, 
                               device MTLQuadTessellationFactorsHalf* quadTessellationFactors        [[ buffer(QUAD_TESSFACTORS_INDEX) ]]
#if OSD_USE_PATCH_INDEX_BUFFER
                               ,device unsigned* patchIndex                                          [[ buffer(OSD_PATCH_INDEX_BUFFER_INDEX) ]]
                               ,device MTLDrawPatchIndirectArguments* drawIndirectCommands           [[ buffer(OSD_DRAWINDIRECT_BUFFER_INDEX) ]]
#endif
                         )
    
    
    
    
    
    
    
    threadgroup int3 patchParam[PATCHES_PER_THREADGROUP];
    
    threadgroup PatchVertexType patchVertices[PATCHES_PER_THREADGROUP * CONTROL_POINTS_PER_PATCH];
    
    const auto real_threadgroup = thread_position_in_grid / REAL_THREADGROUP_DIVISOR;
    const auto subthreadgroup_in_threadgroup = thread_position_in_threadgroup / REAL_THREADGROUP_DIVISOR;
    const auto real_thread_in_threadgroup = thread_position_in_threadgroup & (REAL_THREADGROUP_DIVISOR - 1);
    
#if NEEDS_BARRIER
    const auto validThread = thread_position_in_grid * CONTROL_POINTS_PER_THREAD < osdBuffers.kernelExecutionLimit;
#else
    const auto validThread = true;
    if(thread_position_in_grid * CONTROL_POINTS_PER_THREAD >= osdBuffers.kernelExecutionLimit)
        return;
#endif
    
    
    
    
    if(validThread)
    {
        patchParam[subthreadgroup_in_threadgroup] = OsdGetPatchParam(real_threadgroup, osdBuffers.patchParamBuffer);
        
        for(unsigned threadOffset = 0; threadOffset < CONTROL_POINTS_PER_THREAD; threadOffset++)
        {
            const auto vertexId = osdBuffers.indexBuffer[(thread_position_in_grid * CONTROL_POINTS_PER_THREAD + threadOffset) * IndexLookupStride];
            const auto v = osdBuffers.vertexBuffer[vertexId];
            
            threadgroup auto& patchVertex = patchVertices[thread_position_in_threadgroup * CONTROL_POINTS_PER_THREAD + threadOffset];
            
            
            
            
            
            OsdComputePerVertex(float4(v.position,1), patchVertex, vertexId, transforms.modelViewProjectionTransform, osdBuffers);
        }
    }
    
#if NEEDS_BARRIER
    threadgroup_barrier(mem_flags::mem_threadgroup);
#endif
    
    
    
    
    
    if(validThread)
    {
#if PATCHES_PER_THREADGROUP > 1
        auto patch = patchVertices + subthreadgroup_in_threadgroup * CONTROL_POINTS_PER_THREAD * CONTROL_POINTS_PER_PATCH;
#else
        
        auto patch = patchVertices;
#endif
        
        if(!OsdCullPerPatchVertex(patch, transforms.modelViewTransform))
        {
#if !OSD_USE_PATCH_INDEX_BUFFER
            quadTessellationFactors[real_threadgroup].edgeTessellationFactor[0] = 0.0h;
            quadTessellationFactors[real_threadgroup].edgeTessellationFactor[1] = 0.0h;
            quadTessellationFactors[real_threadgroup].edgeTessellationFactor[2] = 0.0h;
            quadTessellationFactors[real_threadgroup].edgeTessellationFactor[3] = 0.0h;
            quadTessellationFactors[real_threadgroup].insideTessellationFactor[0] = 0.0h;
            quadTessellationFactors[real_threadgroup].insideTessellationFactor[1] = 0.0h;
#endif
            
            patchParam[subthreadgroup_in_threadgroup].z = -1;
#if !NEEDS_BARRIER
            return;
#endif
        }
    }
    
#if NEEDS_BARRIER
    threadgroup_barrier(mem_flags::mem_threadgroup);
#endif
    
    
    
    
    if(validThread && patchParam[subthreadgroup_in_threadgroup].z != -1)
    {
        for(unsigned threadOffset = 0; threadOffset < CONTROL_POINTS_PER_THREAD; threadOffset++)
        {
            OsdComputePerPatchVertex(
                                     patchParam[subthreadgroup_in_threadgroup],
                                     real_thread_in_threadgroup * CONTROL_POINTS_PER_THREAD + threadOffset,
                                     real_threadgroup,
                                     thread_position_in_grid * CONTROL_POINTS_PER_THREAD + threadOffset,
                                     patchVertices + subthreadgroup_in_threadgroup * CONTROL_POINTS_PER_PATCH,
                                     osdBuffers
                                     );
        }
    }
    
#if NEEDS_BARRIER
    threadgroup_barrier(mem_flags::mem_device_and_threadgroup);
#endif
    
    
    
    
    if(validThread && real_thread_in_threadgroup == 0)
    {
        
#if OSD_USE_PATCH_INDEX_BUFFER
        const auto patchId = atomic_fetch_add_explicit((device atomic_uint*)&drawIndirectCommands->patchCount, 1, memory_order_relaxed);
        patchIndex[patchId] = real_threadgroup;
#else
        const auto patchId = real_threadgroup;
#endif
        
        OsdComputePerPatchFactors(
                                  patchParam[subthreadgroup_in_threadgroup],
                                  tessellationLevel,
                                  real_threadgroup,
                                  transforms.projectionTransform,
                                  transforms.modelViewTransform,
                                  osdBuffers,
                                  patchVertices + subthreadgroup_in_threadgroup * CONTROL_POINTS_PER_PATCH,
                                  quadTessellationFactors[patchId]
                                  );
    }
#endif 
#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE)
static inline void scn_smooth_geometry_pn_triangle(thread float3 &position, thread float3 &normal, float3 patchCoord, float3 P0, float3 P1, float3 P2, float3 N0, float3 N1, float3 N2)
    float u = patchCoord.y;
    float v = patchCoord.z;
    float w = patchCoord.x;
    
    float3 P0P1 = P1 - P0;
    float3 P1P2 = P2 - P1;
    float3 P2P0 = P0 - P2;
    
    float w12 = dot(P0P1, N0);
    float w23 = dot(P1P2, N1);
    float w31 = dot(P2P0, N2);
    
    float w21 = dot(-P0P1, N1);
    float w32 = dot(-P1P2, N2);
    float w13 = dot(-P2P0, N0);
    
    float inv3 = 1.f / 3.f;
    
    float3 b210 = (2.f * P0 + P1 - w12 * N0) * inv3;
    float3 b021 = (2.f * P1 + P2 - w23 * N1) * inv3;
    float3 b201 = (2.f * P0 + P2 - w13 * N0) * inv3;
    
    float3 b120 = (2.f * P1 + P0 - w21 * N1) * inv3;
    float3 b012 = (2.f * P2 + P1 - w32 * N2) * inv3;
    float3 b102 = (2.f * P2 + P0 - w31 * N2) * inv3;
    
    float3 E = (b210 + b120 + b021 + b012 + b201 + b102) / 6.f;
    float3 V = (P0 + P1 + P2) * inv3;
    float3 b111 = E + (E - V) / 2.f;
    
    position.xyz =
    P0 * (w * w * w) +
    P1 * (u * u * u) +
    P2 * (v * v * v) +
    b210 * (3.f * w * w * u) +
    b120 * (3.f * w * u * u) +
    b201 * (3.f * w * w * v) +
    b021 * (3.f * u * u * v) +
    b102 * (3.f * w * v * v) +
    b012 * (3.f * u * v * v) +
    b111 * (6.f * w * u * v);
    
    float3 v12 = 2.f * dot(P0P1, N0 + N1) / dot(P0P1, P0P1);
    float3 v23 = 2.f * dot(P1P2, N1 + N2) / dot(P1P2, P1P2);
    float3 v31 = 2.f * dot(P2P0, N2 + N0) / dot(P2P0, P2P0);
    
    float3 h110 = N0 + N1 - v12 * P0P1;
    float3 h011 = N1 + N2 - v23 * P1P2;
    float3 h101 = N2 + N0 - v31 * P2P0;
    
    float3 n010 = normalize(h110);
    float3 n011 = normalize(h011);
    float3 n001 = normalize(h101);
    
    normal = normalize(
    N0 * w * w +
    N1 * u * u +
    N2 * v * v +
    n010 * w * u +
    n011 * u * v +
    n001 * w * v);
#elif defined(TESSELLATION_SMOOTHING_MODE_PHONG)
static inline void scn_smooth_geometry_phong(thread float3 &position, thread float3 &normal, float3 patchCoord, float3 P0, float3 P1, float3 P2, float3 N0, float3 N1, float3 N2)
    float3 P = scn::barycentric_mix(P0, P1, P2, patchCoord);
    
    float3 proj0 = P - dot(P - P0, N0) * N0;
    float3 proj1 = P - dot(P - P1, N1) * N1;
    float3 proj2 = P - dot(P - P2, N2) * N2;
    
    float3 Pproj = scn::barycentric_mix(proj0, proj1, proj2, patchCoord);
    
    const float alpha = 0.75f;
    position = mix(P, Pproj, alpha);
    normal = normalize(scn::barycentric_mix(N0, N1, N2, patchCoord));
#endif 
#if __METAL_VERSION__ >= 220 
    #include <TargetConditionals.h>
    #if TARGET_OS_OSX || TARGET_OS_MACCATALYST
        
        
        #define SHOULD_CHECK_IF_OUTSIDE_TEXTURE  0
        #define RETURN_IF_OUTSIDE_TEXTURE(dst)
        #define RETURN_IF_OUTSIDE_TEXTURE3D(dst)
    #else
        #define SHOULD_CHECK_IF_OUTSIDE_TEXTURE  1
        #define RETURN_IF_OUTSIDE_TEXTURE(dst)   if ((index.x >= dst.get_width()) || (index.y >= dst.get_height())) return;
        #define RETURN_IF_OUTSIDE_TEXTURE3D(dst) if ((index.x >= dst.get_width()) || (index.y >= dst.get_height()) || (index.z >= dst.get_depth())) return;
    #endif
    #define SUPPORTS_LAYERED_RENDERING           1
    #define SUPPORTS_MULTIPLE_VIEWPORT_RENDERING 1
#else
    #if defined(__METAL_MACOS__)
        
        
        #define SHOULD_CHECK_IF_OUTSIDE_TEXTURE      0
        #define RETURN_IF_OUTSIDE_TEXTURE(dst)
        #define RETURN_IF_OUTSIDE_TEXTURE3D(dst)
        #define SUPPORTS_LAYERED_RENDERING           (__METAL_VERSION__ >= 200)
        #define SUPPORTS_MULTIPLE_VIEWPORT_RENDERING (__METAL_VERSION__ >= 200)
    #elif defined(__METAL_IOS__)
        #define SHOULD_CHECK_IF_OUTSIDE_TEXTURE      1
        #define RETURN_IF_OUTSIDE_TEXTURE(dst)       if ((index.x >= dst.get_width()) || (index.y >= dst.get_height())) return;
        #define RETURN_IF_OUTSIDE_TEXTURE3D(dst)     if ((index.x >= dst.get_width()) || (index.y >= dst.get_height()) || (index.z >= dst.get_depth())) return;
        #define SUPPORTS_LAYERED_RENDERING           (__METAL_VERSION__ >= 210)
        #define SUPPORTS_MULTIPLE_VIEWPORT_RENDERING (__METAL_VERSION__ >= 210)
    #endif
#endif
namespace scn {
    
    
    static inline float4 reduce_op(float4 d0, float4 d1)
    {
        d0.x = min(d0.x, d1.x);
        d0.y = max(d0.y, d1.y);
        d0.z += d1.z;
        d0.w += d1.w;
        return d0;
    }
    
    inline float vector_reduce_min(float4 v)
    {
        float2 min_lh = min(v.xy, v.zw);
        return min(min_lh.x, min_lh.y);
    }
    
    inline float vector_reduce_max(float4 v)
    {
        float2 max_lh = max(v.xy, v.zw);
        return max(max_lh.x, max_lh.y);
    }
    
    inline int vector_reduce_add(int4 v)
    {
        int2 add_lh = v.xy + v.zw;
        return add_lh.x + add_lh.y;
    }
    
    inline float3x3 mat3(float4x4 mat4)
    {
        return float3x3(mat4[0].xyz, mat4[1].xyz, mat4[2].xyz);
    }
    
    inline float3 mat4_mult_float3_normalized(float4x4 matrix, float3 src)
    {
        float3 dst  =  src.xxx * matrix[0].xyz;
        dst         += src.yyy * matrix[1].xyz;
        dst         += src.zzz * matrix[2].xyz;
        return normalize(dst);
    }
    
    inline float3 mat4_mult_float3(float4x4 matrix, float3 src)
    {
        float3 dst  =  src.xxx * matrix[0].xyz;
        dst         += src.yyy * matrix[1].xyz;
        dst         += src.zzz * matrix[2].xyz;
        return dst;
    }
    inline float3 matrix_rotate(float4x4 mat, float3 dir)
    {
        return  dir.xxx * mat[0].xyz +
                dir.yyy * mat[1].xyz +
                dir.zzz * mat[2].xyz;
    }
    inline float4 matrix_transform(float4x4 mat, float3 pos)
    {
        return  pos.xxxx * mat[0] +
                pos.yyyy * mat[1] +
                pos.zzzz * mat[2] +
                           mat[3];
    }
    inline float3 quaternion_rotate_vector(float4 q, float3 v)
    {
        float3 t = 2.f * cross(q.xyz, v);
        return v + q.w * t + cross(q.xyz, t);
    }
    
    template <class T>
    inline vec<T, 3> robust_normalize(vec<T, 3> v)
    {
        vec<T, 3> zero = 0.;
        return all(v == zero) ? zero : normalize(v);
    }
    template <class T>
    inline void generate_basis(vec<T, 3> inR, thread vec<T, 3> *outS, thread vec<T, 3> *outT)
    {
        
        T x  = -inR.x;
        T y  = inR.y;
        T z  = inR.z;
        T sz = copysign(T(1.), z);
        T a  = y / (abs(z) + T(1.));
        T b  = y * a;
        T c  = x * a;
        *outS = (vec<T, 3>){ z + sz * b,  sz * c,       x       };
        *outT = (vec<T, 3>){ c,           T(1.) - b,    -sz * y };
    }
    
    
    
    inline float3 blend_add(float3 base, float3 blend)
    {
        return min(base + blend, 1.0);
    }
    
    inline float3 blend_lighten(float3 base, float3 blend)
    {
        return max(blend, base);
    }
    
    inline float3 blend_screen(float3 base, float3 blend)
    {
        return (1.0 - ((1.0 - base) * (1.0 - blend)));
    }
    
    
    inline half sq(half f) {
        return f * f;
    }
    inline float sq(float f) {
        return f * f;
    }
    
    inline float2 sincos(float angle) {
        float cs;
        float sn = ::sincos(angle, cs);
        return float2(sn, cs);
    }
    
    
    inline float acos_fast(float f) {
        float x = abs(f);
        float res = -0.156583f * x + M_PI_2_F;
        res *= sqrt(1.0f - x);
        return (f >= 0.f) ? res : M_PI_F - res;
    }
    inline float asin_fast(float f)
    {
        return M_PI_2_F - acos_fast(f);
    }
    
    inline float atan_fast(float inX)
    {
        float  x = inX;
        return x*(-0.1784f * abs(x) - 0.0663f * x * x + 1.0301f);
    }
    
    inline float atan2_fast(float y, float x)
    {
        float sx = x > 0.f ? -1.f : 1.f;
        float abs_y = abs(y) + 1e-10f; 
        float r = (x + abs_y*sx) / (abs_y - x*sx);
        float angle = sx * M_PI_4_F + M_PI_2_F;
        angle      += (0.1963f * r * r - 0.9817f) * r;
        return y > 0.f ? angle : -angle;
    }
    
    
    template <class T>
    inline vec<T, 3> cartesian_from_spherical(vec<T, 2> uv)
    {
        
        
        T cos_phi;
        T phi = uv.x * 2.0f * M_PI_F;
        T sin_phi = ::sincos(phi, cos_phi);
        
        T cos_theta;
        T theta     = uv.y * M_PI_F;
        T sin_theta = ::sincos(theta, cos_theta);
        return vec<T, 3>(cos_phi * sin_theta,
                         cos_theta,
                         -sin_phi * sin_theta);
    }
    inline float2 spherical_from_cartesian(float3 dir)
    {
        return float2( atan2(-dir.z, dir.x) * (0.5f * M_1_PI_F), acos(dir.y) * M_1_PI_F);
    }
    inline half2 spherical_from_cartesian(half3 dir)
    {
        return half2(atan2(-dir.z, dir.x) * 0.5h, acos(dir.y)) * M_1_PI_H;
    }
    inline float2 spherical_from_cartesian_fast(float3 dir)
    {
        return float2( atan2_fast(-dir.z, dir.x) * (0.5f * M_1_PI_F), acos_fast(dir.y) * M_1_PI_F);
    }
    inline half2 spherical_from_cartesian_fast(half3 dir)
    {
        return half2( atan2_fast(-dir.z, dir.x) * 0.5h, acos_fast(dir.y)) * M_1_PI_H;
    }
    #define dual_contract_factor  1.0
    template <class T>
    inline vec<T, 2> dual_paraboloid_from_cartesian(vec<T, 3> dir)
    {
        dir.xy /= abs(dir.z) + 1.0;
        dir.y = 0.5 - dir.y * 0.5;
        T s   = sign(dir.z) * 0.25;
        dir.x = s * (dir.x - 1.0) + 0.5;
        return dir.xy;
    }
    
    
    template <class T>
    inline vec<T, 3> cartesian_from_dual_paraboloid(vec<T, 2>  uv)
    {
        
        T zside = 0.5 * sign(0.5 - uv.x);
        uv.x = 1.0 - abs(4.0 * uv.x - 2.0); 
        uv.y   = 1.0 - uv.y * 2.0;
        T z = length_squared(uv); 
        z = (1.0 - z) * zside;
        
        return vec<T, 3>(uv.x, uv.y, z);
    }
    inline float reduce_min(float3 v) {
        return min(v.x, min(v.y, v.z));
    }
    
    inline float reduce_min(float4 v) {
        return min(min(v.x, v.y), min(v.z, v.w));
    }
    inline float reduce_max(float3 v) {
        return max(v.x, max(v.y, v.z));
    }
    inline float reduce_max(float4 v) {
        return max(max(v.x, v.y), max(v.z, v.w));
    }
    
    inline float3 randomSphereDir(float2 rnd)
    {
        float s = rnd.x * M_PI_F * 2.f;
        float t = rnd.y * 2.f - 1.f;
        return float3(sin(s), cos(s), t) / sqrt(1.f + t * t);
    }
    
    
    template <class T>
    inline T interleaved_gradient_noise(vec<T, 2> pos)
    {
        vec<T, 3> magic( 0.06711056f, 0.00583715f, 52.9829189f );
        return fract( magic.z * fract( dot( pos, magic.xy ) ) );
    }
    
    inline float3 hemisphere_reflect(float3 v, float3 nrm)
    {
        return v * sign(dot(v, nrm));
    }
    
    inline float3 randomHemisphereDir(float3 dir, float2 rnd)
    {
        return hemisphere_reflect(randomSphereDir( rnd ), dir);
    }
    
    inline void orthogonal_basis(float3 n, thread float3& xp, thread float3& yp)
    {
        
        float sz = n.z >= 0.f ? 1.f : -1.f;
        float a  =  n.y / (1.f + abs(n.z));
        float b  =  n.y * a;
        float c  = -n.x * a;
        
        xp = float3(n.z + sz * b,   sz * c,     -n.x);
        yp = float3(c,              1.f - b,    -sz * n.y);
    }
    template <class U>
    inline float2 normalized_coordinate(ushort2 index, U texture)
    {
        uint width  = texture.get_width();
        uint height = texture.get_height();
        
        float u = width  == 1 ? 0.5f : float(index.x) / float(width - 1);
        float v = height == 1 ? 0.5f : float(index.y) / float(height - 1);
        
        return float2(u, v);
    }
    template <class U>
    inline float2 normalized_coordinate(uint2 index, U texture)
    {
        uint width  = texture.get_width();
        uint height = texture.get_height();
        
        float u = width  == 1 ? 0.5f : float(index.x) / float(width - 1);
        float v = height == 1 ? 0.5f : float(index.y) / float(height - 1);
        
        return float2(u, v);
    }
    template <class U>
    inline half2 normalized_coordinate_half(uint2 index, U texture)
    {
        uint width  = texture.get_width();
        uint height = texture.get_height();
        
        half u = width  == 1 ? 0.5h : half(index.x) / half(width - 1);
        half v = height == 1 ? 0.5h : half(index.y) / half(height - 1);
        
        return half2(u, v);
    }
    
    template <class T>
    inline vec<T, 3> cubemap_dir_from_sampleCoord(uint face, vec<T, 2> sampleCoord) 
    {
        switch(face) {
            case 0: 
                return vec<T, 3>( 1.0, -sampleCoord.y, -sampleCoord.x);
            case 1: 
                return vec<T, 3>(-1.0, -sampleCoord.y,  sampleCoord.x);
            case 2: 
                return vec<T, 3>(sampleCoord.x,  1.0,  sampleCoord.y);
            case 3: 
                return vec<T, 3>(sampleCoord.x, -1.0, -sampleCoord.y);
            case 4: 
                return vec<T, 3>( sampleCoord.x, -sampleCoord.y,  1.0);
            default: 
                return vec<T, 3>(-sampleCoord.x, -sampleCoord.y, -1.0);
        }
    }
    
    template <class T>
    inline T signed_unit(T uv) {
        return uv * 2.0 - 1.0;
    }
    
    template <class T>
    inline T unsigned_unit(T uv) {
        return uv * 0.5 + 0.5;
    }
    template <class T>
    inline vec<T, 3> cubemap_dir_from_uv(uint face, vec<T, 2> uv) 
    {
        return cubemap_dir_from_sampleCoord(face, signed_unit(uv));
    }
    template <class T>
    inline vec<T, 3> cubemap_dir_from_uv_unit(uint face, vec<T, 2> uv) 
    {
        return normalize(cubemap_dir_from_uv(face, uv));
    }
    
    
    inline float2 barycentric_mix(float2 __x, float2 __y, float2 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }
    inline float3 barycentric_mix(float3 __x, float3 __y, float3 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }
    inline float4 barycentric_mix(float4 __x, float4 __y, float4 __z, float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }
    
    static inline float rect(float2 lt, float2 rb, float2 uv)
    {
        float2 borders = step(lt, uv) * step(uv, rb);
        return borders.x * borders.y;
    }
    
    inline half4 debugColorForCascade(int cascade)
    {
        switch (cascade) {
            case 0:
            return half4(1.h, 0.h, 0.h, 1.h);
            case 1:
            return half4(0.9, 0.5, 0., 1.);
            case 2:
            return half4(1., 1., 0., 1.);
            case 3:
            return half4(0., 1., 0., 1.);
            default:
            return half4(0., 0., 0., 1.);
        }
    }
    inline half3 debugColorForFace(int count)
    {
        switch (count) {
            case 0:  return half3(1.0h, 0.1h, 0.1h);
            case 1:  return half3(0.1h, 1.0h, 1.0h);
            case 2:  return half3(0.1h, 1.0h, 0.1h);
            case 3:  return half3(1.0h, 0.1h, 1.0h);
            case 4:  return half3(0.1h, 0.1h, 1.0h);
            default: return half3(1.0h, 1.0h, 0.1h);
        }
    }
    inline half4 debugColorForCount(int count)
    {
        switch (count) {
            case 0: return half4(0.0h, 0.0h, 0.0h, 1.h);
            case 1: return half4(0.0h, 0.0h, 0.4h, 1.h);
            case 2: return half4(0.0h, 0.0h, 0.9h, 1.h);
            case 3: return half4(0.0h, 0.4h, 0.7h, 1.h);
            case 4: return half4(0.0h, 0.9h, 0.4h, 1.h);
            case 5: return half4(0.0h, 0.9h, 0.0h, 1.h);
            case 6: return half4(0.4h, 0.7h, 0.0h, 1.h);
            case 7: return half4(0.9h, 0.7h, 0.0h, 1.h);
            default: return half4(1., 0., 0., 1.);
        }
    }
    inline float grid(float2 lt, float2 rb, float2 gridSize, float thickness, float2 uv)
    {
        float insideRect = rect(lt, rb + thickness, uv);
        float2 gt = thickness * gridSize;
        float2 lines = step(abs(lt - fract(uv * gridSize)), gt);
        return insideRect * (lines.x + lines.y);
    }
    inline float checkerboard(float2 gridSize, float2 uv)
    {
        float2 check = floor(uv * gridSize);
        return step(fmod(check.x + check.y, 2.f), 0.f);
    }
    
    
    inline float luminance(float3 color)
    {
        
        
        return color.r * 0.212671 + color.g * 0.715160 + color.b * 0.072169;
    }
    
    inline float srgb_to_linear(float c)
    {
        return (c <= 0.04045f) ? c / 12.92f : powr((c + 0.055f) / 1.055f, 2.4f);
    }
    
    inline half srgb_to_linear_fast(half c)
    {
        return powr(c, 2.2h);
    }
    
    inline half3 srgb_to_linear_fast(half3 c)
    {
        return powr(c, 2.2h);
    }
    
    inline half srgb_to_linear(half c)
    {
        
        return (c <= 0.04045h) ? (c * 0.0773993808h) :  powr(0.9478672986h * c + 0.05213270142h, 2.4h);
    }
    
    inline float3 srgb_to_linear(float3 c)
    {
        return float3(srgb_to_linear(c.x), srgb_to_linear(c.y), srgb_to_linear(c.z));
    }
    
    inline float linear_to_srgb(float c)
    {
        return (c < 0.0031308f) ? (12.92f * c) : (1.055f * powr(c, 1.f/2.4f) - 0.055f);
    }
    
    inline float3 linear_to_srgb(float3 v) { 
        return float3(linear_to_srgb(v.x), linear_to_srgb(v.y), linear_to_srgb(v.z));
    }
    
template <typename T>
inline T dFdx(T v) {
    return dfdx(v);
template <typename T>
inline T dFdy(T v) {
    return -dfdy(v);
inline float4 texture2DProj(texture2d<float> tex, sampler smp, float4 uv)
    return tex.sample(smp, uv.xy / uv.w);
inline half4 texture2DProj(texture2d<half> tex, sampler smp, float4 uv)
    return tex.sample(smp, uv.xy / uv.w);
static constexpr sampler scn_shadow_sampler_rev_z = sampler(coord::normalized, filter::linear, mip_filter::none, address::clamp_to_zero, compare_func::less_equal);
static constexpr sampler scn_shadow_sampler_ord_z = sampler(coord::normalized, filter::linear, mip_filter::none, address::clamp_to_edge, compare_func::greater_equal);
#if defined(USE_REVERSE_Z) && USE_REVERSE_Z
static constexpr sampler scn_shadow_sampler = scn_shadow_sampler_rev_z;
#else
static constexpr sampler scn_shadow_sampler = scn_shadow_sampler_ord_z;
#endif
inline float shadow2D(sampler shadow_sampler, depth2d<float> tex, float3 uv)
    return tex.sample_compare(shadow_sampler, uv.xy, uv.z);
inline float shadow2DProj(sampler shadow_sampler, depth2d<float> tex, float4 uv)
    float3 uvp = uv.xyz / uv.w;
    return tex.sample_compare(shadow_sampler, uvp.xy, uvp.z);
inline float shadow2DArray(sampler shadow_sampler, depth2d_array<float> tex, float3 uv, uint slice)
    return tex.sample_compare(shadow_sampler, uv.xy, slice, uv.z);
inline float shadow2DArrayProj(sampler shadow_sampler, depth2d_array<float> tex, float4 uv, uint slice)
    float3 uvp = uv.xyz / uv.w;
    return tex.sample_compare(shadow_sampler, uvp.xy, slice, uvp.z);
inline float4 transformViewPosInShadowSpace(float3 pos, float4x4 shadowMatrix, bool reverseZ)
    
    float4 lightScreen =  shadowMatrix * float4(pos, 1.f);
    
    
    
    if (!reverseZ) {
        lightScreen.z = min(lightScreen.z, 0.9999f * lightScreen.w);
    } else {
        if (lightScreen.z <= 0.0) { 
            lightScreen.z = 2.0;
        }
    }
    return lightScreen;
inline float ComputeShadow(sampler shadow_sampler, float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap, bool reverseZ)
    float4 lightScreen =  transformViewPosInShadowSpace(worldPos, shadowMatrix, reverseZ);
    float shadow = shadow2DProj(shadow_sampler, shadowMap, lightScreen);
    
    shadow *= step(0., lightScreen.w);
    
    return shadow;
inline float ComputeSoftShadowGrid(sampler shadow_sampler, float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap, int sampleCount, bool reverseZ)
    float4 lightScreen =  transformViewPosInShadowSpace(worldPos, shadowMatrix, reverseZ);
    
    float shadow;
    if (sampleCount <= 1) {
        shadow = shadow2DProj(shadow_sampler, shadowMap, lightScreen);
    } else {
        float3 uvp = lightScreen.xyz / lightScreen.w;
        uvp.z += reverseZ ? 0.005f : -0.005f; 
        float2 texelSize = 2.f / float2(shadowMap.get_width(), shadowMap.get_height());
        float2 origin    = uvp.xy - (sampleCount * 0.5f) * texelSize;
        
        if (sampleCount <= 4) { 
            half totalAccum = 0.h;
            for (int y = 0; y < sampleCount; ++y) {
                for (int x = 0; x < sampleCount; ++x) {
                    totalAccum  += half(shadowMap.sample_compare(shadow_sampler, origin, uvp.z, 2 * int2(x,y)));
                }
            }
            shadow = totalAccum / half(sampleCount * sampleCount);
        } else {
            float totalAccum = 0.f;
            for (int y = 0; y < sampleCount; ++y) {
                for (int x = 0; x < sampleCount; ++x) {
                    float2 samplePos = origin + texelSize * float2(x, y);
                    totalAccum  += shadowMap.sample_compare(shadow_sampler, samplePos, uvp.z);
                }
            }
            shadow = totalAccum / float(sampleCount * sampleCount);
        }
    }
    
    shadow *= step(0., lightScreen.w);
    return shadow;
inline float ComputeSoftShadow(sampler shadow_sampler, float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount, float shadowRadius, bool reverseZ)
    float4 lightScreen =  transformViewPosInShadowSpace(worldPos, shadowMatrix, reverseZ);
    
    float shadow;
    if (sampleCount <= 1) {
        shadow = shadow2DProj(shadow_sampler, shadowMap, lightScreen);
    } else {
        
        float3 center_uv = lightScreen.xyz / lightScreen.w;
        float3 scale_uv  = float3(shadowRadius, shadowRadius, reverseZ ? shadowRadius * center_uv.z : shadowRadius / lightScreen.w );
        
        float totalAccum = 0.0;
        for (int i = 0; i < sampleCount; i++) {
            totalAccum += shadow2D(shadow_sampler, shadowMap, center_uv + shadowKernel[i].xyz * scale_uv);
        }
        
        shadow = totalAccum / float(sampleCount);
    }
    
    shadow *= step(0., lightScreen.w);
    return shadow;
inline float ComputeCascadeBlendAmount(float3 shadowPos, bool cascadeBlending)
    const float cascadeBlendingFactor = 0.1f; 
    float3 cascadePos = abs(shadowPos.xyz * 2.f - 1.f);
    
    if (cascadeBlending) {
#if 0
        const float edge = 1.f - cascadeBlendingFactor;
        
        cascadePos = 1.f - saturate((cascadePos - edge) / cascadeBlendingFactor);
        return cascadePos.x * cascadePos.y * cascadePos.z; 
#else
        
        float distToEdge = 1.0f - max(max(cascadePos.x, cascadePos.y), cascadePos.z);
        return smoothstep(0.0f, cascadeBlendingFactor, distToEdge);
#endif
    } else {
        return step(cascadePos.x, 1.f) * step(cascadePos.y, 1.f) * step(cascadePos.z, 1.f);
    }
inline float4 SampleShadowCascade(sampler shadow_sampler, depth2d_array<float> shadowMaps, float3 shadowPosition, uint cascadeIndex, constant float4* shadowKernel, int sampleCount, float shadowRadius)
    
    float2 gridSize = float2(shadowMaps.get_width(), shadowMaps.get_height()) / 32;
    float gd = scn::checkerboard(shadowPosition.xy, gridSize);
    float3 gridCol = mix(float3(scn::debugColorForCascade(cascadeIndex).rgb), float3(0.f), float3(gd > 0.f));
    
    float shadow = 0.f;
    if (sampleCount > 1) {
        
        for (int i = 0; i < sampleCount; ++i) {
            shadow += shadow2DArray(shadow_sampler, shadowMaps, shadowKernel[i].xyz * shadowRadius + shadowPosition, cascadeIndex);
        }
        shadow /= float(sampleCount);
    } else {
        
        shadow = shadow2DArray(shadow_sampler, shadowMaps, shadowPosition, cascadeIndex);
    }
    return float4(gridCol, shadow);
inline float4 ComputeCascadedShadow(sampler shadow_sampler, float3 viewPos, float4x4 shadowMatrix, constant float4 *cascadeScale, constant float4 *cascadeBias, int cascadeCount, depth2d_array<float> shadowMaps, bool enableCascadeBlending, constant float4* shadowKernel, int sampleCount, float shadowRadius)
    float4 shadow = 0.f;
    float opacitySum = 1.f;
    
    
    float3 pos_ls =  (shadowMatrix * float4(viewPos, 1.f)).xyz;
    for (int c = 0; c < cascadeCount; ++c) {
        
        float3 pos_cs =  pos_ls * cascadeScale[c].xyz + cascadeBias[c].xyz;
        
        float cascadeRadius = shadowRadius * cascadeScale[c].x;
        float opacity = ComputeCascadeBlendAmount(pos_cs, enableCascadeBlending);
        if (opacity > 0.f) { 
            
            float alpha = opacity * opacitySum;
            shadow += SampleShadowCascade(shadow_sampler, shadowMaps, pos_cs, c, shadowKernel, sampleCount, cascadeRadius) * alpha;
            opacitySum -= alpha;
        }
        if (opacitySum <= 0.f) 
            break;
    }
    return shadow;
#define USE_QUAT_FOR_IES 1
#define USE_PBR_DOMINANT_DIRECTION 1
struct scn_light
    float4 color; 
    float3 pos; 
    float3 dir; 
    float shadowRadius; 
    uint8_t lightType; 
    uint8_t attenuationType; 
    uint8_t shadowSampleCount; 
                                
    union {
        struct {
            float4      cascadeScale[4]; 
            float4      cascadeBias[4];
        } directional; 
        struct {
            float4      attenuationFactors; 
            float3      shadowScaleBias; 
        } omni;
        struct {
            float4      _attenuationFactors; 
            float2      scaleBias; 
        } spot;
        struct {
            float4      _attenuationFactors; 
            float2      scaleBias; 
#if USE_QUAT_FOR_IES
            float4      light_from_view_quat; 
#else
            float4x4    light_from_view; 
#endif
        } ies;
        union {
            struct {
                float2 halfExtents;
                float doubleSided;
            } rectangle;
            struct {
                uint32_t vertexCount;
                float doubleSided;
            } polygon;
            struct {
                float halfLength;
            } line;
            struct {
                float2 halfExtents;
                float doubleSided;
            } ellipse;
            struct {
                float3 halfExtents;
            } ellipsoid;
        } area;
        struct {
            float3  offset;
            float4  halfExtents; 
            float3  parallaxCenter;
            float3  parallaxExtents;
            int32_t index; 
            int32_t parallaxCorrection; 
        } probe;
    } parameters; 
    float4x4    shadowMatrix; 
#if defined(__METAL_VERSION__) 
using namespace metal;
namespace scn {
    static constexpr sampler linearSampler = sampler(filter::linear, mip_filter::linear);
#define ambientOcclusionTexcoord ambientTexcoord
struct SCNShaderSurface {
    float3 view;                
    float3 position;            
    float3 normal;              
    float3 geometryNormal;      
    float2 normalTexcoord;      
    float3 tangent;             
    float3 bitangent;           
    float4 ambient;             
    float2 ambientTexcoord;     
    float4 diffuse;             
    float2 diffuseTexcoord;     
    float4 specular;            
    float2 specularTexcoord;    
    float4 emission;            
    float2 emissionTexcoord;    
    float4 selfIllumination;            
    float2 selfIlluminationTexcoord;    
    float4 multiply;            
    float2 multiplyTexcoord;    
    float4 transparent;         
    float2 transparentTexcoord; 
    float4 reflective;          
    float  metalness;           
    float2 metalnessTexcoord;   
    float  roughness;           
    float2 roughnessTexcoord;   
    float clearCoat;            
    float2 clearCoatTexcoord;   
    float clearCoatRoughness;   
    float2 clearCoatRoughnessTexcoord;
    float3 clearCoatNormal;     
    float2 clearCoatNormalTexcoord;
    float shininess;            
    float fresnel;              
    float ambientOcclusion;     
    float3 _normalTS;           
    float3 _clearCoatNormalTS;  
#ifdef USE_SURFACE_EXTRA_DECL
    __SurfaceExtraDecl__
#endif
struct SCNShaderLight {
    float4 intensity;
    float3 direction;
    float  _att;
    float3 _spotDirection;
    float  _distance;
enum SCNLightingModel
    SCNLightingModelConstant,
    SCNLightingModelLambert,
    SCNLightingModelPhong,
    SCNLightingModelBlinn,
    SCNLightingModelNone,
    SCNLightingModelPhysicallyBased,
    SCNLightingModelShadowOnly,
    SCNLightingModelCustom 
enum C3DLightAttenuationType
    kC3DLightAttenuationTypeNone,
    kC3DLightAttenuationTypeConstant,
    kC3DLightAttenuationTypeLinear,
    kC3DLightAttenuationTypeQuadratic,
    kC3DLightAttenuationTypeExponent,
    kC3DLightAttenuationTypePhysicallyBased,
#define PROBES_NORMALIZATION 0
#define PROBES_OUTER_BLENDING 1
struct SCNShaderLightingContribution
    float3 ambient;
    float3 diffuse;
    float3 specular;
    float3 modulate;
#ifdef USE_SHADOWONLY
    float shadowFactor;
#endif
#if PROBES_NORMALIZATION
    float4 probesWeightedSum; 
#else
    float  probeRadianceRemainingFactor;
#endif
    thread SCNShaderSurface& surface;
#ifdef USE_PER_VERTEX_LIGHTING
    commonprofile_io out;
#else
    commonprofile_io in;
#endif
#if USE_REVERSE_Z
    constant static constexpr bool reverseZ = true;
#else
    constant static constexpr bool reverseZ = false;
#endif
#ifdef USE_PBR
    struct {
        float3 albedo;
        float3 envDiffuse;
        float3 envSpecular;
        float3 reflectance;
        float3 probeReflectance;
#ifndef USE_PBR_LAMBERTIAN_REFLECTION
        float2 diffuseHammonFactors;
#endif
#ifdef USE_PBR_TRANSPARENCY
        float  transparency;
#endif
        float  NoV;
        float  selfIlluminationOcclusion;
#ifdef USE_CLEARCOAT
        float  NoVClearCoat;
        float3 probeReflectanceClearCoat;
#endif
    } pbr;
#endif
    
    SCNShaderLightingContribution(thread SCNShaderSurface& iSurface, commonprofile_io io):surface(iSurface)
#ifdef USE_PER_VERTEX_LIGHTING
    ,out(io)
#else
    ,in(io)
#endif
    {
        ambient = 0.f;
        diffuse = 0.f;
        specular = 0.f;
#ifdef USE_SHADOWONLY
        shadowFactor = 1.f;
#endif
#if PROBES_NORMALIZATION
#if PROBES_OUTER_BLENDING
        probesWeightedSum = float4(0.f);
#else
        probesWeightedSum = float4(0.f, 0.f, 0.f, 0.000001f); 
#endif
#else
        probeRadianceRemainingFactor = 1.f;
#endif
#ifdef USE_MODULATE
        modulate = 1.f;
#else
        modulate = 0.f;
#endif
    }
#ifdef USE_PBR
    void prepareForPBR(texture2d<float, access::sample> specularDFGDiffuseHammonTexture, float occ)
    {
        pbr.envDiffuse = 0.f;
        pbr.envSpecular = 0.f;
        pbr.selfIlluminationOcclusion = occ;
      
        pbr.albedo = surface.diffuse.rgb;
#ifdef USE_PBR_TRANSPARENCY
  #ifdef DIFFUSE_PREMULTIPLIED
        
        pbr.transparency = 1.f;
  #else
        pbr.transparency = surface.diffuse.a;
  #endif
  #ifdef USE_TRANSPARENCY
    #ifdef USE_PER_VERTEX_LIGHTING
        pbr.transparency *= out.transparency;
    #else
        pbr.transparency *= in.transparency;
    #endif
  #endif
  #ifdef USE_TRANSPARENT
        
        pbr.transparency *= surface.transparent.a;
  #endif
        pbr.albedo *= pbr.transparency;
  #ifdef DIFFUSE_PREMULTIPLIED
        
        
        pbr.transparency *= surface.diffuse.a;
  #endif
#endif
        
        float3 n = surface.normal;
        float3 v = surface.view;
        pbr.NoV = abs(dot(n, v));
        
        float roughness = surface.roughness;
#ifdef USE_PBR_LAMBERTIAN_REFLECTION
        float2 specularDFG = specularDFGDiffuseHammonTexture.sample(scn::linearSampler, float2(pbr.NoV, roughness)).rg;
#else
        float4 env = specularDFGDiffuseHammonTexture.sample(scn::linearSampler, float2(pbr.NoV, roughness));
        float2 specularDFG = env.xy;
        pbr.diffuseHammonFactors = env.zw;
#endif
        
        pbr.reflectance = mix(PBR_F0_NON_METALLIC, pbr.albedo, surface.metalness);
        pbr.probeReflectance = pbr.reflectance * specularDFG.r + specularDFG.g;
                                
#ifdef USE_CLEARCOAT
        pbr.NoVClearCoat = abs(dot(surface.clearCoatNormal, v));
        float2 DFGClearCoat = specularDFGDiffuseHammonTexture.sample(scn::linearSampler, float2(pbr.NoVClearCoat, surface.clearCoatRoughness)).rg;
        pbr.probeReflectanceClearCoat = 0.04 * DFGClearCoat.r + DFGClearCoat.g;
#endif
    }
#endif
#ifdef USE_LIGHT_MODIFIER
    __LightModifierExtraDecl__
#endif
    float4 debug_pixel(float2 fragmentPosition)
    {
        const int width = 64;
        switch (int(fragmentPosition.x + fragmentPosition.y ) / width) {
            case 0: return float4(surface.view, 1.f);
            case 1: return float4(surface.position, 1.f);
            case 2: return float4(surface.normal, 1.f);
            case 3: return float4(surface.geometryNormal, 1.f);
            case 4: return float4(float3(surface.ambientOcclusion), 1.f);
            case 5: return surface.diffuse;
            case 6: return float4(float3(surface.metalness), 1.f);
            case 7: return float4(float3(surface.roughness), 1.f);
            case 8: return float4(ambient, 1.f);
            case 9: return float4(diffuse, 1.f);
            default: return float4(specular, 1.f);
        }
    }
    
    static inline float3 lambert_diffuse(float3 l, float3 n, float3 color, float intensity) {
        return color * (intensity * saturate(dot(n, l)));
    }
    void lambert(float3 l, float3 color, float intensity)
    {
        diffuse += lambert_diffuse(l, surface.normal, color, intensity);
    }
    void blinn(float3 l, float3 color, float intensity)
    {
        float3 D = lambert_diffuse(l, surface.normal, color, intensity);
        diffuse += D;
        float3 h = normalize(l + surface.view);
        specular += powr(saturate(dot(surface.normal, h)), surface.shininess) * D;
    }
    void phong(float3 l, float3 color, float intensity)
    {
        float3 D = lambert_diffuse(l, surface.normal, color, intensity);
        diffuse += D;
        float3 r = reflect(-l, surface.normal);
        specular += powr(saturate(dot(r, surface.view)), surface.shininess) * D;
    }
#ifdef USE_PBR
    void physicallyBased(float3 l, float3 color, float intensity)
    {
        float3 n         = surface.normal;
        float3 v         = surface.view;
        float  roughness = surface.roughness;
        float  alpha     = roughness * roughness;
        float3 h = normalize(l + v);
        float NoL = saturate(dot(n, l));
        float NoH = saturate(dot(n, h));
        float LoH = saturate(dot(l, h));
        
        float D   = scn_brdf_D(alpha, NoH);
        float3 F  = scn_brdf_F_opt(pbr.reflectance, LoH);
        float Vis = scn_brdf_V(alpha, NoL, pbr.NoV);
        
        diffuse  += color * (NoL * M_1_PI_F * intensity);
        specular += color * F * (NoL * D * Vis * intensity);
        
        #ifdef USE_CLEARCOAT
            n = surface.clearCoatNormal;
            roughness = max(surface.clearCoatRoughness, 0.089f);
            alpha = roughness * roughness; 
        
            
            
            float NoH_coat = saturate(dot(n, h));
            float NoL_coat = saturate(dot(n, l));
            D   = scn_brdf_D(alpha, NoH_coat);
            F   = scn_brdf_F_opt(0.04, LoH) * surface.clearCoat;
            Vis = scn_brdf_V(alpha, NoL_coat, saturate(dot(n,v)));
        
            float attenuation = 1.0 - F.r;
            specular *=  (attenuation * attenuation);
            specular += color * F * ( NoL_coat * D * Vis * intensity);
        #endif
    }
#endif
    void custom(float3 _l, float3 _color, float _intensity)
    {
#ifdef USE_LIGHT_MODIFIER
        thread SCNShaderLightingContribution &_lightingContribution = *this;
        thread SCNShaderSurface& _surface = surface;
        SCNShaderLight _light = {.direction = _l, .intensity = float4(_color, 1.f), ._att = _intensity };
        
        __DoLightModifier__
        
#endif
    }
    void shade(float3 l, float3 color, float intensity)
    {
#ifdef LIGHTING_MODEL
        switch (LIGHTING_MODEL) {
#ifdef USE_SHADOWONLY
            case SCNLightingModelShadowOnly:        shadowFactor *= intensity; break;
#endif
            case SCNLightingModelLambert:           lambert(l, color, intensity); break;
            case SCNLightingModelBlinn:             blinn(l, color, intensity);   break;
            case SCNLightingModelPhong:             phong(l, color, intensity);   break;
#ifdef USE_PBR
            case SCNLightingModelPhysicallyBased:   physicallyBased(l, color, intensity); break;
#endif
            case SCNLightingModelCustom:            custom(l, color, intensity);  break;
            default:  break; 
        }
#endif
    }
    
    
    
    float pbr_dist_attenuation_alternate(float3 l, float cutoff) {
        
        float radius = 0.1f; 
        float factor = 1.f / (1.f + length(l)/radius);
        float attenuation = saturate(factor * factor); 
        return saturate((attenuation - cutoff) / (1.f - cutoff));
    }
    float pbr_dist_attenuation(float3 l, float inv_square_radius) {
        float sqr_dist = length_squared(l);
        float atten = 1.f / max(sqr_dist, 0.0001f);
        
        float factor = saturate(1.f - scn::sq(sqr_dist * inv_square_radius));
        return atten * factor * factor;
    }
    float non_pbr_dist_attenuation(float3 l, float4 att)
    {
        return powr(saturate(length(l) * att.x + att.y), att.z);
    }
    float dist_attenuation(float3 unnormalized_l, scn_light light)
    {
#ifdef USE_PBR
        return 1000.f * pbr_dist_attenuation(unnormalized_l, light.parameters.omni.attenuationFactors.w);
        
        
#else
#ifdef USE_SHADOWONLY
        return 1.f;
#endif
        return non_pbr_dist_attenuation(unnormalized_l, light.parameters.omni.attenuationFactors);
#endif
    }
    float spot_attenuation(float3 l, scn_light light)
    {
#ifdef USE_SHADOWONLY
        return 1.f;
#endif
        
        return saturate(dot(l, light.dir) * light.parameters.spot.scaleBias.x + light.parameters.spot.scaleBias.y);
    }
    void shade_modulate(float3 l, float4 color, float intensity)
    {
        constexpr half3 white = half3(1.h);
        
        modulate *= float3(mix(white, half3(color.rgb), half(color.a * intensity)));
    }
    float3 gobo(float3 pos, scn_light light, texture2d<half> goboTexture, sampler goboSampler)
    {
        half3 g = texture2DProj(goboTexture, goboSampler, (light.shadowMatrix * float4(pos, 1.f))).rgb;
        return light.color.rgb * float3(mix(1.h, g, half(light.color.a)));
    }
    float shadow(float3 pos, scn_light light, depth2d<float> shadowMap)
    {
        float shadow = ComputeShadow(scn_shadow_sampler, pos, light.shadowMatrix, shadowMap, reverseZ);
        return 1.f - shadow * light.color.a; 
    }
    
    float shadow(float3 pos, scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel)
    {
        float shadow = ComputeSoftShadow(scn_shadow_sampler, pos, light.shadowMatrix, shadowMap, shadowKernel, light.shadowSampleCount, light.shadowRadius, reverseZ);
        return 1.f - shadow * light.color.a; 
    }
    float shadow(float3 pos, scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int shadowSampleCount)
    {
        float shadow = ComputeSoftShadow(scn_shadow_sampler, pos, light.shadowMatrix, shadowMap, shadowKernel, shadowSampleCount, light.shadowRadius, reverseZ);
        return 1.f - shadow * light.color.a; 
    }
    float shadow(float3 pos, scn_light light, depth2d<float> shadowMap, int shadowSampleCount)
    {
        float shadow = ComputeSoftShadowGrid(scn_shadow_sampler, pos, light.shadowMatrix, shadowMap, shadowSampleCount, reverseZ);
        return 1.f - shadow * light.color.a; 
    }
    float shadow_omni(float3 pos_vs, float3 nrm_vs, scn_light light, depthcube<float> shadowMap, constant float4* shadowKernel, int sampleCount)
    {
        
#define USE_TANGENT_SAMPLING 0
        float2 scaleBias = light.parameters.omni.shadowScaleBias.xy;
        float  depthBias = light.parameters.omni.shadowScaleBias.z;
        
        pos_vs += nrm_vs * depthBias;
        
        float3 pos_ls = (light.shadowMatrix * float4(pos_vs, 1.f)).xyz;
        
        float z_lin = scn::reduce_max(abs(pos_ls));
        
        
        
        
        float z_ndc = (z_lin * scaleBias.x + scaleBias.y) / z_lin - depthBias;
        
        float shadow;
        if (sampleCount <= 1) {
            shadow = shadowMap.sample_compare(scn_shadow_sampler, pos_ls.xyz, z_ndc);
        } else {
            
            float filteringSizeFactor = light.shadowRadius;
#if USE_TANGENT_SAMPLING
            float3 tgt_x, tgt_y;
            scn::orthogonal_basis(pos_ls, tgt_x, tgt_y);
#else
            float3 nrm_ls = (light.shadowMatrix * float4(nrm_vs, 0.f)).xyz;
#endif
            
            float totalAccum = 0.0;
            for(int i=0; i < sampleCount; i++){
#if USE_TANGENT_SAMPLING
                float2 scale = shadowKernel[i].xy * filteringSizeFactor * 2.f;
                float3 smp_ls = pos_ls.xyz + tgt_x * scale.x + tgt_y * scale.y;
#else
                float3 smp_ls = pos_ls.xyz + scn::randomHemisphereDir(nrm_ls, shadowKernel[i].xy) * filteringSizeFactor;
#endif
                
                
                
                totalAccum += shadowMap.sample_compare(scn_shadow_sampler, smp_ls, z_ndc);
            }
            shadow = totalAccum / float(sampleCount);
        }
        return 1.f - shadow * light.color.a; 
    }
    float shadow(float3 pos, constant scn_light& light, depth2d_array<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount)
    {
        float shadow = ComputeCascadedShadow(scn_shadow_sampler, pos, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius).a;
        return 1.f - shadow * light.color.a; 
    }
    
    void add_directional(scn_light light)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        shade(light.dir, light.color.rgb, intensity);
    }
    
    void add_directional(scn_light light, texture2d<half> goboTexture, sampler goboSampler, bool modulated)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);
        if (modulated) {
            shade_modulate(light.dir, light.color, 1.f);
        } else {
            shade(light.dir, light.color.rgb, intensity);
        }
    }
    
    void add_directional(scn_light light, depth2d<float> shadowMap)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        intensity *= shadow(surface.position, light, shadowMap);
        shade(light.dir, light.color.rgb, intensity);
    }
    
    void add_directional(scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        intensity *= shadow(surface.position, light, shadowMap, shadowKernel);
        shade(light.dir, light.color.rgb, intensity);
    }
    void add_directional(scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        intensity *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);
        shade(light.dir, light.color.rgb, intensity);
    }
    
    void add_directional(scn_light light, depth2d<float> shadowMap, int sampleCount)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        intensity *= shadow(surface.position, light, shadowMap, sampleCount);
        shade(light.dir, light.color.rgb, intensity);
    }
    
    void add_directional(constant scn_light& light, depth2d_array<float> shadowMaps, int cascadeCount, bool blendCascade, constant float4* shadowKernel, int sampleCount, bool debugCascades)
    {
#ifdef USE_PBR
        float intensity = M_PI_F;
#else
        float intensity = 1.f;
#endif
        if (debugCascades) {
            float4 shadowDebug = ComputeCascadedShadow(scn_shadow_sampler, surface.position, light.shadowMatrix, light.parameters.directional.cascadeScale, light.parameters.directional.cascadeBias, cascadeCount, shadowMaps, blendCascade, shadowKernel, sampleCount, light.shadowRadius);
            intensity *= (1.f - shadowDebug.a);
            shade(light.dir, light.color.rgb, intensity);
            diffuse.rgb = mix(diffuse.rgb, shadowDebug.rgb, light.color.a);
        } else {
            intensity *= shadow(surface.position, light, shadowMaps, cascadeCount, blendCascade, shadowKernel, sampleCount);
            shade(light.dir, light.color.rgb, intensity);
        }
    }
    
    void add_omni(scn_light light)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        shade(l, light.color.rgb, dist_attenuation(unnormalized_l, light));
    }
    void add_omni(scn_light light, depthcube<float> shadowMap, constant float4* shadowKernel, int sampleCount)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity *= shadow_omni(surface.position, surface.normal, light, shadowMap, shadowKernel, sampleCount);
        shade(l, light.color.rgb, intensity);
    }
    void add_local_omni(scn_light light)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        shade(l, light.color.rgb, dist_attenuation(unnormalized_l, light));
    }
    
    void add_spot(scn_light light)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity      *= spot_attenuation(l, light);
        shade(l, light.color.rgb, intensity);
    }
    void add_spot(scn_light light, texture2d<half> goboTexture, sampler goboSampler, bool modulated)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity      *= spot_attenuation(l, light);
        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);
        if (modulated) {
            shade_modulate(l, light.color, intensity);
        } else {
            shade(l, light.color.rgb, intensity);
        }
    }
    void add_local_spot(scn_light light)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity      *= spot_attenuation(l, light);
        shade(l, light.color.rgb, intensity);
    }
    
    void add_spot(scn_light light, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity      *= spot_attenuation(l, light);
        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);
        shade(l, light.color.rgb, intensity);
    }
    
    void add_spot(scn_light light, 
                  depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount,
                  texture2d<half> goboTexture, sampler goboSampler)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity      *= spot_attenuation(l, light);
        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);
        light.color.rgb = gobo(surface.position, light, goboTexture, goboSampler);
        shade(l, light.color.rgb, intensity);
    }
    
#ifdef USE_PBR
    
#ifdef C3D_SUPPORT_CUBE_ARRAY
    void add_local_probe(scn_light light, texturecube_array<half> probeTextureArray)
#else
    void add_local_probe(scn_light light, texture2d_array<half> probeTextureArray)
#endif
    {
#if !PROBES_NORMALIZATION
        if (probeRadianceRemainingFactor <= 0.f)
            return;
#endif
        bool parallaxCorrection = light.parameters.probe.parallaxCorrection;
        int    probeIndex       = light.parameters.probe.index;
        float3 probeExtents     = light.parameters.probe.halfExtents.xyz;
        float  blendDist        = light.parameters.probe.halfExtents.w;
        float3 probeOffset      = light.parameters.probe.offset;
        float3 parallaxExtents  = light.parameters.probe.parallaxExtents;
        float3 parallaxCenter   = light.parameters.probe.parallaxCenter;
        float3 n = surface.normal;
        float3 v = surface.view;
        float3 r = reflect(-v, n); 
        float3 specDir = scn::mat4_mult_float3(light.shadowMatrix, r);
        
        float3 pos_ls = (light.shadowMatrix * float4(surface.position, 1.f)).xyz;
        
        float3 d = abs(pos_ls) - probeExtents;
#if PROBES_OUTER_BLENDING
        if (any(d > blendDist))
#else
        if (any(d > 0.f))
#endif
        {
            return;
        }
#if PROBES_NORMALIZATION
        
        
#if PROBES_OUTER_BLENDING
        float3 nd = saturate(-(d / blendDist) * 0.5f + 0.5f);
#else
        float3 nd = saturate(-(d / blendDist));
#endif
        float probeFactor = (nd.x * nd.y * nd.z) * light.color.r;
#else
        
        float sd = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
#if PROBES_OUTER_BLENDING
        float probeFactor = saturate(1.f - sd / blendDist);
#else
        float probeFactor = saturate(-sd / blendDist);
#endif
        
        
        
        probeFactor *= probeRadianceRemainingFactor * light.color.r; 
#endif
        if (parallaxCorrection ) {
            
            float3 pos_off = pos_ls + parallaxCenter;
            float3 t1 = ( parallaxExtents - pos_off) / specDir;
            float3 t2 = (-parallaxExtents - pos_off) / specDir;
            float3 tmax = max(max(0, t1), t2); 
            float t = min(tmax.x, min(tmax.y, tmax.z));
            
            float3 hit_ls = pos_ls + specDir * t;
            specDir = hit_ls - probeOffset;
        }
        float mipd = float(probeTextureArray.get_num_mip_levels()) - 1.f;
        const float intensity = surface.ambientOcclusion * probeFactor;
        float mips = surface.roughness * mipd;
#ifdef C3D_SUPPORT_CUBE_ARRAY
        float3 LD = float3(probeTextureArray.sample(scn::linearSampler, specDir, probeIndex, level(mips)).rgb);
#else
        float2 specUV = scn::dual_paraboloid_from_cartesian(normalize(specDir));
        float3 LD = float3(probeTextureArray.sample(scn::linearSampler, specUV, probeIndex, level(mips)).rgb);
#endif
        
        
#if PROBES_NORMALIZATION
        probesWeightedSum += float4(LD * intensity * pbr.probeReflectance, probeFactor);
#else
        probeRadianceRemainingFactor = saturate(probeRadianceRemainingFactor - probeFactor);
        specular += LD * intensity * pbr.probeReflectance;
#endif
        
#ifdef USE_CLEARCOAT
        n = surface.clearCoatNormal;
        r = reflect(-v, n);
        specDir = scn::mat4_mult_float3(light.shadowMatrix, r);
        if (parallaxCorrection ) {
            float3 pos_off = pos_ls + parallaxCenter;
            
            float3 t1 = ( parallaxExtents - pos_off) / specDir;
            float3 t2 = (-parallaxExtents - pos_off) / specDir;
            float3 tmax = max(max(0, t1), t2); 
            float t = min(tmax.x, min(tmax.y, tmax.z));
            
            
            float3 hit_ls = pos_ls + specDir * t;
            specDir = hit_ls - probeOffset;
        }
        mips = surface.clearCoatRoughness * mipd;
#ifdef C3D_SUPPORT_CUBE_ARRAY
        LD = float3(probeTextureArray.sample(scn::linearSampler, specDir, probeIndex, level(mips)).rgb);
#else
        specUV = scn::dual_paraboloid_from_cartesian(normalize(specDir));
        LD = float3(probeTextureArray.sample(scn::linearSampler, specUV, probeIndex, level(mips)).rgb);
#endif
#if PROBES_NORMALIZATION
        probesWeightedSum += float4(LD * intensity * pbr.probeReflectanceClearCoat, probeFactor) * surface.clearCoat;
#else
        specular += LD * intensity * pbr.probeReflectanceClearCoat * surface.clearCoat;
#endif
#endif
    }
    void add_global_probe(float4x4 localDirToWorldCubemapDir,
                          float environmentIntensity,
#ifdef C3D_SUPPORT_CUBE_ARRAY
                          texturecube_array<half> probeTextureArray
#else
                          texture2d_array<half> probeTextureArray
#endif
                          )
    {
        float3 n = surface.normal;
        float3 v = surface.view;
        float3 r = reflect(-v, n); 
        
        float3 specDir = scn::mat4_mult_float3(localDirToWorldCubemapDir, r);
        float mips = surface.roughness * float(probeTextureArray.get_num_mip_levels() - 1);
#ifdef C3D_SUPPORT_CUBE_ARRAY
        float3 LD = float3(probeTextureArray.sample(scn::linearSampler, specDir, 0, level(mips)).rgb);
#else
        float2 specUV = scn::dual_paraboloid_from_cartesian(normalize(specDir));
        float3 LD = float3(probeTextureArray.sample(scn::linearSampler, specUV, 0, level(mips)).rgb);
#endif
        
        
        specular += pbr.probeReflectance * LD * surface.ambientOcclusion * environmentIntensity;
    }
    void add_global_probe(texturecube<float, access::sample> specularLD,
                          float4x4                           localDirToWorldCubemapDir,
                          float                              environmentIntensity)
    {
        float3 n        = surface.normal;
        float3 v        = surface.view;
        float3 r        = reflect(-v, n); 
        float roughness = surface.roughness;
#if USE_PBR_DOMINANT_DIRECTION
        float alpha = roughness * roughness;
        float smoothness = 1.0f - alpha;
        float specularLerpFactor = (1. - smoothness * (sqrt(smoothness) + alpha));
        float3 specularDominantNDirection = mix(r, n, specularLerpFactor); 
#else
        float3 specularDominantNDirection = r;
#endif
        
        
        float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);
        float3 dir = scn::mat4_mult_float3(localDirToWorldCubemapDir, specularDominantNDirection);
        float3 LD = specularLD.sample(scn::linearSampler, dir, level(mipLevel)).rgb;
        pbr.envSpecular += pbr.probeReflectance * LD * surface.ambientOcclusion * environmentIntensity;
    }
#ifdef USE_CLEARCOAT
    void add_global_probeClearCoat(texturecube<float, access::sample> specularLD,
                          float4x4                           localDirToWorldCubemapDir,
                          float                              environmentIntensity)
    {
        float3 n = surface.clearCoatNormal;
        
        float3 v        = surface.view;
        float3 r        = reflect(-v, n); 
        float roughness = surface.clearCoatRoughness;
        
        float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);
        float3 LD = specularLD.sample(scn::linearSampler, scn::mat4_mult_float3(localDirToWorldCubemapDir, r), level(mipLevel)).rgb;
        LD *= surface.ambientOcclusion;
        
        
        float Fc = scn_brdf_F_opt(0.04f, pbr.NoVClearCoat).r * surface.clearCoat;
        float attenuation = 1.0f - Fc;
        specular *= (attenuation * attenuation);
        
        specular += LD * environmentIntensity * pbr.probeReflectanceClearCoat * surface.clearCoat;
    }
#endif
    
    
    void add_irradiance_from_selfIllum()
    {
        float selfIlluminationAO = saturate(mix(1.f, surface.ambientOcclusion, pbr.selfIlluminationOcclusion));
        float3 irradiance = surface.selfIllumination.rgb;
        
        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);
#ifdef USE_PBR_LAMBERTIAN_REFLECTION
        pbr.envDiffuse += selfIlluminationAO * irradiance * diffuseAlbedo;
#else
        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);
        pbr.envDiffuse += selfIlluminationAO * irradiance * diffuseReflectance;
#endif
    }
    void add_global_irradiance_from_sh(float4x4         localDirToWorldCubemapDir,
#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)
                                       sh2_coefficients shCoefficients)
#else
    sh3_coefficients shCoefficients)
#endif
    {
        float3 n_sh_space = scn::mat4_mult_float3(localDirToWorldCubemapDir, surface.normal);
        float3 irradiance = shEvalDirection(float4(n_sh_space, 1.), shCoefficients);
        
        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);
#ifdef USE_PBR_LAMBERTIAN_REFLECTION
        pbr.envDiffuse += surface.ambientOcclusion * irradiance * diffuseAlbedo;
#else
        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);
        pbr.envDiffuse += surface.ambientOcclusion * irradiance * diffuseReflectance;
#endif
    }
    void add_global_irradiance_probe(texturecube<float, access::sample> irradianceTexture,
                                     float4x4                           localDirToWorldCubemapDir,
                                     float                              environmentIntensity)
    {
#if USE_PBR_DOMINANT_DIRECTION
        float3 n = surface.normal;
        float3 v = surface.view;
        
        
        const half a = 1.02341h * surface.roughness - 1.51174h; 
        const half b = -0.511705h * surface.roughness + 0.755868h;
        const half diffuseBendFactor = saturate((pbr.NoV * a + b) * surface.roughness);
        float3 diffuseDominantNDirection = mix(n, v, diffuseBendFactor);
#else
        float3 diffuseDominantNDirection = n;
#endif
        
        float3 n_cube_space = scn::mat4_mult_float3(localDirToWorldCubemapDir, diffuseDominantNDirection);
        float3 irradiance = irradianceTexture.sample(scn::linearSampler, n_cube_space).rgb;
        
        float3 diffuseAlbedo = mix(pbr.albedo, float3(0.0), surface.metalness);
#ifdef USE_PBR_LAMBERTIAN_REFLECTION
        pbr.envDiffuse += (surface.ambientOcclusion * environmentIntensity) * irradiance * diffuseAlbedo;
#else
        float3 diffuseReflectance = diffuseAlbedo * (pbr.diffuseHammonFactors.x + diffuseAlbedo * pbr.diffuseHammonFactors.y);
        pbr.envDiffuse += (surface.ambientOcclusion * environmentIntensity) * irradiance * diffuseReflectance;
#endif
    }
#endif 
    
    static constexpr sampler iesSampler = sampler(filter::linear, mip_filter::none, address::clamp_to_edge);
    
    float ies_attenuation(float3 l, scn_light light, texture2d<half> iesTexture)
    {
#if USE_QUAT_FOR_IES
        float3 v    = scn::quaternion_rotate_vector(light.parameters.ies.light_from_view_quat, -l);
#else
        float3 v    = scn::matrix_rotate(light.parameters.ies.light_from_view, -l);
#endif
        float phi   = (v.z * light.parameters.ies.scaleBias.x + light.parameters.ies.scaleBias.y);
        float theta = atan2(v.y, v.x) * 0.5f * M_1_PI_F;
        return iesTexture.sample(iesSampler, float2(phi, abs(theta))).r;
    }
    void add_ies(scn_light light, texture2d<half> iesTexture)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity      *= ies_attenuation(l, light, iesTexture);
        shade(l, light.color.rgb, intensity);
    }
    void add_ies(scn_light light, texture2d<half> iesTexture, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount)
    {
        float3 unnormalized_l = light.pos - surface.position;
        float3 l = normalize(unnormalized_l);
        float intensity = dist_attenuation(unnormalized_l, light);
        intensity      *= ies_attenuation(l, light, iesTexture);
        intensity      *= shadow(surface.position, light, shadowMap, shadowKernel, sampleCount);
        shade(l, light.color.rgb, intensity);
    }
    
    void add_area_rectangle(scn_light light, texture2d_array<float> bakedDataTexture)
    {
#ifdef USE_PBR
        float3 v = surface.view;
        float3 n = surface.normal;
        float3 p = surface.position;
        
        float3 tangent = normalize(v - n * dot(v, n));
        float3 bitangent = cross(n, tangent);
        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));
        float3 lightCenter = light.shadowMatrix[3].xyz;
        
        
        float sidedness = dot(light.dir, lightCenter - p);
        if (light.parameters.area.rectangle.doubleSided == false && sidedness <= 0.f)
            return;
        
        float3 lightRight = light.shadowMatrix[0].xyz * light.parameters.area.rectangle.halfExtents.x * sign(sidedness);
        float3 lightTop   = light.shadowMatrix[1].xyz * light.parameters.area.rectangle.halfExtents.y;
        
        float4x3 cornerDirections = float4x3((lightCenter + lightRight + lightTop) - p,
                                             (lightCenter + lightRight - lightTop) - p,
                                             (lightCenter - lightRight - lightTop) - p,
                                             (lightCenter - lightRight + lightTop) - p);
        cornerDirections[0] = shadingSpaceTransform * cornerDirections[0];
        cornerDirections[1] = shadingSpaceTransform * cornerDirections[1];
        cornerDirections[2] = shadingSpaceTransform * cornerDirections[2];
        cornerDirections[3] = shadingSpaceTransform * cornerDirections[3];
        float diffuseAmount = pbr_area_light_eval_rectangle(cornerDirections);
        float brdfNorm = 1.f;
        float3x3 inverseLTCMatrix = scn_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);
        cornerDirections[0] = inverseLTCMatrix * cornerDirections[0];
        cornerDirections[1] = inverseLTCMatrix * cornerDirections[1];
        cornerDirections[2] = inverseLTCMatrix * cornerDirections[2];
        cornerDirections[3] = inverseLTCMatrix * cornerDirections[3];
        float specularAmount = brdfNorm * pbr_area_light_eval_rectangle(cornerDirections);
        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); 
        
        float3 lightColor = light.color.rgb;
        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;
        specular += specularAmount * lightColor * pbr.reflectance;
#endif
    }
    void add_area_polygon(scn_light light, texture2d_array<float> bakedDataTexture, device packed_float2 *vertexPositions)
    {
#ifdef USE_PBR
        float3 v = surface.view;
        float3 n = surface.normal;
        float3 p = surface.position;
        
        float3 tangent = normalize(v - n * dot(v, n));
        float3 bitangent = cross(n, tangent);
        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));
        float3 lightCenter = light.shadowMatrix[3].xyz;
        
        
        float sidedness = dot(light.dir, lightCenter - p);
        if (light.parameters.area.polygon.doubleSided == false && sidedness <= 0.f)
            return;
        
        float3 lightRight = light.shadowMatrix[0].xyz * sign(sidedness);
        float3 lightTop   = light.shadowMatrix[1].xyz;
        p           = shadingSpaceTransform * p;
        lightCenter = shadingSpaceTransform * lightCenter;
        lightRight  = shadingSpaceTransform * lightRight;
        lightTop    = shadingSpaceTransform * lightTop;
        float diffuseAmount = pbr_area_light_eval_polygon(p, lightCenter, lightRight, lightTop, light.parameters.area.polygon.vertexCount, vertexPositions);
        float brdfNorm = 1.f;
        float3x3 inverseLTCMatrix = scn_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);
        p           = inverseLTCMatrix * p;
        lightCenter = inverseLTCMatrix * lightCenter;
        lightRight  = inverseLTCMatrix * lightRight;
        lightTop    = inverseLTCMatrix * lightTop;
        float specularAmount = brdfNorm * pbr_area_light_eval_polygon(p, lightCenter, lightRight, lightTop, light.parameters.area.polygon.vertexCount, vertexPositions);
        
        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); 
        float3 lightColor = light.color.rgb;
        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;
        specular += specularAmount * lightColor * pbr.reflectance;
#endif
    }
    void add_area_line(scn_light light, texture2d_array<float> bakedDataTexture)
    {
#ifdef USE_PBR
        float3 v = surface.view;
        float3 n = surface.normal;
        float3 p = surface.position;
        
        float3 tangent = normalize(v - n * dot(v, n));
        float3 bitangent = cross(n, tangent);
        float3x3 shadingSpaceTransform = transpose(float3x3(tangent, n, bitangent));
        float3 lightCenter = light.shadowMatrix[3].xyz;
        float3 lightRight  = light.shadowMatrix[0].xyz * light.parameters.area.line.halfLength;
        float2x3 cornerDirections = float2x3((lightCenter + lightRight) - p,
                                             (lightCenter - lightRight) - p);
        cornerDirections[0] = shadingSpaceTransform * cornerDirections[0];
        cornerDirections[1] = shadingSpaceTransform * cornerDirections[1];
        float diffuseAmount = pbr_area_light_eval_line(cornerDirections);
        float brdfNorm = 1.f;
        float3x3 inverseLTCMatrix = scn_sample_area_light_precomputed_data(v, n, surface.roughness, &brdfNorm, bakedDataTexture);
        cornerDirections[0] = inverseLTCMatrix * cornerDirections[0];
        cornerDirections[1] = inverseLTCMatrix * cornerDirections[1];
        float specularAmount = brdfNorm * pbr_area_light_eval_line(cornerDirections);
        float3 ortho = normalize(cross(cornerDirections[0], cornerDirections[1]));
        float ltcWidthFactor = 1.0 / length(scn_ltc_matrix_invert_transpose(inverseLTCMatrix) * ortho);
        specularAmount *= ltcWidthFactor;
        
        float3 effectiveAlbedo = mix(float3(1.0), float3(0.0), surface.metalness); 
        float3 lightColor = light.color.rgb;
        diffuse  += diffuseAmount * lightColor * effectiveAlbedo;
        specular += specularAmount * lightColor * pbr.reflectance;
#endif
    }
    void add_area_ellipse(scn_light light, texture2d_array<float> bakedDataTexture)
    {
#ifdef USE_PBR
#endif
    }
    void add_area_ellipsoid(scn_light light, texture2d_array<float> bakedDataTexture)
    {
#ifdef USE_PBR
#endif
    }
#endif 
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
#import "C3D-PBR.metal"
#import "scn_tessellation.h"
#ifdef USE_LAYERED_RENDERING
#define texture2d_layer texture2d_array
#define sampleLayer(a,b) sample(a,b,in.sliceIndex)
#else
#define texture2d_layer texture2d
#define sampleLayer(a,b) sample(a,b)
#endif
#ifdef C3D_USE_TEXTURE_FOR_LIGHT_INDICES
#define LightIndex(lid) u_lightIndicesTexture.read((ushort)lid).x
#else
#define LightIndex(lid) u_lightIndicesBuffer[lid]
#endif
#ifdef IS_BEZIER_CURVE
[[visible]] bool scn_is_inside_bezier_curve(float2 p, device void const* curveData, device packed_float3 const* controlPoints);
#endif
typedef struct {
#ifdef USE_MODELTRANSFORM
    float4x4 modelTransform;
#endif
#ifdef USE_INVERSEMODELTRANSFORM
    float4x4 inverseModelTransform;
#endif
#ifdef USE_MODELVIEWTRANSFORM
    float4x4 modelViewTransform;
#endif
#ifdef USE_INVERSEMODELVIEWTRANSFORM
    float4x4 inverseModelViewTransform;
#endif
#ifdef USE_NORMALTRANSFORM
    float4x4 normalTransform;
#endif
#ifdef USE_MODELVIEWPROJECTIONTRANSFORM
    float4x4 modelViewProjectionTransform;
#endif
#ifdef USE_INVERSEMODELVIEWPROJECTIONTRANSFORM
    float4x4 inverseModelViewProjectionTransform;
#endif
#ifdef USE_MOTIONBLUR
    float4x4 lastFrameModelTransform;
    float motionBlurIntensity;
#endif
#ifdef USE_BOUNDINGBOX
    float2x3 boundingBox;
#endif
#ifdef USE_WORLDBOUNDINGBOX
    float2x3 worldBoundingBox;
#endif
#ifdef USE_NODE_OPACITY
    float nodeOpacity;
#endif
#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)
    sh2_coefficients shCoefficients;
#elif defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 3)
    sh3_coefficients shCoefficients;
#endif
} commonprofile_node;
typedef struct {
    float3 position         [[attribute(SCNVertexSemanticPosition)]];
#ifdef HAS_NORMAL
    float3 normal           [[attribute(SCNVertexSemanticNormal)]];
#endif
#ifdef USE_TANGENT
    float4 tangent          [[attribute(SCNVertexSemanticTangent)]];
#endif
#ifdef USE_VERTEX_COLOR
    float4 color            [[attribute(SCNVertexSemanticColor)]];
#endif
#if defined(NEED_IN_TEXCOORD0) || defined(DEBUG_PIXEL)
    float2 texcoord0        [[attribute(SCNVertexSemanticTexcoord0)]];
#endif
#ifdef NEED_IN_TEXCOORD1
    float2 texcoord1        [[attribute(SCNVertexSemanticTexcoord1)]];
#endif
#ifdef NEED_IN_TEXCOORD2
    float2 texcoord2        [[attribute(SCNVertexSemanticTexcoord2)]];
#endif
#ifdef NEED_IN_TEXCOORD3
    float2 texcoord3        [[attribute(SCNVertexSemanticTexcoord3)]];
#endif
#ifdef NEED_IN_TEXCOORD4
    float2 texcoord4        [[attribute(SCNVertexSemanticTexcoord4)]];
#endif
#ifdef NEED_IN_TEXCOORD5
    float2 texcoord5        [[attribute(SCNVertexSemanticTexcoord5)]];
#endif
#ifdef NEED_IN_TEXCOORD6
    float2 texcoord6        [[attribute(SCNVertexSemanticTexcoord6)]];
#endif
#ifdef NEED_IN_TEXCOORD7
    float2 texcoord7        [[attribute(SCNVertexSemanticTexcoord7)]];
#endif
} scn_vertex_t; 
typedef struct {
    float4 fragmentPosition [[position]]; 
#ifdef USE_POINT_RENDERING
    float fragmentSize [[point_size]];
#endif
#ifdef USE_VERTEX_COLOR
    float4 vertexColor;
#endif
#ifdef USE_PER_VERTEX_LIGHTING
    float3 diffuse;
#ifdef USE_SPECULAR
    float3 specular;
#endif
#ifdef USE_CLEARCOAT
    float clearCoat;
#endif
#ifdef USE_CLEARCOATROUGHNESS
    float clearCoatRoughness;
#endif
#ifdef USE_CLEARCOATNORMAL
    float clearCoatNormal;
#endif
#endif
#if defined(USE_POSITION) && (USE_POSITION == 2)
    float3 position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)
    float3 normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    float3 tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    float3 bitangent;
#endif
#ifdef USE_DISPLACEMENT_MAP
    float2 displacementTexcoord;   
#endif
#ifdef USE_CLEARCOAT_MAP
    float2 clearCoatTexcoord;   
#endif
#ifdef USE_CLEARCOATROUGHNESS_MAP
    float2 clearCoatRoughnessTexcoord;   
#endif
#ifdef USE_CLEARCOATNORMAL_MAP
    float2 clearCoatNormalTexcoord;   
#endif
#if defined(USE_PBR_TRANSPARENCY) && defined(USE_TRANSPARENCY)
    float transparency;
#endif
#ifdef USE_NODE_OPACITY
    float nodeOpacity;
#endif
#ifdef USE_TEXCOORD
    __TexcoordDecl__
#endif
    
#ifdef USE_EXTRA_VARYINGS
    __ExtraVaryingsDecl__
#endif
    
#ifdef USE_MOTIONBLUR
    float3 mv_fragment;
    float3 mv_lastFragment;
#endif
#ifdef USE_OUTLINE
    float outlineHash [[ flat ]];
#endif
#ifdef USE_INSTANCING
    uint   instanceID [[ flat ]];
#endif
#ifndef USE_VERTEX_AMPLIFICATION 
#ifdef USE_LAYERED_RENDERING
    uint   sliceIndex [[render_target_array_index]];
#endif
#ifdef USE_MULTIPLE_VIEWPORTS_RENDERING
    uint   sliceIndex [[viewport_array_index]];
#endif
#endif
#if DEBUG_PIXEL
    float2 uv0;
#endif
} commonprofile_io;
#ifdef USE_SHADER_MODIFIERS
__ShaderModifiersDecl__
#endif
#import "C3D-Lighting.metal"
enum C3DColorMask {
    kC3DColorMaskRed    = 0x1 << 3,
    kC3DColorMaskGreen  = 0x1 << 2,
    kC3DColorMaskBlue   = 0x1 << 1,
    kC3DColorMaskAlpha  = 0x1 << 0
inline float4 colorFromMask(float4 col, int mask)
    switch (mask) {
        case kC3DColorMaskRed:                      return col.r;
        case kC3DColorMaskRed|kC3DColorMaskGreen:   return float4(col.rg, 0.f, 1.f);
        case kC3DColorMaskRed|kC3DColorMaskBlue:    return float4(col.rb, 0.f, 1.f);
        case kC3DColorMaskRed|kC3DColorMaskAlpha:   return float4(col.ra, 0.f, 1.f);
        case kC3DColorMaskGreen:                    return col.g;
        case kC3DColorMaskGreen|kC3DColorMaskBlue:  return float4(col.bg, 0.f, 1.f);
        case kC3DColorMaskGreen|kC3DColorMaskAlpha: return float4(col.ag, 0.f, 1.f);
        case kC3DColorMaskBlue:     return col.b;
        case kC3DColorMaskBlue|kC3DColorMaskAlpha:  return float4(col.ab, 0.f, 1.f);
        case kC3DColorMaskAlpha:    return col.a;
    }
    return col;
#ifndef USE_PBR
inline float3 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)
    float3 albedo = surface.diffuse.rgb * surface.ambientOcclusion;
    float3 color = lighting.diffuse * albedo;
#if defined(USE_AMBIENT_LIGHTING) && (defined(LOCK_AMBIENT_WITH_DIFFUSE) || defined(USE_AMBIENT_AS_AMBIENTOCCLUSION))
    color +=  lighting.ambient * albedo;
#endif
#ifdef USE_SELFILLUMINATION
    color += surface.diffuse.rgb * surface.selfIllumination.rgb;
#endif
    
    
    
#ifdef USE_SPECULAR
    float3 S = lighting.specular;
#elif defined(USE_REFLECTIVE)
    float3 S = float3(0.);
#endif
#ifdef USE_REFLECTIVE
    S += surface.reflective.rgb * surface.ambientOcclusion;
#endif
#ifdef USE_SPECULAR
    S *= surface.specular.rgb;
#endif
#if (defined(USE_SPECULAR) || defined(USE_REFLECTIVE)) && !defined(DISABLE_SPECULAR)
    color += S;
#endif
#if defined(USE_AMBIENT) && !defined(USE_AMBIENT_AS_AMBIENTOCCLUSION)
    color += surface.ambient.rgb * lighting.ambient;
#endif
#ifdef USE_EMISSION
    color += surface.emission.rgb;
#endif
#ifdef USE_MULTIPLY
    color *= surface.multiply.rgb;
#endif
#ifdef USE_MODULATE
    color *= lighting.modulate;
#endif
    return color;
#endif
struct SCNShaderGeometry
    float4 position;
    float3 normal;
    float4 tangent;
    float4 color;
    float pointSize;
    float2 texcoords[8]; 
#ifdef USE_CLIP_DISTANCE0
    float clipDistance0;
#endif
#ifdef USE_CLIP_DISTANCE1
    float clipDistance1;
#endif
#ifdef USE_CLIP_DISTANCE2
    float clipDistance2;
#endif
#ifdef USE_CLIP_DISTANCE3
    float clipDistance3;
#endif
struct commonprofile_uniforms {
    
    float4 diffuseColor;
    float4 specularColor;
    float4 ambientColor;
    float4 emissionColor;
    float4 selfIlluminationColor;
    float4 reflectiveColor;
    float4 multiplyColor;
    float4 transparentColor;
    float clearCoat;
    float clearCoatRoughness;
    float3 clearCoatNormal;
    float metalness;
    
    float roughness;
    float diffuseIntensity;
    float specularIntensity;
    float normalIntensity;
    float ambientIntensity;
    float emissionIntensity;
    float selfIlluminationIntensity;
    float reflectiveIntensity;
    float multiplyIntensity;
    float transparentIntensity;
    
    float metalnessIntensity;
    float roughnessIntensity;
    float clearCoatIntensity;
    float clearCoatRoughnessIntensity;
    float clearCoatNormalIntensity;
    float displacementIntensity;
    float materialShininess;
    float selfIlluminationOcclusion;
    float transparency;
    float3 fresnel; 
#if USE_ARGUMENT_BUFFERS
    
    texture2d<float>    emissionTexture;
    sampler             emissionSampler;
    texture2d<float>    ambientTexture;
    sampler             ambientSampler;
    
    texture2d<float>    diffuseTexture;
    sampler             diffuseSampler;
    texture2d<float>    specularTexture;
    sampler             specularSampler;
#if defined(USE_REFLECTIVE_CUBEMAP)
    texturecube<float>  reflectiveTexture;
#else
    texture2d<float>    reflectiveTexture;
#endif
    sampler             reflectiveSampler;
    texture2d<float>    transparentTexture;
    sampler             transparentSampler;
    texture2d<float>    multiplyTexture;
    sampler             multiplySampler;
    
    texture2d<float>    normalTexture;
    sampler             normalSampler;
    texture2d<float>    selfIlluminationTexture;
    sampler             selfIlluminationSampler;
    texture2d<float>    metalnessTexture;
    sampler             metalnessSampler;
    texture2d<float>    roughnessTexture;
    sampler             roughnessSampler;
    texture2d<float>    displacementTexture;
    sampler             displacementSampler;
    
    
#endif 
#ifdef TEXTURE_TRANSFORM_COUNT
    float4x4 textureTransforms[TEXTURE_TRANSFORM_COUNT];
#endif
#ifdef USE_OPENSUBDIV
__OpenSubdivDeclPerGeometry__
__OpenSubdivDeclPerPatchType__
__OpenSubdivDeclShared__
struct osd_packed_vertex {
    packed_float3 position;
#if defined(OSD_USER_VARYING_DECLARE_PACKED)
    OSD_USER_VARYING_DECLARE_PACKED
#endif
#endif
#ifdef USE_DISPLACEMENT_MAP
static void applyDisplacement(texture2d<float>                 displacementTexture,
                              sampler                          displacementTextureSampler,
                              float2                           displacementTexcoord,
                              thread SCNShaderGeometry&        geometry,
                              constant commonprofile_uniforms& scn_commonprofile)
#ifdef USE_DISPLACEMENT_TEXTURE_COMPONENT
float altitude = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;
#ifdef USE_DISPLACEMENT_INTENSITY
altitude *= scn_commonprofile.displacementIntensity;
#endif
#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)
float3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));
geometry.position.xyz += geometry.normal * altitude;
float3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);
float3 h;
h.x = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;
h.y = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;
h.z = colorFromMask(displacementTexture.sample(displacementTextureSampler, displacementTexcoord-offset.zy), USE_DISPLACEMENT_TEXTURE_COMPONENT).r;
#ifdef USE_DISPLACEMENT_INTENSITY
h *= scn_commonprofile.displacementIntensity;
#endif
float3 n = normalize( float3( (h.x - h.y)/offset.x, 1., (h.x - h.z)/offset.y) );
geometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;
geometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));
#endif 
#else 
float3 displacement = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;
#ifdef USE_DISPLACEMENT_INTENSITY
displacement *= scn_commonprofile.displacementIntensity;
#endif
#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)
float3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));
geometry.position.xyz += geometry.tangent.xyz * displacement.x + geometry.normal.xyz * displacement.y + bitangent.xyz * displacement.z;
float3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);
float3 a = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;
float3 b = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz).rgb;
float3 c = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.zy).rgb;
#ifdef USE_DISPLACEMENT_INTENSITY
a *= scn_commonprofile.displacementIntensity;
b *= scn_commonprofile.displacementIntensity;
c *= scn_commonprofile.displacementIntensity;
#endif
b += offset.xzz;
c -= offset.zzy;
float3 n = (normalize( cross( b-a, c-a ) ));
geometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;
geometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));
#endif 
#endif 
#endif 
#ifdef USE_OUTLINE
static inline float hash(float2 p)
    const float2 kMod2 = float2(443.8975f, 397.2973f);
    p  = fract(p * kMod2);
    p += dot(p.xy, p.yx+19.19f);
    return fract(p.x * p.y);
#endif
    
#if defined(USE_TESSELLATION)
struct scn_patch_t {
    patch_control_point<scn_vertex_t> controlPoints;
#endif
#if defined(USE_OPENSUBDIV)
#if OSD_IS_ADAPTIVE
[[ patch(quad, VERTEX_CONTROL_POINTS_PER_PATCH) ]]
#endif
#elif defined(USE_TESSELLATION)
[[ patch(triangle, 3) ]]
#endif
    
    
vertex commonprofile_io commonprofile_vert(
#if !defined(USE_TESSELLATION)
                                           scn_vertex_t                       in                               [[ stage_in ]]
                                           , uint                             scn_vertexID                     [[ vertex_id ]]
#else 
                                           
#ifdef USE_OPENSUBDIV
#if OSD_IS_ADAPTIVE
#if USE_STAGE_IN
                                           PatchInput                         patchInput                       [[ stage_in ]]
#else
                                           OsdVertexBufferSet                 patchInput
#endif
                                           , float2                           patchCoord                       [[ position_in_patch ]]
                                           , uint                             patchID                          [[ patch_id ]]
                                           , constant float&                  osdTessellationLevel             [[ buffer(TESSELLATION_LEVEL_BUFFER_INDEX) ]]
#else 
                                           constant unsigned*                 osdIndicesBuffer                 [[ buffer(INDICES_BUFFER_INDEX) ]]
                                           , constant osd_packed_vertex*      osdVertexBuffer                  [[ buffer(VERTEX_BUFFER_INDEX) ]]
                                           , uint                             vertexID                         [[ vertex_id ]]
#endif 
#if defined(OSD_FVAR_WIDTH)
#if OSD_FVAR_USES_MULTIPLE_CHANNELS
                                           , constant uint32_t&               osdFaceVaryingChannelCount       [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_COUNT_INDEX) ]]
                                           , constant OsdFVarChannelDesc*     osdFaceVaryingChannelDescriptors [[ buffer(OSD_FVAR_CHANNELS_CHANNEL_DESCRIPTORS_INDEX) ]]
                                           , constant uint32_t&               osdFaceVaryingPatchArrayIndex    [[ buffer(OSD_FVAR_CHANNELS_PATCH_ARRAY_INDEX_BUFFER_INDEX) ]]
                                           , constant void*                   osdFaceVaryingChannelsPackedData [[ buffer(OSD_FVAR_CHANNELS_PACKED_DATA_BUFFER_INDEX) ]]
#else
                                           , constant float*                  osdFaceVaryingData               [[ buffer(OSD_FVAR_DATA_BUFFER_INDEX) ]]
                                           , constant int*                    osdFaceVaryingIndices            [[ buffer(OSD_FVAR_INDICES_BUFFER_INDEX) ]]
#if OSD_IS_ADAPTIVE
                                           , constant packed_int3*            osdFaceVaryingPatchParams        [[ buffer(OSD_FVAR_PATCHPARAM_BUFFER_INDEX) ]]
                                           , constant packed_int4&            osdFaceVaryingPatchArray         [[ buffer(OSD_FVAR_PATCH_ARRAY_BUFFER_INDEX) ]]
#endif
#endif 
#endif 
#else 
                                           scn_patch_t                        in                               [[ stage_in ]]
                                           , float3                           patchCoord                       [[ position_in_patch ]]
#endif 
#endif 
                                           
#ifdef USE_MULTIPLE_RENDERING
                                           , constant SCNSceneBuffer*         scn_frame_multi                  [[ buffer(0) ]]
#else
                                           , constant SCNSceneBuffer&         scn_frame                        [[ buffer(0) ]]
#endif
#if defined(USE_INSTANCING) || defined(USE_MULTIPLE_RENDERING)
                                           , constant commonprofile_node*     scn_nodes                        [[ buffer(1) ]]
#else
                                           , constant commonprofile_node&     scn_node                         [[ buffer(1) ]]
#endif
#ifdef USE_PER_VERTEX_LIGHTING
                                           , constant scn_light*              scn_lights                       [[ buffer(2) ]]
                                           , constant float4*                 u_shadowKernel
                                           , texture2d_array<float>           u_areaLightBakedDataTexture
#endif
                                           
                                           , constant commonprofile_uniforms& scn_commonprofile
#ifdef USE_INSTANCING
                                           , uint                             scn_instanceID                   [[ instance_id ]]
#endif
#ifdef USE_VERTEX_AMPLIFICATION
                                           , ushort                           amplificationID                  [[ amplification_id ]]
#endif
#ifdef USE_POINT_RENDERING
                                           
                                           , constant float3&                 scn_pointSize
#endif
#ifdef USE_DISPLACEMENT_MAP
#if USE_ARGUMENT_BUFFERS
#define u_displacementTexture           scn_commonprofile.displacementTexture
#define u_displacementTextureSampler    scn_commonprofile.displacementSampler
#else
                                           , texture2d<float>                 u_displacementTexture
                                           , sampler                          u_displacementTextureSampler
#endif 
#endif 
#ifdef USE_VERTEX_EXTRA_ARGUMENTS
                                           __VertexExtraArguments__
#endif
                                           )
    commonprofile_io out;
    
#ifdef USE_MULTIPLE_RENDERING
#ifdef USE_VERTEX_AMPLIFICATION
    constant SCNSceneBuffer& scn_frame = scn_frame_multi[amplificationID];
#else
    out.instanceID = scn_instanceID / USE_MULTIPLE_RENDERING;
    out.sliceIndex = scn_instanceID % USE_MULTIPLE_RENDERING;
    constant SCNSceneBuffer& scn_frame = scn_frame_multi[out.sliceIndex];
#endif
    
#ifdef USE_INSTANCING
#ifdef USE_VERTEX_AMPLIFICATION
    constant commonprofile_node& scn_node = scn_nodes[USE_MULTIPLE_RENDERING * scn_instanceID + amplificationID];
#else
    
    
    constant commonprofile_node& scn_node = scn_nodes[scn_instanceID];
#endif
#else
#ifdef USE_VERTEX_AMPLIFICATION
    constant commonprofile_node& scn_node = scn_nodes[amplificationID];
#else
    constant commonprofile_node& scn_node = scn_nodes[out.sliceIndex];
#endif
#endif
    
#else 
    
#ifdef USE_INSTANCING
    out.instanceID = scn_instanceID;
    constant commonprofile_node& scn_node = scn_nodes[scn_instanceID];
#endif
    
#endif 
    
    
#ifdef USE_TESSELLATION
    uint scn_vertexID; 
    scn_vertexID = 0;
#endif
    
    
    
    
    
    SCNShaderGeometry _geometry;
    
#if !defined(USE_TESSELLATION)
    
    
    _geometry.position = float4(in.position, 1.f);
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
    _geometry.normal = in.normal;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _geometry.tangent = in.tangent;
#endif
#ifdef NEED_IN_TEXCOORD0
    _geometry.texcoords[0] = in.texcoord0;
#endif
#ifdef NEED_IN_TEXCOORD1
    _geometry.texcoords[1] = in.texcoord1;
#endif
#ifdef NEED_IN_TEXCOORD2
    _geometry.texcoords[2] = in.texcoord2;
#endif
#ifdef NEED_IN_TEXCOORD3
    _geometry.texcoords[3] = in.texcoord3;
#endif
#ifdef NEED_IN_TEXCOORD4
    _geometry.texcoords[4] = in.texcoord4;
#endif
#ifdef NEED_IN_TEXCOORD5
    _geometry.texcoords[5] = in.texcoord5;
#endif
#ifdef NEED_IN_TEXCOORD6
    _geometry.texcoords[6] = in.texcoord6;
#endif
#ifdef NEED_IN_TEXCOORD7
    _geometry.texcoords[7] = in.texcoord7;
#endif
#ifdef HAS_VERTEX_COLOR
    _geometry.color = in.color;
#elif USE_VERTEX_COLOR
    _geometry.color = float4(1.);
#endif
    
#else 
    
#ifdef USE_OPENSUBDIV
#if OSD_IS_ADAPTIVE
#if USE_STAGE_IN
    int3 patchParam = patchInput.patchParam;
#else
    int3 patchParam = patchInput.patchParamBuffer[patchID];
#endif
    
    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);
    float tessellationLevel = min(osdTessellationLevel, (float)OSD_MAX_TESS_LEVEL) / exp2((float)refinementLevel - 1);
    
    OsdPatchVertex patchVertex = OsdComputePatch(tessellationLevel, patchCoord, patchID, patchInput);
    
#if defined(OSD_FVAR_WIDTH)
    int patchIndex = OsdGetPatchIndex(patchID);
#if OSD_FVAR_USES_MULTIPLE_CHANNELS
    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);
#else
    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingIndices, osdFaceVaryingData, osdFaceVaryingPatchParams, osdFaceVaryingPatchArray);
#endif
#endif
    
    _geometry.position = float4(patchVertex.position, 1.f);
    
#if defined(USE_NORMAL)
    _geometry.normal = patchVertex.normal;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _geometry.tangent = float4(patchVertex.tangent, -1.f);
    
#endif
#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[0] = patchVertex.texcoord0;
#endif
#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[1] = patchVertex.texcoord1;
#endif
#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[2] = patchVertex.texcoord2;
#endif
#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[3] = patchVertex.texcoord3;
#endif
#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[4] = patchVertex.texcoord4;
#endif
#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[5] = patchVertex.texcoord5;
#endif
#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[6] = patchVertex.texcoord6;
#endif
#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[7] = patchVertex.texcoord7;
#endif
#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.color = patchVertex.color;
#endif
    
#else 
    
#if OSD_PATCH_QUADS
    const uint primitiveIndex = vertexID / 6;
#ifdef USE_NORMAL
    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 0]].position;
    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 1]].position;
    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 2]].position;
    float3 normal = normalize(cross(p2 - p1, p0 - p1));
#endif
    const uint triangleIndices[6] = { 0, 1, 2, 0, 2, 3 };
    const uint quadVertexIndex = triangleIndices[vertexID % 6];
    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + quadVertexIndex]];
#elif OSD_PATCH_TRIANGLES
    const uint primitiveIndex = vertexID / 3;
#ifdef USE_NORMAL
    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 0]].position;
    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 1]].position;
    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 2]].position;
    float3 normal = normalize(cross(p2 - p1, p0 - p1));
#endif
    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[vertexID]];
#endif
    
    float3 position = osdVertex.position;
    
#if defined(OSD_FVAR_WIDTH)
    int patchIndex = OsdGetPatchIndex(primitiveIndex);
#if OSD_PATCH_QUADS
    float2 quadUVs[4] = { float2(0,0), float2(1,0), float2(1,1), float2(0,1) };
#if OSD_FVAR_USES_MULTIPLE_CHANNELS
    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingChannelCount, osdFaceVaryingChannelDescriptors, osdFaceVaryingPatchArrayIndex, osdFaceVaryingChannelsPackedData);
#else
    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingIndices, osdFaceVaryingData);
#endif
#elif OSD_PATCH_TRIANGLES
    
#endif
#endif 
    
#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[0] = osdVertex.texcoord0;
#endif
#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[1] = osdVertex.texcoord1;
#endif
#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[2] = osdVertex.texcoord2;
#endif
#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[3] = osdVertex.texcoord3;
#endif
#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[4] = osdVertex.texcoord4;
#endif
#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[5] = osdVertex.texcoord5;
#endif
#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[6] = osdVertex.texcoord6;
#endif
#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[7] = osdVertex.texcoord7;
#endif
#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.color = osdVertex.color;
#endif
    
    _geometry.position = float4(position, 1.f);
#ifdef USE_NORMAL
    _geometry.normal = normal;
#endif
    
#endif 
    
#else 
    
    
    
    
    
#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE) || defined(TESSELLATION_SMOOTHING_MODE_PHONG)
    float3 P0 = in.controlPoints[0].position;
    float3 P1 = in.controlPoints[1].position;
    float3 P2 = in.controlPoints[2].position;
    float3 N0 = in.controlPoints[0].normal;
    float3 N1 = in.controlPoints[1].normal;
    float3 N2 = in.controlPoints[2].normal;
#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE)
    float3 position, normal;
    scn_smooth_geometry_pn_triangle(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);
#elif defined(TESSELLATION_SMOOTHING_MODE_PHONG)
    float3 position, normal;
    scn_smooth_geometry_phong(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);
#endif
    _geometry.position = float4(position, 1.f);
#ifdef USE_NORMAL
    _geometry.normal = normal;
#endif
#else 
    
    _geometry.position = float4(scn::barycentric_mix(in.controlPoints[0].position, in.controlPoints[1].position, in.controlPoints[2].position, patchCoord), 1.f);
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
    _geometry.normal = normalize(scn::barycentric_mix(in.controlPoints[0].normal, in.controlPoints[1].normal, in.controlPoints[2].normal, patchCoord));
#endif
#endif 
    
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _geometry.tangent = normalize(scn::barycentric_mix(in.controlPoints[0].tangent, in.controlPoints[1].tangent, in.controlPoints[2].tangent, patchCoord));
#endif
#ifdef NEED_IN_TEXCOORD0
    _geometry.texcoords[0] = scn::barycentric_mix(in.controlPoints[0].texcoord0, in.controlPoints[1].texcoord0, in.controlPoints[2].texcoord0, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD1
    _geometry.texcoords[1] = scn::barycentric_mix(in.controlPoints[0].texcoord1, in.controlPoints[1].texcoord1, in.controlPoints[2].texcoord1, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD2
    _geometry.texcoords[2] = scn::barycentric_mix(in.controlPoints[0].texcoord2, in.controlPoints[1].texcoord2, in.controlPoints[2].texcoord2, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD3
    _geometry.texcoords[3] = scn::barycentric_mix(in.controlPoints[0].texcoord3, in.controlPoints[1].texcoord3, in.controlPoints[2].texcoord3, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD4
    _geometry.texcoords[4] = scn::barycentric_mix(in.controlPoints[0].texcoord4, in.controlPoints[1].texcoord4, in.controlPoints[2].texcoord4, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD5
    _geometry.texcoords[5] = scn::barycentric_mix(in.controlPoints[0].texcoord5, in.controlPoints[1].texcoord5, in.controlPoints[2].texcoord5, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD6
    _geometry.texcoords[6] = scn::barycentric_mix(in.controlPoints[0].texcoord6, in.controlPoints[1].texcoord6, in.controlPoints[2].texcoord6, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD7
    _geometry.texcoords[7] = scn::barycentric_mix(in.controlPoints[0].texcoord7, in.controlPoints[1].texcoord7, in.controlPoints[2].texcoord7, patchCoord);
#endif
#ifdef HAS_VERTEX_COLOR
    _geometry.color = scn::barycentric_mix(in.controlPoints[0].color, in.controlPoints[1].color, in.controlPoints[2].color, patchCoord);
#elif USE_VERTEX_COLOR
    _geometry.color = float4(1.);
#endif
    
#endif 
    
#endif 
    
#ifdef USE_POINT_RENDERING
    _geometry.pointSize = scn_pointSize.x;
#endif
    
#ifdef USE_TEXCOORD
    __VertexDoVertexOnlyTexcoord__
#endif
    
#ifdef USE_DISPLACEMENT_MAP
    applyDisplacement(u_displacementTexture, u_displacementTextureSampler, _displacementTexcoord, _geometry, scn_commonprofile);
    out.displacementTexcoord = _displacementTexcoord;
#endif
    
    
    
    
    
#ifdef USE_GEOMETRY_MODIFIER
    
    __DoGeometryModifier__
    
#endif
    
#ifdef USE_CLIP_DISTANCE0
    out.clipDistance[0] = _geometry.clipDistance0;
#endif
#ifdef USE_CLIP_DISTANCE1
    out.clipDistance[1] = _geometry.clipDistance1;
#endif
#ifdef USE_CLIP_DISTANCE2
    out.clipDistance[2] = _geometry.clipDistance2;
#endif
#ifdef USE_CLIP_DISTANCE3
    out.clipDistance[3] = _geometry.clipDistance3;
#endif
    
    
    
    
    
    
#if defined(USE_POSITION) || (defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)) || defined(USE_TANGENT) || defined(USE_BITANGENT) || defined(USE_INSTANCING)
    SCNShaderSurface _surface;
#endif
#if defined(USE_POSITION) || defined(USE_INSTANCING)
    _surface.position = (scn_node.modelViewTransform * _geometry.position).xyz;
#endif
#if defined(USE_NORMAL) && defined(HAS_OR_GENERATES_NORMAL)
#ifdef HINT_UNIFORM_SCALE
    float3x3 nrmTransform = scn::mat3(scn_node.modelViewTransform);
    _surface.normal = nrmTransform * _geometry.normal;
#else
    float3x3 modelViewTransform = scn::mat3(scn_node.modelViewTransform);
    float3 invScaleSquared = 1.f / float3(length_squared(modelViewTransform[0]),
                                          length_squared(modelViewTransform[1]),
                                          length_squared(modelViewTransform[2]));
    _surface.normal = normalize(modelViewTransform * (_geometry.normal * invScaleSquared));
#endif
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _surface.tangent = normalize(scn::mat3(scn_node.modelViewTransform) * _geometry.tangent.xyz);
    _surface.bitangent = _geometry.tangent.w * cross(_surface.tangent, _surface.normal); 
    
#endif
    
    
#ifdef USE_VIEW
    _surface.view = normalize(-_surface.position);
#endif
    
    
    
    
    
#ifdef USE_PER_VERTEX_LIGHTING
    
    SCNShaderLightingContribution _lightingContribution(_surface, out);
    _lightingContribution.diffuse = 0.;
  #ifdef USE_SPECULAR
    _lightingContribution.specular = 0.;
    _surface.shininess = scn_commonprofile.materialShininess;
  #endif
    
    __VertexDoLighting__
    
    out.diffuse = _lightingContribution.diffuse;
  #ifdef USE_SPECULAR
    out.specular = _lightingContribution.specular;
  #endif
#endif
#if defined(USE_POSITION) && (USE_POSITION == 2)
    out.position = _surface.position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_OR_GENERATES_NORMAL)
    out.normal = _surface.normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    out.tangent = _surface.tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    out.bitangent = _surface.bitangent;
#endif
#ifdef USE_VERTEX_COLOR
    out.vertexColor = _geometry.color;
#endif
    
#if DEBUG_PIXEL
    out.uv0 = in.texcoord0;
#endif
#ifdef USE_TEXCOORD
    __VertexDoTexcoord__
#endif
    
#ifdef IS_BEZIER_CURVE
    out.bezierCurveUV = in.texcoord0;
#endif
    
    
    
    
    
#if defined(USE_POSITION) || defined(USE_INSTANCING)
    out.fragmentPosition = scn_frame.projectionTransform * float4(_surface.position, 1.);
#elif defined(USE_MODELVIEWPROJECTIONTRANSFORM) 
    out.fragmentPosition = scn_node.modelViewProjectionTransform * _geometry.position;
#endif
    
#if defined(USE_PBR_TRANSPARENCY) && defined(USE_TRANSPARENCY)
    out.transparency = scn_commonprofile.transparency;
#endif
#ifdef USE_NODE_OPACITY
    out.nodeOpacity = scn_node.nodeOpacity;
#endif
    
#ifdef USE_POINT_RENDERING
    float screenSize = _geometry.pointSize / out.fragmentPosition.w;
    out.fragmentSize = clamp(screenSize, scn_pointSize.y, scn_pointSize.z);
#endif
    
#ifdef USE_MOTIONBLUR
    float4 lastFrameFragmentPosition = scn_frame.lastFrameViewProjectionTransform * scn_node.lastFrameModelTransform * _geometry.position;
    out.mv_fragment = out.fragmentPosition.xyw;
    out.mv_lastFragment = lastFrameFragmentPosition.xyw;
#endif
    
#ifdef USE_OUTLINE
out.outlineHash = hash(scn_node.modelTransform[3].xy)+1.f/255.f;
#endif
    
    return out;
struct SCNOutput
    float4 color [[ color(0) ]];
#ifdef USE_COLOR1_OUTPUT
    half4 color1 [[ color(1) ]];
#endif
#ifdef USE_NORMALS_OUTPUT
    half4 normals [[ color(2) ]];
#endif
#ifdef USE_MOTIONBLUR
    half4 motionblur [[ color(3) ]];
#endif
#ifdef USE_REFLECTANCE_ROUGHNESS_OUTPUT
    half4 reflectanceRoughnessOutput [[ color(4) ]];
#endif
#ifdef USE_RADIANCE_OUTPUT
    half4 radiance [[ color(5) ]];
#endif
    
#ifdef USE_MODIFIER_FRAMEBUFFER
struct SCNFramebuffer
    float4 color;
#endif
fragment SCNOutput commonprofile_frag(commonprofile_io                   in                          [[ stage_in  ]]
                                      , constant commonprofile_uniforms& scn_commonprofile           [[ buffer(0) ]]
#ifdef USE_MULTIPLE_RENDERING
                                      , constant SCNSceneBuffer*         scn_frame_multi             [[ buffer(1) ]]
#else
                                      , constant SCNSceneBuffer&         scn_frame                   [[ buffer(1) ]]
#endif
#if defined(USE_INSTANCING) || defined(USE_MULTIPLE_RENDERING)
                                      , constant commonprofile_node*     scn_nodes                   [[ buffer(2) ]]
#else
                                      , constant commonprofile_node&     scn_node                    [[ buffer(2) ]]
#endif
#ifdef USE_PER_PIXEL_LIGHTING
                                      , constant scn_light*              scn_lights                  [[ buffer(3) ]]
                                      , constant float4*                 u_shadowKernel
                                      , texture2d_array<float>           u_areaLightBakedDataTexture
#ifdef C3D_SUPPORT_CUBE_ARRAY
                                      , texturecube_array<half>          u_reflectionProbeTexture
#else
                                      , texture2d_array<half>            u_reflectionProbeTexture
#endif
                                      , texture3d<ushort>                u_clusterTexture
#ifdef C3D_USE_TEXTURE_FOR_LIGHT_INDICES
                                      , texture1d<ushort>                u_lightIndicesTexture
#else
                                      , constant C3DLightIndexType*      u_lightIndicesBuffer
#endif
#endif
#if defined(C3D_SUPPORTS_PROGRAMMABLE_BLENDING) && defined(USE_MODIFIER_FRAMEBUFFER_COLOR0)
                                      , float4                           framebufferColor0           [[ color(0) ]]
#endif
#if USE_ARGUMENT_BUFFERS
#define u_emissionTexture               scn_commonprofile.emissionTexture
#define u_emissionTextureSampler        scn_commonprofile.emissionSampler
#define u_ambientTexture                scn_commonprofile.ambientTexture
#define u_ambientTextureSampler         scn_commonprofile.ambientSampler
#define u_diffuseTexture                scn_commonprofile.diffuseTexture
#define u_diffuseTextureSampler         scn_commonprofile.diffuseSampler
#define u_specularTexture               scn_commonprofile.specularTexture
#define u_specularTextureSampler        scn_commonprofile.specularSampler
#define u_reflectiveTexture             scn_commonprofile.reflectiveTexture
#define u_reflectiveTextureSampler      scn_commonprofile.reflectiveSampler
#define u_transparentTexture            scn_commonprofile.transparentTexture
#define u_transparentTextureSampler     scn_commonprofile.transparentSampler
#define u_multiplyTexture               scn_commonprofile.multiplyTexture
#define u_multiplyTextureSampler        scn_commonprofile.multiplySampler
#define u_normalTexture                 scn_commonprofile.normalTexture
#define u_normalTextureSampler          scn_commonprofile.normalSampler
#define u_selfIlluminationTexture       scn_commonprofile.selfIlluminationTexture
#define u_selfIlluminationTextureSampler scn_commonprofile.selfIlluminationSampler
#define u_metalnessTexture              scn_commonprofile.metalnessTexture
#define u_metalnessTextureSampler       scn_commonprofile.metalnessSampler
#define u_roughnessTexture              scn_commonprofile.roughnessTexture
#define u_roughnessTextureSampler       scn_commonprofile.roughnessSampler
#else
#ifdef USE_EMISSION_MAP
                                      , texture2d<float>              u_emissionTexture
                                      , sampler                       u_emissionTextureSampler
#endif
#ifdef USE_AMBIENT_MAP
                                      , texture2d<float>              u_ambientTexture
                                      , sampler                       u_ambientTextureSampler
#endif
#ifdef USE_DIFFUSE_MAP
                                      , texture2d<float>              u_diffuseTexture
                                      , sampler                       u_diffuseTextureSampler
#endif
#ifdef USE_SPECULAR_MAP
                                      , texture2d<float>              u_specularTexture
                                      , sampler                       u_specularTextureSampler
#endif
#ifdef USE_REFLECTIVE_MAP
                                      , texture2d<float>              u_reflectiveTexture
                                      , sampler                       u_reflectiveTextureSampler
#elif defined(USE_REFLECTIVE_CUBEMAP)
                                      , texturecube<float>            u_reflectiveTexture
                                      , sampler                       u_reflectiveTextureSampler
#endif
#ifdef USE_TRANSPARENT_MAP
                                      , texture2d<float>              u_transparentTexture
                                      , sampler                       u_transparentTextureSampler
#endif
#ifdef USE_MULTIPLY_MAP
                                      , texture2d<float>              u_multiplyTexture
                                      , sampler                       u_multiplyTextureSampler
#endif
#ifdef USE_NORMAL_MAP
                                      , texture2d<float>              u_normalTexture
                                      , sampler                       u_normalTextureSampler
#endif
#ifdef USE_SELFILLUMINATION_MAP
                                      , texture2d<float>              u_selfIlluminationTexture
                                      , sampler                       u_selfIlluminationTextureSampler
#endif
#ifdef USE_DISPLACEMENT_MAP
                                      , texture2d<float>              u_displacementTexture
                                      , sampler                       u_displacementTextureSampler
#endif
#ifdef USE_PBR
#ifdef USE_METALNESS_MAP
                                      , texture2d<float>              u_metalnessTexture
                                      , sampler                       u_metalnessTextureSampler
#endif
#ifdef USE_ROUGHNESS_MAP
                                      , texture2d<float>              u_roughnessTexture
                                      , sampler                       u_roughnessTextureSampler
#endif
#ifdef USE_CLEARCOAT_MAP
                                      , texture2d<float>              u_clearCoatTexture
                                      , sampler                       u_clearCoatTextureSampler
#endif
#ifdef USE_CLEARCOATROUGHNESS_MAP
                                      , texture2d<float>              u_clearCoatRoughnessTexture
                                      , sampler                       u_clearCoatRoughnessTextureSampler
#endif
#ifdef USE_CLEARCOATNORMAL_MAP
                                      , texture2d<float>              u_clearCoatNormalTexture
                                      , sampler                       u_clearCoatNormalTextureSampler
#endif
#endif 
#endif 
#ifdef USE_PBR
                                      , texturecube<float>            u_radianceTexture
                                      , texture2d<float>              u_specularDFGDiffuseHammonTexture
#if !defined(USE_SELFILLUMINATION_MAP)
                                      , texturecube<float>            u_irradianceTexture
#endif
#endif 
#ifdef USE_SSAO
                                      , texture2d<float>              u_ssaoTexture
#endif
#ifdef USE_FRAGMENT_EXTRA_ARGUMENTS
                                      __FragmentExtraArguments__
#endif
#if defined(USE_DOUBLE_SIDED)
                                      , bool                          isFrontFacing                    [[front_facing]]
#endif
#ifdef USE_POINT_RENDERING
                                      , float2                        pointCoord                       [[point_coord]]
#endif
#ifdef USE_VERTEX_AMPLIFICATION
                                      , ushort                        amplificationID                  [[amplification_id]]
#endif
                                      )
#ifdef USE_MULTIPLE_RENDERING
    
#ifdef USE_VERTEX_AMPLIFICATION
    constant SCNSceneBuffer& scn_frame = scn_frame_multi[amplificationID];
#else
    constant SCNSceneBuffer& scn_frame = scn_frame_multi[in.sliceIndex];
#endif
    
#ifdef USE_INSTANCING
#ifdef USE_VERTEX_AMPLIFICATION
    constant commonprofile_node& scn_node = scn_nodes[USE_MULTIPLE_RENDERING * in.instanceID + amplificationID];
#else
    constant commonprofile_node& scn_node = scn_nodes[USE_MULTIPLE_RENDERING * in.instanceID + in.sliceIndex];
#endif
#else
#ifdef USE_VERTEX_AMPLIFICATION
    constant commonprofile_node& scn_node = scn_nodes[amplificationID];
#else
    constant commonprofile_node& scn_node = scn_nodes[in.sliceIndex];
#endif
#endif
    
#else 
    
#ifdef USE_INSTANCING
    constant commonprofile_node& scn_node = scn_nodes[in.instanceID];
#endif
    
#endif 
    
#ifdef IS_BEZIER_CURVE
    bool insideCurve = scn_is_inside_bezier_curve(in.bezierCurveUV, scn_bezier_curve_data, scn_bezier_curve_controlPoints);
    if (insideCurve == false) {
        discard_fragment();
    }
#endif
    
    SCNOutput _output;
    
    
    
    
    SCNShaderSurface _surface;
#ifdef USE_TEXCOORD
    __FragmentDoTexcoord__
#endif
    _surface.ambientOcclusion = 1.f; 
#ifdef USE_AMBIENT_MAP
    #ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
        #if defined(USE_AMBIENT_TEXTURE_COMPONENT)
            _surface.ambientOcclusion = colorFromMask(u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord), USE_AMBIENT_TEXTURE_COMPONENT).r;
        #else
            _surface.ambientOcclusion = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord).r;
        #endif
        #ifdef USE_AMBIENT_INTENSITY
            _surface.ambientOcclusion = saturate(mix(1.f, _surface.ambientOcclusion, scn_commonprofile.ambientIntensity));
        #endif
    #else 
        _surface.ambient = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord);
        #if defined(USE_AMBIENT_TEXTURE_COMPONENT)
            _surface.ambient = colorFromMask(_surface.ambient, USE_AMBIENT_TEXTURE_COMPONENT);
        #endif
        #ifdef USE_AMBIENT_INTENSITY
            _surface.ambient *= scn_commonprofile.ambientIntensity;
        #endif
    #endif 
#elif defined(USE_AMBIENT_COLOR)
    _surface.ambient = scn_commonprofile.ambientColor;
#elif defined(USE_AMBIENT)
    _surface.ambient = float4(0.);
#endif
#if defined(USE_AMBIENT) && defined(USE_VERTEX_COLOR)
    _surface.ambient *= in.vertexColor;
#endif
#if  defined(USE_SSAO)
    _surface.ambientOcclusion *= u_ssaoTexture.sample( sampler(filter::linear), in.fragmentPosition.xy * scn_frame.inverseResolution.xy ).x;
#endif
    
#ifdef USE_DIFFUSE_MAP
    _surface.diffuse = u_diffuseTexture.sample(u_diffuseTextureSampler, _surface.diffuseTexcoord);
#if defined(USE_DIFFUSE_TEXTURE_COMPONENT)
    _surface.diffuse = colorFromMask(_surface.diffuse, USE_DIFFUSE_TEXTURE_COMPONENT);
#endif
#ifdef USE_DIFFUSE_INTENSITY
    _surface.diffuse.rgb *= scn_commonprofile.diffuseIntensity;
#endif
#elif defined(USE_DIFFUSE_COLOR)
    _surface.diffuse = scn_commonprofile.diffuseColor;
#else
    _surface.diffuse = float4(0.f,0.f,0.f,1.f);
#endif
#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)
    _surface.diffuse.rgb    *= in.vertexColor.rgb;
    _surface.diffuse        *= in.vertexColor.a; 
#endif
#ifdef USE_SPECULAR_MAP
    _surface.specular = u_specularTexture.sample(u_specularTextureSampler, _surface.specularTexcoord);
#if defined(USE_SPECULAR_TEXTURE_COMPONENT)
    _surface.specular = colorFromMask(_surface.specular, USE_SPECULAR_TEXTURE_COMPONENT);
#endif
#ifdef USE_SPECULAR_INTENSITY
    _surface.specular *= scn_commonprofile.specularIntensity;
#endif
#elif defined(USE_SPECULAR_COLOR)
    _surface.specular = scn_commonprofile.specularColor;
#elif defined(USE_SPECULAR)
    _surface.specular = float4(0.f);
#endif
    
#ifdef USE_CLEARCOAT_MAP
    _surface.clearCoat = u_clearCoatTexture.sample(u_clearCoatTextureSampler, _surface.clearCoatTexcoord).r;
#if defined(USE_CLEARCOAT_TEXTURE_COMPONENT)
    _surface.clearCoat = colorFromMask(_surface.clearCoat, USE_CLEARCOAT_TEXTURE_COMPONENT).r;
#endif
#ifdef USE_CLEARCOAT_INTENSITY
    _surface.clearCoat *= scn_commonprofile.clearCoatIntensity;
#endif
#elif defined(USE_CLEARCOAT_COLOR)
    _surface.clearCoat = scn_commonprofile.clearCoat;
#elif defined(USE_CLEARCOAT)
    _surface.clearCoat = 0.f;
#endif
    
#ifdef USE_CLEARCOATROUGHNESS_MAP
#if defined(USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT)
    _surface.clearCoatRoughness = colorFromMask(u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord), USE_CLEARCOATROUGHNESS_TEXTURE_COMPONENT).r;
#else
    _surface.clearCoatRoughness = u_clearCoatRoughnessTexture.sample(u_clearCoatRoughnessTextureSampler, _surface.clearCoatRoughnessTexcoord).r;
#endif
#ifdef USE_CLEARCOATROUGHNESS_INTENSITY
    _surface.clearCoatRoughness *= scn_commonprofile.clearCoatRoughnessIntensity;
#endif
#elif defined(USE_CLEARCOATROUGHNESS_COLOR)
    _surface.clearCoatRoughness = scn_commonprofile.clearCoatRoughness;
#else
    _surface.clearCoatRoughness = 0.03f;
#endif
#ifdef USE_EMISSION_MAP
    _surface.emission = u_emissionTexture.sample(u_emissionTextureSampler, _surface.emissionTexcoord);
#if defined(USE_EMISSION_TEXTURE_COMPONENT)
    _surface.emission = colorFromMask(_surface.emission, USE_EMISSION_TEXTURE_COMPONENT);
#endif
#ifdef USE_EMISSION_INTENSITY
    _surface.emission *= scn_commonprofile.emissionIntensity;
#endif
#elif defined(USE_EMISSION_COLOR)
    _surface.emission = scn_commonprofile.emissionColor;
#elif defined(USE_EMISSION)
    _surface.emission = float4(0.);
#endif
#ifdef USE_SELFILLUMINATION_MAP
    _surface.selfIllumination = u_selfIlluminationTexture.sample(u_selfIlluminationTextureSampler, _surface.selfIlluminationTexcoord);
#if defined(USE_SELFILLUMINATION_TEXTURE_COMPONENT)
    _surface.selfIllumination = colorFromMask(_surface.selfIllumination, USE_SELFILLUMINATION_TEXTURE_COMPONENT);
#endif
#ifdef USE_SELFILLUMINATION_INTENSITY
    _surface.selfIllumination *= scn_commonprofile.selfIlluminationIntensity;
#endif
#elif defined(USE_SELFILLUMINATION_COLOR)
    _surface.selfIllumination = scn_commonprofile.selfIlluminationColor;
#elif defined(USE_SELFILLUMINATION)
    _surface.selfIllumination = float4(0.);
#endif
#ifdef USE_MULTIPLY_MAP
    _surface.multiply = u_multiplyTexture.sample(u_multiplyTextureSampler, _surface.multiplyTexcoord);
#if defined(USE_MULTIPLY_TEXTURE_COMPONENT)
    _surface.multiply = colorFromMask(_surface.multiply, USE_MULTIPLY_TEXTURE_COMPONENT);
#endif
#ifdef USE_MULTIPLY_INTENSITY
    _surface.multiply = mix(float4(1.), _surface.multiply, scn_commonprofile.multiplyIntensity);
#endif
#elif defined(USE_MULTIPLY_COLOR)
    _surface.multiply = scn_commonprofile.multiplyColor;
#elif defined(USE_MULTIPLY)
    _surface.multiply = float4(1.);
#endif
#ifdef USE_TRANSPARENT_MAP
    _surface.transparent = u_transparentTexture.sample(u_transparentTextureSampler, _surface.transparentTexcoord);
#if defined(USE_TRANSPARENT_TEXTURE_COMPONENT)
    _surface.transparent = colorFromMask(_surface.transparent, USE_TRANSPARENT_TEXTURE_COMPONENT);
#endif
#ifdef USE_TRANSPARENT_INTENSITY
    _surface.transparent *= scn_commonprofile.transparentIntensity;
#endif
#elif defined(USE_TRANSPARENT_COLOR)
    _surface.transparent = scn_commonprofile.transparentColor;
#elif defined(USE_TRANSPARENT)
    _surface.transparent = float4(1.f);
#endif
    
#ifdef USE_METALNESS_MAP
#if defined(USE_METALNESS_TEXTURE_COMPONENT)
    _surface.metalness = colorFromMask(u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord), USE_METALNESS_TEXTURE_COMPONENT).r;
#else
    _surface.metalness = u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord).r;
#endif
#ifdef USE_METALNESS_INTENSITY
    _surface.metalness *= scn_commonprofile.metalnessIntensity;
#endif
#elif defined(USE_METALNESS_COLOR)
    _surface.metalness = scn_commonprofile.metalness;
#else
    _surface.metalness = 0.f;
#endif
    
#ifdef USE_ROUGHNESS_MAP
#if defined(USE_ROUGHNESS_TEXTURE_COMPONENT)
    _surface.roughness = colorFromMask(u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord), USE_ROUGHNESS_TEXTURE_COMPONENT).r;
#else
    _surface.roughness = u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord).r;
#endif
#ifdef USE_ROUGHNESS_INTENSITY
    _surface.roughness *= scn_commonprofile.roughnessIntensity;
#endif
#elif defined(USE_ROUGHNESS_COLOR)
    _surface.roughness = scn_commonprofile.roughness;
#else
    _surface.roughness = 0.f;
#endif
#if (defined USE_POSITION) && (USE_POSITION == 2)
    _surface.position = in.position;
#endif
#if (defined USE_NORMAL) && (USE_NORMAL == 2)
#if defined(HAS_NORMAL) || defined(USE_OPENSUBDIV)
#ifdef USE_DOUBLE_SIDED
    _surface.geometryNormal = normalize(in.normal.xyz) * (isFrontFacing ? 1.f : -1.f );
#else
    _surface.geometryNormal = normalize(in.normal.xyz);
#endif
#else 
    _surface.geometryNormal = normalize( cross(dfdy( _surface.position ), dfdx( _surface.position ) ));
#endif
    _surface.normal = _surface.geometryNormal;
    _surface.clearCoatNormal = _surface.geometryNormal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    _surface.tangent = in.tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    _surface.bitangent = in.bitangent;
#endif
#if (defined USE_VIEW) && (USE_VIEW == 2)
    _surface.view = normalize(-in.position);
    {
        
        
        float NoV = dot(_surface.geometryNormal, _surface.view);
        _surface.view = _surface.view + max(0.f, -2.f * NoV) * _surface.geometryNormal;         
        
    }
#endif
#if defined(USE_NORMAL_MAP)
    {
        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.normal);
#ifdef USE_NORMAL_MAP
#if defined(USE_NORMAL_TEXTURE_COMPONENT)
        _surface._normalTS.xy = colorFromMask(u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord), USE_NORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;
        _surface._normalTS.z = sqrt(1.f - saturate(length_squared(_surface._normalTS.xy)));
#else
        _surface._normalTS = u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord).rgb;
        _surface._normalTS = _surface._normalTS * 2.f - 1.f;
#endif
#ifdef USE_NORMAL_INTENSITY
        _surface._normalTS = mix(float3(0.f, 0.f, 1.f), _surface._normalTS, scn_commonprofile.normalIntensity);
#endif
#else
        _surface._normalTS = float3(0.f, 0.f, 1.f);
#endif
        _surface.normal.rgb = normalize(ts2vs * _surface._normalTS.xyz );
    }
#else
    _surface._normalTS = float3(0.f, 0.f, 1.f);
#endif
#ifdef USE_PBR
    {
        float roughness = clamp(_surface.roughness, PBR_MIN_ROUGHNESS, 1.0);
        float alpha = scn_filteredAlphaFromRoughness(_surface.normal, roughness);
        _surface.roughness = sqrt(alpha);
    }
#endif
#if defined(USE_CLEARCOATNORMAL_MAP)
    {
        
        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.geometryNormal);
#ifdef USE_CLEARCOATNORMAL_MAP
#if defined(USE_CLEARCOATNORMAL_TEXTURE_COMPONENT)
        _surface._clearCoatNormalTS.xy = colorFromMask(u_clearCoatNormalTexture.sample(u_clearCoatnormalTextureSampler, _surface.clearCoatNormalTexcoord), USE_CLEARCOATNORMAL_TEXTURE_COMPONENT).rg * 2.f - 1.f;
        _surface._clearCoatNormalTS.z = sqrt(1.f - saturate(length_squared(_surface._clearCoatNormalTS.xy)));
#else
        _surface._clearCoatNormalTS = u_clearCoatNormalTexture.sample(u_clearCoatNormalTextureSampler, _surface.clearCoatNormalTexcoord).rgb;
        _surface._clearCoatNormalTS = _surface._clearCoatNormalTS * 2.f - 1.f;
#endif
#ifdef USE_CLEARCOATNORMAL_INTENSITY
        _surface._clearCoatNormalTS = mix(float3(0.f, 0.f, 1.f), _surface._clearCoatNormalTS, scn_commonprofile.clearCoatNormalIntensity);
#endif
#else
        _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);
#endif
        _surface.clearCoatNormal.rgb = normalize(ts2vs * _surface._clearCoatNormalTS.xyz );
    }
#else
    _surface._clearCoatNormalTS = float3(0.f, 0.f, 1.f);
#endif
    
#ifdef USE_REFLECTIVE_MAP
    float3 refl = reflect( -_surface.view, _surface.normal );
    float m = 2.f * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.f)*(refl.z+1.f));
    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, float2(float2(refl.x,-refl.y) / m) + 0.5f);
#if defined(USE_REFLECTIVE_TEXTURE_COMPONENT)
    _surface.reflective = colorFromMask(_surface.reflective, USE_REFLECTIVE_TEXTURE_COMPONENT).r;
#endif
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective *= scn_commonprofile.reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_CUBEMAP)
    float3 refl = reflect( _surface.position, _surface.normal );
    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, scn::mat4_mult_float3(scn_frame.viewToCubeTransform, refl)); 
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective *= scn_commonprofile.reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_COLOR)
    _surface.reflective = scn_commonprofile.reflectiveColor;
#elif defined(USE_REFLECTIVE)
    _surface.reflective = float4(0.);
#endif
#ifdef USE_FRESNEL
    _surface.fresnel = scn_commonprofile.fresnel.x + scn_commonprofile.fresnel.y * pow(1.f - saturate(dot(_surface.view, _surface.normal)), scn_commonprofile.fresnel.z);
    _surface.reflective *= _surface.fresnel;
#endif
#ifdef USE_SHININESS
    _surface.shininess = scn_commonprofile.materialShininess;
#endif
    
    
    
    
    
#ifdef USE_SURFACE_MODIFIER
    
    __DoSurfaceModifier__
    
#endif
    
    
    
    
    
    SCNShaderLightingContribution _lightingContribution(_surface, in);
#ifdef USE_LIGHT_MODIFIER
    __LightModifierCopyDecl__
#endif
#ifdef USE_AMBIENT_LIGHTING
    _lightingContribution.ambient = scn_frame.ambientLightingColor.rgb;
#endif
#ifdef USE_LIGHTING
#ifdef USE_PER_PIXEL_LIGHTING
#ifdef USE_CLUSTERED_LIGHTING
    uint3 clusterIndex;
    clusterIndex.xy = uint2(in.fragmentPosition.xy * scn_frame.clusterScale.xy); 
    clusterIndex.z = in.position.z * scn_frame.clusterScale.z + scn_frame.clusterScale.w; 
    
    
    ushort4 cluster_offset_count = u_clusterTexture.read(clusterIndex);
    int lid = cluster_offset_count.x;
#endif
#ifdef USE_PBR
    _lightingContribution.prepareForPBR(u_specularDFGDiffuseHammonTexture, scn_commonprofile.selfIlluminationOcclusion);
    
    
#ifdef USE_SELFILLUMINATION
    _lightingContribution.add_irradiance_from_selfIllum();
#else
#ifdef USE_PROBES_LIGHTING 
    _lightingContribution.add_global_irradiance_from_sh(scn_frame.viewToCubeTransform, scn_node.shCoefficients);
#else
    _lightingContribution.add_global_irradiance_probe(u_irradianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);
#endif
#endif
    
#ifndef DISABLE_SPECULAR
#ifdef C3D_USE_REFLECTION_PROBES
    int probe_count = (cluster_offset_count.z & 0xff);
    for (int i = 0 ; i < probe_count; ++i, ++lid) {
        _lightingContribution.add_local_probe(scn_lights[LightIndex(lid)], u_reflectionProbeTexture);
    }
#if PROBES_NORMALIZATION
#if PROBES_OUTER_BLENDING
    _lightingContribution.specular += _lightingContribution.probesWeightedSum.rgb / max(1.f, _lightingContribution.probesWeightedSum.a);
#else
    _lightingContribution.specular += _lightingContribution.probesWeightedSum.rgb / _lightingContribution.probesWeightedSum.a;
#endif
    float globalFactor = saturate(1.f - _lightingContribution.probesWeightedSum.a);
#else
    float globalFactor = _lightingContribution.probeRadianceRemainingFactor;
#endif
    _lightingContribution.add_global_probe(scn_frame.viewToCubeTransform, globalFactor * scn_frame.environmentIntensity,
                                           u_reflectionProbeTexture);
#else 
   _lightingContribution.add_global_probe(u_radianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);
    
#ifdef USE_CLEARCOAT
    _lightingContribution.add_global_probeClearCoat(u_radianceTexture, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);
#endif
    
#endif 
#endif 
#endif 
    #if DEBUG_PIXEL
        switch (DEBUG_PIXEL) {
            case 1: _output.color = float4(_surface.normal * 0.5f + 0.5f, 1.f); break;
            case 2: _output.color = float4(_surface.geometryNormal * 0.5f + 0.5f, 1.f); break;
            case 3: _output.color = float4(_surface.tangent * 0.5f + 0.5f, 1.f); break;
            case 4: _output.color = float4(in.uv0, 0.f, 1.f); break;
            case 5: _output.color = float4(_surface.diffuse.rgb, 1.f); break;
            case 6: _output.color = float4(float3(_surface.roughness), 1.f); break;
            case 7: _output.color = float4(float3(_surface.metalness), 1.f); break;
            case 8: _output.color = float4(float3(_surface.ambientOcclusion), 1.f); break;
            default: break;
        }
        return _output;
    #endif
    
    __FragmentDoLighting__
    
    #ifdef USE_CLUSTERED_LIGHTING
        
        int omni_count = cluster_offset_count.y & 0xff;
        for (int i = 0 ; i < omni_count; ++i, ++lid) {
            _lightingContribution.add_local_omni(scn_lights[LightIndex(lid)]);
        }
        
        int spot_count = (cluster_offset_count.y >> 8);
        for (int i = 0 ; i < spot_count; ++i, ++lid) {
            _lightingContribution.add_local_spot(scn_lights[LightIndex(lid)]);
        }
    #endif
#else 
        _lightingContribution.diffuse = in.diffuse;
    #ifdef USE_SPECULAR
        _lightingContribution.specular = in.specular;
    #endif
#endif 
    #ifdef AVOID_OVERLIGHTING
        _lightingContribution.diffuse = saturate(_lightingContribution.diffuse);
    #ifdef USE_SPECULAR
        _lightingContribution.specular = saturate(_lightingContribution.specular);
    #endif 
    #endif 
#else 
    _lightingContribution.diffuse = float3(1.);
#endif 
    
    
    
    
#ifdef USE_PBR
    { 
        float3 diffuseAlbedo = mix(_lightingContribution.pbr.albedo, float3(0.0), _surface.metalness);
        
        
#ifdef USE_PBR_TRANSPARENCY
        float3 color = (_lightingContribution.ambient * _surface.ambientOcclusion) * _lightingContribution.pbr.albedo;
#else
        float3 color = (_lightingContribution.ambient * _surface.ambientOcclusion) * _surface.diffuse.rgb;
#endif
        
        color += _lightingContribution.pbr.envDiffuse;
        color += _lightingContribution.diffuse * diffuseAlbedo;
#ifndef DISABLE_SPECULAR
        color += _lightingContribution.pbr.envSpecular;
        color += _lightingContribution.specular;
#endif
#ifdef USE_EMISSION
        color += _surface.emission.rgb;
#endif
#ifdef USE_MULTIPLY
        color *= _surface.multiply.rgb;
#endif
#ifdef USE_MODULATE
        color *= _lightingContribution.modulate;
#endif
        _output.color.rgb = color;
    }
#else 
#ifdef USE_SHADOWONLY
    _output.color.rgb = float3(0.0);
    _output.color.a = 1. - _lightingContribution.shadowFactor;
#else
    _output.color.rgb = illuminate(_surface, _lightingContribution);
#endif
#endif
#ifndef USE_SHADOWONLY
  #ifdef USE_PBR_TRANSPARENCY
    _output.color.a = _lightingContribution.pbr.transparency;
  #else
    _output.color.a = _surface.diffuse.a;
  #endif
#endif
#ifdef USE_FOG
    float fogFactor = pow(clamp(length(_surface.position.xyz) * scn_frame.fogParameters.x + scn_frame.fogParameters.y, 0., scn_frame.fogColor.a), scn_frame.fogParameters.z);
    _output.color.rgb = mix(_output.color.rgb, scn_frame.fogColor.rgb * _output.color.a, fogFactor);
#endif
#if !defined(DIFFUSE_PREMULTIPLIED) && !defined(USE_PBR_TRANSPARENCY)
    _output.color.rgb *= _surface.diffuse.a;
#endif
    
    
    
    
    
#ifdef USE_SHADOWONLY
    float transparencyFactor = 1.0;
  #ifdef USE_NODE_OPACITY
    transparencyFactor *= in.nodeOpacity;
  #endif
    _output.color.a *= transparencyFactor; 
#else 
#ifdef USE_TRANSPARENT 
    
#ifdef USE_TRANSPARENCY
    _surface.transparent *= scn_commonprofile.transparency;
#endif
    
#ifdef USE_TRANSPARENCY_RGBZERO
    
    _surface.transparent.a = (_surface.transparent.r * 0.212671f) + (_surface.transparent.g * 0.715160f) + (_surface.transparent.b * 0.072169f);
    _output.color *= (float4(1.f) - _surface.transparent);
#else
  #ifndef USE_PBR_TRANSPARENCY
    _output.color *= _surface.transparent.a;
  #endif
#endif
    
#else 
    
#ifdef USE_TRANSPARENCY 
  #ifndef USE_PBR_TRANSPARENCY
    _output.color *= scn_commonprofile.transparency;
  #endif
#endif
    
#endif 
    
#ifdef USE_NODE_OPACITY
    _output.color *= in.nodeOpacity;
#endif
    
#endif 
    
    
    
    
    
#ifdef USE_MODIFIER_FRAMEBUFFER
    const SCNFramebuffer _framebuffer = {
#if defined(C3D_SUPPORTS_PROGRAMMABLE_BLENDING) && defined(USE_MODIFIER_FRAMEBUFFER_COLOR0)
        .color = framebufferColor0
#else
        .color = 0.f
#endif
    };
#endif
    
#ifdef USE_FRAGMENT_MODIFIER
    
    __DoFragmentModifier__
    
#endif
#if defined(USE_CLUSTERED_LIGHTING) && defined(DEBUG_CLUSTER_TILE)
    _output.color.rgb = mix(_output.color.rgb, float3(scn::debugColorForCount(clusterIndex.z).xyz), 0.1f);
    _output.color.rgb = mix(_output.color.rgb, float3(clusterIndex.x & 0x1 ^ clusterIndex.y & 0x1).xyz, 0.01f);
#endif
#ifdef DISABLE_LINEAR_RENDERING
    _output.color.rgb = scn::linear_to_srgb(_output.color.rgb);
#endif
    
#ifdef USE_DISCARD
    if (_output.color.a == 0.) 
        discard_fragment();
#endif
#ifdef USE_POINT_RENDERING
    if ((dfdx(pointCoord.x) < 0.5f) && (length_squared(pointCoord * 2.f - 1.f) > 1.f)) {
        discard_fragment();
    }
#endif
    
    
#ifdef USE_OUTLINE
    _output.color.rgb = in.outlineHash;
#endif
    
#ifdef USE_MOTIONBLUR
#ifdef USE_MULTIPLE_RENDERING
    _output.motionblur.xy = half2((in.mv_fragment.xy - scn_frame.viewportSize.zw) / in.mv_fragment.z - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * scn_frame.motionBlurIntensity;
#else
    _output.motionblur.xy = half2((in.mv_fragment.xy / in.mv_fragment.z) - (in.mv_lastFragment.xy / in.mv_lastFragment.z))*half2(1.,-1.) * scn_frame.motionBlurIntensity;
#endif
    _output.motionblur.z = length(_output.motionblur.xy);
    _output.motionblur.w = half(-_surface.position.z);
#endif
#ifdef USE_NORMALS_OUTPUT
    _output.normals = half4( half3(_surface.normal.xyz), half(_surface.roughness) );
#endif
    
#ifdef USE_RADIANCE_OUTPUT
    _output.radiance.rgb = half3(_lightingContribution.specular.rgb);
#endif
                                 
#ifdef USE_REFLECTANCE_ROUGHNESS_OUTPUT
#ifdef USE_PBR
    _output.reflectanceRoughnessOutput = half4( half3(_lightingContribution.pbr.probeReflectance), half(_surface.roughness) );
#else 
    _output.reflectanceRoughnessOutput = half4( 0.h );
#endif
#endif
    
    return _output;
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
#import "scn_standard_lighting.h"
#import "scn_standard_constants.h"
#import "C3D-PBR.metal"
enum C3DLightingModel
    C3DLightingModelConstant,
    C3DLightingModelLambert,
    C3DLightingModelPhong,
    C3DLightingModelBlinn,
    C3DLightingModelNone,
    C3DLightingModelPhysicallyBased,
constant bool use_per_vertex_diffuse    = use_per_vertex_lighting;
constant bool use_per_vertex_specular   = use_per_vertex_lighting && use_specular;
constant bool use_per_pixel_lighting    = !use_per_vertex_lighting; 
constant bool lighting_model_is_pbr     = (lighting_model == C3DLightingModelPhysicallyBased);
constant bool use_pbr                   = is_function_constant_defined(lighting_model) && lighting_model_is_pbr;
constant bool use_io_texcoord0          = io_texcoord_count > 0;
constant bool use_io_texcoord1          = io_texcoord_count > 1;
constant bool use_io_texcoord2          = io_texcoord_count > 2;
constant bool use_io_texcoord3          = io_texcoord_count > 3;
constant bool use_io_texcoord4          = io_texcoord_count > 4;
constant bool use_io_texcoord5          = io_texcoord_count > 5;
constant bool use_io_texcoord6          = io_texcoord_count > 6;
constant bool use_io_texcoord7          = io_texcoord_count > 7;
constant bool use_no_instancing             = !use_instancing;
constant bool dummy_shadow0             = LIGHT_HAS_SHADOW(use_light0);
constant bool use_shadow0               = is_function_constant_defined(use_light0) && dummy_shadow0;
constant bool dummy_shadow1             = LIGHT_HAS_SHADOW(use_light1);
constant bool use_shadow1               = is_function_constant_defined(use_light1) && dummy_shadow1;
constant bool dummy_shadow2             = LIGHT_HAS_SHADOW(use_light2);
constant bool use_shadow2               = is_function_constant_defined(use_light2) && dummy_shadow2;
constant bool dummy_shadow3             = LIGHT_HAS_SHADOW(use_light3);
constant bool use_shadow3               = is_function_constant_defined(use_light3) && dummy_shadow3;
constant bool dummy_gobo0               = LIGHT_HAS_GOBO(use_light0);
constant bool use_gobo0                 = is_function_constant_defined(use_light0) && dummy_gobo0;
constant bool dummy_gobo1               = LIGHT_HAS_GOBO(use_light1);
constant bool use_gobo1                 = is_function_constant_defined(use_light1) && dummy_gobo1;
constant bool dummy_gobo2               = LIGHT_HAS_GOBO(use_light2);
constant bool use_gobo2                 = is_function_constant_defined(use_light2) && dummy_gobo2;
constant bool dummy_gobo3               = LIGHT_HAS_GOBO(use_light3);
constant bool use_gobo3                 = is_function_constant_defined(use_light3) && dummy_gobo3;
constant bool dummy_ies0                = LIGHT_TYPE(use_light0) == kC3DLightTypeIES;
constant bool dummy_iesType2d0          = (LIGHT_IES_TYPE(use_light0) != kC3DLightIESTypeCubemap);
constant bool dummy_iesTypeCube0        = (LIGHT_IES_TYPE(use_light0) == kC3DLightIESTypeCubemap);
constant bool dummy_ies2d0              = dummy_ies0 && dummy_iesType2d0;
constant bool dummy_iesCube0            = dummy_ies0 && dummy_iesTypeCube0;
constant bool use_ies0                  = is_function_constant_defined(use_light0) && dummy_ies2d0;
constant bool use_iesCube0              = is_function_constant_defined(use_light0) && dummy_iesCube0;
constant bool dummy_ies1                = LIGHT_TYPE(use_light1) == kC3DLightTypeIES;
constant bool dummy_iesType2d1          = (LIGHT_IES_TYPE(use_light1) != kC3DLightIESTypeCubemap);
constant bool dummy_iesTypeCube1        = (LIGHT_IES_TYPE(use_light1) == kC3DLightIESTypeCubemap);
constant bool dummy_ies2d1              = dummy_ies1 && dummy_iesType2d1;
constant bool dummy_iesCube1            = dummy_ies1 && dummy_iesTypeCube1;
constant bool use_ies1                  = is_function_constant_defined(use_light1) && dummy_ies2d1;
constant bool use_iesCube1              = is_function_constant_defined(use_light1) && dummy_iesCube1;
constant bool dummy_ies2                = LIGHT_TYPE(use_light2) == kC3DLightTypeIES;
constant bool dummy_iesType2d2          = (LIGHT_IES_TYPE(use_light2) != kC3DLightIESTypeCubemap);
constant bool dummy_iesTypeCube2        = (LIGHT_IES_TYPE(use_light2) == kC3DLightIESTypeCubemap);
constant bool dummy_ies2d2              = dummy_ies2 && dummy_iesType2d2;
constant bool dummy_iesCube2            = dummy_ies2 && dummy_iesTypeCube2;
constant bool use_ies2                  = is_function_constant_defined(use_light2) && dummy_ies2d2;
constant bool use_iesCube2              = is_function_constant_defined(use_light2) && dummy_iesCube2;
constant bool dummy_ies3                = LIGHT_TYPE(use_light3) == kC3DLightTypeIES;
constant bool dummy_iesType2d3          = (LIGHT_IES_TYPE(use_light3) != kC3DLightIESTypeCubemap);
constant bool dummy_iesTypeCube3        = (LIGHT_IES_TYPE(use_light3) == kC3DLightIESTypeCubemap);
constant bool dummy_ies2d3              = dummy_ies3 && dummy_iesType2d3;
constant bool dummy_iesCube3            = dummy_ies3 && dummy_iesTypeCube3;
constant bool use_ies3                  = is_function_constant_defined(use_light3) && dummy_ies2d3;
constant bool use_iesCube3              = is_function_constant_defined(use_light3) && dummy_iesCube3;
constexpr sampler linearSampler(filter::linear, mip_filter::linear);
constexpr sampler shadowSampler(filter::linear, mip_filter::none, compare_func::greater_equal);
#define MAX_LIGHT_COUNT 8
typedef struct {
    
    float4x4 modelViewTransform;            
    
    float4x4 normalTransform;               
    
    float4x4 modelTransform;            
    uint8_t lightIndices[MAX_LIGHT_COUNT];  
    float nodeOpacity;                      
    
} scn_std_node;
typedef struct {
    float3 position         [[ attribute(SCNVertexSemanticPosition)]];
    float3 normal           [[ attribute(SCNVertexSemanticNormal),      function_constant(need_normal) ]];
    float4 tangent          [[ attribute(SCNVertexSemanticTangent),     function_constant(need_tangent) ]];
    float4 color            [[ attribute(SCNVertexSemanticColor)        function_constant(need_vertex_color) ]];
    float2 texcoord0        [[ attribute(SCNVertexSemanticTexcoord0),   function_constant(need_texcoord0) ]];
    float2 texcoord1        [[ attribute(SCNVertexSemanticTexcoord1),   function_constant(need_texcoord1) ]];
    float2 texcoord2        [[ attribute(SCNVertexSemanticTexcoord2),   function_constant(need_texcoord2) ]];
    float2 texcoord3        [[ attribute(SCNVertexSemanticTexcoord3),   function_constant(need_texcoord3) ]];
    float2 texcoord4        [[ attribute(SCNVertexSemanticTexcoord4),   function_constant(need_texcoord4) ]];
    float2 texcoord5        [[ attribute(SCNVertexSemanticTexcoord5),   function_constant(need_texcoord5) ]];
    float2 texcoord6        [[ attribute(SCNVertexSemanticTexcoord6),   function_constant(need_texcoord6) ]];
    float2 texcoord7        [[ attribute(SCNVertexSemanticTexcoord7),   function_constant(need_texcoord7) ]];
} scn_vertex_t; 
typedef struct {
    float4 fragmentPosition [[position]]; 
    
    float fragmentSize  [[ point_size, function_constant(use_point_rendering) ]];
    float4 vertexColor  [[ function_constant(use_io_vertex_color) ]];
    float3 position     [[ function_constant(use_io_position) ]];
    float3 normal       [[ function_constant(use_io_normal) ]];
    float3 tangent      [[ function_constant(need_tangent) ]];
    float3 bitangent    [[ function_constant(need_tangent) ]];
    
    float2 texcoord0    [[ function_constant(use_io_texcoord0) ]];
    float2 texcoord1    [[ function_constant(use_io_texcoord1) ]];
    float2 texcoord2    [[ function_constant(use_io_texcoord2) ]];
    float2 texcoord3    [[ function_constant(use_io_texcoord3) ]];
    float2 texcoord4    [[ function_constant(use_io_texcoord4) ]];
    float2 texcoord5    [[ function_constant(use_io_texcoord5) ]];
    float2 texcoord6    [[ function_constant(use_io_texcoord6) ]];
    float2 texcoord7    [[ function_constant(use_io_texcoord7) ]];
    float3 diffuse      [[ function_constant(use_per_vertex_diffuse) ]];
    float3 specular     [[ function_constant(use_per_vertex_specular) ]];
    
#ifdef USE_EXTRA_VARYINGS
    __ExtraVaryingsDecl__
#endif
    
} commonprofile_io;
struct SCNShaderSurface {
    float3 view;                
    float3 position;            
    float3 normal;              
    float3 geometryNormal;      
    float2 normalTexcoord;      
    float3 tangent;             
    float3 bitangent;           
    float4 ambient;             
    float2 ambientTexcoord;     
    float4 diffuse;             
    float2 diffuseTexcoord;     
    float4 specular;            
    float2 specularTexcoord;    
    float4 emission;            
    float2 emissionTexcoord;    
    float4 multiply;            
    float2 multiplyTexcoord;    
    float4 transparent;         
    float2 transparentTexcoord; 
    float4 reflective;          
    float  metalness;           
    float2 metalnessTexcoord;   
    float  roughness;           
    float2 roughnessTexcoord;   
    float shininess;            
    float fresnel;              
    float ambientOcclusion;     
    float3 _normalTS;           
    
#ifdef USE_SURFACE_EXTRA_DECL
    __SurfaceExtraDecl__
#endif
struct SCNShaderGeometry
    float4 position;
    float3 normal;
    float4 tangent;
    float4 color;
    float2 texcoords[8]; 
struct commonprofile_uniforms {
    float4 diffuseColor;
    float4 specularColor;
    float4 ambientColor;
    float4 emissionColor;
    float4 reflectiveColor;
    float4 multiplyColor;
    float4 transparentColor;
    float metalness;
    float roughness;
    
    float diffuseIntensity;
    float specularIntensity;
    float normalIntensity;
    float ambientIntensity;
    float emissionIntensity;
    float reflectiveIntensity;
    float multiplyIntensity;
    float transparentIntensity;
    float metalnessIntensity;
    float roughnessIntensity;
    float displacementIntensity;
    
    float materialShininess;
    float selfIlluminationOcclusion;
    float transparency;
    float3 fresnel; 
    
    
    float4x4 textureTransforms[1];
#ifdef USE_SHADER_MODIFIERS
__ShaderModifiersDecl__
#endif
struct SCNShaderLightingContribution {
    float3 ambient;
    float3 diffuse;
    float3 specular;
    float3 modulate;
struct SCNLightingParameters {
    
    SCNLightData        lightData;
    uint                lightInfo;
    float3              lightDirection;
    float3              attenuation;
    SCNShaderSurface    surface;
static float3 scn_lighting_direction(SCNLightData lightData, uint lightInfo, thread SCNShaderSurface& surface)
    uint lightType = LIGHT_TYPE(lightInfo);
    if (lightType == kC3DLightTypeDirectional) {
        return lightData.direction;
    }
    return normalize(lightData.position - surface.position);
    
static void scn_lambert_lighting(SCNLightingParameters params, thread SCNShaderLightingContribution& lightingContribution)
    SCNLightData lightData      = params.lightData;
    SCNShaderSurface surface    = params.surface;
    float3 l                    = params.lightDirection;
    
    float3 intensity = lightData.color.rgb * max(0.f, dot(surface.normal, l));
    lightingContribution.diffuse += intensity;
static void scn_blinn_lighting(SCNLightingParameters params, thread SCNShaderLightingContribution& lightingContribution)
    SCNLightData lightData      = params.lightData;
    SCNShaderSurface surface    = params.surface;
    float3 l                    = params.lightDirection;
    float3 intensity =  lightData.color.rgb * max(0.f, dot(surface.normal, l));
    lightingContribution.diffuse += intensity;
    float3 h = normalize(l + surface.view);
    lightingContribution.specular += powr(max(0.f, dot(surface.normal, h)), surface.shininess) * intensity;
static void scn_phong_lighting(SCNLightingParameters params, thread SCNShaderLightingContribution& lightingContribution)
    SCNLightData lightData      = params.lightData;
    SCNShaderSurface surface    = params.surface;
    float3 l                    = params.lightDirection;
    
    float3 intensity = lightData.color.rgb * max(0.f, dot(surface.normal, l));
    lightingContribution.diffuse += intensity;
    
    float3 r = reflect(-l, surface.normal);
    lightingContribution.specular += pow(max(0.f, dot(r, surface.view)), surface.shininess) * intensity;
inline void scn_pbr_lightingContribution_pointLight(float3         l,
                                                    float3         n,
                                                    float3         v,
                                                    float3         albedo,
                                                    float          metalness,
                                                    float          roughness,
                                                    thread float3& lightingContributionDiffuse,
                                                    thread float3& lightingContributionSpecular)
    float3 h = normalize(l + v);
    
    float NoL = saturate(dot(n, l));
    float NoH = saturate(dot(n, h));
    float LoH = saturate(dot(l, h));
    
    float  effectiveAlbedo = (1.f - metalness); 
    float3 reflectance = mix(float3(PBR_F0_NON_METALLIC), albedo, metalness);
    
    float alpha = roughness * roughness; 
    
    float D   = scn_brdf_D(alpha, NoH);
    float3 F  = scn_brdf_F_opt(reflectance, LoH);
#if 0 
    float Vis = scn_brdf_V_opt(alpha, LoH);
#else
    float NoV = saturate(dot(n, v));
    float Vis = scn_brdf_V(alpha, NoL, NoV);
#endif
    
    lightingContributionDiffuse = NoL * effectiveAlbedo * M_1_PI_F;
    lightingContributionSpecular = NoL * D * F * Vis;
static void scn_pbr_lighting(SCNLightingParameters params, thread SCNShaderLightingContribution& lightingContribution)
    SCNLightData lightData      = params.lightData;
    SCNShaderSurface surface    = params.surface;
    float3 l                    = params.lightDirection;
    
    float3 diffuseOut, specularOut;
    scn_pbr_lightingContribution_pointLight(l, surface.normal.xyz, surface.view, surface.diffuse.rgb, surface.metalness, surface.roughness, diffuseOut, specularOut);
    
    lightingContribution.diffuse    += diffuseOut  * lightData.pbrColor.rgb;
    lightingContribution.specular   += specularOut * lightData.pbrColor.rgb;
static float scn_distance_attenuation(SCNLightingParameters params)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    float3 l = params.surface.position - lightData.position;
    if (use_pbr) {
        uint lightType = LIGHT_TYPE(lightInfo);
        if (lightType == kC3DLightTypeDirectional) { 
            return 1.f;
        }
        return scn_pbr_distanceAttenuation(l);
    } else {
        uint distAttType = LIGHT_DIST_ATT(lightInfo);
        if (distAttType != kC3DLightAttenuationTypeNone) {
            
            float3 att = lightData.distanceAttenuation;
            float dist = length(l);
            switch (distAttType) {
                case kC3DLightAttenuationTypeConstant:
                    return step(dist, att.x);
                case kC3DLightAttenuationTypeLinear:
                    return saturate(dist * att.x + att.y);
                case kC3DLightAttenuationTypeQuadratic:
                    return scn::sq(saturate(dist * att.x + att.y));
                case kC3DLightAttenuationTypeExponent:
                    return pow(saturate(dist * att.x + att.y), att.z);
            }
        }
    }
    return 1.f;
static float scn_spot_attenuation(SCNLightingParameters params)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    float3 l                = params.lightDirection;
    
    uint spotAttType = LIGHT_SPOT_ATT(lightInfo);
    if (spotAttType != kC3DLightAttenuationTypeNone) {
        
        float3 spotFactors = lightData.spotAttenuation;
        switch (spotAttType) {
            case kC3DLightAttenuationTypeConstant:
                return step(spotFactors.x, dot(l, lightData.direction));
            case kC3DLightAttenuationTypeLinear:
                return saturate(dot(l, lightData.direction) * spotFactors.x + spotFactors.y);
            case kC3DLightAttenuationTypeQuadratic:
                return scn::sq(saturate(dot(l, lightData.direction) * spotFactors.x + spotFactors.y));
            case kC3DLightAttenuationTypeExponent:
                return pow(saturate(dot(l, lightData.direction) * spotFactors.x + spotFactors.y), spotFactors.z);
        }
    }
    return 1.f;
static void scn_do_gobo(thread SCNLightingParameters& params, texture2d<float> goboMap)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    float goboIntensity = lightData.color.a; 
    float3 goboColor = texture2DProj(goboMap, linearSampler, (lightData.shadowMatrix * float4(params.surface.position, 1.f))).rgb;
    if (LIGHT_IS_MODULATE(lightInfo)) {
        params.attenuation *= mix(float3(1.), goboColor, goboIntensity);
    } else {
        params.attenuation *= goboColor * goboIntensity;
    }
static void scn_do_ies(thread SCNLightingParameters& params, texture2d<float> iesMap, sampler iesSampler)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    
    params.lightDirection   = scn_lighting_direction(params.lightData, lightInfo, params.surface);
    float3 spotFactors      = lightData.spotAttenuation;
    float att = 0.f;
    switch (LIGHT_IES_TYPE(lightInfo)) {
        case kC3DLightIESType1D:
            att = iesMap.sample(iesSampler, float2(acos(dot(params.lightDirection, lightData.direction))*spotFactors.x, 0.f)).r;
            break;
            
        case kC3DLightIESType2D:
        {
            
            float vertAngle     = acos(dot(params.lightDirection, lightData.direction));
            
            float3 surfaceRay   = params.surface.position - lightData.position;
            float3 projPos = normalize(surfaceRay - dot(surfaceRay, lightData.direction) * lightData.direction);
            float2 texCoord = float2(dot(projPos, lightData.right), dot(projPos, lightData.up)) * vertAngle * spotFactors.x;
            att = iesMap.sample(iesSampler, texCoord * 0.5f + 0.5f).r;
            
        } break;
    }
    params.attenuation.rgb *= att;
static void scn_do_ies(thread SCNLightingParameters& params, texturecube<float> iesMap, sampler iesSampler)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    
    params.lightDirection   = scn_lighting_direction(params.lightData, lightInfo, params.surface);
    if (LIGHT_IES_TYPE(lightInfo) == kC3DLightIESTypeCubemap) {
        float att = iesMap.sample(iesSampler, (lightData.shadowMatrix * float4(params.surface.position, 1.f)).xyz).r;
        params.attenuation.rgb *= att;
    } 
static void scn_do_shadow(thread SCNLightingParameters& params, depth2d<float> shadowMap, constant float4* u_shadowKernel)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    
    uchar sampleCount = LIGHT_SHADOW_SAMPLE(lightInfo);
    
    float4 lightScreen = lightData.shadowMatrix * float4(params.surface.position, 1.f);
    
    float shadowRadius = lightData.shadowRadius;
    
    float shadowingTerm = 0.f;
    if (sampleCount > 1) { 
        float filteringSizeFactor = shadowRadius * lightScreen.w;
        for (int i = 0; i < sampleCount; i++) {
            
            shadowingTerm += shadow2DProj(shadowSampler, shadowMap, lightScreen + (u_shadowKernel[i] * filteringSizeFactor));
        }
        shadowingTerm /= float(sampleCount);
    } else {
        shadowingTerm = shadow2DProj(shadowSampler, shadowMap, lightScreen);
    }
    
    
    
    params.attenuation *= (1.f - shadowingTerm * lightData.color.a);
static void scn_do_light(SCNLightingParameters params, thread SCNShaderLightingContribution& lightingContrib)
    uint lightInfo          = params.lightInfo;
    
    params.lightDirection   = scn_lighting_direction(params.lightData, lightInfo, params.surface);
    
    
    
    float attenuation = scn_distance_attenuation(params);
    
    
    uint lightType = LIGHT_TYPE(lightInfo);
    if (lightType == kC3DLightTypeSpot) {
        attenuation *= scn_spot_attenuation(params);
    }
    params.attenuation *= attenuation;
    
    params.lightData.color.rgb *= params.attenuation;
    params.lightData.pbrColor.rgb *= params.attenuation;
    switch (lighting_model) {
        case C3DLightingModelLambert:
            scn_lambert_lighting(params, lightingContrib);
            break;
        case C3DLightingModelBlinn:
            scn_blinn_lighting(params, lightingContrib);
            break;
        case C3DLightingModelPhong:
            scn_phong_lighting(params, lightingContrib);
            break;
        case C3DLightingModelPhysicallyBased:
            scn_pbr_lighting(params, lightingContrib);
            break;
        default:
            
            break;
            
            
    }
inline SCNPBRSurface SCNShaderSurfaceToSCNPBRSurface(SCNShaderSurface surface)
    SCNPBRSurface s;
    
    s.n = surface.normal;
    s.v = surface.view;
    s.albedo = surface.diffuse.xyz;
    
    if (use_emission)
        s.emission = surface.emission.xyz;
    else
        s.emission = float3(0.);
    
    s.metalness = surface.metalness;
    s.roughness = surface.roughness;
    s.ao = surface.ambientOcclusion;
    return s;
static float4 scn_pbr_combine_cubemap(SCNPBRSurface                      surface,
                                     SCNShaderLightingContribution      lighting,
                                     texture2d<float, access::sample>   specularDFG,
                                     texturecube<float, access::sample> specularLD,
                                     texturecube<float, access::sample> irradianceTexture,
                                     constant SCNSceneBuffer&           scn_frame)
    
    float4x4 localDirToWorldCubemapDir = scn_frame.viewToCubeTransform;
    float environmentIntensity = scn_frame.environmentIntensity;
    
    float3 n = surface.n;
    float3 v = surface.v;
    float3 albedo = surface.albedo;
    float metalness = surface.metalness;
    float roughness = surface.roughness;
    float ambientOcclusion = surface.ao;
    
    float3 r = reflect(-v, n); 
    float NoV = saturate(dot(n, v));
    
    float3 diffuseDominantNDirection = n;
    float3 specularDominantNDirection = r;
    
    
    diffuseDominantNDirection = scn::mat4_mult_float3(localDirToWorldCubemapDir, diffuseDominantNDirection);
    
    float3 irradiance;
    if (use_emission_as_selfIllumination) {
        irradiance = surface.emission;
    } else {
        
        irradiance = irradianceTexture.sample(linearSampler, diffuseDominantNDirection).rgb * environmentIntensity;
    }
    
    
    float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);
    
    float3 LD = specularLD.sample(linearSampler, scn::mat4_mult_float3(localDirToWorldCubemapDir, specularDominantNDirection), level(mipLevel)).rgb * environmentIntensity;
    float2 DFG = specularDFG.sample(linearSampler, float2(NoV, roughness)).rg;
    
    float3 effectiveAlbedo = mix(albedo, float3(0.0), metalness);
    float3 reflectance = mix(float3(PBR_F0_NON_METALLIC), albedo, metalness);
    
    float3 diffuse = effectiveAlbedo * irradiance;
    float3 specular = LD * (reflectance * DFG.r + DFG.g);
    
    
    float3 ibl_color;
    if (use_emission_as_selfIllumination) { 
        
        float selfIlluminationAmbientOcclusion = saturate(mix(1., ambientOcclusion, surface.selfIlluminationOcclusion));
        ibl_color = selfIlluminationAmbientOcclusion * diffuse + ambientOcclusion * specular;
    } else {
        ibl_color = ambientOcclusion * (diffuse + specular);
    }
    
    float4 color;
    color.rgb = (lighting.ambient * surface.ao + lighting.diffuse) * surface.albedo.rgb + lighting.specular + ibl_color;
    
    if (use_emission && !use_emission_as_selfIllumination)
        color.rgb += surface.emission.rgb;
    
    return color;
static float4 scn_pbr_combine_probes(SCNPBRSurface                      surface,
                              SCNShaderLightingContribution      lighting,
                              texture2d<float, access::sample>   specularDFG,
                              texturecube<float, access::sample> specularLD,
                              sh3_coefficients                   shCoefficients,
                              constant SCNSceneBuffer&           scn_frame)
    
    float4x4 localDirToWorldCubemapDir = scn_frame.viewToCubeTransform;
    float environmentIntensity = scn_frame.environmentIntensity;
    
    float3 n = surface.n;
    float3 v = surface.v;
    float3 albedo = surface.albedo;
    float metalness = surface.metalness;
    float roughness = surface.roughness;
    float ambientOcclusion = surface.ao;
    
    float3 r = reflect(-v, n); 
    float NoV = saturate(dot(n, v));
    
    float3 diffuseDominantNDirection = n;
    float3 specularDominantNDirection = r;
    
    
    diffuseDominantNDirection = scn::mat4_mult_float3(localDirToWorldCubemapDir, diffuseDominantNDirection);
    
    float3 irradiance;
    if (use_emission_as_selfIllumination) {
        irradiance = surface.emission;
    } else {
        irradiance = shEvalDirection(float4(diffuseDominantNDirection, 1.), shCoefficients) * environmentIntensity;
    }
    
    
    float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);
    
    float3 LD = specularLD.sample(linearSampler, scn::mat4_mult_float3(localDirToWorldCubemapDir, specularDominantNDirection), level(mipLevel)).rgb * environmentIntensity;
    float2 DFG = specularDFG.sample(linearSampler, float2(NoV, roughness)).rg;
    
    float3 effectiveAlbedo = mix(albedo, float3(0.0), metalness);
    float3 reflectance = mix(float3(PBR_F0_NON_METALLIC), albedo, metalness);
    
    float3 diffuse = effectiveAlbedo * irradiance;
    float3 specular = LD * (reflectance * DFG.r + DFG.g);
    
    
    float3 ibl_color;
    if (use_emission_as_selfIllumination) { 
        
        float selfIlluminationAmbientOcclusion = saturate(mix(1., ambientOcclusion, surface.selfIlluminationOcclusion));
        ibl_color = selfIlluminationAmbientOcclusion * diffuse + ambientOcclusion * specular;
    } else {
        ibl_color = ambientOcclusion * (diffuse + specular);
    }
    
    float4 color;
    color.rgb = (lighting.ambient * surface.ao + lighting.diffuse) * surface.albedo.rgb + lighting.specular + ibl_color;
    
    if (use_emission && !use_emission_as_selfIllumination)
        color.rgb += surface.emission.rgb;
    
    return color;
inline float4 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)
    float4 color = {0.,0.,0., surface.diffuse.a};
    
    float3 D = lighting.diffuse;
    if (use_ambient_lighting)
        D += lighting.ambient * surface.ambientOcclusion;
    if (use_emission_as_selfIllumination)
        D += surface.emission.rgb;
    
    color.rgb = surface.diffuse.rgb * D;
    if (use_specular || use_reflective) {
        float3 S = (use_specular) ? lighting.specular : float3(0.);
        if (use_reflective)
            S += surface.reflective.rgb * surface.ambientOcclusion;
        if (use_specular)
            S *= surface.specular.rgb;
        color.rgb += S;
    }
    
    if (use_ambient && !use_ambient_as_ambientOcclusion)
        color.rgb += surface.ambient.rgb * lighting.ambient;
    if (use_emission && !use_emission_as_selfIllumination)
        color.rgb += surface.emission.rgb;
    if (use_multiply)
        color.rgb *= surface.multiply.rgb;
    if (use_modulate_lighting)
        color.rgb *= lighting.modulate;
    return color;
struct scn_patch_t {
    patch_control_point<scn_vertex_t> controlPoints;
static void standard_initalize_surface(thread SCNShaderSurface&  surface,
                                       thread SCNShaderGeometry& geometry,
                                       thread scn_std_node&      in_node)
    
    surface.position = (in_node.modelViewTransform * geometry.position).xyz;
    
    if (use_io_normal)
        surface.normal = normalize(scn::mat3(in_node.normalTransform) * geometry.normal);
    
    if (need_tangent) {
        surface.tangent = normalize(scn::mat3(in_node.normalTransform) * geometry.tangent.xyz);
        
        surface.bitangent = geometry.tangent.w * cross(surface.tangent, surface.normal);
    }
    if (use_io_view)
        surface.view = normalize(-surface.position);
static void standard_initalize_geometry(thread scn_vertex_t&      in,
                                        thread SCNShaderGeometry& geometry)
    geometry.position = float4(in.position, 1.f);
    
    if (need_normal)
        geometry.normal = in.normal;
    
    if (need_tangent)
        geometry.tangent = in.tangent;
    
    if (need_texcoord0)
        geometry.texcoords[0] = in.texcoord0;
    if (need_texcoord1)
        geometry.texcoords[1] = in.texcoord1;
    if (need_texcoord2)
        geometry.texcoords[2] = in.texcoord2;
    if (need_texcoord3)
        geometry.texcoords[3] = in.texcoord3;
    if (need_texcoord4)
        geometry.texcoords[4] = in.texcoord4;
    if (need_texcoord5)
        geometry.texcoords[5] = in.texcoord5;
    if (need_texcoord6)
        geometry.texcoords[6] = in.texcoord6;
    if (need_texcoord7)
        geometry.texcoords[7] = in.texcoord7;
    
    geometry.color = (need_vertex_color) ? in.color : float4(1.f);
static void standard_initalize_geometry_post_tessellation(thread scn_patch_t&       in,
                                                          thread SCNShaderGeometry& geometry,
                                                          float3                    patchCoord)
    geometry.position = float4(scn::barycentric_mix(in.controlPoints[0].position, in.controlPoints[1].position, in.controlPoints[2].position, patchCoord), 1.0);
    
    if (need_normal)
        geometry.normal = normalize(scn::barycentric_mix(in.controlPoints[0].normal, in.controlPoints[1].normal, in.controlPoints[2].normal, patchCoord));
    
    if (need_tangent)
        geometry.tangent = normalize(scn::barycentric_mix(in.controlPoints[0].tangent, in.controlPoints[1].tangent, in.controlPoints[2].tangent, patchCoord));
    
    if (need_texcoord0)
        geometry.texcoords[0] = scn::barycentric_mix(in.controlPoints[0].texcoord0, in.controlPoints[1].texcoord0, in.controlPoints[2].texcoord0, patchCoord);
    if (need_texcoord1)
        geometry.texcoords[1] = scn::barycentric_mix(in.controlPoints[0].texcoord1, in.controlPoints[1].texcoord1, in.controlPoints[2].texcoord1, patchCoord);
    if (need_texcoord2)
        geometry.texcoords[2] = scn::barycentric_mix(in.controlPoints[0].texcoord2, in.controlPoints[1].texcoord2, in.controlPoints[2].texcoord2, patchCoord);
    if (need_texcoord3)
        geometry.texcoords[3] = scn::barycentric_mix(in.controlPoints[0].texcoord3, in.controlPoints[1].texcoord3, in.controlPoints[2].texcoord3, patchCoord);
    if (need_texcoord4)
        geometry.texcoords[4] = scn::barycentric_mix(in.controlPoints[0].texcoord4, in.controlPoints[1].texcoord4, in.controlPoints[2].texcoord4, patchCoord);
    if (need_texcoord5)
        geometry.texcoords[5] = scn::barycentric_mix(in.controlPoints[0].texcoord5, in.controlPoints[1].texcoord5, in.controlPoints[2].texcoord5, patchCoord);
    if (need_texcoord6)
        geometry.texcoords[6] = scn::barycentric_mix(in.controlPoints[0].texcoord6, in.controlPoints[1].texcoord6, in.controlPoints[2].texcoord6, patchCoord);
    if (need_texcoord7)
        geometry.texcoords[7] = scn::barycentric_mix(in.controlPoints[0].texcoord7, in.controlPoints[1].texcoord7, in.controlPoints[2].texcoord7, patchCoord);
    
    geometry.color = (need_vertex_color) ? scn::barycentric_mix(in.controlPoints[0].color, in.controlPoints[1].color, in.controlPoints[2].color, patchCoord) : float4(1.f);
static void standard_configure_out(constant commonprofile_uniforms& commonprofile,
                                   thread SCNShaderSurface&         surface,
                                   thread SCNShaderGeometry&        geometry,
                                   thread commonprofile_io&         out)
    if (use_io_position)
        out.position = surface.position;
    
    if (use_io_normal)
        out.normal = surface.normal;
    
    if (need_tangent) {
        out.tangent = surface.tangent;
        out.bitangent = surface.bitangent;
    }
    
    if (use_io_vertex_color)
        out.vertexColor = geometry.color;
    
    float2 uvOut[kSCNTexcoordCount];
    
    if (is_function_constant_defined(diffuse_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ diffuse_channel ];
        if (is_function_constant_defined(diffuse_transform_index))
            uv = (commonprofile.textureTransforms[diffuse_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ diffuse_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(normal_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ normal_channel ];
        if (is_function_constant_defined(normal_transform_index))
            uv = (commonprofile.textureTransforms[normal_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ normal_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(transparent_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ transparent_channel ];
        if (is_function_constant_defined(transparent_transform_index))
            uv = (commonprofile.textureTransforms[transparent_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ transparent_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(emission_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ emission_channel ];
        if (is_function_constant_defined(emission_transform_index))
            uv = (commonprofile.textureTransforms[emission_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ emission_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(ambient_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ ambient_channel ];
        if (is_function_constant_defined(ambient_transform_index))
            uv = (commonprofile.textureTransforms[ambient_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ ambient_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(multiply_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ multiply_channel ];
        if (is_function_constant_defined(multiply_transform_index))
            uv = (commonprofile.textureTransforms[multiply_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ multiply_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(specular_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ specular_channel ];
        if (is_function_constant_defined(specular_transform_index))
            uv = (commonprofile.textureTransforms[specular_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ specular_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(roughness_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ roughness_channel ];
        if (is_function_constant_defined(roughness_transform_index))
            uv = (commonprofile.textureTransforms[roughness_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ roughness_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(metalness_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ metalness_channel ];
        if (is_function_constant_defined(metalness_transform_index))
            uv = (commonprofile.textureTransforms[metalness_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ metalness_texcoord_io_index ] = uv;
    }
    
    switch (io_texcoord_count - 1) {
        case 7 : out.texcoord7 = uvOut[7];
        case 6 : out.texcoord6 = uvOut[6];
        case 5 : out.texcoord5 = uvOut[5];
        case 4 : out.texcoord4 = uvOut[4];
        case 3 : out.texcoord3 = uvOut[3];
        case 2 : out.texcoord2 = uvOut[2];
        case 1 : out.texcoord1 = uvOut[1];
        case 0 : out.texcoord0 = uvOut[0];
    }
vertex commonprofile_io standard_vert(scn_vertex_t                      in                        [[ stage_in ]],
                                      constant SCNSceneBuffer&          scn_frame                 [[ buffer(0) ]],
                                      constant scn_std_node&            scn_node                  [[ buffer(1), function_constant(use_no_instancing) ]],
                                      
                                      device scn_std_node*              scn_nodes                 [[ buffer(1), function_constant(use_instancing) ]],
                                      device SCNLightData*              scn_lights                [[ buffer(2), function_constant(use_per_vertex_lighting) ]],
                                      constant commonprofile_uniforms&  scn_commonprofile         [[ buffer(3) ]],
                                      uint                              instanceID                [[ instance_id, function_constant(use_instancing) ]]
                                      
#ifdef USE_VERTEX_EXTRA_ARGUMENTS
                                      __VertexExtraArguments__
#endif
                                      )
    scn_std_node in_node;
    if (use_instancing) {
        in_node = scn_nodes[instanceID];
    } else {
        in_node = scn_node;
    }
    SCNShaderGeometry _geometry;
    standard_initalize_geometry(in, _geometry);
    
#ifdef USE_GEOMETRY_MODIFIER
__DoGeometryModifier__
#endif
    
    
    SCNShaderSurface _surface;
    standard_initalize_surface(_surface, _geometry, in_node);
    commonprofile_io out;
    
    
    if (use_per_vertex_lighting) {
        SCNShaderLightingContribution _lightingContribution;
        _lightingContribution.diffuse = 0.;
        _lightingContribution.specular = 0.;
        _surface.shininess = scn_commonprofile.materialShininess;
        
        
        out.diffuse = _lightingContribution.diffuse;
        if (use_specular)
            out.specular = _lightingContribution.specular;
    }
    standard_configure_out(scn_commonprofile, _surface, _geometry, out);
    
    
    
    out.fragmentPosition = scn_frame.projectionTransform * float4(_surface.position, 1.f);
    
    if (use_point_rendering) 
        out.fragmentSize = 1.f;
    return out;
[[ patch(triangle, 3) ]]
vertex commonprofile_io standard_post_tessellation_vert(scn_patch_t                       in                        [[ stage_in ]],
                                                        float3                            patchCoord                [[ position_in_patch ]],
                                                        constant SCNSceneBuffer&          scn_frame                 [[ buffer(0) ]],
                                                        constant scn_std_node&            scn_node                  [[ buffer(1), function_constant(use_no_instancing) ]],
                                                        
                                                        device scn_std_node*              scn_nodes                 [[ buffer(1), function_constant(use_instancing) ]],
                                                        device SCNLightData*              scn_lights                [[ buffer(2), function_constant(use_per_vertex_lighting) ]],
                                                        constant commonprofile_uniforms&  scn_commonprofile         [[ buffer(3) ]],
                                                        
                                                        uint                              instanceID                [[ instance_id, function_constant(use_instancing) ]]
                                                        
#ifdef USE_VERTEX_EXTRA_ARGUMENTS
                                      __VertexExtraArgumentsPostTessellation__
#endif
                                      )
    scn_std_node in_node;
    if (use_instancing) {
        in_node = scn_nodes[instanceID];
    } else {
        in_node = scn_node;
    }
    
    SCNShaderGeometry _geometry;
    standard_initalize_geometry_post_tessellation(in, _geometry, patchCoord);
    
#ifdef USE_GEOMETRY_MODIFIER
    
    __DoGeometryModifierPostTessellation__
    
#endif
    
    
    SCNShaderSurface _surface;
    standard_initalize_surface(_surface, _geometry, in_node);
    
    commonprofile_io out;
    
    
    if (use_per_vertex_lighting) {
        SCNShaderLightingContribution _lightingContribution;
        _lightingContribution.diffuse = 0.;
        _lightingContribution.specular = 0.;
        _surface.shininess = scn_commonprofile.materialShininess;
        
        
        
        
        out.diffuse = _lightingContribution.diffuse;
        if (use_specular)
            out.specular = _lightingContribution.specular;
    }
    
    standard_configure_out(scn_commonprofile, _surface, _geometry, out);
    
    
    
    
    out.fragmentPosition = scn_frame.projectionTransform * float4(_surface.position, 1.f);
    
    if (use_point_rendering) 
        out.fragmentSize = 1.f;
    return out;
struct SCNOutput
    float4 color;
fragment half4 standard_frag(commonprofile_io in [[stage_in]],
                             constant commonprofile_uniforms& scn_commonprofile [[buffer(0)]],
                             constant SCNSceneBuffer& scn_frame [[buffer(1)]]
                             
                             , device SCNLightData* scn_lights                     [[ buffer(2),  function_constant(use_per_pixel_lighting) ]]
                             , constant scn_std_node& scn_node                     [[ buffer(3), function_constant(use_no_instancing) ]]
                             , device scn_std_node* scn_nodes                      [[ buffer(3), function_constant(use_instancing) ]]
                             , constant float4* u_shadowKernel                     [[ buffer(4) ]] 
                             , constant sh3_coefficients& scn_shCoefficients       [[ buffer(5), function_constant(use_probes_lighting) ]]
                             , texture2d<float> u_emissionTexture                  [[ texture(0), function_constant(use_emission_map)]]
                             , sampler          u_emissionTextureSampler           [[ sampler(0), function_constant(use_emission_map)]]
                             , texture2d<float> u_ambientTexture                   [[ texture(1), function_constant(use_ambient_map)]]
                             , sampler          u_ambientTextureSampler            [[ sampler(1), function_constant(use_ambient_map)]]
                             , texture2d<float> u_diffuseTexture                   [[ texture(2), function_constant(use_diffuse_map)]]
                             , sampler          u_diffuseTextureSampler            [[ sampler(2), function_constant(use_diffuse_map)]]
                             , texture2d<float> u_specularTexture                  [[ texture(3), function_constant(use_specular_map)]]
                             , sampler          u_specularTextureSampler           [[ sampler(3), function_constant(use_specular_map)]]
                             , texture2d<float> u_reflectiveTexture                [[ texture(4), function_constant(use_reflective_map)]]
                             , sampler          u_reflectiveTextureSampler         [[ sampler(4), function_constant(use_reflective_map)]]
                             , texturecube<float> u_reflectiveCubeTexture          [[ texture(4), function_constant(use_reflectivecube_map)]]
                             , sampler            u_reflectiveCubeTextureSampler   [[ sampler(4), function_constant(use_reflectivecube_map)]]
                             , texture2d<float> u_transparentTexture               [[ texture(5), function_constant(use_transparent_map)]]
                             , sampler          u_transparentTextureSampler        [[ sampler(5), function_constant(use_transparent_map)]]
                             , texture2d<float> u_multiplyTexture                  [[ texture(6), function_constant(use_multiply_map)]]
                             , sampler          u_multiplyTextureSampler           [[ sampler(6), function_constant(use_multiply_map)]]
                             , texture2d<float> u_normalTexture                    [[ texture(7), function_constant(use_normal_map)]]
                             , sampler          u_normalTextureSampler             [[ sampler(7), function_constant(use_normal_map)]]
                             , texture2d<float> u_metalnessTexture                 [[ texture(3), function_constant(use_metalness_map) ]]
                             , sampler          u_metalnessTextureSampler          [[ sampler(3), function_constant(use_metalness_map) ]]
                             , texture2d<float> u_roughnessTexture                 [[ texture(4), function_constant(use_roughness_map) ]]
                             , sampler          u_roughnessTextureSampler          [[ sampler(4), function_constant(use_roughness_map) ]]
                             , texturecube<float> u_irradianceTexture              [[ texture(8), function_constant(use_pbr) ]]
                             
                             , texturecube<float> u_radianceTexture                [[ texture(9), function_constant(use_pbr) ]]
                             , texture2d<float>   u_specularDFGTexture             [[ texture(10), function_constant(use_pbr) ]]
                             , texture2d<float> u_ssaoTexture                      [[ texture(11), function_constant(use_ssao) ]]
                             
                             , depth2d<float> u_shadowTexture0                     [[ texture(12), function_constant(use_shadow0) ]]
                             , depth2d<float> u_shadowTexture1                     [[ texture(13), function_constant(use_shadow1) ]]
                             , depth2d<float> u_shadowTexture2                     [[ texture(14), function_constant(use_shadow2) ]]
                             , depth2d<float> u_shadowTexture3                     [[ texture(15), function_constant(use_shadow3) ]]
                             
                             
                             , texture2d<float> u_goboTexture0                     [[ texture(16), function_constant(use_gobo0) ]]
                             , texture2d<float> u_goboTexture1                     [[ texture(17), function_constant(use_gobo1) ]]
                             , texture2d<float> u_goboTexture2                     [[ texture(18), function_constant(use_gobo2) ]]
                             , texture2d<float> u_goboTexture3                     [[ texture(19), function_constant(use_gobo3) ]]
                             
                             
                             
                             
                             
                             , texture2d<float> u_iesTexture0                      [[ texture(16), function_constant(use_ies0) ]]
                             , texture2d<float> u_iesTexture1                      [[ texture(17), function_constant(use_ies1) ]]
                             , texture2d<float> u_iesTexture2                      [[ texture(18), function_constant(use_ies2) ]]
                             , texture2d<float> u_iesTexture3                      [[ texture(19), function_constant(use_ies3) ]]
                             
                             , texturecube<float> u_iesCubeTexture0                [[ texture(16), function_constant(use_iesCube0) ]]
                             , texturecube<float> u_iesCubeTexture1                [[ texture(17), function_constant(use_iesCube1) ]]
                             , texturecube<float> u_iesCubeTexture2                [[ texture(18), function_constant(use_iesCube2) ]]
                             , texturecube<float> u_iesCubeTexture3                [[ texture(19), function_constant(use_iesCube3) ]]
                             
                             , bool isFrontFacing                                  [[ front_facing, function_constant(use_double_sided) ]]
#ifdef USE_FRAGMENT_EXTRA_ARGUMENTS
__FragmentExtraArguments__
#endif
                             )
    
    
    scn_std_node in_node;
    if (use_instancing) {
        
        in_node = scn_nodes[0];
    } else {
        in_node = scn_node;
    }
    SCNShaderSurface _surface;
    float2 uv[kSCNTexcoordCount];
    switch (io_texcoord_count - 1) {
        case 7 : uv[7] = in.texcoord7;
        case 6 : uv[6] = in.texcoord6;
        case 5 : uv[5] = in.texcoord5;
        case 4 : uv[4] = in.texcoord4;
        case 3 : uv[3] = in.texcoord3;
        case 2 : uv[2] = in.texcoord2;
        case 1 : uv[1] = in.texcoord1;
        case 0 : uv[0] = in.texcoord0;
    }
    if (is_function_constant_defined(diffuse_texcoord_io_index))
        _surface.diffuseTexcoord = uv[diffuse_texcoord_io_index];
    
    if (is_function_constant_defined(normal_texcoord_io_index))
        _surface.normalTexcoord = uv[normal_texcoord_io_index];
    
    if (is_function_constant_defined(transparent_texcoord_io_index))
        _surface.transparentTexcoord = uv[transparent_texcoord_io_index];
    
    if (is_function_constant_defined(emission_texcoord_io_index))
        _surface.emissionTexcoord = uv[emission_texcoord_io_index];
    
    if (is_function_constant_defined(ambient_texcoord_io_index))
        _surface.ambientTexcoord = uv[ambient_texcoord_io_index];
    
    if (is_function_constant_defined(multiply_texcoord_io_index))
        _surface.multiplyTexcoord = uv[multiply_texcoord_io_index];
    
    if (is_function_constant_defined(specular_texcoord_io_index))
        _surface.specularTexcoord = uv[specular_texcoord_io_index];
    
    if (is_function_constant_defined(roughness_texcoord_io_index))
        _surface.roughnessTexcoord = uv[roughness_texcoord_io_index];
    if (is_function_constant_defined(metalness_texcoord_io_index))
        _surface.metalnessTexcoord = uv[metalness_texcoord_io_index];
    _surface.ambientOcclusion = 1.f; 
    if (use_ambient_map) {
        float4 c = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord);
        if (is_function_constant_defined(ambient_texture_component)) {
            c = c[ambient_texture_component];
        }
        
        if (use_ambient_as_ambientOcclusion) {
            _surface.ambientOcclusion = c.r;
            if (use_ambient_intensity)
                _surface.ambientOcclusion = saturate(mix(1.f, _surface.ambientOcclusion, scn_commonprofile.ambientIntensity));
        } else {
            _surface.ambient = c;
            if (use_ambient_intensity)
                _surface.ambient *= scn_commonprofile.ambientIntensity;
        }
    } else {
        _surface.ambient = scn_commonprofile.ambientColor;
    }
    if (use_ambient && use_io_vertex_color)
        _surface.ambient *= in.vertexColor;
    if (use_ssao)
        _surface.ambientOcclusion *= u_ssaoTexture.sample( linearSampler, in.fragmentPosition.xy * scn_frame.inverseResolution.xy ).x;
    
    if (use_diffuse_map) {
        _surface.diffuse = u_diffuseTexture.sample(u_diffuseTextureSampler, _surface.diffuseTexcoord);
        if (is_function_constant_defined(diffuse_texture_component))
            _surface.diffuse = _surface.diffuse[diffuse_texture_component];
        if (use_diffuse_intensity)
            _surface.diffuse.rgb *= scn_commonprofile.diffuseIntensity;
    } else {
        _surface.diffuse = scn_commonprofile.diffuseColor;
    }
    if (use_diffuse && use_io_vertex_color) {
        _surface.diffuse *= in.vertexColor;
    }
    
    if (use_specular_map) {
        _surface.specular = u_specularTexture.sample(u_specularTextureSampler, _surface.specularTexcoord);
        if (is_function_constant_defined(specular_texture_component))
            _surface.specular = _surface.specular[specular_texture_component];
        if (use_specular_intensity)
            _surface.specular *= scn_commonprofile.specularIntensity;
    } else {
        _surface.specular = scn_commonprofile.specularColor;
    }
    if (use_emission_map) {
        _surface.emission = u_emissionTexture.sample(u_emissionTextureSampler, _surface.emissionTexcoord);
        if (is_function_constant_defined(emission_texture_component))
            _surface.emission = float4(_surface.emission[emission_texture_component]);
        if (use_emission_intensity)
            _surface.emission *= scn_commonprofile.emissionIntensity;
    } else {
        _surface.emission = scn_commonprofile.emissionColor;
    }
    if (use_multiply_map) {
        _surface.multiply = u_multiplyTexture.sample(u_multiplyTextureSampler, _surface.multiplyTexcoord);
        if (is_function_constant_defined(multiply_texture_component))
            _surface.multiply = float4(_surface.multiply[multiply_texture_component]);
        if (use_multiply_intensity)
            _surface.multiply = mix(float4(1.f), _surface.multiply, scn_commonprofile.multiplyIntensity);
    } else {
        _surface.multiply = scn_commonprofile.multiplyColor;
    }
    
    if (use_transparent_map) {
        _surface.transparent = u_transparentTexture.sample(u_transparentTextureSampler, _surface.transparentTexcoord);
        if (is_function_constant_defined(transparent_texture_component))
            _surface.transparent = float4(_surface.transparent[transparent_texture_component]);
        if (use_transparent_intensity)
            _surface.transparent *= scn_commonprofile.transparentIntensity;
    } else {
        _surface.transparent = scn_commonprofile.transparentColor;
    }
    if (use_metalness_map) {
        float4 c = u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord);
        if (is_function_constant_defined(metalness_texture_component))
            _surface.metalness = c[metalness_texture_component];
        else 
            _surface.metalness = c.r;
        if (use_metalness_intensity)
            _surface.metalness *= scn_commonprofile.metalnessIntensity;
    } else {
        _surface.metalness = scn_commonprofile.metalness;
    }
    
    if (use_roughness_map) {
        float4 c = u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord).r;
        if (is_function_constant_defined(roughness_texture_component))
            _surface.roughness = c[roughness_texture_component];
        else 
            _surface.roughness = c.r;
        if (use_roughness_intensity)
            _surface.roughness *= scn_commonprofile.roughnessIntensity;
    } else {
        _surface.roughness = scn_commonprofile.roughness;
    }
    
    
    if (use_io_normal) {
        if (use_double_sided)
            _surface.geometryNormal = normalize(in.normal.xyz) * (in.normal.z >= 0.f ? 1.f : -1.f );
        else
            _surface.geometryNormal = normalize(in.normal.xyz);
        _surface.normal = _surface.geometryNormal;
    }
    if (need_tangent) {
        _surface.tangent = in.tangent;
        _surface.bitangent = in.bitangent;
    }
    if (use_io_position)
        _surface.position = in.position;
    if (use_io_view)
        _surface.view = normalize(-in.position);
    if (use_normal_map) {
        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.normal);
        _surface._normalTS = u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord).rgb;
        if (is_function_constant_defined(normal_texture_component)) { 
            _surface._normalTS.xy = _surface._normalTS.xy * 2.f - 1.f;
            _surface._normalTS.z = sqrt(1 - length_squared(_surface._normalTS.xy));
        } else {
            _surface._normalTS = _surface._normalTS * 2.f - 1.f;
        }
        if (use_normal_intensity)
            _surface._normalTS = mix(float3(0.f, 0.f, 1.f), _surface._normalTS, scn_commonprofile.normalIntensity);
        
        _surface.normal.rgb = normalize(ts2vs * _surface._normalTS);
    } else {
        _surface._normalTS = float3(0.f);
    }
    
    if (use_reflective_map) {
        
        float3 refl = reflect( -_surface.view, _surface.normal );
        float m = 2.f * sqrt( refl.x*refl.x + refl.y*refl.y + scn::sq(refl.z + 1.f));
        _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, float2(float2(refl.x,-refl.y) / m) + 0.5f);
        if (is_function_constant_defined(reflective_texture_component))
            _surface.reflective = _surface.reflective[reflective_texture_component];
        
        if (use_reflective_intensity)
            _surface.reflective *= scn_commonprofile.reflectiveIntensity;
    
    } else if (use_reflectivecube_map) {
    
        float3 refl = reflect( _surface.position, _surface.normal );
        _surface.reflective = u_reflectiveCubeTexture.sample(u_reflectiveCubeTextureSampler, scn::mat4_mult_float3(scn_frame.viewToCubeTransform, refl)); 
        if (is_function_constant_defined(reflective_texture_component))
            _surface.reflective = _surface.reflective[reflective_texture_component];
        
        if (use_reflective_intensity)
            _surface.reflective *= scn_commonprofile.reflectiveIntensity;
    
    } else {
        _surface.reflective = scn_commonprofile.reflectiveColor;
    }
    
    if (use_fresnel) {
        _surface.fresnel = scn_commonprofile.fresnel.x + scn_commonprofile.fresnel.y * pow(1.f - saturate(dot(_surface.view, _surface.normal)), scn_commonprofile.fresnel.z);
        _surface.reflective *= _surface.fresnel;
    }
    _surface.shininess = scn_commonprofile.materialShininess;
    
#ifdef USE_SURFACE_MODIFIER
__DoSurfaceModifier__
#endif
    SCNShaderLightingContribution _lightingContribution = {0};
    if (use_ambient_lighting)
        _lightingContribution.ambient = scn_frame.ambientLightingColor.rgb;
    
    if (use_lighting) {
        if (use_per_pixel_lighting) {
            _lightingContribution.diffuse = float3(0.f);
            if (use_modulate_lighting)
                _lightingContribution.modulate = float3(1.f);
            if (use_specular)
                _lightingContribution.specular = float3(0.f);
            
            if (is_function_constant_defined(use_light0)) {
                SCNLightingParameters params;
                params.surface = _surface;
                params.lightInfo = use_light0;
                params.lightData = scn_lights[ in_node.lightIndices[0] ];
                params.attenuation = float3(1.f);
                if (use_shadow0) scn_do_shadow(params, u_shadowTexture0, u_shadowKernel);
                if (use_gobo0)   scn_do_gobo(params, u_goboTexture0);
                if (use_ies0)    scn_do_ies(params, u_iesTexture0, linearSampler );
                if (use_iesCube0)    scn_do_ies(params, u_iesCubeTexture0, linearSampler );
                scn_do_light(params, _lightingContribution);
            }
            if (is_function_constant_defined(use_light1)) {
                SCNLightingParameters params;
                params.surface = _surface;
                params.lightInfo = use_light1;
                params.lightData = scn_lights[ in_node.lightIndices[1] ];
                params.attenuation = float3(1.f);
                if (use_shadow1) scn_do_shadow(params, u_shadowTexture1, u_shadowKernel);
                if (use_gobo1)   scn_do_gobo(params, u_goboTexture1);
                if (use_ies1)    scn_do_ies(params, u_iesTexture1, linearSampler );
                if (use_iesCube1)    scn_do_ies(params, u_iesCubeTexture1, linearSampler );
                scn_do_light(params, _lightingContribution);
            }
            if (is_function_constant_defined(use_light2)) {
                SCNLightingParameters params;
                params.surface = _surface;
                params.lightInfo = use_light2;
                params.lightData = scn_lights[ in_node.lightIndices[2] ];
                params.attenuation = float3(1.f);
                if (use_shadow2) scn_do_shadow(params, u_shadowTexture2, u_shadowKernel);
                if (use_gobo2)   scn_do_gobo(params, u_goboTexture2);
                if (use_ies2)    scn_do_ies(params, u_iesTexture2, linearSampler );
                if (use_iesCube2)    scn_do_ies(params, u_iesCubeTexture2, linearSampler );
                scn_do_light(params, _lightingContribution);
            }
            
            if (is_function_constant_defined(use_light3)) {
                SCNLightingParameters params;
                params.surface = _surface;
                params.lightInfo = use_light3;
                params.lightData = scn_lights[ in_node.lightIndices[3] ];
                params.attenuation = float3(1.f);
                if (use_shadow3) scn_do_shadow(params, u_shadowTexture3, u_shadowKernel);
                if (use_gobo3)   scn_do_gobo(params, u_goboTexture3);
                if (use_ies3)    scn_do_ies(params, u_iesTexture3, linearSampler );
                if (use_iesCube3)    scn_do_ies(params, u_iesCubeTexture3, linearSampler );
                scn_do_light(params, _lightingContribution);
            }
            
        } else { 
            _lightingContribution.diffuse = in.diffuse;
            if (use_specular)
                _lightingContribution.specular = in.specular;
        }
        if (avoid_overlighting) {
            _lightingContribution.diffuse = saturate(_lightingContribution.diffuse);
            if (use_specular)
                _lightingContribution.specular = saturate(_lightingContribution.specular);
        }
    } else { 
        _lightingContribution.diffuse = float3(1.f);
    }
    
    
    SCNOutput _output;
    if (use_pbr) {
        SCNPBRSurface pbr_surface = SCNShaderSurfaceToSCNPBRSurface(_surface);
        pbr_surface.selfIlluminationOcclusion = scn_commonprofile.selfIlluminationOcclusion;
        if (use_probes_lighting) {
            _output.color = scn_pbr_combine_probes(pbr_surface, _lightingContribution, u_specularDFGTexture, u_radianceTexture, scn_shCoefficients, scn_frame);
        } else {
            _output.color = scn_pbr_combine_cubemap(pbr_surface, _lightingContribution, u_specularDFGTexture, u_radianceTexture, u_irradianceTexture, scn_frame);
        }
        _output.color.a = _surface.diffuse.a;
    } else {
        _output.color = illuminate(_surface, _lightingContribution);
    }
    
    if (use_fog) {
        float fogFactor = pow(clamp(length(_surface.position.xyz) * scn_frame.fogParameters.x + scn_frame.fogParameters.y, 0., scn_frame.fogColor.a), scn_frame.fogParameters.z);
        _output.color.rgb = mix(_output.color.rgb, scn_frame.fogColor.rgb * _output.color.a, fogFactor);
    }
    if (!diffuse_premultiplied)
        _output.color.rgb *= _surface.diffuse.a;
    float nodeOpacity = use_node_opacity ? in_node.nodeOpacity : 1.f;
    if (use_transparent) {
        if (use_transparency)
            _surface.transparent *= scn_commonprofile.transparency;
        
        if (use_transparency_rgbzero) {
            
            _surface.transparent.a = (_surface.transparent.r * 0.212671f) + (_surface.transparent.g * 0.715160f) + (_surface.transparent.b * 0.072169f);
            _output.color *= nodeOpacity * (float4(1.f) - _surface.transparent);
        } else { 
            _output.color *= (nodeOpacity * _surface.transparent.a);
        }
    } else {
        if (use_transparency) { 
            _output.color *= (nodeOpacity * scn_commonprofile.transparency);
        }
    }
    
#ifdef USE_FRAGMENT_MODIFIER
__DoFragmentModifier__
#endif
    
    
    if (use_discard && _output.color.a == 0.) 
        discard_fragment();
    return half4(_output.color);
static int OsdGetPatchNumControlVertices(int patchType) {
    switch(patchType) {
        case 3: return 4;
        case 6: return 16;
        case 9: return 20;
        default: return 0;
    }
#if OSD_IS_ADAPTIVE
#if USE_STAGE_IN
#if OSD_PATCH_REGULAR
struct ControlPoint
    
    float3 P [[attribute(0)]];
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    float3 P1 [[attribute(1)]];
    float3 P2 [[attribute(2)]];
#if !USE_PTVS_SHARPNESS
    float2 vSegments [[attribute(3)]];
#endif 
#endif 
struct PatchInput
    patch_control_point<ControlPoint> cv;
#if !USE_PTVS_FACTORS
    float4 tessOuterLo [[attribute(5)]];
    float4 tessOuterHi [[attribute(6)]];
#endif 
    int3 patchParam [[attribute(10)]];
#elif OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY
struct ControlPoint
    
    float3 P [[attribute(0)]];
    float3 Ep [[attribute(1)]];
    float3 Em [[attribute(2)]];
    float3 Fp [[attribute(3)]];
    float3 Fm [[attribute(4)]];
struct PatchInput
    patch_control_point<ControlPoint> cv;
    int3 patchParam [[attribute(10)]];
#elif OSD_PATCH_GREGORY_BASIS
struct ControlPoint
    float3 position [[attribute(0)]];
struct PatchInput
    patch_control_point<ControlPoint> cv;
    int3 patchParam [[attribute(10)]];
#endif
#endif 
#endif 
#if defined(OSD_FVAR_WIDTH)
static void OsdInterpolateFaceVarings(thread SCNShaderGeometry&      geometry
                                      , float2                       uv
                                      , int                          patchIndex
#if OSD_FVAR_USES_MULTIPLE_CHANNELS
                                      , constant uint32_t&           osdFaceVaryingChannelCount
                                      , constant OsdFVarChannelDesc* osdFaceVaryingChannelDescriptors
                                      , constant uint32_t&           osdFaceVaryingPatchArrayIndex
                                      , constant void*               osdFaceVaryingChannelsPackedData
#else 
                                      , constant int*                osdFaceVaryingIndices
                                      , constant float*              osdFaceVaryingData
#if OSD_IS_ADAPTIVE
                                      , constant packed_int3*        osdFaceVaryingPatchParams
                                      , constant packed_int4&        osdFaceVaryingPatchArray
#endif
#endif 
                                      )
#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[0] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[1] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[2] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[3] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[4] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[5] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[6] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[7] = float2(0.0);
#endif
#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.color = float4(0.0);
#endif
    
#if OSD_FVAR_USES_MULTIPLE_CHANNELS
    for (uint32_t channel = 0; channel < osdFaceVaryingChannelCount; ++channel) {
        OsdFVarChannelDesc channelDescriptor = osdFaceVaryingChannelDescriptors[channel];
        
        int4 osdFaceVaryingPatchArray = ((constant packed_int4 *)((constant uint8_t *)osdFaceVaryingChannelsPackedData + channelDescriptor.patchArraysBufferOffset))[osdFaceVaryingPatchArrayIndex];
        int indexBase = osdFaceVaryingPatchArray.z;
        
        constant int *osdFaceVaryingIndices = (constant int *)((constant uint8_t *)osdFaceVaryingChannelsPackedData + channelDescriptor.indicesBufferOffset) + indexBase * 3;
        constant float *osdFaceVaryingData = (constant float *)((constant uint8_t *)osdFaceVaryingChannelsPackedData + channelDescriptor.dataBufferOffset);
        
#if OSD_IS_ADAPTIVE
        int primitiveIdBase = osdFaceVaryingPatchArray.w;
        constant packed_int3 *osdFaceVaryingPatchParams = (constant packed_int3 *)((constant uint8_t *)osdFaceVaryingChannelsPackedData + channelDescriptor.patchParamsBufferOffset) + primitiveIdBase;
        
        int3 fvarPatchParam = osdFaceVaryingPatchParams[patchIndex];
        bool isRegular = OsdGetPatchIsRegular(fvarPatchParam);
        
        int4 patchArray = osdFaceVaryingPatchArray;
        int patchStride = OsdGetPatchNumControlVertices(patchArray.x);
        int patchType = select(patchArray.x, int(6), isRegular);
        int patchCVs = OsdGetPatchNumControlVertices(patchType);
        
        float wP[20], wDs[20], wDt[20], wDss[20], wDst[20], wDtt[20];
        
        if (patchType == 3) {
            OsdGetBilinearPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
        } else if (patchType == 6) {
            int boundaryMask = OsdGetPatchBoundaryMask(fvarPatchParam);
            OsdGetBSplinePatchWeights(uv.x, uv.y, 1.0f, boundaryMask, wP, wDs, wDt, wDss, wDst, wDtt);
        } else if (patchType == 9) {
            OsdGetGregoryPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
        }
#else
        float wP[4], wDs[4], wDt[4], wDss[4], wDst[4], wDtt[4];
        int patchCVs = 4;
        int patchStride = patchCVs;
        OsdGetBilinearPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
#endif
        
        for (int i = 0; i < patchCVs; ++i) {
#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.colorPrimvar.isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.colorPrimvar.offset;
                geometry.color += wP[i] * float4(osdFaceVaryingData[index], osdFaceVaryingData[index+1], osdFaceVaryingData[index+2], osdFaceVaryingData[index+3]);
            }
#endif
#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[0].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[0].offset;
                geometry.texcoords[0] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[1].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[1].offset;
                geometry.texcoords[1] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[2].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[2].offset;
                geometry.texcoords[2] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[3].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[3].offset;
                geometry.texcoords[3] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[4].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[4].offset;
                geometry.texcoords[4] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[5].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[5].offset;
                geometry.texcoords[5] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[6].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[6].offset;
                geometry.texcoords[6] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
            if (channelDescriptor.texcoordPrimvars[7].isUsed) {
                int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * channelDescriptor.dataBufferFVarWidth + channelDescriptor.texcoordPrimvars[7].offset;
                geometry.texcoords[7] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
            }
#endif
        }
    }
    
#else 
    
#if OSD_IS_ADAPTIVE
    int3 fvarPatchParam = osdFaceVaryingPatchParams[patchIndex];
    bool isRegular = OsdGetPatchIsRegular(fvarPatchParam);
    
    int4 patchArray = osdFaceVaryingPatchArray;
    int patchStride = OsdGetPatchNumControlVertices(patchArray.x);
    int patchType = select(patchArray.x, int(6), isRegular);
    int patchCVs = OsdGetPatchNumControlVertices(patchType);
    
    float wP[20], wDs[20], wDt[20], wDss[20], wDst[20], wDtt[20];
    
    if (patchType == 3) {
        OsdGetBilinearPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
    } else if (patchType == 6) {
        int boundaryMask = OsdGetPatchBoundaryMask(fvarPatchParam);
        OsdGetBSplinePatchWeights(uv.x, uv.y, 1.0f, boundaryMask, wP, wDs, wDt, wDss, wDst, wDtt);
    } else if (patchType == 9) {
        OsdGetGregoryPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
    }
#else
    float wP[4], wDs[4], wDt[4], wDss[4], wDst[4], wDtt[4];
    int patchCVs = 4;
    int patchStride = patchCVs;
    OsdGetBilinearPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
#endif
    
    for (int i = 0; i < patchCVs; ++i) {
        int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * OSD_FVAR_WIDTH + 0 ;
#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.color += wP[i] * float4(osdFaceVaryingData[index], osdFaceVaryingData[index+1], osdFaceVaryingData[index+2], osdFaceVaryingData[index+3]);
        index += 4;
#endif
#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[0] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[1] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[2] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[3] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[4] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[5] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[6] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[7] += wP[i] * float2(osdFaceVaryingData[index], osdFaceVaryingData[index+1]);
        index += 2;
#endif
    }
#endif 
#endif 
#import <metal_stdlib>
using namespace metal;
struct sh2_coefficients
    float4 R;
    float4 G;
    float4 B;
struct sh3_coefficients
    float4 ar;
    float4 ag;
    float4 ab;
    float4 br;
    float4 bg;
    float4 bb;
    float4 c;
struct SCNPBRSurface {
    float3 n;
    float3 v;
    
    float3 albedo;
    float3 emission;
    float3 selfIllumination;
    float  metalness;
    float  roughness;
    float  ao;
    float  selfIlluminationOcclusion;
#define PBR_F0_NON_METALLIC 0.04f
#define PBR_MIN_ROUGHNESS 0.01
#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)
inline float3 shEvalDirection(float4 dir, sh2_coefficients cachedSH)
    const float Exponent = 1;
    
    
    sh2_vector diffSH = sh2_compute_diffuse_transfer(half3(dir.xyz), Exponent);
    
    
    half3 lighting = max(half3(0,0,0), sh2_dot(cachedSH, diffSH)) * M_1_PI_F;
    
    
    
    return float3(lighting);
#endif
inline float3 shEvalDirection(float4 dir, sh3_coefficients sh)
    float3 x1, x2, x3;
    
    
    x1.r = dot(sh.ar, dir);
    x1.g = dot(sh.ag, dir);
    x1.b = dot(sh.ab, dir);
    
    
    float4 vB = dir.xyzz * dir.yzzx;
    x2.r = dot(sh.br, vB);
    x2.g = dot(sh.bg, vB);
    x2.b = dot(sh.bb, vB);
    
    
    float vC = dir.x * dir.x - dir.y * dir.y;
    x3 = sh.c.xyz * vC;
    
    return x1 + x2 + x3;
inline float scn_radicalInverse(uint32_t bits) {
#if __METAL_VERSION__ >= 210
    bits = reverse_bits(bits);
#else
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
#endif
    return float(bits) * 0x1p-32;
inline float scn_filteredAlphaFromRoughness(float3 N, float roughness)
    float3 dNdx = dfdx(N);
    float3 dNdy = dfdy(N);
#if 1
    constexpr half sigma2 = 0.5h * 0.5h;
#else
    constexpr half sigma2 = 0.15915494h;
#endif
    constexpr half kappa = 0.18h;
    half variance = (half)sigma2 * (dot(dNdx, dNdx) + dot(dNdy, dNdy));
    half kernelAlphaSquared = min(variance, kappa);
    half alpha = roughness * roughness;
    half filteredAlphaSquared = saturate(alpha * alpha + kernelAlphaSquared);
    return sqrt(filteredAlphaSquared);
inline float3 scn_tangentSpaceToLocalSpace(float3 v, float3 normal) {
    float3 tangent,bitangent;
    scn::generate_basis(normal, &tangent, &bitangent);
    
    return tangent * v.x + bitangent * v.y + normal * v.z;
inline float2 scn_sampleHammersley(uint32_t i, uint sampleCount) {
    return float2(float(i) / sampleCount, scn_radicalInverse(i));
static float3 scn_importanceSampleGGX_brdf(float2 random, float alpha) __attribute__((overloadable)) {
    
    
    float cosTheta = sqrt((1.0 - random.x) / (1.0 + (alpha * alpha - 1.0) * random.x));
    float phi = 2.0 * M_PI_F * random.y;
    
    
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    return float3(sinTheta * cos(phi),
                  sinTheta * sin(phi),
                  cosTheta);
static float3 scn_importanceSampleGGX_brdf(float2 random, float alpha, float3 n) __attribute__((overloadable)) {
    float3 importanceSampleGGX = scn_importanceSampleGGX_brdf(random, alpha);
    return scn_tangentSpaceToLocalSpace(importanceSampleGGX, n);
static float3 scn_importanceSampleCosine_brdf(float2 random) __attribute__((overloadable)) {
    
    
    
    float r = sqrt(random.x);
    float phi = 2.0 * M_PI_F * random.y;
    
    float cosPhi;
    float sinPhi = sincos(phi, cosPhi);
    
    
    float x = r * cosPhi;
    float y = r * sinPhi;
    float z = sqrt(max(0.f, 1.f - random.x)); 
    return float3(x, y, z);
static float3 scn_importanceSampleCosine_brdf(float2 random, float3 n) __attribute__((overloadable)) {
    float3 importanceSampleCosine = scn_importanceSampleCosine_brdf(random);
    return scn_tangentSpaceToLocalSpace(importanceSampleCosine, n);
inline float scn_brdf_D(float alpha, float NoH) {
    float alpha_squared = alpha * alpha;
    float denom = (NoH * alpha_squared - NoH) * NoH + 1.0f;
    float denom_squared = denom * denom;
    return alpha_squared / (denom_squared * M_PI_F);
inline float3 scn_brdf_F(float3 F0, float LoH) {
    return F0 + (1.f - F0) * pow(1.f - LoH, 5.f);
inline float3 scn_brdf_F_opt(float3 F0, float LoH) {
    float inv_LoH = 1.f - LoH;
    float inv_LoH_pow_2 = inv_LoH * inv_LoH;
    float inv_LoH_pow_5 = inv_LoH_pow_2 * inv_LoH_pow_2 * inv_LoH;
    return F0 + (1.f - F0) * inv_LoH_pow_5;
inline float scn_brdf_GLambda(float alpha2, float NoL) {
    float NoL2 = NoL * NoL;
    float t = (1.0f - NoL2) * alpha2 / NoL2;
    return 0.5f * (-1.0f + sqrt(1.0f + t));
inline float scn_brdf_G(float alpha, float NoL, float NoV) {
    float alpha2 = alpha * alpha;
    float lambdaL = scn_brdf_GLambda(alpha2, NoL);
    float lambdaV = scn_brdf_GLambda(alpha2, NoV);
    return 1.f / (1.f + lambdaL + lambdaV);
inline float scn_brdf_V(float alpha, float NoL, float NoV) {
    float alpha_squared = alpha * alpha;
    float NoL_squared = NoL * NoL;
    float NoV_squared = NoV * NoV;
    float lambda_L = NoV * sqrt(NoL_squared + alpha_squared * (1.0f - NoL_squared));
    float lambda_V = NoL * sqrt(NoV_squared + alpha_squared * (1.0f - NoV_squared));
    return 0.5f / (lambda_L + lambda_V + 1e-6f);
inline float scn_brdf_V_opt(float alpha, float LoH) {
    float k = alpha * 0.5f;
    float k2 = k * k;
    float invK2 = 1.f - k2;
    return 1.f / (LoH * LoH * invK2 + k2);
static float2 scn_computeHammonFactors(float NdotL, float NdotH, float NdotV, float LdotV, float alpha)
    
    
    
    
    
    
    
    
    
    float facing = 0.5f + 0.5f * LdotV;
    float rough = facing * (0.9f - 0.4f * facing) * (0.5f + NdotH) / NdotH;
    float smooth = 1.05f * (1.0f - pow(1.0f - NdotL, 5.f)) * (1.0f - pow(1.0f - NdotV, 5.f));
    float single = mix(smooth, rough, alpha);
    float multi = M_PI_F * 0.1159f * alpha;
    return float2(single, multi);
inline float4 scn_specularDFG_diffuseHammon(float NoV,
                                            float roughness)
    
    
    float3 v = float3(sqrt(1.0 - NoV * NoV),
                      0.0,
                      NoV);
    
    float alpha = roughness * roughness; 
    
    float2 specularDFG = float2(0.0);
    float2 diffuseHammonFactors = float2(0.0);
    
    int const sampleCount = 1024;
    for (int i = 0; i < sampleCount; ++i) {
        float2 random = scn_sampleHammersley(i, sampleCount);
        
        
        float3 h = scn_importanceSampleGGX_brdf(random, alpha); 
        float3 l = reflect(-v, h); 
        
        float NoL = saturate(l.z); 
        float NoH = saturate(h.z); 
        float LoH = saturate(dot(l, h));
        
        if (NoL > 0.f) {
            float G = scn_brdf_G(alpha, NoL, NoV);
            float GVis = G * LoH / (NoH * NoV);
            float Fc = pow(1.f - LoH, 5.f);
            specularDFG.x += (1.f - Fc) * GVis;
            specularDFG.y += Fc * GVis;
        }
        
        
        float3 Ld = scn_importanceSampleCosine_brdf(random); 
        float NoLd = saturate(Ld.z);
        if (NoLd > 0.f) {
            float3 Hd = normalize(v + Ld);
            float NoHd = Hd.z;
            
            float LoVd = saturate(dot(Ld, v));
            float2 HF = scn_computeHammonFactors(NoLd, NoHd, NoV, LoVd, alpha);
            diffuseHammonFactors.x += HF.x;
            diffuseHammonFactors.y += HF.y;
        }
    }
    
    return float4(specularDFG.x, specularDFG.y, diffuseHammonFactors.x, diffuseHammonFactors.y) / sampleCount;
inline float3 scn_irradiance_cube(texturecube<float, access::sample> environment,
                                  uint                               environmentMipmapLevel,
                                  float3                             n_cube)
    float3 n = float3(n_cube.x, -n_cube.z, n_cube.y);
    
    constexpr sampler linearSampler(filter::linear);
    
    float3 L = float3(0.0);
    float weight = 0.0f;
    
    ushort const sampleCount = 1024;
    for (ushort i = 0; i < sampleCount; ++i) {
        float2 random = scn_sampleHammersley(i, sampleCount);
        float3 l = scn_importanceSampleCosine_brdf(random, n); 
        
        float NoL = saturate(dot(n, l));
        if (NoL > 0) {
            float3 Li = environment.sample(linearSampler, float3(l.x , l.z, -l.y), level(environmentMipmapLevel)).rgb;
            L += Li; 
            weight += 1.0;
        }
    }
    
    return L / weight;
inline float scn_pbr_distanceAttenuation(float3 lightVector)
    float sqrDist = dot(lightVector, lightVector);
    return 1. / max(sqrDist, 0.0001);
inline float3 scn_pbr_reference_world(SCNPBRSurface                      surface,
                                      texturecube<float, access::sample> environment,
                                      uint                               environmentSamplingLevel,
                                      float4x4                           localDirToWorldCubemapDir,
                                      float                              environmentIntensity)
    constexpr sampler linearSampler(filter::linear, mip_filter::linear);
    
    float3 n = surface.n;
    float3 v = surface.v;
    float3 albedo = surface.albedo;
    float metalness = surface.metalness;
    float roughness = surface.roughness;
    float ambientOcclusion = surface.ao;
    
    float NoV = saturate(dot(n, v));
    
    float3 effectiveAlbedo = mix(albedo, float3(0.0), metalness);
    float3 reflectance = mix(float3(PBR_F0_NON_METALLIC), albedo, metalness);
    
    
    float3 irradiance = float3(0.0);
    
    ushort const sampleCountDiffuse = 1024;
    for (ushort i = 0; i < sampleCountDiffuse; ++i) {
        float2 random = scn_sampleHammersley(i, sampleCountDiffuse);
        float3 l = scn_importanceSampleCosine_brdf(random, n); 
        
        float NoL = saturate(dot(n, l));
        
        if (NoL > 0) {
            float3 Li = environment.sample(linearSampler, scn::mat4_mult_float3(localDirToWorldCubemapDir, l), level(environmentSamplingLevel)).rgb * environmentIntensity;
            irradiance += Li; 
        }
    }
    
    irradiance = irradiance / float(sampleCountDiffuse);
    
    
    float3 specular = float3(0.0);
    float specularWeight = 0.0;
    
    float correctedRoughness = mix(1.0f / 128.0f, 1.0f - 1.0f / 128.0f, roughness);
    float alpha = correctedRoughness * correctedRoughness; 
    
    ushort const sampleCountSpecular = 128;
    for (ushort i = 0; i < sampleCountSpecular; ++i) {
        float2 random = scn_sampleHammersley(i, sampleCountSpecular);
        float3 h = scn_importanceSampleGGX_brdf(random, correctedRoughness, n); 
        float3 l = reflect(-v, h); 
        
        float NoL = saturate(dot(n, l));
        float NoH = saturate(dot(n, h));
        float LoH = saturate(dot(l, h));
        
        if (NoH * NoV > 0) {
            float3 Li = environment.sample(linearSampler, scn::mat4_mult_float3(localDirToWorldCubemapDir, l), level(environmentSamplingLevel)).rgb * environmentIntensity;
            float3 F = scn_brdf_F(reflectance, LoH);
            float G = scn_brdf_G(alpha, NoL, NoV);
#if 0
            float D = scn_brdf_D(alpha, NoH);
            float pdf = (D * NoH) / (4.0f * LoH);
            
            if (pdf >= 0) {
                float3 l = D * F * G / (4.0f * NoV); 
                specular += Li * l / pdf;
                specularWeight += 1.0f;
            }
#else
            specular += Li * F * G * LoH / (NoH * NoV);
            specularWeight += 1.0f;
#endif
        }
    }
    
    specular /= specularWeight;
    
    
    return ambientOcclusion * (effectiveAlbedo * irradiance + specular);
inline float3x3 scn_ltc_matrix_invert_transpose(float3x3 m)
    float a = m[0][0];
    float b = m[1][0];
    float c = m[0][1];
    float d = m[1][1];
    float det = a * d - b * c;
    m[0][0] = +det * d;
    m[1][0] = -det * b;
    m[1][0] = -det * c;
    m[1][1] = +det * a;
    m[2][2] = 1.f / m[2][2];
    return m;
inline float3x3 scn_sample_area_light_precomputed_data(float3                 v,
                                                       float3                 n,
                                                       float                  roughness,
                                                       thread float*          brdfNorm,
                                                       texture2d_array<float> bakedDataTexture)
    constexpr sampler linearSampler = sampler(address::clamp_to_edge, filter::linear);
    
    float theta = acos(fabs(dot(n, v)));
    float2 uv = float2(roughness, theta * M_2_PI_F);
    
    float4 dataA = bakedDataTexture.sample(linearSampler, uv, 0);
    float4 dataB = bakedDataTexture.sample(linearSampler, uv, 1);
    
    *brdfNorm = dataB.y;
    
    return float3x3(float3(dataA.x, dataA.y, 0.f),
                    float3(dataA.z, dataA.w, 0.f),
                    float3(0.f, 0.f, dataB.x));
inline float3 scn_area_light_polygon_edge_vector_form_factor(float3 cornerDirectionA,
                                                             float3 cornerDirectionB)
    
    
    
#if 0
    float theta = acos(dot(cornerDirectionA, cornerDirectionB));
    return (0.5f * M_1_PI_F) * cross(cornerDirectionA, cornerDirectionB) * ((theta > 0.001) ? theta/sin(theta) : 1.0);
#else
    float x = dot(cornerDirectionA, cornerDirectionB);
    float y = abs(x);
    
    float a = 5.42031f + (3.12829f + 0.0902326 * y) * y;
    float b = 3.45068f + (4.18814f + y) * y;
    float thetaOverSinTheta = a / b;
    
    if (x < 0.f)
        thetaOverSinTheta = M_PI_F * rsqrt(1.f - x * x) - thetaOverSinTheta;
    
    float3 u = cross(cornerDirectionA, cornerDirectionB);
    return (0.5f * M_1_PI_F) * thetaOverSinTheta * u;
#endif
inline float scn_area_light_horizon_clipped_sphere_form_factor_from_polygon_vector_form_factor(float3 vectorFormFactor)
#if 1
    
    float l = length(vectorFormFactor);
    return max((l * l + vectorFormFactor.y) / (l + 1.f), 0.f);
#else
    
    return max(vectorFormFactor.y, 0.f);
#endif
inline float pbr_area_light_eval_rectangle(float4x3 corners)
    
    
    
    float3 corner0 = normalize(corners[0]);
    float3 corner1 = normalize(corners[1]);
    float3 corner2 = normalize(corners[2]);
    float3 corner3 = normalize(corners[3]);
    
    float3 vectorFormFactor = float3(0.f);
    vectorFormFactor += scn_area_light_polygon_edge_vector_form_factor(corner0, corner1);
    vectorFormFactor += scn_area_light_polygon_edge_vector_form_factor(corner1, corner2);
    vectorFormFactor += scn_area_light_polygon_edge_vector_form_factor(corner2, corner3);
    vectorFormFactor += scn_area_light_polygon_edge_vector_form_factor(corner3, corner0);
    
    return scn_area_light_horizon_clipped_sphere_form_factor_from_polygon_vector_form_factor(vectorFormFactor);
inline float pbr_area_light_eval_polygon(float3                position,
                                         float3                lightCenter,
                                         float3                lightRight,
                                         float3                lightTop,
                                         uint32_t              vertexCount,
                                         device packed_float2 *vertexPositions)
    
    
    
    float3 vectorFormFactor = float3(0.f);
    for (uint32_t vertexIndex = 0; vertexIndex < vertexCount; ++vertexIndex) {
        packed_float2 localCorner0 = vertexPositions[vertexIndex];
        packed_float2 localCorner1 = vertexPositions[(vertexIndex + 1) % vertexCount];
        
        
        
        float3 cornerDirection0 = lightCenter - localCorner0[0] * lightRight + localCorner0[1] * lightTop;
        float3 cornerDirection1 = lightCenter - localCorner1[0] * lightRight + localCorner1[1] * lightTop;
        
        float3 corner0 = normalize(cornerDirection0 - position);
        float3 corner1 = normalize(cornerDirection1 - position);
        
        vectorFormFactor += scn_area_light_polygon_edge_vector_form_factor(corner0, corner1);
    }
    
    return scn_area_light_horizon_clipped_sphere_form_factor_from_polygon_vector_form_factor(vectorFormFactor);
inline float pbr_area_light_line_integral_position(float d, float l) {
    float d_squared = d * d;
    float l_squared = l * l;
    return l / (d * (d_squared + l_squared)) + atan(l / d) / d_squared;
inline float pbr_area_light_line_integral_direction(float d, float l) {
    float d_squared = d * d;
    float l_squared = l * l;
    return l_squared / (d * (d_squared + l_squared));
inline float pbr_area_light_eval_line(float2x3 cornerDirections)
    
    
    
    float3 corner0 = normalize(cornerDirections[0]);
    float3 corner1 = normalize(cornerDirections[1]);
    
    float3 direction = normalize(corner1 - corner0);
    
    if (corner0.y <= 0.f && corner1.y <= 0.f) return 0.f;
    if (corner0.y < 0.f) corner0 = (+corner0 * corner1.y - corner1 * corner0.y) / (+corner1.y - corner0.y);
    if (corner1.y < 0.f) corner1 = (-corner0 * corner1.y + corner1 * corner0.y) / (-corner1.y + corner0.y);
    
    float l1 = dot(corner0, direction);
    float l2 = dot(corner1, direction);
    
    float3 position = corner0 - l1 * direction;
    float d = length(position);
    
    float I = (pbr_area_light_line_integral_position(d, l2) - pbr_area_light_line_integral_position(d, l1)) * position.y
            + (pbr_area_light_line_integral_direction(d, l2) - pbr_area_light_line_integral_direction(d, l1)) * direction.y;
    
    return M_1_PI_F * I;
#ifndef __SCNMetalDefines__
#define __SCNMetalDefines__
enum {
    SCNVertexSemanticPosition,
    SCNVertexSemanticNormal,
    SCNVertexSemanticTangent,
    SCNVertexSemanticColor,
    SCNVertexSemanticBoneIndices,
    SCNVertexSemanticBoneWeights,
    SCNVertexSemanticTexcoord0,
    SCNVertexSemanticTexcoord1,
    SCNVertexSemanticTexcoord2,
    SCNVertexSemanticTexcoord3,
    SCNVertexSemanticTexcoord4,
    SCNVertexSemanticTexcoord5,
    SCNVertexSemanticTexcoord6,
    SCNVertexSemanticTexcoord7
struct SCNSceneBuffer {
    float4x4    viewTransform;
    float4x4    inverseViewTransform; 
    float4x4    projectionTransform;
    float4x4    viewProjectionTransform;
    float4x4    viewToCubeTransform; 
    float4x4    lastFrameViewProjectionTransform;
    float4      ambientLightingColor;
    float4
fogColor;
    float3
fogParameters; 
    float2      inverseResolution;
    float       time;
    float       sinTime;
    float       cosTime;
    float       random01;
    float       motionBlurIntensity;
    
    float       environmentIntensity;
    float4x4    inverseProjectionTransform;
    float4x4    inverseViewProjectionTransform;
    
    float2      nearFar; 
    float4      viewportSize; 
    
    float4x4    inverseTransposeViewTransform;
    
    float4      clusterScale; 
#endif 
struct OsdFVarPrimvar {
    uint8_t isUsed;
    uint8_t offset;
struct OsdFVarChannelDesc {
    uint32_t indicesBufferOffset;
    uint32_t dataBufferOffset;
    uint32_t dataBufferFVarWidth;
    uint32_t patchParamsBufferOffset;
    uint32_t patchArraysBufferOffset;
    OsdFVarPrimvar colorPrimvar;
    OsdFVarPrimvar texcoordPrimvars[8];
enum {
    SCNDeformerAttributeSrcPosition,
    SCNDeformerAttributeSrcNormal,
    SCNDeformerAttributeSrcTangent,
    
    SCNDeformerAttributeDstPosition,
    SCNDeformerAttributeDstNormal,
    SCNDeformerAttributeDstTangent,
    
    SCNDeformerAttributeCount
  struct scn_floor {
    float4 u_floor_viewport;
    float u_floorReflectivity;
#ifdef USE_FALLOFF
    float4x4 u_floorMVP_i;
    float4 u_floorPlane;
    float u_floorFalloff;
#ifdef USE_FALLOFF_START
    float u_floorFalloffStart;
#endif
#endif
static inline float3 floorUnprojectPoint(float3 screenPos, float4x4 mvp_i)
    float4 pTmp = mvp_i * float4(screenPos.xy * 2.0 - 1.0, screenPos.z, 1.0);
    return pTmp.xyz / pTmp.w;
#pragma arguments
scn_floor scn_floorSurf
texture2d_layer u_floorReflectionColor;
depth2d u_floorReflectionDepth;
#pragma body
float2 normalizedFragCoord =  scn_floorSurf.u_floor_viewport.xy + in.fragmentPosition.xy * scn_floorSurf.u_floor_viewport.zw;
normalizedFragCoord.xy += 0.2 * _surface._normalTS.xy;
constexpr sampler linear_sampler(filter::linear);
float4 floorColor = u_floorReflectionColor.sampleLayer(linear_sampler, normalizedFragCoord);
float reflectionFactor = scn_floorSurf.u_floorReflectivity;
#ifdef USE_FALLOFF
float floorDepth = u_floorReflectionDepth.sample(linear_sampler, normalizedFragCoord);
float3  floorPW = floorUnprojectPoint(float3(normalizedFragCoord.x, 1. - normalizedFragCoord.y, floorDepth), scn_floorSurf.u_floorMVP_i);
float floorDist = -dot(floorPW.xyz, scn_floorSurf.u_floorPlane.xyz) - scn_floorSurf.u_floorPlane.w;;
#ifdef USE_FALLOFF_START
floorDist -= scn_floorSurf.u_floorFalloffStart; 
#endif 
reflectionFactor *= 1.0 - clamp(floorDist / scn_floorSurf.u_floorFalloff, 0.0, 1.0);
#endif 
floorColor *= reflectionFactor; 
_output.color.rgb *= (1. - floorColor.a); 
_output.color.rgba += floorColor.rgba; 
C3DShaderModifier
view
normalTexcoord
ambientTexcoord
diffuseTexcoord
specularTexcoord
emissionTexcoord
selfIlluminationTexcoord
multiplyTexcoord
transparentTexcoord
displacementTexcoord
clearCoatTexcoord
clearCoatRoughnessTexcoord
clearCoatNormalTexcoord
fresnel
_surface.%@
_geometry.normal
_geometry.tangent
_geometry.color
_geometry.clipDistance0
_geometry.clipDistance1
_geometry.clipDistance2
_geometry.clipDistance3
_framebuffer
_framebuffer.color
USE_MODIFIER_FRAMEBUFFER
iModifier
<C3DShaderModifier %p language:%s, entryPoint:"%d" flags:%x
Metal
GLSL
  declaration : %@
  arguments : %@
  varyings : %@
  code : %@
newDefines
USE_EMISSIVETEXCOORD
USE_AMBIENTTEXCOORD
USE_DIFFUSETEXCOORD
USE_SPECULARTEXCOORD
USE_REFLECTIVETEXCOORD
USE_TRANSPARENTTEXCOORD
USE_FILTERTEXCOORD
USE_NORMALTEXCOORD
USE_METALNESSTEXCOORD
USE_ROUGHNESSTEXCOORD
USE_CLEARCOATTEXCOORD
USE_CLEARCOATROUGHNESSTEXCOORD
USE_CLEARCOATNORMALTEXCOORD
_geometry.texcoords[x]
u_%@TextureMatrix
{_SCNVector4=dddd}
{_SCNVector3=ddd}
is%@%@
v@:^v
^v@:
v@:f
v@:i
v@:B
v@:c
v@:d
v@:{CGPoint=dd}
{CGPoint=dd}@:
v@:{SCNVector3=ddd}
{SCNVector3=ddd}@:
v@:{SCNVector4=dddd}
{SCNVector4=dddd}@:
v@:{SCNMatrix4=dddddddddddddddd}
{SCNMatrix4=dddddddddddddddd}@:
v@:{CATransform3D=dddddddddddddddd}
{CATransform3D=dddddddddddddddd}@:
v@:{C3DMatrix3x3=ddddddddd}
{C3DMatrix3x3=ddddddddd}@:
v@:{C3DColor4=ffff}
{C3DColor4=ffff}@:
v@:s
v@:C
v@:S
constraint
constraintController
C3DConstraintController
C3DConstraintConstantScale
C3DConstraintProcedural
<C3DConstraintController>
C3DConstraint
<C3DConstraint %@ %p>
influenceFactor
C3DConstraintLookAt
<C3DConstraintLookAt %p>
targetOffset
worldUp
localFront
C3DConstraintBillboard
<C3DConstraintBillboard %p>
<C3DConstraintConstantScale>
<C3DConstraintProcedural>
C3DConstraintIK
<C3DConstraintIK %p>
targetPosition
C3DConstraintDistance
<C3DConstraintDistance>
maximumDistance
C3DConstraintAcceleration
maximumLinearAcceleration
maximumLinearVelocity
decelerationDistance
C3DConstraintReplicator
<C3DConstraintReplicator>
orientationOffset
positionOffset
scaleOffset
C3DConstraintManager
<C3DConstraintManagerRef>
__controller
superClass
_currentClassRegistry
CFDictionaryGetCountOfKey(_currentClassRegistry, propertyName) == 0
prefix
indexString
GenerateMipmapPass
C3DModelTarget
<C3DModelTarget>
ControllerAnimation
ControllerVariableMode
ControllerVariableOverLife
ControllerVariableOverDistance
ControllerVariableOverOtherProperty
ControllerVariableOrigin
ControllerVariableScale
ControllerVariableBias
C3DParticleSystem
<C3DParticleSystemRef>
InvLifeSpan
BirthTime
SortingIndices
Mass
TempData
EventIndex
C3DModelValueStorageItem
item
C3DModelValueStorage
item->_getter
item->_setter
CFGetTypeID(target->_owner) == C3DNodeGetTypeID()
aValue
<C3DModelValueStorageItem %p>
<C3DModelValueStorage>
incremental
gimbalLockEnabled
upVector
targetDirection
replicatesOrientation
replicatesScale
replicatesPosition
collisionCategoryBitMask
bias
freeAxes
preserveScale
v36@?0^{__C3DConstraint={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__CFString}fBB{?=^?^?^?^?^?^?}^v}8^v16^{__C3DModelTarget={__CFRuntimeBase=QAQ}^v^vscCCB^?^?}24f32
node%d
angle%d
ikTarget
chainRootNode
C3DAnimationEvents
events
events->_eventCount < events->_eventCapacity
<C3DAnimationEvents>
t0 <= t1
index < events->_eventCount
C3DRendererElementStore
node == NULL || node->_rendererElementSpan.count == 0 || renderableHash & kC3DRenderableAttributeHashParticleSystem
node->_rendererLOD->count == count
index < (CFIndex)span.count
<C3DRendererElementStore %p>
C3DIndexStore
indexStore
<C3DIndexStore>
alignedIndex >= 0 && alignedIndex < bufferLength
copy_no_alpha_depth_texture
copy_no_alpha_uint_texture
copy_no_alpha_texture
addDependency
C3DRenderGraph.mm
_renderGraph->size() > n1
_renderGraph->size() > n2
n1Port == kPartialDependencyPort || node1.pass->descriptor().inputCount() > n1Port
n2Port == kPartialDependencyPort || node2.pass->descriptor().outputCount() > n2Port
a->identifier() != kInvalidPass
b->identifier() != kInvalidPass
(*_renderGraph).size() > n1
(*_renderGraph).size() > n2
v16@?0^{__C3DLight=}8
simd_all(viewport != -1)
output.textureDesc.sampleCount != 1
nextInput.textureDesc.sampleCount != 1
_graphDescription
%@/%s_%d.tiff
no_name
imagePath
attachmentID < 255
outputResource->type == output.type
stages
outputDesc
%d-i-%d
%d-o-%d
links
addPass
passIndex < 32767
res->poolSubBuffer.buffer
res->texture
param.attachmentType == TextureAttachmentType::Color
resolveParam->textureDesc.sampleCount == 0 || resolveParam->textureDesc.sampleCount == 1
!SCNMTLTextureTypeIsMultisampled((MTLTextureType)resolveParam->textureDesc.textureType)
res->resolveTexture
sort
_renderGraph->size() < 32767
!_stageFirst->passes.empty()
index == 0 || inputPorts[index].a != inputPorts[index - 1].a
!portsPairs.empty()
strlen(inputParam.name) != 0
outputParam
inputParam.type == outputParam->type
res->usedCount >= 0
node.resource().outputCount() == node.descriptor().outputCount()
resOutput == nullptr
resInput
resDestination == outputRes
inputRes
!outputResDesc.usedInternally
Clear drawable
SpriteKit transition
renderEncoder
linked to : %s slot %d (%s)
linked to : 
%s %s slot %d (%s)
Allocator::_allocator
initial_capacity || _capacity == 0
a._capacity == initial_capacity
PickedObjectPass
COLOR_PICKED
DEPTH_PICKED
dstParticles != srcParticles
invLifeSpanArray
C3DParticleSystemInstance
v16@?0Q8
<C3DParticleSystemInstanceRef>
offset < 4
size == sizeof(C3DFloat)
_affineValid(t)
!_matrixValid(t)
_matrixValid(t)
!_affineValid(t)
C3DAllocator
<C3DAllocator>
address < (void*) ((unsigned char*)controller+sizeof(struct __C3DAnimatableParamController))
C3DAnimatableParamController
<C3DAnimatableParamController>
pname
C3DProgramHashCodeStore
v24@?0Q8r^v16
programIndex < 0xffffffff
<C3DProgramHashCodeStore %p>
cullingContext->eyeCount == 2
passInstance->_cullingData[eye] == NULL
cullingContext->scene
C3DKeyValueStore
<C3DKeyValueStore>
SCNProgramDidChangeNotification
parameter
vertexFunctionName
sourceFile
fragmentFunctionName
semanticInfos
SCNShaderModifierEntryPointGeometry
SCNShaderModifierEntryPointSurface
SCNShaderModifierEntryPointFragment
SCNShaderModifierEntryPointLightingModel
_owner == nil
^v16@?0^v8
v32@?0@"NSString"8@"SCNBufferBinding"16^B24
v24@?0i8^{__CFString=}12B20
owner
minimumLanguageVersion
SCNShadableDidCompileNotificationName
issues
%@ // [SCN_%@(%d)]
C3DArray
index < C3DArrayGetCount(array)
<C3DArray %p:, %d objects>
<%@ | string=%@ extrusionDepth=%.3f> 
-[SCNText set_wantsSeparateGeometryElements:]
-[SCNText setChamferRadius:]
-[SCNText setDiscretizedStraightLineMaxLength:]
-[SCNText setExtrusionDepth:]
extrusionDepth
-[SCNText setFlatness:]
-[SCNText setPrimitiveType:]
-[SCNText setString:]
-[SCNText setWrapped:]
SFProUI
SFProText
HelveticaNeue
.AppleSystemUIFont
.SFUI
.SFNS
-[SCNText setContainerFrame:]
chamferProfile
font
alignmentMode
truncationMode
discretizedStraightLineMaxLength
wrapped
useCustomContainerFrame
customContainerFrame
_wantsSeparateGeometryElements
root_node
/System/Library/PrivateFrameworks/USDKit.framework/USDKit
../SharedFrameworks/USDKit.framework/USDKit
USKObjectPath
USKToken
USKData
USKScene
USKDataTypeResourcePath
USKDataTypeInt
USKDataTypeBool
USKDataTypeDouble3
USKDataTypeDouble4x4
USKDataTypeDouble4x4Array
USKDataTypeFloat
USKDataTypeFloat2
USKDataTypeFloat3
USKDataTypeFloat4
USKDataTypeFloat2Array
USKDataTypeFloat3Array
USKDataTypeFloatArray
USKDataTypeIntArray
USKDataTypeObjectPath
USKDataTypeObjectPathArray
USKDataTypeQuatf
USKDataTypeQuatfArray
USKDataTypeStringArray
USKDataTypeToken
USKDataTypeTokenArray
USKNodeTypeCamera
USKNodeTypeMaterial
USKNodeTypeMesh
USKNodeTypeMeshGroup
USKNodeTypeScope
USKNodeTypeShader
USKNodeTypeSkeletalAnimation
USKNodeTypeSkeleton
USKNodeTypeSkeletonRoot
USKNodeTypeBlendShape
USKNodeTypeTransform
USKRoleTypeColor
USKRoleTypeNone
USKRoleTypeNormal
USKRoleTypePoint
USKRoleTypeVector
USKRoleTypeTextureCoordinate
USKSchemaTypeBindingAPI
[^A-Za-z0-9]
SceneKit export preview %.02f
customLayerData
creator
assetInfo
kind
component
defaultPrim
metersPerUnit
startTimeCode
endTimeCode
timeCodesPerSecond
invisible
Node_
Skeleton
restTransforms
bindTransforms
skel:skeleton
subdivisionScheme
faceVertexCounts
faceVarying
extent
material:binding
_meshGroup
elementType
face
familyName
materialBind
indices
primvars:normals
primvars:st
primvars:displayColor
faceVertexIndices
primvars:normals:indices
primvars:st:indices
primvars:displayColor:indices
Material_
surfaceShader
info:id
UsdPreviewSurface
outputs:surface
emissiveColor
occlusion
Materials
texgen_%lu.png
texgen_%lu
@"NSString"24@?0@"NSString"8@?<B@?@"NSString">16
B16@?0@"NSString"8
inputs:
_texCoordReader
UsdPrimvarReader_float2
outputs:result
inputs:varname
inputs:frame:stPrimvarName
_transform2D
sdrMetadata
role
math
UsdTransform2d
inputs:in
inputs:rotation
inputs:scale
inputs:translation
_texture
UsdUVTexture
inputs:bias
inputs:file
inputs:st
inputs:wrapS
inputs:wrapT
inputs:minFilter
inputs:magFilter
outputs:
blendShape
BlendShape
pointIndices
skel:blendShapes
skel:blendShapeTargets
offsets
normalOffsets
projection
horizontalAperture
verticalAperture
clippingRange
xformOp:transform
xformOp:translate
xformOp:orient
rotation.euler
xformOp:rotate
xformOp:rotateXYZ
xformOp:scale
xformOp:rotateX
xformOp:rotateY
xformOp:rotateZ
xformOpOrder
Geom
blendShapeWeights
skel:animationSource
blendShapes
primvars:skel:jointWeights
elementSize
primvars:skel:jointIndices
primvars:skel:geomBindTransform
translations
rotations
scales
baseGeometryMeshlessPositionSource
maxMorphTargetCount > 0
-[SCNMTLMorphDeformer setupMorphTargetsWithComputeContext:]
SCNMTLMorphDeformer.mm
_finalMeshDataKind == _dataKindForComputeKernel
baseNormalSource
-[SCNMTLMorphDeformer setupMorphTargetsWithComputeContext:]_block_invoke
morphUsesSparseTargets == false
originalNormalSource
vertexCount == _vertexCountForComputeKernel
vertexBufferOffset == vertexBufferLength
sparseIndicesBufferOffset == sparseIndicesBufferLength
morphNormal
copy_generic
copy_indexed_u8_generic
blend_indexed_u8_generic
copy_indexed_u16_generic
blend_indexed_u16_generic
copy_indexed_u32_generic
blend_indexed_u32_generic
blend_generic
splat_indexed_s8_vertices
splat_indexed_s16_vertices
splat_indexed_s32_vertices
blend_inc_init_8x_pn_kernel
blend_inc_add_8x_pn_kernel
blend_inc_init_8x_p_kernel
blend_inc_add_8x_p_kernel
dstForWriting == dst + length
writtenIndexCount == runtimeTarget->vertexCount
weightCount == _morphTargetCount
SSRDepthBackFacePass
--SSRBackFaceMaterial--
C3DWrapDeformerComputeBindingPointIndicesAndBarycentricCoordsFromUVs
SCNGeometryWrapDeformerUtils.mm
doneIndicesCount == vertexCount
C3DWrapDeformerComputeSharedBindingPointIndicesAndBarycentricCoordsFromSandwichedPositions_block_invoke_2
__bindToUV_block_invoke
__computeBarycentricCoordinates2D
__adjustDistanceByAligningProjection
CopyTextureBlitPass
CopyTextureComputePass
texturecube_slices_copy_kernel
texturecube_copy_kernel
texturecube_copy_resample_kernel
texture2d_copy_kernel
texture2d_copy_resample_kernel
descriptor().renderStartIndex == 0
srcElementType == dstElementType
CopyTextureRenderPass
<%@ | path=%@ extrusionDepth=%.3f> 
-[SCNShape setChamferMode:]
-[SCNShape setChamferRadius:]
-[SCNShape setDiscretizedStraightLineMaxLength:]
-[SCNShape setExtrusionDepth:]
-[SCNShape setPrimitiveType:]
chamferMode
C3DShape
<C3DShape '%@'>
C3DShapeGeometryValidate
C3DShapeGeometry.m
CFGetTypeID(geometry) == C3DShapeGeometryGetTypeID()
newMesh
shapeGeometry
Helvetica
C3DShapeGeometryMeshForBoundingBox
^{__C3DMesh=}8@?0
C3DShapeGeometryGetBoundingBox
C3DShapeGeometryGetBoundingSphere
C3DShapeGeometry
C3DTextGeometry
scn_generate_grain
levelOfDetail <%p>: geometry:%@ threshold:%f useDistance:%d
mode
C3DNodeGetLight(_drawNodesParameters.pointOfView)
PROBE
RenderProbePass
CFDictionaryGetValue(dic, uniformName) == NULL
mat2x3
scn_frame.invScreenPixelSize
SceneKit_downSample4x
SceneKit_DOF_blurCoc_H
SceneKit_DOF_blurCoc_V
SceneKit_blurColor4x_H
SceneKit_blurColor4x_V
C3D-dof-lerpBias
C3D-dof-lerpScale
C3D-dof-cocScaleBias
C3D-dof-invertPixelSize
scnasset
.scnassets
baseTangentSource
_finalDataKind == kC3DMeshDataKindOriginal && subdivIsUsed
UInt%d-%d-%d
deformer_splat
_meshlessDeformer
info.wantsFinalNormalsBuffer == false
info.wantsFinalTangentsBuffer == false
orig < originalVertexCount
prov < deindexedVertexCount
-[SCNMTLDeformerStack reconfigureIfNeededWithContext:programHashCodeRequirements:]
SCNMTLDeformerStack.mm
wantsDrawIndirect == NO
^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}12@?0C8
-[SCNMTLDeformerStack reconfigureIfNeededWithContext:programHashCodeRequirements:]_block_invoke_2
-[SCNMTLDeformerStack reconfigureIfNeededWithContext:programHashCodeRequirements:]_block_invoke
_finalMesh != nil
[dependencyDeformerStack computeDeformedMeshReliesOnTransforms] == NO
[dependencyDeformerStack computeDeformedMeshReliesOnFrustum] == NO
@"<MTLComputeCommandEncoder>"8@?0
buffer != nil
-[SCNMTLDeformerStack dependencyBufferForInput:dependencyMesh:]
buffers->dependency0Positions
buffers->dependency0Normals
buffers->dependency0Tangents
buffers->dependency1Positions
buffers->dependency1Normals
buffers->dependency1Tangents
_configureStageInputOutputDescriptorWithDeformerFunction
info.isActive
btOptimizedBvhNodeData
btQuantizedBvhNodeData
btBvhSubtreeInfoData
btQuantizedBvhFloatData
btCollisionObjectFloatData
Overflow in AABB, object removed from simulation
If you can reproduce this, please email bugs@continuousphysics.com
Please include above information, your Platform, version of OS.
Thanks.
Triangle
btConvexInternalShapeData
Box2d
btTriangleMeshShapeData
BVHTRIANGLEMESH
CapsuleShape
btCapsuleShapeData
btCollisionShapeData
btCompoundShapeChildData
btCompoundShapeData
Compound
btVector3FloatData
btConvexHullShapeData
Convex
ConvexTrimesh
CylinderY
btCylinderShapeData
btPositionAndRadius
btMultiSphereShapeData
MultiSphere
SPHERE
STATICPLANE
btStaticPlaneShapeData
btIntIndexData
btShortIntIndexTripletData
btCharIndexTripletData
btVector3DoubleData
btMeshPartData
btStridingMeshInterfaceData
TRIANGLEMESH
btConeTwistConstraintData
btHingeConstraintFloatData
btPoint2PointConstraintFloatData
btSliderConstraintData
btTypedConstraintData
btDynamicsWorldFloatData
btRigidBodyFloatData
hw.optional.neon_hpfp
completeTopologyFromFaceValues
fvarLevel.cpp
vSpan._size != 0
getVertexEdgeValues
edgeTopologyMatches(eIndex)
getFaceValueTags
_vertValueIndices[srcValueIndex] == faceValues[i]
getFaceCompositeValueTag
bilinear
catmark
loop
AddWithWeight
stencilBuilder.cpp
_sources[i] < _coarseVertCount
patchTableFactory.cpp
IsPatchEligible
fVerts.size() == 4
GetRegularPatchBoundaryMask
eBoundaryMask != -1
computePatchParam
ptexIndex!=-1
createUniform
refiner.IsUniform()
ptype!=PatchDescriptor::NON_PATCH
npatches>=0
(levelVertOffset + fvalues[vert]) < (int)table->getFVarValues(fvc).size()
createAdaptive
! refiner.IsUniform()
populateAdaptivePatches
"Unknown Descriptor for FVar patch" == 0
identifyNonManifoldCornerSpan
vSpan._numFaces == 1
getPatchIndex
patchTable.cpp
patchIndex<pa.numPatches
getPatchArrayVertices
pa.vertIndex<(Index)_patchVerts.size()
GetPatchArrayVertices
GetPatchVertices
(pa.vertIndex + patchIndex*size)<(Index)_patchVerts.size()
getFVarPatchChannel
channel>=0 && channel<(int)_fvarChannels.size()
getPatchArray
arrayIndex<(Index)GetNumPatchArrays()
Failure in TopologyRefinerFactory<>::Create() -- mesh contains no vertices.
Failure in TopologyRefinerFactory<>::Create() -- meshes without faces not yet supported.
Failure in TopologyRefinerFactory<>::Create() -- face with %d vertices > %d max.
Failure in TopologyRefinerFactory<>::Create() -- mesh contains no face-vertices.
Failure in TopologyRefinerFactory<>::Create() -- non-triangular faces not supported by Loop scheme.
prepareComponentTopologySizing
topologyRefinerFactory.cpp
baseLevel.getNumFaceEdgesTotal() > 0
baseLevel.getNumEdgeVerticesTotal() > 0
baseLevel.getNumEdgeFacesTotal() > 0
baseLevel.getNumVertexFacesTotal() > 0
baseLevel.getNumVertexEdgesTotal() > 0
Failure in TopologyRefinerFactory<>::Create() -- vertex with valence %d > %d max.
Failure in TopologyRefinerFactory<>::Create() -- maximum valence not assigned.
Failure in TopologyRefinerFactory<>::Create() -- invalid topology detected from partial specification.
Failure in TopologyRefinerFactory<>::Create() -- invalid topology detected as fully specified.
prepareComponentTagsAndSharpness
(schemeRegularInteriorValence == 4) || (schemeRegularInteriorValence == 6)
Failure in TopologyRefinerFactory<>::Create() -- face-varying channel %d has no values.
GetFaceId
ptexIndices.cpp
f<(int)_ptexIndices.size()
FindIndexIn4Tuple
array.h
_size>=4
"FindIndexIn4Tuple() did not find expected value!" == 0
Create
mtlPatchTable.mm
0 && "MTLPatchTable Creation Failed"
OSD PatchIndexBuffer
OSD PatchParamBuffer
MISSING_EDGE_FACES
MISSING_EDGE_VERTS
MISSING_FACE_EDGES
MISSING_FACE_VERTS
MISSING_VERT_FACES
MISSING_VERT_EDGES
FAILED_CORRELATION_FACE_VERT
FAILED_CORRELATION_FACE_EDGE
FAILED_ORIENTATION_INCIDENT_EDGE
FAILED_ORIENTATION_INCIDENT_FACE
FAILED_ORIENTATION_INCIDENT_FACES_EDGES
DEGENERATE_EDGE
NON_MANIFOLD_EDGE
level.cpp
%s - missing face-verts
%s - missing vert-faces
%s - face %d correlation of vert %d failed
%s - missing edge-faces
%s - missing face-edges
%s - face %d correlation of edge %d failed
%s - missing edge-verts
%s - missing vert-edges
%s - edge %d correlation of vert %d failed
%s - vertex %d cannot orient incident faces and edges
%s - vertex %d orientation failure at incident face %d
%s - vertex %d orientation failure at incident edge %d
%s - Error in eIndex = %d:  degenerate edge not tagged marked non-manifold
%s - edge %d with %d incident faces not tagged non-manifold
gatherQuadRegularPartialRingAroundVertex
! level.isVertexNonManifold(vIndex)
(0 <= rotation) && (rotation < 4)
gatherQuadRegularInteriorPatchPoints
gatherQuadRegularBoundaryPatchPoints
(boundaryFaceInV0Faces >= 0) && (boundaryFaceInV1Faces >= 0)
gatherQuadRegularCornerPatchPoints
cornerFaceInIntVertFaces >= 0
completeTopologyFromFaceVertices
(vCount > 0) && (fCount > 0) && (eCount == 0)
_maxValence > 0
orderVertexFacesAndEdges
fCountOrdered == fCount
MTLStencilTable
mtlComputeEvaluator.mm
context != nil
context->device != nil && context->commandQueue != nil
StencilTable Sizes
StencilTable Offsets
StencilTable Indices
StencilTable Weights
Compile
Using OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES
LENGTH
SRC_STRIDE
DST_STRIDE
WORK_GROUP_SIZE
OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES
PARAMETER_BUFFER_INDEX
SIZES_BUFFER_INDEX
OFFSETS_BUFFER_INDEX
WEIGHTS_BUFFER_INDEX
SRC_VERTEX_BUFFER_INDEX
DST_VERTEX_BUFFER_INDEX
DU_WEIGHTS_BUFFER_INDEX
DV_WEIGHTS_BUFFER_INDEX
DU_DERIVATIVE_BUFFER_INDEX
DV_DERIVATIVE_BUFFER_INDEX
PATCH_ARRAYS_BUFFER_INDEX
PATCH_COORDS_BUFFER_INDEX
PATCH_PARAMS_BUFFER_INDEX
Error compiling MTL Shader: %s
eval_stencils
Error compiling MTL Pipeline eval_stencils: %s
eval_patches
Error compiling MTL Pipeline eval_patches:  %s
EvalStencils
context != nullptr
device != nil && commandQueue != nil
#line 0 "osd/mtlComputeKernel.metal"
//   Copyright 2015 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
#include <metal_stdlib>
#ifndef OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES
#define OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES 0
#endif
using namespace metal;
struct PatchCoord
    int arrayIndex;
    int patchIndex;
    int vertIndex;
    float s;
    float t;
struct PatchParam
    uint field0;
    uint field1;
    float sharpness;
struct KernelUniformArgs
int batchStart;
int batchEnd;
    int srcOffset;
int dstOffset;
    int3 duDesc;
    int3 dvDesc;
struct Vertex {
    float vertexData[LENGTH];
void clear(thread Vertex& v) {
    for (int i = 0; i < LENGTH; ++i) {
        v.vertexData[i] = 0;
    }
Vertex readVertex(int index, device float* vertexBuffer, KernelUniformArgs args) {
    Vertex v;
    int vertexIndex = args.srcOffset + index * SRC_STRIDE;
    for (int i = 0; i < LENGTH; ++i) {
        v.vertexData[i] = vertexBuffer[vertexIndex + i];
    }
    return v;
void writeVertex(int index, Vertex v, device float* vertexBuffer, KernelUniformArgs args) {
    int vertexIndex = args.dstOffset + index * DST_STRIDE;
    for (int i = 0; i < LENGTH; ++i) {
        vertexBuffer[vertexIndex + i] = v.vertexData[i];
    }
void writeVertexSeparate(int index, Vertex v, device float* dstVertexBuffer, KernelUniformArgs args) {
    int vertexIndex = args.dstOffset + index * DST_STRIDE;
    for (int i = 0; i < LENGTH; ++i) {
        dstVertexBuffer[vertexIndex + i] = v.vertexData[i];
    }
void addWithWeight(thread Vertex& v, const Vertex src, float weight) {
    for (int i = 0; i < LENGTH; ++i) {
        v.vertexData[i] += weight * src.vertexData[i];
    }
void writeDu(int index, Vertex du, device float* duDerivativeBuffer, KernelUniformArgs args)
    int duIndex = args.duDesc.x + index * args.duDesc.z;
    for(int i = 0; i < LENGTH; i++)
    {
        duDerivativeBuffer[duIndex + i] = du.vertexData[i];
    }
void writeDv(int index, Vertex dv, device float* dvDerivativeBuffer, KernelUniformArgs args)
    int dvIndex = args.dvDesc.x + index * args.dvDesc.z;
    for(int i = 0; i < LENGTH; i++)
    {
        dvDerivativeBuffer[dvIndex + i] = dv.vertexData[i];
    }
// ---------------------------------------------------------------------------
kernel void eval_stencils(
    uint thread_position_in_grid [[thread_position_in_grid]],
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    const device uint8_t* sizes [[buffer(SIZES_BUFFER_INDEX)]],
    const device int* offsets [[buffer(OFFSETS_BUFFER_INDEX)]],
    const device uint16_t* indices [[buffer(INDICES_BUFFER_INDEX)]],
    const device half* weights [[buffer(WEIGHTS_BUFFER_INDEX)]],
#else
    const device int* sizes [[buffer(SIZES_BUFFER_INDEX)]],
    const device int* offsets [[buffer(OFFSETS_BUFFER_INDEX)]],
    const device int* indices [[buffer(INDICES_BUFFER_INDEX)]],
    const device float* weights [[buffer(WEIGHTS_BUFFER_INDEX)]],
#endif
    device float* srcVertices [[buffer(SRC_VERTEX_BUFFER_INDEX)]],
    device float* dstVertexBuffer [[buffer(DST_VERTEX_BUFFER_INDEX)]],
    const device float* duWeights [[buffer(DU_WEIGHTS_BUFFER_INDEX)]],
    const device float* dvWeights [[buffer(DV_WEIGHTS_BUFFER_INDEX)]],
    device float* duDerivativeBuffer [[buffer(DU_DERIVATIVE_BUFFER_INDEX)]],
    device float* dvDerivativeBuffer [[buffer(DV_DERIVATIVE_BUFFER_INDEX)]],
    const constant KernelUniformArgs& args [[buffer(PARAMETER_BUFFER_INDEX)]]
    auto current  = thread_position_in_grid + args.batchStart;
    if(current >= args.batchEnd)
        return;
    Vertex dst;
    clear(dst);
    auto offset = offsets[current];
    auto size = sizes[current];
    for(auto stencil = 0; stencil < size; stencil++)
    {
        auto vindex = offset + stencil;
        addWithWeight(dst, readVertex(indices[vindex], srcVertices, args), weights[vindex]);
    }
    writeVertex(current, dst, dstVertexBuffer, args);
#if OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES
    Vertex du, dv;
    clear(du);
    clear(dv);
    for(auto i = 0; i < size; i++)
    {
        auto src = readVertex(indices[offset + i], srcVertices, args);
        addWithWeight(du, src, duWeights[offset + i]);
        addWithWeight(dv, src, dvWeights[offset + i]);
    }
    writeDu(current, du, duDerivativeBuffer, args);
    writeDv(current, dv, dvDerivativeBuffer, args);
#endif
// ---------------------------------------------------------------------------
// PERFORMANCE: stride could be constant, but not as significant as length
//struct PatchArray {
//    int patchType;
//    int numPatches;
//    int indexBase;        // an offset within the index buffer
//    int primitiveIdBase;  // an offset within the patch param buffer
//};
// # of patcharrays is 1 or 2.
uint getDepth(uint patchBits) {
    return (patchBits & 0xf);
float getParamFraction(uint patchBits) {
    uint nonQuadRoot = (patchBits >> 4) & 0x1;
    uint depth = getDepth(patchBits);
    if (nonQuadRoot == 1) {
        return 1.0f / float( 1 << (depth-1) );
    } else {
        return 1.0f / float( 1 << depth );
    }
float2 normalizePatchCoord(uint patchBits, float2 uv) {
    float frac = getParamFraction(patchBits);
    uint iu = (patchBits >> 22) & 0x3ff;
    uint iv = (patchBits >> 12) & 0x3ff;
    // top left corner
    float pu = float(iu*frac);
    float pv = float(iv*frac);
    // normalize u,v coordinates
    return float2((uv.x - pu) / frac, (uv.y - pv) / frac);
bool isRegular(uint patchBits) {
    return (((patchBits >> 5) & 0x1u) != 0);
int getNumControlVertices(int patchType) {
    switch(patchType) {
        case 3: return 4;
        case 6: return 16;
        case 9: return 20;
        default: return 0;
    }
// ---------------------------------------------------------------------------
kernel void eval_patches(
                         uint thread_position_in_grid [[thread_position_in_grid]],
                         const constant uint4* patchArrays [[buffer(PATCH_ARRAYS_BUFFER_INDEX)]],
                         device PatchCoord* patchCoords [[buffer(PATCH_COORDS_BUFFER_INDEX)]],
                         device int* patchIndices [[buffer(PATCH_INDICES_BUFFER_INDEX)]],
                         device PatchParam* patchParams [[buffer(PATCH_PARAMS_BUFFER_INDEX)]],
                         device float* srcVertexBuffer [[buffer(SRC_VERTEX_BUFFER_INDEX)]],
                         device float* dstVertexBuffer [[buffer(DST_VERTEX_BUFFER_INDEX)]],
                         device float* duDerivativeBuffer [[buffer(DU_DERIVATIVE_BUFFER_INDEX)]],
                         device float* dvDerivativeBuffer [[buffer(DV_DERIVATIVE_BUFFER_INDEX)]],
                         const constant KernelUniformArgs& args [[buffer(PARAMETER_BUFFER_INDEX)]]
                         )
    auto current = thread_position_in_grid;
    auto patchCoord = patchCoords[current];
    auto patchIndex = patchIndices[patchCoord.patchIndex];
    auto patchArray = patchArrays[patchCoord.arrayIndex];
    auto patchBits = patchParams[patchIndex].field1; 
    auto patchType = select(patchArray.x, uint(6), isRegular(patchBits));
    auto numControlVertices = getNumControlVertices(patchType);
    auto uv = normalizePatchCoord(patchBits, float2(patchCoord.s, patchCoord.t));
    auto dScale = float(1 << getDepth(patchBits));
    auto boundaryMask = int((patchBits >> 8) & 0xFU);
    float wP[20], wDs[20], wDt[20], wDss[20], wDst[20], wDtt[20];
    if(patchType == 3) {
        OsdGetBilinearPatchWeights(uv.x, uv.y, dScale, wP, wDs, wDt, wDss, wDst, wDtt);
    } else if(patchType == 6) {
        OsdGetBSplinePatchWeights(uv.x, uv.y, dScale, boundaryMask, wP, wDs, wDt, wDss, wDst, wDtt);
    } else if(patchType == 9) {
        OsdGetGregoryPatchWeights(uv.x, uv.y, dScale, wP, wDs, wDt, wDss, wDst, wDtt);
    }
    Vertex dst, du, dv;
    clear(dst);
    clear(du);
    clear(dv);
    auto indexBase = patchArray.z + numControlVertices * (patchCoord.patchIndex - patchArray.w);
    for(auto cv = 0; cv < numControlVertices; cv++)
    {
        auto index = patchIndices[indexBase + cv];
        auto src = readVertex(index, srcVertexBuffer, args);
        addWithWeight(dst, src, wP[cv]);
        addWithWeight(du, src, wDs[cv]);
        addWithWeight(dv, src, wDt[cv]);
    }
    writeVertex(current, dst, dstVertexBuffer, args);
#if OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES
    if(args.duDesc.y > 0)
        writeDu(current, du, duDerivativeBuffer, args);
    if(args.dvDesc.y > 0)
        writeDv(current, dv, dvDerivativeBuffer, args);
#endif
appendLocalPointStencilTable
stencilTableFactory.cpp
GetStencil
stencilTable.h
(! _offsets.empty()) && i<(int)_offsets.size()
ProtoBasis
gregoryBasis.cpp
cornerPatchFace[corner] != -1
gregoryBasis.h
_size < (int)_stencils.GetSize()
computeCoefficient
valence > 0
operator=
_size <= (int)_stencils.GetSize()
Refinement
refinement.cpp
(childArg.getDepth() == 0) && (childArg.getNumVertices() == 0)
refine
_parent && _child
populateParentToChildMapping
"Unsupported empty sparse refinement detected in Refinement" == 0
subdivideFVarChannels
_child->_fvarChannels.size() == 0
this->_fvarChannels.size() == 0
markSparseVertexChildren
_parentVertexTag.size() > 0
markSparseEdgeChildren
_parentEdgeTag.size() > 0
No Error
Fatal Error
Coding Error (internal)
Coding Error
Error
error.cpp
err!=FAR_NO_ERROR
%s: %s
Warning: %s
estimateAndAllocateChildValues
fvarRefinement.cpp
_refinement.isChildVertexComplete(cVert)
propagateValueTags
propagateValueCreases
_childFVar.hasSmoothBoundaries()
populateChildValuesForEdgeVertex
cVertFaces.size() == cVertFaceSiblings.size()
cVertFaces.size() >= cValueCount
populateChildValuesForVertexVertex
populateFaceVerticesFromParentFaces
triRefinement.cpp
pFaceVerts.size() == 3
pFaceChildren.size() == 4
populateFaceEdgesFromParentFaces
pFaceChildFaces.size() == 4
pFaceChildEdges.size() == 3
populateEdgeVerticesFromParentFaces
pFaceEdges.size() == 3
populateEdgeFacesFromParentFaces
populateVertexFacesFromParentEdges
markSparseFaceChildren
_parentFaceTag.size() > 0
fChildFaces.size() == 4
fChildEdges.size() == 3
#define OSD_METAL_OSX 1
#define OSD_PATCH_BASIS_METAL 1
#line 0 "osd/mtlPatchCommon.metal"
//   Copyright 2015 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//----------------------------------------------------------
// Patches.Common
//----------------------------------------------------------
#define offsetof_(X, Y) &(((device X*)nullptr)->Y)
#define OSD_IS_ADAPTIVE (OSD_PATCH_REGULAR || OSD_PATCH_GREGORY_BASIS || OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY)
#ifndef OSD_MAX_TESS_LEVEL
#define OSD_MAX_TESS_LEVEL 64
#endif
#ifndef OSD_NUM_ELEMENTS
#define OSD_NUM_ELEMENTS 3
#endif
#ifndef OSD_USER_VARYING_DECLARE
#define OSD_USER_VARYING_DECLARE
#endif
#ifndef OSD_USER_VARYING_DECLARE_ATTRIBUTE
#define OSD_USER_VARYING_DECLARE_ATTRIBUTE
#endif
#ifndef OSD_USER_VARYING_PER_VERTEX
#define OSD_USER_VARYING_PER_VERTEX(in, out)
#endif
#ifndef OSD_USER_VARYING_PER_CONTROL_POINT
#define OSD_USER_VARYING_PER_CONTROL_POINT(in, out)
#endif
#ifndef OSD_USER_VARYING_PER_EVAL_POINT
#define OSD_USER_VARYING_PER_EVAL_POINT(UV, a, b, c, d, out)
#endif
static_assert(sizeof(OsdInputVertexType) > 0, "OsdInputVertexType must be defined and have a float3 position member");
#if OSD_IS_ADAPTIVE
#if OSD_PATCH_GREGORY_BASIS
constant constexpr unsigned IndexLookupStride = 5;
#else 
constant constexpr unsigned IndexLookupStride = 1;
#endif
#define PATCHES_PER_THREADGROUP ((THREADS_PER_THREADGROUP * CONTROL_POINTS_PER_THREAD) / CONTROL_POINTS_PER_PATCH)
#define REAL_THREADGROUP_DIVISOR (CONTROL_POINTS_PER_PATCH / CONTROL_POINTS_PER_THREAD)
static_assert(REAL_THREADGROUP_DIVISOR % 2 == 0, "REAL_THREADGROUP_DIVISOR must be a power of 2");
static_assert(!OSD_ENABLE_SCREENSPACE_TESSELLATION || !USE_PTVS_FACTORS, "USE_PTVS_FACTORS cannot be enabled if OSD_ENABLE_SCREENSPACE_TESSELLATION is enabled");
static_assert((OSD_ENABLE_SCREENSPACE_TESSELLATION && (OSD_FRACTIONAL_ODD_SPACING || OSD_FRACTIONAL_EVEN_SPACING)) || !OSD_ENABLE_SCREENSPACE_TESSELLATION, "OSD_ENABLE_SCREENSPACE_TESSELLATION requires OSD_FRACTIONAL_ODD_SPACING or OSD_FRACTIONAL_EVEN_SPACING");
#endif
//Adjustments to the UV reparameterization can be defined here. 
#ifndef OSD_UV_CORRECTION
#define OSD_UV_CORRECTION
#endif
using namespace metal;
// ----------------------------------------------------------------------------
// Patch Parameters
// ----------------------------------------------------------------------------
// Each patch has a corresponding patchParam. This is a set of three values
// specifying additional information about the patch:
//    faceId    -- topological face identifier (e.g. Ptex FaceId)
//    bitfield  -- refinement-level, non-quad, boundary, transition, uv-offset
//    sharpness -- crease sharpness for single-crease patches
// These are stored in OsdPatchParamBuffer indexed by the value returned
// from OsdGetPatchIndex() which is a function of the current PrimitiveID
// along with an optional client provided offset.
using OsdPatchParamBufferType = packed_int3;
struct OsdPerVertexGregory {
    float3 P;
    short3 clipFlag;
    int valence;
    float3 e0;
    float3 e1;
#if OSD_PATCH_GREGORY_BOUNDARY
    int zerothNeighbor;
    float3 org;
#endif
    float3 r[OSD_MAX_VALENCE];
    OSD_USER_VARYING_DECLARE
struct OsdPerPatchVertexGregory {
    packed_float3 P;
    packed_float3 Ep;
    packed_float3 Em;
    packed_float3 Fp;
    packed_float3 Fm;
    OSD_USER_VARYING_DECLARE
//----------------------------------------------------------
// HLSL->Metal Compatibility
//----------------------------------------------------------
static inline float4 mul(float4x4 a, float4 b)
    return a * b;
static inline float3 mul(float4x4 a, float3 b)
    float3x3 m(a[0].xyz, a[1].xyz, a[2].xyz);
    return m * b;
//----------------------------------------------------------
// Patches.Common
//----------------------------------------------------------
// For now, fractional spacing is supported only with screen space tessellation
#ifndef OSD_ENABLE_SCREENSPACE_TESSELLATION
#undef OSD_FRACTIONAL_EVEN_SPACING
#undef OSD_FRACTIONAL_ODD_SPACING
#endif
struct HullVertex {
    float4 position;
#if OSD_ENABLE_PATCH_CULL
    short3 clipFlag;
#endif
    OSD_USER_VARYING_DECLARE
    float3 GetPosition() threadgroup
    {
        return position.xyz;
    }
    void SetPosition(float3 v) threadgroup
    {
    
position.xyz = v;
    }
// XXXdyu all downstream data can be handled by client code
struct OsdPatchVertex {
    float3 position;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 patchCoord; //u, v, faceLevel, faceId
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    float3 Nu;
    float3 Nv;
#endif
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    float2 vSegments;
#endif
    OSD_USER_VARYING_DECLARE
struct OsdPerPatchTessFactors {
    float4 tessOuterLo;
    float4 tessOuterHi;
struct OsdPerPatchVertexBezier {
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    packed_half3 P;
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    packed_half3 P1;
    packed_half3 P2;
#if !USE_PTVS_SHARPNESS
    half2 vSegments;
#endif
#endif
#else
    packed_float3 P;
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    packed_float3 P1;
    packed_float3 P2;
#if !USE_PTVS_SHARPNESS
    float2 vSegments;
#endif
#endif
#endif //C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    OSD_USER_VARYING_DECLARE
struct OsdPerPatchVertexGregoryBasis {
    packed_float3 P;
    OSD_USER_VARYING_DECLARE
#if OSD_PATCH_REGULAR
using PatchVertexType = HullVertex;
using PerPatchVertexType = OsdPerPatchVertexBezier;
#elif OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY
using PatchVertexType = OsdPerVertexGregory;
using PerPatchVertexType = OsdPerPatchVertexGregory;
#elif OSD_PATCH_GREGORY_BASIS
using PatchVertexType = HullVertex;
using PerPatchVertexType = OsdPerPatchVertexGregoryBasis;
#else
using PatchVertexType = OsdInputVertexType;
using PerPatchVertexType = OsdInputVertexType;
#endif
//Shared buffers used by OSD that are common to all kernels
struct OsdPatchParamBufferSet
const device OsdInputVertexType* vertexBuffer [[buffer(VERTEX_BUFFER_INDEX)]];
const device unsigned* indexBuffer [[buffer(CONTROL_INDICES_BUFFER_INDEX)]];
const device OsdPatchParamBufferType* patchParamBuffer [[buffer(OSD_PATCHPARAM_BUFFER_INDEX)]];
device PerPatchVertexType* perPatchVertexBuffer [[buffer(OSD_PERPATCHVERTEXBEZIER_BUFFER_INDEX)]];
#if !USE_PTVS_FACTORS    
    device OsdPerPatchTessFactors* patchTessBuffer [[buffer(OSD_PERPATCHTESSFACTORS_BUFFER_INDEX)]];
#endif
#if OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY
const device int* quadOffsetBuffer [[buffer(OSD_QUADOFFSET_BUFFER_INDEX)]];
const device int* valenceBuffer [[buffer(OSD_VALENCE_BUFFER_INDEX)]];
#endif
const constant unsigned& kernelExecutionLimit [[buffer(OSD_KERNELLIMIT_BUFFER_INDEX)]];
//Shared buffers used by OSD that are common to all PTVS implementations
struct OsdVertexBufferSet
const device OsdInputVertexType* vertexBuffer [[buffer(VERTEX_BUFFER_INDEX)]];
const device unsigned* indexBuffer [[buffer(CONTROL_INDICES_BUFFER_INDEX)]];
const device OsdPatchParamBufferType* patchParamBuffer [[buffer(OSD_PATCHPARAM_BUFFER_INDEX)]];
device PerPatchVertexType* perPatchVertexBuffer [[buffer(OSD_PERPATCHVERTEXBEZIER_BUFFER_INDEX)]];
#if !USE_PTVS_FACTORS    
    device OsdPerPatchTessFactors* patchTessBuffer [[buffer(OSD_PERPATCHTESSFACTORS_BUFFER_INDEX)]];
#endif
// ----------------------------------------------------------------------------
// Patch Parameters Accessors
// ----------------------------------------------------------------------------
static int3 OsdGetPatchParam(int patchIndex, const device OsdPatchParamBufferType* osdPatchParamBuffer)
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    return int3(osdPatchParamBuffer[patchIndex]);
#else
    auto p = osdPatchParamBuffer[patchIndex];
    return int3(p[0], p[1], 0);
#endif
static int OsdGetPatchIndex(int primitiveId)
    return primitiveId;
static int OsdGetPatchFaceId(int3 patchParam)
    return (patchParam.x & 0xfffffff);
static int OsdGetPatchFaceLevel(int3 patchParam)
    return (1 << ((patchParam.y & 0xf) - ((patchParam.y >> 4) & 1)));
static int OsdGetPatchRefinementLevel(int3 patchParam)
    return (patchParam.y & 0xf);
static int OsdGetPatchBoundaryMask(int3 patchParam)
    return ((patchParam.y >> 8) & 0xf);
static int OsdGetPatchTransitionMask(int3 patchParam)
    return ((patchParam.x >> 28) & 0xf);
static int2 OsdGetPatchFaceUV(int3 patchParam)
    int u = (patchParam.y >> 22) & 0x3ff;
    int v = (patchParam.y >> 12) & 0x3ff;
    return int2(u,v);
static bool OsdGetPatchIsRegular(int3 patchParam)
    return ((patchParam.y >> 5) & 0x1) != 0;
static float OsdGetPatchSharpness(int3 patchParam)
    return as_type<float>(patchParam.z);
static float OsdGetPatchSingleCreaseSegmentParameter(int3 patchParam, float2 uv)
    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);
    float s = 0;
    if ((boundaryMask & 1) != 0) {
        s = 1 - uv.y;
    } else if ((boundaryMask & 2) != 0) {
        s = uv.x;
    } else if ((boundaryMask & 4) != 0) {
        s = uv.y;
    } else if ((boundaryMask & 8) != 0) {
        s = 1 - uv.x;
    }
    return s;
// ----------------------------------------------------------------------------
static void OsdUnivar4x4(float u, thread float* B)
    float t = u;
    float s = 1.0f - u;
    
    float A0 = s * s;
    float A1 = 2 * s * t;
    float A2 = t * t;
    
    B[0] = s * A0;
    B[1] = t * A0 + s * A1;
    B[2] = t * A1 + s * A2;
    B[3] = t * A2;
static void OsdUnivar4x4(float u, thread float* B, thread float* D)
    float t = u;
    float s = 1.0f - u;
    float A0 = s * s;
    float A1 = 2 * s * t;
    float A2 = t * t;
    B[0] = s * A0;
    B[1] = t * A0 + s * A1;
    B[2] = t * A1 + s * A2;
    B[3] = t * A2;
    D[0] =    - A0;
    D[1] = A0 - A1;
    D[2] = A1 - A2;
    D[3] = A2;
static void OsdUnivar4x4(float u, thread float* B, thread float* D, thread float* C)
    float t = u;
    float s = 1.0f - u;
    float A0 = s * s;
    float A1 = 2 * s * t;
    float A2 = t * t;
    B[0] = s * A0;
    B[1] = t * A0 + s * A1;
    B[2] = t * A1 + s * A2;
    B[3] = t * A2;
    D[0] =    - A0;
    D[1] = A0 - A1;
    D[2] = A1 - A2;
    D[3] = A2;
    A0 =   - s;
    A1 = s - t;
    A2 = t;
    C[0] =    - A0;
    C[1] = A0 - A1;
    C[2] = A1 - A2;
    C[3] = A2;
// ----------------------------------------------------------------------------
static float3 OsdEvalBezier(float3 cp[16], float2 uv)
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    float B[4], D[4];
    OsdUnivar4x4(uv.x, B, D);
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            float3 A = cp[4*i + j];
            BUCP[i] += A * B[j];
        }
    }
    float3 P = float3(0,0,0);
    OsdUnivar4x4(uv.y, B, D);
    for (int k=0; k<4; ++k) {
        P += B[k] * BUCP[k];
    }
    return P;
static bool OsdCullPerPatchVertex(
threadgroup PatchVertexType* patch, 
float4x4 ModelViewMatrix
#if OSD_ENABLE_BACKPATCH_CULL && OSD_PATCH_REGULAR
    auto v0 = float3(ModelViewMatrix * patch[5].position);
    auto v3 = float3(ModelViewMatrix * patch[6].position);
    auto v12 = float3(ModelViewMatrix * patch[9].position);
    auto n = normalize(cross(v3 - v0, v12 - v0));
    v0 = normalize(v0 + v3 + v12);
    if(dot(v0, n) > 0.6f)
    {
        return false;
    }
#endif
#if OSD_ENABLE_PATCH_CULL
    short3 clipFlag = short3(0,0,0);
    for(int i = 0; i < CONTROL_POINTS_PER_PATCH; ++i) {
        clipFlag |= patch[i].clipFlag;
    }
    if (any(clipFlag != short3(3,3,3))) {
        return false;
    }
#endif
    return true;
// When OSD_PATCH_ENABLE_SINGLE_CREASE is defined,
// this function evaluates single-crease patch, which is segmented into
// 3 parts in the v-direction.
//  v=0             vSegment.x        vSegment.y              v=1
//   +------------------+-------------------+------------------+
//   |       cp 0       |     cp 1          |      cp 2        |
//   | (infinite sharp) | (floor sharpness) | (ceil sharpness) |
//   +------------------+-------------------+------------------+
static float3 OsdEvalBezier(device OsdPerPatchVertexBezier* cp, int3 patchParam, float2 uv)
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    float B[4], D[4];
    float s = OsdGetPatchSingleCreaseSegmentParameter(patchParam, uv);
    OsdUnivar4x4(uv.x, B, D);
#if OSD_PATCH_ENABLE_SINGLE_CREASE
#if USE_PTVS_SHARPNESS
    float sharpness = OsdGetPatchSharpness(patchParam);
    float Sf = floor(sharpness);
    float Sc = ceil(sharpness);
    float s0 = 1 - exp2(-Sf);
    float s1 = 1 - exp2(-Sc);
    float2 vSegments(s0, s1);
#else
    float2 vSegments = float2(cp[0].vSegments);
#endif // USE_PTVS_SHARPNESS
    //By doing the offset calculation ahead of time it can be kept out of the actual indexing lookup.
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    if(s <= vSegments.x)
        cp = (device OsdPerPatchVertexBezier*)(((device half*)cp) + 0);
    else if( s <= vSegments.y)
        cp = (device OsdPerPatchVertexBezier*)(((device half*)cp) + 3);
    else
        cp = (device OsdPerPatchVertexBezier*)(((device half*)cp) + 6);
#else
    if(s <= vSegments.x)
        cp = (device OsdPerPatchVertexBezier*)(((device float*)cp) + 0);
    else if( s <= vSegments.y)
        cp = (device OsdPerPatchVertexBezier*)(((device float*)cp) + 3);
    else
        cp = (device OsdPerPatchVertexBezier*)(((device float*)cp) + 6);
#endif //C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    BUCP[0] += float3(cp[0].P) * B[0];
    BUCP[0] += float3(cp[1].P) * B[1];
    BUCP[0] += float3(cp[2].P) * B[2];
    BUCP[0] += float3(cp[3].P) * B[3];
    BUCP[1] += float3(cp[4].P) * B[0];
    BUCP[1] += float3(cp[5].P) * B[1];
    BUCP[1] += float3(cp[6].P) * B[2];
    BUCP[1] += float3(cp[7].P) * B[3];
    BUCP[2] += float3(cp[8].P) * B[0];
    BUCP[2] += float3(cp[9].P) * B[1];
    BUCP[2] += float3(cp[10].P) * B[2];
    BUCP[2] += float3(cp[11].P) * B[3];
    BUCP[3] += float3(cp[12].P) * B[0];
    BUCP[3] += float3(cp[13].P) * B[1];
    BUCP[3] += float3(cp[14].P) * B[2];
    BUCP[3] += float3(cp[15].P) * B[3];
#else // single crease
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            float3 A = float3(cp[4*i + j].P);
            BUCP[i] += A * B[j];
        }
    }
#endif  // single crease
    OsdUnivar4x4(uv.y, B);
    float3 P = B[0] * BUCP[0];
    for (int k=1; k<4; ++k) {
        P += B[k] * BUCP[k];
    }
    return P;
// ----------------------------------------------------------------------------
// Boundary Interpolation
// ----------------------------------------------------------------------------
template<typename VertexType>
static void OsdComputeBSplineBoundaryPoints(threadgroup VertexType* cpt, int3 patchParam)
//APPL TODO - multithread this
    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);
    if ((boundaryMask & 1) != 0) {
        cpt[0].SetPosition(2*cpt[4].GetPosition() - cpt[8].GetPosition());
        cpt[1].SetPosition(2*cpt[5].GetPosition() - cpt[9].GetPosition());
        cpt[2].SetPosition(2*cpt[6].GetPosition() - cpt[10].GetPosition());
        cpt[3].SetPosition(2*cpt[7].GetPosition() - cpt[11].GetPosition());
    }
    if ((boundaryMask & 2) != 0) {
        cpt[3].SetPosition(2*cpt[2].GetPosition() - cpt[1].GetPosition());
        cpt[7].SetPosition(2*cpt[6].GetPosition() - cpt[5].GetPosition());
        cpt[11].SetPosition(2*cpt[10].GetPosition() - cpt[9].GetPosition());
        cpt[15].SetPosition(2*cpt[14].GetPosition() - cpt[13].GetPosition());
    }
    if ((boundaryMask & 4) != 0) {
        cpt[12].SetPosition(2*cpt[8].GetPosition() - cpt[4].GetPosition());
        cpt[13].SetPosition(2*cpt[9].GetPosition() - cpt[5].GetPosition());
        cpt[14].SetPosition(2*cpt[10].GetPosition() - cpt[6].GetPosition());
        cpt[15].SetPosition(2*cpt[11].GetPosition() - cpt[7].GetPosition());
    }
    if ((boundaryMask & 8) != 0) {
        cpt[0].SetPosition(2*cpt[1].GetPosition() - cpt[2].GetPosition());
        cpt[4].SetPosition(2*cpt[5].GetPosition() - cpt[6].GetPosition());
        cpt[8].SetPosition(2*cpt[9].GetPosition() - cpt[10].GetPosition());
        cpt[12].SetPosition(2*cpt[13].GetPosition() - cpt[14].GetPosition());
    }
template<typename VertexType>
static void OsdComputeBSplineBoundaryPoints(thread VertexType* cpt, int3 patchParam)
    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);
    if ((boundaryMask & 1) != 0) {
        cpt[0].SetPosition(2*cpt[4].GetPosition() - cpt[8].GetPosition());
        cpt[1].SetPosition(2*cpt[5].GetPosition() - cpt[9].GetPosition());
        cpt[2].SetPosition(2*cpt[6].GetPosition() - cpt[10].GetPosition());
        cpt[3].SetPosition(2*cpt[7].GetPosition() - cpt[11].GetPosition());
    }
    if ((boundaryMask & 2) != 0) {
        cpt[3].SetPosition(2*cpt[2].GetPosition() - cpt[1].GetPosition());
        cpt[7].SetPosition(2*cpt[6].GetPosition() - cpt[5].GetPosition());
        cpt[11].SetPosition(2*cpt[10].GetPosition() - cpt[9].GetPosition());
        cpt[15].SetPosition(2*cpt[14].GetPosition() - cpt[13].GetPosition());
    }
    if ((boundaryMask & 4) != 0) {
        cpt[12].SetPosition(2*cpt[8].GetPosition() - cpt[4].GetPosition());
        cpt[13].SetPosition(2*cpt[9].GetPosition() - cpt[5].GetPosition());
        cpt[14].SetPosition(2*cpt[10].GetPosition() - cpt[6].GetPosition());
        cpt[15].SetPosition(2*cpt[11].GetPosition() - cpt[7].GetPosition());
    }
    if ((boundaryMask & 8) != 0) {
      cpt[0].SetPosition(2*cpt[1].GetPosition() - cpt[2].GetPosition());
      cpt[4].SetPosition(2*cpt[5].GetPosition() - cpt[6].GetPosition());
      cpt[8].SetPosition(2*cpt[9].GetPosition() - cpt[10].GetPosition());
      cpt[12].SetPosition(2*cpt[13].GetPosition() - cpt[14].GetPosition());
    }
static void OsdEvalPatchGregory(int3 patchParam, float2 UV, thread float3* cv,
                    thread float3& P, thread float3& dPu, thread float3& dPv,
                    thread float3& N, thread float3& dNu, thread float3& dNv)
    float u = UV.x, v = UV.y;
    float U = 1-u, V = 1-v;
    //(0,1)                              (1,1)
    //   P3         e3-      e2+         P2
    //      15------17-------11-------10
    //      |        |        |        |
    //      |        |        |        |
    //      |        | f3-    | f2+    |
    //      |       19       13        |
    //  e3+ 16-----18          14-----12 e2-
    //      |     f3+          f2-     |
    //      |                          |
    //      |                          |
    //      |     f0-         f1+      |
    //  e0- 2------4            8------6 e1+
    //      |        3 f0+    9        |
    //      |        |        | f1-    |
    //      |        |        |        |
    //      |        |        |        |
    //      0--------1--------7--------5
    //    P0        e0+      e1-         P1
    //(0,0)                               (1,0)
    float d11 = u+v;
    float d12 = U+v;
    float d21 = u+V;
    float d22 = U+V;
    float3 q[16];
    q[ 5] = (d11 == 0.0) ? cv[3]  : (u*cv[3] + v*cv[4])/d11;
    q[ 6] = (d12 == 0.0) ? cv[8]  : (U*cv[9] + v*cv[8])/d12;
    q[ 9] = (d21 == 0.0) ? cv[18] : (u*cv[19] + V*cv[18])/d21;
    q[10] = (d22 == 0.0) ? cv[13] : (U*cv[13] + V*cv[14])/d22;
    q[ 0] = cv[0];
    q[ 1] = cv[1];
    q[ 2] = cv[7];
    q[ 3] = cv[5];
    q[ 4] = cv[2];
    q[ 7] = cv[6];
    q[ 8] = cv[16];
    q[11] = cv[12];
    q[12] = cv[15];
    q[13] = cv[17];
    q[14] = cv[11];
    q[15] = cv[10];
    P   = float3(0,0,0);
    dPu = float3(0,0,0);
    dPv = float3(0,0,0);
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    float B[4], D[4], C[4];
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    DUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    CUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    float3 dUU = float3(0,0,0);
    float3 dVV = float3(0,0,0);
    float3 dUV = float3(0,0,0);
    OsdUnivar4x4(UV.x, B, D, C);
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            float3 A = q[4*i + j];
            BUCP[i] += A * B[j];
            DUCP[i] += A * D[j];
            CUCP[i] += A * C[j];
        }
    }
    OsdUnivar4x4(UV.y, B, D, C);
    for (int i=0; i<4; ++i) {
        P   += B[i] * BUCP[i];
        dPu += B[i] * DUCP[i];
        dPv += D[i] * BUCP[i];
        dUU += B[i] * CUCP[i];
        dVV += C[i] * BUCP[i];
        dUV += D[i] * DUCP[i];
    }
    int level = OsdGetPatchFaceLevel(patchParam);
    dPu *= 3 * level;
    dPv *= 3 * level;
    dUU *= 6 * level;
    dVV *= 6 * level;
    dUV *= 9 * level;
    float3 n = cross(dPu, dPv);
    N = normalize(n);
    float E = dot(dPu, dPu);
    float F = dot(dPu, dPv);
    float G = dot(dPv, dPv);
    float e = dot(N, dUU);
    float f = dot(N, dUV);
    float g = dot(N, dVV);
    dNu = (f*F-e*G)/(E*G-F*F) * dPu + (e*F-f*E)/(E*G-F*F) * dPv;
    dNv = (g*F-f*G)/(E*G-F*F) * dPu + (f*F-g*E)/(E*G-F*F) * dPv;
    dNu = dNu/length(n) - n * (dot(dNu,n)/powr(dot(n,n), 1.5));
    dNv = dNv/length(n) - n * (dot(dNv,n)/powr(dot(n,n), 1.5));
#else //OSD_COMPUTE_NORMAL_DERIVATIVES
    float B[4], D[4];
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    DUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    OsdUnivar4x4(UV.x, B, D);
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            float3 A = q[4*i + j];
            BUCP[i] += A * B[j];
            DUCP[i] += A * D[j];
        }
    }
    OsdUnivar4x4(UV.y, B, D);
    for (int i=0; i<4; ++i) {
        P += B[i] * BUCP[i];
        dPu += B[i] * DUCP[i];
        dPv += D[i] * BUCP[i];
    }
    int level = OsdGetPatchFaceLevel(patchParam);
    dPu *= 3 * level;
    dPv *= 3 * level;
    N = normalize(cross(dPu, dPv));
    dNu = float3(0,0,0);
    dNv = float3(0,0,0);
#endif //OSD_COMPUTE_NORMAL_DERIVATIVES
// ----------------------------------------------------------------------------
// Tessellation
// ----------------------------------------------------------------------------
// Organization of B-spline and Bezier control points.
// Each patch is defined by 16 control points (labeled 0-15).
// The patch will be evaluated across the domain from (0,0) at
// the lower-left to (1,1) at the upper-right. When computing
// adaptive tessellation metrics, we consider refined vertex-vertex
// and edge-vertex points along the transition edges of the patch
// (labeled vv* and ev* respectively).
// The two segments of each transition edge are labeled Lo and Hi,
// with the Lo segment occuring before the Hi segment along the
// transition edge's domain parameterization. These Lo and Hi segment
// tessellation levels determine how domain evaluation coordinates
// are remapped along transition edges. The Hi segment value will
// be zero for a non-transition edge.
// (0,1)                                         (1,1)
//   vv3                  ev23                   vv2
//        |       Lo3       |       Hi3       |
//      --O-----------O-----+-----O-----------O--
//        | 12        | 13     14 |        15 |
//        |           |           |           |
//        |           |           |           |
//    Hi0 |           |           |           | Hi2
//        |           |           |           |
//        O-----------O-----------O-----------O
//        | 8         | 9      10 |        11 |
//        |           |           |           |
// ev03 --+           |           |           +-- ev12
//        |           |           |           |
//        | 4         | 5       6 |         7 |
//        O-----------O-----------O-----------O
//        |           |           |           |
//    Lo0 |           |           |           | Lo2
//        |           |           |           |
//        |           |           |           |
//        | 0         | 1       2 |         3 |
//      --O-----------O-----+-----O-----------O--
//        |       Lo1       |       Hi1       |
//   vv0                  ev01                   vv1
// (0,0)                                         (1,0)
static float OsdComputePostProjectionSphereExtent(const float4x4 OsdProjectionMatrix, float3 center, float diameter)
    //float4 p = OsdProjectionMatrix * float4(center, 1.0);
    float w = OsdProjectionMatrix[0][3] * center.x + OsdProjectionMatrix[1][3] * center.y + OsdProjectionMatrix[2][3] * center.z + OsdProjectionMatrix[3][3];
    return abs(diameter * OsdProjectionMatrix[1][1] / w);
// Round up to the nearest even integer
static float OsdRoundUpEven(float x) {
    return 2*ceil(x/2);
// Round up to the nearest odd integer
static float OsdRoundUpOdd(float x) {
    return 2*ceil((x+1)/2)-1;
// Compute outer and inner tessellation levels taking into account the
// current tessellation spacing mode.
static void OsdComputeTessLevels(thread float4& tessOuterLo, thread float4& tessOuterHi,
                     thread float4& tessLevelOuter, thread float2& tessLevelInner)
    // Outer levels are the sum of the Lo and Hi segments where the Hi
    // segments will have lengths of zero for non-transition edges.
#if OSD_FRACTIONAL_EVEN_SPACING
    // Combine fractional outer transition edge levels before rounding.
    float4 combinedOuter = tessOuterLo + tessOuterHi;
    // Round the segments of transition edges separately. We will recover the
    // fractional parameterization of transition edges after tessellation.
    tessLevelOuter = combinedOuter;
    if (tessOuterHi[0] > 0) {
        tessLevelOuter[0] =
            OsdRoundUpEven(tessOuterLo[0]) + OsdRoundUpEven(tessOuterHi[0]);
    }
    if (tessOuterHi[1] > 0) {
        tessLevelOuter[1] =
            OsdRoundUpEven(tessOuterLo[1]) + OsdRoundUpEven(tessOuterHi[1]);
    }
    if (tessOuterHi[2] > 0) {
        tessLevelOuter[2] =
            OsdRoundUpEven(tessOuterLo[2]) + OsdRoundUpEven(tessOuterHi[2]);
    }
    if (tessOuterHi[3] > 0) {
        tessLevelOuter[3] =
            OsdRoundUpEven(tessOuterLo[3]) + OsdRoundUpEven(tessOuterHi[3]);
    }
#elif OSD_FRACTIONAL_ODD_SPACING
    // Combine fractional outer transition edge levels before rounding.
    float4 combinedOuter = tessOuterLo + tessOuterHi;
    // Round the segments of transition edges separately. We will recover the
    // fractional parameterization of transition edges after tessellation.
    //
    // The sum of the two outer odd segment lengths will be an even number
    // which the tessellator will increase by +1 so that there will be a
    // total odd number of segments. We clamp the combinedOuter tess levels
    // (used to compute the inner tess levels) so that the outer transition
    // edges will be sampled without degenerate triangles.
    tessLevelOuter = combinedOuter;
    if (tessOuterHi[0] > 0) {
        tessLevelOuter[0] =
            OsdRoundUpOdd(tessOuterLo[0]) + OsdRoundUpOdd(tessOuterHi[0]);
        combinedOuter = max(float4(3,3,3,3), combinedOuter);
    }
    if (tessOuterHi[1] > 0) {
        tessLevelOuter[1] =
            OsdRoundUpOdd(tessOuterLo[1]) + OsdRoundUpOdd(tessOuterHi[1]);
        combinedOuter = max(float4(3,3,3,3), combinedOuter);
    }
    if (tessOuterHi[2] > 0) {
        tessLevelOuter[2] =
            OsdRoundUpOdd(tessOuterLo[2]) + OsdRoundUpOdd(tessOuterHi[2]);
        combinedOuter = max(float4(3,3,3,3), combinedOuter);
    }
    if (tessOuterHi[3] > 0) {
        tessLevelOuter[3] =
            OsdRoundUpOdd(tessOuterLo[3]) + OsdRoundUpOdd(tessOuterHi[3]);
        combinedOuter = max(float4(3,3,3,3), combinedOuter);
    }
#else //OSD_FRACTIONAL_ODD_SPACING
    // Round equally spaced transition edge levels before combining.
    tessOuterLo = round(tessOuterLo);
    tessOuterHi = round(tessOuterHi);
    float4 combinedOuter = tessOuterLo + tessOuterHi;
    tessLevelOuter = combinedOuter;
#endif //OSD_FRACTIONAL_ODD_SPACING
    // Inner levels are the averages the corresponding outer levels.
    tessLevelInner[0] = (combinedOuter[1] + combinedOuter[3]) * 0.5;
    tessLevelInner[1] = (combinedOuter[0] + combinedOuter[2]) * 0.5;
static float OsdComputeTessLevel(const float OsdTessLevel, const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix, float3 p0, float3 p1)
    // Adaptive factor can be any computation that depends only on arg values.
    // Project the diameter of the edge's bounding sphere instead of using the
    // length of the projected edge itself to avoid problems near silhouettes.
    float3 center = (p0 + p1) / 2.0;
    float diameter = distance(p0, p1);
    float projLength = OsdComputePostProjectionSphereExtent(OsdProjectionMatrix, center, diameter);
    float tessLevel = max(1.0, OsdTessLevel * projLength);
    // We restrict adaptive tessellation levels to half of the device
    // supported maximum because transition edges are split into two
    // halfs and the sum of the two corresponding levels must not exceed
    // the device maximum. We impose this limit even for non-transition
    // edges because a non-transition edge must be able to match up with
    // one half of the transition edge of an adjacent transition patch.
    return min(tessLevel, (float)(OSD_MAX_TESS_LEVEL / 2));
static void OsdGetTessLevelsUniform(const float OsdTessLevel, int3 patchParam,
                        thread float4& tessOuterLo, thread float4& tessOuterHi)
    // Uniform factors are simple powers of two for each level.
    // The maximum here can be increased if we know the maximum
    // refinement level of the mesh:
    //     min(OSD_MAX_TESS_LEVEL, pow(2, MaximumRefinementLevel-1)
    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);
    float tessLevel = min(OsdTessLevel, ((float)OSD_MAX_TESS_LEVEL / 2)) /
                        pow(2, refinementLevel - 1.0f);
//    float tessLevel = min(OsdTessLevel, (float)OSD_MAX_TESS_LEVEL);
//    if(refinementLevel != 0)
//         tessLevel /= (1 << (refinementLevel - 1));
//    else
//    {
//        tessLevel /= pow(2.0, (0 - 1));
//        tessLevel /= pow(2.0, (refinementLevel - 1));
//    }
    // tessLevels of transition edge should be clamped to 2.
    int transitionMask = OsdGetPatchTransitionMask(patchParam);
    float4 tessLevelMin = float4(1)
    + float4(((transitionMask & 8) >> 3),
             ((transitionMask & 1) >> 0),
             ((transitionMask & 2) >> 1),
             ((transitionMask & 4) >> 2));
//    tessLevelMin =  (tessLevelMin - 1.0) * 2.0f + 1.0;
//    tessLevelMin = float4(OsdTessLevel);
    tessOuterLo = max(float4(tessLevel,tessLevel,tessLevel,tessLevel),
                      tessLevelMin);
    tessOuterHi = float4(0,0,0,0);
//    tessOuterLo.x = refinementLevel;
static void OsdGetTessLevelsRefinedPoints(const float OsdTessLevel,
                              const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,
                              float3 cp[16], int3 patchParam,
                              thread float4& tessOuterLo, thread float4& tessOuterHi)
    // Each edge of a transition patch is adjacent to one or two patches
    // at the next refined level of subdivision. We compute the corresponding
    // vertex-vertex and edge-vertex refined points along the edges of the
    // patch using Catmull-Clark subdivision stencil weights.
    // For simplicity, we let the optimizer discard unused computation.
    float3 vv0 = (cp[0] + cp[2] + cp[8] + cp[10]) * 0.015625 +
    (cp[1] + cp[4] + cp[6] + cp[9]) * 0.09375 + cp[5] * 0.5625;
    float3 ev01 = (cp[1] + cp[2] + cp[9] + cp[10]) * 0.0625 +
    (cp[5] + cp[6]) * 0.375;
    float3 vv1 = (cp[1] + cp[3] + cp[9] + cp[11]) * 0.015625 +
    (cp[2] + cp[5] + cp[7] + cp[10]) * 0.09375 + cp[6] * 0.5625;
    float3 ev12 = (cp[5] + cp[7] + cp[9] + cp[11]) * 0.0625 +
    (cp[6] + cp[10]) * 0.375;
    float3 vv2 = (cp[5] + cp[7] + cp[13] + cp[15]) * 0.015625 +
    (cp[6] + cp[9] + cp[11] + cp[14]) * 0.09375 + cp[10] * 0.5625;
    float3 ev23 = (cp[5] + cp[6] + cp[13] + cp[14]) * 0.0625 +
    (cp[9] + cp[10]) * 0.375;
    float3 vv3 = (cp[4] + cp[6] + cp[12] + cp[14]) * 0.015625 +
    (cp[5] + cp[8] + cp[10] + cp[13]) * 0.09375 + cp[9] * 0.5625;
    float3 ev03 = (cp[4] + cp[6] + cp[8] + cp[10]) * 0.0625 +
    (cp[5] + cp[9]) * 0.375;
    tessOuterLo = float4(0,0,0,0);
    tessOuterHi = float4(0,0,0,0);
    int transitionMask = OsdGetPatchTransitionMask(patchParam);
    if ((transitionMask & 8) != 0) {
        tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv0, ev03);
        tessOuterHi[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv3, ev03);
    } else {
        tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp[5], cp[9]);
    }
    if ((transitionMask & 1) != 0) {
        tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv0, ev01);
        tessOuterHi[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv1, ev01);
    } else {
        tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp[5], cp[6]);
    }
    if ((transitionMask & 2) != 0) {
        tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv1, ev12);
        tessOuterHi[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv2, ev12);
    } else {
        tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp[6], cp[10]);
    }
    if ((transitionMask & 4) != 0) {
        tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv3, ev23);
        tessOuterHi[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv2, ev23);
    } else {
        tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp[9], cp[10]);
    }
static float3 miniMul(float4x4 a, float3 b)
    float3 r;
    r.x = a[0][0] * b[0] + a[1][0] * b[1] + a[2][0] * b[2] + a[3][0];
    r.y = a[0][1] * b[0] + a[1][1] * b[1] + a[2][1] * b[2] + a[3][1];
    r.z = a[0][2] * b[0] + a[1][2] * b[1] + a[2][2] * b[2] + a[3][2];
    return r;
static void OsdGetTessLevelsLimitPoints(const float OsdTessLevel, const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,
                            device OsdPerPatchVertexBezier* cpBezier,
                            int3 patchParam, thread float4& tessOuterLo, thread float4& tessOuterHi)
    // Each edge of a transition patch is adjacent to one or two patches
    // at the next refined level of subdivision. When the patch control
    // points have been converted to the Bezier basis, the control points
    // at the four corners are on the limit surface (since a Bezier patch
    // interpolates its corner control points). We can compute an adaptive
    // tessellation level for transition edges on the limit surface by
    // evaluating a limit position at the mid point of each transition edge.
    tessOuterLo = float4(0,0,0,0);
    tessOuterHi = float4(0,0,0,0);
    int transitionMask = OsdGetPatchTransitionMask(patchParam);
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    // PERFOMANCE: we just need to pick the correct corner points from P, P1, P2
    float3 p0 = OsdEvalBezier(cpBezier, patchParam, float2(0.0, 0.0));
    float3 p3 = OsdEvalBezier(cpBezier, patchParam, float2(1.0, 0.0));
    float3 p12 = OsdEvalBezier(cpBezier, patchParam, float2(0.0, 1.0));
    float3 p15 = OsdEvalBezier(cpBezier, patchParam, float2(1.0, 1.0));
    p0 = miniMul(OsdModelViewMatrix, p0);
    p3 = miniMul(OsdModelViewMatrix, p3);
    p12 = miniMul(OsdModelViewMatrix, p12);
    p15 = miniMul(OsdModelViewMatrix, p15);
    thread float3 * tPt;
    float3 ev;
    if ((transitionMask & 8) != 0) { // EVO3
        ev = OsdEvalBezier(cpBezier, patchParam, float2(0.0, 0.5));
        ev = miniMul(OsdModelViewMatrix, ev);
        tPt = &ev;
        tessOuterHi[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p12, ev);
    } else {
        tPt = &p12;
    }
    tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p0, *tPt);
    
    if ((transitionMask & 1) != 0) { // EV01
        ev = OsdEvalBezier(cpBezier, patchParam, float2(0.5, 0.0));
        ev = miniMul(OsdModelViewMatrix, ev);
        tPt = &ev;
        tessOuterHi[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p3, ev);
    } else {
        tPt = &p3;
    }
    tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p0, *tPt);
    
    if ((transitionMask & 2) != 0) { // EV12
        ev = OsdEvalBezier(cpBezier, patchParam, float2(1.0, 0.5));
        ev = miniMul(OsdModelViewMatrix, ev);
        tPt = &ev;
        tessOuterHi[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p15, ev);
    } else {
        tPt = &p15;
    }
    tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p3, *tPt);
    
    if ((transitionMask & 4) != 0) { // EV23
        ev = OsdEvalBezier(cpBezier, patchParam, float2(0.5, 1.0));
        ev = miniMul(OsdModelViewMatrix, ev);
        tPt = &ev;
        tessOuterHi[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p15, ev);
    } else {
        tPt = &p15;
    }
    tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p12, *tPt);
#else // OSD_PATCH_ENABLE_SINGLE_CREASE
    float3 p0 = OsdEvalBezier(cpBezier, patchParam, float2(0.0, 0.5));
    float3 p3 = OsdEvalBezier(cpBezier, patchParam, float2(0.5, 0.0));
    float3 p12 = OsdEvalBezier(cpBezier, patchParam, float2(1.0, 0.5));
    float3 p15 = OsdEvalBezier(cpBezier, patchParam, float2(0.5, 1.0));
    p0 = miniMul(OsdModelViewMatrix, p0);
    p3 = miniMul(OsdModelViewMatrix, p3);
    p12 = miniMul(OsdModelViewMatrix, p12);
    p15 = miniMul(OsdModelViewMatrix, p15);
    float3 c00 = miniMul(OsdModelViewMatrix, float3(cpBezier[0].P));
    float3 c12 = miniMul(OsdModelViewMatrix, float3(cpBezier[12].P));
    float3 c03 = miniMul(OsdModelViewMatrix, float3(cpBezier[3].P));
    float3 c15 = miniMul(OsdModelViewMatrix, float3(cpBezier[15].P));
    
    if ((transitionMask & 8) != 0) {
        tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c00, p0);
        tessOuterHi[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c12, p0);
    } else {
        tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c00, c12);
    }
    if ((transitionMask & 1) != 0) {
        tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c00, p3);
        tessOuterHi[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c03, p3);
    } else {
        tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c00, c03);
    }
    if ((transitionMask & 2) != 0) {
        tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c03, p12);
        tessOuterHi[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c15, p12);
    } else {
        tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c03, c15);
    }
    if ((transitionMask & 4) != 0) {
        tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c12, p15);
        tessOuterHi[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c15, p15);
    } else {
        tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c12, c15);
    }
#endif
static void OsdGetTessLevelsUniform(const float OsdTessLevel, int3 patchParam,
                        thread float4& tessLevelOuter, thread float2& tessLevelInner,
                        thread float4& tessOuterLo, thread float4& tessOuterHi)
    OsdGetTessLevelsUniform(OsdTessLevel, patchParam, tessOuterLo, tessOuterHi);
    OsdComputeTessLevels(tessOuterLo, tessOuterHi, tessLevelOuter, tessLevelInner);
static void OsdGetTessLevelsAdaptiveRefinedPoints(const float OsdTessLevel, const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,
                                      float3 cpRefined[16], int3 patchParam,
                                      thread float4& tessLevelOuter, thread float2& tessLevelInner,
                                      thread float4& tessOuterLo, thread float4& tessOuterHi)
    OsdGetTessLevelsRefinedPoints(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cpRefined, patchParam, tessOuterLo, tessOuterHi);
    OsdComputeTessLevels(tessOuterLo, tessOuterHi,
                         tessLevelOuter, tessLevelInner);
static void OsdGetTessLevelsAdaptiveLimitPoints(const float OsdTessLevel, const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,
                                    device OsdPerPatchVertexBezier* cpBezier,
                                    int3 patchParam,
                                    thread float4& tessLevelOuter, thread float2& tessLevelInner,
                                    thread float4& tessOuterLo, thread float4& tessOuterHi)
    OsdGetTessLevelsLimitPoints(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cpBezier, patchParam, tessOuterLo, tessOuterHi);
    OsdComputeTessLevels(tessOuterLo, tessOuterHi,
                         tessLevelOuter, tessLevelInner);
static void OsdGetTessLevels(const float OsdTessLevel, const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,
                 float3 cp0, float3 cp1, float3 cp2, float3 cp3,
                 int3 patchParam,
                 thread float4& tessLevelOuter, thread float2& tessLevelInner)
    float4 tessOuterLo = float4(0,0,0,0);
    float4 tessOuterHi = float4(0,0,0,0);
    cp0 = mul(OsdModelViewMatrix, float4(cp0, 1.0)).xyz;
    cp1 = mul(OsdModelViewMatrix, float4(cp1, 1.0)).xyz;
    cp2 = mul(OsdModelViewMatrix, float4(cp2, 1.0)).xyz;
    cp3 = mul(OsdModelViewMatrix, float4(cp3, 1.0)).xyz;
#if OSD_ENABLE_SCREENSPACE_TESSELLATION
    tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp0, cp1);
    tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp0, cp3);
    tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp2, cp3);
    tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp1, cp2);
    tessOuterHi = float4(0,0,0,0);
#else //OSD_ENABLE_SCREENSPACE_TESSELLATION
    OsdGetTessLevelsUniform(OsdTessLevel, patchParam, tessOuterLo, tessOuterHi);
#endif //OSD_ENABLE_SCREENSPACE_TESSELLATION
    OsdComputeTessLevels(tessOuterLo, tessOuterHi,
                         tessLevelOuter, tessLevelInner);
#if OSD_FRACTIONAL_EVEN_SPACING || OSD_FRACTIONAL_ODD_SPACING
static float OsdGetTessFractionalSplit(float t, float level, float levelUp)
    // Fractional tessellation of an edge will produce n segments where n
    // is the tessellation level of the edge (level) rounded up to the
    // nearest even or odd integer (levelUp). There will be n-2 segments of
    // equal length (dx1) and two additional segments of equal length (dx0)
    // that are typically shorter than the other segments. The two additional
    // segments should be placed symmetrically on opposite sides of the
    // edge (offset).
#if OSD_FRACTIONAL_EVEN_SPACING
    if (level <= 2) return t;
    float base = pow(2.0,floor(log2(levelUp)));
    float offset = 1.0/(int(2*base-levelUp)/2 & int(base/2-1));
#elif OSD_FRACTIONAL_ODD_SPACING
    if (level <= 1) return t;
    float base = pow(2.0,floor(log2(levelUp)));
    float offset = 1.0/(((int(2*base-levelUp)/2+1) & int(base/2-1))+1);
#endif //OSD_FRACTIONAL_ODD_SPACING
    float dx0 = (1.0 - (levelUp-level)/2) / levelUp;
    float dx1 = (1.0 - 2.0*dx0) / (levelUp - 2.0*ceil(dx0));
    if (t < 0.5) {
        float x = levelUp/2 - round(t*levelUp);
        return 0.5 - (x*dx1 + int(x*offset > 1) * (dx0 - dx1));
    } else if (t > 0.5) {
        float x = round(t*levelUp) - levelUp/2;
        return 0.5 + (x*dx1 + int(x*offset > 1) * (dx0 - dx1));
    } else {
        return t;
    }
#endif //OSD_FRACTIONAL_EVEN_SPACING || OSD_FRACTIONAL_ODD_SPACING
static float OsdGetTessTransitionSplit(float t, float lo, float hi )
#if OSD_FRACTIONAL_EVEN_SPACING
  float loRoundUp = OsdRoundUpEven(lo);
  float hiRoundUp = OsdRoundUpEven(hi);
  // Convert the parametric t into a segment index along the combined edge.
  float ti = round(t * (loRoundUp + hiRoundUp));
  if (ti <= loRoundUp) {
      float t0 = ti / loRoundUp;
      return OsdGetTessFractionalSplit(t0, lo, loRoundUp) * 0.5;
   } else {
      float t1 = (ti - loRoundUp) / hiRoundUp;
      return OsdGetTessFractionalSplit(t1, hi, hiRoundUp) * 0.5 + 0.5;
    }
#elif OSD_FRACTIONAL_ODD_SPACING
  float loRoundUp = OsdRoundUpOdd(lo);
  float hiRoundUp = OsdRoundUpOdd(hi);
  // Convert the parametric t into a segment index along the combined edge.
  // The +1 below is to account for the extra segment produced by the
  // tessellator since the sum of two odd tess levels will be rounded
  // up by one to the next odd integer tess level.
  float ti = (t * (loRoundUp + hiRoundUp + 1));
  OSD_UV_CORRECTION
  ti = round(ti);
  if (ti <= loRoundUp) {
      float t0 = ti / loRoundUp;
      return OsdGetTessFractionalSplit(t0, lo, loRoundUp) * 0.5;
  } else if (ti > (loRoundUp+1)) {
      float t1 = (ti - (loRoundUp+1)) / hiRoundUp;
      return OsdGetTessFractionalSplit(t1, hi, hiRoundUp) * 0.5 + 0.5;
  } else {
      return 0.5;
#else //OSD_FRACTIONAL_ODD_SPACING
  // Convert the parametric t into a segment index along the combined edge.
  float ti = round(t * (lo + hi));
  if (ti <= lo) {
      return (ti / lo) * 0.5;
  } else {
      return ((ti - lo) / hi) * 0.5 + 0.5;
#endif //OSD_FRACTIONAL_ODD_SPACING
static float2 OsdGetTessParameterization(float2 uv, float4 tessOuterLo, float4 tessOuterHi)
    float2 UV = uv;
if (UV.x == 0 && tessOuterHi[0] > 0)
UV.y = OsdGetTessTransitionSplit(UV.y, tessOuterLo[0], tessOuterHi[0]);
else if (UV.y == 0 && tessOuterHi[1] > 0)
UV.x = OsdGetTessTransitionSplit(UV.x, tessOuterLo[1], tessOuterHi[1]);
else if (UV.x == 1 && tessOuterHi[2] > 0)
UV.y = OsdGetTessTransitionSplit(UV.y, tessOuterLo[2], tessOuterHi[2]);
else if (UV.y == 1 && tessOuterHi[3] > 0)
UV.x = OsdGetTessTransitionSplit(UV.x, tessOuterLo[3], tessOuterHi[3]);
    return UV;
static int4 OsdGetPatchCoord(int3 patchParam)
    int faceId = OsdGetPatchFaceId(patchParam);
    int faceLevel = OsdGetPatchFaceLevel(patchParam);
    int2 faceUV = OsdGetPatchFaceUV(patchParam);
    return int4(faceUV.x, faceUV.y, faceLevel, faceId);
static float4 OsdInterpolatePatchCoord(float2 localUV, int3 patchParam)
    int4 perPrimPatchCoord = OsdGetPatchCoord(patchParam);
    int faceId = perPrimPatchCoord.w;
    int faceLevel = perPrimPatchCoord.z;
    float2 faceUV = float2(perPrimPatchCoord.x, perPrimPatchCoord.y);
    float2 uv = localUV/faceLevel + faceUV/faceLevel;
    // add 0.5 to integer values for more robust interpolation
    return float4(uv.x, uv.y, faceLevel+0.5, faceId+0.5);
// ----------------------------------------------------------------------------
// GregoryBasis
// ----------------------------------------------------------------------------
static void OsdComputePerPatchVertexGregoryBasis(int3 patchParam, int ID, float3 cv,
                                     device OsdPerPatchVertexGregoryBasis& result)
    result.P = cv;
// Regular BSpline to Bezier
constant float4x4 Q(
                    float4(1.f/6.f, 4.f/6.f, 1.f/6.f, 0.f),
                    float4(0.f,     4.f/6.f, 2.f/6.f, 0.f),
                    float4(0.f,     2.f/6.f, 4.f/6.f, 0.f),
                    float4(0.f,     1.f/6.f, 4.f/6.f, 1.f/6.f)
                    );
// Infinitely Sharp (boundary)
constant float4x4 Mi(
                     float4(1.f/6.f, 4.f/6.f, 1.f/6.f, 0.f),
                     float4(0.f,     4.f/6.f, 2.f/6.f, 0.f),
                     float4(0.f,     2.f/6.f, 4.f/6.f, 0.f),
                     float4(0.f,     0.f,     1.f,     0.f)
                     );
    
static float4x4 OsdComputeMs2(float sharpness, float factor)
    float s = exp2(sharpness);
    float s2 = s*s;
    float s3 = s2*s;
    float sx6 = s*6.0;
    float sx6m2 = sx6 - 2;
    float sfrac1 = 1-s;
    float ssub1 = s-1;
    float ssub1_2 = ssub1 * ssub1;
    float div6 = 1.0/6.0;
    
    float4x4 m(
               float4(0, s + 1 + 3*s2 - s3, 7*s - 2 - 6*s2 + 2*s3,    sfrac1 * ssub1_2),
               float4(0,      1 + 2*s + s2,         sx6m2 - 2*s2,             ssub1_2),
               float4(0,               1+s,                sx6m2,              sfrac1),
               float4(0,                 1,                sx6m2,                 1));
    
    m *= factor * (1/sx6);
    
    m[0][0] = div6 * factor;
    
    return m;
// ----------------------------------------------------------------------------
// BSpline
// ----------------------------------------------------------------------------
// convert BSpline cv to Bezier cv
template<typename VertexType> //VertexType should be some type that implements float3 VertexType::GetPosition()
static void OsdComputePerPatchVertexBSpline(int3 patchParam, unsigned ID, threadgroup VertexType* cv, device OsdPerPatchVertexBezier& result)
    int i = ID%4;
    int j = ID/4;
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    float3 P  = float3(0,0,0); // 0 to 1-2^(-Sf)
    float3 P1 = float3(0,0,0); // 1-2^(-Sf) to 1-2^(-Sc)
    float3 P2 = float3(0,0,0); // 1-2^(-Sc) to 1
    float sharpness = OsdGetPatchSharpness(patchParam);
    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);
    if (sharpness > 0 && (boundaryMask & 15))
    {
        float Sf = floor(sharpness);
        float Sc = ceil(sharpness);
        float Sr = fract(sharpness);
        float4x4 Mj = OsdComputeMs2(Sf, 1-Sr);
        float4x4 Ms = Mj;
        Mj += (Sr * Mi);
        Ms += OsdComputeMs2(Sc, Sr);
#if USE_PTVS_SHARPNESS
#else
        float s0 = 1 - exp2(-Sf);
        float s1 = 1 - exp2(-Sc);
        result.vSegments = float2(s0, s1);
#endif
        
        bool isBoundary[2];
        isBoundary[0] = (((boundaryMask & 8) != 0) || ((boundaryMask & 2) != 0)) ? true : false;
        isBoundary[1] = (((boundaryMask & 4) != 0) || ((boundaryMask & 1) != 0)) ? true : false;
        bool needsFlip[2];
        needsFlip[0] = (boundaryMask & 8) ? true : false;
        needsFlip[1] = (boundaryMask & 1) ? true : false;
        float3 Hi[4], Hj[4], Hs[4];
        
        if (isBoundary[0])
        {
            int t[4] = {0,1,2,3};
            int ti = i, step = 1, start = 0;
            if (needsFlip[0]) {
                t[0] = 3; t[1] = 2; t[2] = 1; t[3] = 0;
                ti = 3-i;
                start = 3; step = -1;
            }
            for (int l=0; l<4; ++l) {
                Hi[l] = Hj[l] = Hs[l] = float3(0,0,0);
                for (int k=0, tk = start; k<4; ++k, tk+=step) {
                    float3 p = cv[l*4 + k].GetPosition();
                    Hi[l] += Mi[ti][tk] * p;
                    Hj[l] += Mj[ti][tk] * p;
                    Hs[l] += Ms[ti][tk] * p;
                }
            }
        }
        else
        {
            for (int l=0; l<4; ++l) {
                Hi[l] = Hj[l] = Hs[l] = float3(0,0,0);
                for (int k=0; k<4; ++k) {
                    float3 p = cv[l*4 + k].GetPosition();
                    float3 val = Q[i][k] * p;
                    Hi[l] += val;
                    Hj[l] += val;
                    Hs[l] += val;
                }
            }
        }
        {
            int t[4] = {0,1,2,3};
            int tj = j, step = 1, start = 0;
            if (needsFlip[1]) {
                t[0] = 3; t[1] = 2; t[2] = 1; t[3] = 0;
                tj = 3-j;
                start = 3; step = -1;
            }
            for (int k=0, tk = start; k<4; ++k, tk+=step) {
                if (isBoundary[1])
                {
                    P  += Mi[tj][tk]*Hi[k];
                    P1 += Mj[tj][tk]*Hj[k];
                    P2 += Ms[tj][tk]*Hs[k];
                }
                else
                {
                    P  += Q[j][k]*Hi[k];
                    P1 += Q[j][k]*Hj[k];
                    P2 += Q[j][k]*Hs[k];
                }
            }
        }
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    result.P  = half3(P);
    result.P1 = half3(P1);
    result.P2 = half3(P2);
#else
    result.P  = P;
    result.P1 = P1;
    result.P2 = P2;
#endif //C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    } else {
#if USE_PTVS_SHARPNESS
#else
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
        result.vSegments = half2(0, 0);
#else
        result.vSegments = float2(0, 0);
#endif //C3D_OPTIMIZE_OPENSUBDIV_STORAGE
#endif
        OsdComputeBSplineBoundaryPoints(cv, patchParam);
    float3 Hi[4];
    for (int l=0; l<4; ++l) {
        Hi[l] = float3(0,0,0);
        for (int k=0; k<4; ++k) {
            Hi[l] += Q[i][k] * cv[l*4 + k].GetPosition();
        }
    }
    for (int k=0; k<4; ++k) {
        P += Q[j][k]*Hi[k];
    }
        
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
    result.P  = half3(P);
    result.P1 = half3(P);
    result.P2 = half3(P);
#else
    result.P  = P;
    result.P1 = P;
    result.P2 = P;
#endif //C3D_OPTIMIZE_OPENSUBDIV_STORAGE
#else
    OsdComputeBSplineBoundaryPoints(cv, patchParam);
    float3 H[4];
    for (int l=0; l<4; ++l) {
        H[l] = float3(0,0,0);
        for(int k=0; k<4; ++k) {
            H[l] += Q[i][k] * (cv + l*4 + k)->GetPosition();
        }
    }
    {
        float3 P = float3(0,0,0);
        for (int k=0; k<4; ++k){
            P += Q[j][k]*H[k];
        }
#if C3D_OPTIMIZE_OPENSUBDIV_STORAGE
        result.P = half3(P);
#else
        result.P = P;
#endif
    }
#endif
template<typename PerPatchVertexBezier>
static void OsdEvalPatchBezier(int3 patchParam, float2 UV,
                   PerPatchVertexBezier cv,
                   thread float3& P, thread float3& dPu, thread float3& dPv,
                   thread float3& N, thread float3& dNu, thread float3& dNv,
                   thread float2& vSegments)
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    float B[4], D[4], C[4];
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    DUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    CUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    OsdUnivar4x4(UV.x, B, D, C);
#else
    float B[4], D[4];
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    DUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    OsdUnivar4x4(UV.x, B, D);
#endif
    // ----------------------------------------------------------------
#if OSD_PATCH_ENABLE_SINGLE_CREASE
#if USE_PTVS_SHARPNESS
    float sharpness = OsdGetPatchSharpness(patchParam);
    float Sf = floor(sharpness);
    float Sc = ceil(sharpness);
    float s0 = 1 - exp2(-Sf);
    float s1 = 1 - exp2(-Sc);
    vSegments = float2(s0, s1);
#else //USE_PTVS_SHARPNESS
    vSegments = cv[0].vSegments;
#endif //USE_PTVS_SHARPNESS
    float s = OsdGetPatchSingleCreaseSegmentParameter(patchParam, UV);
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            int k = 4*i + j;
            float3 A = (s <= vSegments.x) ? float3(cv[k].P)
            :   ((s <= vSegments.y) ?  float3(cv[k].P1)
                 :  float3(cv[k].P2));
            BUCP[i] += A * B[j];
            DUCP[i] += A * D[j];
#if OSD_COMPUTE_NORMAL_DERIVATIVES
            CUCP[i] += A * C[j];
#endif //OSD_COMPUTE_NORMAL_DERIVATIVES
        }
    }
#else //OSD_PATCH_ENABLE_SINGLE_CREASE
    // ----------------------------------------------------------------
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            float3 A = float3(cv[4*i + j].P);
            BUCP[i] += A * B[j];
            DUCP[i] += A * D[j];
#if OSD_COMPUTE_NORMAL_DERIVATIVES
            CUCP[i] += A * C[j];
#endif //OSD_COMPUTE_NORMAL_DERIVATIVES
        }
    }
#endif //OSD_PATCH_ENABLE_SINGLE_CREASE
    // ----------------------------------------------------------------
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    // used for weingarten term
    OsdUnivar4x4(UV.y, B, D, C);
    P = B[0] * BUCP[0];
    dPu = B[0] * DUCP[0];
    dPv = D[0] * BUCP[0];
    float3 dUU = B[0] * CUCP[0];
    float3 dVV = C[0] * BUCP[0];
    float3 dUV = D[0] * DUCP[0];
    for (int k=1; k<4; ++k) {
        P   += B[k] * BUCP[k];
        dPu += B[k] * DUCP[k];
        dPv += D[k] * BUCP[k];
        dUU += B[k] * CUCP[k];
        dVV += C[k] * BUCP[k];
        dUV += D[k] * DUCP[k];
    }
    int level = OsdGetPatchFaceLevel(patchParam);
    dPu *= 3 * level;
    dPv *= 3 * level;
    dUU *= 6 * level;
    dVV *= 6 * level;
    dUV *= 9 * level;
    float3 n = cross(dPu, dPv);
    float ln = 1.0 / length(n);
    N = ln * n;
    float E = dot(dPu, dPu);
    float F = dot(dPu, dPv);
    float G = dot(dPv, dPv);
    float e = dot(N, dUU);
    float f = dot(N, dUV);
    float g = dot(N, dVV);
    float EGFF = 1.0 / (E*G - F*F);
    dNu = (f*F-e*G) * EGFF * dPu + (e*F-f*E) * EGFF * dPv;
    dNv = (g*F-f*G) * EGFF * dPu + (f*F-g*E) * EGFF * dPv;
    float powrn = 1.0 / powr(dot(n,n), 1.5);
    dNu = dNu * ln - n * (dot(dNu,n) * powrn);
    dNv = dNv * ln - n * (dot(dNv,n) * powrn);
#else //OSD_COMPUTE_NORMAL_DERIVATIVES
    OsdUnivar4x4(UV.y, B, D);
    P = B[0] * BUCP[0];
    dPu = B[0] * DUCP[0];
    dPv = D[0] * BUCP[0];
    for (int k=1; k<4; ++k) {
        P   += B[k] * BUCP[k];
        dPu += B[k] * DUCP[k];
        dPv += D[k] * BUCP[k];
    }
    int level = OsdGetPatchFaceLevel(patchParam);
    dPu *= 3 * level;
    dPv *= 3 * level;
    N = normalize(cross(dPu, dPv));
    dNu = float3(0,0,0);
    dNv = float3(0,0,0);
#endif //OSD_COMPUTE_NORMAL_DERIVATIVES
// compute single-crease patch matrix
static float4x4 OsdComputeMs(float sharpness)
    float s = exp2(sharpness);
    float s2 = s*s;
    float s3 = s2*s;
    float4x4 m(
        float4(0, s + 1 + 3*s2 - s3, 7*s - 2 - 6*s2 + 2*s3, (1-s)*(s-1)*(s-1)),
        float4(0,       (1+s)*(1+s),        6*s - 2 - 2*s2,       (s-1)*(s-1)),
        float4(0,               1+s,               6*s - 2,               1-s),
        float4(0,                 1,               6*s - 2,                 1));
    m[0] /= (s*6.0);
    m[1] /= (s*6.0);
    m[2] /= (s*6.0);
    m[3] /= (s*6.0);
    m[0][0] = 1.0/6.0;
    return m;
// flip matrix orientation
static float4x4 OsdFlipMatrix(float4x4 m)
    return float4x4(float4(m[3][3], m[3][2], m[3][1], m[3][0]),
                    float4(m[2][3], m[2][2], m[2][1], m[2][0]),
                    float4(m[1][3], m[1][2], m[1][1], m[1][0]),
                    float4(m[0][3], m[0][2], m[0][1], m[0][0]));
static void OsdFlipMatrix(threadgroup float * src, threadgroup float * dst)
    for (int i = 0; i < 16; i++) dst[i] = src[15-i];
// ----------------------------------------------------------------------------
// Legacy Gregory
// ----------------------------------------------------------------------------
#if OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY
#if OSD_MAX_VALENCE<=10
constant float ef[7] = {
    0.813008, 0.500000, 0.363636, 0.287505,
    0.238692, 0.204549, 0.179211
#else
constant float ef[27] = {
    0.812816, 0.500000, 0.363644, 0.287514,
    0.238688, 0.204544, 0.179229, 0.159657,
    0.144042, 0.131276, 0.120632, 0.111614,
    0.103872, 0.09715, 0.0912559, 0.0860444,
    0.0814022, 0.0772401, 0.0734867, 0.0700842,
    0.0669851, 0.0641504, 0.0615475, 0.0591488,
    0.0569311, 0.0548745, 0.0529621
#endif
static float cosfn(int n, int j) {
    return cospi((2.0f * j)/float(n));
static float sinfn(int n, int j) {
    return sinpi((2.0f * j)/float(n));
#ifndef OSD_MAX_VALENCE
#define OSD_MAX_VALENCE 4
#endif
template<typename OsdVertexBuffer>
static float3 OsdReadVertex(int vertexIndex, OsdVertexBuffer osdVertexBuffer)
    int index = (vertexIndex /*+ OsdBaseVertex()*/);
    return osdVertexBuffer[index].position;
template<typename OsdValenceBuffer>
static int OsdReadVertexValence(int vertexID, OsdValenceBuffer osdValenceBuffer)
    int index = int(vertexID * (2 * OSD_MAX_VALENCE + 1));
    return osdValenceBuffer[index];
template<typename OsdValenceBuffer>
static int OsdReadVertexIndex(int vertexID, int valenceVertex, OsdValenceBuffer osdValenceBuffer)
    int index = int(vertexID * (2 * OSD_MAX_VALENCE + 1) + 1 + valenceVertex);
    return osdValenceBuffer[index];
template<typename OsdQuadOffsetBuffer>
static int OsdReadQuadOffset(int primitiveID, int offsetVertex, OsdQuadOffsetBuffer osdQuadOffsetBuffer)
    int index = int(4*primitiveID + offsetVertex);
    return osdQuadOffsetBuffer[index];
static void OsdComputePerVertexGregory(unsigned vID, float3 P, threadgroup OsdPerVertexGregory& v, OsdPatchParamBufferSet osdBuffers)
    v.clipFlag = short3(0,0,0);
    int ivalence = OsdReadVertexValence(vID, osdBuffers.valenceBuffer);
    v.valence = ivalence;
    int valence = abs(ivalence);
    float3 f[OSD_MAX_VALENCE];
    float3 pos = P;
    float3 opos = float3(0,0,0);
#if OSD_PATCH_GREGORY_BOUNDARY
    v.org = pos;
    int boundaryEdgeNeighbors[2];
    int currNeighbor = 0;
    int ibefore = 0;
    int zerothNeighbor = 0;
#endif
    for (int i=0; i<valence; ++i) {
        int im = (i+valence-1)%valence;
        int ip = (i+1)%valence;
        int idx_neighbor = OsdReadVertexIndex(vID, 2*i, osdBuffers.valenceBuffer);
#if OSD_PATCH_GREGORY_BOUNDARY
        bool isBoundaryNeighbor = false;
        int valenceNeighbor = OsdReadVertexValence(idx_neighbor, osdBuffers.valenceBuffer);
        if (valenceNeighbor < 0) {
            isBoundaryNeighbor = true;
            if (currNeighbor<2) {
                boundaryEdgeNeighbors[currNeighbor] = idx_neighbor;
            }
            currNeighbor++;
            if (currNeighbor == 1) {
                ibefore = i;
                zerothNeighbor = i;
            } else {
                if (i-ibefore == 1) {
                    int tmp = boundaryEdgeNeighbors[0];
                    boundaryEdgeNeighbors[0] = boundaryEdgeNeighbors[1];
                    boundaryEdgeNeighbors[1] = tmp;
                    zerothNeighbor = i;
                }
            }
        }
#endif
        float3 neighbor = OsdReadVertex(idx_neighbor, osdBuffers.vertexBuffer);
        int idx_diagonal = OsdReadVertexIndex(vID, 2*i + 1, osdBuffers.valenceBuffer);
        float3 diagonal = OsdReadVertex(idx_diagonal, osdBuffers.vertexBuffer);
        int idx_neighbor_p = OsdReadVertexIndex(vID, 2*ip, osdBuffers.valenceBuffer);
        float3 neighbor_p = OsdReadVertex(idx_neighbor_p, osdBuffers.vertexBuffer);
        int idx_neighbor_m = OsdReadVertexIndex(vID, 2*im, osdBuffers.valenceBuffer);
        float3 neighbor_m = OsdReadVertex(idx_neighbor_m, osdBuffers.vertexBuffer);
        int idx_diagonal_m = OsdReadVertexIndex(vID, 2*im + 1, osdBuffers.valenceBuffer);
        float3 diagonal_m = OsdReadVertex(idx_diagonal_m, osdBuffers.vertexBuffer);
        f[i] = (pos * float(valence) + (neighbor_p + neighbor)*2.0f + diagonal) / (float(valence)+5.0f);
        opos += f[i];
        v.r[i] = (neighbor_p-neighbor_m)/3.0f + (diagonal - diagonal_m)/6.0f;
    }
    opos /= valence;
    v.P = float4(opos, 1.0f).xyz;
    float3 e;
    v.e0 = float3(0,0,0);
    v.e1 = float3(0,0,0);
    for(int i=0; i<valence; ++i) {
        int im = (i + valence -1) % valence;
        e = 0.5f * (f[i] + f[im]);
        v.e0 += cosfn(valence, i)*e;
        v.e1 += sinfn(valence, i)*e;
    }
    v.e0 *= ef[valence - 3];
    v.e1 *= ef[valence - 3];
#if OSD_PATCH_GREGORY_BOUNDARY
    v.zerothNeighbor = zerothNeighbor;
    if (currNeighbor == 1) {
        boundaryEdgeNeighbors[1] = boundaryEdgeNeighbors[0];
    }
    if (ivalence < 0) {
        if (valence > 2) {
            v.P = (OsdReadVertex(boundaryEdgeNeighbors[0], osdBuffers.vertexBuffer) +
                   OsdReadVertex(boundaryEdgeNeighbors[1], osdBuffers.vertexBuffer) +
                   4.0f * pos)/6.0f;
        } else {
            v.P = pos;
        }
        v.e0 = (OsdReadVertex(boundaryEdgeNeighbors[0], osdBuffers.vertexBuffer) -
                OsdReadVertex(boundaryEdgeNeighbors[1], osdBuffers.vertexBuffer))/6.0;
        float k = float(float(valence) - 1.0f);    //k is the number of faces
        float c = cospi(1.0/k);
        float s = sinpi(1.0/k);
        float gamma = -(4.0f*s)/(3.0f*k+c);
        float alpha_0k = -((1.0f+2.0f*c)*sqrt(1.0f+c))/((3.0f*k+c)*sqrt(1.0f-c));
        float beta_0 = s/(3.0f*k + c);
        int idx_diagonal = OsdReadVertexIndex(vID, 2*zerothNeighbor + 1, osdBuffers.valenceBuffer);
        float3 diagonal = OsdReadVertex(idx_diagonal, osdBuffers.vertexBuffer);
        v.e1 = gamma * pos +
            alpha_0k * OsdReadVertex(boundaryEdgeNeighbors[0], osdBuffers.vertexBuffer) +
            alpha_0k * OsdReadVertex(boundaryEdgeNeighbors[1], osdBuffers.vertexBuffer) +
            beta_0 * diagonal;
        for (int x=1; x<valence - 1; ++x) {
            int curri = ((x + zerothNeighbor)%valence);
            float alpha = (4.0f*sinpi((float(x))/k))/(3.0f*k+c);
            float beta = (sinpi((float(x))/k) + sinpi((float(x+1))/k))/(3.0f*k+c);
            int idx_neighbor = OsdReadVertexIndex(vID, 2*curri, osdBuffers.valenceBuffer);
            float3 neighbor = OsdReadVertex(idx_neighbor, osdBuffers.vertexBuffer);
            idx_diagonal = OsdReadVertexIndex(vID, 2*curri + 1, osdBuffers.valenceBuffer);
            diagonal = OsdReadVertex(idx_diagonal, osdBuffers.vertexBuffer);
            v.e1 += alpha * neighbor + beta * diagonal;
        }
        v.e1 /= 3.0f;
    }
#endif
static void OsdComputePerPatchVertexGregory(int3 patchParam, unsigned ID, unsigned primitiveID,
                                threadgroup OsdPerVertexGregory* v,
                                device OsdPerPatchVertexGregory& result,
                                OsdPatchParamBufferSet osdBuffers)
    result.P = v[ID].P;
    int i = ID;
    int ip = (i+1)%4;
    int im = (i+3)%4;
    int valence = abs(v[i].valence);
    int n = valence;
    int start = OsdReadQuadOffset(primitiveID, i, osdBuffers.quadOffsetBuffer) & 0xff;
    int prev = (OsdReadQuadOffset(primitiveID, i, osdBuffers.quadOffsetBuffer) >> 8) & 0xff;
    int start_m = OsdReadQuadOffset(primitiveID, im, osdBuffers.quadOffsetBuffer) & 0xff;
    int prev_p = (OsdReadQuadOffset(primitiveID, ip, osdBuffers.quadOffsetBuffer) >> 8) & 0xff;
    int np = abs(v[ip].valence);
    int nm = abs(v[im].valence);
    // Control Vertices based on :
    // "Approximating Subdivision Surfaces with Gregory Patches
    //  for Hardware Tessellation"
    // Loop, Schaefer, Ni, Castano (ACM ToG Siggraph Asia 2009)
    //
    //  P3         e3-      e2+         P2
    //     O--------O--------O--------O
    //     |        |        |        |
    //     |        |        |        |
    //     |        | f3-    | f2+    |
    //     |        O        O        |
    // e3+ O------O            O------O e2-
    //     |     f3+          f2-     |
    //     |                          |
    //     |                          |
    //     |      f0-         f1+     |
    // e0- O------O            O------O e1+
    //     |        O        O        |
    //     |        | f0+    | f1-    |
    //     |        |        |        |
    //     |        |        |        |
    //     O--------O--------O--------O
    //  P0         e0+      e1-         P1
    //
#if OSD_PATCH_GREGORY_BOUNDARY
    float3 Em_ip;
    if (v[ip].valence < -2) {
        int j = (np + prev_p - v[ip].zerothNeighbor) % np;
        Em_ip = v[ip].P + cospi(j/float(np-1))*v[ip].e0 + sinpi(j/float(np-1))*v[ip].e1;
    } else {
        Em_ip = v[ip].P + v[ip].e0*cosfn(np, prev_p) + v[ip].e1*sinfn(np, prev_p);
    }
    float3 Ep_im;
    if (v[im].valence < -2) {
        int j = (nm + start_m - v[im].zerothNeighbor) % nm;
        Ep_im = v[im].P + cospi(j/float(nm-1))*v[im].e0 + sinpi(j/float(nm-1))*v[im].e1;
    } else {
        Ep_im = v[im].P + v[im].e0*cosfn(nm, start_m) + v[im].e1*sinfn(nm, start_m);
    }
    if (v[i].valence < 0) {
        n = (n-1)*2;
    }
    if (v[im].valence < 0) {
        nm = (nm-1)*2;
    }
    if (v[ip].valence < 0) {
        np = (np-1)*2;
    }
    if (v[i].valence > 2) {
        result.Ep = v[i].P + (v[i].e0*cosfn(n, start) + v[i].e1*sinfn(n, start));
        result.Em = v[i].P + (v[i].e0*cosfn(n, prev) +  v[i].e1*sinfn(n, prev));
        float s1=3-2*cosfn(n,1)-cosfn(np,1);
        float s2=2*cosfn(n,1);
        result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;
        s1 = 3.0f-2.0f*cospi(2.0f/float(n))-cospi(2.0f/float(nm));
        result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;
    } else if (v[i].valence < -2) {
        int j = (valence + start - v[i].zerothNeighbor) % valence;
        result.Ep = v[i].P + cospi(j/float(valence-1))*v[i].e0 + sinpi(j/float(valence-1))*v[i].e1;
        j = (valence + prev - v[i].zerothNeighbor) % valence;
        result.Em = v[i].P + cospi(j/float(valence-1))*v[i].e0 + sinpi(j/float(valence-1))*v[i].e1;
        float3 Rp = ((-2.0f * v[i].org - 1.0f * v[im].org) + (2.0f * v[ip].org + 1.0f * v[(i+2)%4].org))/3.0f;
        float3 Rm = ((-2.0f * v[i].org - 1.0f * v[ip].org) + (2.0f * v[im].org + 1.0f * v[(i+2)%4].org))/3.0f;
        float s1 = 3-2*cosfn(n,1)-cosfn(np,1);
        float s2 = 2*cosfn(n,1);
        result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;
        s1 = 3.0f-2.0f*cospi(2.0f/float(n))-cospi(2.0f/float(nm));
        result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;
        if (v[im].valence < 0) {
            s1 = 3-2*cosfn(n,1)-cosfn(np,1);
            result.Fp = result.Fm = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;
        } else if (v[ip].valence < 0) {
            s1 = 3.0f-2.0f*cospi(2.0f/n)-cospi(2.0f/nm);
            result.Fm = result.Fp = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;
        }
    } else if (v[i].valence == -2) {
        result.Ep = (2.0f * v[i].org + v[ip].org)/3.0f;
        result.Em = (2.0f * v[i].org + v[im].org)/3.0f;
        result.Fp = result.Fm = (4.0f * v[i].org + v[(i+2)%n].org + 2.0f * v[ip].org + 2.0f * v[im].org)/9.0f;
    }
#else // not OSD_PATCH_GREGORY_BOUNDARY
    result.Ep = v[i].P + v[i].e0 * cosfn(n, start) + v[i].e1*sinfn(n, start);
    result.Em = v[i].P + v[i].e0 * cosfn(n, prev ) + v[i].e1*sinfn(n, prev );
    float3 Em_ip = v[ip].P + v[ip].e0*cosfn(np, prev_p) + v[ip].e1*sinfn(np, prev_p);
    float3 Ep_im = v[im].P + v[im].e0*cosfn(nm, start_m) + v[im].e1*sinfn(nm, start_m);
    float s1 = 3-2*cosfn(n,1)-cosfn(np,1);
    float s2 = 2*cosfn(n,1);
    result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;
    s1 = 3.0f-2.0f*cospi(2.0f/float(n))-cospi(2.0f/float(nm));
    result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em +s2*Ep_im - v[i].r[prev])/3.0f;
#endif
#endif  // OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY
//   Copyright 2016 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
#ifndef OPENSUBDIV3_OSD_PATCH_BASIS_COMMON_H
#define OPENSUBDIV3_OSD_PATCH_BASIS_COMMON_H
#if defined(OSD_PATCH_BASIS_GLSL)
    #define OSD_FUNCTION_STORAGE_CLASS
    #define OSD_DATA_STORAGE_CLASS
    #define OSD_OPTIONAL(a) true
    #define OSD_OPTIONAL_INIT(a,b) b
    #define OSD_OUT out
    #define OSD_INOUT inout
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             elementType[](a0,a1,a2,a3,a4,a5,a6,a7)
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             elementType[](a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)
#elif defined(OSD_PATCH_BASIS_HLSL)
    #define OSD_FUNCTION_STORAGE_CLASS
    #define OSD_DATA_STORAGE_CLASS
    #define OSD_OPTIONAL(a) true
    #define OSD_OPTIONAL_INIT(a,b) b
    #define OSD_OUT out
    #define OSD_INOUT inout
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             {a0,a1,a2,a3,a4,a5,a6,a7}
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}
#elif defined(OSD_PATCH_BASIS_CUDA)
    #define OSD_FUNCTION_STORAGE_CLASS __device__
    #define OSD_DATA_STORAGE_CLASS
    #define OSD_OPTIONAL(a) true
    #define OSD_OPTIONAL_INIT(a,b) b
    #define OSD_OUT
    #define OSD_INOUT
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             {a0,a1,a2,a3,a4,a5,a6,a7}
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}
#elif defined(OSD_PATCH_BASIS_OPENCL)
    #define OSD_FUNCTION_STORAGE_CLASS static
    #define OSD_DATA_STORAGE_CLASS
    #define OSD_OPTIONAL(a) true
    #define OSD_OPTIONAL_INIT(a,b) b
    #define OSD_OUT
    #define OSD_INOUT
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             {a0,a1,a2,a3,a4,a5,a6,a7}
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}
#elif defined(OSD_PATCH_BASIS_METAL)
    #define OSD_FUNCTION_STORAGE_CLASS static
    #define OSD_DATA_STORAGE_CLASS
    #define OSD_OPTIONAL(a) true
    #define OSD_OPTIONAL_INIT(a,b) b
    #define OSD_OUT
    #define OSD_INOUT
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) thread elementType* identifier
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             {a0,a1,a2,a3,a4,a5,a6,a7}
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}
#else
    #define OSD_FUNCTION_STORAGE_CLASS static inline
    #define OSD_DATA_STORAGE_CLASS static
    #define OSD_OPTIONAL(a) (a)
    #define OSD_OPTIONAL_INIT(a,b) (a ? b : 0)
    #define OSD_OUT
    #define OSD_INOUT
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             {a0,a1,a2,a3,a4,a5,a6,a7}
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}
#endif
OSD_FUNCTION_STORAGE_CLASS
void
OsdGetBezierWeights(
    float t, OSD_TYPE_ARRAY(OSD_OUT float, wP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDP2, 4)) {
    // The four uniform cubic Bezier basis functions (in terms of t and its
    // complement tC) evaluated at t:
    float t2 = t*t;
    float tC = 1.0f - t;
    float tC2 = tC * tC;
    wP[0] = tC2 * tC;
    wP[1] = tC2 * t * 3.0f;
    wP[2] = t2 * tC * 3.0f;
    wP[3] = t2 * t;
    // Derivatives of the above four basis functions at t:
    if (OSD_OPTIONAL(wDP)) {
       wDP[0] = -3.0f * tC2;
       wDP[1] =  9.0f * t2 - 12.0f * t + 3.0f;
       wDP[2] = -9.0f * t2 +  6.0f * t;
       wDP[3] =  3.0f * t2;
    }
    // Second derivatives of the basis functions at t:
    if (OSD_OPTIONAL(wDP2)) {
        wDP2[0] =   6.0f * tC;
        wDP2[1] =  18.0f * t - 12.0f;
        wDP2[2] = -18.0f * t +  6.0f;
        wDP2[3] =   6.0f * t;
    }
OSD_FUNCTION_STORAGE_CLASS
void
OsdGetBSplineWeights(
    float t, OSD_TYPE_ARRAY(OSD_OUT float, wP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDP2, 4)) {
    // The four uniform cubic B-Spline basis functions evaluated at t:
    const float one6th = 1.0f / 6.0f;
    float t2 = t * t;
    float t3 = t * t2;
    wP[0] = one6th * (1.0f - 3.0f*(t -      t2) -      t3);
    wP[1] = one6th * (4.0f           - 6.0f*t2  + 3.0f*t3);
    wP[2] = one6th * (1.0f + 3.0f*(t +      t2  -      t3));
    wP[3] = one6th * (                                 t3);
    // Derivatives of the above four basis functions at t:
    if (OSD_OPTIONAL(wDP)) {
        wDP[0] = -0.5f*t2 +      t - 0.5f;
        wDP[1] =  1.5f*t2 - 2.0f*t;
        wDP[2] = -1.5f*t2 +      t + 0.5f;
        wDP[3] =  0.5f*t2;
    }
    // Second derivatives of the basis functions at t:
    if (OSD_OPTIONAL(wDP2)) {
        wDP2[0] = -       t + 1.0f;
        wDP2[1] =  3.0f * t - 2.0f;
        wDP2[2] = -3.0f * t + 1.0f;
        wDP2[3] =         t;
    }
OSD_FUNCTION_STORAGE_CLASS
void
OsdGetBoxSplineWeights(float v, float w, OSD_TYPE_ARRAY(OSD_OUT float, wP, 12)) {
    float u = 1.0f - v - w;
    //
    //  The 12 basis functions of the quartic box spline (unscaled by their common
    //  factor of 1/12 until later, and formatted to make it easy to spot any
    //  typing errors):
    //
    //      15 terms for the 3 points above the triangle corners
    //       9 terms for the 3 points on faces opposite the triangle edges
    //       2 terms for the 6 points on faces opposite the triangle corners
    //
    //  Powers of each variable for notational convenience:
    float u2 = u*u;
    float u3 = u*u2;
    float u4 = u*u3;
    float v2 = v*v;
    float v3 = v*v2;
    float v4 = v*v3;
    float w2 = w*w;
    float w3 = w*w2;
    float w4 = w*w3;
    //  And now the basis functions:
    wP[ 0] = u4 + 2.0f*u3*v;
    wP[ 1] = u4 + 2.0f*u3*w;
    wP[ 8] = w4 + 2.0f*w3*u;
    wP[11] = w4 + 2.0f*w3*v;
    wP[ 9] = v4 + 2.0f*v3*w;
    wP[ 5] = v4 + 2.0f*v3*u;
    wP[ 2] = u4 + 2.0f*u3*w + 6.0f*u3*v + 6.0f*u2*v*w + 12.0f*u2*v2 +
                v4 + 2.0f*v3*w + 6.0f*v3*u + 6.0f*v2*u*w;
    wP[ 4] = w4 + 2.0f*w3*v + 6.0f*w3*u + 6.0f*w2*u*v + 12.0f*w2*u2 +
                u4 + 2.0f*u3*v + 6.0f*u3*w + 6.0f*u2*v*w;
    wP[10] = v4 + 2.0f*v3*u + 6.0f*v3*w + 6.0f*v2*w*u + 12.0f*v2*w2 +
                w4 + 2.0f*w3*u + 6.0f*w3*v + 6.0f*w3*u*v;
    wP[ 3] = v4 + 6*v3*w + 8*v3*u + 36*v2*w*u + 24*v2*u2 + 24*v*u3 +
                w4 + 6*w3*v + 8*w3*u + 36*w2*v*u + 24*w2*u2 + 24*w*u3 + 6*u4 + 60*u2*v*w + 12*v2*w2;
    wP[ 6] = w4 + 6*w3*u + 8*w3*v + 36*w2*u*v + 24*w2*v2 + 24*w*v3 +
                u4 + 6*u3*w + 8*u3*v + 36*u2*v*w + 24*u2*v2 + 24*u*v3 + 6*v4 + 60*v2*w*u + 12*w2*u2;
    wP[ 7] = u4 + 6*u3*v + 8*u3*w + 36*u2*v*w + 24*u2*w2 + 24*u*w3 +
                v4 + 6*v3*u + 8*v3*w + 36*v2*u*w + 24*v2*w2 + 24*v*w3 + 6*w4 + 60*w2*u*v + 12*u2*v2;
    for (int i = 0; i < 12; ++i) {
        wP[i] *= 1.0f / 12.0f;
    }
OSD_FUNCTION_STORAGE_CLASS
void
OsdGetBilinearPatchWeights(
        float s, float t, float dScale,
        OSD_TYPE_ARRAY(OSD_OUT float, wP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDs, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDt, 4),
        OSD_TYPE_ARRAY(OSD_OUT float, wDss, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDst, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDtt, 4)) {
    float sC = 1.0f - s,
          tC = 1.0f - t;
    if (OSD_OPTIONAL(wP)) {
        wP[0] = sC * tC;
        wP[1] =  s * tC;
        wP[2] =  s * t;
        wP[3] = sC * t;
    }
    if (OSD_OPTIONAL(derivS && derivT)) {
        wDs[0] = -tC * dScale;
        wDs[1] =  tC * dScale;
        wDs[2] =   t * dScale;
        wDs[3] =  -t * dScale;
        wDt[0] = -sC * dScale;
        wDt[1] =  -s * dScale;
        wDt[2] =   s * dScale;
        wDt[3] =  sC * dScale;
        if (OSD_OPTIONAL(derivSS && derivST && derivTT)) {
            float d2Scale = dScale * dScale;
            for(int i=0;i<4;i++) {
                wDss[i] = 0;
                wDtt[i] = 0;
            }
            wDst[0] =  d2Scale;
            wDst[1] = -d2Scale;
            wDst[2] = -d2Scale;
            wDst[3] =  d2Scale;
        }
    }
OSD_FUNCTION_STORAGE_CLASS
void OsdAdjustBoundaryWeights(
        int boundary,
        OSD_TYPE_ARRAY(OSD_INOUT float, sWeights, 4), OSD_TYPE_ARRAY(OSD_INOUT float, tWeights, 4)) {
    if ((boundary & 1) != 0) {
        tWeights[2] -= tWeights[0];
        tWeights[1] += 2*tWeights[0];
        tWeights[0] = 0;
    }
    if ((boundary & 2) != 0) {
        sWeights[1] -= sWeights[3];
        sWeights[2] += 2*sWeights[3];
        sWeights[3] = 0;
    }
    if ((boundary & 4) != 0) {
        tWeights[1] -= tWeights[3];
        tWeights[2] += 2*tWeights[3];
        tWeights[3] = 0;
    }
    if ((boundary & 8) != 0) {
        sWeights[2] -= sWeights[0];
        sWeights[1] += 2*sWeights[0];
        sWeights[0] = 0;
    }
OSD_FUNCTION_STORAGE_CLASS
void OsdComputeTensorProductPatchWeights(float dScale, int boundary,
    OSD_TYPE_ARRAY(float, sWeights, 4), OSD_TYPE_ARRAY(float, tWeights, 4),
    OSD_TYPE_ARRAY(float, dsWeights, 4), OSD_TYPE_ARRAY(float, dtWeights, 4),
    OSD_TYPE_ARRAY(float, dssWeights, 4), OSD_TYPE_ARRAY(float, dttWeights, 4),
    OSD_TYPE_ARRAY(OSD_OUT float, wP, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDs, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDt, 16),
    OSD_TYPE_ARRAY(OSD_OUT float, wDss, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDst, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDtt, 16)) {
    if (OSD_OPTIONAL(wP)) {
        // Compute the tensor product weight of the (s,t) basis function
        // corresponding to each control vertex:
        OsdAdjustBoundaryWeights(boundary, sWeights, tWeights);
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                wP[4*i+j] = sWeights[j] * tWeights[i];
            }
        }
    }
    if (OSD_OPTIONAL(derivS && derivT)) {
        // Compute the tensor product weight of the differentiated (s,t) basis
        // function corresponding to each control vertex (scaled accordingly):
        OsdAdjustBoundaryWeights(boundary, dsWeights, dtWeights);
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                wDs[4*i+j] = dsWeights[j] * tWeights[i] * dScale;
                wDt[4*i+j] = sWeights[j] * dtWeights[i] * dScale;
            }
        }
        if (OSD_OPTIONAL(derivSS && derivST && derivTT)) {
            // Compute the tensor product weight of appropriate differentiated
            // (s,t) basis functions for each control vertex (scaled accordingly):
            float d2Scale = dScale * dScale;
            OsdAdjustBoundaryWeights(boundary, dssWeights, dttWeights);
            for (int i = 0; i < 4; ++i) {
                for (int j = 0; j < 4; ++j) {
                    wDss[4*i+j] = dssWeights[j] * tWeights[i] * d2Scale;
                    wDst[4*i+j] = dsWeights[j] * dtWeights[i] * d2Scale;
                    wDtt[4*i+j] = sWeights[j] * dttWeights[i] * d2Scale;
                }
            }
        }
    }
OSD_FUNCTION_STORAGE_CLASS
void OsdGetBezierPatchWeights(
    float s, float t, float dScale,
    OSD_TYPE_ARRAY(OSD_OUT float, wP, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDS, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDT, 16),
    OSD_TYPE_ARRAY(OSD_OUT float, wDSS, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDST, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDTT, 16)) {
    float sWeights[4], tWeights[4], dsWeights[4], dtWeights[4], dssWeights[4], dttWeights[4];
    OsdGetBezierWeights(s, OSD_OPTIONAL_INIT(wP, sWeights), OSD_OPTIONAL_INIT(wDS, dsWeights), OSD_OPTIONAL_INIT(wDSS, dssWeights));
    OsdGetBezierWeights(t, OSD_OPTIONAL_INIT(wP, tWeights), OSD_OPTIONAL_INIT(wDT, dtWeights), OSD_OPTIONAL_INIT(wDTT, dttWeights));
    OsdComputeTensorProductPatchWeights(dScale, /*boundary=*/0, sWeights, tWeights, dsWeights, dtWeights, dssWeights, dttWeights, wP, wDS, wDT, wDSS, wDST, wDTT);
OSD_FUNCTION_STORAGE_CLASS
void OsdGetBSplinePatchWeights(
    float s, float t, float dScale, int boundary,
    OSD_TYPE_ARRAY(OSD_OUT float, wP, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDs, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDt, 16),
    OSD_TYPE_ARRAY(OSD_OUT float, wDss, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDst, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDtt, 16)) {
    float sWeights[4], tWeights[4], dsWeights[4], dtWeights[4], dssWeights[4], dttWeights[4];
    OsdGetBSplineWeights(s, sWeights, OSD_OPTIONAL_INIT(wDS, dsWeights), OSD_OPTIONAL_INIT(wDSS, dssWeights));
    OsdGetBSplineWeights(t, tWeights, OSD_OPTIONAL_INIT(wDT, dtWeights), OSD_OPTIONAL_INIT(wDTT, dttWeights));
    OsdComputeTensorProductPatchWeights(dScale, boundary, sWeights, tWeights, dsWeights, dtWeights, dssWeights, dttWeights, wP, wDs, wDt, wDss, wDst, wDtt);
OSD_FUNCTION_STORAGE_CLASS
void OsdGetGregoryPatchWeights(
    float s, float t, float dScale,
    OSD_TYPE_ARRAY(OSD_OUT float, wP, 20), OSD_TYPE_ARRAY(OSD_OUT float, wDs, 20), OSD_TYPE_ARRAY(OSD_OUT float, wDt, 20),
    OSD_TYPE_ARRAY(OSD_OUT float, wDss, 20), OSD_TYPE_ARRAY(OSD_OUT float, wDst, 20), OSD_TYPE_ARRAY(OSD_OUT float, wDtt, 20)) {
    //
    //  P3         e3-      e2+         P2
    //     15------17-------11--------10
    //     |        |        |        |
    //     |        |        |        |
    //     |        | f3-    | f2+    |
    //     |       19       13        |
    // e3+ 16-----18           14-----12 e2-
    //     |     f3+          f2-     |
    //     |                          |
    //     |                          |
    //     |      f0-         f1+     |
    // e0- 2------4            8------6 e1+
    //     |        3        9        |
    //     |        | f0+    | f1-    |
    //     |        |        |        |
    //     |        |        |        |
    //     O--------1--------7--------5
    //  P0         e0+      e1-         P1
    //
    //  Indices of boundary and interior points and their corresponding Bezier points
    //  (this can be reduced with more direct indexing and unrolling of loops):
    //
    OSD_DATA_STORAGE_CLASS const int boundaryGregory[12] = OSD_ARRAY_12(int, 0, 1, 7, 5, 2, 6, 16, 12, 15, 17, 11, 10 );
    OSD_DATA_STORAGE_CLASS const int boundaryBezSCol[12] = OSD_ARRAY_12(int, 0, 1, 2, 3, 0, 3,  0,  3,  0,  1,  2,  3 );
    OSD_DATA_STORAGE_CLASS const int boundaryBezTRow[12] = OSD_ARRAY_12(int, 0, 0, 0, 0, 1, 1,  2,  2,  3,  3,  3,  3 );
    OSD_DATA_STORAGE_CLASS const int interiorGregory[8] = OSD_ARRAY_8(int, 3, 4,  8, 9,  13, 14,  18, 19 );
    OSD_DATA_STORAGE_CLASS const int interiorBezSCol[8] = OSD_ARRAY_8(int, 1, 1,  2, 2,   2,  2,   1,  1 );
    OSD_DATA_STORAGE_CLASS const int interiorBezTRow[8] = OSD_ARRAY_8(int, 1, 1,  1, 1,   2,  2,   2,  2 );
    //
    //  Bezier basis functions are denoted with B while the rational multipliers for the
    //  interior points will be denoted G -- so we have B(s), B(t) and G(s,t):
    //
    //  Directional Bezier basis functions B at s and t:
    float Bs[4], Bds[4], Bdss[4];
    float Bt[4], Bdt[4], Bdtt[4];
    OsdGetBezierWeights(s, Bs, OSD_OPTIONAL_INIT(wDs, Bds), OSD_OPTIONAL_INIT(wDss, Bdss));
    OsdGetBezierWeights(t, Bt, OSD_OPTIONAL_INIT(wDt, Bdt), OSD_OPTIONAL_INIT(wDtt, Bdtt));
    //  Rational multipliers G at s and t:
    float sC = 1.0f - s;
    float tC = 1.0f - t;
    //  Use <= here to avoid compiler warnings -- the sums should always be non-negative:
    float df0 = s  + t;   df0 = (df0 <= 0.0f) ? 1.0f : (1.0f / df0);
    float df1 = sC + t;   df1 = (df1 <= 0.0f) ? 1.0f : (1.0f / df1);
    float df2 = sC + tC;  df2 = (df2 <= 0.0f) ? 1.0f : (1.0f / df2);
    float df3 = s  + tC;  df3 = (df3 <= 0.0f) ? 1.0f : (1.0f / df3);
    float G[8] = OSD_ARRAY_8(float, s*df0, t*df0,  t*df1, sC*df1,  sC*df2, tC*df2,  tC*df3, s*df3 );
    //  Combined weights for boundary and interior points:
    for (int i = 0; i < 12; ++i) {
        wP[boundaryGregory[i]] = Bs[boundaryBezSCol[i]] * Bt[boundaryBezTRow[i]];
    }
    for (int i = 0; i < 8; ++i) {
        wP[interiorGregory[i]] = Bs[interiorBezSCol[i]] * Bt[interiorBezTRow[i]] * G[i];
    }
    //
    //  For derivatives, the basis functions for the interior points are rational and ideally
    //  require appropriate differentiation, i.e. product rule for the combination of B and G
    //  and the quotient rule for the rational G itself.  As initially proposed by Loop et al
    //  though, the approximation using the 16 Bezier points arising from the G(s,t) has
    //  proved adequate (and is what the GPU shaders use) so we continue to use that here.
    //
    //  An implementation of the true derivatives is provided for future reference -- it is
    //  unclear if the approximations will hold up under surface analysis involving higher
    //  order differentiation.
    //
    if (OSD_OPTIONAL(wDs && wDt)) {
        bool find_second_partials = OSD_OPTIONAL(wDs && wDst && wDtt);
        //  Remember to include derivative scaling in all assignments below:
        float d2Scale = dScale * dScale;
        //  Combined weights for boundary points -- simple (scaled) tensor products:
        for (int i = 0; i < 12; ++i) {
            int iDst = boundaryGregory[i];
            int tRow = boundaryBezTRow[i];
            int sCol = boundaryBezSCol[i];
            wDs[iDst] = Bds[sCol] * Bt[tRow] * dScale;
            wDt[iDst] = Bdt[tRow] * Bs[sCol] * dScale;
            if (find_second_partials) {
                wDss[iDst] = Bdss[sCol] * Bt[tRow] * d2Scale;
                wDst[iDst] = Bds[sCol] * Bdt[tRow] * d2Scale;
                wDtt[iDst] = Bs[sCol] * Bdtt[tRow] * d2Scale;
            }
        }
        // dclyde's note: skipping half of the product rule like this does seem to change the result a lot in my tests.
        // This is not a runtime bottleneck for cloth sims anyway so I'm just using the accurate version.
#ifndef OPENSUBDIV_GREGORY_EVAL_TRUE_DERIVATIVES
        //  Approximation to the true Gregory derivatives by differentiating the Bezier patch
        //  unique to the given (s,t), i.e. having F = (g^+ * f^+) + (g^- * f^-) as its four
        //  interior points:
        //
        //  Combined weights for interior points -- (scaled) tensor products with G+ or G-:
        for (int i = 0; i < 8; ++i) {
            int iDst = interiorGregory[i];
            int tRow = interiorBezTRow[i];
            int sCol = interiorBezSCol[i];
            wDs[iDst] = Bds[sCol] * Bt[tRow] * G[i] * dScale;
            wDt[iDst] = Bdt[tRow] * Bs[sCol] * G[i] * dScale;
            if (find_second_partials) {
                wDss[iDst] = Bdss[sCol] * Bt[tRow] * G[i] * d2Scale;
                wDst[iDst] = Bds[sCol] * Bdt[tRow] * G[i] * d2Scale;
                wDtt[iDst] = Bs[sCol] * Bdtt[tRow] * G[i] * d2Scale;
            }
        }
#else
        //  True Gregory derivatives using appropriate differentiation of composite functions:
        //
        //  Note that for G(s,t) = N(s,t) / D(s,t), all N' and D' are trivial constants (which
        //  simplifies things for higher order derivatives).  And while each pair of functions
        //  G (i.e. the G+ and G- corresponding to points f+ and f-) must sum to 1 to ensure
        //  Bezier equivalence (when f+ = f-), the pairs of G' must similarly sum to 0.  So we
        //  can potentially compute only one of the pair and negate the result for the other
        //  (and with 4 or 8 computations involving these constants, this is all very SIMD
        //  friendly...) but for now we treat all 8 independently for simplicity.
        //
        //float N[8] = OSD_ARRAY_8(float,    s,     t,      t,     sC,      sC,     tC,      tC,     s );
        float D[8] = OSD_ARRAY_8(float,  df0,   df0,    df1,    df1,     df2,    df2,     df3,   df3 );
        OSD_DATA_STORAGE_CLASS const float Nds[8] = OSD_ARRAY_8(float, 1.0f, 0.0f,  0.0f, -1.0f, -1.0f,  0.0f,  0.0f,  1.0f );
        OSD_DATA_STORAGE_CLASS const float Ndt[8] = OSD_ARRAY_8(float, 0.0f, 1.0f,  1.0f,  0.0f,  0.0f, -1.0f, -1.0f,  0.0f );
        OSD_DATA_STORAGE_CLASS const float Dds[8] = OSD_ARRAY_8(float, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  1.0f );
        OSD_DATA_STORAGE_CLASS const float Ddt[8] = OSD_ARRAY_8(float, 1.0f, 1.0f,  1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f );
        //  Combined weights for interior points -- (scaled) combinations of B, B', G and G':
        for (int i = 0; i < 8; ++i) {
            int iDst = interiorGregory[i];
            int tRow = interiorBezTRow[i];
            int sCol = interiorBezSCol[i];
            //  Quotient rule for G' (re-expressed in terms of G to simplify (and D = 1/D)):
            float Gds = (Nds[i] - Dds[i] * G[i]) * D[i];
            float Gdt = (Ndt[i] - Ddt[i] * G[i]) * D[i];
            //  Product rule combining B and B' with G and G' (and scaled):
            wDs[iDst] = (Bds[sCol] * G[i] + Bs[sCol] * Gds) * Bt[tRow] * dScale;
            wDt[iDst] = (Bdt[tRow] * G[i] + Bt[tRow] * Gdt) * Bs[sCol] * dScale;
            if (find_second_partials) {
                float Dsqr_inv = D[i]*D[i];
                float Gdss = 2.0f * Dds[i] * Dsqr_inv * (G[i] * Dds[i] - Nds[i]);
                float Gdst = Dsqr_inv * (2.0f * G[i] * Dds[i] * Ddt[i] - Nds[i] * Ddt[i] - Ndt[i] * Dds[i]);
                float Gdtt = 2.0f * Ddt[i] * Dsqr_inv * (G[i] * Ddt[i] - Ndt[i]);
                wDss[iDst] = (Bdss[sCol] * G[i] + 2.0f * Bds[sCol] * Gds + Bs[sCol] * Gdss) * Bt[tRow] * d2Scale;
                wDst[iDst] = (Bt[tRow] * (Bs[sCol] * Gdst + Bds[sCol] * Gdt) + Bdt[tRow] * (Bds[sCol] * G[i] + Bs[sCol] * Gds)) * d2Scale;
                wDtt[iDst] = (Bdtt[tRow] * G[i] + 2.0f * Bdt[tRow] * Gdt + Bt[tRow] * Gdtt) * Bs[sCol] * d2Scale;
            }
        }
#endif
    }
#endif /* OPENSUBDIV3_OSD_PATCH_BASIS_COMMON_H */
#define OSD_PATCH_LINES 1
#define OSD_PATCH_TRIANGLES 1
#define OSD_PATCH_QUADS 1
#define OSD_PATCH_BSPLINE 1
#define OSD_PATCH_REGULAR 1
#define OSD_PATCH_GREGORY 1
#define OSD_PATCH_GREGORY_BOUNDARY 1
#define OSD_PATCH_GREGORY_BASIS 1
GetPatchTypeDefine
mtlPatchShaderSource.mm
"Unknown Far::PatchDescriptor::Type" && 0
GetPatchTypeSource
#line 0 "osd/mtlPatchBSpline.metal"
//   Copyright 2015 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//----------------------------------------------------------
// Patches.BSpline.Hull
//----------------------------------------------------------
static void OsdComputePerVertex(
float4 vertexPosition,
    threadgroup HullVertex& hullVertex,
    int vertexId,
    float4x4 ModelViewProjectionMatrix,
    OsdPatchParamBufferSet osdBuffers
    )
    hullVertex.position = vertexPosition;
#if OSD_ENABLE_PATCH_CULL
    float4 clipPos = mul(ModelViewProjectionMatrix, vertexPosition);   
    short3 clip0 = short3(clipPos.x < clipPos.w,                    
    clipPos.y < clipPos.w,                    
    clipPos.z < clipPos.w);                   
    short3 clip1 = short3(clipPos.x > -clipPos.w,                   
    clipPos.y > -clipPos.w,                   
    clipPos.z > -clipPos.w);                  
    hullVertex.clipFlag = short3(clip0) + 2*short3(clip1);              
#endif
    
    OSD_USER_VARYING_PER_CONTROL_POINT(osdBuffers.vertexBuffer[vertexId], hullVertex);
//----------------------------------------------------------
// Patches.BSpline.Factors
//----------------------------------------------------------
static void OsdComputePerPatchBSplineFactors(
    int3 patchParam,
    float tessLevel,
    float4x4 projectionMatrix,
    float4x4 modelViewMatrix,
    device OsdPerPatchVertexBezier* patch
#if !USE_PTVS_FACTORS
    ,device OsdPerPatchTessFactors& patchFactors
#endif
    ,device MTLQuadTessellationFactorsHalf& quadFactors
    float4 tessLevelOuter = float4(0,0,0,0);
    float2 tessLevelInner = float2(0,0);
    float4 tessOuterLo = float4(0,0,0,0);
    float4 tessOuterHi = float4(0,0,0,0);
#if OSD_ENABLE_SCREENSPACE_TESSELLATION
    OsdGetTessLevelsAdaptiveLimitPoints(
        tessLevel, 
        projectionMatrix, 
        modelViewMatrix,
        patch,
        patchParam,
        tessLevelOuter,
        tessLevelInner,
        tessOuterLo,
        tessOuterHi
        );
#else
    OsdGetTessLevelsUniform(
        tessLevel, 
        patchParam, 
        tessLevelOuter,
        tessLevelInner,
        tessOuterLo,
        tessOuterHi
        );
#endif
    quadFactors.edgeTessellationFactor[0] = tessLevelOuter[0];
    quadFactors.edgeTessellationFactor[1] = tessLevelOuter[1];
    quadFactors.edgeTessellationFactor[2] = tessLevelOuter[2];
    quadFactors.edgeTessellationFactor[3] = tessLevelOuter[3];
    quadFactors.insideTessellationFactor[0] = tessLevelInner[0];
    quadFactors.insideTessellationFactor[1] = tessLevelInner[1];
#if !USE_PTVS_FACTORS
    patchFactors.tessOuterLo = tessOuterLo;
    patchFactors.tessOuterHi = tessOuterHi;
#endif
static void OsdComputePerPatchFactors(
int3 patchParam,
float tessLevel,
unsigned patchID,
float4x4 projectionMatrix,
float4x4 modelViewMatrix,
OsdPatchParamBufferSet osdBuffer,
threadgroup PatchVertexType* patchVertices,
device MTLQuadTessellationFactorsHalf& quadFactors
OsdComputePerPatchBSplineFactors(
patchParam, 
tessLevel, 
projectionMatrix, 
modelViewMatrix, 
osdBuffer.perPatchVertexBuffer + patchID * CONTROL_POINTS_PER_PATCH,
#if !USE_PTVS_FACTORS
osdBuffer.patchTessBuffer[patchID],
#endif
quadFactors
//----------------------------------------------------------
// Patches.BSpline.Vertex
//----------------------------------------------------------
static void OsdComputePerPatchVertex(
int3 patchParam, 
unsigned ID, 
unsigned PrimitiveID, 
unsigned ControlID,
threadgroup PatchVertexType* patchVertices,
OsdPatchParamBufferSet osdBuffers
OsdComputePerPatchVertexBSpline(patchParam, ID, patchVertices, osdBuffers.perPatchVertexBuffer[ControlID]);
    
    OSD_USER_VARYING_PER_VERTEX(patchVertices[ID], osdBuffers.perPatchVertexBuffer[ControlID]);
//----------------------------------------------------------
// Patches.BSpline.Domain
//----------------------------------------------------------
template<typename PerPatchVertexBezier>
static OsdPatchVertex ds_regular_patches(
    const float TessLevel,
#if !USE_PTVS_FACTORS
    float4 tessOuterHi,
    float4 tessOuterLo,
#endif
    PerPatchVertexBezier cv,
    int3 patchParam,
    float2 domainCoord)
    OsdPatchVertex output;
    float3 P, dPu, dPv;
    float3 N, dNu, dNv;
    float2 vSegments;
#if !USE_PTVS_FACTORS
    float2 UV = OsdGetTessParameterization(domainCoord,
                                           tessOuterLo,
                                           tessOuterHi);
#else
    auto transitionMask = OsdGetPatchTransitionMask(patchParam);
    float4 tessLevelMin = float4(1)
    + float4(((transitionMask & 8) >> 3),
             ((transitionMask & 1) >> 0),
             ((transitionMask & 2) >> 1),
             ((transitionMask & 4) >> 2));
    float2 UV = OsdGetTessParameterization(domainCoord,
                                           tessLevelMin,
                                           float4(0));
#endif
    OsdEvalPatchBezier(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv, vSegments);
    output.normal = N;
    output.tangent = dPu;
    output.bitangent = dPv;
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    output.Nu = dNu;
    output.Nv = dNv;
#endif
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    output.vSegments = vSegments;
#endif
    output.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);
    output.position = P;
    
    OSD_USER_VARYING_PER_EVAL_POINT(UV, cv[5], cv[6], cv[9], cv[10], output);
    
    return output;
#if USE_STAGE_IN
template<typename PerPatchVertexBezier>
#endif
static OsdPatchVertex OsdComputePatch(
float tessLevel,
float2 domainCoord,
unsigned patchID,
#if USE_STAGE_IN
PerPatchVertexBezier osdPatch
#else
OsdVertexBufferSet osdBuffers
#endif
return ds_regular_patches(
tessLevel,
#if !USE_PTVS_FACTORS
#if USE_STAGE_IN
osdPatch.tessOuterHi,
osdPatch.tessOuterLo,
#else
osdBuffers.patchTessBuffer[patchID].tessOuterHi,
osdBuffers.patchTessBuffer[patchID].tessOuterLo,
#endif
#endif
#if USE_STAGE_IN
osdPatch.cv,
osdPatch.patchParam,
#else
osdBuffers.perPatchVertexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,
osdBuffers.patchParamBuffer[patchID],
#endif
domainCoord
#line 0 "osd/mtlPatchGregory.metal"
//   Copyright 2013 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//----------------------------------------------------------
// Patches.Gregory.Hull
//----------------------------------------------------------
void OsdComputePerVertex(
float4 position,
    threadgroup OsdPerVertexGregory& hullVertex,
    int vertexId,
    float4x4 modelViewProjectionMatrix,
    OsdPatchParamBufferSet osdBuffers
    )
OsdComputePerVertexGregory(vertexId, position.xyz, hullVertex, osdBuffers);
#if OSD_ENABLE_PATCH_CULL
    float4 clipPos = mul(modelViewProjectionMatrix, position);    
    short3 clip0 = short3(clipPos.x < clipPos.w,                    
    clipPos.y < clipPos.w,                    
    clipPos.z < clipPos.w);                   
    short3 clip1 = short3(clipPos.x > -clipPos.w,                   
    clipPos.y > -clipPos.w,                   
    clipPos.z > -clipPos.w);                  
    hullVertex.clipFlag = short3(clip0) + 2*short3(clip1);
#endif
    
    OSD_USER_VARYING_PER_CONTROL_POINT(osdBuffers.vertexBuffer[vertexId], hullVertex);
//----------------------------------------------------------
// Patches.Gregory.Factors
//----------------------------------------------------------
void OsdComputePerPatchFactors(
int3 patchParam,
float tessLevel,
unsigned patchID,
float4x4 projectionMatrix,
float4x4 modelViewMatrix,
OsdPatchParamBufferSet osdBuffer,
threadgroup PatchVertexType* patchVertices,
device MTLQuadTessellationFactorsHalf& quadFactors
    float4 tessLevelOuter = float4(0,0,0,0);
    float2 tessLevelInner = float2(0,0);
OsdGetTessLevels(
tessLevel, 
projectionMatrix, 
modelViewMatrix,
patchVertices[0].P, 
patchVertices[3].P, 
patchVertices[2].P, 
patchVertices[1].P,
patchParam, 
tessLevelOuter, 
tessLevelInner
    quadFactors.edgeTessellationFactor[0] = tessLevelOuter[0];
    quadFactors.edgeTessellationFactor[1] = tessLevelOuter[1];
    quadFactors.edgeTessellationFactor[2] = tessLevelOuter[2];
    quadFactors.edgeTessellationFactor[3] = tessLevelOuter[3];
    quadFactors.insideTessellationFactor[0] = tessLevelInner[0];
    quadFactors.insideTessellationFactor[1] = tessLevelInner[1];
//----------------------------------------------------------
// Patches.Gregory.Vertex
//----------------------------------------------------------
void OsdComputePerPatchVertex(
int3 patchParam, 
unsigned ID, 
unsigned PrimitiveID, 
unsigned ControlID,
threadgroup PatchVertexType* patchVertices,
OsdPatchParamBufferSet osdBuffers
OsdComputePerPatchVertexGregory(
patchParam,
PrimitiveID,
patchVertices,
osdBuffers.perPatchVertexBuffer[ControlID],
osdBuffers);
    
    OSD_USER_VARYING_PER_VERTEX(patchVertices[ID], osdBuffers.perPatchVertexBuffer[ControlID]);
//----------------------------------------------------------
// Patches.Gregory.Domain
//----------------------------------------------------------
template<typename PerPatchVertexGregory>
static OsdPatchVertex ds_gregory_patches(
                     PerPatchVertexGregory patch,
                     int3 patchParam,
                     float2 UV
                    )
    OsdPatchVertex output;
    
    float3 P = float3(0,0,0), dPu = float3(0,0,0), dPv = float3(0,0,0);
    float3 N = float3(0,0,0), dNu = float3(0,0,0), dNv = float3(0,0,0);
    
    float3 cv[20];
    cv[0] = patch[0].P;
    cv[1] = patch[0].Ep;
    cv[2] = patch[0].Em;
    cv[3] = patch[0].Fp;
    cv[4] = patch[0].Fm;
    
    cv[5] = patch[1].P;
    cv[6] = patch[1].Ep;
    cv[7] = patch[1].Em;
    cv[8] = patch[1].Fp;
    cv[9] = patch[1].Fm;
    
    cv[10] = patch[2].P;
    cv[11] = patch[2].Ep;
    cv[12] = patch[2].Em;
    cv[13] = patch[2].Fp;
    cv[14] = patch[2].Fm;
    
    cv[15] = patch[3].P;
    cv[16] = patch[3].Ep;
    cv[17] = patch[3].Em;
    cv[18] = patch[3].Fp;
    cv[19] = patch[3].Fm;
    
    OsdEvalPatchGregory(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);
    
    // all code below here is client code
    output.position = P;
    output.normal = N;
    output.tangent = dPu;
    output.bitangent = dPv;
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    output.Nu = dNu;
    output.Nv = dNv;
#endif
    output.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);
    
    OSD_USER_VARYING_PER_EVAL_POINT(UV, patch[0], patch[1], patch[3], patch[2], output);
    return output;
#if USE_STAGE_IN
template<typename PerPatchVertexGregoryBasis>
#endif
static OsdPatchVertex OsdComputePatch(
float tessLevel,
float2 domainCoord,
unsigned patchID,
#if USE_STAGE_IN
PerPatchVertexGregoryBasis osdPatch
#else
    OsdVertexBufferSet osdBuffers
#endif
return ds_gregory_patches(
#if USE_STAGE_IN
osdPatch.cv,
osdPatch.patchParam,
#else
        osdBuffers.perPatchVertexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,
        osdBuffers.patchParamBuffer[patchID],
#endif
domainCoord);
#line 0 "osd/mtlPatchGregoryBasis.metal"
//   Copyright 2015 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//----------------------------------------------------------
// Patches.GregoryBasis.Hull
//----------------------------------------------------------
void OsdComputePerVertex(
float4 position,
    threadgroup HullVertex& hullVertex,
    int vertexId,
    float4x4 modelViewProjectionMatrix,
    OsdPatchParamBufferSet osdBuffers
    )
hullVertex.position = position;
#if OSD_ENABLE_PATCH_CULL
    float4 clipPos = mul(modelViewProjectionMatrix, position);    
    short3 clip0 = short3(clipPos.x < clipPos.w,                    
    clipPos.y < clipPos.w,                    
    clipPos.z < clipPos.w);                   
    short3 clip1 = short3(clipPos.x > -clipPos.w,                   
    clipPos.y > -clipPos.w,                   
    clipPos.z > -clipPos.w);                  
    hullVertex.clipFlag = short3(clip0) + 2*short3(clip1);              
#endif
    
    OSD_USER_VARYING_PER_CONTROL_POINT(osdBuffers.vertexBuffer[vertexId], hullVertex);
//----------------------------------------------------------
// Patches.GregoryBasis.Factors
//----------------------------------------------------------
void OsdComputePerPatchFactors(
int3 patchParam,
float tessLevel,
unsigned patchID,
float4x4 projectionMatrix,
float4x4 modelViewMatrix,
OsdPatchParamBufferSet osdBuffer,
threadgroup PatchVertexType* patchVertices,
device MTLQuadTessellationFactorsHalf& quadFactors
    float4 tessLevelOuter = float4(0,0,0,0);
    float2 tessLevelInner = float2(0,0);
OsdGetTessLevels(
tessLevel, 
projectionMatrix, 
modelViewMatrix,
patchVertices[0].position.xyz, 
patchVertices[3].position.xyz, 
patchVertices[2].position.xyz, 
patchVertices[1].position.xyz,
patchParam, 
tessLevelOuter, 
tessLevelInner
    quadFactors.edgeTessellationFactor[0] = tessLevelOuter[0];
    quadFactors.edgeTessellationFactor[1] = tessLevelOuter[1];
    quadFactors.edgeTessellationFactor[2] = tessLevelOuter[2];
    quadFactors.edgeTessellationFactor[3] = tessLevelOuter[3];
    quadFactors.insideTessellationFactor[0] = tessLevelInner[0];
    quadFactors.insideTessellationFactor[1] = tessLevelInner[1];
//----------------------------------------------------------
// Patches.GregoryBasis.Vertex
//----------------------------------------------------------
void OsdComputePerPatchVertex(
int3 patchParam, 
unsigned ID, 
unsigned PrimitiveID, 
unsigned ControlID,
threadgroup PatchVertexType* patchVertices,
OsdPatchParamBufferSet osdBuffers
//Does nothing, all transforms are in the PTVS
    OSD_USER_VARYING_PER_VERTEX(patchVertices[ID], osdBuffers.perPatchVertexBuffer[ControlID]);
//----------------------------------------------------------
// Patches.GregoryBasis.Domain
//----------------------------------------------------------
#define USE_128BIT_GREGORY_BASIS_INDICES_READ 1
#if USE_STAGE_IN
template<typename PerPatchVertexGregoryBasis>
#endif
static OsdPatchVertex ds_gregory_basis_patches(
#if USE_STAGE_IN
                     PerPatchVertexGregoryBasis patch,
#else
                     const device OsdInputVertexType* patch,
                     const device unsigned* patchIndices,
#endif
                     int3 patchParam,
                     float2 UV
                     )
    OsdPatchVertex output;
    float3 P = float3(0,0,0), dPu = float3(0,0,0), dPv = float3(0,0,0);
    float3 N = float3(0,0,0), dNu = float3(0,0,0), dNv = float3(0,0,0);
#if USE_STAGE_IN
    float3 cv[20];
    for(int i = 0; i < 20; i++)
        cv[i] = patch[i].position;
#else   
#if USE_128BIT_GREGORY_BASIS_INDICES_READ
    float3 cv[20];
    for(int i = 0; i < 5; i++) {
        int4 indices = ((device int4*)patchIndices)[i];
        
        int n = i * 4;
        cv[n + 0] = (patch + indices[0])->position;
        cv[n + 1] = (patch + indices[1])->position;
        cv[n + 2] = (patch + indices[2])->position;
        cv[n + 3] = (patch + indices[3])->position;
    }
#else
    float3 cv[20];
    for (int i = 0; i < 20; ++i) {
        cv[i] = patch[patchIndices[i]].position;
    }
#endif
#endif
    
    OsdEvalPatchGregory(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);
    
    output.position = P;
    output.normal = N;
    output.tangent = dPu;
    output.bitangent = dPv;
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    output.Nu = dNu;
    output.Nv = dNv;
#endif
    
    output.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);
    
#if USE_STAGE_IN
    OSD_USER_VARYING_PER_EVAL_POINT(UV, patch[0], patch[5], patch[15], patch[10], output);
#else
    OSD_USER_VARYING_PER_EVAL_POINT(UV, patch[patchIndices[0]], patch[patchIndices[5]], patch[patchIndices[15]], patch[patchIndices[10]], output);
#endif
    
    return output;
#if USE_STAGE_IN
template<typename PerPatchVertexGregoryBasis>
#endif
static OsdPatchVertex OsdComputePatch(
float tessLevel,
float2 domainCoord,
unsigned patchID,
#if USE_STAGE_IN
PerPatchVertexGregoryBasis osdPatch
#else
OsdVertexBufferSet osdBuffers
#endif
return ds_gregory_basis_patches(
#if USE_STAGE_IN
osdPatch.cv,
osdPatch.patchParam,
#else
osdBuffers.vertexBuffer,
osdBuffers.indexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,
osdBuffers.patchParamBuffer[patchID],
#endif
domainCoord
EndCapBSplineBasisPatchFactory
endCapBSplineBasisPatchFactory.cpp
computeLimitStencils
(ringSize & 1) == 0
start > -1 && prev > -1
EndCapGregoryBasisPatchFactory
endCapGregoryBasisPatchFactory.cpp
GetPatchPoints
fedges.size()==4
aedge!=Vtr::INDEX_INVALID
adjPatchIndex>=0 && adjPatchIndex<(int)_levelAndFaceIndices.size()
quadRefinement.cpp
_splitType == Sdc::SPLIT_TO_QUADS
initializeInventory
topologyRefiner.cpp
_levels.size() == 1
Failure in TopologyRefiner::RefineUniform() -- base level is uninitialized.
Failure in TopologyRefiner::RefineUniform() -- previous refinements already applied.
Failure in TopologyRefiner::RefineAdaptive() -- base level is uninitialized.
Failure in TopologyRefiner::RefineAdaptive() -- previous refinements already applied.
Failure in TopologyRefiner::RefineAdaptive() -- currently only supported for Catmark scheme.
doesFaceHaveDistinctFaceVaryingFeatures
!level.doesFaceFVarTopologyMatch(face, fvarChannel)
getQuadOffsets
endCapLegacyGregoryPatchFactory.cpp
thisFaceInVFaces != -1
Edge %d specified to be sharp does not exist (%d, %d)
Vertex %d specified to be sharp does not exist
OSD VertexBuffer
skew
_value
Float7
xsNCName
xsAnyURI
Float4x4
Uint
ListOfUInts
ListOfInts
bool_array
xsID
Float
control_vertices
closed
Bool
tapered_capsule
radius1
radius2
Float2
tapered_cylinder
TargetableFloat
TargetableFloat3
Float3
xsNMTOKEN
trifans
xsBoolean
xsDateTime
DateTime
xsDouble
xsLong
xsName
Name
xsString
xsToken
Token
xsUnsignedLong
ListOfBools
ListOfFloats
xsHexBinary
ListOfHexBinary
ListOfNames
ListOfTokens
Bool2
Bool3
Bool4
Float4
Float2x2
Float3x3
Float2x3
Float2x4
Float3x2
Float3x4
Float4x2
Float4x3
Int2
Int3
Int4
Int2x2
Int3x3
Int4x4
MorphMethodType
NodeType
NODE
URIFragmentType
UpAxisType
VersionType
1.4.0
Fx_color_common
Fx_opaque_enum
Fx_surface_type_enum
UNTYPED
RECT
Fx_surface_face_enum
POSITIVE_X
NEGATIVE_X
POSITIVE_Y
NEGATIVE_Y
POSITIVE_Z
NEGATIVE_Z
Fx_surface_format_hint_channels_enum
RGBA
XYZW
Fx_surface_format_hint_precision_enum
HIGH
Fx_surface_format_hint_range_enum
SNORM
UNORM
SINT
UINT
FLOAT
Fx_surface_format_hint_option_enum
SRGB_GAMMA
NORMALIZED3
NORMALIZED4
COMPRESSABLE
Fx_sampler_wrap_common
Fx_sampler_filter_common
NEAREST_MIPMAP_NEAREST
LINEAR_MIPMAP_NEAREST
NEAREST_MIPMAP_LINEAR
LINEAR_MIPMAP_LINEAR
Fx_modifier_enum_common
CONST
UNIFORM
VARYING
STATIC
VOLATILE
EXTERN
SHARED
Fx_draw_common
Fx_pipeline_stage_common
VERTEXPROGRAM
FRAGMENTPROGRAM
VERTEXSHADER
PIXELSHADER
xsNonNegativeInteger
GL_MAX_LIGHTS_index
GL_MAX_CLIP_PLANES_index
GL_MAX_TEXTURE_IMAGE_UNITS_index
Gl_blend_type
ZERO
SRC_COLOR
ONE_MINUS_SRC_COLOR
DEST_COLOR
ONE_MINUS_DEST_COLOR
SRC_ALPHA
ONE_MINUS_SRC_ALPHA
DST_ALPHA
ONE_MINUS_DST_ALPHA
CONSTANT_COLOR
ONE_MINUS_CONSTANT_COLOR
CONSTANT_ALPHA
ONE_MINUS_CONSTANT_ALPHA
SRC_ALPHA_SATURATE
Gl_face_type
FRONT
BACK
FRONT_AND_BACK
Gl_blend_equation_type
FUNC_ADD
FUNC_SUBTRACT
FUNC_REVERSE_SUBTRACT
Gl_func_type
NEVER
LESS
LEQUAL
EQUAL
GREATER
NOTEQUAL
GEQUAL
ALWAYS
Gl_stencil_op_type
KEEP
REPLACE
INCR
DECR
INVERT
INCR_WRAP
DECR_WRAP
Gl_material_type
EMISSION
AMBIENT
DIFFUSE
SPECULAR
AMBIENT_AND_DIFFUSE
Gl_fog_type
EXP2
Gl_fog_coord_src_type
FOG_COORDINATE
FRAGMENT_DEPTH
Gl_front_face_type
Gl_light_model_color_control_type
SINGLE_COLOR
SEPARATE_SPECULAR_COLOR
Gl_logic_op_type
CLEAR
AND_REVERSE
COPY
AND_INVERTED
NOOP
EQUIV
OR_REVERSE
COPY_INVERTED
NAND
Gl_polygon_mode_type
POINT
LINE
FILL
Gl_shade_model_type
FLAT
SMOOTH
xsFloat
Gl_alpha_value_type
Gl_enumeration
Glsl_float
xsInt
Glsl_int
Glsl_bool
Glsl_ListOfBool
Glsl_ListOfFloat
Glsl_ListOfInt
Glsl_bool2
Glsl_bool3
Glsl_bool4
Glsl_float2
Glsl_float3
Glsl_float4
Glsl_float2x2
Glsl_float3x3
Glsl_float4x4
Glsl_int2
Glsl_int3
Glsl_int4
Glsl_pipeline_stage
Glsl_identifier
Cg_bool
Cg_float
Cg_int
Cg_half
Cg_fixed
Cg_bool1
Cg_float1
Cg_int1
Cg_half1
Cg_fixed1
Cg_ListOfBool
Cg_ListOfFloat
Cg_ListOfInt
Cg_ListOfHalf
Cg_ListOfFixed
Cg_bool2
Cg_bool3
Cg_bool4
Cg_bool1x1
Cg_bool1x2
Cg_bool1x3
Cg_bool1x4
Cg_bool2x1
Cg_bool2x2
Cg_bool2x3
Cg_bool2x4
Cg_bool3x1
Cg_bool3x2
Cg_bool3x3
Cg_bool3x4
Cg_bool4x1
Cg_bool4x2
Cg_bool4x3
Cg_bool4x4
Cg_float2
Cg_float3
Cg_float4
Cg_float1x1
Cg_float1x2
Cg_float1x3
Cg_float1x4
Cg_float2x1
Cg_float2x2
Cg_float2x3
Cg_float2x4
Cg_float3x1
Cg_float3x2
Cg_float3x3
Cg_float3x4
Cg_float4x1
Cg_float4x2
Cg_float4x3
Cg_float4x4
Cg_int2
Cg_int3
Cg_int4
Cg_int1x1
Cg_int1x2
Cg_int1x3
Cg_int1x4
Cg_int2x1
Cg_int2x2
Cg_int2x3
Cg_int2x4
Cg_int3x1
Cg_int3x2
Cg_int3x3
Cg_int3x4
Cg_int4x1
Cg_int4x2
Cg_int4x3
Cg_int4x4
Cg_half2
Cg_half3
Cg_half4
Cg_half1x1
Cg_half1x2
Cg_half1x3
Cg_half1x4
Cg_half2x1
Cg_half2x2
Cg_half2x3
Cg_half2x4
Cg_half3x1
Cg_half3x2
Cg_half3x3
Cg_half3x4
Cg_half4x1
Cg_half4x2
Cg_half4x3
Cg_half4x4
Cg_fixed2
Cg_fixed3
Cg_fixed4
Cg_fixed1x1
Cg_fixed1x2
Cg_fixed1x3
Cg_fixed1x4
Cg_fixed2x1
Cg_fixed2x2
Cg_fixed2x3
Cg_fixed2x4
Cg_fixed3x1
Cg_fixed3x2
Cg_fixed3x3
Cg_fixed3x4
Cg_fixed4x1
Cg_fixed4x2
Cg_fixed4x3
Cg_fixed4x4
Cg_pipeline_stage
FRAGMENT
Cg_identifier
GLES_MAX_LIGHTS_index
GLES_MAX_CLIP_PLANES_index
GLES_MAX_TEXTURE_COORDS_index
GLES_MAX_TEXTURE_IMAGE_UNITS_index
Gles_texenv_mode_enums
MODULATE
DECAL
BLEND
Gles_texcombiner_operatorRGB_enums
ADD_SIGNED
INTERPOLATE
SUBTRACT
DOT3_RGB
DOT3_RGBA
Gles_texcombiner_operatorAlpha_enums
Gles_texcombiner_source_enums
TEXTURE
CONSTANT
PRIMARY
PREVIOUS
Gles_texcombiner_operandRGB_enums
Gles_texcombiner_operandAlpha_enums
Gles_texcombiner_argument_index_type
Gles_sampler_wrap
REPEAT
CLAMP_TO_EDGE
MIRRORED_REPEAT
Gles_stencil_op_type
Gles_enumeration
Gles_rendertarget_common
SpringType
ANGULAR
evaluate_scene
camera_node
notype
badtype
enum
xsInteger
xsIntegerArray
xsHexBinaryArray
xsByte
xsLongArray
%lld
long
xsShort
xsUnsignedByte
xsUnsignedInt
xsPositiveInteger
ulong
%llu
xsDecimal
token
xsNameArray
xsTokenArray
xsNCNameArray
Element
TrackedElement
resolver
xsIDREF
xsIDREFS
idref_resolver
-INF
NaN encountered while setting an attribute or value
INF encountered while setting an attribute or value
-INF encountered while setting an attribute or value
createArray
daeAtomicType.cpp
setDocument
keywords
revision
title
comments
copyright
half_extents
imager
ymag
aspect_ratio
cg_connect_param
cg_newarray_type
cg_param_type
usertype
connect_param
cg_newparam
bool1
bool1x1
bool1x2
bool1x3
bool1x4
bool2x1
bool2x2
bool2x3
bool2x4
bool3x1
bool3x2
bool3x3
bool3x4
bool4x1
bool4x2
bool4x3
bool4x4
float1
float1x1
float1x2
float1x3
float1x4
float2x1
float3x1
float4x1
int1
int1x1
int1x2
int1x3
int1x4
int2x1
int2x2
int2x3
int2x4
int3x1
int3x2
int3x3
int3x4
int4x1
int4x2
int4x3
int4x4
half1
half1x1
half1x2
half1x3
half1x4
half2x1
half3x1
half4x1
fixed
fixed1
fixed2
fixed3
fixed4
fixed1x1
fixed1x2
fixed1x3
fixed1x4
fixed2x1
fixed2x2
fixed2x3
fixed2x4
fixed3x1
fixed3x2
fixed3x3
fixed3x4
fixed4x1
fixed4x2
fixed4x3
fixed4x4
samplerRECT
samplerCUBE
samplerDEPTH
cg_sampler1D
border_color
mipmap_maxlevel
mipmap_bias
cg_sampler2D
cg_sampler3D
wrap_p
cg_samplerCUBE
cg_samplerDEPTH
cg_samplerRECT
cg_setarray_type
cg_setparam
cg_setparam_simple
cg_setuser_type
setparam
cg_surface_type
fx_surface_init_common
format_hint
viewport_ratio
mip_levels
mipmap_generate
generator
code
gles_pipeline_settings
alpha_func
blend_func
clear_color
clear_stencil
clear_depth
clip_plane
color_mask
cull_face
depth_func
depth_mask
depth_range
fog_color
fog_density
fog_mode
fog_start
fog_end
front_face
texture_pipeline
logic_op
light_ambient
light_diffuse
light_specular
light_position
light_constant_attenuation
light_linear_attenutation
light_quadratic_attenuation
light_spot_cutoff
light_spot_direction
light_spot_exponent
light_model_ambient
line_width
material_ambient
material_diffuse
material_emission
material_shininess
material_specular
model_view_matrix
point_distance_attenuation
point_fade_threshold_size
point_size
point_size_min
point_size_max
polygon_offset
projection_matrix
scissor
shade_model
stencil_func
stencil_mask
stencil_op
alpha_test_enable
blend_enable
clip_plane_enable
color_logic_op_enable
color_material_enable
cull_face_enable
depth_test_enable
dither_enable
fog_enable
texture_pipeline_enable
light_enable
lighting_enable
light_model_two_side_enable
line_smooth_enable
multisample_enable
normalize_enable
point_smooth_enable
polygon_offset_fill_enable
rescale_normal_enable
sample_alpha_to_coverage_enable
sample_alpha_to_one_enable
sample_coverage_enable
scissor_test_enable
stencil_test_enable
index
0 0 0 0
0 0 0 1
0 0 1 0
0 0 -1
0.2 0.2 0.2 1.0
0.8 0.8 0.8 1.0
1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1
1 0 0
mask
4294967295
zfail
zpass
gles_sampler_state
gles_texcombiner_argumentAlpha_type
operand
gles_texcombiner_argumentRGB_type
gles_texcombiner_command_type
gles_texcombiner_commandAlpha_type
argument
operator
gles_texcombiner_commandRGB_type
gles_texenv_command_type
gles_texture_constant_type
gles_texture_pipeline
texcombiner
texenv
gles_texture_unit
sampler_state
glsl_newarray_type
glsl_param_type
glsl_newparam
glsl_setarray_type
glsl_setparam
glsl_setparam_simple
glsl_surface_type
InputLocal
InputLocalOffset
technique_hint
platform
fx_basic_type_common
instance_force_field
bind
instance_node
instance_physics_material
instance_physics_model
instance_rigid_body
instance_rigid_constraint
angular_velocity
mass_frame
inertia
physics_material
shape
hollow
density
InstanceWithExtra
minInclusive
-2147483648
maxInclusive
2147483647
library_force_fields
force_field
library_nodes
library_physics_materials
physics_model
physics_scene
xml_base
common_color_or_texture_type
common_float_or_param_type
common_newparam_type
common_transparent_type
fx_surface_format_hint_common
range
precision
option
fx_surface_init_planar_common
fx_surface_init_volume_common
primary
fx_surface_init_cube_common
order
fx_surface_init_from_common
fx_surface_common
fx_sampler1D_common
fx_sampler2D_common
fx_sampler3D_common
fx_samplerCUBE_common
fx_samplerRECT_common
fx_samplerDEPTH_common
fx_colortarget_common
fx_depthtarget_common
fx_stenciltarget_common
fx_clearcolor_common
fx_cleardepth_common
fx_clearstencil_common
fx_annotate_common
fx_include_common
fx_newparam_common
fx_code_profile
gl_sampler1D
gl_sampler2D
gl_sampler3D
gl_samplerCUBE
gl_samplerRECT
gl_samplerDEPTH
gles_newparam
init_as_null
init_as_target
fx_annotate_type_common
gl_pipeline_settings
blend_func_separate
src_rgb
dest_rgb
src_alpha
dest_alpha
blend_equation
blend_equation_separate
color_material
fog_coord_src
light_model_color_control
polygon_mode
stencil_func_separate
stencil_op_separate
stencil_mask_separate
light_linear_attenuation
textureCUBE
textureRECT
textureDEPTH
texture1D_enable
texture2D_enable
texture3D_enable
textureCUBE_enable
textureRECT_enable
textureDEPTH_enable
texture_env_color
texture_env_mode
blend_color
depth_bounds
line_stipple
auto_normal_enable
depth_bounds_enable
depth_clamp_enable
light_model_local_viewer_enable
line_stipple_enable
logic_op_enable
polygon_offset_line_enable
polygon_offset_point_enable
polygon_smooth_enable
polygon_stipple_enable
gles_basic_type_common
linestrips
polylist
lookat
fx_profile_abstract
gl_hook_abstract
profile_GLSL
compiler_target
compiler_options
profile_CG
profile_GLES
color_target
depth_target
stencil_target
color_clear
depth_clear
stencil_clear
equation
convex_mesh
rigid_body
rigid_constraint
ref_attachment
interpenetrate
limits
swing_cone_and_twist
spring
angular
init_cube
init_volume
init_planar
texture_unit
dynamic_friction
static_friction
time_step
stiffness
target_value
convex_hull_of
digits
magnitude
slice
true true true true
1 65536
DefaultIDRefResolver
Failed to load XML document from memory
Failed to load 
The DOM was unable to create an element named 
 at line 
. Probably a schema violation.
The DOM was unable to create an attribute 
Probably a schema violation.
Trying to load an invalid COLLADA version for this DOM build!
Missing xmlns meta attribute for root element.
The DOM was unable to set a value for element of type 
noname
placeElement
daeMetaChoice.cpp
contentsOrder
CMData
RawResolver
daeRawResolver::resolveElement() - Can't get path from URI
-array
XMLResolver
file://
saveRawBinary
TRUE
Failed to open 
 in daeLIBXMLPlugin::readFromFile
Failed to open XML document from memory buffer in daeLIBXMLPlugin::readFromMemory
Error parsing XML in daeLIBXMLPlugin::read
readElement
daeLIBXMLPlugin.cpp
xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
can't get path in write
daeLIBXMLPlugin::write(
) failed
UTF-8
writeRawSource
accessor != NULL
%s#%ld
ColladaDOM Error: %s
daeStandardURIResolver::resolveElement() - Failed to resolve 
getInfo
AnimDecoder.cpp
headerSizeInBytes == HeaderSizeInBytes
incrementNeighborCount
AnimCodec.h
i < int32_t(_neighborCount.size())
addNeighbor
_neighborCount[i] < maxNeighborCount(i)
maxNeighborCount
kCFAllocatorNull
CFDataCreateWithBytesNoCopy
CFPropertyListCreateWithData
CFPropertyListCreateFromXMLData
CFStringCreateWithCStringNoCopy
CFDictionaryGetValue
CFGetTypeID
CFStringGetTypeID
CFStringGetCString
CFRelease
/System/Library/CoreServices/SystemVersion.plist
ProductVersion
%d.%d.%d
Assertion '%s' failed. Null argument
Error: C3DTransformsArrayAppendTransforms - out of bounds
Assertion '%s' failed. Default irradiance texture is not valid
Assertion '%s' failed. Default radiance texture is not valid
Assertion '%s' failed. Pre-computed irradiance texture is not valid
Assertion '%s' failed. Pre-computed radiance texture is not valid
Unreachable code: Asking to created a texture with an invalid format!
Error: Failed to load image with error %@
Error: Cannot load image %@. Using dummy texture.
Assertion '%s' failed. Too many mip level loaded
Error: unknown compression format
Error: Cannot load image %@. Texture will be garbage.
Error: C3DRendererCreateTextureWithImage : error while getting bitmap bytes
Error: Failed to load texture named %@ : %@
Assertion '%s' failed. slice count must match to copy
Assertion '%s' failed. width must match to copy
Assertion '%s' failed. height must match to copy
Assertion '%s' failed. depth must match to copy
Assertion '%s' failed. bad time
Assertion '%s' failed. bad count
Assertion '%s' failed. C3DAnimationClusterCreateWithAnimationGroup out of bounds
Assertion '%s' failed. unexpected animation class
Assertion '%s' failed. _getNextKeyTime twice the same keytime?
Error: can't edit NULL address
Error: can't edit pointer
Error: can't edit unknown type
Error: repeatAction: invoked with a nil action
Error: repeatActionForever: invoked with a nil action
Assertion '%s' failed. wrong light type
Assertion '%s' failed. wrong probe type
Warning: Should not register a node without light to the light system
Error: Node is already registered to the light system
Assertion '%s' failed. Invalid runtime light index
Error: Invalid runtime light index
Error: The shadow node is not registered
Assertion '%s' failed. Light does not casts shadow. Cannot compute shadow parameters.
Error: Too many shadow caster lights at once. Limit is %d
Assertion '%s' failed. Not Yet Implemented!!!!
Assertion '%s' failed. Max caster index overflow
Assertion '%s' failed. 0 caster index is reserved
Error: Too many effective lights at once. Limit is %d
Error: Missing shadow %@
Error: unabled to create a read stream at %@
Assertion '%s' failed. texture is not a MTLTexture
Assertion '%s' failed. Depth Clip Mode is not supported on this device
Assertion '%s' failed. Dereferencing null pointer
Error: Failed to create instance of type %ld. Extra size too large
Error: Failed to create instance of type %@
Error: No point of view set for tone mapping pass
Error: No camera set for tone mapping pass
Error: Color deserialize: could not read the float array
Error: Color deserialize: no color or no deserialized data
Assertion '%s' failed. Unsupported conversion info - different TRCs for input components
Error: Unsupported conversion info - unsupported TRC type %d
Error: Unsupported conversion info - stage %d of %d will be ignored!
Error: Unsupported conversion info - %d color matrices
Error: Unsupported conversion info - NxMLUTs not supported
Error: Failed to compute color conversion parameters for %@ 
Error: No conversion info for %@ 
 %@, texture will be copied
Error: Color matching for %@ 
 %@ could be done more efficiently by switching to a _sRGB variant of the MTLPixelFormat
Error: C3DBaseTypeForCFNumberType: Type not supported
Assertion '%s' failed. Not enough room for the specified count & stride to read
Assertion '%s' failed. Not enough room for the specified count & stride to write
Error: C3DConvertToPlatformIndependentData - archiving pointers makes no sense
Error: C3DConvertToPlatformIndependentData - Type not supported
Error: C3DConvertFromPlatformIndependentData: Not enough room for the specified count & stride to read
Error: C3DConvertFromPlatformIndependentData: Not enough room for the specified count & stride to write
Error: C3DConvertFromPlatformIndependentData - Type not supported
Assertion '%s' failed. unknown type
Error: unknown type
Unreachable code: Compound type %s%d is not supported
Assertion '%s' failed. Only one compound type per vector
Assertion '%s' failed. wrong parameters
Warning: C3DBaseTypeFromDescription - signed/unsigned ambiguity
Error: C3DBaseTypeFromDescription - Type not supported
Error: C3DBaseTypeRequires32to64bitConversion:: unknown type
Error: C3DAddBaseType - type %d can't be added
Error: C3DAddBaseType - addition of half float not supported
Error: C3DAddBaseType - unknown type
Error: C3DSubBaseType - type %d can't be substracted
Error: C3DSubBaseType - substraction of half float not supported
Error: C3DSubBaseType - unknown type
Error: Conversion to C string failed
Warning: C3DParseVersionNumber - No version found
Error: failed to load resource named %@
Error: failed to load dictionary named %@
Error: failed to load json named %@ (reason: %@)
Error: failed to load json named %@
Warning: C3DDataFromMTLBuffer - can't read private MTL buffer
Info: linear rendering forced to %d
Assertion '%s' failed. Spherical Harmonics Data seems malformed: order(%d) !=> length(%zu)
Error: Could not deserialize a number array (nil buffer or serialized data)
Error: Could not deserialize a number (%@) in a number array
Error: Could not deserialize a number array (unexpected type)
Warning: C3DBaseTypeFromGLSLString: unknown type name '%@'
Warning: C3DBaseTypeFromMetalString: unknown type name '%@'
Warning: C3DBaseTypeFromMetalOrGLSLString: unknown type name '%@'
Assertion '%s' failed. No node should be tracked anymore by the geometry %@
Error: Geometry deserialization: cannot find the mesh ID
Error: Geometry deserialization: cannot find the specified mesh
Error: Geometry deserialization: cannot find the specified material
Warning: _C3DGeometryFinalizeDeserialization - material ID of 0 is unexpected
Assertion '%s' failed. Node should not already been tracked by this geometry
Assertion '%s' failed. Node should been tracked by this geometry
Error: cannot generate points : mismatch between vertices and normals count
Error: Cannot use volume generation on a generic mesh. fallbacking on surface
Error: Could not deserialize the property %@ in the serialized effect %@
Error: C3DMeshElementCreateByMergingElements - strip not supported
Error: C3DMeshElementCreateByMergingElements - merging elements with different byte per index
Assertion '%s' failed. Mesh element has %d channels but channel %d was requested
Warning: %s does not support non-renderable topologies.
Error: C3DMeshElementGetIndexCount:primitive type not handled
Assertion '%s' failed. Internal consistency error: number of indices should be a multiple of number of channels
Unreachable code: unexpected vertex count
Error: unexpected vertex count
Unreachable code: Invalid bytes per index (%d)
Unreachable code: Unknown primitive type %d
Error: invalid propertylist in %s
Error: Mesh element deserialization: no faces count
Error: Mesh element deserialization: no mesh element type
Error: Mesh element deserialization: no bytes per index
Error: Could not read the indexes
Error: Mesh element deserialization: no serialized indices
Warning: Unknown mesh element type %@, assuming triangles array.
Error: C3DMeshElementSetPrimitives invalid index buffer size
Error: __readIndexInBuffer - index (%u) out of bounds (%lu)
Assertion '%s' failed. %s - unsupported index size (%ld)
Unreachable code: Unknown index type %d
Unreachable code: A tessellator object should not exist when no tessellation is required
Error: failed to copy a snapshot of %@
Assertion '%s' failed. error in computing triangle bbox
Assertion '%s' failed. Update %s to support mesh element channels
Assertion '%s' failed. there should be exactly one transposed matrix in here
Warning: unlock not locked ressource
Assertion '%s' failed. Unsupported element type in C3DMeshCreateByMergingMeshes
Error: C3DMeshSubdivide inconsistency
Assertion '%s' failed. inconsistency (2) in C3DMeshSubdivide
Warning: try to preload a geometry with no mesh
Error: WARNING: NULL data in mesh source (warming geometry)
Error: Cannot generate tangents without valid positions
Error: Cannot generate valid tangents without valid texture coordinates
Error: Cannot generate valid tangents without valid normals
Unreachable code: Unsupported index size (%zu)
Error: invalid geometry detected - skip C3DCreateTangentsWithGeometryOptimized
Error: target mesh has a different number of vertices (%d != %d)
Error: Cannot generate tangents without positions
Error: Cannot generate tangents without texture coordinates
Error: error in C3DMeshCreateTangentsIfNeeded
Warning: Cannot create an interleaved copy, count mismatch
Unreachable code: C3DAdjustZRangeOfProjectionInfos - no scene or no point of view
Unreachable code: C3DAdjustZRangeOfProjectionInfos - no root node
Unreachable code: C3DAdjustZRangeOfProjectionInfos - no world matrix
Assertion '%s' failed. We badly computed zFar (%f) and zNear (%f) in this scene
Error: Given sources must be of the same length for interval list creation
Assertion '%s' failed. different material!!!!
Warning: __MergeMeshSources unknown source type
Assertion '%s' failed. __AllocateNewSource - componentsCount is zero
Assertion '%s' failed. inconsistency in _finalizeSplit
Assertion '%s' failed. _finalizeSplit - inconsistent data length
Assertion '%s' failed. _createSubSource - inconsistent data length
Error: C3DSourceAccessorCopyDataToAccessor failed
Warning: C3DUnifyNormalsFromGeometry can only process triangles and polygons
Warning: C3DUnifyNormalsFromGeometry empty indices
Assertion '%s' failed. unexpected vertex count
Assertion '%s' failed. NULL allocator
Error: inconsistency in lru list
Error: inconsistency in lru list (2)
Error: [SCNAction sequence:] invoked with nil
Assertion '%s' failed. Wrong probe type
Assertion '%s' failed. Wrong light type
Assertion '%s' failed. Slice index should have been attributed already
Assertion '%s' failed. first light was not of the same index
Assertion '%s' failed. end index should be set already
Assertion '%s' failed. previous light was not of the same index
Assertion '%s' failed. nextIndex out of range
Assertion '%s' failed. Should be non empty
Assertion '%s' failed. range overflow
Assertion '%s' failed. Pass input descriptor out of bound access %d
Assertion '%s' failed. Pass output descriptor out of bound access %d
Assertion '%s' failed. input resource index out of bound %d
Assertion '%s' failed. output resource index out of bound %d
Assertion '%s' failed. Adding dependency on self
Assertion '%s' failed. Input buffer parameter index out of bounds
Assertion '%s' failed. Output buffer parameter index out of bounds
Welcome to SceneKit 602 (Jul  4 2024 02:58:40)
Assertion '%s' failed. invalid handle (%d) given
Assertion '%s' failed. no more handle available
Assertion '%s' failed. can't move negative number of data
Assertion '%s' failed. overflow !
Assertion '%s' failed. child must be one level under parent
Assertion '%s' failed. C3DNodeIterateTree : null node
Assertion '%s' failed. C3DNodeIterateTree : no callbacks
Error: Could not create texture with descriptor : %@
Unreachable code: Wrong texture given to the cache %@
Error: object %@ doesn't conform to the copying protocol
Error: invalid ref count for entity %@
Assertion '%s' failed. Must call GetScene with an entity
Error: Failed to instantiate unarchiver with error %@
Assertion '%s' failed. Stack Pop error
Assertion '%s' failed. C3DStackSetValue only accept CFTypeRef stacks
Assertion '%s' failed. C3DStackGetValue only accept CFTypeRef stacks
Assertion '%s' failed. range not found
Unreachable code: Argument type not supported %d
Unreachable code: OpenSubdiv support not implemented yet for constant shaders
Error: Invalid shader modifier: programmable blending is not supported by this device
Error: cannot handle more than one lighting modifier
Assertion '%s' failed. wrong entry point
Error: Invalid shader modifier : no code provided
Unreachable code: Multiple rendering is lacking a multiple output vertex streams generator
Assertion '%s' failed. Infinite lights can only be dir or unranged omni
Assertion '%s' failed. No more than 4 components for mesh source value types
Error: Morph: target vertex count do not match base vertex count (%d != %d)
Error: MeshSource packing only supports non interleaved float sources
Assertion '%s' failed. Provided mesh element is not an interval list
Error: Conversion from other types than float is not supported
Error: Conversion of an interleaved source is not supported, please convert your sources before interleaving
Error: C3DMeshSourceCreateCopyWithComponentsBaseType: unsupported type
Error: Conversion from %@ to %@ to is not supported
Error: no meshSource deserialize => semantic in mesh source
Error: _C3DMeshSourceCopyPropertyList unsupported semantic
Assertion '%s' failed. C3DFramebufferRegistryRetainTextureWithName retainCount==0
Assertion '%s' failed. _removeReference - index==0
Assertion '%s' failed. _C3DAnimationManagerAddAnimationNode - cluster not expected
Warning: fail to setup the animation - won't be added to the animation stack
Assertion '%s' failed. _C3DAnimationManagerAppendCallback triggered while animation manager is muted
Assertion '%s' failed. C3DAnimationManagerUpdateConstantCount
Assertion '%s' failed. C3DAnimationManagerNeedsRedraw - inconsistant constant count
Error: Binding: Unable to resolve destination keypath: %@(%@)
Error: Binding: Trying to bind two incompatible keypaths: %@(%@) -> %@(%@)
Assertion '%s' failed. C3DAnimationManagerNewStackWithKey key already exist
Assertion '%s' failed. unexpected semantic
Assertion '%s' failed. C3DAnimationManagerNewStackWithKey key doesn't exist
Error: _resolveAnimationGroupTargets - can't find common ancessor
Assertion '%s' failed. Inconsistency in _C3DAnimationManagerRemoveAnimationNode: triggered while applying animations
Assertion '%s' failed. C3DAnimationManagerRemoveAnimationNode removing an animation while applying
Assertion '%s' failed. _C3DPreviousKeyIndexForTime - unexpected integer division
Error: C3DKeyframeControllerSetKeyframeAtIndex - time is NaN
Error: C3DKeyframeControllerRef - index out of bounds
Assertion '%s' failed. C3DKeyframeControllerEvaluateAtTime animation has no key
Warning: can't simplify keyframes because of cubic interpolation
Warning: can't simplify keyframes because of tcb values
Warning: can't simplify keyframes because of timing functions
Assertion '%s' failed. wrong number of keyCount in data
Error: failed to deserialize animation data
Error: _C3DKeyframeControllerFlattenKeyframeData unexpected value
Assertion '%s' failed. _C3DKeyframeControllerFlattenKeyframeData bad value type
Error: _C3DKeyframeControllerCreateKeyframeArray unknown key type
Warning: _C3DKeyDistance - can't compute key distance for type %d
Unreachable code: Unknown SCNSceneRenderer conforming class
Error: Cannot append manipulator vertex data because we encountered an overflow and we are not allowed to flush
Assertion '%s' failed. A mesh should have been allocated by now
Assertion '%s' failed. Can not nest two Timed record
Warning: ring buffer is full [%d/%d]
Assertion '%s' failed. start != end
Assertion '%s' failed. Found crease element with more than 1 channel
Assertion '%s' failed. Only GL_LINES and kC3DManipulatorDrawModeTriangles are supported
Assertion '%s' failed. basevertex should be 0 here.
Assertion '%s' failed. Base index should be reset at this point
Unreachable code: Unknown use of manipulators
Assertion '%s' failed. There should be at lease a valid C3DRendererContext or a valid SCNRenderer
Assertion '%s' failed. No program for the auth env!
Assertion '%s' failed. __appendRect2D: uv but not texture
Assertion '%s' failed. __appendRect2D: no uv but texture
Error: Unable to create context
Assertion '%s' failed. C3DAnimationStackInit called twice
Assertion '%s' failed. C3DAnimationStack invalid
Assertion '%s' failed. unexpected animation node class
Assertion '%s' failed. unexpected size
Error: didAddToPhysicsWorld - can't share a physics behavior to multiple world
Warning: Character should already have a body
Error: SCNMTLRenderContext initWithDevice : device should not be nil
Error: SCNMTLRenderContext initWithDevice : cannot create a command queue. Bailing out.
Error: Deallocating render context with %d outstanding command buffer scheduling handlers
Error: Deallocating render context with 1 outstanding command buffer scheduling handler
Error: Deallocating render context with %d outstanding command buffer completion handlers
Error: Deallocating render context with 1 outstanding command buffer completion handler
Error: Deallocating render context with %d outstanding drawable presentation handlers
Error: Deallocating render context with 1 outstanding drawable presentation handler
Error: Main command buffer execution failed with status %d, error: %@
Warning: Failed getting a valid drawable. Skipping this frame.
Error: Resource command buffer execution failed with status %d, error: %@
Assertion '%s' failed. Control point indices must be 16-bit or 32-bit
Assertion '%s' failed. Only triangle arrays are supported for tessellation
Unreachable code: Cannot render video background with an unspecified source type.
Error: cannot renderMesh without a vaid passDescriptor
Assertion '%s' failed. Volatile mesh must have been mapped already
Assertion '%s' failed. shader does not support batching!
Assertion '%s' failed. unexpected engine context
Error: can not render without programs, using default
Assertion '%s' failed. C3DDeformerTransforms is not supported when instancing is active
Assertion '%s' failed. 
Unreachable code: Internal consistency error
Error: _executeProgram - no pipeline state
Error: pass has no storage for input %@
Error: binding is broken : neither block or semantic
Assertion '%s' failed. Light indices buffer has wrong size
Assertion '%s' failed. size mismatch for sh coefficients
Assertion '%s' failed. only shOrder 3 supported with function constants
Assertion '%s' failed. Cannot set more than 4 matrices for cascade shadows
Assertion '%s' failed. You can only map volatile mesh
Assertion '%s' failed. Mesh should have volatile data to allocate
Assertion '%s' failed. Mesh should be mapped
Assertion '%s' failed. MeshElement should be mapped
Assertion '%s' failed. Mesh should not be already mapped
Assertion '%s' failed. Hidden nodes should have been removed from the pipeline already
Assertion '%s' failed. Fully transparents objects should have been removed from the pipeline already
Error: C3DEngineContextRenderTechnique - unknown draw instruction
Error: _initializeRenderFromLightPass - no light
Error: _initializeDeferredShadows - no light
Error: _willExecuteDeferredShadows - no light
Error: _setupDeferredShadows - no light
Error: _C3DKeyframedAnimationInitWithPropertyList serializedData invalid
Error: _C3DKeyframedAnimationInitWithPropertyList plist invalid
Assertion '%s' failed. Completion item will be released without having handled a completion or interruption event. This can lead to an inconsistent state.
Error: can't set a property (%s::%d) on the presentation instance %@ - ignoring
Assertion '%s' failed. __removeAnimationForKey: cftype is not an entity
Error: attempt to add a null animation player on %@
Error: attempt to add a null animation on %@
Assertion '%s' failed. sync animations: cftype is not an entity
Error: referenced particle systems can't be resolved without a SCNAssetCatalog
Error: particle reference name is nil
Error: animation class %@ is not supported for particle systems
Error: Can't introspect type of property %@
Error: unknown particle controller input mode
Error: Cannot build cubemap from array of images because image at index %d is NULL
Error: Cannot build cubemap from array of images because image at index %d is not square: %fx%f
Error: Cannot build cubemap from array of images because image at index %d (%fx%f) does not have the expected size (%zux%zu)
Error: Cannot build cubemap from array of images because conversion to CGImageRef of image at index %d failed
Error: Cannot build column cubemap from non-cubemap image
Warning: Failed to create bitmap context for CG image %@
Assertion '%s' failed. Can't get name for non catalog texture
Error: failed to map image data for image inside %@
Error: failed to resolve image inside %@
Error: Failed to create image source from data %@
Error: Failed to create image from image source %@ (status: %d)
Assertion '%s' failed. C3DImageCacheBitmap context is not null when it should be
Error: failed to create a CGBitmapContext from a CGImage for %@
Info: FixIncorrectPremultiply %@ time %u x %u : %fms
Error: Unknown cubemap image type
Error: Cannot support rotation layout for compressed texture
Error: Unknown Texture3D image type
Assertion '%s' failed. image has already compression infos
Error: failed to load image with description: %@
Warning: serialize C3DImage: empty image
Error: _C3DImageCopyPropertyList error retrieving path
Error: Failed to load %@
Error: unable to get a CGImageRef from image
Warning: While reading a texture sampler: could not read %@ (serializedData: %@), using the default value %d instead
Error: Could not serialize an integer
Error: convexSweep only works with convex shapes
Assertion '%s' failed. Node should be visible
Assertion '%s' failed. update should not be called if not implemented by the delegate
Warning: PhysicsWarn: %s
Info: Reload Shaders
Assertion '%s' failed. wrong viewport
Assertion '%s' failed. src and dst count must be equal
Error: unsupported conversion %@ -> float4
Unreachable code: not implemented
Assertion '%s' failed. cannot remove null span
Assertion '%s' failed. page overflow
Assertion '%s' failed. wrong page selected for span size %d
Error: RendererElementStore does not support span of more than %d
Assertion '%s' failed. pages are broken...
Assertion '%s' failed. handle is broken...
Assertion '%s' failed. re is broken...
Error: SCNLayer::copyCGLPixelFormatForDisplayMask -> unable to find a valid pixel format
Error: copyCGLContextForPixelFormat: cannot create context error %d
Assertion '%s' failed. unoptimal : don't keep empty arrays
Error: program failed to build:
Error: Cannot compile empty shader %@
Error: %3d: %@
Error: failed to link program: %s
Error: C3DRendererContextSetupResidentMeshSourceAtLocation:not handling type, using float as default
Error: C3DRendererContextCreateProgramObjectForProgram : missing vertex shader
Error: C3DRendererContextCreateProgramObjectForProgram : missing fragment shader
Error: C3DRendererContextCreateProgramObjectForProgram metal program unsupported
Error: C3DRendererContextCreateProgramObjectForProgram unsupported program
Warning: Trying to delete an empty or already released VBO
Error: image copy did fail: %@
Assertion '%s' failed. gl texture allocation failed
Assertion '%s' failed. inconsistent sample count
Error: C3DRendererContextSetupFramebuffer invoked twice on a Framebuffer
Assertion '%s' failed. C3DRendererContextUnbindFramebuffer - fbo is not bound
Unreachable code: C3DRendererContextUnbindFramebuffer - no fbo bound
Warning: C3DRendererContextInferTextureTargetForImageTypeAndTextureSampler: called with kC3DTextureUntype type should be resolved before calling it, using GL_TEXTURE_2D as fallback
Assertion '%s' failed. Wrong light index %d
Assertion '%s' failed. C3DRendererContextSetLight texture unit out of bounds
Error: Physically based lighting model is not supported by the OpenGL renderer, using Phong instead
Error: C3DRendererContextCreateBufferObjectForMeshSource - mesh source has no data
Assertion '%s' failed. mesh elements to vbo id dictionary should already be allocated
Error: C3DRendererContextBindMeshElement unsupported byte per index (%d)
Assertion '%s' failed. `polygon array` is not a supported element type for volatile meshes
Assertion '%s' failed. there should be at least one primitive of a known type
Assertion '%s' failed. mesh elements to vbo id dictionary should be allocated by now
Assertion '%s' failed. mesh element should be volatile
Assertion '%s' failed. fillProgramLocation: index out of bounds
Error: __FillProgramObjectLocations uniform index out of bounds
Error: Cannot load image %@.
Error: For best performance when using OpenGL, consider adding the `SCNDisableLinearSpaceRendering` and `SCNDisableWideGamut` keys with a bool value of `YES` to your app's Info.plist
Error: _createTextureForRenderTarget - fbo size is zero
Error: _createRBOForRenderTargetDescription - fbo size is zero
Unreachable code: NOT IMPLEMENTED
Error: Max number of texture unit (%d) is reached - can't bind a new texture
Error: We do not handle property %d to get the program attribute enum for the texture (using default: diffuse)
Assertion '%s' failed. Cube conversion can only happen for global probe
Assertion '%s' failed. Bad index
Assertion '%s' failed. Out of bound Array:%p access %d size %d
Warning: We do not support skipping <param>s yet
Warning: We do not support alternating types yet
Info: zNear of 0 found while loading DAE - will use 0.01 instead
Warning: Found a camera without either an orthographic specification or a perspective one. Discarding the camera. Please ensure the document has been checked for consistency.
Warning: Could not get the controller referenced by the URL %s. Please ensure the document has been checked for consistency
Warning: Could not interpret the URL %s
Warning: Could not interpret (2) the URL %s
Warning: Could not initialize an image, an init_from element is needed
Error: The DOM could not be loaded
Error: failed to resolve referenced animation %@ at index %ld
Warning: The instance_effect with URL %s does not reference an effect, skipping it
Warning: Found an invalid material [%s], reverting to a default material
Warning: We cannot yet read geometries without IDs; discarding one
Error: Cannot create an unique ID for a node
Warning: Node %@: we do not handle multiple controller instances per node. Using the first and skipping the others
Warning: We do not handle multiple controller instances per node. Using the first and skipping the others
Warning: Could not create an instance_node, no URL specified. Please check the document for consistency.
Assertion '%s' failed. We only support internal URIs for now
Warning: Could not find a skeleton for the URI %s
Warning: Could not find a node for the skeleton with the URI %s
Error: Found a Rotate element without the 4 required floats, please ensure the document has been checked for coherency
Error: Found a translate element without three associated floats; please ensure the document has been checked for consistency
Error: Found a scale element without three associated floats; please ensure the document has been checked for consistency
Warning: We do not handle skew transforms yet
Warning: [Coherency check] %s %s
Warning: No bind_material in %s
Warning: Invalid bind_material %s: no technique_common
Warning: Unknown array type %s
Warning: Ignoring a non-required invalid input
Warning: Ignoring error XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 on a texture element as it is a bit too harsh with texcoords
Warning: Ignoring error XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 on a source_data element
Warning: Ignoring error XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 on a node element (Illusoft exports wrong layer attributes)
Warning: Ignoring an invalid URL exported by older exporters in an init_from element
Warning: Ignoring an invalid names or IDs exported by exporters
Warning: Ignoring error concerning empty library_images elements
Warning: Ignoring error concerning empty technique_common elements
Warning: Ignoring error concerning empty animation elements
Warning: Ignoring error concerning multiple texture elements
Warning: Ignoring error concerning slots exported in the wrong order
Warning: Ignoring error from an extra or physics element
Warning: Ignoring error concerning <annotate> elements
Warning: Ignoring an invalid SID attribute error
Warning: Ignoring an invalid URL attribute error
Warning: Ignoring an empty ID or name attribute on visual_scene error
Warning: Ignoring error concerning <extra> and <node> exported in the wrong order
Warning: Ignoring error concerning <subject> and <title> exported in the wrong order
Warning: Ignoring error concerning non-existent canvas_aspect element
Warning: Schema validation warning: msg=%s (%s:%d) (code %d)
Warning: Cannot perform validation, validation context could not be created
Error: Failed to parse the XML document (base URL: %s)
Error: Index out of bounds.
Error: <vertices> not found in mesh, please check the document for consistency
Error: Deindexer: source %s has a count of %d, but the morphed source %s has a count of %d
Error: Deindexer: Detected a morph target and a morph source which do not have the same number of vertices
Warning: Targets input missing in a <morph> element, ignoring the morph
Warning: Invalid <input> in a <morph> element, ignoring the morph
Warning: We only support name arrays and IDREF arrays for morph targets for now, ignoring the morph
Warning: Found a morph target which does not exist or is not a geometry, ignoring the morph
Warning: Could not interpret or find the image for the id %s, ignoring it
Warning: Could not find the image information for the id %s, ignoring it
Warning: Could not find the image information (empty fx_surface array), ignoring it
Warning: Unsupported domFx_surface_type_enum
Error: Expecting a surface
Error: C3DIO_COLLADA_ReadEffect error 4
Error: invalid property name
Error: Found errors while checking the document for coherency:
Error: %@
Error: Could not deindex.
Error: Unable to get the referenced visual_scene
Error: Could not get the instance_visual_scene
Error: invalid collada file - missing animation input
Warning: failed to create an animation keyframes for: %s
Warning: failed to create an animation target for: %s
Warning: failed to create an animation for target: %s
Warning: kvcPathForElement: We do not know how to handle elements named %s
Error: Found a Rotate element without 4 attached floats. Please check the document for consistency.
Warning: kvcPathForElement: unknown color slot: %s
Warning: kvcPathForElement: unexpected color path
Warning: inconsistent keyframe length
Error: invalid tangent buffer length
Warning: trying to animate kC3DBaseTypeNone
Error: _sampleAndAddAnimations can't find transform stack for node %@
Error: animation duration is too long: %f - skip sampling
Error: animation duration is too long (>9hours) to be sampled - skipping
Error: unable to sample transform animation - fail to transpose animation target
Error: unable to sample transform animation - no transform found with sid %@
Error: unable to sample transform animation - no transform sid found
Warning: failed to evaluate animation to bake animation
Error: unable to sample transform animation - to parent animation to attach sampled animation
Error: _C3DCreateTransformAnimationChannelFromChannels - no path
Warning: invalide animation group detected
Warning: loaded an animation with duration == 0
Error: C3DIO_COLLADA_ReadMesh: geometry should already be cached into the library
Warning: The source %s does not have a Technique_common element. This might be caused by an exporter bug. Skipping it.
Warning: Found a source %s without a Technique_common element. This might be caused by an exporter bug. Skipping it.
Warning: The source %s has some unsupported traits (advanced params or non-float arrays). Skipping it
Warning: Found a source with some unsupported traits (advanced params or non-float arrays). Skipping it
Warning: The source %s has some unsupported traits (non-float array or interleaved arrays). Skipping it
Warning: Found a source with some unsupported traits (non-float array or interleaved arrays). Skipping it
Warning: Found an invalid source (stride == 0). Skipping it
Warning: Invalid source %s: offset + stride * count > source count. Skipping it
Warning: Found an invalid source (offset + stride * count > source count). Skipping it
Warning: Source %s: unsupported semantic %s. Skipping it.
Warning: Found an source with the unsupported semantic %s. Skipping it
Error: C3DIO_COLLADA_ReadElements: geometryElement references an index out of bounds - ignoring
Error: __CreateMeshElement inconsistent index count
Unreachable code: Unsupported element index size (%d)
Error: Invalid polygon array indices buffer size
Warning: The morph base geometry does not exist or is not a geometry, ignoring the morph
Warning: Unable to read the geometry of one of the targets, ignoring the morph
Warning: Weights input missing in a <morph> element, ignoring the morph
Warning: Lightmap image at path %s not found, can't create lightmap info
Warning: No path found, can't create lightmap info
Warning: Skipping the skin with source %s: it is not a geometry, or it is an invalid geometry
Error: Skipping the skin with source %s: we only support joints elements with joints and inverse bind matrices
Error: Skipping the skin with source %s: a joints source should have either a name array or an IDREF array
Error: Skipping the skin with source %s: inv bind matrices need to be 4x4 matrices. Please ensure the document has been checked for consistency
Error: Skipping the skin with source %s: a inv bind matrix accessor should have only one param
Error: Skipping the skin with source %s: a inv bind matrix should be a float4x4
Error: Skipping the skin with source %s: the number of floats describing the inverse bind matrices should be 16 * number of joints
Error: Skipping the skin with source %s: found two different sources for the bones
Error: Skipping the skin with source %s: vertex weights source not found
Error: Skipping the skin with source %s: vertex weights source accessor does not reference the source's float array
Assertion '%s' failed. invalid skin
Warning: could not find bundle %@, fall back to main bundle
Error: No source referencing the <vertices> element found
Error: [Deindexer] Found a vertices element without a POSITION source
Error: [Deindexer] Found a mesh element without a <vertices> element in its inputs
Error: [Deindexer] Vertices %s: index %llu -> %llu out of bounds (%llu)
Error: [Deindexer] Input %d: index %llu out of bounds (%llu)
Error: [Deindexer] Source resizing failed, the size to allocate was probably too big
Error: [Deindexer] Source resizing failed, old/new indices are out of ranges
Error: [Deindexer] Source %s: index %llu out of bounds (%llu)
Error: [Deindexer] Vertices %s: index %llu out of bounds (%llu)
Error: [Deindexer] Found a source referencing %s which is not a vertices or input element
Error: [Deindexing] Target %d of a morph does not have a mesh
Unreachable code: Invalid CommonProfile generator
Warning: Failed to create program for hashcode %@: %@
Error: C3DCommonProfileProgramReleaseHashCode can't find cache for tracked resource
Assertion '%s' failed. wrong notification sent
Unreachable code: _getCIFilterParameterValue - unexpected type
Error: _applyCIFilter can't fint render target named SceneKit-CI-nodetree-color
Warning: CIFilter should have been clipped by the culling
Warning: CIFilter should have been clipped by the culling (2)
Assertion '%s' failed. _createCIImageForTexture texture is not rect
Unreachable code: Could not find mesh source indexing info for source %p
Unreachable code: Unssuported texture coordinates channel (%d)
Unreachable code: Does not make sense
Unreachable code: Trying to subdivide a mesh that does not have exactly 1 position source.
Warning: Subdivision process might lead to gaps in surface because vertex welding is disabled when subdividing on the GPU
Assertion '%s' failed. Error while building face-varying channel.
Assertion '%s' failed. Internal consistency error
Unreachable code: Internal consistency error - Unexpected element type
Error (OpenSubdiv): %s
Warning (OpenSubdiv ): %s
Assertion '%s' failed. Semantic %d can not be a primvar
Unreachable code: Can not subdivide primvar data with %d values per component
Assertion '%s' failed. Can't subdivide further
Unreachable code: Invalid GPU primvar semantic '%@'
Assertion '%s' failed. Primvar data size is too big (cannot fit %d floats in a float4)
Assertion '%s' failed. Position sources must use the 'vertex' interpolation mode
Assertion '%s' failed. Number of normals at limit surface is not equal to number of vertex positions
Error: Position must be float3 to be subdivided. Actual type is %d
Assertion '%s' failed. C3DFramebufferCleanup - bad retain count
Assertion '%s' failed. can't render to texture if multisampled
Error: Could not issue extension for path: %s.
Assertion '%s' failed. program is of wrong type
Error: C3DResourceManagerMakeProgramResident failed to compile program - fallback on default program
Error: rendererContext is not tracked by the resource manager
Error: __ResourceManagerDeleteTexture: texture to be deleted not found, bail out
Error: _C3DResourceManagerDeleteTexture source does not match to any stored texture (no texture samplers associated)
Error: _C3DResourceManagerDeleteTexture can't find image source
Warning: C3DResourceManagerMakeImageResident invalid image
Warning: single texture is larger than memory limit
Assertion '%s' failed. Calling C3DRasterizerStatesCFFinalize outside of C3DReleaseRasterizerStates probably direct call to CFRelease
Assertion '%s' failed. RasterizerStates should be in the registry
Warning: Warning _lightNodes not NULL in C3DEnginePipelineSetup
Assertion '%s' failed. wrong notification type
Error: unexpected renderer element with no material/technique/program
Unreachable code: Unsupported node attribute '%@'
Assertion '%s' failed. no render elements have been created
Assertion '%s' failed. C3DTriangle3PointAtIndex: index out of bounds (%d)
Warning: C3DTriangle3BarycentricCoordinates: unable to solve the equation
Error: C3DRendererContextSetValueUniformAtLocation not implemented for this type (%d) yet
Error: uniform has incorrect type
Assertion '%s' failed. wrong length
Error: set transform not implemented on %@
Error: set world transform not implemented on %@
Error: set position not implemented on %@
Assertion '%s' failed. invalid iteration count
Error: OpenSubdiv unarchiver command buffer execution failed with status %d, error: %@
Unreachable code: Unsupported patch type
Assertion '%s' failed. GPU support for OpenSubdiv must not be enabled when there is a tessellator but the subdivision level is still 0.
Error: Invalidating OpenSubdiv runtime data of geometry %@
Assertion '%s' failed. %s called but there's no patch to draw.
Error: OpenSubdiv command buffer execution failed with status %d, error: %@
Assertion '%s' failed. Internal consistency error.
Error: OSD_MAX_VALENCE is set to %d and current mesh has a max valence of %d
Error: OpenSubdiv archiver dependency command buffer execution failed with status %d, error: %@
Error: OpenSubdiv archiver command buffer execution failed with status %d, error: %@
Error: C3DImageToMDLTexture not supported for image 3D
Warning: Failed to create cubemap from Model I/O texture
Assertion '%s' failed. Found in-between morph target with influence weight of %f
Warning: Warning: unable to flip non-float2 texture coordinates, skipping
Error: unknown MKGeometryType
Error: a MDLObject has more than 1 child mesh - not supported
Error: failed to find MKMaterial corresponding SCNMaterial
Error: Unknown Model I/O semantic %@
Assertion '%s' failed. C3DEffectCommonProfileGetHashCode: inconsistency error
Error: No function %@ in the common profile %@
Error: Could not deserialize the color %@
Error: C3DEffectCommonProfile DeserializeColor: No property for the key %@
Error: Common profile deserialization: could not read the property %@
Error: Common profile deserialization: property found for the key %@
Error: Could not deserialize the texture sampler %@
Assertion '%s' failed. Too many objects
Error: Cannot find the specified image
Error: Cannot find the image ID for the key %@ in the dictionary %@
Error: orphan effect common profile detected
Warning: __OpacityFromColorSlot:unexpected transparency mode %d
Assertion '%s' failed. LightingEnvironment not set on a Light or a Scene
Assertion '%s' failed. We do not support appending to really complicated interleavings
Error: C3DMeshSourceAppendVector3 - Type not supported
Error: C3DMeshSourceAppendVector2 - Type not supported
Error: C3DMeshSourceCreate: unsupported type
Assertion '%s' failed. Cannot set volatile data of a non volatile source
Assertion '%s' failed. Morph target has a vertex count different from the base geometry
Assertion '%s' failed. Internal consistency error, %@'s (%p) morph %p is not sparse
Error: AnimCodec - Failed to compress mesh
Error: AnimCodec - Failed to parse header
Error: AnimCodec - Failed to decompress animation
Error: AnimCodec - Can't decode metadata
Error: unsupported SH order
Assertion '%s' failed. _computeNeighbourIndexes - missing tetrahedron
Assertion '%s' failed. overwrite a neighbour index
Assertion '%s' failed. wrong data size for SH
Error: SH order unsupported : %d
Assertion '%s' failed. Should never have been outside the tetras
Error: _buildTetrahedrons - failed with first tetrahedron
Error: tetrahedrisation: index out of bounds
Assertion '%s' failed. will make an invalid tetrahedron valid
Assertion '%s' failed. validTetraCount > indexToRecycle
Assertion '%s' failed. _faceHasEdgeSharedWithMoreThanTwoOtherOpenFace
Assertion '%s' failed. memory smasher found in C3DEdgeArrayCreateFromMeshElement (%ld != %ld)
Assertion '%s' failed. C3DEdgeArrayGetEdgeAtIndex index out of bounds
Assertion '%s' failed. C3DTriangulationInfoCreateFromMeshElement - edge out of bounds
Error: C3DMeshElementEditorCreateWithMeshElement: mesh element is not a triangle array
Error: _C3DMeshElementEditorSetIndex unknown bytes per index
Error: C3DMeshElementEditorSubdivideTriangleAtIndex: triangleIndex out of bounds
Error: inconsistency - material count doesn't match - can't diff reference node
Error: inconsistency - material has custom properties - can't diff reference node
Error: inconsistency - hierarchy doesn't match - can't diff reference node
Error: inconsistency - hierarchy changed - can't diff reference node
Error: failed to parse key path %@ - missing '['
Error: failed to parse key path %@ - missing ']'
Error: failed to evaluate key path %@ - material index %d out of bounds (%d)
Error: failed to locate scene reference %@
Error: failed to resolve referenced scene (%@) cycle detected
Error: referenced animations can't be resolved without a SCNAssetCatalog
Error: referenced actions can't be resolved without a SCNAssetCatalog
Error: Index %ld out of range bounds [0...%ld]
Error: Index %ld out of bounds [0...%ld]
Error: Failed to deserialize an animation because it is of an unknown type (%@)
Unreachable code: C3DAnimationSetup - unknown animation class
Error: C3DSimpleAnimationEvaluate - invalid evaluation function
Error: SimpleAnimation deserialization: could not deserialize the animation
Error: _C3DSimpleAnimationInitWithPropertyList - no base type
Error: Failed to load IES profile : %@
Assertion '%s' failed. Light should be a IES
Error: While deserializing a light: could not decode the number for the key %@ (serializedData : %@)
Error: While deserializing a light: no value for the key %@ (serializedData : %@)
Error: While deserializing a light: could not decode the color
Error: While deserializing a light: could not decode the shadowcolor
Info: invalid zNear value (0) set to camera
Error: C3DProjectionInfosUnproject : invalid viewport dimension
Error: error in C3DProjectionInfosUnproject
Info: loaded camera has an invalid zNear value (0)
Error: CVMetalTextureCacheCreateTextureFromImage failed with status %d
Error: Could not get pixel buffer (CVPixelBufferRef)
Error: Could not create AVCaptureInput with error: %@
Error: Pixel buffer (CVPixelBufferRef) must be IOSurface-backed
Error: Invalid pixel buffer pixel format: %s
Error: Authoring pass can't find input depth pass.
Error: Unsupported draw instruction kC3DFXDrawGeometry
Error: Unsupported draw instruction kC3DFXDrawMetalCustom
Assertion '%s' failed. Unable to find dependency in previous techniques for pass %s
Unreachable code: Invalid render buffer type for attachment type
Unreachable code: Invalid render buffer type for attachment id
Assertion '%s' failed. attachementID out of bounds
Unreachable code: Invalid semantic for attachment id
Assertion '%s' failed. Render target not found
Assertion '%s' failed. need subdivision level
Assertion '%s' failed. child is already inserted in a tree
Assertion '%s' failed. prevChild is not parented to the right node
Warning: C3DNodeGetWorldMatrix - no transform tree
Assertion '%s' failed. Node should have a TT handle already
Assertion '%s' failed. layer index out of bound
Error: inconsistency in scene graph found in C3DNode finalize
Error: Could not read a matrix (serializedData: %@)
Error: Could not read a quaternion
Error: Could not read Euler
Error: Could not read the axis angle
Error: Could not read a matrix
Error: No data present to deserialize a rotation (serialized data : %@)
Error: Could not read a transform, position, scale and rotation have to be present (serializedData: %@)
Error: loading pivot from compressed collada file is not supported anymore - use SCN file format instead
Assertion '%s' failed. _serializeNodeAttribute lighmap not serialized
Error: Node deserialization: cannot retrieve the object ID
Warning: Node<->attribute inconsistency finalizing deserialization
Error: Node deserialization: cannot retrieve the lightmap image ID
Error: Node deserialization: cannot retrieve the lightmap image
Assertion '%s' failed. Node should already be in CullingSystem
Assertion '%s' failed. No double position sources allowed
Warning: Mesh '%@' : sources of redundant semantic '%@' will be ignored in rendering
Assertion '%s' failed. Mesh sources are not sorted correctly
Assertion '%s' failed. Mesh sources with same semantic non contiguous
Error: Mesh deserialization: cannot find the sources in %@
Info: Mesh deserialization: Skipped a source that will be recreated at runtime : %@
Error: Mesh deserialization: cannot find the specified source
Error: Mesh deserialization: cannot deserialize a source
Error: Mesh deserialization: cannot init a mesh element
Assertion '%s' failed. Can't copy bounding volumes from meshes with different element count
Assertion '%s' failed. Mesh sources are malformed
Assertion '%s' failed. Renderable data kind must not give a channel
Assertion '%s' failed. need to provide a valid channel index when adding a new source
Assertion '%s' failed. Could not find source with semantic %@ at index %d
Unreachable code: Internal consistency error in %s
Warning: Can only convert to lines or points element type
Warning: Can only convert from triangle array to another element type
Error: Cannot find the specified primary source
Error: Cannot find the specified source
Assertion '%s' failed. This accessor doesn't point back to the primary source
Error: Could not deserialize a source locator in %@
Assertion '%s' failed. Too many objects in the library
Assertion '%s' failed. This source should be a primary one
Warning: Can't add two position sources
Error: __C3DMeshCopy - unable to resolve interleaved mesh
Error: Failed to build renderable data for mesh %p
Assertion '%s' failed. Consistency error: there must be as many renderable elements as original elements
Warning: Mesh element %p of mesh %p has %d channels but they all define the same topology
Error: Deindexer failed - Source %p (%@) has no original data at index %u
Assertion '%s' failed. Deindexer failed - Hash value inconsistency
Assertion '%s' failed. Deindexing failed - Vertex count inconsistency
Warning: Mesh %p has multiple channels but deindexing didn't have any effect
Warning: Deindexing - Vertex at index %u of %u is not used by any geometry element
Assertion '%s' failed. Deindexing failed - Count of deindexed mesh sources does not match count of indexed mesh sources
Assertion '%s' failed. Deindexing failed - Count of deindexed mesh elements does not match count of indexed mesh elements
Unreachable code: Requested channel (%d) does not exist in element (%p)
Assertion '%s' failed. Two elements in the same mesh do not have the same number of index channels
Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)
Assertion '%s' failed. %s - Cannot create a renderable topology from indexed vertices
Error: %s - Invalid polygon edge count (%u)
Error: __C3DMeshElementCreateRenderablePrimitiveTypeCopy - polygon %u (%u vertices, indices [%u, %u]) does not fit in index buffer (%u elements)
Error: Inconsistent index count after triangulation.
Error: SCNAction: Custom actions can not be properly encoded, Objective-C blocks do not support NSSecureCoding.
Error: SCNAction: Custom actions can not be properly decoded, Objective-C blocks do not support NSCoding.
Assertion '%s' failed. invalid fill mode
Unreachable code: Blend mode not implemented.
Warning: Could not deserialize an effect
Assertion '%s' failed.  - Only vector3 type is supported.
Warning: Slider can only process triangles.
Warning: Occluder can only process triangles.
Warning: C3DSceneSetRootNode - old root node seems to be already connected to another scene
Assertion '%s' failed. Only %d layers are available, but layer %d requested
Warning: RootNode is not retained by the scene
Error: Could not read the animations manager
Error: C3DSceneRef _copySerializedHierarchy: lib entry not found
Warning: Some nodes failed to be deserialized
Error: ... and we do not even have a root node, so bailing out
Error: Scene deserialization : cannot finalize the deserialization of the animation manager
Error: Library could not remap the ID %@
Error: _deserializeHierarchy: could not find the specified node in the library
Error: _deserializeHierarchy: no nodeID specified!
Unreachable code: You can't change the sceneRef of a scene
Warning: %@: zNear of 0 is not allowed
Assertion '%s' failed. inconsistent physically-based camera settings
Error: failed to create a GL context with the pixelFormat %@
Warning: SCNCreateGLContext - failed to share our context with SpriteKit - fallback on a private context
Unreachable code: _setupMaterialProperty -- should not reach
Warning: can't prepare shadable animation with path %@
Error: Material : %@ is not an animatable path
Error: Failed to archive material's custom attributes. %@ %@
Assertion '%s' failed. cannot update matrix without affine
Assertion '%s' failed. cannot update affine without matrix
Error: attempt to add a parent node as a child node
Error: removeChildNodeAtIndex - index out of bounds
Unreachable code: error in removeObjectFromChildNodesAtIndex -> try to remove inconsitent node
Unreachable code: circular reference found when trying to add %@ as a child node of %@
Unreachable code: error in replaceObjectInChildNodesAtIndex -> index out of bounds
Unreachable code: error in replaceObjectInChildNodesAtIndex
Error: error in removeFromParentNode : inconsistent tree
Error: removing the root node of a scene from its scene is not allowed
Assertion '%s' failed. _updateFocusableCache - invoked on a non focusable node (waste of time)
Error: Physics body %@ 's owner (%@) should be %@
Error: Physics body %@ already has a owner: %@ that is not %@
Error: attempt to add a null particle system on %@
Assertion '%s' failed. removeObjectFromMaterialsAtIndex: index out of bounds
Error: error while transposing skeleton or morph target
Error: error while transposing animations to cloned tree
Assertion '%s' failed. bad type
Assertion '%s' failed. bad image type
Assertion '%s' failed. bad cull mode
Assertion '%s' failed. bad fill mode
Assertion '%s' failed. bad blend mode
Assertion '%s' failed. bad blend operation
Assertion '%s' failed. bad comparison func
Assertion '%s' failed. bad stencil op
Assertion '%s' failed. Polygon Array not supported in Metal
Assertion '%s' failed. Triangle Fan not supported in Metal
Assertion '%s' failed. Patch not supported in Metal
Warning: r8Unorm_sRGB variant is not supported on macOS for this hardware. Defaulting to r8Unorm.
Warning: rg8Unorm_sRGB variant is not supported on macOS for this hardware. Defaulting to rg8Unorm.
Error: Failed to create Metal pixel format for %@ [%d components, %d bits per component, bitmap info: %u (%@|%@), float components: %@, color space: %@]
Unreachable code: Kernel functions have no corresponding program stage
Warning: unsupported texture type %d
Warning: C3DValueWriteToMTLData - Unsupported data type %@
Warning: value unsupported %d of member %@
Error: Unexpected pixel format %lu
Unreachable code: Unexpected antialiasing mode (%d)
Error: [SCNScene root] is deprecated, use rootNode instead
Error: can't convert c3dImage to cgImage %@ (url=%@)
Error: _subnodeFromIndexPath - invalid keypath
Error: %@ is not in a scene yet
Assertion '%s' failed. _subnodeIndexPath - unexpected count (hierachy was mutated?)
Warning: failed to load scene at %@
Error: failed to unarchive SCNScene - (secureCoding compliance issue?)
Error: SCNTextureSource abstract method invoked %@
Error: SCNImageSource astract method invoked %@
Error: SCNTextureDelegateSource::textureProxy -> no delegate
Error: C3DTextureSourceGetSharedRendererContext: cannot create context error %d
Assertion '%s' failed. wrong target index
Warning: Unknown render buffer format %hhu
Error: C3DCoreProfileSlotToAttachmentID : unknown slot
Assertion '%s' failed. DrawNodes must output in color or depth as first outputs
Assertion '%s' failed. Can't get a valid projection info
Warning: MappingChannel %d needed but not available
Assertion '%s' failed. too many io texcoord needed
Assertion '%s' failed. bad redirection index after sort
Assertion '%s' failed. weld - bad index
Assertion '%s' failed. weld - bad redirection
Assertion '%s' failed. weld - redirection out of bounds
Assertion '%s' failed. weld - bad duplicated vertex count
Assertion '%s' failed. weld: bad index
Info: PrefersOpenGL key is set in the plist but Metal is requested programmatically. GL will be used
Error: Failed to create default Metal device.
Error: switchToCameraNamed: no camera named %@
Warning: SCNView -> can't create a valid pixel format
Error: Can't set the pixel format of a Metal-based SCNView
Error: Pixel format defines an unknown sample count : %d
Error: attaching a single wheel to multiple vehicle is not supported
Unreachable code: invalid spatial handle (%d) given
Assertion '%s' failed. invalid spatial handle (%d) given
Assertion '%s' failed. handle should not point to non existing index
Assertion '%s' failed. Background was already rendered in the main pass
Error: <FlushMappedBufferRange> unsupported on OpenGL Compatibility profile
Error: syntax error in the uniform declaration : %@
Error: SCNRenderer::init - no engine context
Assertion '%s' failed. Private renderer only supports SCNView, SCNLayer or SCNMetalLayer
Assertion '%s' failed. device context doesn't conform to MTLDevice protocol
Warning: _deleteGLFramebuffer - No context!
Assertion '%s' failed. _beginFrame - unexpected rendering API
Warning: _prepareGLRenderTarget - No context!
Assertion '%s' failed. invalid framebuffer state
Assertion '%s' failed. invalid renderer (3)
Error: failed to create a framebuffer
Error: framebuffer width must be > 0
Error: framebuffer width (%d) exceeds device's limit (%d), clamping
Error: framebuffer height must be > 0
Error: framebuffer height (%d) exceeds device's limit (%d), clamping
Error: autoenablesDefaultLighting: renderer has no context
Error: setAutoenablesDefaultLighting: renderer has no context
Assertion '%s' failed. can't set a presentation instance as a point of view
Error: SCNRenderer::setTechnique - no engine available yet - ignoring
Assertion '%s' failed. warmUpScene: no gl context
Error: prepareObject:shouldAbortBlock renderer has no GL context
Error: prepareObject:shouldAbortBlock failed to create a shared context
Assertion '%s' failed. invalid renderer (4)
Error: glError before rendering SceneKit contents: %x
Assertion '%s' failed. can't call renderAtTime:withEncoder:pass:commandQueue: with a GL context
Error: Starting iOS 13.0 and macOS 10.15, SceneKit uses reverseZ depth buffer to achieve better precision. You must clear your depth to 0.0 or everything will be discarded. To opt out of this new behavior you can set the SCNDisableReverseZ key to a boolean value of YES in your app's Info.plist file.
Error: Render pass descriptor misconfigured - missing drawable texture
Warning: createSnapshot: no GL context
Error: Failed to create snapshot with error %@
Error: Can only update lightProbe
Error: Can only update 'baked' lightProbes
Assertion '%s' failed. MTLBuffer containing the SH coefficients has not the expected size
Unreachable code: Unsupported probe type
Error: %s should only be called when using Metal
Error: %s should only be called on a private renderer, using -[SCNRenderer _addGPUFrameCompletedHandler:] instead
Error: %s should only be called on a private renderer, using -[SCNRenderer _discardPendingGPUFrameCompletedHandlers] instead
Assertion '%s' failed. framebuffer should be null
Assertion '%s' failed. multisampling framebuffer should be null
Assertion '%s' failed. invalid framebuffer size
Error: unable to create the shader cache folder at %@ (%@)
Unreachable code: Invalid resource type
Unreachable code: Not indices are bound!?!
Assertion '%s' failed. Bad stage
Error: Invalid index size (%d bytes per index)
Unreachable code: Invalid index size (%d bytes per index)
Error: unknown light type %@
Error: SCNEncodeAnimations unknown animation: %@
Error: can't deserialize animation %@
Error: failed to deserialize animation %@
Error: SCNEncodeAnimations failed to encode animation: %@
Error: SCNEncodeAnimations unknown animation type: %@
Error: SCNDecodemage: invalid archive
Warning: CGPath archiving: unknown path element type
Assertion '%s' failed. Only original data kind can have non 'GPU' primitive type
Assertion '%s' failed. Variable topology sample expects triangles
Unreachable code: Volatile meshes are not supported by the deformer stack
Unreachable code: Unsupported semantic %@
Warning: unable to infer the type of a basic animation: %@
Warning: unable to infer the type of a keyframed animation: %@
Error: animating between instances is not supported
Error: CAKeyframeAnimationToC3DAnimation :: too large value to animate : %d bytes
Error: CAKeyframeAnimation has no keyframe - skipping conversion
Error: can't add a NULL animation to %@
Assertion '%s' failed. SCNAddAnimationGroup target is not an entity
Assertion '%s' failed. SCNRemoveAnimation target is not an entity
Assertion '%s' failed. SCNFadeAndRemoveAnimation target is not an entity
Assertion '%s' failed. SCNRemoveAllAnimations target is not an entity
Assertion '%s' failed. SCNFadeAndRemoveAllAnimations target is not an entity
Assertion '%s' failed. _animationEvents should be nil
Unreachable code: Unknown animation type %@
Error: can't encode an animation that has never been attached to any target
Error: Loading animation %@ failed with %@
Error: failed to convert CAAnimation to SCNAnimation
Warning: default duration is zero - using default transaction duration
Unreachable code: SCNAnimation to CAAnimation: no animation data
Error: This animation can't be changed to additive. To make this animation additive first convert it to a CAAnimation, set it to additive and convert back to SCNAnimation
Error: This animation can't be changed to cumulative. To make this animation cumulative first convert it to a CAAnimation, set it to cumulative and convert back to SCNAnimation
Warning: failed to optimize keyframes
Error: unknown fill mode
Error: Unsupported CAPropertyAnimation subclass (%@)
Error: Unsupported CAAnimation class (%@)
Error: sub-animation %@ of %@ has no keyPath - ignoring
Error: C3DAnimationToCAAnimation: unsupported animation
Warning: SCNAnimationGroupToCAAnimationGroup - no target path
Warning: SCNSimpleAnimationToCABasicAnimation - can't convert startValue
Warning: SCNSimpleAnimationToCABasicAnimation - can't convert endValue
Warning: SCNSimpleAnimationToCABasicAnimation - can't convert byValue
Unreachable code: Unhandled SceneKit error code (%d)
Error: failed to unarchive data at %@ (%@)
Error: failed to unarchive scene at %@ - unknown decoded object class (%@)
Error: failed to unarchive scene at %@ (%@)
Error: entryWithUID:withClass: object with uid %@ exists but is not a geometry
Error: entryWithUID:withClass: object with uid %@ exists but is not a material
Error: entryWithUID:withClass: object with uid %@ exists but is not an animation
Error: entryWithUID:withClass: object with uid %@ exists but is not a node
Error: entryWithUID:withClass: object with uid %@ exists but is not a light
Error: entryWithUID:withClass: object with uid %@ exists but is not a camera
Error: entryWithUID:withClass: object with uid %@ exists but is not a scene
Error: entryWithUID:withClass: object with uid %@ exists but is not a skinner
Error: entryWithUID:withClass: object with uid %@ exists but is not a morpher
Error: entryWithUID:withClass: object with uid %@ exists but is not an image
Error: entrieswithClass: class %@ is not a known C3D class
Assertion '%s' failed. the c3dImage should have been cleared when setting a layer or a skscene
Error: slotName %d not found
Error: array for material property contents must have 6 elements
Warning: copyC3DImageFromImage: invalid sub-image
Assertion '%s' failed. inconsistency in SCNMaterialProperty::parentWillDie
Assertion '%s' failed. _updateMaterialAttachment: unexpected argument
Error: SKTexture not found - missing linkage with SpriteKit?
Error: unknown material property type for archiving
Error: unknown archived material property type
Error: C3DLibraryCreateEntryIdentifier - unknown type
Error: _remapInfos does not contain an entry %@
Error: library does not contain an entry %d with kind %d
Warning: C3DLibraryAddEntryWithUniqueID - object has no unique ID
Error: Library: could not deserialize the substorage for the type %@
Error: unknown type: %d
Error: type %d is not serializable
Assertion '%s' failed. inconsistent parameters
Error: Library deserialization: could not finalize the deserialization of a substorage
Error: Library Deserialization: cannot finalize the deserialization of %@
Warning: C3DLibraryGetMemoryUsageForKind found an image with no sampler
Error: __CreateMeshElement unexpected byte per index
Unreachable code: Geometry rendering not yet implemented
Error: ParticleSystem shaders missing : %@
Assertion '%s' failed. ParticleSystemInstance: wrong instance stored in rendererElement
Error: C3DFXTechniqueAppendPass out of capacity
Assertion '%s' failed. C3DFXTechniqueGetPassAtIndex index %ld is out of bounds (%ld)
Assertion '%s' failed. Must declare upfront
Assertion '%s' failed. Cannot declare twice the same symbol (%@)
Assertion '%s' failed. Assumed count is 1
Error: C3DFXTechniqueSetValueForSymbol - expect an image for paramName %@
Error: C3DFXTechniqueSetValueForSymbol - unknown param named %@
Error: C3DFXTechniqueGetValueForSymbol - unknown param named %@
Assertion '%s' failed. compiling a technique twice
Error: invalue description for input named %@ - expect a dictionary
Error: C3DFXTechniqueCompile - invalid description (sequence missing or empty) %@
Info: pass named %@ appears to be useless - skipping
Assertion '%s' failed. unexpected pass inputs in merge
Assertion '%s' failed. _customInitializeBlock not nil
Assertion '%s' failed. _customExecuteBlock not nil
Warning: SCNMTLSmoothNormalsDeformer can only process triangles and polygons
Assertion '%s' failed. indexed index overflow
Assertion '%s' failed. expecting at least triangles here
Assertion '%s' failed. splitted vertices should not have been decremented yet
Assertion '%s' failed. welded vertices should have been entirely decremented
Error: Can't create a vehicle with this chassis because it is not in the scene yet
Warning: Chassis should already have a body
Error: leaking materials array
Error: Cannot set edge creases element because its primitive type is not SCNGeometryPrimitiveTypeLine
Error: Cannot set edge creases source because its semantic is not SCNGeometrySourceSemanticEdgeCrease
Error: Failed to archive geometry's custom attributes. %@ %@
Warning: Found elements with different channel counts in the same geometry
Error: Missing channel for source at index %u
Error: Invalid channel (%d) for source at index %u
Error: Point of view has custom projection.
Assertion '%s' failed. Mesh type has to define a topology
Error: light node already has an authoring node - skip
Error: particle node already has an authoring node - skip
Error: camera node already has an authoring node - skip
Error: physicsField node already has an authoring node - skip
Error: FATAL ERROR : can't load library without a path
Error: FATAL ERROR : failed to load Metal shaders library %@, %@
Error: Failed to load common profile chache library : %@
Error: Compilation failed %@
Error: Only metal program are supported %@
Error: Failed to find pre-compiled combination %@ + %@
Error: Failed to collect shader: %@
Error: Failed to collect shader: additional file "%@" is not always the same
Error: FATAL ERROR : failed compiling shader:
%d: %@
Unreachable code: Unknown compilation mode %d
Error: Physically based lighting model is not supported by the OpenGL renderer, using Phong instead (3)
Error: failed to load vertex uber shader.
Error: failed to load fragment uber shader.
Error: Physically based lighting model is not supported by the OpenGL renderer, using Phong instead (2)
Warning: C3DSkinnerTransposeSkeleton - unable to transpose every joints
Warning: Cannot update the joints using node names: unammed joint found
Warning: Cannot update the joints using node names: can't find node named %@
Warning: _C3DSkinnerUpdateBoundingBox - skinned node has no geometry
Error: We did not succeed in locating all the joints, so do not update the geometry as it might be worse if we use the wrong bones.
Error: _C3DSkinnerUpdateBoundingBox invalid mesh source
Unreachable code: Unknown skinning calculation mode.
Assertion '%s' failed. New deformer pipeline should never have to call `__C3DSkinnerPrepareSkinnedMesh`
Assertion '%s' failed. flags not up to date
Assertion '%s' failed. Position source should be mutable
Assertion '%s' failed. Normal source should be mutable
Error: C3DSkinnerUpdateJointsAndBoundingBox skinner has no mesh
Assertion '%s' failed. CPU Skinning dst position source not created.
Assertion '%s' failed. CPU skinning: position not mutable
Assertion '%s' failed. CPU Skinning dst normal source not created.
Assertion '%s' failed. CPU skinning: normal not mutable
Unreachable code: It's up to SceneKit to decide if `kC3DSkinnerCalculationModeUpdateTransform` can be used.
Error: C3DSkinner serialization: lib entry not found
Warning: Skinner deserialization: cannot find the specified skeleton
Error: Skinner deserialization: cannot find a joint
Error: Skinner deserialization: cannot find the skin
Error: C3DSkinner deserialization: lib entry not found
Error: C3DSkinner deserialization: Could not get a valid number value
Assertion '%s' failed. We should have a compute command encoder open at this point
Assertion '%s' failed. We should have a blit command encoder open at this point
Assertion '%s' failed. Not enough space allocated
Warning: Failed to transpose skeleton
old skeleton: %@
new skeleton: %@
Error: SCNSkinner setBaseGeometry is deprecated on iOS10 and OS X 10.12 and has no effect
Error: SCNSkinner: there must be the same number of bone weights and bone indices
Error: SCNSkinner: bone weights must be of type `float`
Error: SCNSkinner: bone indices must be uint8 or uint16 (maximum of 2 bytes)
Error: SCNSkinner: bone indices stride must be equal to componentsPerVector * bytesPerComponent
Error: SCNSkinner: bone weights stride must be equal to componentsPerVector * bytesPerComponent
Error: skinner: invalid index (%d)
Error: mismatch between the vertex count and the number of bones per vertex
Assertion '%s' failed. skinner: invalid compressed data
Unreachable code: Unsupported bytes per weight
Error: can't create a skinner with no bones
Error: can't create a skinner with no base geometry
Error: bones count and bind transform count don't match
Assertion '%s' failed. boneIndices - failed to deindex
Assertion '%s' failed. boneIndices - failed to deindex (2)
Error: number of transforms (%d) doesn't match the number of joints (%d)
Error: Bones index too large for compressed representation : %d
Error: Unsupported skin weight format
Assertion '%s' failed. inconsistency in %s
Error: invalid skin indices
Info: Too many influencing joints (%ld > %d) on the vertex #%u, will cap to %d and renormalize
Error: No jointsCount in the skin %@
Error: Unable to read the jointsCount in the skin %@
Warning: No maxInfluences in the skin %@, defaulting to 4. Please re-convert your assets.
Warning: Unable to read the maxInfluences in the skin %@, defaulting to 4. Please re-convert your assets.
Error: No inverseBindMatrices in the skin %@
Error: No defaultShapeMatrix in the skin %@
Error: A vertex weight index does not fit on an int
Error: Skin: Could not remap the ID for geometry %d
Error: Skin deserialization: no weightsCount in %@
Error: Skin deserialization: no jointsForVertexWeights in %@
Error: Skin deserialization: no vertexWeights in %@
Error: Skin deserialization: invalid vertexWeights
Assertion '%s' failed. Fov is larger that 180 degrees. this can't be
Error: GenericSource deserialize => no data type
Error: GenericSource deserialize => no count, bailing out
Error: GenericSource deserialize => no comp/value, bailing out
Error: GenericSource deserialize => no padding, bailing out
Error: Could not serialize the accessor's type
Error: accessor->_count too big
Error: accessor->_offset too big
Error: accessor->_padding too big
Error: Accessor serialization failed
Error: Accessor deserialization: Could not find the source ID
Error: Accessor deserialization: Could not find a valid source type
Error: Accessor deserialization: Could not remap the ID for source %d
Error: Accessor deserialization: : no serialized data
Error: C3DSourceAccessorGetValuePtrAtIndex - index out of bounds : %d > %d
Error: C3DSourceAccessorGetValuePtrAtIndex - no data
Error: C3DSourceAccessorGetMutableValuePtrAtIndex - index out of bounds : %d > %d
Error: C3DSourceAccessorGetVolatileValuePtrAtIndex - index out of bounds : %d > %d
Assertion '%s' failed. cannot access volatile data on non volatile source
Error: The destination does not have enough room to copy this data
Error: error in C3DSourceAccessorCopyDataToAccessor
Assertion '%s' failed. You have to push frames before allocating memory.
Unreachable code: C3DStackAllocator: Max Restore Points reached!!!!
Assertion '%s' failed. C3DStackAllocator: You cannot pop frames without pushing first.
Assertion '%s' failed. We used to support only floats, but another type was encountered
Error: ERROR: GenericSource deserialize => no data type, bailing out
Error: ERROR: GenericSource deserialize => no count, bailing out
Error: ERROR: GenericSource deserialize => no stride, bailing out
Error: Could not deserialize an accessor
Error: Could not serialize an accessor
Error: Cannot finalize the deserialization of mesh source: accessor data missing
Warning: Cannot duplicate a Metal Buffer source. Create an empty data instead.
Assertion '%s' failed. cannot set data to volatile source
Assertion '%s' failed. cannot set data to MTL buffer
Assertion '%s' failed. cannot set volatile data to non volatile source
Assertion '%s' failed. cannot set volatile data to MTL buffer
Error: SCNMTLResourceManager initWithDevice : cannot create a command queue. Bailing out.
Assertion '%s' failed. cannot use volatile meshSource
Assertion '%s' failed. Semantic %d is not meant to be passed to shaders
Assertion '%s' failed. source should be present
Assertion '%s' failed. size mismatch in mutable buffers %u!=%u
Error: missing value for attachment "%@" [vertex: %d fragment: %d]
Error: incorrect buffer size  for attachments vertex [%d] fragments [%d]. Expected:%d Provided:%d
Error: Argument '%@' : failed to write value to Metal buffer (%@)
Error: Argument '%@' : mismatch between the NSData and the buffer size %ld != %ld
Error: Argument '%@' : only NSData and NSValue are supported for shadable value storage (found '%@'). Please make sure that your custom shader modifier uniform types match the custom properties of the shadable object
Assertion '%s' failed. only C3DValue are supported for partial struct storage
Warning: Missing texture value for %@
Unreachable code: Sampler are not yet implemented as separate bindings
Error: format %@ not convertible to MTLVertexFormat
Error: DeferredShadowPass Setup - no light
Error: failed to load audio source at %@
Error: can't archive audio data directly
Error: Animation group deserialization: could not deserialize the animation
Error: Could not deserialize an animation
Error: Could not deserialize a keyframe animation
Error: Could not deserialize an animation: animation not found in %@
Error: Could not deserialize an animation: targetPath not found in %@
Error: _C3DAnimationChannelCopyPropertyList - no target path
Error: unable to update the physics shape of %@
Warning: cannot change collision bit masks without physics world
Error: cannot apply force on a body that is not attached to a SCNNode
Error: cannot clear forces on a body that is not attached to a SCNNode
Assertion '%s' failed. SCNPhysicsBody is already attached to a SCNNode
Error: cannot attach a body to a null node %p
Error: SCNTextureSpriteKitSource::textureProxy -> no scene
Warning: SCNTextureSource unexpected SKScene
Unreachable code: -[SCNDisplayLink invalidate] must be called before -[SCNDisplayLink dealloc]
Error: Failed to create display link with error %d
Error: format %lu not supported for SH generation
Unreachable code: vm_allocate failed allocating %zu bytes
Error: [SCNAction group:] invoked with nil
Warning: changing the content of a physics shape is not expected
Assertion '%s' failed. Unsupported indices stride
Info: Non triangle list element type not yet supported in physics shape generation
Error: vertex format not supported for physics shape creation (%d)
Warning: Cannot create convex hull for entity %@
Error: Compound shapes cannot be created without shapes
Warning: SCNPhysicsShape does not support a SCNCone with TopRadius != 0.0
Warning: Physics shape construction does not support meshes with positions value type different from double or float. (%d)
Unreachable code: This is not yet implemented
Unreachable code: NOT IMPLEMENTED YET
Unreachable code: C3DParametricGeometryGetType - unknown type
Assertion '%s' failed. A parametric geometry with a mesh must also have a hash
Assertion '%s' failed. inconsistency in _C3DParametricGeometryReleaseCachedMesh
Assertion '%s' failed. inconsistency in _C3DParametricGeometryCacheIncrRetainCount
Error: C3DParticleModifier_PhysicsField - no aether
Assertion '%s' failed. Can't change max batch size while in batch
Warning: overflow the max batch size boundary
Assertion '%s' failed. Top level filtered node must have a filter
Assertion '%s' failed. Trying to access last element of empty Array.
Error: C3DGLSLProfileBindProfileInputs - profile has no technique
Error: wrong location returned for input named %@
Error: can't find input named %@
Warning: the same program is shared by two passes but indexed in a different manner
Error: failed to find texture target named %@
Error: declared type doesn't match the uniform named %@
Unreachable code: Metal renderer does not support other shaders than Metal
Error: Metal renderer does not support nil vertex function name
Error: Missing vertex function `%@`, error: %@
Error: Missing fragment function `%@`, error: %@
Error: Missing vertex function `%@`
Error: Missing fragment function `%@`
Info: Shaders without a vertex function are not allowed
Error: Compiler error while building render pipeline state for node %@:
Error: Failed to create compute function '%@', error: %@
Error: Failed to find compute function '%@'
Error: Failed creating ComputePipelineState, error: %@
Assertion '%s' failed. Caching requires a constant hash to be provided when using constants
Unreachable code: Unsupported pixel buffer format %s
Unreachable code: Unsupported pixel buffer YCbCr matrix %@
Error: Could not create color space from %@ and %@
Assertion '%s' failed. string to type conversion not supported
Assertion '%s' failed. C3DValueAdd - invalid arguments
Assertion '%s' failed. assertion in DDS loading
Info: SCNSceneSourceConvertUnitsToMetersKey and SCNSceneSourceConvertToYUpKey have no effect on compressed assets. Use Xcode's compression options instead
Warning: Safe mode enabled, denying the download of a network URL %@
Warning: Unable to find the image named %@ at the specified path (%@)
Warning: Invalid URL %@
Warning: light_map uv_set:%d is pointing to an invalid uv_set(no corresponding source) and was reset to 1
Unreachable code: __OptimizeMesh:bytesPerIndex != 1, 2, or 4 during conversion, this should not happen !!
Warning: invalid zRange detected (whole scene clipped)
Error: can't serize plist :%@
Error: Could not get the data for the serialized property list
Error: Could not zip the serialized property list
Error: failed to write scene
Error: This file cannot be opened (version is too old)
Error: This file cannot be opened (version of this c3d is too recent for this version of the framework)
Error: Could not find the zipped data
Error: Could not unzip the zipped data
Error: Error loading the unzipped data: %@
Error: cannot initialize library
Error: Cannot get the library in the serialized data
Error: cannot initialize scene
Error: cannot finalize scene deserialization
Warning: cannot finalize library deserialization
Unreachable code: _C3DEntityCFInit
Unreachable code: _C3DEntityCFFinalize
Assertion '%s' failed. CFTypeIsC3DEntity - dispatched twice
Assertion '%s' failed. C3DEntitySetAttribute failed to cache attribute
Assertion '%s' failed. missing attribute
Warning: adding a node that was just removed %p
Error: unknown notification name
Assertion '%s' failed. Override custom pass name if it doesn't have any fxPass
Assertion '%s' failed. Override custom pass execute if it doesn't have any fxPass
Error: Unsupported pixel format %@ (%u) in KTX encoder
Error: Unsupported texture type %@ (%u) in KTX encoder
Warning: KTX file seems too small or is not a KTX
Error: Only big endian ktx are supported
Error: Unsupported format in KTX file
Warning: Compression type %d not supported
Error: overflow reading mip[%d] (%zu > %zu)
Error: overflow reading slice[%d] / mip[%d] (%zu > %zu)
Assertion '%s' failed. C3DVertexAttribFromParameterSemantic channel out of bounds
Error: can't find program named %@
Assertion '%s' failed. ShadowMapPass::setup() - Light missing from light node
Assertion '%s' failed. ShadowMapPass::setup() - Light doesn't cast shadow
Assertion '%s' failed. It doesn't make sense to call C3DMeshElementCreateIntervalList for sources with different channels
Error: Could not create intervals for sparse morph target %d (this morph target is useless)
Error: Failed to create packed source %d for sparse morph target %d
Assertion '%s' failed. sparse target should only contain 1 mesh element
Assertion '%s' failed. sparse targets should be in additive mode
Error: No morphingType in the morph %@
Error: Unable to read the morphingType in the morph %@
Error: Could not remap the ID for mesh %d
Error: Could not remap the ID for weights source %d
Error: Morpher has %d targets weights, but has %d main targets (note: there are %d in-betweens and %d correctives)
Assertion '%s' failed. Morpher failed to update all its runtime weights
Error: Internal consistency error. There should be %d runtime morph target weights, but we the current morph weight index is %d.
Assertion '%s' failed. Morph of other type than float not yet implemented
Unreachable code: %s should never be called when using the new deformer pipeline
Error: Morpher deserialization: cannot find the morph
Error: C3DMorpher deserialization: lib entry not found
Error: C3DMorpher deserialization: Could not get a valid number value
Assertion '%s' failed. C3DFXContextGetCurrentPassInstance - invalid index
Warning: C3DFXContextGetFirstPassInstanceWithGroupID: failed to find pass instance with name (%@)
Error: _C3DFXSetupPasses : no context
Error: shadows are only supported by spot lights and directional lights
Assertion '%s' failed. C3DEngineContextRenderSubTechnique is already being rendered
Assertion '%s' failed. sub techniques of type draw scene is not supported
Assertion '%s' failed. Need one type of render context
Error: failed to bind program for pass %@
Assertion '%s' failed. unexpected subpass fbo
Error: pass %@ has no program set
Error: C3DFXRenderPassWillExecute: invalid framebuffer
Assertion '%s' failed. C3DFXContextSetCurrentColor invalid retainCount
Assertion '%s' failed. C3DFXContextSetCurrentDepth invalid retainCount
Error: can't share a SCNPhysicsField is already attached to a SCNNode
Assertion '%s' failed. SCNPhysicsField is already attached to a SCNNode
Assertion '%s' failed. Progress not current.
Assertion '%s' failed. Progress fraction is greater than 1.0
Assertion '%s' failed. To many calls to the unitCompletedBlock
Error: %@ setWeight:forTargetAtIndex:%d - index out of bounds (%d)
Assertion '%s' failed. Update can't be done in place
Error: invalid in-between buffer, ignoring in-betweens
Assertion '%s' failed. Invalid in-between count (out of bounds) passed to morpher initialization
Assertion '%s' failed. Expected %u in-betweens but found %u
Assertion '%s' failed. Invalid range
Assertion '%s' failed. Presentation instance query targets the wrong scene
Assertion '%s' failed. Internal consistency error 
 no free index
Assertion '%s' failed. offset should be exactly equal to size
Assertion '%s' failed. should have some index free
Assertion '%s' failed. subBuffer size overflow %d > %d
Assertion '%s' failed. __UpdateHashCodeWithTextureType:inconsistent textureType
Error: Too many uniform custom samplers given (Max is %d)
Error: invalid custom texture slot.
Assertion '%s' failed. effect slot hash out of bounds
Assertion '%s' failed. ProgramHashCode should be in the dictionary
Assertion '%s' failed. Count should be > 0
Assertion '%s' failed. C3DResourceManagerRegistryReleaseContext invalid retainCount
Error: SCNTextureCoreAnimationSource::textureProxy -> no layer
Error: Skinning internal consistency error - vertex count mismatch ('%d == %d' assertion failed)
Error: Skinning internal consistency error - out of range bone index ('%d < %d' assertion failed)
Assertion '%s' failed. Wrong vertex count for skinned positions
Assertion '%s' failed. Wrong vertex count for skinned normals
Assertion '%s' failed. Wrong vertex count for skinned tangents
Error: Unflushed transaction present.
Error: Transaction stack contains an uncommited transaction.
Assertion '%s' failed. Unflushed transaction present.
Warning: invalid keypath: %@ sent to object %@
Error: C3DTransactionCommit - transaction already committed
Error: Scene %@ is modified within a rendering callback of another scene (%@). This is not allowed and may lead to crash
Assertion '%s' failed. C3DTransactionRemoveChild inconsistency
Error: C3DTransactionRemoveChild - inconsistency
Assertion '%s' failed. Error in C3DTransactionPop -> stack empty
Error: unexpected transaction commit (missing begin?)
Assertion '%s' failed. C3DTransactionAnimationDidComplete inconsistent animation count
Assertion '%s' failed. C3DTransactionAnimationDidInterrupt inconsistent animation count
Unreachable code: Command enqueued by %@ was expected to be run in immediate mode
Unreachable code: Unsupported class %@
Error: geometrySourceWithData: interleaved buffers as doubles are not supported
Error: geometrySourceWithBuffer - invalid vertex format
Error: _geometrySourceWithSource - invalid vertex format
Error: Could not create mesh source
Assertion '%s' failed. SCNGeometrySource should only store a base type
Assertion '%s' failed. vImageEncodeVectorHalf only supports half2/3/4
Assertion '%s' failed. Consistenty check issue during conversion for vImageEncodeVectorHalf
Assertion '%s' failed. vImageEncodeVectorHalf failed to write bytes
Unreachable code: Unknown component type
Unreachable code: SCNGeometrySource should only store a base type
Unreachable code: Data is marked as compressed but does not contain half components
Unreachable code: vImageEncodeVectorHalf only supports half2/3/4
Assertion '%s' failed. Decoding failed
Error: Failed to decompress data because vImageDecodeVectorHalf is not available
Unreachable code: Geometry source has invalid bounds
Error: _geometrySourceWithSource - Conversion failed
Unreachable code: SCNGeometryPrimitiveTypePolygon not supported with MTLBuffers
Assertion '%s' failed. SCNGeometryElement initialization - Invalid data length
Error: SCNGeometryElement initialization - Invalid index size (%ld bytes)
Error: SCNGeometryElement initialization - Invalid polygon edge count (%ld)
Error: not able to get click origin
Warning: _beginTranslateAtLocation: invalid zRange
Warning: Warning: no C3DIntersectionRay3Plane
Error: setGimbalLockVector is deprecated
Warning: _computeTranslationOrigin3DFromPoint: invalid zRange
Error: Could not create service connection.
Error: Message error: %s
Error: [ResourcesSandboxing] Could not unarchive reply arguments.
Error: Could not create the XPC message object
Error: Could not create object from message arguments.
Error: Could not get resource list from reply message.
Error: Could not get extension at index: %d.
Error: Could not consume extension at index: %d.
Error: Unable to resolve URL %@
Assertion '%s' failed. You can't allocate a registry twice
Assertion '%s' failed. You can't deallocate a registry that wasn't allocated
Assertion '%s' failed. You can't register twice the same semantic
Assertion '%s' failed. You can't register twice the same argument name
Warning: arguments named %@ is reserved for type %d
Warning: unknown member in scn automated buffer : %@
Unreachable code: invalid program stage %d
Assertion '%s' failed. Argument with the same name cannot have different types (%d != %d)
Assertion '%s' failed. Argument with the same name cannot have different blocks
Assertion '%s' failed. Argument with the same name cannot have different class type
Assertion '%s' failed. Only supports pass buffer arguments as struct
Warning: struct member does not match pass description : %@
Assertion '%s' failed. buffers of the same name in different stages need to have the same type
Error: AVAssetWriter can't create a movie at %@ (error:%@)
Error: appendImage: failed to get a pixelBuffer from CVPixelBufferPoolRef
Error: append pixel buffer failed
Error: error while exporting movie: %@
Assertion '%s' failed. realloc has an allocation size of 0 bytes
Assertion '%s' failed. Cannot produce any additional triangle.
Error: C3DShapeConnectedComponentTriangulatePseudopolygon - neighbor index out of bounds
Error: C3DMeshCreateTextFrame: C3DTextFrameRef object is NULL, will create NULL mesh
Assertion '%s' failed. The set we are updating contains more elements than the number of positions we have in store, something it wrong (%d vs %d)
Unreachable code: Unknown manipulator action
Assertion '%s' failed. VDMC expects triangles
Warning: C3DIO(warn) _writeAnimationChannel: animation not supported - won't be exported
Error: can't find index of animated buffer component
Error: can't mix affine and matrices animations
Warning: _writeSource - shared source detected (not supported)
Warning: _writeSource - shared accessor detected (not supported)
Warning: _writeArrayWithWriterFunc: infinite double encountered
Warning: _writeArrayWithWriterFunc: infinite float encountered
Error: failed to generate a path for an image
Error: found a texture with no sampler
Warning: geometry is partially double sided - not supported at export
Warning: failed to find source of morph
Warning: invalid light map info - not exported
Error: too many blend states: max render target is %d
Warning: can't create a fbo description for pass %@ - can't find pass description with name %@
Assertion '%s' failed. C3DFXPassInitialize pass is already initialized
Error: failed to load program %@
Warning: Unable to find metal library named %@ in bundle %@
Warning: Technique for pass "%@" has a custom Metal library, but the "%@" fragment function is missing
Warning: Technique for pass "%@" has a custom Metal library, but the "%@" vertex function is missing
Warning: Technique for pass "%@" has a custom Metal library, but the "%@" and "%@" vertex and fragment functions are missing
Error: failed to load program %@ %@
Assertion '%s' failed. Unsuported shading language
Assertion '%s' failed. Sub technique should only have 1 pass
Assertion '%s' failed. unexpected error in C3DFXPassSetInputs
Assertion '%s' failed. unexpected error in C3DFXPassSetOutput
Error: unknown cull mode named %@
Error: unknown depth comparison function named %@
Error: unknown blend factor named %@
Error: unknown blend op named %@
Error: _bufferTypeFromName - unknown output type: %@
Warning: unknown depth texture format : %@
Warning: unknown texture format : %@
Assertion '%s' failed. attributes should have a semantic
Error: description for input named %@ is missing
Error: 'type' is required for symbol %@
Assertion '%s' failed. pass:_setupInput unexpected type
Warning: symbol named %@ should be in "targets" not "symbols"
Warning: _convertOutputsDescriptionToOutputs - can't find output named %@
Error: _convertOutputsDescriptionToOutputs - unknown output type: %@
Error: C3DRenderBufferGetSlotForOutputBufferType : unsupported type %d
Error: Could not find text resource named %@
Error: modifier without code is invalid
Error: unexpected value (%@)
Warning: SCNDefaultValueWithBaseType - unknwon base type %d
Error: unexpected returned value for property %@ of object %@
Error: can't generate implementation for property of type %d
Error: C3DConstraintApplyIK leef is not a child of root
Error: C3DConstraintApplyIK root and leaf nodes are the same node
Warning: unsupported ease out for contraint applied on base type %d
Error: C3DModelPathResolveCommonProfileProperty unknown path %@
Error: _C3DModelPathResolverRegistryResolvePathWithClassName unknown path %@
Unreachable code: Support for subscript model path is not implemented for %@
Assertion '%s' failed. Cannot register twice the same propertyName : %@
Error: _C3DModelPathResolveColor4 unknown path %@
Error: _C3DModelPathResolveCommonProfileTexture unknown path %@
Error: _C3DModelPathResolveMatrix unknown path %@
Error: _C3DModelPathResolveTransform unknown path %@
Error: _C3DModelPathResolveRotation unknown path %@
Error: _C3DModelPathResolveVector3 unknown path %@
Error: _C3DModelPathResolveVector4 unknown path %@
Assertion '%s' failed. _C3DModelPathResolveEntity inconsistent cftype
Error: _C3DModelPathResolveNode unknown path %@
Error: _C3DModelPathResolveDynamicParameter unknown path %@
Error: _C3DModelPathResolveCommonProfile unknown path %@
Error: _C3DModelPathResolveMorpher unknown path %@
Error: _C3DModelPathResolveMorpher unknown key subscript %@[%ld]
Error: _C3DModelPathResolveMorpher unknown key subscript %@[%@]
Warning: _C3DCreateAnimationTargetFromPath: can't resolve a path (null model)
Warning: _C3DCreateAnimationTargetFromPath: can't resolve a path
Error: Too many properties added to this ParticleSystem
Error: Cannot animate this particle semantic : %@
Error: Try to parametrize with a variable property not present : %@
Error: Unknown controller mode : %@
Error: Try to set a controller on a property not present : %@
Assertion '%s' failed. C3DModelValueStorageUpdateModelValueFromPresentationValue - unexpected class
Unreachable code: attempt to copy SCNConstraint that is a virtual class
Assertion '%s' failed. C3DAnimationEventsAddEvent - index out of bounds
Assertion '%s' failed. _C3DAnimationEventsTriggerEventsWithTimeChanges invalid time
Assertion '%s' failed. _C3DAnimationEventsTriggerEventAtIndex - index out of bounds
Assertion '%s' failed. RendererElement should not be in span already
Assertion '%s' failed. C3DRendererElementStoreDeallocateSpan - null span
Assertion '%s' failed. C3DRendererElementStoreDeallocateSpanForNodeGeometryLOD unexpected lod count
Assertion '%s' failed. wrong index in rendererElements span
Assertion '%s' failed. __AllocateSpansForNodeGeometryLOD unexpected lod count
Error: indexstore::_getNextFreeIndex - no more free index
Assertion '%s' failed. C3DIndexStoreGetOrderedIndexForKey index out of bounds
Error: Can't add dependency %s on %s
Error: Output buffer parameters for port %d isn't compatible with input port %d
Error: Output descriptor of pass %s at port %d: %s
Error: Input descriptor of pass %s at port %d: %s
Assertion '%s' failed. Pass %s has specific viewport but it's not specified for index : %d
Unreachable code: Layered rendering is lacking a multiple output vertex streams generator
Unreachable code: Multi-viewport rendering is lacking a multiple output vertex streams generator
Unreachable code: Invalid buffer type: %hhu
Assertion '%s' failed. Invalid sample count
Assertion '%s' failed. _graphDescription is nil
Assertion '%s' failed. Attachment ID not set for %s
Assertion '%s' failed. Mismatch between resource type and resource description type, forgot useInternally ?
Assertion '%s' failed. Missing output at index %d for stage %d
Assertion '%s' failed. Trying to add NULL pass
Assertion '%s' failed. Buffer pool allocator failed, buffer is NULL
Assertion '%s' failed. Texture pool allocator failed, texture is NULL
Assertion '%s' failed. Only color attachement can use drawable texture
Assertion '%s' failed. Depth resolved texture must have sample count 0 or 1
Assertion '%s' failed. Depth resolve texture type must not be multisampled
Assertion '%s' failed. Can't find first stage, all nodes have inputs.
Error: ** Cycle detected ** involving pass %s and input pass %s
Error: Pass %s has an unresolved dependency on input port %d with pass %s. Pass %s will be ignored
Error: Pass %s has an unresolved dependency from output port %d of pass %s. Pass %s will be ignored
Error: Pass %s has an unresolved dependency with pass %s. Pass %s will be ignored
Error: Pass %s is not linked to the rendering graph and will be ignored check it's input/output
Error: ReadWrite pass %s require input %zu:%s with load mode set to "Load", forcing it.
Error: ReadWrite pass %s must have compatible input/output.
Error: Input %s doesn't match output %s.
Assertion '%s' failed. Invalid pass
Error: Unresolved dependency between %s and %s
Assertion '%s' failed. Unresolved dependency
Error: Invalid output texture sampleCount %d for pass %s %d:%s, if no multisample needed, set it to 0
Assertion '%s' failed. Invalid pass parameter
Error: Invalid input texture sampleCount %d for pass %s %d:%s, if no multisample needed, set it to 0
Error: Invalid output parameter for pass %s
Error: Invalid output parameters for port %d: %s
Error: Invalid input parameter for pass %s
Error: Buffer input parameters for port %d: %s
Error: Compatibility mismatch between %s and %s
Assertion '%s' failed. Incompatible passes
Assertion '%s' failed. Multiple dependencies on the same input %zu on %s
Assertion '%s' failed. Unable to resolve dependency between %s and %s
Error: ReadWrite pass %s can't be the present on first stage since it will load it's input.
Assertion '%s' failed. Can't dispatch input to output with multiple output without a named input.
Assertion '%s' failed. Can't dispatch input to output, unable to find output named %s.
Assertion '%s' failed. Can't dispatchToOutput to output of different type
Assertion '%s' failed. Invalid used count for pass internal resource
Assertion '%s' failed. Invalid resource, texture is NULL
Assertion '%s' failed. Invalid resource, buffer is NULL
Assertion '%s' failed. Pass output resources should be allocated
Assertion '%s' failed. Readwrite pass %s has an initialised output at index %d:%s should be null
Assertion '%s' failed. Readwrite pass %s has an uninitialised input at index %d:%s should be null
Assertion '%s' failed. node output resource should match destination node input resource
Assertion '%s' failed. Pass %s resource at index %d:%s should not be tagged as "usedInternally"
Error: Resource allocated for output index %d:%s but resource is tagged as "used internally"
Unreachable code: 
Error: Dependency issue between source %s[%d]:%s and destination %s[%d]:%s
Error: Types mismatch %s <-> %s
Error: Texture width mismatch %hu <-> %hu
Error: Texture height mismatch %hu <-> %hu
Error: Texture depth mismatch %hu <-> %hu
Error: Texture type mismatch %@ <-> %@
Error: Texture storage mode mismatch %@ <-> %@
Error: Texture CPU cache mode mismatch %@ <-> %@
Error: Texture pixel format mismatch %@ <-> %@
Error: Texture mipmap count mismatch %d <-> %d
Error: Buffers have different length %lu <-> %lu
Info: |%s%s|width|height|depth|        pixelFormat      |arrayLength|storageMode|usage|cpuCacheMo|mipmapCount|sampleCount|usedForRes|         textureType      |
Info: |%s%s|%5d|%6d|%5d|%25s|%11d|%11d|%5d|%10d|%11d|%11d|%10d|%26s|
Info: |
Info: |%s%slength : %lu
Info: |%stype : INVALID
Info: |%s%s|type|clearColor R|   G|   B|   A|attachmentType|loadMode|dispatchToOutput|usedInternally|registerTexture|registerResolveT|specificClearCol|readWrite|persistent|
Info: |%s%s|%4hhu|%12.1f|%4.1f|%4.1f|%4.1f|%14hhu|%8hhu|%16d|%14d|%15d|%16d|%16d|%9d|%10d|
Info: ###########################################################################################################
Info: ################################################ NEW FRAME ################################################
Info: ###########################################################################################################
Info: ######################################## STAGE %d ########################################
Info: 
Info: |---------------------------  %s ---------------------------
Info: |---- %d INPUTS ---- 
Info: |-> %s ( %s )
Info: |---- %d OUTPUTS ---- 
Info: |----------------------------%s----------------------------
Info: 
Unreachable code: Vertex amplification shouldn't be active
Assertion '%s' failed. pop_back() on empty Array.
Assertion '%s' failed. Array capacity inconsistency
Error: ParticleSystem: mismatch in meshes and meshElements
Assertion '%s' failed. C3DTransformGetValue offset out of bounds
Error: C3DTransformGetValue - unexpected semantic
Assertion '%s' failed. C3DTransformSetValue unexpected size
Error: C3DTransformSetValue unexptected component index %d
Error: C3DTransformSetValue - unexpected semantic
Assertion '%s' failed. C3DTransformSetValue offset out of bounds
Assertion '%s' failed. _updateMatrix - no valid rep
Assertion '%s' failed. _updateMatrix - already valid
Assertion '%s' failed. _updateAffine - no valid rep
Assertion '%s' failed. _updateAffine - already valid
Assertion '%s' failed. _updateAffineScale - no valid rep
Assertion '%s' failed. _updateAffineScale - already valid
Assertion '%s' failed. _updateAffineRotation - no valid rep
Assertion '%s' failed. _updateAffineRotation - already valid
Error: C3DAllocatorDelete - unknown address
Assertion '%s' failed. C3DAnimatableParamControllerGetParamDescription - address out of bounds
Error: C3DProgramHashCodeStoreRegisterProgramForRendererElement - index out of capacity (%d > %d)
Assertion '%s' failed. C3DProgramHashCodeStoreRegisterProgramForRendererElement - programIndex out of uint32_t. will crash soon
Error: technique should not be null
Assertion '%s' failed. Invalid point of view
Unreachable code: Unsupported configuration
Assertion '%s' failed. Multiple viewport is for stero only
Assertion '%s' failed. leaking culling data
Error: type for key %@ is switching from %@ to %@, this will lead to improper animation
Error: %@ failed to create a library with error %@
Error: %@ can't provide a library for %@
Error: %@ can't provide a library hash
Assertion '%s' failed. Must call -[SCNShadableHelper ownerWillDie] before releasing it !
Error: Cannot use a program because shader modifiers are set
Error: ShaderModifiers - unkwnown supporting class '%@'
Error: Cannot use shader modifiers because a program is set
Warning: _updateC3DProgramInput can't find input named %@
Error: ShaderModifiers - unkwnown entrypoint '%@'
Assertion '%s' failed. index out of bounds
Unreachable code: CATextAlignmentModeFromC3DTextAlignmentMode unknown mode
Warning: Unknown alignment mode %@
Warning: Unknown truncation mode %@
Error: Could not load UsdKit
Assertion '%s' failed. Internal consistency error - unexpected sparse moprh target
Assertion '%s' failed. Vertex buffer has not been completely written to
Assertion '%s' failed. Sparse indices buffer has not been completely written to
Unreachable code: Unsupported index size for compute kernel
Unreachable code: Unsupported morph kind
Assertion '%s' failed. Buffer has not been completely written to
Assertion '%s' failed. renderStartIndex is not taken into account in this pass
Assertion '%s' failed. Type mismatch
Assertion '%s' failed. uniform %@ already set
Error: DOF pass: no point of view
Error: DOF pass: no camera
Unreachable code: SCNSceneDatabase is supposed to be unarchived with a SCNKeyedUnarchiver and a lookUpName set
Unreachable code: Could not find deformer class associated to meshless geometry
Assertion '%s' failed. Meshless deformers do not support deforming normals
Assertion '%s' failed. Meshless deformers do not support deforming tangents
Assertion '%s' failed. buffer overflow
Unreachable code: Can't create an interleaved buffer for the renderable topology, possible vector count mismatch between semantics
Assertion '%s' failed. Transform of dependency node is not available
Assertion '%s' failed. Frustum info for dependency node is not available
Assertion '%s' failed. Deformer stack failed to find buffer for shader argument "%@"
Unreachable code: Unsupported input
Unreachable code: Not implemented
softlink:r:path:/System/Library/Frameworks/ModelIO.framework/ModelIO
Textures
SCNMonitor
SCNTypeInspector
NSOutlineViewDataSource
NSObject
NSOutlineViewDelegate
NSControlTextEditingDelegate
SCNActionRepeat
SCNActionFade
SCNPrecomputedLightingEnvironment
NSSecureCoding
NSCoding
SCNMaterialPropertyPrivate_PrecomputedLightingEnvironment
MTLTexture
MTLResource
MTLAllocation
SCNWeakPointer
SCNBezierCurveGeometry
SCNMTLTessellator
SCNLowLatencyMetalLayer
SCNMetalBackingLayer
SCNBackingLayer
///'@
SCNActionPlaySound
SCNMTLBezierCurveDeformer
SCNMTLMeshlessDeformer
SCNMTLDeformer
SCNUIImagePicker
SCNActionSequence
SCNKeyedUnarchiver
SCNKeyedArchiver
C3DBinding
SCNCommonProfileProgramGeneratorMetal
C3DAnimationBinding
SCNAuthoringEnvironment
SCNPhysicsCharacter
SCNMTLRenderContext
SCNBufferStream
SCNActionJavaScript
SCNParticleSystem
NSCopying
SCNAnimatable
SCNRendererOptionsPanelController
SCNPhysicsWorld
SCNTransactionCommandObject
SCNMTLOpenSubdivComputeEvaluator
OpenSubdiv
SCN_DisplayLinkExtensions
SCNDisplayLinkARC
SCNRenderTarget
SCNLayer
SCNSceneRenderer
SCNTechniqueSupport
SCNRendererOptionsPanel
SCN_NSImageFromSlotContents
SCNCommonProfileProgramCache
SCNCommonProfileProgramGenerator
SCNSceneLoaderProtocol
SCNPhysicsBehavior
SCNManipulableItem
SCNNodeManipulableItem
SCNExtensions
SCNJitterer
SCNModelIO
MDLMorphDeformerComponent
MDLComponent
MDLSkinDeformerComponent
SceneKitAdditions
SCNTechniquePanelController
SCNRenderTargetView
SCNActionRunBlock
SCNReferenceNode
SCNNodeReference
SCNAnimationReference
SCNActionReference
SCNMetalLayer
SCNUIProperty
SCN_NSImageFromImageValue
SCNUID_ConstantTransformer
SCNUID_NumberTransformer
SCNUIDynamicInspector
SCNPhysicsConeTwistJoint
SCNParticlePropertyController
SCNAVPlayerSource
SCNCaptureDeviceSource
AVCaptureVideoDataOutputSampleBufferDelegate
SCNCaptureDeviceOutputConsumerSource
SCNCaptureDeviceOutputConsumer
SCNActionCustom
SCNActionWait
SCNActionRemove
SCNCamera
SCNAdditions
Core3DKitAdditions
SCNLight
SCNMaterial
SCNShadable
SCNNode
SCNActionable
SCNBoundingVolume
Transforms
SIMD
SCNScene
SCNTextureSource
SCNImageSource
SCNTextureOffscreenRenderingSource
SCNSourceRendererRegistry
SCNDelegateSource
SCNTextureDelegateSource
SCNGeometryWrapDeformerParameters
SCNGeometryWrapDeformer
SCNGeometryWrapDeformerInstance
SCNGeometryDeformerInstance
SCNActionPerformSelector
SCNUtils
SCNView
SCNPhysicsVehicleWheel
SCNMTLRenderContextSceneRendererMainPassCustomPostProcessHelper
_SCNSceneRendererMainPassCustomPostProcessHelper
SCNActionScale
SCNAction
Internal
SCNActionTargetState
SCNNodeComponent
SCNNodeWeakComponent
SCNRendererViewPoint
SCNRendererTransitionContext
MTLDevice
SCNRenderer
SCNMTLRenderContextCommandBufferStatusMonitor
SCNMTLRenderContextResourceManagerMonitor
SCNOffscreenRenderer
SCNAddition
SCNStatisticsProvider
SCNMTLBuffer
SCNMTLResourceBinding
SCNMTLSemanticResourceBinding
SCNMTLPassResourceBinding
SCNMTLShadable
SCNMTLRenderPipeline
SCNMTLComputePipeline
SCNMTLMesh
SCNMTLMeshElement
SCNPhysicsSliderJoint
SCNActionMove
SCNDeepCopy
SCNOrderedDictionary
SCNRecursiveLock
SCNGeometryVariableTopologySampleDeformer
SCNGeometryVariableTopologySampleDeformerMeshElementData
SCNGeometryVariableTopologySampleDeformerInstance
SCN_CAKeyframeAnimation
SCNAnimationEvent
SCNTimingFunction
SCNAnimation
SCNAnimationPlayer
SCNSceneSource
NSKeyedUnarchiverDelegate
SCNHitTestResult
SCNMaterialAttachment
SCNMaterialPropertyTextureProvider
SCNMaterialProperty
SCNFloor
SCNMTLSmoothNormalsDeformer
SCNPhysicsVehicle
SCNGeometry
SCNMutableGeometry
SCNSpriteKitEventHandler
SCNCameraController
SCNAuthoringEnvironment2
SCNMTLLibrary
3$0"0 0
SCNMTLLibraryManager
SCNCommonProfileProgramGeneratorGL
SCNMaterialPropertyTextureProviderSource
SCNMaterialPropertyTextureProviderHelper
SCNActionHide
SCNUIScrubberCell
SCNUIScrubber
SCNSkinner
C3DIONSZipFileArchive
SCN_DTAdditions
SCNMTLShadableKey
SCNMetalWireframeResource
MTLBuffer
SCNMTLResourceManager
SCNAudioPlayer
SCNAudioSource
SCNPhysicsContact
SCNPhysicsBody
SCNPlane
SCNBox
SCNPyramid
SCNSphere
SCNCylinder
SCNCone
SCNTube
SCNCapsule
SCNTorus
SCNSpriteKitSource
SCNTextureSpriteKitSource
SCNDisplayLink
SCNTechniquePanel
SCNActionRotate
SCNUISceneGraphView
SCNActionGroup
SCNPhysicsShape
1$0"0 0 0/$6
6%0"0 0 0/$6
3$0"0 0 0/$6
Compilation
SCNUIArrayEditor
SCNUIArrayEditorController
SCNUIHandleButton
SCNUIColorWell
SCNUIBindableView
SCNUIVector4TextField
SCNUIMatrix4TextField
SCNUIVector3TextField
SCNUIVector2TextField
SCNUIPopUpButton
SCNGeometryTessellator
SCNGeometryDeformer
C3DEngineNotificationQueueTransientWrapper
SCNPhysicsBallSocketJoint
SCNPhysicsField
SCNPhysicsLinearGravityField
SCNPhysicsRadialGravityField
SCNPhysicsSpringField
SCNPhysicsMagneticField
SCNPhysicsElectricField
SCNPhysicsDragField
SCNPhysicsCustomField
SCNPhysicsVortexField
SCNPhysicsNoiseField
SCNPhysicsTurbulenceField
_C3DProgressDebugger
SCNTechnique
SCNPassContext
SCNPass
SCNMorpher
SCNMTLBufferAllocatorSubBuffer
SCNFixedSizePage
SCNMTLBufferAllocator
SCNJSLayerJSExport
JSExport
SCN_JSSupport
SCNJSImageJSExport
SCNJSImage
SCNJSValueSExport
SCNJSValue
SCNJSExtensions
SCNJSValueTmpImp
SCNMaterialPropertyJSExport
SCNBoundingBoxJSExport
SCNBoundingSphereJSExport
SCNTransactionJSExport
SCNColorJSExport
SCNJSBasicAnimationJSExport
SCNJSAnimationGroupJSExport
SCNJSKeyframeAnimationJSExport
SCNViewJSExport
SCNMetalLayerJSExport
SCNPhysicsBehaviorJSExport
SCNParticlePropertyControllerJSExport
SCNPhysicsHingeJointJSExport
SCNPhysicsContactJSExport
SCNProgramJSExport
SCNTorusJSExport
SCNMorpherJSExport
SCNCapsuleJSExport
SCNLevelOfDetailJSExport
SCNRendererJSExport
SCNCylinderJSExport
SCNFloorJSExport
SCNNodeJSExport
SCNPlaneJSExport
SCNPhysicsBallSocketJointJSExport
SCNConeJSExport
SCNSphereJSExport
SCNGeometryJSExport
SCNConstraintJSExport
SCNPhysicsSliderJointJSExport
SCNLightJSExport
SCNMaterialJSExport
SCNParticleSystemJSExport
SCNHitTestResultJSExport
SCNTubeJSExport
SCNLookAtConstraintJSExport
SCNPhysicsShapeJSExport
SCNGeometryElementJSExport
SCNGeometrySourceJSExport
SCNShapeJSExport
SCNSceneSourceJSExport
SCNPyramidJSExport
SCNCameraJSExport
SCNIKConstraintJSExport
SCNTechniqueJSExport
SCNPhysicsWorldJSExport
SCNPhysicsBodyJSExport
SCNBoxJSExport
SCNTransformConstraintJSExport
SCNAnimationEventJSExport
SCNActionJSExport
SCNSceneJSExport
SCNPhysicsVehicleJSExport
SCNPhysicsVehicleWheelJSExport
SCNPhysicsFieldJSExport
SCNTextJSExport
SCNJSMediaTimingFunctionJSExport
SCNCoreAnimationSource
SCNTextureCoreAnimationSource
SCNMTLSkinDeformerReadOnlyBuffers
SCNMTLSkinDeformer
SCNBoundingBox
SCNBoundingSphere
SCNTransaction
SCNGeometrySource
SCNMutableGeometrySource
SCNGeometryElement
SCN3DConnexionDevice
SCNEventHandler
SCNCameraControlEventHandler
SCNCameraNavigationController
SCNCameraControlConfiguration
SCNCameraControllerDelegate
SCNUIDynamicInspectorConfiguration
SCNUIDynamicUI
SCNMTLArgumentBinder
SCNMTLShaderBindingsGenerator
SCNMovieExport
SCNExportAddition
SCNExportOperation
_SCNExportOperation
SCNMovieExportOperation
SCNCOLLADAExportOperation
SCNManipulator
SCNGeometryVDMCDeformer
SCNGeometryVDMCDeformerMeshElementData
SCNGeometryVDMCDeformerInstance
SCNActionRunAction
SCNConstraint
SCNLookAtConstraint
SCNDistanceConstraint
SCNReplicatorConstraint
SCNAccelerationConstraint
SCNSliderConstraint
SCNAvoidOccluderConstraint
SCNBillboardConstraint
SCNConstantScaleConstraint
SCNTransformConstraint
SCNIKJoint
SCNIKConstraint
/////////$2@
SCNBufferBinding
SCNProgramSemanticInfo
SCNProgram
SCNMetalLibraryProvider
SCNShadableHelper
_SCNShadableCompilationIssue
SCNText
USKHelper
USKToken_helper
USKObjectPath_helper
USKData_helper
SCNMTLMorphDeformer
SCNShape
SCNPhysicsHingeJoint
SCNLevelOfDetail
SCNAssetCatalogCacheEntry
SCNAssetCatalog
SCNSceneDatabase
SCNSceneLookUpUnarchiver
SCNMTLDeformerStack
SCNMTLDeformerInitComputeContext
SCNMTLDeformerUpdateComputeContext
SCNGeometryDeformerInstanceWrapper
SCNGeometryDeformerInitComputeContext
SCNGeometryDeformerUpdateComputeContext
CGColor
.cxx_destruct
MTLTextureCache
CGContext
SCNUI_unbindAll
CGLContext
SCNVector4Value
CGLPixelFormatObj
T@"<MTLBlitCommandEncoder>",R,N
GPUEndTime
T@"<SCNNodeRendererDelegate>",N
IDsOfEntriesWithClass:
T@"AVAudioNode",R,N,V_audioNode
JSONObjectWithData:options:error:
T@"MTLRenderPassDescriptor",R,N
NSSize
T@"NSArray",C,N
SCNJSExportProtocol
T@"NSColor",&,N
SCNPixelsHigh
T@"NSData",&,N,V_irradianceData
SCNUID_additionalProperties
T@"SCNNode",&,N
SCNUID_constantToStringForProperty:
T@"SCNNode",W,N
SCNUID_enumForProperty:
T@"SKScene",&,N
SCNUID_propertiesToFilterOut
T@,W,N,VweakRef
SCNUID_rangeForFloatProperty:min:max:
T@?,C,N
SCNUI_name
TB,N,GisEnabled
SCN_arrayWithSimdMatrix4:
TB,N,GisWrapped
SCN_evaluateAtTime:reverse:to:
TB,N,V_readonly
SCN_setupDisplayLinkWithQueue:screen:policy:
TB,N,VusesEuler
SCN_valueWithCGPoint:
T^v,R,N
T#,&,N,VobjectClass
Td,N,Vtimestamp
T,R,N
Tq,N,VmaterialModificationCount
T:,N,Vaction
T@"<MTLBuffer>",&,N,V_buffer
T@"<MTLBuffer>",R,N
T@"<MTLCommandBuffer>",R,N
__light
T@"<MTLComputeCommandEncoder>",R,N
__openGLContext
T@"<MTLDevice>",R,N
_action
T@"<MTLFunction>",&,N,V_vertexFunction
_aether
T@"<MTLLibrary>",R,N,V_library
_allSymbolsWithSceneKitSemantic
T@"<MTLRenderPipelineState>",&,N,V_state
_allowsCreation
T@"<MTLTexture>",R
_animationSpeed
T@"<SCNAuthoringEnvironmentDelegate>",N,V_delegate
_applyOverrides
T@"<SCNCameraControlConfiguration>",R,N
_availableCompiledLibrariesLock
T@"<SCNCameraNavigationControllerDelegate>",N,V_delegate
_bindingAdaptor
T@"<SCNPhysicsContactDelegate>",W
_bloomIntensity
T@"<SCNSceneRenderer>",R
_bloomThreshold
T@"<SCNShadable>",R,N,V_shadable
_buffer
T@"AVAudioEnvironmentNode",R,N
_cachedContents
T@"AVCaptureDevice",&,N
_cameraGeometry
T@"CAAnimation",&,N
_cgPath
T@"CAMediaTimingFunction",&
_charge
T@"MDLAnimatedScalarArray",R,N
_commandBufferCompletedHandlers
T@"MTLArgument",&,N,V_argument
_componentCount
T@"MTLVertexDescriptor",C,N,V_vertexDescriptor
_currentInitResourceBlitEncoder
T@"NSArray",C
_customSlotName
T@"NSArray",C,N,V_lightBufferBindings
_cylinderradius
T@"NSArray",C,N,V_passBufferBindings
_defaultLibrary
T@"NSArray",R
_defaultTexture
T@"NSButton",&,N,Vadd
_deindexedToOriginalTableBuffer
T@"NSData",&,N,V_radianceData
_didEndSelector
T@"NSData",R,C,N
_didTriggerRedrawWhileRendering
T@"NSDictionary",&,N,V_attributes
_drawShadowMaps
T@"NSDictionary",&,N,V_options
_enumerateChildNodesUsingBlock:
T@"NSDictionary",&,N,Voptions
_exposureOffset
T@"NSDictionary",C,N
_fadeInDuration
T@"NSDictionary",R
_filterCallback
T@"NSError",&,N,V_error
_fogEndDistance
T@"NSMutableArray",R,N
_frozen
T@"NSNumber",&,N
_geometryLoaded
T@"NSObjectController",W,N,V_objectController
_gimbalLockMode
T@"NSOpenGLContext",&,N,V_sourceContext
_grainIntensity
T@"NSOrderedSet",&,N
_handle
T@"NSString",&,N,V_lookUpKey
_hidden
T@"NSString",&,N,VkeyPathSrc
_inertiaRunning
T@"NSString",?,R,C
_innerLayerNode
T@"NSString",C,N
_installContext
T@"NSString",C,N,V_semantic
_irradianceData
T@"NSString",C,N,VreferenceSceneName
_isFocusableOrHasFocusableChild
T@"NSString",R,C
_isolateProgram
T@"NSString",R,N,V_effectiveModifier
_legacyUniforms
T@"NSString",R,N,V_message
_levelsOfDetail
T@"NSURL",&,N
_loadSourceCode
T@"NSURL",&,N,V_outputURL
_mappingChannel
T@"NSURL",R
_nextUpdateDate
T@"NSURL",R,N,V_catalogURL
_normal
T@"SCNAnimation",R,N,V_animation
_offset
T@"SCNAudioSource",R,N,V_audioSource
_opaque
T@"SCNCamera",&,N
_outerBindingSpaceVectorsBuffer
T@"SCNCameraController",R,N,V_cameraController
_owners
T@"SCNGeometry",R
_parent
T@"SCNGeometrySource",&,N
_particleCharge
T@"SCNGeometryTessellator",&,N
_passDescriptor
T@"SCNLight",R,N
_paused
T@"SCNManipulator",R,N
_player
T@"SCNMaterial",R,N
_positionBuffer
T@"SCNMorpher",&,N
_primitiveCount
T@"SCNNode",&,N,V_outgoingPointOfView
_referenceCount
T@"SCNNode",&,N,Vnode
_renderableCopy
T@"SCNNode",N,Vjoint
_renderingQueue
T@"SCNNode",R,N,V_freeViewCameraNode
_replicateScale
T@"SCNNodeComponent",&,N,Vnext
_runOnSubSprite
T@"SCNPhysicsBody",&,N
_scenes
T@"SCNPhysicsField",&,N
_selectRenderingAPIWithOptions:
T@"SCNPhysicsWorld",R,N
_setImagePath:withResolvedPath:
T@"SCNProgram",?,&,N
_setSurfaceBackedOpenGLContext:
T@"SCNScene",&,N
_setWheelIndex:
T@"SCNScene",&,N,V_scene
_showStatistics
T@"SCNTechnique",C,N
_snapToAlignOnY
T@"SCNView",&
_source
T@"SCNView",N,V_parentView
_spheregeodesic
T@"SCNView",R
_spotOuterAngle
T@"SKTransition",&,N,V_transition
_statisticsInfo
T@,&,N
_subdivPipeline
T@,&,N,V_lookUpFoundInstance
_syncObjCModel:
T@,&,N,Vcomponent
_targetDistance
T@,&,N,VrepresentedObject
_timingFunction
T@,&,N,Vtarget
_translateInCameraSpaceByX:Y:Z:
T@,C,N,V_bindBlock
_tuberadialSpan
T@,N,V_dataSource
_update
T@,R,N,V_referenceObject
_updateMaterialTextureProvider:
T@,W,N,Vdelegate
_userAttributes
T@,W,N,Vtarget
_velocityFactor
T@?,C,N,VwillStartPlayback
_vertexSamplers
_volatileBuffer
TB,GisAdditive
_wantsWideGamut
TB,GisPlaying
_weight
TB,N
_windowOcclusionStateDidChange:
TB,N,GisAdaptive
_zArrow
TB,N,GisAffectedByGravity
TB,N,GisBlackPassEnabled
actions
TB,N,GisDoubleSided
addAudioPlayer:
TB,N,GisGeodesic
allKeys
TB,N,GisHidden
anchorA
TB,N,GisJitteringEnabled
angularVelocity
TB,N,GisLitPerPixel
animationNamed:
TB,N,GisOpaque
areaLightPrecomputedDataTexture
TB,N,GisPositional,Vpositional
attributeNamed:
TB,N,GisScreenSpace
TB,N,GisVideoMirrored
backgroundColor
TB,N,V_automaticTarget
bloomBlurRadius
TB,N,V_graphicalSelectionEnabled
bundleForClass:
TB,N,V_shouldSnapOnGrid
caction
TB,N,V_shouldStream
cameraDidChange
TB,N,V_syncTimeWithCoreAnimation
canJump
TB,N,VskipMorphTargets
capSegmentCount
TB,R,GareBarycentricCoordsSupported
channelEncoding
TB,R,GareRasterOrderGroupsSupported
clearCoatNormal
TB,R,GisFramebufferOnly
clickedPathItem
TB,R,GisLoaded
commitImmediate
TB,R,GisRemovable
compressionType
TB,R,N
conformsToType:
TB,R,N,GisInertiaRunning
contactDelegate
TB,V_completed
containsString:
TI,N,VglID
context
TI,R
copyTo:
TIFFRepresentation
currentViewport
TQ,?,R
customFieldWithEvaluationBlock:
TQ,N,V_antialiasingMode
dataWithDouble:
TQ,N,VelementIndex
dataWithString:
TQ,R,N
delegateWillDie
TQ,R,N,V_elementSize
didModifyRange:
T^v,N,V_userInfo
disableOverlays
T^{CGColorSpace=},R,N
dollyBy:onScreenPoint:viewport:
T^{CGPath=},R
edgeCreaseCount
T^{__C3DScene=},R,V_scene
enabled
enqueue
Td,N,V_continuousCollisionDetectionThreshold
evaluateScript:
Td,N,V_flyModeVelocity
falloffExponent
Td,N,V_rotationSensitivity
filters
Td,N,V_transitionStartTime
flyModeVelocity
Td,N,VmaxAllowedRotationAngle
framebufferOnly
Td,R
Td,R,N,V_gridUnit
geometrySources
Tf,N
getReturnValue:
Tf,N,Vrate
hasGobo
Tf,N,Vvolume
inBetweenCounts
Ti,R,N
influenceFactor
Tq,N
initTransformInWorld:withBlock:
Tq,N,V_frequency
initWithDevice:
Tq,N,V_loadingPolicy
initWithDrivingNode:parameters:
Tq,N,V_timeStamp
initWithLength:
Tq,N,V_yAlignment
initWithRenderer:sharedContext:
Tq,N,VbufferSize
initWithSource:
Tq,N,VsemanticsCount
initWithTarget:
Tq,R
interactionMode
Tq,R,N,V_line
isBaked
T{?=CCCC},R,N
isGizmo
T{?=[4]},N
isLocal
T{?=dddddd},N
isProxy
T{CATransform3D=dddddddddddddddd},N
isValid
T{CATransform3D=dddddddddddddddd},N,V_viewMatrix
isolate
T{CATransform3D=dddddddddddddddd},R,N
keyPath
T{CGRect={CGPoint=dd}{CGSize=dd}},N
latlongTextureForCubemap:pixelFormat:renderContext:needsMipmap:
T{CGSize=dd}
library
T{CGSize=dd},N,V_size
libraryProvider
T{CGSize=dd},R,N
localUp
T{SCNVector3=ddd}
lookAt:
T{SCNVector3=ddd},N,Vcenter
manipulatorNode
T{SCNVector3=ddd},N,Vmax
materialWithMDLMaterial:option:
T{SCNVector3=ddd},N,Vposition
T{SCNVector3=ddd},R
maxTransferRate
T{SCNVector4=dddd},N
maximumExposure
T{SCNVector4=dddd},R
message
URLByAppendingPathComponent:
minimumDistance
URLByDeletingLastPathComponent
momentOfInertia
URLByResolvingSymlinksInPath
moveToPosition:
URLForDirectory:inDomain:appropriateForURL:create:error:
newCommandQueue
URLForResource:withExtension:subdirectory:
newComputePipelineStateWithFunctionName:library:constantValues:
URLValue
newIndirectCommandBufferWithDescriptor:maxCommandCount:options:
UTF8String
newRenderPipelineStateWithDescriptor:options:completionHandler:
UUIDString
nodeRef
_IESProfileURL
numberWithChar:
__allocateContentTransformIfNeeded
objectInParticleSystemsAtIndex:
__aspectRatio
opacity
__createCFObject
options
__drawableSafeAreaInsets
outlineView:didDragTableColumn:
__geometry
outlineView:toolTipForCell:rect:tableColumn:item:mouseLocation:
__ibSceneName
particleSystems
__morpher
playing
__preparePixelFormat
present
__removeAnimation:forKey:
primitiveRanges
__renderLayer:withCARenderer:engineContext:viewport:atTime:forceUpdate:didUpdate:
profile
__renderSKScene:withSKSCNRenderer:engineContext:viewport:atTime:
programHashCode
__runtimeResolvedPath
pushDebugGroup:
__shadableHelper
__updateMutableMesh:withMetalMesh:
recycle
__updateTextureWithLayer:texture:engineContext:sampler:
reflectionResolutionScaleFactor
__viewport
remove:
_acceleration
removeBehavior:
_actionData
removeObserver:
_actions
render:
_activeBehaviors
rendererContext
_adaptativeEndFrame
rendererWithCGLContext:options:
_adaptativeState0
replicatesScale
_adaptive
representations
_addGPUFrameCompletedHandler:
reshape
_addGPUFrameScheduledHandler:
restart
_addToPhysicsWorld:definition:
rollingFriction
_adjustBackingLayerPixelFormat
runBlock:queue:
_affectedByGravity
sceneNamed:inDirectory:options:
_alignmentMode
sceneWithOptions:statusHandler:
_allocateElement
scrollingDeltaX
_allowDecodingCyclesInSecureMode
_allowGhostObjects
setAdditionalCompilerArguments:
_allowsResting
setAreaExtents:
_alternateMode
setAspectRatio:
_ambientOcclusion
setBlendFactor:
_angularVelocity
setBufferIndex:
_animation
setChamferMode:
_animationDidStop
setConstraints:
_animationPathForKey:
setCurrentTime:
_animations
setDisplayLink:
_appendFocusableNodesInRect:ofView:toFocusItems:
setDocumentURL:
_applyOnCompletion
setEulerAngles:
_applyUnsharing:alreadyShared:
setFloat2Value:
_arcHandleXY
setFloat4Value:
_arcHandleYZ
setForceAsyncShaderCompilation:
_arcball
setGeometryRef:
_areaLightPrecomputedDataTexture
setHemispheric:
_areaType
setIbSceneName:
_argument
setInnerRadius:
_arrayController
setInputsCount:
_arrowIndicesCount
setLitPerPixel:
_aspectRatio
setMaxVertexAmplificationCount:
_assetWriter
setNeedsDisplay
_assignComponent:toContainerWithType:
setObjectClass:
_associatedSCNNode
setOuterRadius:
_attenuationEndDistance
setPixelBuffer:
_attenuationStartDistance
setPointOfView:
_audioName
setRepeatCount:
_audioPlayer
setReverbBlend:
_audioURL
setSampleCount:
_authoringDisplayMask
setScaleOffset:
_authoringEnvironmentNode
setScissorRect:
_autoSwitchToFreeCamera
setScreenSpaceReflectionStride:
_automaticCameraTargetUpToDate
setSortingMode:
_automaticallyAdjustsShadowProjection
setStorageMode:
_automaticallyAdjustsZRange
setStringArray:
_avAdaptor
setTemperature:
_availableColorMatchingComputePipelines
setTessellator:
_availableComputePipelines
setVertexBuffer:offset:atIndex:
_availableDeformerStacks
set_bonesAndIndicesCompression:
_availableImageProxy
set_systemTime:
_availableIrradianceTextures
shadingLanguage
_availableLightingSystemReflectionProbeTextures
showsStatistics
_availableMeshSources
simdLocalNormal
_availableMorphDeformerReadOnlyBuffers
simdWorldNormal
_availablePipelineStates
skinner
_availableRadianceTextures
snapshotAtTime:
_availableSamplers
standardizedURL
_availableShadablesSearchKey
stringByAppendingPathExtension:
_availableStageDescriptors
stringFromByteCount:countStyle:
_availableWireframeMaterials
supportsMemorylessRenderTargets
_avoidsOverLighting
tailSizeInBytes
_axle
targets
_background2DProgram
textureForName:
_backgroundCubeProgram
timeSampleCount
_backgroundRasterizerStates
toValue
_backingLayer
triggerBindings
_bakeNodes:folderPath:inVertex:bakeAO:quality:attenuation:geomSetter:terminateSetter:
unbind:
_bakeStochasticIrradianceTexture:forEnvironmentTexture:mipmapLevelForSampling:renderContext:
unprojectPoint:
_barycentricCoordsBuffer
updateAndDrawStatisticsIfNeeded
_baseGeometry
updateLightNode:withSourceNode:
_baseNormalDataType
_baseVertexCount
valueWithRange:
_beginMouseMovedTracking
vector2
_beginTranslateAtLocation:
vector4
_bezierCurveInfoBuffer
vignettingPower
_bindBlock
weakRef
_bindValueForSymbol:atLocation:programID:node:renderer:
worldUp
_bindingMode
zoomBy:
_bindingsGenerator
.cxx_construct
CGImage
CATransform3DValue
SCNMatrix4Value
CGImageForProposedRect:context:hints:
SCNVector3Value
CGLContextObj
CGPath
T@"<MTLHeap>",R
GPUStartTime
T@"<SCNPhysicsContactDelegate>"
IESProfileURL
T@"MTLRenderPassDescriptor",&,N
MTLTexture
T@"NSArray",&,N
SCNFixDPI
T@"NSArray",R,N
SCNMutableDeepCopy
T@"NSColor",C,N
SCNPixelsWide
T@"NSString",C,N,VreferenceName
SCNUID_classForElementOfArray:
T@"SCNNode",R,N
SCNUID_creationOptions
T@"SCNView",&,N
SCNUID_instanciateWithOption:
T@,N,V_delegate
SCNUID_propertyOrdering
SCNUID_viewForProperty:
T@?,C,N,V_block
SCN_CGPointValue
TB,N,GisPlaying
SCN_displayLinkCallback:
TB,N,V_canceled
SCN_safeHash
TB,N,V_succeded
SCN_simdMatrix4Value
TQ,N,V_freeAxes
SCN_valueWithSimdMatrix4:
Td,N,V_progress
T#,R
Tq,N,VgeometryModificationCount
T:,N,V_didEndSelector
T{?=},N
T@"<MTLArgumentEncoder>",&,N,V_argumentEncoder
T@"<MTLBuffer>",R
T@"<MTLBuffer>",R,N,V_buffer
_3dView
T@"<MTLCommandQueue>",R,N
__nextFrameTime
T@"<MTLDevice>",R
__wantsSeparateGeometryElements
T@"<MTLFunction>",&,N,V_fragmentFunction
_active
T@"<MTLLibrary>",&,N
_affineUpToDate
T@"<MTLRenderCommandEncoder>",R,N
_allowHotReload
T@"<MTLResource>",R
_angularDamping
T@"<MTLTexture>",R,N
_animationsLock
T@"<SCNAvoidOccluderConstraintDelegate>",N
_argumentsNames
T@"<SCNCameraControllerDelegate>",N,V_delegate
_baseEntityName
T@"<SCNMaterialPropertyTextureProvider>",&,N
_birthDirection
T@"<SCNProgramDelegate>",N
_bloomIteration
T@"<SCNSceneRendererDelegate>",W,N
_bodies
T@"AVAudioEngine",R,N
_bufferBindings
T@"AVAudioPlayerNode",R,V_audioPlayer
_camera
T@"AVPlayer",&,N
_captureSession
T@"CALayer",&,N,V_layer
_chamferProfile
T@"CAMediaTimingFunction",C,N
_collisionShape
T@"MTLArchitecture",R
_commandBufferScheduledHandlers
T@"MTLStageInputOutputDescriptor",R,N
_copyImage:toTexture:desc:textureOptions:needsMipMapGeneration:
T@"NSArray",&,N,V_allTargetsFromAnimCodec
_custom
T@"NSArray",C,N,V_frameBufferBindings
_cylinderheight
T@"NSArray",C,N,V_nodeBufferBindings
T@"NSArray",C,N,V_shadableBufferBindings
_defaultProgram
T@"NSBezierPath",C,N
_deformDataKind
T@"NSButton",&,N,Vremove
_device
T@"NSData",R
_didMoveToView:
T@"NSData",R,N
_drawAtTimeLock
T@"NSDictionary",&,N,V_context
_encodeNodePropertiesWithCoder:
T@"NSDictionary",&,N,VconstantToString
_expand
T@"NSDictionary",?,C,N
_extrusionDepth
T@"NSDictionary",C,N,Voptions
_fields
T@"NSDictionary",R,N
_finishedExport
T@"NSFont",&,N
_fragmentShader
T@"NSMutableData",R,N
_fxPass
T@"NSNumber",?,&,N
_geometryShader
T@"NSOpenGLContext",&,N
_glTextureCache
T@"NSOpenGLPixelFormat",&,N
_grainIsColored
T@"NSPathControl",&,N,VstackControl
_height
T@"NSString",&,N,VkeyPathDst
_ignoreAnimationWhenCopying_tmp
T@"NSString",&,N,Vname
_innerBindingSpaceVectorsBuffer
T@"NSString",C
_inputs
T@"NSString",C,N,V_name
_installGLContextAndSetViewport
T@"NSString",C,N,VreferenceNodeName
_isDefaultShape
T@"NSString",R
_isInLiveResize
T@"NSString",R,N
_lastSystemTime
T@"NSString",R,N,V_entryPoint
_length
T@"NSTableView",&,N,Vtable
_libraryManager
T@"NSURL",&,N,V_documentURL
_loaded
T@"NSURL",C,N
_neighborBuffer
T@"NSURL",R,N
_noColorProgram
T@"NSValue",R,N,V_value
_normalTextInfo
T@"SCNAssetCatalog",&,N,V_assetCatalog
_onInertiaTimer
T@"SCNAuthoringEnvironment",R
_orange
T@"SCNCameraController",R,N
_outerLayerNode
T@"SCNGeometry",&,N
_panSensitivity
T@"SCNGeometryElement",&,N
_particleBounce
T@"SCNGeometrySource",R,N
_particleSystem
T@"SCNLight",&,N
_passes
T@"SCNMTLMesh",R,N
_physicsContact
T@"SCNMaterial",&,N
_pointOfCulling
T@"SCNMaterialProperty",R,N
_positionOffset
T@"SCNMorpher",R,N
_radius
T@"SCNNode",&,N,V_pointOfView
_renderPassDesc
T@"SCNNode",N
_renderingOrder
T@"SCNNode",R
_repeatedAction
T@"SCNNode",R,W,N
_result
T@"SCNParticleSystem",&,N
_samplerIndices
T@"SCNPhysicsBody",R,N
_script
T@"SCNPhysicsShape",&,N
_setAttributes:
T@"SCNProgram",&,N
_setQuaternion:
T@"SCNRenderer",&,N,V_renderer
_setTransforms:
T@"SCNScene",&,N,V_outgoingScene
_shadableHelper
T@"SCNSkinner",&,N
_snapToAlignOnX
T@"SCNTimingFunction",&,N
_snapToAlignOnZ
T@"SCNView",N
_sourceChannels
T@"SCNView",N,V_view
_spotInnerAngle
T@"SKScene",&,N,V_scene
_spreadingAngle
T@,&
_string
T@,&,N,V_delegate
_symbolToBinder
T@,&,N,V_texture
_target
T@,&,N,Vitem
_textureOptions
T@,&,N,VsourceObject
_transitionPass
T@,C,N
_truncationMode
T@,N
T@,R,N
_updateCorrectivesAndInBetween:
T@,W,N,Vcomponent
_updateRotation
T@,W,N,VmlDelegate
_valueForSymbol
T@?,C,N,VdidFinishPlayback
_vertexFunction
T@?,N
_vertexTextures
TB,?,R
_volatileMeshes
TB,GisCumulative
_warmupDuration
TB,GisRemovedOnCompletion
_wheels
TB,N,GisActive
_yellow
TB,N,GisAdditive
_zFlags
TB,N,GisAppliedOnCompletion
accessInstanceVariablesDirectly
TB,N,GisCumulative
TB,N,GisExclusive
addUIForStringProperty:ofClass:
TB,N,GisHemispheric
ambient
TB,N,GisIncremental
anchorB
TB,N,GisLightingEnabled
animationEvents
TB,N,GisLocal
archive:propertiesForEntryName:
TB,N,GisPaused
argumentEncoder
TB,N,GisRemovedOnCompletion
automaticTarget
TB,N,GisTemporalAntialiasingEnabled
backFaceStencil
TB,N,V_autoSwitchToFreeCamera
blendInDuration
TB,N,V_enableFreeCamera
TB,N,V_loops
byValue
TB,N,V_shouldSnapToAlign
calculationMode
TB,N,V_surroundToSelect
canDraw
TB,N,Vreadonly
cancelSelection
TB,R
categoryBitMask
TB,R,GareProgrammableSamplePositionsSupported
ciImage
TB,R,GisDepth24Stencil8PixelFormatSupported
clearInBetweens
TB,R,GisHeadless
colorWithCalibratedWhite:alpha:
TB,R,GisLowPower
completionBlock
TB,R,GisShareable
computeFunction
TB,R,N,GhasInterleavedIndicesChannels
connectToProxy:
TB,R,V_customAudioNode
containsObject:
TC,R,N
content
TI,N,Vtarget
control:textShouldBeginEditing:
TI,R,N
currentProgress
customAudioNode
TQ,N
damping
TQ,N,V_offset
dataWithLength:
TQ,R
dealloc
TQ,R,N,V_bufferSize
depthAttachment
TQ,R,N,V_type
diffuse
T^v,N,Vcontext
display
T^{CGPath=}
dstNormalBuffer
T^{SCNMTLComputeCommandEncoder=[31@][31Q][128@][16@]@@@^{SCNMTLBufferPool}I[2Q][1Q]},R,N
elementPosition
T^{__IOSurface=},R
endTime
Td,N
evalAtLocation:
Td,N,V_endTime
fadeOutDuration
Td,N,V_panSensitivity
filterWithName:
Td,N,V_startTime
floatComponents
Td,N,V_truckSensitivity
focalBlurRadius
Td,N,Vradius
fresnelExponent
Td,R,N
geometrySourceWithColorData:colorSpace:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:
getBoundingSphereCenter:radius:
Tf,N,Vopacity
gravity
Tf,N,VreverbBlend
imageSequenceFrameRateVariation
Ti,N,Vtype
inertiaFriction
iniWithLibrary:
Tq,N,V_editingSpace
initWithCGPath:
Tq,N,V_interactionMode
initWithDouble:
Tq,N,V_referenceCount
initWithFormat:
Tq,N,V_xAlignment
initWithMatrix:
Tq,N,V_zAlignment
initWithResult:
Tq,N,VinputsCount
initWithString:
Tq,N,Vtype
initialVelocity
Tq,R,N
interleavedCopy
Tq,V_usedCount
isFront
T{?=QQQ},R
isJoint
T{?=[4]},R,N
isPremultiplied
T{?={?=[4]}{?=[4]}{?=[4]}},R,N
isTextureKnown:
T{CATransform3D=dddddddddddddddd},N,V_projectionMatrix
isVideoMirrored
T{CATransform3D=dddddddddddddddd},R
keyCode
T{CGRect={CGPoint=dd}{CGSize=dd}}
keyPathsForValuesAffectingScale
T{CGRect={CGPoint=dd}{CGSize=dd}},R,N
layouts
T{CGSize=dd},N
libraryForFile:
T{CGSize=dd},N,Vsize
lightingEnabled
T{MTLResourceID=Q},R
locationInNode:
T{SCNVector3=ddd},N
lowercaseString
T{SCNVector3=ddd},N,Veuler
T{SCNVector3=ddd},N,Vmin
matrix4
T{SCNVector3=ddd},N,Vscale
maxBufferLength
T{SCNVector3=ddd},R,N
maximumDistance
T{SCNVector4=dddd},N,Vrotation
members
T{_NSRange=QQ},N
URLByAppendingPathExtension:
minimumExposure
URLByDeletingPathExtension
morpher
URLByStandardizingPath
newBuffer:type:
URLForResource:withExtension:
newComputePipelineStateWithDescriptor:options:reflection:error:
URLOfResourceNamed:
newDynamicLibraryWithURL:error:
URLWithString:
newRenderPipelineStateWithDesc:
UUID
newSharedTextureWithDescriptor:
_3DConnexionIsPressed
numberWithBool:
__CFObject
numberWithLong:
__antialiasingMode
observedKeyPath
__camera
openGLContextWithCGLContextObj:
__didChangePointOfView
orientationMode
__engineStats
outlineView:shouldCollapseItem:
__ibPreferredRenderingAPI
outlineViewSelectionIsChanging:
__insertObject:inChildNodesAtIndex:
pixelBufferPool
__prepareFramebufferWithSize:withEngineContext:textureSampler:needsStencil:
prepareObject:shouldAbortBlock:
__prepareQueue
presentationBox
__removeObjectFromChildNodesAtIndex:
probeUpdateType
__renderLayerUsingMetal:withCARenderer:engineContext:viewport:atTime:forceUpdate:didUpdate:
program
__renderingQueue
propertyForKey:
__setTransitionContext:
pyramidWithWidth:height:length:
__skinner
recompilePasses
__updateTextureWithDelegate:engineContext:
referenceObject
__updateTextureWithSKScene:engineContext:sampler:
release
__willChangePointOfView
removeAllChilds
_accumulatedDrag
removeMaterial:
_actionKey
removeSourceRenderersForSource:
_activate
renderer:didRenderScene:atTime:
_activeBehaviorsValid
rendererOptions
_adaptativeFrameDuration
rendererWithMTLTexture:options:
_adaptativeTechniqueTimeStamp
replicatorConstraintWithTarget:
_addFieldToWorld:
requiredOutputs
_addGPUFramePresentedHandler:
resourceOptions
_addSkinnerWithMDLMesh:sceneNodes:
rightMouseDown:
_additive
runAction:onFirstChildWithName:
_aetherHandle
sceneDidChange:
_affectedByPhysicsFields
sceneWillChange
_allTargetsFromAnimCodec
screenSpaceAmbientOcclusionBias
_allocatorLock
scrollingDeltaY
_allowGPUBackgroundExecution
setAdd:
_allowsDefaultLightingEnvironmentFallback
setAnchorPoint:
_allowsTranslation
setArrayLength:
_ambient
setAverageGray:
_angularRestingThreshold
setBorderColor:
_angularVelocityFactor
setCastsShadow:
_animationDidStart
setConstantValue:type:withName:
_animationEvents
setControlSize:
_animationRef
setDestinationAlphaBlendFactor:
_antialiasingMode
setDisplayMask:
_appendToEntries:entriesWithType:passingTest:entryObjectConstructor:
setDoubleSided:
_applyOverride:forKeyPath:
setFieldOfView:
_applyWithEvent:
setFloat3Value:
_arcHandleXZ
setFocalLength:
_arcHandles
setFrameOrigin:
_areaExtents
setGroundColor:
_areaPolygonVertices
setHighDynamicRangeCompression:
_argUpdatePipeline
setIncremental:
_argumentEncoder
setInputOrigin:
_arrayLength
setKey:
_arrowIndicesOffset
setMax:
_assetCatalog
setMin:
_assetWriterInput
setNextKeyView:
_associatedMDLObject
setOrientation:
_asynchronousResizing
setPhysicsBody:
_attenuationFalloffExponent
setPixelFormat:
_attributes
setProbeOffset:
_audioNode
setRestitution:
_audioSource
setSRGBTexture:
_authEnv2
setSampleDistributedShadowMaps:
_authoringEnvironment
setSceneSource:
_autoCameraTarget
setScreenSpace:
_autoUpdate
setShadowColor:
_automaticTarget
setSpeedFactor:
_automaticallyAdjustsVideoMirroring
setStoreAction:
_autoreverses
setStringValue:
_availableBuffers
setTemporalAntialiasingEnabled:
_availableCompiledLibraries
setTextureType:
_availableComputePipelinesWithStageDescriptor
setWithObjects:
_availableIESTextures
set_commandBufferStatusMonitor:
_availableImages
shaderModifiers
_availableLibraries
sharedWorkspace
_availableMeshElements
simdEulerAngles
_availableMeshes
simdOrientation
_availableOpenSubdivComputeEvaluators
skScene
_availablePipelineStatesLock
skipFramesIfNoDrawableAvailable
_availableRasterizerStates
srcNormalBuffer
_availableShadables
stringByAppendingPathComponent:
_availableSkinDeformerReadOnlyBuffers
stringByResolvingSymlinksInPath
_availableTessellators
supportsFamily:
_averageGray
swizzle
_axis
targetDirection
_background
texture
_backgroundColor
textureProvider
_backgroundDidChange
timingFunctions
_backgroundVideoProgram
torusWithRingRadius:pipeRadius:
_backingSize
typeOfProperty:
_bakeSphericalHamonicsBasedIrradianceTexture:forEnvironmentTexture:renderContext:applySH:
unlinkCustomPropertyWithParent:
_baked
update:
_baseBufferForComputeKernel
updateFieldNode:withSourceNode:
_baseMesh
uppercaseString
_basePositionDataType
valueWithPoint:
_beginFrame
valueWithTransform3D:inContext:
_beginTime
vector3
_behaviors
vertexArguments
_billboard
wakeUpAllBodies
_bindFramebuffer:
weights
_bindingData
wrapped
_bindings
zoomBy:animate:
_birthLocation
_birthRate
_birthRateVariation
_blackPassEnabled
_bladeCount
_blendDenseIndexedPipeline
_blendDensePipeline
_blendMode
_blendSparsePipeline
_block
_bloomBlurRadius
_bloomIterationSpread
_blue
_body
_boldLogsInfo
_boldTextInfo
_boneIndexSize
_boneIndicesBuffer
_boneWeightsBuffer
_bonesAndIndicesCompression
_borderColor
_boundsSize
_boxchamferRadius
_boxchamferSegmentCount
_boxheight
_boxheightSegmentCount
_boxlength
_boxlengthSegmentCount
_boxprimitiveType
_boxwidth
_boxwidthSegmentCount
_browseMode
_browseScale
_browseScaleFactor
_bufferForData:bytesPerIndex:
_bufferForMTLBuffer:
_bufferPool
_bufferSize
_buffers
_buffersUsageMask
_buildBezierCurveInfoPipelineCubic
_buildBezierCurveInfoPipelineLinear
_buildBezierCurveInfoPipelineQuadratic
_buildMipmaps:
_buildQuadGeometryPipeline
_bytesPerIndex
_c3dAnimation
_c3dBackgroundColor
_c3dBackgroundColorDidChange
_c3dImage
_c3dShaderModifierCache
_caAnimationCache
_caReady
_cache
_cacheSceneSource:forURL:options:
_cachedObject
_cachedSceneSourceForURL:options:
_cachedTessellator
_caction
_calculationMode
_callbackWithTime:
_cameraController
_cameraFrustumGeometry
_cameraLoaded
_cameraNearPlaneGeometry
_cameraOriginalFieldOfView
_cameraOrthographicFrustumGeometry
_cameraRoot
_cameraTarget
_cameraTargetComputed
_camerasDictionary
_canJitter
_cancelJitterRedisplay
_cancelMouseMovedTracking
_canceled
_capOrientationAnglesToMaximum
_cappedTranslationDelta:
_capsuleShape
_capsulecapRadius
_capsulecapSegmentCount
_capsuleheight
_capsuleheightSegmentCount
_capsuleprimitiveType
_capsuleradialSegmentCount
_captureDevice
_cascadeDebugFactor
_castsShadow
_catalog
_catalogURL
_categoryBitMask
_centerOfMassOffset
_cglContext
_chainRootNode
_chamferMode
_chamferRadius
_characterController
_chassisBody
_checkAndUpdateDisplayLinkStateIfNeeded
_checkForAssociatedSamplerOnBinding:argument:
_checkSettingsConsistency
_childNodes
_childNodesPassingTest:recursively:output:
_childNodesWithAttribute:output:recursively:
_ciImage
_clearAppKitGLContext
_clearBackBuffer
_clearC3DCache
_clearCoat
_clearCoatNormal
_clearCoatRoughness
_clearContents
_clearSceneRef
_clearUnusedBindingPoints
_clickOrigin
_clientCommandBuffer
_clientCommandQueue
_clientRenderCommandEncoder
_clientRenderPassDescriptor
_clients
_cloneSet
_cloning
_coalescingSource
_collectCompilationErrors
_colliderNodes
_collisionBitMask
_collisionImpulse
_color
_colorAndTextureProgram
_colorBufferWriteMask
_colorFringeIntensity
_colorFringeStrength
_colorGrading
_colorOnlyProgram
_colorSpace
_commandBufferStatusMonitor
_commandQueue
_commonInit
_commonInit:
_commonProfileBuffersAllocator
_commonProfileCacheLibrary
_commonProfileCacheLibraryHasherBlock
_commonProfileCacheLibraryProviderBlock
_commonProfileIORange
_commonProfilePrecompiledFunctions
_compilationErrors
_compilationIssues
_completed
_componentType
_components
_compositeRendering
_computeACMR
_computeAutomaticTargetPointIfNeeded
_computeBoundingSphereOmittingFloorsForNode:sphere:
_computeEvaluator
_computeFunction
_computeNextFrameTime
_computePipeline
_computePipelineStateForKernel:constants:constantsHash:threadGroupSizeIsMultipleOfThreadExecutionWidth:
_computeStickyAxisIfNeeded:
_computeTranslationOrigin3DFromPoint:
_computeUsageForArguments:function:
_computedLightingEnvironmentMapsPath
_conebottomRadius
_coneheight
_coneheightSegmentCount
_coneprimitiveType
_coneradialSegmentCount
_conetopRadius
_configBufferChain
_configureComputePipeline:withDescriptor:
_connectionPosition
_consoleLineCount
_constantBufferPools
_constraint
_constraintRef
_contact
_contactDelegate
_contactNormal
_contactPoint
_contactTestBitMask
_contactWithManifold:index:
_containsAlpha
_contentScaleFactor
_contentTransform
_contentType
_contents
_contentsScaleFactor
_context
_contextIsDoubleBuffered
_continuousCollisionDetectionThreshold
_contrast
_controller
_controllers
_convertRotationFromWorldToPointOfView:
_convertToCA
_copyAnimationsFrom:
_copyAttributes:
_copyAttributesTo:
_copyBaseBufferPipeline
_copyC3DImageFromImageData:typeID:
_copyDefinition:
_copyImageFromC3DImage:
_copyPassDescription
_copyPerformanceStatistics
_copyRecursively
_copyRenderGraphDescription
_copySnapshot:
_cornerRadius
_cornerSegmentCount
_correctiveDriverCounts
_correctiveDriverIndices
_correctiveInBetweenCounts
_correctiveInBetweenInfluenceWeights
_correctivesAndInBetweens
_counterVector
_counters
_createBackgroundColorImageWithSize:
_createBody
_createDisplayLinkIfNeeded
_createDynamicWorldIfNeeded
_createField
_createFramebufferWithEngineContext:size:
_createOffscreenFramebufferIfNeeded
_createPipelineStateWithDescriptor:desc:pipeline:
_createPrepareFramebufferIfNeeded
_createResourceCommandBufferIfNeeded
_createSceneRefWithOptions:statusHandler:
_createSkinnerWithBones:boneWeights:boneIndices:baseGeometry:
_createSkinnerWithCompressedData:bonesCount:vertexCount:
_createSnapshotAtTime:withSize:antialiasingMode:
_createSnapshotAtTime:withSize:antialiasingMode:error:
_createWheel:
_cullMode
_cumulative
_current
_currentAllocatorPage
_currentCommandBuffer
_currentFrameHash
_currentFrameIndex
_currentFrustumInfo
_currentInitRenderContext
_currentPass
_currentRenderContext
_currentRenderPassDescriptor
_currentResourceManager
_currentSceneTime
_currentSeekStep
_currentStickyAxis
_currentStreamBufferIndices
_currentSystemTime
_currentTransforms
_currentUpdateBuffers
_currentUpdateComputeCommandEncoder
_currentUpdateComputeEncoder
_currentUpdateComputeEncoderProvider
_currentUpdateFrustumInfo
_currentUpdateRenderContext
_currentUpdateTransforms
_curveControlPointCount
_curveInfo
_curveToGeometryTransform
_customAudioNode
_customContainerFrame
_customDecodingOfSCNAudioSource:
_customDecodingOfSCNAvoidOccluderConstraint:
_customDecodingOfSCNDistanceConstraint:
_customDecodingOfSCNFloor:
_customDecodingOfSCNGeometry:
_customDecodingOfSCNIKConstraint:
_customDecodingOfSCNLight:
_customDecodingOfSCNLookAtConstraint:
_customDecodingOfSCNMaterial:
_customDecodingOfSCNMaterialProperty:
_customDecodingOfSCNMorpher:
_customDecodingOfSCNNode:
_customDecodingOfSCNParticlePropertyController:
_customDecodingOfSCNParticleSystem:
_customDecodingOfSCNPhysicsShape:
_customDecodingOfSCNPhysicsVehicle:
_customDecodingOfSCNPhysicsWorld:
_customDecodingOfSCNProgram:
_customDecodingOfSCNReplicatorConstraint:
_customDecodingOfSCNScene:
_customDecodingOfSCNShadableHelper:
_customDecodingOfSCNShape:
_customDecodingOfSCNTechnique:
_customDecodingOfSCNText:
_customDeformerToInstances
_customEncodingOfSCNAudioSource:
_customEncodingOfSCNAvoidOccluderConstraint:
_customEncodingOfSCNCamera:
_customEncodingOfSCNDistanceConstraint:
_customEncodingOfSCNGeometry:
_customEncodingOfSCNIKConstraint:
_customEncodingOfSCNLevelOfDetail:
_customEncodingOfSCNLight:
_customEncodingOfSCNLookAtConstraint:
_customEncodingOfSCNMaterial:
_customEncodingOfSCNMaterialProperty:
_customEncodingOfSCNMorpher:
_customEncodingOfSCNNode:usePresentationInstance:
_customEncodingOfSCNParticlePropertyController:
_customEncodingOfSCNParticleSystem:
_customEncodingOfSCNPhysicsShape:
_customEncodingOfSCNPhysicsWorld:
_customEncodingOfSCNProgram:
_customEncodingOfSCNReplicatorConstraint:
_customEncodingOfSCNScene:
_customEncodingOfSCNShadableHelper:
_customEncodingOfSCNShape:
_customEncodingOfSCNTechnique:
_customEncodingOfSCNText:
_customMainPassPostProcessUsesExtraRenderTargetForRenderer:pixelFormat:
_customSlot
_cvDisplayLink
_cyan
_cylinderheightSegmentCount
_cylinderprimitiveType
_cylinderradialSegmentCount
_cylinderradialSpan
_damping
_dampingFactor
_data
_dataKind
_dataKindForComputeKernel
_dataOffset
_dataSource
_dataStride
_datasource
_debug
_debugDrawer
_debugOptions
_decelerationDistance
_defaultBackgroundColor
_defaultCubeTexture
_defaultDepthStencilState
_defaultLightingEnvironmentIrradianceTexture
_defaultLightingEnvironmentRadianceTexture
_defaultPOVForScene:
_defaultPixelFormat
_defaultPixelFormatWithAPI:sampleCount:stencil:
_defaultProgramForTessellation
_defaultSamplerState
_defaultTargetForScene:
_defaultTexture3D
_defaultVehicleRayCaster
_definition
_deformNormalBuffer
_deformNormalStageInputOutputDescriptorInfo
_deformPositionBuffer
_deformPositionStageInputOutputDescriptorInfo
_deformTangentBuffer
_deformTangentStageInputOutputDescriptorInfo
_deformedIndexBuffer
_deformedMesh
_deformedNode
_deformedPrimitiveCountBuffer
_deformedPrimitiveCountBufferOffset
_deformedToDrivingBindingTransform
_deformer
_deformerStackDidChange:
_deformerStackWillDie:
_deformers
_deindexedToFirstDeindexedTableBuffer
_deindexedToFirstDeindexedTableBufferIndexSize
_deindexedToOriginalTableBufferIndexSize
_delegate
_delegationConformance
_deleteGLFramebuffer
_deleteOriginalData
_deltaTime
_depthAndStencilStateWithReadWriteDepthDisabled
_depthOffCullOffStates
_depthOffCullOnStates
_depthOnCullOffStates
_depthOnCullOnStates
_depthPrePass
_desc
_description
_destination
_deviceQueue
_dictionaryForFrequency:
_didDecodeSCNCamera:
_didDecodeSCNIKConstraint:
_didDecodeSCNLevelOfDetail:
_didDecodeSCNLight:
_didDecodeSCNMaterialProperty:
_didDecodeSCNMorpher:
_didDecodeSCNNode:
_didDecodeSCNPhysicsBody:
_didDecodeSCNPhysicsWorld:
_didDecodeSCNScene:
_didDecodeSCNShadableHelper:
_didDragTo:
_didEncodeSCNScene:
_didEverFocusNode
_didInstallInEngineContext:
_didMutate
_didRenderScene:
_diffNode:with:path:
_diffObject:with:path:
_diffuse
_direction
_directionForScreenPoint:viewport:
_disableLinearRendering
_disableOverlays
_discardOriginalTopology
_discardPendingGPUFrameCompletedHandlers
_discardPendingGPUFramePresentedHandlers
_discardPendingGPUFrameScheduledHandlers
_discretizedStraightLineMaxLength
_displacement
_displayID
_displayLink
_displayLinkCreationRequested
_displayLinkStatsTack
_displayLinkStatsTick
_displayMask
_displayScaleFactor
_distance
_documentURL
_dofIntensity
_doubleSided
_downSamplePipeline
_draw
_drawAtTime:
_drawAtTime:WithContext:
_drawDebugInAuthoringEnvironment:
_drawForJittering
_drawInBackingLayerWithCGLContext:atTime:
_drawIndexedPrimitivesIndirectBuffer
_drawIndexedPrimitivesIndirectBufferOffset
_drawOnMainThreadPending
_drawOverlaySceneAtTime:
_drawPBRTextures
_drawScale
_drawScene:
_drawSceneWithLegacyRenderer:
_drawSceneWithNewRenderer:
_drawWithJitteringPresentationMode
_drawable
_drawablePresentedHandlers
_drawableSafeAreaInsets
_drawsArea
_drivenBydefaultNavigationCameraController
_dump:
_dumpNodeTree:tab:
_dumpToDisk
_dumpTree
_duration
_dynamicLinesInfo
_dynamicLinesNoDepthTestInfo
_dynamicTrianglesInfo
_edgeCreasesElement
_edgeCreasesSource
_edgeTessellationFactor
_editingSpace
_effectiveFeatures
_effectiveIndexCount
_effectiveIndexOffset
_effectiveModifier
_effectiveStickyAxis
_elapsedTime
_elementData
_elementSize
_elements
_emission
_emissionDuration
_emissionDurationVariation
_emitterShape
_emittingDirection
_enableARMode
_enableFreeCamera
_enabled
_encodeCustomMainPassPostProcessForRenderer:atTime:helper:
_encodeDataAsHalf
_endDraggingWithVelocity:
_endFrame
_endTime
_engineContext
_enqueueCopyFromTexture:toTexture:blitEncoder:generateMipMaps:
_entryPoint
_enumerateDependencyNodesUsingBlock:
_environment
_error
_euler
_eventBlock
_eventTime
_exclusive
_executeDrawCommand:
_expandItem:
_explicitMomentOfInertia
_exportAsMovieOperationWithDestinationURL:size:attributes:delegate:didEndSelector:userInfo:
_exposureAdaptationBrighteningSpeedFactor
_exposureAdaptationDarkeningSpeedFactor
_exposureAdaptationDuration
_exposureAdaptationHistogramRangeHighProbability
_exposureAdaptationHistogramRangeLowProbability
_exposureAdaptationMode
_fStop
_fadeOutDuration
_falloffExponent
_features
_field
_fieldGeometry
_fieldOfView
_fieldOfViewZoomFactor
_fillBackward
_fillForward
_fillMode
_fillNodeA:nodeB:
_fillNodeA:nodeB:contactPoint:collisionImpulse:distance:hitFraction:
_fillVertexDescriptor:withMeshSource:semantic:inputSet:bufferIndex:
_fillVertexDescriptor:withSemantic:inputSet:bufferIndex:vertexFormat:offset:stride:
_filterChannel
_finalDataKind
_finalMesh
_finalMeshDataKind
_finalMeshVertexCount
_finalNormalBuffer
_finalPositionBuffer
_finalTangentBuffer
_finalizeComputePipeline
_findComponentWithType:
_findFieldAttachedToNode:
_fired
_firstDrawDone
_firstMaterial
_firstSimulationDone
_fixedBoundingBoxExtrema
_fixedTimeStep
_flatness
_flyModeVelocity
_focalBlurSampleCount
_focalLength
_focusBehavior
_focusDistance
_focusFrameInView:
_fogColor
_fogDensityExponent
_fogStartDistance
_font
_forceAsyncShaderCompilation
_forceSystemTime
_forcesBackFaceCasters
_fraction
_fragmentBuffers
_fragmentFunction
_fragmentFunctionName
_fragmentSamplers
_fragmentTextures
_frameBindings
_frameBufferBindings
_frameConstantBufferPool
_frameTexturePool
_frameUniforms
_frameVolatileBufferPool
_framebuffer
_framebufferInfo
_framebufferSize
_frameworkLibrary
_freeAxes
_freeCameraActivated
_freeIndices
_freeViewCameraNode
_freeVolatileMeshElements
_frequency
_fresnelExponent
_friction
_frictionSlip
_generateLock
_generatedTexturePath
_geometry
_geometryByAddingSourcesOfSkinner:
_geometryByRemovingSkinnerSources
_geometryByUnifyingNormalsWithCreaseThreshold:
_geometryByWeldingVerticesWithThreshold:normalThreshold:
_geometrySourceWithData:semantic:vectorCount:componentType:componentCount:dataOffset:dataStride:
_geometrySourceWithSource:vertexFormat:
_geometryWillDie:
_getDeformedMeshBoundingBox:
_getFrameIndex
_ghostObject
_ghostPairCallback
_gimbalLockEnabled
_glContext
_glContextDidChange
_gobo
_gpuHandlersLock
_grainScale
_grainSlice
_grainTexture
_graphicalSelectionEnabled
_gravity
_grayDark
_grayLight
_grayMedium
_green
_gridUnit
_halfExtent
_handleCreateIfNeeded:
_handlingInteraction
_hasActiveFields
_hasAutomaticCameraTarget
_hasComponentBitmask
_hasDefaultValues
_hasFired
_hasFixedBoundingBoxExtrema
_hasLighting
_hasPivot
_heightSegmentCount
_hidManager
_highlightNode
_hitTest:viewport:options:
_ibNoMultisampling
_ibPreferredRenderingAPI
_ibSceneName
_ibWantsMultisampling
_idleDuration
_idleDurationVariation
_ignoreGravity
_ikTarget
_image
_imagePathWithSceneDocumentURL:originalImageURL:
_imagePathWithSceneDocumentURL:originalImageURL:error:
_imageProxyWillDie:
_imageSequenceAnimationMode
_imageSequenceColumnCount
_imageSequenceFrameRate
_imageSequenceFrameRateVariation
_imageSequenceInitialFrame
_imageSequenceInitialFrameVariation
_imageSequenceRowCount
_imageWillDie:
_inBetweenCounts
_inBetweenInfluenceWeights
_inFlightSemaphore
_inRenderQueueForLayerBackedGLRendering
_incremental
_incrementalAddPipeline
_incrementalInitPipeline
_indexBuffer
_indexCount
_indexOfRefraction
_indexPathForNode:
_indexType
_indices
_indicesChannelCount
_inertia
_inertiaVelocity
_influenceFactor
_initChildNodesArray
_initWithEngineContext:
_initWithOptions:isPrivateRenderer:privateRendererOwner:clearsOnDraw:context:renderingAPI:
_initialBuffersStageInputDescriptor
_initialInputLocation
_initialMatrix
_initialNormalBuffer
_initialNormalStageInputOutputDescriptorInfo
_initialPoint
_initialPointOfViewWorldPosition
_initialPositionBuffer
_initialPositionStageInputOutputDescriptorInfo
_initialSelection
_initialTangentBuffer
_initialTangentStageInputOutputDescriptorInfo
_initialTime
_initialZoom
_initializeWheelsArray
_injectionPointRanges
_innerBindingOffsetsBuffer
_innerLayerInfluencesBuffer
_inputBias
_inputLocation
_inputMode
_inputOrigin
_inputProperty
_inputScale
_insideTessellationFactor
_inspector
_installFreeViewCameraIfNeeded
_installViewport
_instance
_instanceCount
_integrateModelKitComputedMaps:withGeometry:node:texturePathProvider:vertexAttributeNamed:materialPropertyNamed:filePath:
_intensity
_interactionMode
_interleavedIndicesChannels
_invalidateFramebuffer
_invalidated
_isAReference
_isAnimating
_isCommonProfileProperty
_isDefault
_isDirty
_isEditor
_isEffectivelyHidden
_isFront
_isGLLayerBacked
_isHidden
_isInertiaRunning
_isInvalidated
_isJoint
_isLayerBacked
_isLayerPrivateRenderer
_isLegacySingleLayerDeformer
_isLocal
_isLocationValid:inViewport:
_isMetalSupported
_isMouseDown
_isNameUnique:
_isNodeInsideFrustum:withPointOfView:viewport:
_isOpaque
_isOrbiting
_isPresentationInstance
_isPrivateRenderer
_isRenderingForJittering
_isRunningInExtension
_isSceneBoundingSphereComputed
_isUsingSparseTargets
_isValid
_isValidationEnabled
_isViewPrivateRenderer
_isViewedObjectSphereComputed
_iteration
_jitterAtStep:updateMainFramebuffer:redisplay:jitterer:
_jitterRedisplayWithContext:
_jitterer
_jitteringEnabled
_jointsPerNode
_keepTargetDirection
_keyPath
_keyValues
_keyboard
_keys
_kvoKeysForwardedToRenderer
_lastDeformedCurveControlPointsBuffer
_lastDisplayLinkTime
_lastDragLocation
_lastDragTime
_lastFramePositionBuffer
_lastFrameTime
_lastGridDistance
_lastInputLocation
_lastKeyInputTime
_lastLoadedScene
_lastModifierFlags
_lastMorpherIncrementalPassState
_lastOptions
_lastRenderedTime
_lastRotationAngle
_lastSimulationTime
_lastUpdate
_layer
_layerDidChange:
_layerRoot
_layerRootNode
_layerTarget
_layoutLocked
_legacyDeformedNodeUVChannel
_legacyDrivingNode
_legacyDrivingNodeUVChannel
_legacyFov
_legacyOffsetsOrTransformsBuffer
_lensShift
_library
_libraryHash
_libraryProvider
_libraryURL
_light
_lightBindings
_lightBufferBindings
_lightEmissionRadiusFactor
_lightGeometry
_lightLoaded
_lightProbesInfo
_lightProbesProgram
_lightRoot
_lighting
_lightingEnabled
_lightingInjectionPointRanges
_lightingModelName
_lightsData
_lightsDictionary
_line
_linearRestingThreshold
_litPerPixel
_load
_loadReferencedSceneWithURL:catalog:
_loadURLWithBundle:
_loadWithCatalog:
_loadWithURL:
_loadWithURL:catalog:
_loadingPolicy
_localFront
_lock
_locksAmbientWithDiffuse
_lod
_logLightingInformation
_logsInfo
_lookUpFoundInstance
_lookUpKey
_loops
_magnificationFilter
_mainContext
_mainTargetNamesToIndexes
_mainTargets
_mainTargetsAndInBetweens
_mainView
_manager
_manipulator
_mapToSphere:inViewport:
_mass
_material
_materialPropertyClass
_materialWillDie:
_materialWithName:
_materials
_maxAnisotropy
_maxLevel
_maxTrianglesAtLevel
_maximumAngles
_maximumDirectionAngle
_maximumDistance
_maximumEdgeLength
_maximumExposure
_maximumLinearAcceleration
_maximumLinearVelocity
_maximumPointScreenSpaceRadius
_maximumShadowDistance
_maximumSuspensionForce
_maximumSuspensionTravel
_meshElement
_meshElementData
_meshElementWillDie:
_meshSource
_meshSourceWillDie:
_meshWillDie:
_meshlessDeformer
_message
_metalness
_minificationFilter
_minimumAngles
_minimumDistance
_minimumExposure
_minimumLanguageVersion
_minimumPointScreenSpaceRadius
_mipFilter
_mirrored
_mkSemantic
_mode
_modeSensitivity
_modelInspectors
_modelPath
_modelPathComponents
_modelViewContainer
_momentOfInertia
_morphDeformer
_morphKind
_morphNormals
_morphTargetCount
_morphTargetNormalDataType
_morphTargetPositionDataType
_morphTargets
_morphTargetsSparseIndicesBuffer
_morphTargetsVertexBuffer
_morphWillDie:
_morpher
_morpherLoaded
_motionBlurIntensity
_mouseDown
_mouseIsDown
_movability
_mtkTextureLoader
_mtlBuffer
_mtlTexture
_mtlTextureCache
_mtlVertexFormat
_multiply
_mutabilityTimestamp
_mutex
_mycaction
_name
_names
_navigationCameraController
_needSuperSampling
_needsRedraw
_needsRedrawAsap
_needsRedrawForJittering
_needsRenderResource
_needsRepetitiveRedraw
_newComputeDescriptorForPipelineDesc:library:
_newMTLBufferFromPoolWithLength:
_newProgramWithHashCode:engineContext:introspectionDataPtr:
_newProgramWithHashCodeWithFunctionConstants:engineContext:introspectionDataPtr:
_newSubBuffer
_nextFrameTime
_nibLoaded
_node
_nodeA
_nodeB
_nodeBindings
_nodeBufferBindings
_nodeRef
_nodeUniforms
_nodeWithIndexPath:
_nodesInsideFrustumWithPointOfView:viewport:
_notifyNextDirtyState
_objectController
_occluder
_opacity
_openGLContext
_openGLContextDidChange:
_openGLContextIfAny
_operateOnDataUsingCompressionAlgorithm:operation:
_optimizeKeyframesWithTarget:
_optimizeTriangleIndices
_optimizedGeometryElementWithData:primitiveType:primitiveCount:bytesPerIndex:
_options
_optionsForSymbol:
_orientationDirection
_orientationForMode
_orientationMode
_orientationOffset
_orientationState
_originalData
_originalDataCount
_originalFovX
_originalFovY
_originalIndexBuffer
_originalLightingSourceCode
_originalMouseLocation
_originalOrthoScale
_originalPrimitiveCount
_originalRenderPassDescriptor
_originalSourceCode
_originalToFirstDeindexedTableBuffer
_originalToFirstDeindexedTableBufferIndexSize
_orthographicScale
_orthographicScaleForZoomFactor:
_orthographicViewSpaceTranslationForZoomAtScreenPoint:scaleDelta:viewport:
_orthographicZoomFactor
_orthographicZoomFactorForProposedZoomFactor:
_outerBindingOffsetsBuffer
_outgoingPointOfView
_outgoingScene
_outlineView
_outputURL
_overlayDynamicLinesInfo
_overlayDynamicTriangleInfo
_overlayLayerRoot
_overlayRenderer
_overlayScene
_overlaysDidUpdate:
_overrides
_ownedCommandQueue
_owner
_ownerWillDie
_pages
_paleBlue
_paleGreen
_panel
_parallaxCenterOffset
_parallaxCorrectionEnabled
_parallaxExtentsFactor
_parameters
_parentPage
_parentView
_parseAndSetShaderModifier:
_parseArguments:function:renderPipeline:
_particleAngle
_particleAngleVariation
_particleAngularVelocity
_particleAngularVelocityVariation
_particleBounceVariation
_particleChargeVariation
_particleColor
_particleColorVariation
_particleDiesOnCollision
_particleFriction
_particleFrictionVariation
_particleGeometries
_particleImage
_particleIntensity
_particleIntensityVariation
_particleLifeSpan
_particleLifeSpanVariation
_particleMass
_particleMassVariation
_particleSize
_particleSizeVariation
_particleSystems
_particleVelocity
_particleVelocityVariation
_particlesDictionary
_particlesGeometry
_particlesRoot
_partitionMode
_pass
_passBindings
_passBufferBindings
_passWillDie:
_path
_pause
_pauseAnimation:forKey:pausedByNode:
_pauseDisplayLink
_pauseDisplayLinkIfPossible
_pausedByInheritance
_pausedForEditing
_pendingAllocationListener
_pendingGPUFrameCount
_perVertexTrianglesIndices
_perVertexTrianglesOffsets
_physicsCollisionsEnabled
_physicsFieldsDictionary
_physicsFieldsRoot
_physicsShape
_physicsWorld
_physicsWorldCreateIfNeeded:
_pinchShouldMoveCamera
_pink
_pipeline
_pipelineStateHashForMeshElement:patchType:
_pixelFormatByDefaultingIfNeeded
_planarTranslationHandleXY
_planarTranslationHandleXZ
_planarTranslationHandleYZ
_planarTranslationHandles
_planarTranslationLayout
_plane
_play
_playerRef
_playing
_pointIndicesBuffer
_pointOfView
_pointOfViewIsSelected
_pointOfViewOrthographicScale
_pointOfViewUsesOrthographicProjection
_pointOfViewWasSet
_pointSize
_pointsOfViewRoot
_position
_postCommandWithBlock:
_postMorphingDeformerInstances
_postProjectionTransformScale
_postProjectionTransformTranslation
_postSkinningDeformerInstances
_preTick:
_precomputedLightingEnvironmentWillDie:
_preferredFramePerSeconds
_preferredFrameRate
_preloadRenderer
_preloadResource:abortHandler:
_prepareForTransition:outgoingScene:outgoingPointOfView:completionHandler:
_prepareFreeViewCamera
_prepareGLRenderTarget
_prepareMaterialTextures:
_prepareObject:shouldAbortBlock:
_preparePixelFormat
_preparePreloadRenderer:
_prepareRenderTarget
_prepareSKRenderer
_prepareSnapToAlignData:minOffset:maxOffset:
_prepareUpdate
_presentFramebuffer
_presentationInstance
_presentationMappingChannel
_presentationWeightForTargetAtIndex:token:
_preserveScale
_prettifyForPreview
_preventWarmup
_primitiveRanges
_primitiveType
_printData
_privateOpenGLContext
_privateOpenGLContextIfAny
_privateRendererOwner
_privateRendererOwnerDelegationConformance
_probeEnvironment
_probeExtents
_probeOffset
_probeType
_probeUpdateType
_processedJoints
_processingContext
_profile
_program
_programDidChange:
_programFromPassAtIndex:
_programHashCodeWillDie:
_programMutex
_programWillDie:
_progress
_projectPoint:viewport:
_projectPoints:count:viewport:
_projectionDirection
_projectionMatrix
_projectionTransform
_properties
_property:
_propertyControllers
_propertyType
_provider
_pyramidheight
_pyramidheightSegmentCount
_pyramidlength
_pyramidlengthSegmentCount
_pyramidprimitiveType
_pyramidwidth
_pyramidwidthSegmentCount
_quadMesh
_quadPositionsBuffer
_quadTexcoordsBuffer
_quadrantIndicesCount
_quadrantIndicesOffset
_quadrantRingIndicesCount
_quadrantRingIndicesOffset
_quaternion
_queue
_queuedFrameCount
_radianceData
_rasterizerStateDidDie:
_rate
_rayTestWithSegmentFromPoint:toPoint:options:
_readSubdivCacheForHash:
_readonly
_readsFromDepthBuffer
_recordWithoutExecute
_recordingPointOfViewEvents
_recycleMTLBufferToPool:
_red
_reduceStatsOfConstantBuffer:
_referenceName
_referenceObject
_referenceURL
_reflectionCategoryBitMask
_reflectionFalloffEnd
_reflectionFalloffStart
_reflectionResolutionScaleFactor
_reflectionSampleCount
_reflective
_reflectivity
_registerAsObserver
_registry
_releaseCachedSourcesAndElements
_releasePreloadRenderer
_reliesOnFrustum
_reliesOnTransforms
_reloadDebugOptions
_reloadWithScene:
_removeAction:forKey:
_removeButton
_removeCachedSceneSourceIfNeededForURL:
_removeComponentWithType:
_removeDeadParticleSystem:
_removeFieldFromWorld:
_removeMatchingProgram:pass:
_removeOwner
_removedOnCompletion
_renderAtTime:
_renderAtTime:viewport:encoder:passDescriptor:commandQueue:commandBuffer:
_renderContext
_renderContextMetal
_renderEncoder
_renderGraph
_renderGraphFrameRecordingAtPath:withCompletion:
_renderOptions
_renderPassParameters
_renderSceneWithEngineContext:sceneTime:
_renderSize
_renderThreadPriority
_renderer
_renderer:didApplyAnimationsAtTime:
_renderer:didApplyConstraintsAtTime:
_renderer:didBuildSubdivDataForHash:dataProvider:
_renderer:didRenderScene:atTime:
_renderer:didSimulatePhysicsAtTime:
_renderer:inputTimeForCurrentFrameWithTime:
_renderer:subdivDataForHash:
_renderer:updateAtTime:
_renderer:willRenderScene:atTime:
_rendererContextGL
_rendererDelegate
_renderers
_renderingAPI
_renderingMode
_renderingPrepare
_renderingSnapshot
_rendersContinuously
_rendersIntoMaterial
_repeatCount
_replicateOrientation
_replicatePosition
_reserved
_reserved2
_reset
_resetBrowseScaleFactor
_resetContentsScaleFactor
_resetFreeViewCamera
_resetLightAuthoringWithContainerNode:source:light:
_resetOrientationState
_resetSceneTimeRange
_reshape
_resizeLayer:toSize:updateLayer:updateTransform:caRenderer:
_resizeLayer:toSize:updateLayer:updateTransform:caRenderer:isMainThread:
_resolveAndDiscardGL
_resolveURL
_resourceBlitEncoder
_resourceCommandBuffer
_resourceComputeEncoder
_resourceGroup
_resourceManager
_resourceManagerMonitor
_resourceQueue
_restartSource
_restartSourceIsSuspended
_restitution
_resumeDisplayLink
_resumeDisplayLinkForDelayedFrame
_resumeDisplayLinkIfNeeded
_resyncObjCModelOfPerTypeParameters
_reverseZ
_rightMouseIsDown
_rollingFriction
_rootNode
_rotateByX:Y:
_rotateWithDrag:mode:stickyAxis:
_rotation
_rotationHandles
_rotationRepresentation
_rotationSensitivity
_roughness
_runFPSTestWithDuration:
_runningInExtension
_runningLock
_runtimeResolvedPath
_sRGB
_sampleCount
_sampleDistributedShadowMaps
_samplerInput
_samplersUsageMask
_saturation
_saveOriginalData
_scale
_scaleNode
_scaleOffset
_scaleSceneBy:
_scene
_sceneBoundingSphere
_sceneBuffer
_sceneDidUpdate:
_sceneGraph
_sceneLoaded
_sceneRenderer
_sceneRendererDelegate
_sceneRendererDelegateDelegationConformance
_sceneRendererIsSCNView
_sceneSource
_sceneSourceOptions
_sceneUniforms
_sceneWithClass:options:statusHandler:
_scnAnimationForKey:
_scnBindings
_scnUpdateContentsGravity
_scnView
_scnlayerBackedOpenGLContext
_scope
_screenSize
_screenSpace
_screenSpaceAmbientOcclusion
_screenSpaceReflectionMaxRayDistance
_screenSpaceReflectionSampleCount
_screenSpaceReflectionStride
_screenSpaceRotation
_screenTransform
_scrollWheelModifiers
_scrollWheelMultiplier
_searchArguments:forArgumentNamed:type:
_seed
_selectedAxis
_selectedNodes
_selecting
_selection
_selectionIsReadonly
_selectionP0
_selectionP1
_selector
_selfDelegationConformance
_selfIllumination
_selfIlluminationOcclusion
_semantic
_semanticInfos
_semantics
_sensorSize
_setAnimation:
_setAnimationRef:
_setAuthoringEnvironment:
_setBackingSize:
_setBaseGeometry:
_setC3DImageRef:
_setC3DProgram
_setC3DProgramDelegate
_setColor:
_setComponent:withType:
_setContentsScaleFactor:
_setDisplayScaleFactor:
_setEngineStats:
_setGeometryRef:
_setHasFocusableChild
_setInertiaRunning:
_setLayerBackedOpenGLContext:
_setNeedsDisplay
_setOpenGLContext:madeWithPixelFormat:
_setOwner:
_setParent:
_setParticleImagePath:withResolvedPath:
_setPausedOrPausedByInheritance:
_setPointOfViewOrthographicScale:
_setPosition:
_setRootNode:
_setScale:
_setSceneTime:
_setSkeleton:
_setSourceURL:
_setVehicle:
_setWorld:
_setupAuthoringEnv2:
_setupCommonProperties
_setupContentsFromC3DImage
_setupDuration
_setupFrom:
_setupGeometryElements
_setupGeometrySources
_setupMaterialProperty:
_setupMovieToWritableFile:
_setupObjCModelFrom:
_setupOffscreenRendererWithSize:
_setupPasses
_setupSKRendererIfNeeded
_setupShadableHelperIfNeeded
_setupUpVector
_setupWithGeometry:thresholdMode:value:
_shadable
_shadableBindings
_shadableBufferBindings
_shadableSetValue:forUndefinedKey:
_shaderCompilationGroup
_shaderModifiers
_shaders
_shadowBias
_shadowCascadeCount
_shadowCascadeDebugFactor
_shadowCascadeSplittingFactor
_shadowColor
_shadowKernelBuffer
_shadowMapSize
_shadowRadius
_shadowSampleCount
_shapeHandleWithShape:owner:
_sharedIndexBufferOffset
_shiftBuffer
_shininess
_shouldBakeDirectLighting
_shouldBakeIndirectLighting
_shouldCacheWithOptions:
_shouldDelegateARCompositing
_shouldDeleteFramebuffer
_shouldForwardSceneRendererDelegationMessagesToPrivateRendererOwner
_shouldForwardSceneRendererDelegationMessagesToSelf
_shouldIgnoreMomentumEvents
_shouldInheritContentsScale:
_shouldPostUpdate
_shouldPresentAfterMinimumDuration
_shouldPresentWithTransaction
_shouldRecycle
_shouldSnapOnGrid
_shouldSnapToAlign
_shouldStream
_shouldUpdateTarget
_showAuthoringEnvironment
_showsAuthoringEnvironment
_size
_skCompositing
_skSceneDidChange:
_skeleton
_skinDeformer
_skinNormals
_skinTangents
_skinWillDie:
_skinner
_skinnerLoaded
_skinnerWithBaseGeometry:skinnableGeometry:bones:boneInverseBindTransforms:bindMatrix:
_skipFramesIfNoDrawableAvailable
_sliceTextures
_smoothNormalsDeformer
_smoothNormalsPipeline
_smoothingMode
_smoothness
_snapPositionToAlign:original:unit:axisMove:rayStart:rayDir:didSnap:snapIndexes:
_snapToAlignCount
_snapXIndexes
_snapYIndexes
_snapZIndexes
_snapshotImageData
_snapshotImageDataLength
_snapshotRenderer
_softParticlesEnabled
_sortingMode
_sourceContext
_sourceDocumentURL
_sourceFile
_sourceURL
_sources
_specular
_specularDFGDiffuseHammonTexture
_speed
_speedFactor
_speedKmHour
_spherehemispheric
_sphereprimitiveType
_sphereradialSpan
_sphereradius
_spheresegmentCount
_sphericalHarmonics
_splatDeformedToFinalPipeline
_splatPipeline
_splatUniforms
_spotFalloffExponent
_spriteKitEventHandler
_stack
_stageDescriptor
_stageDescriptorsLock
_stageInputOutputDescriptors
_startBrowsingIfNeeded:
_startObservingProgram
_startTime
_state
_statisticsTimeStamp
_steeringAxis
_step:
_stickyAxis
_stickyDirection
_stickyMove
_stop
_stopInertia
_stopObservingProgram
_strength
_stretchFactor
_subSpriteKey
_subdivIndexBuffer
_subdivMesh
_subdivMeshInfoBuffer
_subdivVertexBuffer
_subdividedCopyWithSubdivisionLevel:
_subdividedVertexStartIndex
_subdivisionIsAdaptive
_subdivisionLevel
_subdivisionSettings
_subnodeFromIndexPath:
_succeded
_superSamplingFactor
_supersampling
_supportsJitteringSyncRedraw
_surfaceBackedOpenGLContext
_surroundToSelect
_suspensionCompression
_suspensionDamping
_suspensionRestLength
_suspensionStiffness
_switchToFreeViewCamera
_symbolToUnbinder
_syncEntityObjCModel
_syncObjCAnimations
_syncObjCModel
_syncObjCModelAfterC3DIOSceneLoadingWithNodeRef:
_syncTimeWithCoreAnimation
_systemSpawnedOnCollision
_systemSpawnedOnDying
_systemSpawnedOnLiving
_systemTime
_systemTimeAnimationStarted:
_targetDirection
_targetOffset
_targetRelativeToPointOfViewParent
_targetView
_targetedFrameInterval
_targets
_targetsProxy
_technique
_temperature
_temporalAntialiasingEnabled
_tessellationControlShader
_tessellationEvaluationShader
_tessellationFactorBuffer
_tessellationFactorScale
_tessellationVertexDescriptor
_tessellationVertexDescriptorHash
_tessellator
_tessellatorValueForGeometry:
_textInfo
_texture
_textureCache
_textureComponents
_textureDescriptorFromImage:needsMipMap:textureOptions:
_textureProvider
_textureTarget
_textureWithEngineContext:textureSampler:nextFrameTime:
_texturesUsageMask
_timeOffset
_timeStamp
_timeStep
_timedRecordingBuffer
_timedRecordingBufferEnd
_timedRecordingBufferStart
_timedRecordingExpirationTime
_toruspipeRadius
_toruspipeSegmentCount
_torusprimitiveType
_torusradialSpan
_torusringRadius
_torusringSegmentCount
_totalDragWithInertia
_touchMap
_trackedResourcesToHashcode
_transform
_transformUpToDate
_transforms
_transition
_transitionContext
_transitionStartTime
_translateHandles
_translateTo:
_translateToViewPoint:
_translationAllowed
_translationCoef
_translationOrigin
_transparency
_transparencyMode
_transparent
_triangleBufferChain
_triangleCounterBuffer
_truckSensitivity
_tubeheight
_tubeheightSegmentCount
_tubeinnerRadius
_tubeouterRadius
_tubeprimitiveType
_tuberadialSegmentCount
_type
_typeInspector
_unbindFramebuffer:
_unbindValueForSymbol:atLocation:programID:node:renderer:
_uniforms
_unifyNormal
_unifyNormals
_uninterleaveData:count:srcOffset:srcStride:dstStride:
_unprojectPoint:viewport:
_upDir
_upDirIsSet
_upVector
_update:
_updateActionWithEvent:
_updateAffine
_updateAllC3DProgramInputs
_updateArcballOrientation
_updateAssociatedSCNNodeWithGeometrySetter:texturePathProvider:vertexAttributeNamed:materialPropertyNamed:
_updateBackingSize
_updateC3DImageWithContents:
_updateC3DProgramInput:forSymbol:
_updateC3DProgramInputForSymbol:
_updateCloneStateWithEvent:
_updateContentsScaleFactor
_updateCount
_updateEngineCallbacks
_updateFieldOfView
_updateFocalLength
_updateFocusableCache
_updateInertiaAtTime:
_updateMaterialAVPlayer:
_updateMaterialAttachment:
_updateMaterialBorderColor:
_updateMaterialCaptureDevice:
_updateMaterialCaptureDeviceOutputConsumerSource:
_updateMaterialColor:
_updateMaterialFilters
_updateMaterialImage:
_updateMaterialLayer:
_updateMaterialMTLTexture:
_updateMaterialNumber:
_updateMaterialProceduralContents:
_updateMaterialPropertyTransform:
_updateMaterialSKScene:
_updateMaterialSKTexture:
_updateOpacity
_updateParticleC3DImage:
_updatePhysicsFieldsTransforms
_updatePointOfView
_updatePrecomputedLightingEnvironment:
_updateProbes:withProgress:
_updateProjectionMatrixForOrthographicSkyboxRenderingIfNeeded:
_updateResourceManager
_updateRootsVisibility
_updateSelectionWithSelectionFrame:
_updateSystemTimeAndDeltaTimeWithCurrentTime:
_updateTargetsAndInBetween:
_updateTransform
_updateWithManifold:index:point:
_updateWithSystemTime:
_useCustomContainerFrame
_useFallbackCopyKernel
_useFunctionConstants
_useSparseTargets
_usedCount
_usedResources
_usedVolatileMeshElements
_userAnimation
_userDefinedPixelFormat
_userInfo
_userInfoLock
_usesCustomScaleFactor
_usesDeferredShadows
_usesEllipsoidalExtent
_usesIOSurface
_usesModulatedMode
_usesOrthographicProjection
_usesSceneTimeBase
_usesSpecificMainPassClearColorForRenderer:clearColor:
_value
_valueForKey
_valueForKeyLock
_valueForSymbolLock
_valueTransformer
_valuesForUndefinedKeys
_valuesForUndefinedKeysLock
_vectorCount
_vehicle
_vehicleRayCaster
_velocity
_vertexBuffers
_vertexCount
_vertexCountForComputeKernel
_vertexDescriptor
_vertexDescriptorHash
_vertexFunctionName
_vertexShader
_vertexWeightIndexSize
_vertexWeightIndicesBuffer
_videoMirrored
_view
_viewIsOffscreen
_viewLocked
_viewMatrix
_viewedObjectSphere
_viewpointCoordinateSpace
_viewpoints
_viewport
_vignettingIntensity
_vignettingPower
_visibleManipulableItems
_volatileBufferPools
_waitForKeyedAction
_wantsCustomMainPassPostProcessForRenderer:
_wantsExposureAdaptation
_wantsHDR
_wantsSceneRendererDelegationMessages
_wantsScreenSpaceReflection
_wantsSeparateGeometryElements
_weightCount
_weightIndexForTargetNamed:
_weights
_wheelIndex
_white
_whiteBalanceTemperature
_whiteBalanceTint
_whitePoint
_width
_widthSegmentCount
_willBeginInteraction
_willRemoveFromPhysicsWorld
_willRemoveFromPhysicsWorld:
_willRenderScene:
_windowBackingDidChange:
_wireframeProgram
_wireframeRenderer
_world
_worldInitialMatrix
_worldMatrix
_wrapS
_wrapT
_wrapped
_writeSubdivCacheForHash:dataProvider:
_writesToDepthBuffer
_xAlignment
_xAxisToZAxisTransform
_xFov
_xyPlaneToXZPlaneTransform
_xyPlaneToYZPlaneTransform
_yAlignment
_yAxisToZAxisTransform
_yFov
_zAlignment
_zFar
_zFarForSkyboxRenderingProjectionMatrix:defaultZFar:
_zNear
_zoomFactor
absoluteString
acceleration
accelerationConstraint
accelerationStructureSizesWithDescriptor:
acceptsFirstMouse:
acceptsFirstResponder
accessibilityDescription
action
actionForKey:
actionKeys
actionNamed:
activateBackground:
activateFreeCamera
active
adaptativeFrameRate
adaptive
add:
addAnimation:
addAnimation:forKey:
addAnimationPlayer:forKey:
addBehavior:
addCameraNode:
addChild:
addChildNode:
addClient:
addClonesToScene
addCompletedHandler:
addDebugMarker:range:
addEntriesFromDictionary:
addIndex:
addInput:
addInstance:withName:class:
addItemWithTitle:
addItemWithTitle:action:keyEquivalent:
addItems:toScene:
addLightNode:
addModifierForProperties:atStage:withBlock:
addNodeToSelection:
addNormalsWithAttributeNamed:creaseThreshold:
addObject:
addObjectsFromArray:
addObserver:forKeyPath:options:context:
addObserver:selector:name:object:
addOutput:
addOverride:forKeyPath:
addParticleSystem:
addParticleSystem:withTransform:
addParticlesNode:
addPassResourceBindingsForArgument:
addPhysicsBody:nodeRef:colGroup:colMask:colTest:
addPhysicsFieldNode:
addPresentedHandler:
addResourceBindingsForArgument:frequency:needsRenderResource:block:
addSceneAnimation:forKey:target:
addScheduledHandler:
addSubview:
addTrackingArea:
addUIForArrayProperty:ofClass:
addUIForBoolProperty:
addUIForColorProperty:
addUIForContentsProperty:
addUIForFloatProperty:ofClass:
addUIForImageProperty:
addUIForIntProperty:ofClass:
addUIForMat4Property:
addUIForObjectProperty:
addUIForProperty:ofClass:instance:
addUIForVec2Property:
addUIForVec3Property:
addUIForVec4Property:
addUpdateRect:
addedNode:
additive
adjustViewportForRendering:
adjustsShadowProjection
affectedByGravity
affectedByPhysicsFields
alignmentMode
allBehaviors
allObjects
allTargetsFromAnimCodec
allValues
alloc
allocateRegistry
allocatedSize
allocationMenuForClass:propertyName:
allowGPUOptimizedContents
allowedClasses
allowsCameraControl
allowsCreation
allowsResting
allowsReverseTransformation
allowsTranslation
alphaComponent
alternateTitle
ambientOcclusion
anchorPoint
angularDamping
angularRestingThreshold
angularSleepingThreshold
angularVelocityFactor
animation
animationDidStart
animationDidStart:
animationDidStop
animationDidStop:finished:
animationDuration
animationEventWithKeyTime:block:
animationForKey:
animationFromScene:
animationKeys
animationManager
animationPlayerForKey:
animationPlayerRef
animationPlayerWithAnimation:
animationPlayerWithAnimationPlayerRef:
animationPlayerWithSCNAnimation:
animationRef
animationSpeed
animationTimingFunction
animationWithC3DAnimation:
animationWithCAAnimation:
animationWithContentsOfURL:
animationWithKeyPath:
animationWithMDLTransform:
animationWithSCNAnimation:
animations
antialiasingLevels
antialiasingMode
anyObject
aperture
apertureBladeCount
appendBytes:length:
appendData:
appendFormat:
appendImage:withPresentationTime:usingAdaptor:
appendPixelBuffer:withPresentationTime:
appendString:
appliedOnCompletion
applyBlock:
applyBrakingForce:forWheelAtIndex:
applyEngineForce:forWheelAtIndex:
applyForce:atPosition:impulse:
applyForce:impulse:
applyFunction:withContext:
applyTorque:impulse:
applyType:
architecture
archive:contentsForEntryName:
archive:streamForEntryName:
archiveData
archiveStream
archiveToDesktop:
archivedDataWithRootObject:options:
archivedDataWithRootObject:requiringSecureCoding:error:
areBarycentricCoordsSupported
areProgrammableSamplePositionsSupported
areRasterOrderGroupsSupported
areSoftParticlesEnabled
areaExtents
areaPolygonVertices
areaType
argument
argumentBuffersSupport
array
array:didSelect:atIndex:
arrayByAddingObject:
arrayByAddingObjectsFromArray:
arrayEditor
arrayLength
arrayOwnerPath
arrayType
arrayWithCapacity:
arrayWithObject:
arrayWithObjects:
arrayWithObjects:count:
aspectRatio
asset
assetCatalog
assetCatalogForResourceURL:
assetCatalogNamed:
assetCatalogWithURL:
assetWithSCNNode:
assetWithSCNNode:bufferAllocator:
assetWithSCNScene:
assetWithSCNScene:bufferAllocator:
asynchronousResizing
attachment
attenuationEndDistance
attenuationFalloffExponent
attenuationStartDistance
attribute:atIndex:effectiveRange:
attributeForKey:
attributeIndex
attributes
attributesOfItemAtPath:error:
audioBufferFormat
audioEngine
audioEnvironmentNode
audioListener
audioNode
audioPlayer
audioPlayerWithAVAudioNode:
audioPlayerWithSource:
audioPlayers
audioSource
audioSourceNamed:
audioSourceWithAVAudioPCMBuffer:
authoringCamera:
authoringCameraNodes
authoringCameraType
authoringDisplayMask
authoringEnvironment
authoringEnvironment2
authoringEnvironment:didCloneSelection:
authoringEnvironment:didMoveItems:fromTransform:
authoringEnvironment:selectionDidUpdateWithProposedSelection:
authoringEnvironmentCompanionNode
authoringEnvironmentForScene:
authoringEnvironmentForScene:createIfNeeded:
authoringEnvironmentForSceneRenderer:
authoringEnvironmentForSceneRenderer:createIfNeeded:
authoringEnvironmentNode
authoringEnvironmentPresentationNode
authoringLayer
authoringOverlayLayer
autoAdjustCamera
autoSwitchToFreeCamera
autoenablesDefaultLighting
automaticCameraTarget
automaticallyAdjustsShadowProjection
automaticallyAdjustsVideoMirroring
automaticallyAdjustsZRange
automaticallyNotifiesObserversForKey:
autorelease
autoreverses
avPlayer
averageGray
avoidOccluderConstraint
avoidOccluderConstraint:didAvoidOccluder:forNode:
avoidOccluderConstraint:shouldAvoidOccluder:forNode:
avoidOccluderConstraintWithTarget:
avoidsOverLighting
awakeFromNib
axis
axisA
axisB
axle
background
backingScaleFactor
backingSizeForBoundSize:
barycentricCoordsSupported
baseGeometry
baseGeometryBindTransform
becomeCurrentWithPendingUnitCount:
becomeFirstResponder
begin
beginEditingNode:
beginEditingNodes:
beginFrameAtTime:timeStamp:
beginInteraction:withViewport:
beginOrbiting
beginSheetModalForWindow:completionHandler:
beginTime
benchResult
bezierPathWithCGPath:
bezierPathWithOvalInRect:
bias
biasValues
billboardConstraint
bind:toObject:withKeyPath:options:
bindAnimatablePath:toObject:withKeyPath:options:
bindBlock
bindTo:withKeyPath:valueTransformerName:
bindingMode
birthDirection
birthLocation
birthRate
birthRateVariation
blackColor
blackPassEnabled
blendFactor
blendMode
blendOutDuration
blitCommandEncoder
block
bloomIntensity
bloomIteration
bloomIterationCount
bloomIterationSpread
bloomThreshold
blueComponent
bodyA
bodyB
bodyWithType:shape:
boneIndices
boneInverseBindTransforms
boneNode
boneWeights
bones
boolForKey:
boolValue
borderColor
borderColor4
bottomRadius
boundingRectWithSize:options:attributes:
bounds
boxWithWidth:height:length:chamferRadius:
boxWithWidth:height:length:cornerRadius:options:
brightness
btVehicle
buffer
bufferAtIndices:
bufferBytesPerRow
bufferDataSize
bufferDataType
bufferForCommonProfileArgumentNamed:
bufferIndex
bufferOffset
bufferSize
bufferStructType
buildTessellationVertexDescriptorIfNeeded
builtinProperties
bundlePath
bundleURL
bundleWithIdentifier:
bytes
bytesPerComponent
bytesPerIndex
c3dAnimation
c3dDataRepresentation
c3dTimingFunction
cStringUsingEncoding:
caAnimation
cacheObject:withTimestamp:forKey:
cachedTextureWithURL:token:
cachedTextureWithURL:token:didFallbackToDefaultTexture:
camera
cameraAutomaticTargetPoint
cameraControlConfiguration
cameraController
cameraFrustumGeometry
cameraGeometry
cameraInertiaDidEndForController:
cameraInertiaWillStartForController:
cameraNearPlaneGeometry
cameraOrthographicFrustumGeometry
cameraRef
cameraTarget
cameraWillChange
cameraWithCameraRef:
cameraWithMDLCamera:
cameraWithSCNCamera:
canAddChildNode:
canBecomeFocused
canBecomeKeyWindow
canBecomeMainWindow
canDrawConcurrently
canDrawInCGLContext:pixelFormat:forLayerTime:displayTime:
canDrawInOpenGLContext:pixelFormat:forLayerTime:displayTime:
canExportToColladaWithNoDataLoss
canImportFileExtension:
canImportFileUTI:
canRepresentDisplayGamut:
cancel
cancelEdition
cancelPreviousPerformRequestsWithTarget:selector:object:
canceled
capRadius
capitalizedString
capsuleWithCapRadius:height:
capsuleWithRadius:height:options:
capture:
captureDevice
captureDeviceOutputConsumer
captureDeviceOutputConsumerSource
captureDeviceOutputConsumerWithOptions:
captureOutput:didDropSampleBuffer:fromConnection:
captureOutput:didOutputSampleBuffer:fromConnection:
caseInsensitiveCompare:
castsShadow
catalogURL
cell
center
centerOfMassOffset
chainRootNode
chamferMode
chamferProfile
chamferRadius
chamferSegmentCount
changeColor:
channelTargetCounts
channelTargetWeights
charValue
characterAtIndex:
characterIsMember:
characterSetWithCharactersInString:
charge
chassisBody
checkBounds:
checkResourceIsReachableAndReturnError:
checkUncommittedTransactions
childNodeWithName:
childNodeWithName:recursively:
childNodes
childNodesPassingTest:
childNodesPassingTest:recursively:
childNodesWithAttribute:recursively:
children
class
classNamed:
cleanup:
clear
clearAllForces
clearCache
clearCaches
clearCoat
clearCoatRoughness
clearColor
clearCompiledLibraries
clearCorrectives
clearDepth
clearDrawable
clearRoll
clearSnapIndexes
clearValue
clickCount
clientWillDie:
clone
cloneForManipulators
close
close:
collectOverrides
collectShaderForProgram:hashCode:newVertexFunctionName:newFragmentFunctionName:sourceCodeBlock:additionalFileBlock:
collectedShadersForPid:
colliderNodes
collisionBitMask
collisionCategoryBitMask
collisionImpulse
color
color4
color::::
colorAttachments
colorBufferWriteMask
colorChanged:
colorFringeIntensity
colorFringeStrength
colorGrading
colorMatchBiPlanarPixelBufferWithFormatType:pixelBufferYCbCrMatrix:pixelBufferColorPrimaries:pixelBufferTransferFunction:sourceTextureY:sourceTextureCbCr:sourceColorSpace:destinationColorSpace:destinationTexture:renderContext:
colorMatchSourceTexture:sourceColorSpace:destinationColorSpace:destinationTexture:renderContext:
colorMatchingComputePipelineStateForBiPlanarPixelBufferWithFormatType:pixelBufferYCbCrMatrix:pixelBufferColorPrimaries:pixelBufferTransferFunction:sourceColorSpace:destinationColorSpace:renderContext:
colorMatchingComputePipelineStateForSourceColorSpace:destinationColorSpace:renderContext:
colorPixelFormat
colorSpace
colorUsingColorSpace:
colorWithAlphaComponent:
colorWithCGColor:
colorWithRed:green:blue:alpha:
comboBox:objectValueForItemAtIndex:
commandBuffer
commandBufferDidCompleteWithError:
commandBufferWithDescriptor:
commandQueue
commit
commitConfiguration
commitsOnCompletion
commonInit
commonProfile
commonProfileCacheLibrary
compare:
completed
completedUnitCount
completionHandler
component
componentConformingToProtocol:
componentsJoinedByString:
componentsPerVector
componentsSeparatedByCharactersInSet:
componentsSeparatedByString:
componentsWithURL:resolvingAgainstBaseURL:
computeAutomaticTargetPoint
computeBoundingSphereOmittingFloorsForNode:sphere:
computeCommandEncoder
computeEvaluatorWithContext:srcDesc:dstDesc:duDesc:dvDesc:
computePipelineStateForKernel:
computePipelineStateForKernel:constants:constantsHash:
computePipelineStateForKernel:threadGroupSizeIsMultipleOfThreadExecutionWidth:
computePipelineStateForKernel:withStageDescriptor:stageDescriptorUpdateBlock:constants:constantsHash:
coneWithHeight:topRadius:bottomRadius:options:
coneWithTopRadius:bottomRadius:height:
configureStageInputOutputDescriptor:withDeformerFunction:
conformsToProtocol:
connectionPosition
constantDataAtIndex:
constantPopupChanged:
constantScaleConstraint
constantToString
constrainedEdgeLengthTessellationDrawMeshElement:forMesh:instanceCount:renderContext:
constraintRef
constraints
consumeExtensions:
contactNormal
contactPoint
contactTestBetweenBody:andBody:options:
contactTestBitMask
contactTestWithBody:options:
containerFrame
containsAlpha
containsValueForKey:
contentLayer
contentSize
contents
contentsChanged:
contentsForEntryName:
contentsOfDirectoryAtPath:error:
contentsScale
contentsTransform
contextWithCGLContext:pixelFormat:colorSpace:options:
contextWithMTLDevice:
continueInteraction:withViewport:sensitivity:
continuityValues
continuousCollisionDetection
continuousCollisionDetectionThreshold
contrast
control:didFailToFormatString:errorDescription:
control:didFailToValidatePartialString:errorDescription:
control:isValidObject:
control:textShouldEndEditing:
control:textView:completions:forPartialWordRange:indexOfSelectedItem:
control:textView:doCommandBySelector:
controlTextDidBeginEditing:
controlTextDidChange:
controlTextDidEndEditing:
controller
controllerWithAnimation:
convertPoint:fromView:
convertPointToBacking:
convertPosition:fromNode:
convertPosition:toNode:
convertSizeToBacking:
convertSparsePixelRegions:toTileRegions:withTileSize:alignmentMode:numRegions:
convertSparseTileRegions:toPixelRegions:withTileSize:numRegions:
convertTime:fromLayer:
convertToAdditiveWithBaseGeometry:
convertToSparseWithBaseGeometry:
convertTransform:fromNode:
convertTransform:toNode:
convertVector:fromNode:
convertVector:toNode:
convexSweepTestWithShape:fromTransform:toTransform:options:
copy
copyAnimationChannelForKeyPath:animation:
copyAnimationChannelForKeyPath:property:
copyAnimationPathForKeyPath:animation:
copyC3DImageFromImage:
copyC3DImageFromImage:textureOptions:
copyC3DImageFromImage:textureOptions:wasCached:
copyCGLContextForPixelFormat:
copyCGLPixelFormatForDisplayMask:
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyImageFromC3DImage:
copyItemAtPath:toPath:error:
copyJointBindTransformsInto:maxCount:
copyModifiersFrom:
copyPixelBufferForItemTime:itemTimeForDisplay:
copyPropertiesAtIndex:options:
copyPropertiesFrom:
copyShaderModifiersAndLanguageVersionFrom:
copyTextureByConvertingToCubeMapIfApplicable:engineContext:needsMipmap:
copyWeakRef
copyWithZone:
cornerRadius
cornerSegmentCount
correctiveDriverCountForCorrectiveAtIndex:
correctiveDriverCounts
correctiveDriverIndices
correctiveDriverIndicesForCorrectiveAtIndex:
correctiveInBetweenCounts
correctiveInBetweenWeights
correctives
correctivesAndInBetween
count
countByEnumeratingWithState:objects:count:
countOfChildNodes
countOfMaterials
countOfParticleSystems
countOfScenes
counterSets
cpuCacheMode
createDirectoryAtPath:withIntermediateDirectories:attributes:error:
createDirectoryAtURL:withIntermediateDirectories:attributes:error:
createSnapshot:error:
createSparseIndicesBufferForMorphTarget:withSetupTarget:indicesBuffer:indicesBufferOffset:indexSize:originalToFirstDeindexedTable:computeContext:
createVertexBufferForMorphTarget:withSetupTarget:vertexBuffer:vertexBufferOffset:indicesBuffer:indicesBufferOffset:indexSize:originalToFirstDeindexedTable:computeContext:
cullMode
cumulative
currentAllocatedSize
currentBlitEncoder
currentCommandBuffer
currentComputeEncoder
currentContext
currentEvent
currentFrameHash
currentHandler
currentItem
currentRenderCommandEncoder
currentRenderPassDescriptor
currentState
currentTexture
currentThread
currentTime
currentTransforms
customActionWithDuration:actionBlock:
customMaterialAttributeNames
customMaterialAttributes
customMaterialProperties
customMaterialPropertyNames
cylinderWithRadius:height:
cylinderWithRadius:height:options:
dampingFactor
data
dataByConvertingColorData:colorSpace:newColorSpace:vectorCount:componentsPerVector:bytesPerComponent:dataOffset:dataStride:newDataOffset:newDataStride:
dataByConvertingDoublesToFloats:count:
dataForType:
dataNoCopy
dataOffset
dataSource
dataStart
dataStride
dataType
dataUsingEncoding:
dataWithBytes:length:
dataWithBytesNoCopy:length:
dataWithBytesNoCopy:length:freeWhenDone:
dataWithCapacity:
dataWithContentsOfFile:
dataWithContentsOfFile:options:error:
dataWithContentsOfURL:
dataWithContentsOfURL:options:error:
dataWithInt:
dataWithPointArray:count:bytesPerComponent:
dataWithPropertyList:format:options:error:
dataWithToken:
dataWithVector3Array:count:bytesPerComponent:
deallocateElementAtOffset:
deallocateRegistry
debugDescription
debugOptions
debugQuickLookData
debugQuickLookObject
debugQuickLookObjectWithPointOfView:
decelerationDistance
decimalDigitCharacterSet
decodeArrayOfObjectsOfClass:forKey:
decodeArrayOfObjectsOfClasses:forKey:
decodeBoolForKey:
decodeBytesForKey:returnedLength:
decodeDictionaryWithKeysOfClass:objectsOfClass:forKey:
decodeDictionaryWithKeysOfClasses:objectsOfClasses:forKey:
decodeDoubleForKey:
decodeFloatForKey:
decodeInt32ForKey:
decodeIntForKey:
decodeIntegerForKey:
decodeObjectOfClass:forKey:
decodeObjectOfClasses:forKey:
decodePropertyListForKey:
decrementUsedCount
defaultAuthoringDisplayMask
defaultCStringEncoding
defaultCameraController
defaultCenter
defaultCubeTexture
defaultLibrary
defaultLightingEnvironmentIrradianceTexture
defaultLightingEnvironmentRadianceTexture
defaultManager
defaultProgramUsingTessellation:
defaultShapeForGeometry:
defaultTexture
defaultTexture3D
defaultUICatalogForBundle:
deformedMeshReliesOnFrustum
deformedMeshReliesOnTransforms
deformerClassForMeshlesshGeometry:
deformsControlPointsForMeshlessGeometry:
deindexedToFirstDeindexedTableBufferWithBlitEncoder:indexSizeOut:
deindexedToOriginalTableBufferWithBlitEncoder:indexSizeOut:
del:
delegate
deltaX
deltaY
dependency0NormalBuffer
dependency0PositionBuffer
dependency0TangentBuffer
dependency1NormalBuffer
dependency1PositionBuffer
dependency1TangentBuffer
dependencyBufferForInput:dependencyMesh:
dependencyBufferForInput:dependencyStack:
dependencyNodeAtIndex:
depth
depth24Stencil8PixelFormatSupported
depthPixelFormat
description
destinationTexture
device
deviceDescription
deviceForOptions:
deviceQueue
deviceRef
dictionary
dictionaryRepresentation
dictionaryWithCapacity:
dictionaryWithContentsOfURL:
dictionaryWithDictionary:
dictionaryWithObject:forKey:
dictionaryWithObjects:forKeys:count:
dictionaryWithObjectsAndKeys:
didChangePointOfView
didChangeValueForKey:
didEndSelector
didFinishPlayback
didInstanciateNewElementInArray:
dimensions
direction
disableActions
disablePassesToggle:
disableScreenUpdatesUntilFlush
discretizedStraightLineMaxLength
dispatchThreadgroups:threadsPerThreadgroup:
dispatchThreads:threadsPerThreadgroup:
displacement
displayIDDidChange:
displayLink
displayLinkCallbackShouldReturnImmediately
displayLinkPolicy
displayMask
displayOptions
distanceConstraint
distanceConstraintWithTarget:
distantFuture
documentEnclosingURL
documentURL
doesNotRecognizeSelector:
dofIntensity
dollyToTarget:
doubleClick:
doubleSided
doubleValue
drag
dragField
draggingEntered:
draggingPasteboard
draggingUpdated:
drain
draw:
drawAtPoint:
drawImage:inRect:fromRect:
drawInCGLContext:pixelFormat:forLayerTime:displayTime:
drawInContext:
drawInContext:atTime:
drawInOpenGLContext:pixelFormat:forLayerTime:displayTime:
drawInRect:
drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:
drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset:
drawLineFromPoint:toPoint:color:
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:
drawPrimitives:vertexStart:vertexCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:
drawRect:
drawSceneBackgroundUsingEncoder:commandBuffer:renderPassDescriptor:
drawString:atPoint:color:
drawWithFrame:inView:
drawableResizesAsynchronously
drawableSize
drawsArea
drivenByDefaultNavigationCameraController
drivingNode
dstPositionBuffer
dstTangentBuffer
dump
duration
durationRange
dvt_supportedTypesForPropertyContents
dynamicBody
edgeCreaseIndices
edgeCreases
edgeCreasesElement
edgeCreasesSource
edgeTessellationFactor
editingModeEnabled
editingSpace
editingSpaceChanged
effectSlot
effectSlotCreateIfNeeded:
effectiveEditingSpace
effectiveModifier
electricField
elementCount
elementIndex
elementSize
elementType
emission
emissionDuration
emissionDurationVariation
emitterShape
emittingDirection
emptyShaderCache
enableFreeCamera
enableInertia
enableVBL:
enclosingScrollView
encodeBool:forKey:
encodeBytes:length:forKey:
encodeCommandsInNewCommandBufferUsingBlock:
encodeDouble:forKey:
encodeFloat:forKey:
encodeInt32:forKey:
encodeInt:forKey:
encodeInteger:forKey:
encodeObject:forKey:
encodeWithCoder:
encodedData
encodedLength
endDragging
endDraggingWithVelocity:
endEncoding
endFrame
endFrameForEngineContext:
endInteraction:withViewport:velocity:
endOrbiting
engineNotificationQueue
enqueueCommandForObject:immediateTransactionBlock:
entity
entriesPassingTest:
entryNames
entryPoint
entryWithID:withClass:
entryWithIdentifier:withClass:
enumerateBodiesUsingBlock:
enumerateChildNodesUsingBlock:
enumerateHierarchyUsingBlock:
enumerateKeysAndObjectsUsingBlock:
enumerateLinesUsingBlock:
enumerateNodesUsingBlock:
enumerateObjectsUsingBlock:
enumeratorAtPath:
error
errorWithDomain:code:userInfo:
euler
eulerAngles
eventBlock
eventHandler
eventHandlerWantsRedraw
exception
exclusive
executionHandler
expandItem:
exportAs:
exportAsCOLLADAOperationWithDestinationURL:attributes:delegate:didEndSelector:userInfo:
exportAsMovieOperationWithDestinationURL:size:attributes:delegate:didEndSelector:userInfo:
exportAssetToURL:error:
exposure
exposureAdaptationBrighteningSpeedFactor
exposureAdaptationDarkeningSpeedFactor
exposureAdaptationDuration
exposureAdaptationHistogramRangeHighProbability
exposureAdaptationHistogramRangeLowProbability
exposureAdaptationMode
exposureOffset
extendedSRGBColorSpace
extent
extraLayerMeshesWithDrivingMesh0:drivingMesh1:
extrusionDepth
fStop
fStopAnimation
faceCount
faceIndex
faceIndexing
faceTopology
fadeInDuration
fadeInWithDuration:
fadeOpacityBy:duration:
fadeOpacityTo:duration:
fadeOutWithDuration:
farVisibilityDistance
features
field
fieldGeometry
fieldOfView
fieldOfViewOrientation
fileExistsAtPath:
fileName
fileSystemRepresentation
fileURLWithPath:
fileURLWithPath:isDirectory:
fill
fillMode
fillsBackward
fillsForward
filterPropertyName:ofClass:
filteringMode
finalMesh
finalizeDecodeConstraint:
finishDecoding
finishEncoding
finishWritingWithCompletionHandler:
finished
firstIndex
firstMaterial
firstMipmapInTail
firstObject
firstResponder
fixedTimeStep
flagsChanged:
flatness
flattenedClone
flattenedCopy
float3Value
float4Value
floatForKey:
floatValue
floor
floorRef
floorWithOptions:
flush
flushBuffer
focalBlurSampleCount
focalDistance
focalDistanceAnimation
focalLength
focalLengthAnimation
focalSize
focusBehavior
focusDistance
focusNode:
focusNodes:
fogColor
fogDensityExponent
fogEndDistance
fogStartDistance
font
fontName
fontWithName:size:
forceAsyncShaderCompilation
forceBackFaceCasters
forcesBackFaceCasters
format
fractionCompleted
fragmentArguments
fragmentFunction
fragmentFunctionName
fragmentShader
frame
frameA
frameB
frameBufferBindings
frameNodes:
frameRate
frameworkLibrary
freeAxes
freeCamera
freezeButton
frequency
friction
frictionSlip
fromValue
frontFaceStencil
frontVector
frontVectorWithPointOfView:
frozen
functionNames
functionType
functionWithCAMediaTimingFunction:
functionWithControlPoints::::
functionWithName:
functionWithTimingMode:
fxContext
gamma
generateAmbientOcclusionTextureWithQuality:attenuationFactor:objectsToConsider:vertexAttributeNamed:materialPropertyNamed:
generateAmbientOcclusionVertexColorsWithQuality:attenuationFactor:objectsToConsider:vertexAttributeNamed:
generateBindingsForPipeline:withReflection:program:material:geometry:pass:
generateLightMapTextureWithQuality:lightsToConsider:objectsToConsider:vertexAttributeNamed:materialPropertyNamed:
generateLightMapVertexColorsWithLightsToConsider:objectsToConsider:vertexAttributeNamed:
generateMipmapsForTexture:
generatorWithProfile:allowingHotReload:
geodesic
geometry
geometryBindTransform
geometryDescription
geometryElementAtIndex:
geometryElementCount
geometryElementWithBuffer:primitiveType:primitiveCount:bytesPerIndex:
geometryElementWithBuffer:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:
geometryElementWithData:primitiveType:primitiveCount:bytesPerIndex:
geometryElementWithData:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:
geometryElementWithMDLSubmesh:
geometryElementWithMeshElementRef:
geometryElements
geometryForLightType:
geometryIndex
geometryModificationCount
geometryRef
geometryShader
geometrySourceChannels
geometrySourceForSemantic:
geometrySourceWithBuffer:vertexFormat:semantic:vertexCount:dataOffset:dataStride:
geometrySourceWithColorComponents:count:hasAlpha:colorSpace:
geometrySourceWithData:semantic:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:
geometrySourceWithMDLVertexAttribute:mesh:
geometrySourceWithMeshSourceRef:
geometrySourceWithNormals:count:
geometrySourceWithTextureCoordinates:count:
geometrySourceWithVertices:count:
geometrySourcesForSemantic:
geometryType
geometryWithGeometryRef:
geometryWithMDLMesh:
geometryWithMDLMesh:options:
geometryWithMDLMesh:submesh:options:
geometryWithSources:elements:
geometryWithSources:elements:sourceChannels:
getBackgroundGPUPriority
getBoundingBox
getBoundingBoxMin:max:
getBoundingSphere
getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:
getBytes:bytesPerRow:fromRegion:mipmapLevel:
getC3DImageRef
getControlPointAtIndex:values:
getDefaultSamplePositions:count:
getDouble4x4Array:maxCount:
getFloat3Array:maxCount:
getFloat4x4Array:maxCount:
getFloatArray:maxCount:
getFloatArray:maxCount:atTime:
getFloatQuaternionArray:maxCount:
getFrustum:withViewport:
getObjects:range:
getRed:green:blue:alpha:
getTimes:maxCount:
getUniqueStageDescriptor:
getValue:size:
getValues:forAttribute:forVirtualScreen:
gimbalLockEnabled
gimbalLockMode
gimbalLockVector
glID
glTextureCache
glTextureId
globalGLSharedContext
globalMetalDevice
globalObject
gobo
gpuAddress
gpuResourceID
grainIntensity
grainIsColored
grainScale
grainSlice
grainTexture
graphicalSelectionEnabled
graphicsContextWithCGContext:flipped:
greenComponent
gridUnit
groundAlbedo
groundColor
group:
groupWithActions:
halfExtent
handleBindingOfBufferNamed:frequency:usingBlock:
handleBindingOfSymbol:usingBlock:
handleEvent:forProperties:withBlock:
handleFailureInFunction:file:lineNumber:description:
handleFailureInMethod:object:file:lineNumber:description:
handleReport:data:
handleUnbindingOfSymbol:usingBlock:
hardwareFilter
hasActions
hasAlpha
hasCommonProfilePrecompiledFunctions
hasCustomProjectionTransform
hasFreeElementsLeft
hasInterleavedIndicesChannels
hasNewPixelBufferForItemTime:
hasPreciseScrollingDeltas
hasPrefix:
hasReferenceToPhysicsBody:
hasSuffix:
hasUnifiedMemory
hash
hashCodeForSource:macros:
hazardTrackingMode
headless
heap
heapAccelerationStructureSizeAndAlignWithDescriptor:
heapAccelerationStructureSizeAndAlignWithSize:
heapBufferSizeAndAlignWithLength:options:
heapOffset
heapTextureSizeAndAlignWithDescriptor:
height
heightSegmentCount
hemispheric
hidden
hide
hideSpriteKitOverlaysToggled:
highDynamicRangeCompression
hitTest:
hitTest:options:
hitTestResultsFromHitTestResultRef:
hitTestWithSegmentFromPoint:toPoint:options:
horizonElevation
horizontalMaximumAngle
ibPreferredRenderingAPI
ibSceneName
ibWantsMultisampling
identifier
identifiersOfEntriesWithClass:
idleDuration
idleDurationVariation
iesTextureForProfile:renderContext:
image
imageContentsWithPasteboard:
imageFromTexture
imageNamed:
imageSequenceAnimationMode
imageSequenceColumnCount
imageSequenceFrameRate
imageSequenceInitialFrame
imageSequenceInitialFrameVariation
imageSequenceRowCount
imageToEncodeForProposedImage:userInfo:
imageWithPath:
imageWithURL:
immediateMode
immediateModeRestrictedContext
inBetweenTargetsForCorrectiveAtIndex:
inBetweenTargetsForTargetAtIndex:
inBetweenWeights
inBetweenWeightsForCorrectiveAtIndex:
inBetweenWeightsForTargetAtIndex:
incrementUsedCount
incremental
index
indexAtPosition:
indexBuffer
indexBufferIndex
indexCount
indexGreaterThanIndex:
indexOfChildNode:
indexOfObject:
indexOfObjectPassingTest:
indexOfRefraction
indexOfSelectedItem
indexSet
indexSetWithIndex:
indexType
indexesOfObjectsPassingTest:
indicesChannelCount
inertiaEnabled
inertiaRunning
infoDictionary
infoWithSemantic:options:
iniWithBlock:
iniWithLibraryURL:
init
initAllowingHotReload:
initByReferencingFile:
initByReferencingURL:
initForJavascript:
initForReadingFromData:error:
initForReadingWithData:secure:
initForWritingWithMutableData:
initOrientationInWorldSpace:withBlock:
initParametersIfNeededForDeformedNode:
initParametersIfNeededWithDrivingNodeRef:deformedNodeRef:
initParametersIfNeededWithInnerLayerNodeRef:outerLayerNodeRef:deformedNodeRef:
initPositionInWorld:withBlock:
initPresentationCameraWithCameraRef:
initPresentationGeometryWithGeometryRef:
initPresentationLightWithLightRef:
initPresentationMaterialPropertyWithModelProperty:
initPresentationMaterialWithMaterialRef:
initPresentationMorpherWithMorphRef:
initPresentationNodeWithNodeRef:
initPresentationParametricGeometryWithParametricGeometryRef:
initPresentationShapeGeometryWithShapeGeometryRef:
initPresentationSystemWithSystemRef:
initPresentationTechniqueWithTechniqueRef:
initPresentationTextGeometryWithTextGeometryRef:
initRequiringSecureCoding:
initThroughSCNKitBridgeWithURL:options:error:
initThroughSCNKitBridgeWithURL:preserveTopology:error:
initWithAVAudioNode:
initWithAVAudioPCMBuffer:
initWithAnimationPlayerRef:
initWithArray:
initWithAssetWriterInput:sourcePixelBufferAttributes:
initWithAttributes:
initWithBlock:frequency:needsRenderResource:
initWithBody:anchor:
initWithBody:axis:anchor:
initWithBody:frame:
initWithBodyA:anchorA:bodyB:anchorB:
initWithBodyA:axisA:anchorA:bodyB:axisB:anchorB:
initWithBodyA:frameA:bodyB:frameB:
initWithBuffer:elementSize:
initWithBuffer:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:
initWithBuffer:vertexFormat:semantic:vertexCount:dataOffset:dataStride:
initWithBufferAllocator:
initWithBytes:length:encoding:
initWithBytesNoCopy:length:
initWithBytesNoCopy:length:freeWhenDone:
initWithC3DAnimation:
initWithCAAnimation:
initWithCGImage:
initWithCGImage:size:
initWithCGPath:transform:
initWithCString:encoding:
initWithCachedObject:options:
initWithCameraRef:
initWithCapacity:
initWithChainRootNode:
initWithCharacter:
initWithChassisBody:wheels:
initWithCoder:
initWithContent:options:
initWithContentsOfURL:options:error:
initWithData:
initWithData:options:
initWithData:options:error:
initWithData:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:
initWithData:semantic:colorSpace:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:
initWithData:semantic:vectorCount:componentType:componentCount:dataOffset:dataStride:
initWithData:topLeftOrigin:name:dimensions:rowStride:channelCount:channelEncoding:isCube:
initWithDelegate:
initWithDescription:size:arrayLength:
initWithDevice:error:
initWithDevice:fixedSizeElement:buffersize:name:
initWithDeviceRef:
initWithDictionary:copyItems:
initWithDrivingNode:deformedNode:bindingMode:bindingTransform:drivingNodeUVChannel:deformedNodeUVChannel:
initWithEntryNames:contents:properties:options:
initWithEntryNames:dataProvider:options:
initWithFXPass:technique:
initWithFileNamed:
initWithFileNamed:inBundle:
initWithFloorGeometryRef:
initWithFormat:shareContext:
initWithFrame:
initWithFrame:options:
initWithGeometry:resourceManager:
initWithGeometry:thresholdMode:lod:
initWithGeometry:thresholdMode:thresholdValue:
initWithGeometryRef:
initWithIndexes:length:
initWithIndexesInRange:
initWithInnerLayerNode:outerLayerNode:deformedNode:bindingMode:bindingTransform:
initWithInnerLayerNode:outerLayerNode:parameters:
initWithInt:
initWithKeyOptions:valueOptions:capacity:
initWithLayer:
initWithLightRef:
initWithMTLTexture:options:
initWithMaterialRef:
initWithMediaType:outputSettings:
initWithMeshElement:
initWithMeshSource:
initWithMeshlessGeometry:outputs:deformDataKind:finalDataKind:resourceManager:computeContext:
initWithMorphRef:
initWithName:channelEncoding:textureDimensions:turbidity:sunElevation:upperAtmosphereScattering:groundAlbedo:
initWithName:indexBuffer:indexCount:indexType:geometryType:material:topology:
initWithName:scatteringFunction:
initWithName:semantic:
initWithNibName:bundle:
initWithNodeRef:
initWithObjects:
initWithObjects:count:
initWithOptions:
initWithOwner:
initWithPage:allocator:
initWithParametricGeometryRef:
initWithParent:andCustomName:
initWithParent:propertyType:
initWithParticleSystemRef:
initWithPasteboard:
initWithPath:manager:
initWithPath:options:error:
initWithPixelBufferAttributes:
initWithProfile:
initWithQueue:screen:policy:block:
initWithRect:options:owner:userInfo:
initWithRenderer:size:attributes:outputURL:
initWithSCNAnimation:
initWithScene:
initWithScene:attributes:outputURL:
initWithSceneRef:
initWithServiceName:
initWithSkinnerRef:
initWithString:attributes:
initWithTechniqueRef:
initWithTextGeometryRef:
initWithTexture:size:flipped:colorSpace:
initWithTimingFunctionRef:
initWithTitle:
initWithTitle:action:keyEquivalent:
initWithToken:
initWithType:component:
initWithType:data:
initWithType:shape:
initWithURL:
initWithURL:fileType:error:
initWithURL:offset:length:
initWithURL:options:
initWithURL:resolvingAgainstBaseURL:
initWithUTF8String:
initWithVertexBuffers:vertexCount:descriptor:submeshes:
initWithView:
initializationHandler
initialize
innerConeAngle
innerRadius
inputBias
inputMode
inputOrigin
inputProperty
inputScale
inputStreamWithData:
inputTextureWithName:
inputsCount
insertChildNode:atIndex:
insertMaterial:atIndex:
insertObject:atIndex:
insertObject:inChildNodesAtIndex:
insertObject:inMaterialsAtIndex:
insertObject:inParticleSystemsAtIndex:
insertString:atIndex:
insideTessellationFactor
inspectCamera:
instance
instanceDidChange
instanceMethodSignatureForSelector:
instanceNewElementInArray:withPropertyName:
instanceWillChange
instancesRespondToSelector:
intValue
integerForKey:
integerValue
intensity
interfaceWithProtocol:
interleavedIndicesChannels
invalidate
invalidateCameraTarget
inverseKinematicsConstraintWithChainRootNode:
invocationWithMethodSignature:
invokeWithTarget:
iosurface
iosurfacePlane
irradianceData
irradianceTextureForEnvironmentTexture:renderContext:applySH:
irradianceTextureForPrecomputedLightingEnvironment:
isARepeat
isASTCPixelFormatsSupported
isAborting
isAbsolutePath
isActive
isAdaptive
isAdditive
isAffectedByGravity
isAliasable
isAnimated
isAnimationForKeyPaused:
isAppliedOnCompletion
isAsynchronous
isBlackPassEnabled
isCancelled
isCube
isCumulative
isCustom
isDepth24Stencil8PixelFormatSupported
isDirectionInvertedFromDevice
isDoubleSided
isDragging
isDrawableAvailable
isEditingSubComponent
isEnabled
isEqual:
isEqualTo:
isEqualToDictionary:
isEqualToString:
isExclusive
isFileURL
isFocusInteractionEnabled
isFramebufferOnly
isFull
isGeodesic
isHandlingKeyboard
isHeadless
isHemispheric
isHidden
isHittable
isIncremental
isInertiaRunning
isJitteringEnabled
isKindOfClass:
isLightingEnabled
isLitPerPixel
isLoaded
isLowPower
isMainThread
isMemberOfClass:
isNodeInsideFrustum:withPointOfView:
isNodeManipulator
isOpaque
isPaused
isPausedForEditing
isPausedOrPausedByInheritance
isPlaying
isPositional
isPresentationInstance
isReadyForMoreMediaData
isRelative
isRemovable
isRemovedOnCompletion
isResting
isRotated
isScreenSpace
isSelectedForSegment:
isShareable
isSparse
isSubclassOfClass:
isTemporalAntialiasingEnabled
isUndefined
isUserInteractionEnabled
isVertexAmplificationEnabled
isWrapped
isolate:
issueWithShadable:entryPoint:effectiveModifier:message:line:type:
item
itemArray
itemAtRow:
itemTimeForHostTime:
ivarsOfItem:
javaScriptActionWithDuration:script:
javaScriptActionWithScript:duration:
jitter
jitteringEnabled
joint
jointAnimation
jointBindTransforms
jointForNode:
jointPaths
jointRestTransforms
jointWithBody:anchor:
jointWithBody:axis:anchor:
jointWithBody:frame:
jointWithBodyA:anchorA:bodyB:anchorB:
jointWithBodyA:axisA:anchorA:bodyB:axisB:anchorB:
jointWithBodyA:frameA:bodyB:frameB:
joints
jsChildNodesWithAttribute:
jsConstructor
jump
jumpSpeed
keepTargetDirection
keyDown:
keyForNodeAttributes
keyPathDst
keyPathSrc
keyPathsForValuesAffectingEulerAngles
keyPathsForValuesAffectingFieldOfView
keyPathsForValuesAffectingFocalLength
keyPathsForValuesAffectingOrientation
keyPathsForValuesAffectingPosition
keyPathsForValuesAffectingRotation
keyPathsForValuesAffectingTransform
keyPathsForValuesAffectingValueForKey:
keyTimes
keyUp:
keys
kinematicBody
label
lastFrameTime
lastItem
lastObject
lastPathComponent
launch
launchImagePicker
launchMonitor:
layer
layer:shouldInheritContentsScale:fromWindow:
layerContentsScaleFactor
layerSizeInPixels
layerToFocusForRenderedLayer:
layout
lazyMTKTextureLoader
length
lengthSegmentCount
lensShift
levelOfDetailWithGeometry:screenSpaceRadius:
levelOfDetailWithGeometry:worldSpaceDistance:
levelsOfDetail
libraryForDevice:
libraryForProgramDesc:completionHandler:
libraryForSourceCode:options:
light
lightBufferBindings
lightEmissionRadiusFactor
lightProbeWithSCNLight:node:
lightRef
lightType
lightWithLightRef:
lightWithMDLLight:
lightWithMDLLightProbe:
lightWithSCNLight:
lightingEnvironment
lightingModelName
line
lineRangeForRange:
linearGravityField
linearRestingThreshold
linearSleepingThreshold
linkCustomPropertyWithParent:andCustomName:
litPerPixel
load
loadAction
loadIfNeeded
loadNibNamed:owner:topLevelObjects:
loadSceneAtURL:options:withReply:
loadTextures
loaded
loadingPolicy
local
localCoordinates
localFront
localNormal
localRight
localRotateBy:
localTranslateBy:
localizedDescription
localizedStringForKey:value:table:
location
locationInWindow
locationNumber
lock
lockFocusIfCanDraw
lockLayout
locksAmbientWithDiffuse
logs
longValue
lookAt:up:localFront:
lookAtConstraintWithTarget:
lookAtWith:target:
lookUpFoundInstance
lookUpKey
lookUpKeyForObjectNamed:class:
loops
lowLatency
lowPower
magFilter
magneticField
magnification
magnificationFilter
magnifyWithEvent:
main
mainBundle
mainPassColorTextureAtIndex:
mainScreen
makeAliasable
makeBackingLayer
makeCurrentContext
makeFirstResponder:
makeKeyAndOrderFront:
makeReadOnlyBuffersWithBaseGeometry:baseMesh:blitEncoder:
manipulator
mappingChannel
markAsFinished
mass
matchesDescription:size:arrayLength:
matchesInString:options:range:
matchesRenderPassDescriptor:
material
materialAttachmentWithGLKTextureInfo:
materialFace
materialModificationCount
materialNamed:
materialPropertyWithContents:
materialRef
materialRefCreateIfNeeded
materialWithColor:
materialWithContents:
materialWithMDLMaterial:
materialWithMDLMaterial:options:
materialWithMaterialRef:
materialWithName:
materialWithSCNMaterial:
materials
matrix
matrixWithNoRoll:
maxAllowedRotationAngle
maxAllowedRotationAngleForJoint:
maxAnisotropy
maxArgumentBufferSamplerCount
maxTessellationFactor
maxTextureHeight2D
maxTextureWidth2D
maxThreadgroupMemoryLength
maxThreadsPerThreadgroup
maxTotalThreadsPerThreadgroup
maxValue
maxViewportCount
maximumAngularLimit
maximumAngularLimit1
maximumAngularLimit2
maximumConcurrentCompilationTaskCount
maximumDrawableCount
maximumEdgeLength
maximumHorizontalAngle
maximumLinearAcceleration
maximumLinearLimit
maximumLinearVelocity
maximumPointScreenSpaceRadius
maximumShadowDistance
maximumSuspensionForce
maximumSuspensionTravel
maximumTime
maximumTwistAngle
maximumVerticalAngle
menu
menuItemForInstance:propertyName:
meshBindTransform
meshElement
meshForDeformedTopology
meshSource
meshWithSCNGeometry:
meshWithSCNGeometry:bufferAllocator:
metalDevice
metalLayer
metalTexture
metalTextureWithEngineContext:textureSampler:nextFrameTime:status:
metalness
minFilter
minValue
minificationFilter
minimumAngularLimit
minimumHorizontalAngle
minimumLanguageVersion
minimumLinearLimit
minimumLinearTextureAlignmentForPixelFormat:
minimumPointScreenSpaceRadius
minimumTextureBufferAlignmentForPixelFormat:
minimumTime
minimumVerticalAngle
mipFilter
mipmapLevelCount
mkSemantic
mlDelegate
modelTransform
modelTypeChanged:
modifierFlags
momentumPhase
monospacedSystemFontOfSize:weight:
morphIncrementallyWithComputeContext:positions:normals:
morphRef
morphSparseWithComputeContext:positions:normals:
morpherWithMDLMesh:
morpherWithMorphRef:
motionBlurIntensity
motorMaximumForce
motorMaximumTorque
motorTargetAngularVelocity
motorTargetLinearVelocity
mouseDown:
mouseDragged:
mouseLocation
mouseLocationOutsideOfEventStream
mouseMoved:
mouseUp:
movabilityHint
moveBy:duration:
moveByX:y:z:duration:
moveItemAtPath:toPath:error:
moveItemAtURL:toURL:error:
moveTo:duration:
moveToTransform:
moveToX:y:z:duration:
mtlTexture
multiply
mutableBytes
mutableChildNodes
mutableCopy
mutableCopyWithZone:
mutableData
mutableGeometrySourcesForSemantic:
mutableMaterials
mutateGeometrySourcesWithSemantics:usingBlock:
name
namedTextureWithName:scaleFactor:
navigationCameraController
nearVisibilityDistance
needsRenderResource
needsUpdate
newAccelerationStructureWithDescriptor:
newAccelerationStructureWithSize:
newArgumentEncoderWithArguments:
newArgumentEncoderWithBufferBinding:
newBinaryArchiveWithDescriptor:error:
newBufferForDataKind:meshSource:dataType:forStageInputOutputDescriptor:usePrivateStorageMode:outStride:
newBufferForDataKind:positionSource:normalSource:positionDataType:normalDataType:forStageInputOutputDescriptor:usePrivateStorageMode:outStride:outPositionOffset:outNormalOffset:
newBufferWithBytes:length:options:
newBufferWithBytesNoCopy:length:options:deallocator:
newBufferWithData:type:
newBufferWithLength:options:
newCommandQueueWithDescriptor:
newCommandQueueWithMaxCommandBufferCount:
newComputePipelineStateForDesc:library:
newComputePipelineStateWithDescriptor:options:completionHandler:
newComputePipelineStateWithFunction:completionHandler:
newComputePipelineStateWithFunction:error:
newComputePipelineStateWithFunction:options:completionHandler:
newComputePipelineStateWithFunction:options:reflection:error:
newComputePipelineStateWithFunctionName:
newComputePipelineStateWithFunctionName:constantValues:
newComputePipelineStateWithFunctionName:library:
newCounterSampleBufferWithDescriptor:error:
newCubemapTextureForLatlongTexture:pixelFormat:engineContext:needsMipmap:
newDefaultLibrary
newDefaultLibraryWithBundle:error:
newDeformerInstanceForNode:outputs:computeVertexCount:context:
newDepthStencilStateWithDescriptor:
newDynamicLibrary:error:
newEvent
newFence
newFunctionWithName:
newFunctionWithName:constantValues:error:
newHeapWithDescriptor:
newIOCommandQueueWithDescriptor:error:
newIOFileHandleWithURL:compressionMethod:error:
newIOFileHandleWithURL:error:
newIOHandleWithURL:compressionMethod:error:
newIOHandleWithURL:error:
newInstanceMenuClicked:
newLibraryWithData:error:
newLibraryWithFile:error:
newLibraryWithSource:options:completionHandler:
newLibraryWithSource:options:error:
newLibraryWithStitchedDescriptor:completionHandler:
newLibraryWithStitchedDescriptor:error:
newLibraryWithURL:error:
newLogStateWithDescriptor:error:
newNodeAtPath:type:
newPipelineStateConfiguratorForMeshElement:patchType:device:
newPropertyWithName:type:role:
newRadianceTextureForEnvironmentTexture:engineContext:cpuAccessible:commandBuffer:
newRasterizationRateMapWithDescriptor:
newRemoteBufferViewForDevice:
newRemoteTextureViewForDevice:
newRenderPipelineStateWithDescriptor:completionHandler:
newRenderPipelineStateWithDescriptor:error:
newRenderPipelineStateWithDescriptor:options:reflection:error:
newRenderPipelineStateWithMeshDescriptor:options:completionHandler:
newRenderPipelineStateWithMeshDescriptor:options:reflection:error:
newRenderPipelineStateWithTileDescriptor:options:completionHandler:
newRenderPipelineStateWithTileDescriptor:options:reflection:error:
newResidencySetWithDescriptor:error:
newSamplerStateWithDescriptor:
newSceneWithURL:
newSharedEvent
newSharedEventWithHandle:
newSharedTextureHandle
newSharedTextureWithHandle:
newSubBufferForAllocator:
newSubBufferWithBytes:length:renderContext:
newSubmeshWithGeometryData:indexBufferLength:interleaved:channelCount:channelIdx:bytesPerIndex:indexType:geometryType:allocator:indexCount:topology:
newSubmeshWithSCNGeometryElement:bufferAllocator:
newSubmeshWithSCNGeometryElement:bufferAllocator:positionSourceChannel:
newSubmeshWithUniquedIndexData:andSCNGeometryElement:bufferAllocator:
newTextureForDevice:
newTextureUsingMTKTextureLoaderWithData:options:
newTextureUsingMTKTextureLoaderWithURL:options:
newTextureViewWithPixelFormat:
newTextureViewWithPixelFormat:textureType:levels:slices:
newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:
newTextureWithContentsOfURL:options:error:
newTextureWithData:options:error:
newTextureWithDescriptor:
newTextureWithDescriptor:iosurface:plane:
newTextureWithDescriptor:offset:bytesPerRow:
newTextureWithName:scaleFactor:bundle:options:error:
newlineCharacterSet
next
nextDrawable
nextEventMatchingMask:untilDate:inMode:dequeue:
nextFrameTime
nextKeyView
nextObject
node
node:propertyWithName:type:role:
nodeA
nodeAtPoint:recursive:
nodeB
nodeBufferBindings
nodeManipulatorItemWithNode:screenSize:
nodeWithGeometry:
nodeWithMDLAsset:
nodeWithMDLAsset:options:
nodeWithMDLObject:
nodeWithMDLObject:masterObjects:sceneNodes:skinnedMeshes:skelNodesMap:asset:options:
nodeWithMDLObject:options:
nodeWithNodeRef:
nodesInsideFrustumWithPointOfView:
noiseFieldWithSmoothness:animationSpeed:
normal
null
numberOfItemsInComboBox:
numberOfRows
numberWithDouble:
numberWithFloat:
numberWithInt:
numberWithInteger:
numberWithShort:
numberWithUnsignedChar:
numberWithUnsignedInt:
numberWithUnsignedInteger:
numberWithUnsignedLong:
numberWithUnsignedLongLong:
numberWithUnsignedShort:
objCType
object
objectAtIndex:
objectAtIndexedSubscript:
objectClass
objectController
objectForKey:
objectForKeyedSubscript:
objectHandleClicked:
objectInAllBehaviorsAtIndex:
objectInChildNodesAtIndex:
objectInChildNodesWithAttribute:firstOnly:
objectInChildNodesWithName:
objectInMaterialsAtIndex:
objectPathWithString:
objectWithName:class:
objectWithSCNNode:
objectWithSCNNode:bufferAllocator:
observeValueForKeyPath:ofObject:change:context:
observer
occluderCategoryBitMask
offscreenRendererWithContext:size:
offscreenRendererWithDevice:sceneRendererDelegate:size:
offscreenRendererWithDevice:size:
offset
opaque
open
openFile:
openGLContext
openGLContextForPixelFormat:
openGLPixelFormatForDisplayMask:
orangeColor
orderFrontColorPanel:
orderedSet
orderedSetWithCapacity:
orderedSetWithObject:
orientation
orientationConstraintInWorldSpace:withBlock:
orientationDirection
orientationOffset
originalToFirstDeindexedTableBufferWithBlitEncoder:indexSizeOut:
orthographicScale
outerConeAngle
outerRadius
outgoingPointOfView
outgoingScene
outlineView:acceptDrop:item:childIndex:
outlineView:child:ofItem:
outlineView:dataCellForTableColumn:item:
outlineView:didAddRowView:forRow:
outlineView:didClickTableColumn:
outlineView:didRemoveRowView:forRow:
outlineView:draggingSession:endedAtPoint:operation:
outlineView:draggingSession:willBeginAtPoint:forItems:
outlineView:heightOfRowByItem:
outlineView:isGroupItem:
outlineView:isItemExpandable:
outlineView:itemForPersistentObject:
outlineView:mouseDownInHeaderOfTableColumn:
outlineView:namesOfPromisedFilesDroppedAtDestination:forDraggedItems:
outlineView:nextTypeSelectMatchFromItem:toItem:forString:
outlineView:numberOfChildrenOfItem:
outlineView:objectValueForTableColumn:byItem:
outlineView:pasteboardWriterForItem:
outlineView:persistentObjectForItem:
outlineView:rowViewForItem:
outlineView:selectionIndexesForProposedSelection:
outlineView:setObjectValue:forTableColumn:byItem:
outlineView:shouldEditTableColumn:item:
outlineView:shouldExpandItem:
outlineView:shouldReorderColumn:toColumn:
outlineView:shouldSelectItem:
outlineView:shouldSelectTableColumn:
outlineView:shouldShowCellExpansionForTableColumn:item:
outlineView:shouldShowOutlineCellForItem:
outlineView:shouldTrackCell:forTableColumn:item:
outlineView:shouldTypeSelectForEvent:withCurrentSearchString:
outlineView:sizeToFitWidthOfColumn:
outlineView:sortDescriptorsDidChange:
outlineView:tintConfigurationForItem:
outlineView:typeSelectStringForTableColumn:item:
outlineView:updateDraggingItemsForDrag:
outlineView:userCanChangeVisibilityOfTableColumn:
outlineView:userDidChangeVisibilityOfTableColumns:
outlineView:validateDrop:proposedItem:proposedChildIndex:
outlineView:viewForTableColumn:item:
outlineView:willDisplayCell:forTableColumn:item:
outlineView:willDisplayOutlineCell:forTableColumn:item:
outlineView:writeItems:toPasteboard:
outlineViewColumnDidMove:
outlineViewColumnDidResize:
outlineViewItemDidCollapse:
outlineViewItemDidExpand:
outlineViewItemWillCollapse:
outlineViewItemWillExpand:
outlineViewSelectionDidChange:
outputTextureWithName:
outputURL
overlaySKScene
overrides
owner
ownerWillDie
panSensitivity
panel
parallaxCenterOffset
parallaxCorrectionEnabled
parallaxExtentsFactor
parameters
params
parent
parentForItem:
parentItem
parentNode
parentRelativeLevel
parentRelativeSlice
parentTexture
parentView
parentWillDie:
parseSpecialKey:withPath:intoDestination:
parseSpecialKey:withPath:intoDestination:remainingPath:
particleAngle
particleAngleVariation
particleAngularVelocity
particleAngularVelocityVariation
particleBounce
particleBounceVariation
particleCharge
particleChargeVariation
particleColor
particleColorVariation
particleDiesOnCollision
particleFriction
particleFrictionVariation
particleGeometries
particleImage
particleIntensity
particleIntensityVariation
particleLifeSpan
particleLifeSpanVariation
particleMass
particleMassVariation
particlePropertyControllerWithAnimation:
particleSize
particleSizeVariation
particleSystem
particleSystemNamed:
particleSystemNamed:inDirectory:
particleSystemRef
particleSystemWithParticleSystemRef:
particleVelocity
particleVelocityVariation
particlesGeometry
passAtIndex:
passBufferBindings
passDescriptor
patchFont:
path
pathByAppendingPropertyComponent:
pathByMakingURLRelativeToCatalog:
pathComponents
pathControlClicked:
pathControlItemForInstance:
pathExtension
pathForResource:ofType:
pathForResource:ofType:inDirectory:
pathItems
pause
pause:
pauseAnimationForKey:
pauseDisplayLink
paused
pausesIncomingScene
pausesOutgoingScene
peerCount
peerGroupID
peerIndex
penetrationDistance
performConsistencyCheck
performDragOperation:
performPresentationInstanceQueriesInScene:usingBlock:
performSelector:
performSelector:onTarget:
performSelector:withObject:
performSelector:withObject:afterDelay:
performSelector:withObject:withObject:
performanceStatisticsForPid:
phase
physicsBody
physicsCollisionsEnabled
physicsField
physicsShape
physicsWorld
physicsWorld:didBeginContact:
physicsWorld:didEndContact:
physicsWorld:didUpdateContact:
pipeRadius
pipeSegmentCount
pipelineStateHashForMeshElement:patchType:
pivot
pixelFormat
pixelsHigh
pixelsWide
planeWithWidth:height:
planeWithWidth:height:options:
play
play:
playAudioSource:waitForCompletion:
playbackSpeed
player
pointOfCulling
pointOfCullingComboBox
pointOfView
pointOfViewComboBox
pointSize
pointValue
pointerValue
popDebugGroup
popUpContextMenu:withEvent:forView:
popupChanged:
position
positionConstraintInWorldSpace:withBlock:
positionOffset
positional
postCommandWithContext:object:applyBlock:
postCommandWithContext:object:key:applyBlock:
postCommandWithContext:object:key:subscriptIndex:derivedKeyPath:applyBlock:
postCommandWithContext:object:key:subscriptKey:derivedKeyPath:applyBlock:
postCommandWithContext:object:keyPath:applyBlock:
postMorphingDeformers
postNotificationName:object:
postNotificationName:object:userInfo:
postProjectionTransform
postSkinningDeformers
precomputedLightingEnvironment
precomputedLightingEnvironmentContentsWithData:error:
precomputedLightingEnvironmentContentsWithURL:error:
precomputedLightingEnvironmentDataForContents:device:error:
preferredFilenameExtension
preferredFrameRate
preferredFramesPerSecond
prefersGL3
prepareContentOfPopUpButton
prepareForDragOperation:
prepareObjects:withCompletionHandler:
prepareRendererAtIndex:withScene:renderSize:pointOfView:parentRenderer:
prepareScene:
prepareSnapToAlignData
prepareSnapToAlignDataIfNeeded
prepareWithTarget:implicitDuration:
preprocessorMacros
presentDrawable:
presentDrawable:afterMinimumDuration:
presentScene:withTransition:incomingPointOfView:completionHandler:
presentationCamera
presentationCapsule
presentationCone
presentationCylinder
presentationGeometry
presentationInstance
presentationLight
presentationMaterial
presentationMaterialProperty
presentationMorpher
presentationNode
presentationPlane
presentationPyramid
presentationSphere
presentationTorus
presentationTube
presentsWithTransaction
preserveScale
pressureChangeWithEvent:
primitiveCount
primitiveRange
primitiveType
privateFunctions
privateRendererOwner
probeEnvironment
probeExtents
probeOffset
probeType
proceduralContents
processInfo
processName
program:bindValueForSymbol:atLocation:programID:renderer:
program:handleError:
program:unbindValueForSymbol:atLocation:programID:renderer:
programIsOpaque:
programWithHashCode:engineContext:trackedResource:introspectionDataPtr:
programWithLibrary:
programWithNode:withMaterial:
programmableSamplePositionsSupported
progress
progressWithTotalUnitCount:
projectPoint:
projectPoints:count:
projection
projectionDirection
projectionMatrix
projectionTransform
projectionTransformWithViewportSize:
properties
propertiesForEntryName:
propertyControllers
propertyListWithData:options:format:error:
propertyName
propertyNamed:
propertyType
propertyWithSemantic:
pvrtcData
pyramidWithWidth:height:length:options:
quaternion
query
queryItems
queuedFrameCount
radialGravityField
radialSegmentCount
radialSpan
radianceData
radianceTextureForEnvironmentTexture:engineContext:commandBuffer:
radianceTextureForPrecomputedLightingEnvironment:
radius
range
rangeAtIndex:
rangeOfString:
rangeOfString:options:
rangeOfString:options:range:
rangeValue
rasterOrderGroupsSupported
rasterizationRateMap
rate
ratioForTime:
rayTestWithSegmentFromPoint:toPoint:options:
reParsePasses
readWriteTextureSupport
readonly
readsFromDepthBuffer
reason
recommendedMaxWorkingSetSize
reconfigureIfNeededWithContext:programHashCodeRequirements:
recordGraph
recordGraph:
recordGraphInView:
rectValue
recursivePathsForResourcesOfType:inDirectory:
redComponent
referenceCount
referenceName
referenceNodeName
referenceNodeWithURL:
referenceSceneName
referenceURL
reflectionCategoryBitMask
reflectionFallOffEnd
reflectionFallOffStart
reflectionFalloffEnd
reflectionFalloffStart
reflectionSampleCount
reflective
reflectivity
registerArgument:frequency:block:
registerArgument:frequency:needsRenderResource:block:
registerForDraggedTypes:
registerPlayerIfNeeded:
registerSemantic:withBlock:
registerShadableArgumentBindingBlockForBuffers:textures:samplers:
registerUserBlockTrampoline:
registryID
regularExpressionWithPattern:options:error:
rejectFirstResponder
relativePath
releaseProgramForResource:
reloadData
reloadPipelinesIfNeeded
remoteObjectProxy
remoteStorageBuffer
remoteStorageTexture
removable
remove
removeActionForKey:
removeAllActions
removeAllAnimations
removeAllAnimationsWithBlendOutDuration:
removeAllAudioPlayers
removeAllBehaviors
removeAllBindings
removeAllDebugMarkers
removeAllIndexes
removeAllItems
removeAllMaterials
removeAllModifiers
removeAllObjects
removeAllOverrides
removeAllParticleSystems
removeAnimationForKey:
removeAnimationForKey:blendOutDuration:
removeAnimationForKey:fadeOutDuration:
removeAudioPlayer:
removeButton
removeCameraNode:
removeClient:
removeClonesFromScene
removeForKeyPath:
removeFromParentNode
removeFromSuperview
removeIndex:
removeItemAtPath:error:
removeItemAtURL:error:
removeItemsFromScene:
removeLastObject
removeLightNode:
removeMaterialAtIndex:
removeModifiersOfStage:
removeObject:
removeObjectAtIndex:
removeObjectClicked:
removeObjectForKey:
removeObjectFromChildNodesAtIndex:
removeObjectFromMaterialsAtIndex:
removeObjectFromParticleSystemsAtIndex:
removeObjectsAtIndexes:
removeObserver:forKeyPath:
removeObserver:forKeyPath:context:
removeObserver:name:object:
removeOutput:
removeParticleSystem:
removeParticlesNode:
removePhysicsBody:handle:
removePhysicsFieldNode:
removeSourceRenderersForEngineContext:
removeTrackingArea:
removedNode:
removedOnCompletion
render
render:toMTLTexture:commandBuffer:bounds:colorSpace:
renderAndAppendWithPresentationTime:usingAdaptor:metalTextureCache:cvQueue:completionBlock:
renderAtTime:
renderAtTime:commandBuffer:viewPoints:
renderAtTime:encoder:commandQueue:passDescriptor:viewPoints:
renderAtTime:encoder:commandQueue:passDescriptor:viewPoints:coordinateSpace:
renderAtTime:viewport:commandBuffer:passDescriptor:
renderAtTime:viewport:encoder:passDescriptor:commandQueue:
renderBufferFormat
renderCommandEncoder
renderCommandEncoderWithDescriptor:
renderContext:commandBufferDidCompleteWithError:
renderContext:didFallbackToDefaultTextureForSource:message:
renderDebugOptions
renderGraphUtils
renderInContext:
renderMovieToURL:size:antialiasingMode:attributes:error:
renderNode:renderer:arguments:
renderPassDescriptor
renderResourceForDeformerStack:node:dataKind:
renderResourceForEffectSlot:withEngineContext:didFallbackToDefaultTexture:
renderResourceForImage:sampler:options:engineContext:didFallbackToDefaultTexture:
renderResourceForImageProxy:sampler:engineContext:didFallbackToDefaultTexture:
renderResourceForMorpher:baseMesh:dataKind:provider:
renderResourceForProgramDesc:renderPassDescriptor:
renderResourceForSkinner:baseMesh:dataKind:provider:
renderTargetArrayLength
renderToFramebuffer:shouldClear:
renderToTexture:commandQueue:
renderToTexture:computeCommandHandler:blitCommandHandler:completionHandler:helper:
renderToTexture:computeCommandHandler:blitCommandHandler:helper:
renderTransition:withInputTexture:outputTexture:inputTextureSize:outputTextureSize:time:
renderTransition:withInputTexture:outputTexture:time:encoder:pass:commandQueue:
renderWithCommandBuffer:viewPoints:
renderWithCommandBuffer:viewpoints:coordinateSpace:
renderWithEncoder:pass:commandQueue:
renderWithEngineContext:textureSampler:nextFrameTime:
renderWithEngineContext:textureSampler:nextFrameTime:status:
renderWithViewport:commandBuffer:passDescriptor:
renderer
renderer:commandBufferDidCompleteWithError:
renderer:didApplyAnimationsAtTime:
renderer:didApplyConstraintsAtTime:
renderer:didFallbackToDefaultTextureForSource:message:
renderer:didSimulatePhysicsAtTime:
renderer:updateAtTime:
renderer:willRenderScene:atTime:
rendererContextForTextureSourceWithEngineContext:
rendererDelegate
rendererDidChange:
rendererForSceneRenderer:
rendererOptionsPanelForView:
rendererWithContext:options:
rendererWithDevice:options:
renderingAPI
renderingAPIForOptions:
renderingAlgorithm
renderingMode
renderingOrder
rendersContinuously
rendersIntoMaterial
repeatAction:count:
repeatActionForever:
repeatCount
repeatDuration
replaceBytesInRange:withBytes:
replaceCharactersInRange:withString:
replaceChildNode:with:
replaceMaterial:with:
replaceMaterialAtIndex:withMaterial:
replaceObjectAtIndex:withObject:
replaceObjectInChildNodesAtIndex:withObject:
replaceObjectInMaterialsAtIndex:withObject:
replaceObjectInParticleSystemsAtIndex:withObject:
replaceOccurrencesOfString:withString:options:range:
replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:
replaceRegion:mipmapLevel:withBytes:bytesPerRow:
replicatesOrientation
replicatesPosition
replicatorConstraint
representationUsingType:properties:
representedObject
requestMediaDataWhenReadyOnQueue:usingBlock:
requiredInputs
requiresMainThreadUpdates
requiresSecureCoding
reset
resetToTransform:
resetTransform
resetVolatileMeshElements
resetVolatileMeshes
resignCurrent
resignFirstResponder
resolveInsideArchiveWithAssetNamed:
resolveInstanceMethod:
resolveTexture
resolvedBackgroundColorDidChange:
resolver
resourcePath
respondsToCollision
respondsToSelector:
restitution
resume
resumeAnimationForKey:
resumeDisplayLink
retain
retainCount
reverbBlend
reverseObjectEnumerator
reverseTransformedValue:
reversedAction
rightMouseDragged:
rightMouseUp:
ringRadius
ringSegmentCount
rollAroundTarget:
rollBy:aroundScreenPoint:viewport:
rollCameraSpaceBy:withPoint:viewport:
root
rootNode
rootNodeForLayer:
rootResource
rotateBy:aroundTarget:
rotateByAngle:aroundAxis:duration:
rotateByX:Y:
rotateByX:y:z:duration:
rotateOf:
rotateToAxisAngle:
rotateToAxisAngle:duration:
rotateToX:y:z:duration:
rotateToX:y:z:duration:shortestUnitArc:
rotateWithEvent:
rotateWithVector:mode:
rotation
rotationRepresentation
rotationSensitivity
rotations
roughness
rowForItem:
runAction:
runAction:afterActionWithKey:
runAction:completionHandler:
runAction:forKey:
runAction:forKey:completionHandler:
runAction:onChildNodeWithName:
runBench:
runBlock:
runModal
sRGBColorSpace
sRGBTexture
sWrapMode
sampleCount
sampleDistributedShadowMaps
sampleTimestamps:gpuTimestamp:
samplerAtIndices:
saturation
save
saveAndCreateUSDZPackageWithURL:
saveInitialSelection
savePanel
scale
scaleBy:duration:
scaleMode
scaleOffset
scaleTo:duration:
scales
scatteringFunction
scene
scene:nodeAtPath:type:
sceneAtIndex:options:
sceneAtIndex:options:error:
sceneCount
sceneDatabase
sceneDidChange
sceneFileTypes
sceneNamed:
sceneNamed:options:
sceneRef
sceneRenderer
sceneSource
sceneSourceOptions
sceneSourceRef
sceneSourceWithData:options:
sceneSourceWithURL:options:
sceneTime
sceneTypes
sceneWillDie
sceneWithClass:options:error:
sceneWithClass:options:statusHandler:
sceneWithData:atIndex:options:
sceneWithData:options:
sceneWithMDLAsset:
sceneWithMDLAsset:options:
sceneWithOptions:error:
sceneWithSceneRef:
sceneWithURL:
sceneWithURL:atIndex:options:
sceneWithURL:options:
sceneWithURL:options:error:
scheduledTimerWithTimeInterval:repeats:block:
scheme
scn_C3DColorIgnoringColorSpace:success:
scn_backingLayer
scn_colorComponentsForModelIO
scn_colorWithC3DColor:
scn_colorWithLinearDisplayP3Red:green:blue:alpha:
scn_colorWithLinearSRGBRed:green:blue:alpha:
scn_colorWithModelIORed:green:blue:alpha:options:
scn_compressedDataUsingCompressionAlgorithm:
scn_decodeArrayOfObjectsOfClass:containingNestedContainersForKey:
scn_decodeArrayOfObjectsOfClass:forKey:
scn_decodeArrayOfObjectsOfClasses:containingNestedContainersForKey:
scn_decodeArrayOfObjectsOfClasses:forKey:
scn_decodeDictionaryWithKeysOfClass:objectsOfClass:containingNestedContainersForKey:
scn_decodeDictionaryWithKeysOfClass:objectsOfClass:forKey:
scn_decodeDictionaryWithKeysOfClasses:objectsOfClasses:containingNestedContainersForKey:
scn_decodeDictionaryWithKeysOfClasses:objectsOfClasses:forKey:
scn_enumerateKeysAndValuesUsingBlock:
scn_inLiveResize
scn_indexedDataDecodingDeltaWithBytesPerIndex:
scn_indexedDataDecodingHighWatermarkWithBytesPerIndex:
scn_indexedDataDecodingTrianglePairsWithBytesPerIndex:
scn_indexedDataEncodingDeltaWithBytesPerIndex:
scn_indexedDataEncodingHighWatermarkWithBytesPerIndex:
scn_indexedDataEncodingTrianglePairsWithBytesPerIndex:
scn_setBackingLayer:
scn_stringByReplacingCharactersInRanges:withStrings:
scn_uncompressedDataUsingCompressionAlgorithm:
scope
screen
screenSize
screenSpace
screenSpaceAdaptiveTessellationDrawMeshElement:forMesh:instanceCount:renderContext:
screenSpaceAmbientOcclusionDepthThreshold
screenSpaceAmbientOcclusionDownSample
screenSpaceAmbientOcclusionIntensity
screenSpaceAmbientOcclusionNormalThreshold
screenSpaceAmbientOcclusionRadius
screenSpaceAmbientOcclusionSampleCount
screenSpaceRadius
screenSpaceReflectionDepthThreshold
screenSpaceReflectionMaximumDistance
screenSpaceReflectionSampleCount
screenSpaceReflectionStride
scrollPoint:
scrollRowToVisible:
scrollWheel:
seed
seekSlider
seekStep
seekStepper
segmentCount
selectAuthoringDisplayMask:
selectCamera:
selectInstance:propertyName:
selectItemAtIndex:
selectNode:
selectNodes:
selectPass:
selectPointOfCulling:
selectRenderingDebugOptions:
selectRowIndexes:byExtendingSelection:
selectTarget:
selectedItem
selectedItems
selectedNode
selectedNodes
selectedRow
selecting
selection
selectionDidChange:
selectionIsReadonly
selectionShouldChangeInOutlineView:
selectionWillChange
self
selfIllumination
selfIlluminationOcclusion
semantic
semanticForSymbol:
semanticsCount
sendAction:to:
sensorAspect
sensorHeight
sensorVerticalAperture
sequence:
sequenceWithActions:
setAcceleration:
setAccessibilityDescription:
setAction:
setActive:
setAdaptativeFrameRate:
setAdaptive:
setAdditive:
setAdjustsShadowProjection:
setAffectedByGravity:
setAffectedByPhysicsFields:
setAlignment:
setAlignmentMode:
setAllTargetsFromAnimCodec:
setAllowedFileTypes:
setAllowsBrowsing:
setAllowsCameraControl:
setAllowsCreation:
setAllowsResting:
setAllowsTickMarkValuesOnly:
setAllowsTranslation:
setAlphaBlendOperation:
setAlternateMode:
setAlternateTitle:
setAnchorA:
setAnchorB:
setAngularDamping:
setAngularRestingThreshold:
setAngularSleepingThreshold:
setAngularVelocity:
setAngularVelocityFactor:
setAnimation:
setAnimationDidStart:
setAnimationDidStop:
setAnimationDuration:
setAnimationEvents:
setAnimationSpeed:
setAnimationTimingFunction:
setAnimations:
setAntialiasingLevel:
setAntialiasingMode:
setAperture:
setApertureBladeCount:
setAppliedOnCompletion:
setAreaPolygonVertices:
setAreaType:
setArgument:
setArgument:atIndex:
setArgumentBuffer:offset:
setArgumentEncoder:
setArguments:
setAssetCatalog:
setAsynchronous:
setAsynchronousLoading:
setAsynchronousResizing:
setAttachment:
setAttenuationEndDistance:
setAttenuationFalloffExponent:
setAttenuationStartDistance:
setAttribute:forKey:
setAttributedTitle:
setAttributes:
setAudioListener:
setAuthoringCamera:forView:
setAuthoringCameraType:
setAuthoringDisplayMask:
setAuthoringEnvironmentCompanionNode:
setAuthoringEnvironmentNode:
setAuthoringEnvironmentPresentationNode:
setAutoAdjustCamera:
setAutoSwitchToFreeCamera:
setAutoenablesDefaultLighting:
setAutoenablesItems:
setAutomaticCameraTarget:
setAutomaticTarget:
setAutomaticallyAdjustsShadowProjection:
setAutomaticallyAdjustsVideoMirroring:
setAutomaticallyAdjustsZRange:
setAutoresizingMask:
setAutoreverses:
setAvPlayer:
setAvoidsOverLighting:
setAxisA:
setAxisB:
setAxle:
setBackgroundColor:
setBackgroundGPUPriority:
setBackingScaleFactor:
setBaked:
setBaseGeometry:
setBaseGeometryBindTransform:
setBeginTime:
setBezelStyle:
setBias:
setBiasValues:
setBindBlock:
setBirthDirection:
setBirthLocation:
setBirthRate:
setBirthRateVariation:
setBlackPassEnabled:
setBlendColorRed:green:blue:alpha:
setBlendInDuration:
setBlendMode:
setBlendOutDuration:
setBlendingEnabled:
setBlock:
setBloomBlurRadius:
setBloomIntensity:
setBloomIteration:
setBloomIterationCount:
setBloomIterationSpread:
setBloomThreshold:
setBoneInverseBindTransforms:
setBones:
setBoolValue:
setBordered:
setBottomRadius:
setBoundingBoxMin:max:
setBounds:
setBoxType:
setBrightness:
setBuffer:
setBuffer:offset:atIndex:
setBufferOffset:atIndex:
setBufferSize:
setBuffers:offsets:withRange:
setButtonType:
setByAddingObject:
setByAddingObjectsFromArray:
setByAddingObjectsFromSet:
setByValue:
setBytes:length:atIndex:
setC3dAnimation:
setCGLContextObj:
setCalculationMode:
setCamera:
setCameraTarget:
setCanDrawConcurrently:
setCanceled:
setCapRadius:
setCapSegmentCount:
setCaptureDevice:
setCaptureDeviceOutputConsumerSource:
setCategoryBitMask:
setCenter:
setCenterOfMassOffset:
setChainRootNode:
setChamferProfile:
setChamferRadius:
setChamferSegmentCount:
setChannelTargetCounts:
setChannelTargetWeights:
setCharge:
setClass:forClassName:
setClearColor:
setClearDepth:
setClipsToBounds:
setColliderNodes:
setCollisionBitMask:
setCollisionCategoryBitMask:
setColor:
setColorBufferWriteMask:
setColorFringeIntensity:
setColorFringeStrength:
setColorSpace:
setColorspace:
setCommitsOnCompletion:
setCompleted:
setCompletedUnitCount:
setCompletionBlock:
setComponent:
setComputeFunction:
setComputePipelineState:
setConnectionPosition:
setConnectionWithTargetPaths:
setConstantToString:
setConstantValue:type:atIndex:
setConstraintRef:
setContactDelegate:
setContactTestBitMask:
setContainerFrame:
setContent:
setContents:
setContentsScale:
setContentsTransform:
setContext:
setContinuityValues:
setContinuousCollisionDetectionThreshold:
setContrast:
setController:
setCornerRadius:
setCornerSegmentCount:
setCppAction:
setCpuCacheMode:
setCullMode:
setCumulative:
setCurrentContext:
setCurrrentPass:
setDamping:
setDampingFactor:
setDataSource:
setDebugOptions:
setDecelerationDistance:
setDecodingFailurePolicy:
setDefaults
setDelegate:
setDepth:
setDepthAttachment:
setDepthAttachmentPixelFormat:
setDepthBias:slopeScale:clamp:
setDepthClipMode:
setDepthCompareFunction:
setDepthFailureOperation:
setDepthResolveFilter:
setDepthStencilPassOperation:
setDepthStencilState:
setDepthWriteEnabled:
setDestinationRGBBlendFactor:
setDevice:
setDictionaryMetadataWithKey:dictionaryKey:value:
setDidEndSelector:
setDidFinishPlayback:
setDirection:
setDisableActions:
setDisableOverlays:
setDiscretizedStraightLineMaxLength:
setDisplaysWhenScreenProfileChanges:
setDofIntensity:
setDouble3Value:
setDouble4x4Array:count:
setDouble4x4Value:
setDouble4x4Value:atTime:
setDoubleAction:
setDrawableResizesAsynchronously:
setDrawableSize:
setDrawsArea:
setDrivenByDefaultNavigationCameraController:
setDuration:
setDurationRange:
setEdgeCreasesElement:
setEdgeCreasesSource:
setEdgeTessellationFactor:
setEditable:
setEditingModeEnabled:
setEditingSpace:
setElementIndex:
setEmissionDuration:
setEmissionDurationVariation:
setEmitterShape:
setEmittingDirection:
setEnableFreeCamera:
setEnableInertia:
setEnabled:
setEndTime:
setEngineNotificationQueue:
setEntity:
setError:
setErrorOptions:
setEuler:
setEventBlock:
setEventHandler:
setException:
setExclusive:
setExecutionHandler:
setExpectsMediaDataInRealTime:
setExposure:
setExposureAdaptationBrighteningSpeedFactor:
setExposureAdaptationDarkeningSpeedFactor:
setExposureAdaptationDuration:
setExposureAdaptationHistogramRangeHighProbability:
setExposureAdaptationHistogramRangeLowProbability:
setExposureAdaptationMode:
setExposureOffset:
setExtrusionDepth:
setFStop:
setFaceCount:
setFaceTopology:
setFadeInDuration:
setFadeOutDuration:
setFalloffExponent:
setFarVisibilityDistance:
setFastMathEnabled:
setFeatures:
setFieldOfViewOrientation:
setFillMode:
setFillsBackward:
setFillsForward:
setFilterChannel:
setFilters:
setFinished:
setFirstMaterial:
setFixedTimeStep:
setFlatness:
setFloat2Array:count:
setFloat3Array:count:
setFloat3Array:count:atTime:
setFloat3Value:atTime:
setFloatArray:count:
setFloatArray:count:atTime:
setFloatValue:
setFloatValue:atTime:
setFlyModeVelocity:
setFocalBlurRadius:
setFocalBlurSampleCount:
setFocalDistance:
setFocalSize:
setFocusBehavior:
setFocusDistance:
setFogColor:
setFogDensityExponent:
setFogEndDistance:
setFogStartDistance:
setFont:
setForceBackFaceCasters:
setForcesBackFaceCasters:
setFormat:
setFormatter:
setFragmentBuffer:offset:atIndex:
setFragmentBufferOffset:atIndex:
setFragmentBytes:length:atIndex:
setFragmentFunction:
setFragmentFunctionName:
setFragmentLinkedFunctions:
setFragmentSamplerState:atIndex:
setFragmentShader:
setFragmentTexture:atIndex:
setFragmentTextures:withRange:
setFrame:
setFrameA:
setFrameB:
setFrameBufferBindings:
setFrameRate:
setFrameSize:
setFramebufferOnly:
setFreeAxes:
setFrequency:
setFresnelExponent:
setFriction:
setFrictionSlip:
setFromValue:
setFrontFacingWinding:
setFrozen:
setGamma:
setGeodesic:
setGeometry:
setGeometryModificationCount:
setGeometryShader:
setGimbalLockEnabled:
setGimbalLockMode:
setGimbalLockVector:
setGizmo:
setGlID:
setGlTextureCache:
setGlobalGLSharedContext:
setGlobalMetalDevice:
setGrainIntensity:
setGrainIsColored:
setGrainScale:
setGrainSlice:
setGrainTexture:
setGraphicalSelectionEnabled:
setGravity:
setHalfExtent:
setHeight:
setHeightSegmentCount:
setHidden:
setHittable:
setHorizonElevation:
setHorizontalMaximumAngle:
setIESProfileURL:
setIESProfileURL:resolvedURL:
setIbPreferredRenderingAPI:
setIbWantsMultisampling:
setIdentifier:
setIdleDuration:
setIdleDurationVariation:
setImage:
setImageFrameStyle:
setImageSequenceAnimationMode:
setImageSequenceColumnCount:
setImageSequenceFrameRate:
setImageSequenceFrameRateVariation:
setImageSequenceInitialFrame:
setImageSequenceInitialFrameVariation:
setImageSequenceRowCount:
setImmediateMode:
setImmediateModeRestrictedContext:
setIndexOfRefraction:
setInertiaEnabled:
setInertiaFriction:
setInfluenceFactor:
setInitializationHandler:
setInnerConeAngle:
setInputBias:
setInputMode:
setInputPrimitiveTopology:
setInputProperty:
setInputScale:
setInsideTessellationFactor:
setInstance:
setIntArray:count:
setIntensity:
setInteractionMode:
setInterruptionHandler:
setInvalidationHandler:
setIrradianceData:
setIsFront:
setIsJoint:
setIsLocal:
setItem:
setJitteringEnabled:
setJoint:
setJumpSpeed:
setKeepTargetDirection:
setKeyCodeConfiguration:
setKeyPath:
setKeyPathDst:
setKeyPathSrc:
setKeyTimes:
setLabel:
setLanguageVersion:
setLastFrameTime:
setLaunchPath:
setLayer:
setLayerContentsPlacement:
setLength:
setLengthSegmentCount:
setLensShift:
setLevel:
setLevelsOfDetail:
setLibrary:
setLibraryProvider:
setLight:
setLightBufferBindings:
setLightEmissionRadiusFactor:
setLightType:
setLightingEnabled:
setLightingModelName:
setLineBreakMode:
setLinearRestingThreshold:
setLinearSleepingThreshold:
setLoadAction:
setLoadingPolicy:
setLocal:
setLocalFront:
setLocksAmbientWithDiffuse:
setLookUpFoundInstance:
setLookUpKey:
setLoops:
setMTLTextureCache:
setMagFilter:
setMagnificationFilter:
setMappingChannel:
setMass:
setMaterial:
setMaterialFace:
setMaterialModificationCount:
setMaterials:
setMatrix4:
setMatrix:
setMaxAllowedRotationAngle:
setMaxAllowedRotationAngle:forJoint:
setMaxAnisotropy:
setMaxTessellationFactor:
setMaxValue:
setMaximumAngularLimit1:
setMaximumAngularLimit2:
setMaximumAngularLimit:
setMaximumCircleOfConfusion:
setMaximumDistance:
setMaximumEdgeLength:
setMaximumExposure:
setMaximumHorizontalAngle:
setMaximumLinearAcceleration:
setMaximumLinearLimit:
setMaximumLinearVelocity:
setMaximumPointScreenSpaceRadius:
setMaximumShadowDistance:
setMaximumSuspensionForce:
setMaximumSuspensionTravel:
setMaximumTwistAngle:
setMaximumVerticalAngle:
setMetadataWithKey:value:
setMinFilter:
setMinificationFilter:
setMinimumAngularLimit:
setMinimumDistance:
setMinimumExposure:
setMinimumHorizontalAngle:
setMinimumLanguageVersion:
setMinimumLinearLimit:
setMinimumPointScreenSpaceRadius:
setMinimumVerticalAngle:
setMipFilter:
setMipmapLevelCount:
setMkSemantic:
setMlDelegate:
setMomentOfInertia:
setMorpher:
setMotionBlurIntensity:
setMotorMaximumForce:
setMotorMaximumTorque:
setMotorTargetAngularVelocity:
setMotorTargetLinearVelocity:
setMovabilityHint:
setMovableByWindowBackground:
setMtlTexture:
setName:
setNameFieldStringValue:
setNavigationCameraController:
setNearVisibilityDistance:
setNeedsDisplay:
setNeedsDisplayOnBoundsChange:
setNeedsRenderResource:
setNext:
setNode:
setNodeBufferBindings:
setNodeRef:
setNumberOfTickMarks:
setObject:atIndexedSubscript:
setObject:forKey:
setObject:forKeyedSubscript:
setObjectController:
setObjectPath:
setObjectPathArray:
setOccluderCategoryBitMask:
setOffset:
setOpacity:
setOpaque:
setOpenGLContext:
setOptions:
setOrientationDirection:
setOrientationMode:
setOrientationOffset:
setOrthographicScale:
setOuterConeAngle:
setOutgoingPointOfView:
setOutgoingScene:
setOutputURL:
setOverlaySKScene:
setOverride:forKeyPath:
setOverrides:
setOwnerWithIdentity:
setPanSensitivity:
setParallaxCenterOffset:
setParallaxCorrectionEnabled:
setParallaxExtentsFactor:
setParentView:
setParticleAngle:
setParticleAngleVariation:
setParticleAngularVelocity:
setParticleAngularVelocityVariation:
setParticleBounce:
setParticleBounceVariation:
setParticleCharge:
setParticleChargeVariation:
setParticleColor:
setParticleColorVariation:
setParticleDiesOnCollision:
setParticleFriction:
setParticleFrictionVariation:
setParticleGeometries:
setParticleImage:
setParticleIntensity:
setParticleIntensityVariation:
setParticleLifeSpan:
setParticleLifeSpanVariation:
setParticleMass:
setParticleMassVariation:
setParticleSize:
setParticleSizeVariation:
setParticleVelocity:
setParticleVelocityVariation:
setPassBufferBindings:
setPassDescriptor:
setPath:
setPathItems:
setPaused:
setPaused:nextFrameTimeHint:lastUpdate:
setPausedForEditing:
setPhysicsCollisionsEnabled:
setPhysicsField:
setPhysicsShape:
setPipeRadius:
setPipeSegmentCount:
setPivot:
setPixelBuffer:fromDevice:
setPlaybackSpeed:
setPlayer:
setPlaying:
setPointOfCulling:
setPointOfView:animate:
setPointOfView:updateUpTransform:
setPointSize:
setPosition:
setPositionOffset:
setPositional:
setPostMorphingDeformers:
setPostProjectionTransform:
setPostProjectionTransformScale:
setPostProjectionTransformTranslation:
setPostSkinningDeformers:
setPrecomputedLightingEnvironment:
setPreferredFrameRate:
setPreferredFramesPerSecond:
setPrefersOpenGL:
setPreprocessorMacros:
setPreserveScale:
setPrimitiveRange:
setPrimitiveRanges:
setPrimitiveType:
setPrivateFunctions:
setProbeExtents:
setProbeType:
setProbeUpdateType:
setProceduralContents:
setProgram:
setProgress:
setProjection:
setProjectionDirection:
setProjectionMatrix:
setProjectionTransform:
setPropertyControllers:
setPurgeableState:
setQuaternion:
setQuatfArray:count:atTime:
setQuatfValue:
setQuatfValue:atTime:
setQuery:
setRAddressMode:
setRadialSegmentCount:
setRadialSpan:
setRadianceData:
setRadius:
setRasterSampleCount:
setRasterizationRateMap:
setRate:
setReadMask:
setReadonly:
setReadsFromDepthBuffer:
setReferenceCount:
setReferenceName:
setReferenceNodeName:
setReferenceObject:
setReferenceSceneName:
setReferenceURL:
setReflectionCategoryBitMask:
setReflectionFallOffEnd:
setReflectionFallOffStart:
setReflectionFalloffEnd:
setReflectionFalloffStart:
setReflectionResolutionScaleFactor:
setReflectionSampleCount:
setReflectivity:
setRemoteObjectInterface:
setRemove:
setRemoveButton:
setRemovedOnCompletion:
setRenderPipelineState:
setRenderTargetArrayLength:
setRenderer:
setRendererDelegate:
setRenderingMode:
setRenderingOrder:
setRendersContinuously:
setRendersIntoMaterial:
setRepeatDuration:
setReplicatesOrientation:
setReplicatesPosition:
setReplicatesScale:
setRepresentedObject:
setRequiresSecureCoding:
setResolveSlice:
setResolveTexture:
setResource:ofType:atIndices:
setResourceOptions:
setResourcePath:
setResting:
setRgbBlendOperation:
setRingRadius:
setRingSegmentCount:
setRollingFriction:
setRootNode:
setRootNode:forLayer:
setRotation:
setRotationSensitivity:
setSAddressMode:
setSCNView:
setSampleBuffer:
setSampleBuffer:fromDevice:
setSampleBufferDelegate:queue:
setSamplerState:atIndex:
setSaturation:
setScale:
setScene:
setScene:completionHandler:
setSceneTime:
setScissorRects:count:
setScope:
setScreenSize:
setScreenSpaceAmbientOcclusionBias:
setScreenSpaceAmbientOcclusionDepthThreshold:
setScreenSpaceAmbientOcclusionDownSample:
setScreenSpaceAmbientOcclusionIntensity:
setScreenSpaceAmbientOcclusionNormalThreshold:
setScreenSpaceAmbientOcclusionRadius:
setScreenSpaceAmbientOcclusionSampleCount:
setScreenSpaceReflectionDepthThreshold:
setScreenSpaceReflectionMaximumDistance:
setScreenSpaceReflectionSampleCount:
setSeed:
setSeekStep:
setSegmentCount:
setSelected:forSegment:
setSelecting:
setSelectionIsReadonly:
setSelector:
setSelfIlluminationOcclusion:
setSemantic:
setSemantic:forSymbol:
setSemantic:forSymbol:options:
setSemanticInfos:
setSemanticsCount:
setSensorAspect:
setSensorHeight:
setSensorVerticalAperture:
setShadableBufferBindings:
setShaderModifiers:
setShadowBias:
setShadowCascadeCount:
setShadowCascadeSplittingFactor:
setShadowMapSize:
setShadowMode:
setShadowRadius:
setShadowSampleCount:
setShininess:
setShouldBakeDirectLighting:
setShouldBakeIndirectLighting:
setShouldClearCPUDataAfterUpload:
setShouldMaximizeConcurrentCompilation:
setShouldMorphNormals:
setShouldSnapOnGrid:
setShouldSnapToAlign:
setShouldStream:
setShowsAlpha:
setShowsStatistics:
setSimdEulerAngles:
setSimdOrientation:
setSimdPivot:
setSimdPosition:
setSimdProjectionMatrix:
setSimdRotation:
setSimdScale:
setSimdTarget:
setSimdTransform:
setSimdUp:
setSimdViewMatrix:
setSimdWorldOrientation:
setSimdWorldPosition:
setSimdWorldTransform:
setSize:
setSkScene:
setSkTexture:
setSkeleton:
setSkinner:
setSkipFramesIfNoDrawableAvailable:
setSkipMorphTargets:
setSlice:
setSmoothingMode:
setSmoothness:
setSoftParticlesEnabled:
setSourceAlphaBlendFactor:
setSourceContext:
setSourceFile:
setSourceObject:
setSourceRGBBlendFactor:
setSpeed:
setSpeed:forAnimationKey:
setSphericalHarmonicsCoefficients:
setSpotFalloffExponent:
setSpotInnerAngle:
setSpotOuterAngle:
setSpreadingAngle:
setStackControl:
setStageInRegion:
setStageInputDescriptor:
setStageInputOutputBuffersToComputeEncoder:
setStageInputOutputBuffersToCurrentComputeEncoder
setStageInputOutputBuffersToEncoder:
setStartDelay:
setStartTime:
setState:
setSteeringAngle:forWheelAtIndex:
setSteeringAxis:
setStencilAttachment:
setStencilAttachmentPixelFormat:
setStencilCompareFunction:
setStencilFailureOperation:
setStencilReferenceValue:
setStencilResolveFilter:
setStepFunction:
setStepRate:
setStickyAxis:
setStrength:
setStretchFactor:
setStride:
setString:
setSubdivisionLevel:
setSucceded:
setSuperSampling:
setSurroundToSelect:
setSuspensionCompression:
setSuspensionDamping:
setSuspensionRestLength:
setSuspensionStiffness:
setSwizzle:
setSyncTimeWithCoreAnimation:
setSystemSpawnedOnCollision:
setSystemSpawnedOnDying:
setSystemSpawnedOnLiving:
setTAddressMode:
setTable:
setTarget:
setTargetDirection:
setTargetOffset:
setTargetPosition:
setTargets:
setTargets:withInBetweenTargetCounts:inBetweenWeights:
setTargetsAndInBetweens:inBetweenCounts:inBetweenWeights:correctives:driverCounts:driverIndices:inBetweenCounts:inBetweenWeights:
setTechnique:
setTensionValues:
setTessellationControlPointIndexType:
setTessellationControlShader:
setTessellationEvaluationShader:
setTessellationFactorBuffer:offset:instanceStride:
setTessellationFactorFormat:
setTessellationFactorScale:
setTessellationFactorScaleEnabled:
setTessellationFactorStepFunction:
setTessellationOutputWindingOrder:
setTessellationPartitionMode:
setTexture:
setTexture:atIndex:
setTextureComponents:
setTextureProvider:
setTextureSamplerValue:
setTextures:withRange:
setThreadGroupSizeIsMultipleOfThreadExecutionWidth:
setThreadgroupMemoryLength:atIndex:
setTime:
setTimeOffset:
setTimeStamp:
setTimeStep:
setTimestamp:
setTimingFunction:
setTimingFunctions:
setTimingMode:
setTitle:
setToValue:
setTokenArray:
setTokenValue:
setToolTip:
setTopRadius:
setTransform:
setTransition:
setTransitionStartTime:
setTransparency:
setTransparencyMode:
setTriangleFillMode:
setTruckSensitivity:
setTruncationMode:
setType:
setURLValue:
setUnifiesNormals:
setUp:
setUpAxis:
setUpVector:
setUsage:
setUsedCount:
setUserInfo:
setUsesDefaultMomentOfInertia:
setUsesDeferredShadows:
setUsesDepthPrePass:
setUsesEllipsoidalExtent:
setUsesEuler:
setUsesModulatedMode:
setUsesOrthographicProjection:
setUsesReverseZ:
setUsesSceneTimeBase:
setValue:
setValue:forKey:
setValue:forKeyPath:
setValue:forPassPropertyKey:
setValue:forProperty:
setValue:forSymbolNamed:
setValue:forUndefinedKey:
setValueForKey:optionKey:options:
setValueTransformer:forName:
setValues:
setValues:forParameter:
setVector2:
setVector3:
setVector4:
setVelocity:
setVelocityFactor:
setVertexAmplificationCount:viewMappings:
setVertexAmplificationEnabled:
setVertexBufferOffset:atIndex:
setVertexBuffers:offsets:withRange:
setVertexDescriptor:
setVertexFunction:
setVertexFunctionName:
setVertexLinkedFunctions:
setVertexSamplerState:atIndex:
setVertexShader:
setVertexTexture:atIndex:
setVertexTextures:withRange:
setVerticalMaximumAngle:
setVideoMirrored:
setVideoSettings:
setView:
setViewMatrix:
setViewport:
setViewports:count:
setVignettingIntensity:
setVignettingPower:
setVolume:
setWalkingDirection:
setWantsAdaptiveSubdivision:
setWantsBestResolutionOpenGLSurface:
setWantsDepthOfField:
setWantsExposureAdaptation:
setWantsHDR:
setWantsLayer:
setWantsScreenSpaceReflection:
setWarmupDuration:
setWeakRef:
setWeight:
setWeight:atTargetIndex:
setWeight:forTargetAtIndex:
setWeight:forTargetNamed:
setWeightIncrementalThreshold:
setWeights:
setWhiteBalanceTemperature:
setWhiteBalanceTint:
setWhitePoint:
setWidth:
setWidthSegmentCount:
setWillStartPlayback:
setWithArray:
setWithCapacity:
setWithObject:
setWithSet:
setWorldOrientation:
setWorldPosition:
setWorldTransform:
setWorldUp:
setWrapS:
setWrapT:
setWrapped:
setWriteMask:
setWritesToDepthBuffer:
setXAlignment:
setXFov:
setXMag:
setYAlignment:
setYFov:
setYMag:
setZAlignment:
setZFar:
setZNear:
setZoomFactor:
set_allowsDefaultLightingEnvironmentFallback:
set_antialiasingMode:
set_aspectRatio:
set_collectCompilationErrors:
set_computedLightingEnvironmentMapsPath:
set_deltaTime:
set_disableLinearRendering:
set_drawableSafeAreaInsets:
set_encodeDataAsHalf:
set_ibPreferredRenderingAPI:
set_ibSceneName:
set_ibWantsMultisampling:
set_nextFrameTime:
set_preparePixelFormat:
set_recordWithoutExecute:
set_renderOptions:
set_resourceManagerMonitor:
set_screenTransform:
set_shadowCascadeDebugFactor:
set_shouldForwardSceneRendererDelegationMessagesToPrivateRendererOwner:
set_showsAuthoringEnvironment:
set_sphericalHarmonics:
set_subdivisionSettings:
set_superSamplingFactor:
set_viewport:
set_wantsSceneRendererDelegationMessages:
set_wantsSeparateGeometryElements:
settingsForTransition:atTime:renderIncomingToTexture:renderOutgoingToTexture:renderIncomingToScreen:renderOutgoingToScreen:
setup
setupAuthoringEnv2
setupAuthoringEnvironment
setupClones
setupDisplayLinkOutputHandler:
setupFinalMeshFromBaseMeshWithInfo:
setupFinalMeshFromMeshlessBaseGeometryWithInfo:
setupInitialBuffersWithBasePositionSourceProvider:baseNormalSourceProvider:baseTangentSourceProvider:info:
setupMorphTargetsWithComputeContext:
setupNode
setupParticleMeshEmitter:authoringNode:
setupWithActions:
setupWithComputeContext:
shFromCPU:commandBuffer:
shadable
shadableBufferBindings
shaderCompilationGroup
shaderModifiersArgumentsNames
shadowBias
shadowCascadeCount
shadowCascadeSplittingFactor
shadowColor
shadowMapSize
shadowMode
shadowRadius
shadowSampleCount
shapeSetTargetCounts
shapeSetTargetWeights
shapeWithGeometry:options:
shapeWithNode:options:
shapeWithPath:extrusionDepth:
shapeWithShapes:transforms:
shareable
sharedColorPanel
sharedRegistry
shininess
shortValue
shouldBakeDirectLighting
shouldBakeIndirectLighting
shouldClearCPUDataAfterUpload
shouldFlip
shouldMaximizeConcurrentCompilation
shouldMorphNormals
shouldObserveApplicationStateToPreventBackgroundGPUAccess
shouldSnapOnGrid
shouldSnapToAlign
shouldStream
showManipulators
showModelInspector:
simdConvertPosition:fromNode:
simdConvertPosition:toNode:
simdConvertTransform:fromNode:
simdConvertTransform:toNode:
simdConvertVector:fromNode:
simdConvertVector:toNode:
simdGetBoundingSphereCenter:radius:
simdLocalCoordinates
simdLocalFront
simdLocalRight
simdLocalRotateBy:
simdLocalTranslateBy:
simdLocalUp
simdLookAt:
simdLookAt:up:localFront:
simdModelTransform
simdPivot
simdPosition
simdProjectionMatrix
simdRotateBy:aroundTarget:
simdRotation
simdScale
simdTarget
simdTransform
simdUp
simdViewMatrix
simdWorldCoordinates
simdWorldFront
simdWorldOrientation
simdWorldPosition
simdWorldRight
simdWorldTransform
simdWorldUp
size
sizeValue
skTexture
skeleton
skinnerRef
skinnerWithBaseGeometry:bones:boneInverseBindTransforms:boneWeights:boneIndices:
skinnerWithSkinnerRef:
skipExecute
skipMorphTargets
sliderConstraint
slotName
smoothingMode
smoothness
snapGuideIndexesOnAxis:
snapInfoAtIndex:axis:
snapshot
snapshotAtTime:withSize:antialiasingMode:
snapshotAtTime:withSize:antialiasingMode:error:
snapshotRendererWithSize:
softParticlesEnabled
sortUsingComparator:
sortedArrayUsingComparator:
sortedArrayUsingSelector:
sortingMode
sourceContext
sourceFile
sourceObject
sourceRendererForEngineContext:source:textureSource:targetTexture:
sourceStatus
sparseTileSizeInBytes
sparseTileSizeInBytesForSparsePageSize:
sparseTileSizeWithTextureType:pixelFormat:sampleCount:
sparseTileSizeWithTextureType:pixelFormat:sampleCount:sparsePageSize:
specular
specularDFGDiffuseHammonTextureWithRenderContext:
speed
speedFactor
speedInKilometersPerHour
sphereWithRadius:
sphereWithRadius:options:
sphericalHarmonicsCoefficients
sphericalHarmonicsForEnvironmentTexture:order:commandBuffer:
splitInputOutputStructsIfNeededForSourceCode:generatedFromReplacementStrings:perPixelLighting:clipDistanceCount:
spotFalloffExponent
spotInnerAngle
spotOuterAngle
spreadingAngle
springField
srcPositionBuffer
srcTangentBuffer
stackControl
stackSelectionChanged:
stageInputAttributes
stageInputDescriptor
standardUserDefaults
startCollectingPerformanceStatisticsForPid:
startDelay
startRunning
startSessionAtSourceTime:
startTime
startWriting
state
staticBody
status
steeringAxis
stencilAttachment
stencilPixelFormat
stepFunction
stepRate
stickyAxis
stiffness
stop
stop:
stopCollectingPerformanceStatisticsForPid:
stopIfNeeded
stopInertia
stopRunning
stopWithBlendOutDuration:
stopWithFadeOutDuration:
storageMode
storeAction
streamForEntryName:
strength
stretchFactor
stride
string
stringByAppendingFormat:
stringByAppendingString:
stringByDeletingLastPathComponent
stringByDeletingPathExtension
stringByExpandingTildeInPath
stringByReplacingCharactersInRange:withString:
stringByReplacingMatchesInString:options:range:withTemplate:
stringByReplacingOccurrencesOfString:withString:
stringByStandardizingPath
stringValue
stringWithCString:encoding:
stringWithCapacity:
stringWithContentsOfFile:encoding:error:
stringWithContentsOfURL:encoding:error:
stringWithFormat:
stringWithString:
stringWithUTF8String:
strongToStrongObjectsMapTable
structType
subAnimations
subarrayWithRange:
subdataWithRange:
subdivisionLevel
subdivisionScheme
subdivisionSurfaceTessellationDraw:
sublayers
submeshWithSCNGeometryElement:
submeshWithSCNGeometryElement:bufferAllocator:
submeshWithSCNGeometryElement:bufferAllocator:positionSourceChannel:
submeshWithUniquedIndexData:andSCNGeometryElement:bufferAllocator:
submeshes
substringFromIndex:
substringToIndex:
substringWithRange:
subviews
succeded
sunElevation
superclass
supportedFileUTIsForExport
supportedFileUTIsForImport
supportedOutputs
supports32BitFloatFiltering
supports32BitMSAA
supportsBCTextureCompression
supportsBaseVertexInstanceDrawing
supportsCounterSampling:
supportsDepthClipMode
supportsDirection
supportsDynamicLibraries
supportsFeatureSet:
supportsFunctionPointers
supportsFunctionPointersFromRender
supportsLayeredRendering
supportsMSAADepthResolve
supportsMSAAStencilResolve
supportsMetal
supportsNonUniformThreadgroupSize
supportsOffset
supportsPrimitiveMotionBlur
supportsPullModelInterpolation
supportsQueryTextureLOD
supportsRasterizationRateMapWithLayerCount:
supportsRaytracing
supportsRaytracingFromRender
supportsReadWriteTextureCubeArguments
supportsRenderDynamicLibraries
supportsSecureCoding
supportsShaderBarycentricCoordinates
supportsTessellation
supportsTextureCubeArray
supportsTextureSampleCount:
supportsTextureSwizzle
supportsUnalignedVertexFetch
supportsVertexAmplificationCount:
surroundToSelect
suspensionCompression
suspensionDamping
suspensionRestLength
suspensionStiffness
sweepTestFraction
switchToCameraNamed:
switchToNextCamera
syncTimeWithCoreAnimation
systemFontOfSize:
systemFontSizeForControlSize:
systemSpawnedOnCollision
systemSpawnedOnDying
systemSpawnedOnLiving
tWrapMode
table
tableColumns
target
targetOffset
targetPosition
targetShapes
targetsAndInBetween
technique
techniqueBySequencingTechniques:
techniquePanelForView:
techniqueRef
techniqueWithDictionary:
techniqueWithTechniqueRef:
techniquesDidUpdate:
temperature
temporalAntialiasingEnabled
temporaryDirectory
tensionValues
tessellationControlShader
tessellationEvaluationShader
tessellationFactorScale
tessellationPartitionMode
tessellator
tessellatorValueDidChange
tessellatorValueDidChangeForClient:
text
textSize
textWithString:extrusionDepth:
texture2DDescriptorWithPixelFormat:width:height:mipmapped:
textureAtIndices:
textureComponents
textureCoordinate
textureCoordinatesWithMappingChannel:
textureCubeDescriptorWithPixelFormat:size:mipmapped:
textureForSliceIndex:
textureID
textureRect
textureSampler
textureSamplerValue
textureSize
textureSource
textureTarget
textureType
textureWithEngineContext:textureSampler:nextFrameTime:
textureWithName:scaleFactor:bundle:options:error:
threadDictionary
threadExecutionWidth
thresholdMode
thresholdValue
time
timeIntervalSinceReferenceDate
timeJumpWithTarget:timeOffset:
timeOffset
timeStamp
timeStep
timestamp
timingFunction
timingMode
title
toBool
toDouble
toString
toTransform3D
toVector3
toVector4
toggleRetina:
tokenWithString:
topRadius
topology
torusWithRingRadius:pipeRadius:options:
trackingAreas
tracksWithMediaCharacteristic:
transform
transformAnimation
transformConstraintInWorldSpace:withBlock:
transformedValue:
transformedValueClass
transforms
transition
transitionPass
transitionStartTime
translateByX:Y:Z:
translateInCameraSpaceByX:Y:Z:
translateInScreenSpaceTo:viewport:
translations
transparency
transparencyMode
transparent
truckSensitivity
truncationMode
tubeWithInnerRadius:outerRadius:height:
tubeWithInnerRadius:outerRadius:height:options:
turbidity
turbulenceFieldWithSmoothness:animationSpeed:
type
typeWithFilenameExtension:
typeWithIdentifier:
types
unarchiveObjectWithData:
unarchivedObjectOfClass:fromData:error:
unarchivedObjectOfClasses:fromData:error:
unarchiver:cannotDecodeObjectOfClassName:originalClasses:
unarchiver:didDecodeObject:
unarchiver:willReplaceObject:withObject:
unarchiverDidFinish:
unarchiverWillFinish:
unbind
unbindAnimatablePath:
unhide
unhighlightSelectedNode
unifiesNormals
uniformTessellationDrawMeshElement:forMesh:instanceCount:renderContext:
unload
unlock
unlockLayout
unregisterManagerForDevice:
unregisterPlayer:
unrolledWorldOrientation:
unsignedCharValue
unsignedIntValue
unsignedIntegerValue
unsignedLongValue
unsignedShortValue
unstageTexture:commandBuffer:
upAxis
upVector
update
updateAtTime:
updateBounds
updateBrowseScaleFactor
updateCameraNode:withSourceNode:
updateCollisionPairs
updateConstrainedEdgeLengthTessellator:parameters:
updateCurrentTimeIfPlayingWithSystemTime:
updateDependencyBuffersInBufferArray:forDeformer:
updateGlobalScale:
updateInertiaAtTime:
updateItemsPosition
updateItemsRotation:
updateItemsScale:
updateKeyboardStateAndRedrawIfNeeded:
updateLightTypeForNode:source:light:screenspaceScalingFactor:
updateManipulatorComponents
updateManipulatorNode
updateManipulatorPosition:
updateParticlesNode:withSourceNode:
updateProbes:atTime:
updateSceneGraph
updateScreenSpaceAdaptiveTessellator:parameters:
updateSeek
updateStackControl
updateSubdivisionSurfaceTessellator:parameters:
updateTargets
updateTexture
updateUniformTessellator:
updateWithComputeContext:buffers:
updateWithContext:
updateWithRenderer:
updateWithTarget:forTime:
upperAtmosphereScattering
usage
useLegacyFov
useOrbitInteractionMode
useResource:usage:
usedCount
usedResources
userAnimation
userInfo
usesDefaultMomentOfInertia
usesDeferredShadows
usesDepthPrePass
usesEllipsoidalExtent
usesEuler
usesMipmaps
usesModulatedMode
usesOrthographicProjection
usesReverseZ
usesSceneTimeBase
usesSeparateWorkGroup
validateAndCommitValueInEditor:editingIsEnding:errorUserInterfaceHandled:
validateClone
validateClones
value
valueForKey:
valueForKeyPath:
valueForPassPropertyKey:
valueForProperty:
valueForSymbolNamed:
valueForUndefinedKey:
valueWithBytes:objCType:
valueWithCATransform3D:
valueWithMatrix4:
valueWithObject:inContext:
valueWithPointer:
valueWithRect:
valueWithSCNMatrix4:
valueWithSCNVector3:
valueWithSCNVector4:
valueWithSize:
valueWithVector3:
valueWithVector3:inContext:
valueWithVector4:
valueWithVector4:inContext:
values
vectorCount
vectorWithValues:count:
vectorWithX:Y:Z:W:
vehicleWithChassisBody:wheels:
velocity
velocityFactor
vertexAmplificationEnabled
vertexAttributeDataForAttributeNamed:
vertexBuffers
vertexBuffersUsageMask
vertexCount
vertexCreaseCount
vertexCreaseIndices
vertexCreases
vertexDescriptor
vertexFunction
vertexFunctionName
vertexShader
verticalMaximumAngle
verticesCount
videoMirrored
view
viewDidDrawAtTime:
viewDidEndLiveResize
viewDidMoveToWindow
viewMatrix
viewWillDrawAtTime:
viewWillMoveToWindow:
viewWillStartLiveResize
viewedObjectSphere
viewport
viewportDependant
viewportMousePosition
vignettingIntensity
volatileOffset
volatileSize
volatileStride
volume
vortexField
waitForDuration:
waitForDuration:withRange:
waitForShadersCompilation
waitUntilCompleted
waitUntilExit
wantsAdaptiveSubdivision
wantsBestResolutionOpenGLSurface
wantsDepthOfField
wantsExposureAdaptation
wantsHDR
wantsLayer
wantsRedraw
wantsScreenSpaceReflection
warmupDuration
wasAddedToTarget:atTime:
wasPausedWithTarget:atTime:
wasRemovedFromTarget:atTime:
weakToStrongObjectsMapTable
weight
weightAtTargetIndex:
weightForTargetAtIndex:
weightForTargetNamed:
weightIncrementalThreshold
weightIndexStringForIndex:
wheelAtIndex:
wheelWithNode:
wheels
whiteBalanceTemperature
whiteBalanceTint
whiteColor
whitePoint
width
widthSegmentCount
willBeShown
willChangePointOfView
willChangeValueForKey:
willMoveFromView:
willResumeWithTarget:atTime:
willStartPlayback
willStartWithTarget:atTime:
window
windowChangedScreen:
windowWillClose:
workingColorSpace
worldCoordinates
worldFront
worldNormal
worldOrientation
worldPosition
worldRight
worldSpaceDistance
worldTransform
wrapS
wrapT
writeBytes:length:
writeContentsForEntryName:toFile:options:error:
writeImage:withSceneDocumentURL:originalImageURL:
writeToFile:atomically:
writeToFile:options:error:
writeToURL:
writeToURL:atomically:
writeToURL:atomically:encoding:error:
writeToURL:options:
writeToURL:options:delegate:progressHandler:
writeToURL:options:error:
writeToURLWithUSDKit:
writesToDepthBuffer
xAlignment
xFov
xMag
yAlignment
yFov
yMag
zAlignment
zFar
zNear
zone
zoomFactor
@16@0:8
@24@0:8@16
@40@0:8@16@24@?32
v48@0:8@16@24Q32@40
v48@0:8@16@24@32@?40
@44@0:8@16^{__C3DEngineContext=}24B32@36
@40@0:8@16^{__C3DEngineContext=}24@32
@36@0:8@16^{__C3DEngineContext=}24B32
@32@0:8@16@24
v44@0:8@16@24^{SCNMTLBlitCommandEncoder=@@}32B40
@32@0:8^{__C3DImage=}16B24i28
B48@0:8^{__C3DImage=}16@24@32i40B44
@44@0:8@16Q24^{__C3DEngineContext=}32B40
@44@0:8@16Q24@32B40
@40@0:8^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture}^v)b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}16^{__C3DEngineContext=}24^B32
@48@0:8^{__C3DImageProxy={__CFRuntimeBase=QAQ}{?=^?^?^?^?}^vC}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24^{__C3DEngineContext=}32^B40
@52@0:8^{__C3DImage=}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24i32^{__C3DEngineContext=}36^B44
v56@0:8@16^{CGColorSpace=}24^{CGColorSpace=}32@40@48
v92@0:8I16@20@28@36@44@52^{CGColorSpace=}60^{CGColorSpace=}68@76@84
v20@0:8i16
v16@0:8
v24@0:8@16
^{__C3DScene=}16@0:8
v48@0:8@16@24@32^v40
@"NSView"
[10@"NSView"]
@"SCNView"
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
q32@0:8@16@24
@40@0:8@16q24@32
B32@0:8@16@24
@40@0:8@16@24@32
v48@0:8@16@24@32@40
v32@0:8@16@24
v56@0:8@16@24{CGPoint=dd}32@48
v56@0:8@16@24{CGPoint=dd}32Q48
B40@0:8@16@24@32
Q48@0:8@16@24@32q40
B48@0:8@16@24@32q40
q32@0:8@"NSOutlineView"16@24
@40@0:8@"NSOutlineView"16q24@32
B32@0:8@"NSOutlineView"16@24
@40@0:8@"NSOutlineView"16@"NSTableColumn"24@32
v48@0:8@"NSOutlineView"16@24@"NSTableColumn"32@40
@32@0:8@"NSOutlineView"16@24
v32@0:8@"NSOutlineView"16@"NSArray"24
@"<NSPasteboardWriting>"32@0:8@"NSOutlineView"16@24
v56@0:8@"NSOutlineView"16@"NSDraggingSession"24{CGPoint=dd}32@"NSArray"48
v56@0:8@"NSOutlineView"16@"NSDraggingSession"24{CGPoint=dd}32Q48
B40@0:8@"NSOutlineView"16@"NSArray"24@"NSPasteboard"32
v32@0:8@"NSOutlineView"16@"<NSDraggingInfo>"24
Q48@0:8@"NSOutlineView"16@"<NSDraggingInfo>"24@32q40
B48@0:8@"NSOutlineView"16@"<NSDraggingInfo>"24@32q40
@"NSArray"40@0:8@"NSOutlineView"16@"NSURL"24@"NSArray"32
v40@0:8@16@24@32
B40@0:8@16@24:32
@64@0:8@16@24@32{_NSRange=QQ}40^q56
v24@0:8@"NSNotification"16
B32@0:8@"NSControl"16@"NSText"24
B40@0:8@"NSControl"16@"NSString"24@"NSString"32
v40@0:8@"NSControl"16@"NSString"24@"NSString"32
B32@0:8@"NSControl"16@24
B40@0:8@"NSControl"16@"NSTextView"24:32
@"NSArray"64@0:8@"NSControl"16@"NSTextView"24@"NSArray"32{_NSRange=QQ}40^q56
v40@0:8@16@24q32
@72@0:8@16@24^{CGRect={CGPoint=dd}{CGSize=dd}}32@40@48{CGPoint=dd}56
d32@0:8@16@24
@48@0:8@16@24@32@40
B48@0:8@16@24@32@40
d32@0:8@16q24
B40@0:8@16q24q32
@"NSView"40@0:8@"NSOutlineView"16@"NSTableColumn"24@32
@"NSTableRowView"32@0:8@"NSOutlineView"16@24
v40@0:8@"NSOutlineView"16@"NSTableRowView"24q32
B40@0:8@"NSOutlineView"16@"NSTableColumn"24@32
B24@0:8@"NSOutlineView"16
@"NSIndexSet"32@0:8@"NSOutlineView"16@"NSIndexSet"24
B32@0:8@"NSOutlineView"16@"NSTableColumn"24
v32@0:8@"NSOutlineView"16@"NSTableColumn"24
@"NSString"72@0:8@"NSOutlineView"16@"NSCell"24^{CGRect={CGPoint=dd}{CGSize=dd}}32@"NSTableColumn"40@48{CGPoint=dd}56
d32@0:8@"NSOutlineView"16@24
@"NSTintConfiguration"32@0:8@"NSOutlineView"16@24
@"NSString"40@0:8@"NSOutlineView"16@"NSTableColumn"24@32
@48@0:8@"NSOutlineView"16@24@32@"NSString"40
B40@0:8@"NSOutlineView"16@"NSEvent"24@"NSString"32
B48@0:8@"NSOutlineView"16@"NSCell"24@"NSTableColumn"32@40
@"NSCell"40@0:8@"NSOutlineView"16@"NSTableColumn"24@32
d32@0:8@"NSOutlineView"16q24
B40@0:8@"NSOutlineView"16q24q32
@48@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16
@"NSOutlineView"
@"NSMutableDictionary"
@32@0:8@16Q24
@24@0:8^{_NSZone=}16
^{SCNCActionRepeat=^^?d@?@BdddddBB@?^{__CFString}qdddd^{SCNCAction}QQdB}
@"SCNAction"
@32@0:8d16d24
@24@0:8d16
^{SCNCActionFade=^^?d@?@BdddddBB@?^{__CFString}qddddfffB}
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
@"NSData"
@32@0:8@16^@24
@40@0:8@16@24^@32
Q24@0:8Q16
i20@0:8I16
v24@0:8@"NSString"16
@"<MTLDevice>"16@0:8
@"<MTLHeap>"16@0:8
v104@0:8^v16Q24Q32{?={?=QQQ}{?=QQQ}}40Q88Q96
v104@0:8{?={?=QQQ}{?=QQQ}}16Q64Q72r^v80Q88Q96
v88@0:8^v16Q24{?={?=QQQ}{?=QQQ}}32Q80
v88@0:8{?={?=QQQ}{?=QQQ}}16Q64r^v72Q80
@24@0:8Q16
@64@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48
@68@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64
^{__IOSurface=}16@0:8
q16@0:8
{MTLResourceID=Q}16@0:8
{?=CCCC}16@0:8
@"<MTLTexture>"24@0:8Q16
@"<MTLTexture>"64@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48
@"MTLSharedTextureHandle"16@0:8
@"<MTLTexture>"24@0:8@"<MTLDevice>"16
@"<MTLTexture>"68@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64
@"<MTLResource>"16@0:8
@"<MTLTexture>"16@0:8
@"<MTLBuffer>"16@0:8
@24@0:8^{CGPath=}16
@88@0:8^{CGPath=}16{?=[4]}24
^{CGPath=}16@0:8
@24@0:8q16
v24@0:8q16
^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16@0:8
^{CGPath=}
{?="columns"[4]}
@32@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16@24
{?=b2b2b2b1}28@0:8@16C24
C28@0:8@16C24
@?36@0:8@16C24@28
v48@0:8{?=@@^{?}IB}16
v72@0:8{?=^{__C3DMesh}@^{__C3DMeshElement}@I@C}16
v40@0:8{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}16
v72@0:8{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}16{?=@@^{?}IB}40
^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}
@"SCNMTLResourceManager"
{?="type"C"tessellationFactorScale"f"tessellationPartitionMode"I"tessellationSmoothingMode"C"parameters"(?="uniform"{?="edgeTessellationFactor"f"insideTessellationFactor"f}"screenSpaceAdaptive"{?="projectedEdgeLength"f}"constrainedEdgeLength"{?="maximumEdgeLength"f}"subdivisionSurface"{?="tessellationLevel"C"allowSingleCreasePatch"b1"useScreenSpaceTessellation"b1})}
@"<MTLBuffer>"
@20@0:8I16
v24@0:8^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16
B48@0:8@16@24d32r^{?=IiqQdq{CVSMPTETime=ssIIIssss}QQ}40
v48@0:8@16@24d32r^{?=IiqQdq{CVSMPTETime=ssIIIssss}QQ}40
v24@0:8^{CGContext=}16
@28@0:8@16B24
^{SCNCPlaySound=^^?d@?@BdddddBB@?^{__CFString}qddddBB@}
B24@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16
Q32@0:8@16r^{?=@@@@@@@@@@@@}24
Q32@0:8@"<SCNMTLDeformerUpdateComputeContext>"16r^{?=@@@@@@@@@@@@}24
@56@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16Q24C32C36@40@48
@56@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16Q24C32C36@"SCNMTLResourceManager"40@"<SCNMTLDeformerInitComputeContext>"48
@"SCNMTLMesh"16@0:8
{?="segmentCountLinear"S"segmentCountQuadratic"S"segmentCountCubic"S"segmentInfoOffsetLinear"S"segmentInfoOffsetQuadratic"S"segmentInfoOffsetCubic"S"controlPointIndicesOffset"S}
@"SCNMTLMesh"
@"SCNMTLComputePipeline"
v48@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16
Q24@0:8@16
:16@0:8
v24@0:8:16
@"NSImage"
@"NSArray"
@"NSURL"
@"NSDictionary"
@"SCNAssetCatalog"
@"NSString"
v20@0:8B16
i16@0:8
@20@0:8B16
^{__C3DFXProgram=}40@0:8^{__C3DProgramHashCode=}16^{__C3DEngineContext=}24^{?=q^{?}[4{?=qq}][4{?=qq}][4q]^v^vB}32
@44@0:8@16@24B32Q36
v64@0:8^{__C3DFXMetalProgram=}16@24@32@40@?48@?56
{_NSRange="location"Q"length"Q}
^{__C3DModelTarget={__CFRuntimeBase=QAQ}^v^vscCCB^?^?}
@24@0:8^{__C3DEngineContext=}16
{CATransform3D=dddddddddddddddd}16@0:8
v24@0:8Q16
v72@0:8{SCNVector3=ddd}16{SCNVector3=ddd}40@64
v48@0:8@16{CGPoint=dd}24@40
d16@0:8
^{__C3DEngineContext=}
@"<SCNSceneRenderer>"
^{__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}
{?="weakProgram"^{__C3DFXProgram}"baseIndex"I"baseVertex"I"vertexSize"I"allocatedVerticesSize"I"allocatedIndicesSize"I"textureImage"^{__C3DImage}"texture"^{__C3DTexture}"drawMode"C"orthographic"B"clearDepthBuffer"B"enableDepthTest"B"enableCulling"B"isDynamic"B"mesh"^{__C3DMesh}"meshElement"^{__C3DMeshElement}"_cache"{?="verticesStride"Q"colorsStride"Q"uvsStride"Q"verticesData"*"colorsData"*"uvsData"*}"_usedMeshes"@"NSMutableSet""_freeMeshes"@"NSMutableSet""_usedMeshElements"@"NSMutableSet""_freeMeshElements"@"NSMutableSet"}
{?="textureInfo"{?="texture"^{__C3DImage}"textureSize"{CGSize="width"d"height"d}"isRetina"B}"lineHeight"d"characterWidth_texture"s"characterWidth_typography"^d"characterHeight_texture"s"symbolRects"^{?}}
^{__C3DRasterizerStates=}
@"NSMutableSet"
[64000C]
@"NSSet"
@"NSMutableOrderedSet"
@"NSMutableArray"
{?="initialized"B"showFullStatistics"B"showRenderOptionsPanel"B"fps"f"waitDisplayLinkTime"f"pressedButtonIndex"q"fpsString"^{__CFString}"shortString"^{__CFString}"internalString"^{__CFString}"lightingStatistics"[9I]"stats"{__C3DEngineStats="verticesProcessed"I"primitivesProcessed"I"drawCount"I"drawStep"I"frameCount"I"fboSwitches"I"vboSwitches"I"attSwitches"I"attEnabling"I"iboSwitches"I"vaoSwitches"I"prgSwitches"I"texSwitches"I"rssSwitches"I"getCount"I"uniformFloatSent"I"uniformIntSent"I"uniformVector2Sent"I"uniformVector3Sent"I"uniformVector4Sent"I"uniformMatrix4Sent"I"vboUploaded"I"iboUploaded"I"texUploaded"I"cpuTime"d"cstrTime"d"phyTime"d"prtTime"d"animTime"d"skinTime"d"mrphTime"d"rendTime"d"twoDTime"d"delegateTime"d"glFlushTime"d"waitDisplayLinkTime"d"drawableWaitTime"d"gpuTime"d"lastDisplayLinkTime"d"prgCount"I"texCount"I"fboCount"I"vboCount"I"rboCount"I"iboCount"I"cboCount"I"vaoCount"I"fboMemory"I"rboMemory"I"vboMemory"I"iboMemory"I"cboMemory"I"texMemory"I"backBufferMemory"I"depthBuffersMemory"I"onlineShaderCount"I"onlineShaderCompilationTime"d"renderPipelineCount"I"renderPipelineCompilationTime"d"computePipelineCount"I"computePipelineCompilationTime"d"frmAvgTime"d"frmMinTime"d"frmMaxTime"d"frameTimeHistory"[60d]"frameTimeCurrentIndex"I"startTime"d"lastFrameTime"d}}
@"SCNAuthoringEnvironment2"
v40@0:8{SCNVector3=ddd}16
v24@0:8d16
v24@0:8^{?=[296C]}16
v320@0:8@16{?=[296C]}24
{?="characterBody"@"SCNPhysicsBody""direction"{SCNVector3="x"d"y"d"z"d}"velocity"d"jumpSpeed"d}
^{btCharacterControllerInterface=^^?}
^{btOverlapFilterCallback=^^?}
^{btCapsuleShape=^^?i^v{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffi}
@"SCNPhysicsWorld"
v32@0:8r^v16Q24
v24@0:8^(C3DMatrix4x4=[16f][4]{?=[4]})16
f28@0:8r^(C3DMatrix4x4=[16f][4]{?=[4]})16f24
v24@0:8^{__C3DMaterial=}16
v96@0:8{?=^{__C3DFXMetalProgram}^{__C3DMaterial}^{__C3DGeometry}^{__C3DNode}^{__C3DMesh}^{__C3DMeshElement}{?=[8C]}^{__C3DFXPass}^IBBBBBb3}16
^{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIdddddddddddddddIIIIIIIIIIIIIIIIIdIdIdddd[60d]Idd}
{CATransform3D="m11"d"m12"d"m13"d"m14"d"m21"d"m22"d"m23"d"m24"d"m31"d"m32"d"m33"d"m34"d"m41"d"m42"d"m43"d"m44"d}
@"<MTLDevice>"
@"<MTLCommandQueue>"
@"NSObject<OS_dispatch_semaphore>"
{atomic<int>="__a_"{__cxx_atomic_impl<int, std::__cxx_atomic_base_impl<int>>="__a_value"Ai}}
@"<MTLTexture>"
@"CAMetalLayer"
@"<CAMetalDrawable>"
@"MTLRenderPassDescriptor"
@"<MTLCommandBuffer>"
^{SCNMTLRenderCommandEncoder=BQQQQBBBBIICBB[31{?=@Q}][128@][16@][31{?=@Q}][128@][16@]@@@^{SCNMTLBufferPool}[2Q][2Q]}
{SCNMTLBlitCommandEncoder="_encoder"@"<MTLBlitCommandEncoder>""_commandBuffer"@"<MTLCommandBuffer>"}
{SCNMTLComputeCommandEncoder="_buffers"[31@"<MTLBuffer>"]"_offsets"[31Q]"_textures"[128@"<MTLTexture>"]"_samplers"[16@"<MTLSamplerState>"]"_computePipelineState"@"<MTLComputePipelineState>""_encoder"@"<MTLComputeCommandEncoder>""_commandBuffer"@"<MTLCommandBuffer>""_bufferPool"^{SCNMTLBufferPool}"_features"I"_texturesToBind"[2Q]"_buffersToBind"[1Q]}
{?="renderSliceIndex"C"eyeCount"C"renderMode"C"multiVertexOutputStreamGenerator"C"isMainPass"B"isFinalTechnique"B}
{?="vertexIndex"c"fragmentIndex"c}
[3^{SCNMTLBufferPool}]
@"<MTLDepthStencilState>"
@"<MTLSamplerState>"
[3^{__C3DFXMetalProgram}]
^{__C3DFXMetalProgram={__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}[2^{__CFString}]^{__CFString}^{__CFString}^{__CFDictionary}^{__CFSet}^v^{__CFDictionary}i@?@?QI}
@"NSObject<OS_dispatch_queue>"
@"NSObject<OS_dispatch_group>"
{?="passInstance"^{__C3DFXPassInstance}"lightingSystem"^{__C3DLightingSystem}"dynamicBatchingSystem"^{__C3DDynamicBatchingSystem}"pass"^{__C3DFXPass}"renderGraphPass"^v"passRequiresLighting"B"transformTree"^{__C3DTransformTree}}
[6{SCNSceneBuffer="viewTransform"{float4x4="columns"[4]}"inverseViewTransform"{float4x4="columns"[4]}"projectionTransform"{float4x4="columns"[4]}"viewProjectionTransform"{float4x4="columns"[4]}"viewToCubeTransform"{float4x4="columns"[4]}"lastFrameViewProjectionTransform"{float4x4="columns"[4]}"ambientLightingColor""fogColor""fogParameters""inverseResolution""time"f"sinTime"f"cosTime"f"random01"f"motionBlurIntensity"f"environmentIntensity"f"inverseProjectionTransform"{float4x4="columns"[4]}"inverseViewProjectionTransform"{float4x4="columns"[4]}"nearFar""viewportSize""inverseTransposeViewTransform"{float4x4="columns"[4]}"clusterScale"}]
{?="buffer"@"<MTLBuffer>""offset"Q}
{?="buffer"@"<MTLBuffer>""offset"Q"size"Q"shadowMaps"[256@"<MTLTexture>"]"textureMaps"[256@"<MTLTexture>"]"samplerStates"[256@"<MTLSamplerState>"]}
{?="modelTransform"{float4x4="columns"[4]}"lastFrameModelTransform"{float4x4="columns"[4]}"normalTransforms"[6{float4x4="columns"[4]}]"modelViewTransforms"[6{float4x4="columns"[4]}]"modelViewProjectionTransforms"[6{float4x4="columns"[4]}]"boundingBox"{float2x3="columns"[2]}"worldBoundingBox"{float2x3="columns"[2]}"instanceNode"^{__C3DNode}"flags"I"probeCacheIndex"^I}
{?="currentLightingSet"{?="lights"[8C]}"currentShadowMaps"[8@"<MTLTexture>"]"currentGoboMaps"[8@"<MTLTexture>"]"frameLightingSetDatas"{unordered_map<unsigned long long, SCNMTLLightSetData, std::hash<unsigned long long>, std::equal_to<unsigned long long>, std::allocator<std::pair<const unsigned long long, SCNMTLLightSetData>>>="__table_"{__hash_table<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::__unordered_map_hasher<unsigned long long, std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::hash<unsigned long long>, std::equal_to<unsigned long long>>, std::__unordered_map_equal<unsigned long long, std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::equal_to<unsigned long long>, std::hash<unsigned long long>>, std::allocator<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<unsigned long long, std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::hash<unsigned long long>, std::equal_to<unsigned long long>>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<unsigned long long, std::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::equal_to<unsigned long long>, std::hash<unsigned long long>>>="__value_"f}}}"currentLightingHashKey"Q"currentLightingDesc"{?="count"q"lights"[8^{__C3DLight}]"lightsData"[8^{__C3DLightRuntimeData}]}"currentLightingSpace"{?="columns"[4]}"currentLightingSpaceShadow"{?="columns"[4]}"needLightingSpaceTransformation"B"clusterSystem"{SCNMTLClusterSystem="clustersCount""tileSize""selectedDebugClusterIndex""_debugClusterTilesPipeline"@"SCNMTLRenderPipeline""_debugLightIndicesBufferPipeline"@"SCNMTLRenderPipeline""_debugClusterSlicesPipeline"@"SCNMTLRenderPipeline""_debugProgram"[7^{__C3DFXMetalProgram}]"_debugShapes"[7^{__C3DMesh}]}"clusterInfo"{Info="clusterBuffer"{?="memory"*"buffer"@"<MTLBuffer>""offset"Q}"clusterTexture"@"<MTLTexture>""lightIndicesBuffer"@"<MTLBuffer>""lightIndicesBufferOffset"I"lightIndicesBufferSize"I"cellSize""clusterScale""cellPixelSize""omniLightsRange""spotLightsRange""probeLightsRange""lightsBuffer"{?="memory"*"buffer"@"<MTLBuffer>""offset"Q}"lightsBufferLightCount"I"shadowTextures"[8@"<MTLTexture>"]"iesOrGoboTextures"[8@"<MTLTexture>"]"samplerStates"[8@"<MTLSamplerState>"]"areaBuffer"@"<MTLBuffer>""areaBufferOffset"Q"areaBufferOffsets"[8Q]}"reflectionProbesTextureArray"@"<MTLTexture>"}
{Cache="rasterizerStates"^{__C3DRasterizerStates}"mesh"^{__C3DMesh}"metalMesh"@"SCNMTLMesh""meshElement"^{__C3DMeshElement}"metalMeshElement"@"SCNMTLMeshElement""program"^{__C3DFXMetalProgram}"material"^{__C3DMaterial}"geometry"^{__C3DGeometry}"metalShadable"@"SCNMTLShadable""commonProfile"^{__C3DEffectCommonProfile}"blendStates"^{__C3DBlendStates}"colorBufferWriteMask"C"primitiveTopologyClass"C"node"^{__C3DNode}"deformers"^{__C3DDeformerStack}"vertexDescriptorHash"Q"tessellationPipelineStateHash"C"renderPipeline"@"SCNMTLRenderPipeline"}
[2{?="hash"Q"pipeline"@"SCNMTLRenderPipeline"}]
@"SCNMTLRenderPipeline"
{?="backgroundTexture"@"<MTLTexture>""overlayTexture"@"<MTLTexture>""stencilDepthTexture"@"<MTLTexture>"}
{?="pixelFormat"Q"sampleCount"Q"displayCubemapPipeline"@"SCNMTLRenderPipeline""displayTexture2DPipeline"@"SCNMTLRenderPipeline""displayDepth2DPipeline"@"SCNMTLRenderPipeline""displayDepthCubePipeline"@"SCNMTLRenderPipeline"}
{?="collectEnabled"B"errors"@"NSMutableDictionary"}
{?="modelTransformBindingCount"I"modelViewTransformBindingCount"I"normalTransformBindingCount"I"nodeOpacityBindingCount"I}
{?="passHash"Q"material"^{__C3DMaterial}}
@"<SCNMTLRenderContextResourceManagerMonitor>"
@"<SCNMTLRenderContextCommandBufferStatusMonitor>"
{os_unfair_lock_s="_os_unfair_lock_opaque"I}
@"<MTLRenderCommandEncoder>"
@32@0:8d16@24
@24@0:8^{__C3DParticleSystem=}16
v32@0:8@16d24
v32@0:8d16@24
v32@0:8@"<SCNAnimation>"16@"NSString"24
v32@0:8@"SCNAnimationPlayer"16@"NSString"24
v32@0:8@"NSString"16d24
@"SCNAnimationPlayer"24@0:8@"NSString"16
@"CAAnimation"24@0:8@"NSString"16
v32@0:8d16@"NSString"24
B24@0:8@"NSString"16
@"NSArray"16@0:8
^v16@0:8
^{__C3DAnimationManager=}16@0:8
v32@0:8B16@20B28
^{__C3DParticleSystem=}16@0:8
s24@0:8@16
{SCNVector3=ddd}16@0:8
{SCNVector4=dddd}16@0:8
v48@0:8{SCNVector4=dddd}16
v40@0:8q16@24@?32
v40@0:8@16q24@?32
^{__C3DParticleSystem=}
@"SCNOrderedDictionary"
@"SCNGeometry"
{SCNVector3="x"d"y"d"z"d}
@"NSColor"
{SCNVector4="x"d"y"d"z"d"w"d}
@"SCNParticleSystem"
^{__C3DEngineContext=}16@0:8
^{__C3DRendererContext={__CFRuntimeBase=QAQ}iIIIIfI^{__C3DTexture}^{__C3DStack}^vBBBBB^{__CFDictionary}I^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}{C3DColor4=(?=[4f]{?=ffff})}^vq^{__C3DFXProgramObject}{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIdddddddddddddddIIIIIIIIIIIIIIIIIdIdIdddd[60d]Idd}{Cache=[16I]Ii^{__C3DBlendStates}I^{__C3DRasterizerStates}^{__C3DMesh}^{__C3DMeshElement}IIiI^viii}{?=[5I][5i][46{?=iII}][46I]^?^?^?^?^?^?^?^?^?^?}[2{VolatileObject=^{__C3DArray}II^{__CFArray}}]^{__C3DArray}I^{__CFDictionary}}16@0:8
@32@0:8@16q24
q24@0:8@16
@"SCNRendererOptionsPanel"
@"NSPopUpButton"
@"NSTextField"
@"NSSlider"
@"NSStepper"
@"NSButton"
@"SCNUIDynamicInspector"
@"NSComboBox"
B40@0:8@16@24^@32
@72@0:8{SCNVector3=ddd}16{SCNVector3=ddd}40@64
@56@0:8{btVector3=(?=[4f])}16{btVector3=(?=[4f])}32@48
@288@0:8@16{CATransform3D=dddddddddddddddd}24{CATransform3D=dddddddddddddddd}152@280
v24@0:8@?16
^{btVehicleRaycaster=^^?}16@0:8
v24@0:8^v16
v56@0:8@16^{__C3DNode=}24Q32Q40Q48
v32@0:8@16^v24
^{btOverlappingPairCallback=^^?}
^{btVehicleRaycaster=^^?}
^{btC3DDebugDraw=^^?if^v}
{c3dAether="_fields"{vector<c3dPhysicsField *, std::allocator<c3dPhysicsField *>>="__begin_"^^{c3dPhysicsField}"__end_"^^{c3dPhysicsField}"__end_cap_"{__compressed_pair<c3dPhysicsField **, std::allocator<c3dPhysicsField *>>="__value_"^^{c3dPhysicsField}}}"_activeFields"{vector<c3dPhysicsField *, std::allocator<c3dPhysicsField *>>="__begin_"^^{c3dPhysicsField}"__end_"^^{c3dPhysicsField}"__end_cap_"{__compressed_pair<c3dPhysicsField **, std::allocator<c3dPhysicsField *>>="__value_"^^{c3dPhysicsField}}}"_lastOverrideIndex"I}
@"<SCNPhysicsContactDelegate>"
@"SCNPhysicsContact"
@"SCNScene"
^{MTLComputeEvaluator=@@@i}
@56@0:8^{MTLContext=@@@@}16r^{BufferDescriptor=iii}24r^{BufferDescriptor=iii}32r^{BufferDescriptor=iii}40r^{BufferDescriptor=iii}48
@40@0:8@16@24Q32
v24@0:8^{__CVDisplayLink=}16
@40@0:8^{?=CCCb1b1b1b1b1b1[4C]}1624Q32
C16@0:8
B40@0:8^{?=CCCb1b1b1b1b1b1[4C]}1624Q32
{?="format"C"sampleCount"C"textureUsage"C"renderToTexture"b1"forceTextureRect"b1"viewportDependant"b1"renderToIOSurface"b1"mipmapped"b1"textureCube"b1"padding"[4C]}
@"CIImage"
@40@0:8{CGPoint=dd}16@32
{SCNVector3=ddd}40@0:8{SCNVector3=ddd}16
B32@0:8@16@?24
v32@0:8@16@?24
^{CGColorSpace=}16@0:8
{CGRect={CGPoint=dd}{CGSize=dd}}16@0:8
v48@0:8@"SCNScene"16@"SKTransition"24@"SCNNode"32@?<v@?>40
@"NSArray"40@0:8{CGPoint=dd}16@"NSDictionary"32
B32@0:8@"SCNNode"16@"SCNNode"24
@"NSArray"24@0:8@"SCNNode"16
B32@0:8@16@?<B@?>24
v32@0:8@"NSArray"16@?<v@?B>24
@"SCNScene"16@0:8
v24@0:8@"SCNScene"16
@"<SCNSceneRendererDelegate>"16@0:8
v24@0:8@"<SCNSceneRendererDelegate>"16
@"SCNNode"16@0:8
v24@0:8@"SCNNode"16
@"SKScene"16@0:8
v24@0:8@"SKScene"16
@"<MTLRenderCommandEncoder>"16@0:8
@"MTLRenderPassDescriptor"16@0:8
@"<MTLCommandQueue>"16@0:8
@"AVAudioEngine"16@0:8
@"AVAudioEnvironmentNode"16@0:8
@"SCNTechnique"16@0:8
v24@0:8@"SCNTechnique"16
@32@0:8@16^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}24
v32@0:8^{SCNVector3=ddd}16Q24
v24@0:8^{CGColor=}16
^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16@0:8
^{_CGLPixelFormatObject=}20@0:8I16
^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}24@0:8^{_CGLPixelFormatObject=}16
B48@0:8^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16^{_CGLPixelFormatObject=}24d32r^{?=IiqQdq{CVSMPTETime=ssIIIssss}QQ}40
v48@0:8^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16^{_CGLPixelFormatObject=}24d32r^{?=IiqQdq{CVSMPTETime=ssIIIssss}QQ}40
@"SCNJitterer"
@"SCNRenderer"
^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}
@"SCNRendererOptionsPanelController"
^{__C3DFXProgram=}
^{__CFSet=}
@24@0:8i16B20
^{__C3DFXProgram=}48@0:8^{__C3DProgramHashCode=}16^{__C3DEngineContext=}24@32^{?=q^{?}[4{?=qq}][4{?=qq}][4q]^v^vB}40
^{__CFDictionary=}
v40@0:8@16@24@?32
v24@0:8@"NSArray"16
v40@0:8@"NSURL"16@"NSDictionary"24@?<v@?@"NSData"@"NSError">32
v144@0:8{CATransform3D=dddddddddddddddd}16
@"SCNNode"
@32@0:8@16d24
@32@0:8#16@24
@40@0:8#16#24@32
@"<SCNJittererDelegate>"
@"NSObject<OS_dispatch_source>"
@100@0:8@16Q24B32Q36Q44Q52Q60q68@76Q84@92
@"MDLAnimatedScalarArray"16@0:8
Q32@0:8^{?=[4]}16Q24
{?=[4]}16@0:8
@"NSData"16@0:8
v64@0:8@16@24B32B36f40f44@?48@?56
@72@0:8@16@24@32@40^v48@56@64
@72@0:8@16@24@32@?40@48@56@64
v48@0:8@?16@?24@32@40
^{__C3DFXContext=}16@0:8
^{__C3DTexture=}16@0:8
@"SCNTechniquePanel"
@"SCNRenderTargetView"
v24@0:8^{__C3DTexture=}16
v40@0:8@16@24d32
^{__C3DTexture=}
@"SCNPlane"
@"NSOpenGLContext"
@32@0:8@?16@24
@"SCNDisplayLink"
v24@0:8#16
@32@0:8@16#24
@40@0:8@16#24@32
v40@0:8@16@24Q32
@"SCNUIArrayEditor"
@"NSObjectController"
@"NSPathControl"
@288@0:8@16{CATransform3D=dddddddddddddddd}24@152{CATransform3D=dddddddddddddddd}160
@152@0:8@16{CATransform3D=dddddddddddddddd}24
{?="bodyA"@"SCNPhysicsBody""frameA"{CATransform3D="m11"d"m12"d"m13"d"m14"d"m21"d"m22"d"m23"d"m24"d"m31"d"m32"d"m33"d"m34"d"m41"d"m42"d"m43"d"m44"d}"bodyB"@"SCNPhysicsBody""frameB"{CATransform3D="m11"d"m12"d"m13"d"m14"d"m21"d"m22"d"m23"d"m24"d"m31"d"m32"d"m33"d"m34"d"m41"d"m42"d"m43"d"m44"d}"maximumAngularLimit1"d"maximumAngularLimit2"d"maximumTwistAngle"d}
^{btConeTwistConstraint=^^?ii(?=i^v)fBBi^{btRigidBody}^{btRigidBody}ff^{btJointFeedback}[3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}]{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}ffffffff{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffffffBBBBff{btVector3=(?=[4f])}BB{btQuaternion=(?=[4f])}f{btVector3=(?=[4f])}ifff}
@"CAAnimation"
v24@0:8^{__C3DImageProxy=}16
v24@0:8^{__C3DRendererContext={__CFRuntimeBase=QAQ}iIIIIfI^{__C3DTexture}^{__C3DStack}^vBBBBB^{__CFDictionary}I^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}{C3DColor4=(?=[4f]{?=ffff})}^vq^{__C3DFXProgramObject}{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIdddddddddddddddIIIIIIIIIIIIIIIIIdIdIdddd[60d]Idd}{Cache=[16I]Ii^{__C3DBlendStates}I^{__C3DRasterizerStates}^{__C3DMesh}^{__C3DMeshElement}IIiI^viii}{?=[5I][5i][46{?=iII}][46I]^?^?^?^?^?^?^?^?^?^?}[2{VolatileObject=^{__C3DArray}II^{__CFArray}}]^{__C3DArray}I^{__CFDictionary}}16
@48@0:8^{__C3DEngineContext=}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24^d32^{?=BB}40
@"AVPlayer"
{?="videoOutput"@"pixelBuffer"^{__CVBuffer}"mtlTextureForRenderer"@"<MTLTexture>""mtlTextureColorMatched"@"<MTLTexture>""mtlTextureColorForColorMatchingComputeKernel"@"<MTLTexture>""pixelBufferColorSpace"^{CGColorSpace}}
^{__CVMetalTextureCache=}
v40@0:8@16^{opaqueCMSampleBuffer=}24@32
v40@0:8@"AVCaptureOutput"16^{opaqueCMSampleBuffer=}24@"AVCaptureConnection"32
@"AVCaptureDevice"
@"AVCaptureSession"
v24@0:8^{opaqueCMSampleBuffer=}16
v24@0:8^{__CVBuffer=}16
v32@0:8^{opaqueCMSampleBuffer=}16@24
v32@0:8^{__CVBuffer=}16@24
v32@0:8^{opaqueCMSampleBuffer=}16@"AVCaptureDevice"24
v32@0:8^{__CVBuffer=}16@"AVCaptureDevice"24
@32@0:8d16@?24
^{SCNCActionWait=^^?d@?@BdddddBB@?^{__CFString}qdddd}
@24@0:8^{__C3DCamera={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}{?=b1b1b1b1b1b1b1dddfd(C3DMatrix4x4=[16f][4]{?=[4]}){?=[4]}dd}ffffiib1b1b1b1b1C(C3DMatrix4x4=[16f][4]{?=[4]})ffffffffffffiffffffffffffff{?=fffffii}^{__C3DEffectSlot}Q^{__C3DFXTechnique}^vf}16
f16@0:8
v20@0:8f16
16@0:8
v24@0:816
{CGAffineTransform=dddddd}16@0:8
v64@0:8{CGAffineTransform=dddddd}16
^{__C3DCamera={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}{?=b1b1b1b1b1b1b1dddfd(C3DMatrix4x4=[16f][4]{?=[4]}){?=[4]}dd}ffffiib1b1b1b1b1C(C3DMatrix4x4=[16f][4]{?=[4]})ffffffffffffiffffffffffffff{?=fffffii}^{__C3DEffectSlot}Q^{__C3DFXTechnique}^vf}16@0:8
{CATransform3D=dddddddddddddddd}32@0:8{CGSize=dd}16
^{__C3DCamera={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}{?=b1b1b1b1b1b1b1dddfd(C3DMatrix4x4=[16f][4]{?=[4]}){?=[4]}dd}ffffiib1b1b1b1b1C(C3DMatrix4x4=[16f][4]{?=[4]})ffffffffffffiffffffffffffff{?=fffffii}^{__C3DEffectSlot}Q^{__C3DFXTechnique}^vf}
@"SCNTechnique"
@"SCNMaterialProperty"
{?="intensity"f"radius"f"bias"f"depthThreshold"f"normalThreshold"f"sampleCount"q"downSample"q}
{C3DColor4=(?=[4f]{?=ffff})}28@0:8B16^B20
@48@0:8d16d24d32d40
@56@0:8d16d24d32d40@48
@24@0:8r^{C3DColor4=(?=[4f]{?=ffff})}16
@80@0:8{?=[4]}16
{CGPoint=dd}16@0:8
@32@0:8{CGPoint=dd}16
@40@0:8{SCNVector3=ddd}16
@48@0:8{SCNVector4=dddd}16
@144@0:8{CATransform3D=dddddddddddddddd}16
@24@0:8^{__C3DLight=}16
^{__C3DLight=}16@0:8
{CGSize=dd}16@0:8
v32@0:8{CGSize=dd}16
v32@0:816
^{__C3DLight=}
{CGSize="width"d"height"d}
@24@0:8^{__C3DMaterial=}16
v32@0:8@"NSString"16@?<v@?II@"SCNNode"@"SCNRenderer">24
@"SCNProgram"16@0:8
v24@0:8@"SCNProgram"16
@"NSDictionary"16@0:8
v24@0:8@"NSDictionary"16
@"NSNumber"16@0:8
v24@0:8@"NSNumber"16
^{__C3DMaterial=}16@0:8
^{__C3DEffectCommonProfile={__CFRuntimeBase=QAQ}^{__C3DMaterial}i^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}fffffCqBBb1b1b1b1b1b1b1b1b1b13}16@0:8
v24@0:8^@16
@24@0:8^@16
^{__C3DMaterial=}
@"SCNShadableHelper"
@24@0:8^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}16
v24@0:8@"SCNAction"16
v32@0:8@"SCNAction"16@?<v@?>24
v32@0:8@"SCNAction"16@"NSString"24
v40@0:8@"SCNAction"16@"NSString"24@?<v@?>32
@"SCNAction"24@0:8@"NSString"16
B32@0:8^{SCNVector3=ddd}16^{SCNVector3=ddd}24
v32@0:8^{SCNVector3=ddd}16^{SCNVector3=ddd}24
B32@0:8^{SCNVector3=ddd}16^d24
B36@0:8@?16B24@28
@28@0:8@?16B24
@24@0:8@?16
B24@0:8@?16
v36@0:8#16@24B32
@28@0:8#16B24
v32@0:8@16q24
^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}16@0:8
{?=}16@0:8
v32@0:8{?=}16
v24@0:8^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}16
v32@0:8@16Q24
v32@0:8Q16@24
B40@0:8^{?=[6(?={?=ffff})]}1624
{CGRect={CGPoint=dd}{CGSize=dd}}24@0:8@16
v64@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16@48@56
v24@0:8^{__C3DParticleSystem=}16
{SCNVector3=ddd}48@0:8{SCNVector3=ddd}16@40
{CATransform3D=dddddddddddddddd}152@0:8{CATransform3D=dddddddddddddddd}16@144
v28@0:8@16B24
^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}
(?="eulerAngles""axisAngle""quaternion"{?="vector"})
@"SCNNodeComponent"
^{SCNVector3=ddd}
v88@0:8{SCNVector3=ddd}16{SCNVector3=ddd}40{SCNVector3=ddd}64
v72@0:8{SCNVector4=dddd}16{SCNVector3=ddd}48
B32@0:8^16^f24
v80@0:8{?=[4]}16
40@0:816@32
{?=[4]}88@0:8{?=[4]}16@80
v64@0:8163248
v48@0:8{?=}1632
@24@0:8^{__C3DScene=}16
v28@0:8@16i24
@20@0:8i16
B48@0:8@16@24@32@?40
v152@0:8@16{CATransform3D=dddddddddddddddd}24
^{__C3DScene=}
@"SCNSceneSource"
[4@"SCNNode"]
@"SCNAuthoringEnvironment"
^{__C3DRendererContext={__CFRuntimeBase=QAQ}iIIIIfI^{__C3DTexture}^{__C3DStack}^vBBBBB^{__CFDictionary}I^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}{C3DColor4=(?=[4f]{?=ffff})}^vq^{__C3DFXProgramObject}{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIdddddddddddddddIIIIIIIIIIIIIIIIIdIdIdddd[60d]Idd}{Cache=[16I]Ii^{__C3DBlendStates}I^{__C3DRasterizerStates}^{__C3DMesh}^{__C3DMeshElement}IIiI^viii}{?=[5I][5i][46{?=iII}][46I]^?^?^?^?^?^?^?^?^?^?}[2{VolatileObject=^{__C3DArray}II^{__CFArray}}]^{__C3DArray}I^{__CFDictionary}}24@0:8^{__C3DEngineContext=}16
^{__C3DTexture=}40@0:8^{__C3DEngineContext=}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24^d32
v40@0:8^{__C3DEngineContext=}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24^d32
v40@0:8^{__C3DEngineContext=}16{CGSize=dd}24
^{__C3DTexture=}52@0:8{CGSize=dd}16^{__C3DEngineContext=}32^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}40B48
v24@0:8^{__C3DEngineContext=}16
^{__C3DFramebuffer=}
@48@0:8^{__C3DEngineContext=}16@24@32@40
v32@0:8@16^{__C3DEngineContext=}24
@120@0:8@16@24Q32{?=[4]}40Q104Q112
@112@0:8@16@24@32Q40{?=[4]}48
v32@0:8^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}16^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}24
v40@0:8^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}16^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}24^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DDeformerStack}f{?=}}32
@32@0:8^{__C3DMesh=}16^{__C3DMesh=}24
{?="pointIndices"^v"pointIndicesStride"Q"pointIndicesFormat"Q"barycentricCoords"^v"barycentricCoordsStride"Q"barycentricCoordsFormat"Q"innerLayerInfluences"^f"innerLayerInfluencesLength"Q"innerLayerTNBs"^f"outerLayerTNBs"^f"tnbMatricesLength"Q"innerLayerOffsets"^f"outerLayerOffsets"^f"offsetsLength"Q"legacyOffsetsOrTransforms"^f"legacyOffsetsOrTransformsLength"Q}
B24@0:8^{?=}16
@48@0:8@16Q24Q32@40
@"SCNGeometryWrapDeformerParameters"
Q24@0:8@"<SCNGeometryDeformerUpdateComputeContext>"16
{?="vertexCount"I"innerLayerToDeformedTransform"{?="columns"[4]}"outerLayerToDeformedTransform"{?="columns"[4]}}
{?="vertexCount"I"driverToDeformedTransform"{?="columns"[4]}}
@36@0:8Q16Q24B32
@56@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16@48
B20@0:8f16
{CGSize=dd}32@0:8{CGSize=dd}16
v32@0:8d16^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}24
d24@0:8d16
v32@0:8^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16d24
@"NSOpenGLPixelFormat"
@"CALayer"
@"SCNRecursiveLock"
@"<SCNEventHandler>"
@"SCNSpriteKitEventHandler"
@"SCNPhysicsVehicle"
v40@0:8@"<MTLRenderCommandEncoder>"16@"<MTLCommandBuffer>"24@"MTLRenderPassDescriptor"32
@"<MTLCommandBuffer>"16@0:8
v24@0:8^{MainPassCustomPostProcessPass=^^?^{Pass}^{__C3DEngineContext}^{RenderGraph}{PassDescriptor=iSSSSIB^{PassIODescriptor}^{PassIODescriptor}SS}{PassResource=^^{RefCountedResource}^^{RefCountedResource}SS}I{Parameters=CCCCCCCBBB[6]I}BQB^{MainPassCustomPostProcessPassResource}}16
@"SCNMTLRenderContext"
^{MainPassCustomPostProcessPass=^^?^{Pass}^{__C3DEngineContext}^{RenderGraph}{PassDescriptor=iSSSSIB^{PassIODescriptor}^{PassIODescriptor}SS}{PassResource=^^{RefCountedResource}^^{RefCountedResource}SS}I{Parameters=CCCCCCCBBB[6]I}BQB^{MainPassCustomPostProcessPassResource}}
^{SCNCActionScale=^^?d@?@BdddddBB@?^{__CFString}qddddfffffBB}
@48@0:8{SCNVector3=ddd}16d40
@56@0:8d16{SCNVector3=ddd}24d48
@56@0:8{SCNVector4=dddd}16d48
@52@0:8d16d24d32d40B48
@?16@0:8
^{SCNCAction=^^?d@?@BdddddBB@?^{__CFString}qdddd}16@0:8
^{SCNCAction=^^?d@?@BdddddBB@?^{__CFString}qdddd}
@32@0:8q16@24
{?=dddddd}16@0:8
v64@0:8{?=dddddd}16
{?="originX"d"originY"d"width"d"height"d"znear"d"zfar"d}
^{__C3DFXPass=}16@0:8
@60@0:8i16@20{CGSize=dd}28@44@52
@"SKTransition"
^{__C3DFXPass=}
[2@"SCNOffscreenRenderer"]
{?=QQ}24@0:8@16
{?=QQ}32@0:8Q16Q24
@32@0:8Q16Q24
@40@0:8r^v16Q24Q32
@48@0:8^v16Q24Q32@?40
@40@0:8@16^{__IOSurface=}24Q32
@48@0:8@16Q24^@32^@40
v40@0:8@16Q24@?32
B24@0:8Q16
B24@0:8q16
v32@0:8^{?=ff}16Q24
@40@0:8@16Q24Q32
@40@0:8@16q24^@32
{?=QQQ}40@0:8Q16Q24Q32
Q24@0:8q16
{?=QQQ}48@0:8Q16Q24Q32q40
v32@0:8^Q16^Q24
{?=QQQ}24@0:8@16
{?=QQ}24@0:8Q16
{?=QQQ}16@0:8
I16@0:8
v72@0:8r^{?={?=QQQ}{?=QQQ}}16^{?={?=QQQ}{?=QQQ}}24{?=QQQ}32Q56Q64
v64@0:8r^{?={?=QQQ}{?=QQQ}}16^{?={?=QQQ}{?=QQQ}}24{?=QQQ}32Q56
@"<MTLLogState>"32@0:8@"MTLLogStateDescriptor"16^@24
@"<MTLCommandQueue>"24@0:8Q16
@"<MTLCommandQueue>"24@0:8@"MTLCommandQueueDescriptor"16
{?=QQ}24@0:8@"MTLTextureDescriptor"16
@"<MTLHeap>"24@0:8@"MTLHeapDescriptor"16
@"<MTLBuffer>"32@0:8Q16Q24
@"<MTLBuffer>"40@0:8r^v16Q24Q32
@"<MTLBuffer>"48@0:8^v16Q24Q32@?<v@?^vQ>40
@"<MTLDepthStencilState>"24@0:8@"MTLDepthStencilDescriptor"16
@"<MTLTexture>"24@0:8@"MTLTextureDescriptor"16
@"<MTLTexture>"40@0:8@"MTLTextureDescriptor"16^{__IOSurface=}24Q32
@"<MTLTexture>"24@0:8@"MTLSharedTextureHandle"16
@"<MTLSamplerState>"24@0:8@"MTLSamplerDescriptor"16
@"<MTLLibrary>"16@0:8
@"<MTLLibrary>"32@0:8@"NSBundle"16^@24
@"<MTLLibrary>"32@0:8@"NSString"16^@24
@"<MTLLibrary>"32@0:8@"NSURL"16^@24
@"<MTLLibrary>"32@0:8@"NSObject<OS_dispatch_data>"16^@24
@"<MTLLibrary>"40@0:8@"NSString"16@"MTLCompileOptions"24^@32
v40@0:8@"NSString"16@"MTLCompileOptions"24@?<v@?@"<MTLLibrary>"@"NSError">32
@"<MTLLibrary>"32@0:8@"MTLStitchedLibraryDescriptor"16^@24
v32@0:8@"MTLStitchedLibraryDescriptor"16@?<v@?@"<MTLLibrary>"@"NSError">24
@"<MTLRenderPipelineState>"32@0:8@"MTLRenderPipelineDescriptor"16^@24
@"<MTLRenderPipelineState>"48@0:8@"MTLRenderPipelineDescriptor"16Q24^@32^@40
v32@0:8@"MTLRenderPipelineDescriptor"16@?<v@?@"<MTLRenderPipelineState>"@"NSError">24
v40@0:8@"MTLRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLComputePipelineState>"32@0:8@"<MTLFunction>"16^@24
@"<MTLComputePipelineState>"48@0:8@"<MTLFunction>"16Q24^@32^@40
v32@0:8@"<MTLFunction>"16@?<v@?@"<MTLComputePipelineState>"@"NSError">24
v40@0:8@"<MTLFunction>"16Q24@?<v@?@"<MTLComputePipelineState>"@"MTLComputePipelineReflection"@"NSError">32
@"<MTLComputePipelineState>"48@0:8@"MTLComputePipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLComputePipelineDescriptor"16Q24@?<v@?@"<MTLComputePipelineState>"@"MTLComputePipelineReflection"@"NSError">32
@"<MTLFence>"16@0:8
@"<MTLRenderPipelineState>"48@0:8@"MTLTileRenderPipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLTileRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLRenderPipelineState>"48@0:8@"MTLMeshRenderPipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLMeshRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLArgumentEncoder>"24@0:8@"NSArray"16
@"<MTLRasterizationRateMap>"24@0:8@"MTLRasterizationRateMapDescriptor"16
@"<MTLIndirectCommandBuffer>"40@0:8@"MTLIndirectCommandBufferDescriptor"16Q24Q32
@"<MTLEvent>"16@0:8
@"<MTLSharedEvent>"16@0:8
@"<MTLSharedEvent>"24@0:8@"MTLSharedEventHandle"16
@"<MTLIOFileHandle>"32@0:8@"NSURL"16^@24
@"<MTLIOCommandQueue>"32@0:8@"MTLIOCommandQueueDescriptor"16^@24
@"<MTLIOFileHandle>"40@0:8@"NSURL"16q24^@32
@"<MTLCounterSampleBuffer>"32@0:8@"MTLCounterSampleBufferDescriptor"16^@24
@"<MTLArgumentEncoder>"24@0:8@"<MTLBufferBinding>"16
@"<MTLDynamicLibrary>"32@0:8@"<MTLLibrary>"16^@24
@"<MTLDynamicLibrary>"32@0:8@"NSURL"16^@24
@"<MTLBinaryArchive>"32@0:8@"MTLBinaryArchiveDescriptor"16^@24
{?=QQQ}24@0:8@"MTLAccelerationStructureDescriptor"16
@"<MTLAccelerationStructure>"24@0:8Q16
@"<MTLAccelerationStructure>"24@0:8@"MTLAccelerationStructureDescriptor"16
{?=QQ}24@0:8@"MTLAccelerationStructureDescriptor"16
@"<MTLResidencySet>"32@0:8@"MTLResidencySetDescriptor"16^@24
@"MTLArchitecture"16@0:8
@32@0:8^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16@24
v32@0:8@"SCNMTLRenderContext"16@"<MTLCommandBuffer>"24
v40@0:8@"SCNMTLRenderContext"16@24@"NSString"32
@56@0:8@16B24@28B36^v40Q48
32@0:816
v64@0:8^{SCNVector3=ddd}16Q24{SCNVector4=dddd}32
{SCNVector3=ddd}72@0:8{SCNVector3=ddd}16{SCNVector4=dddd}40
v24@0:8^{__C3DScene=}16
@56@0:8{CGPoint=dd}16{CGSize=dd}32@48
B64@0:8@16@24{SCNVector4=dddd}32
@56@0:8@16{SCNVector4=dddd}24
v32@0:8^{__C3DEngineContext=}16d24
B24@0:8^{__C3DScene=}16
v72@0:8d16{CGRect={CGPoint=dd}{CGSize=dd}}24@56@64
v88@0:8d16{CGRect={CGPoint=dd}{CGSize=dd}}24@56@64@72@80
v80@0:8d16{CGRect={CGPoint=dd}{CGSize=dd}}24@56@64@72
v56@0:8d16@24@32@40@48
v64@0:8d16@24@32@40@48Q56
v40@0:8d16@24@32
^{CGImage=}32@0:8d16^@24
^{CGImage=}32@0:8{CGSize=dd}16
@48@0:8d16{CGSize=dd}24Q40
@56@0:8d16{CGSize=dd}24Q40^@48
^{CGImage=}48@0:8d16{CGSize=dd}24Q40
^{CGImage=}56@0:8d16{CGSize=dd}24Q40^@48
@32@0:8{CGSize=dd}16
v40@0:8Q16B24B28@32
{?="frameBuffer"^{__C3DFramebuffer}"multisamplingFrameBuffer"^{__C3DFramebuffer}"drawableSize"{CGSize="width"d"height"d}}
@"SCNRendererTransitionContext"
{?="supportsUpdate"b1"supportsDidApplyAnimations"b1"supportsDidSimulatePhysics"b1"supportsDidApplyConstraints"b1"supportsWillRender"b1"supportsDidRender"b1"supportsInputTime"b1"supportsReadSubdivCache"b1"supportsWriteSubdivCache"b1"supportsMainPassCustomPostProcess"b1}
{C3DColor4=""(?="rgba"[4f]""{?="r"f"g"f"b"f"a"f}"simd")}
@"__SKSCNRenderer"
@"<_SCNSceneRendererResourceManagerMonitor>"
@"<_SCNSceneCommandBufferStatusMonitor>"
@40@0:8^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16{CGSize=dd}24
@40@0:8@16{CGSize=dd}24
@48@0:8@16@24{CGSize=dd}32
B32@0:8@16^24
v40@0:8@16d24@32
@"<_SCNSceneRendererDelegate><_SCNSceneRendererDelegateSPI>"
i20@0:8i16
@"MTLArgument"
@"<MTLArgumentEncoder>"
^{?=@?II}
^{?=^{__C3DFXPassInput}II}
^{__C3DFXPassInput=}
v34@0:8@16Q24{?=cc}32
@18@0:8{?=cc}16
[31@]
[16@]
^{__C3DFXMetalProgram=}
{?="colorFormat"[8Q]"depthFormat"Q"stencilFormat"Q"sampleCount"C}
[2I]
@"<MTLRenderPipelineState>"
@"MTLVertexDescriptor"
@"<MTLFunction>"
@"<MTLComputePipelineState>"
@"MTLStageInputOutputDescriptor"
@"SCNMTLBuffer"
@128@0:8@16{SCNVector3=ddd}24{SCNVector3=ddd}48@72{SCNVector3=ddd}80{SCNVector3=ddd}104
@72@0:8@16{SCNVector3=ddd}24{SCNVector3=ddd}48
{?="bodyA"@"SCNPhysicsBody""bodyB"@"SCNPhysicsBody""axisA"{SCNVector3="x"d"y"d"z"d}"anchorA"{SCNVector3="x"d"y"d"z"d}"axisB"{SCNVector3="x"d"y"d"z"d}"anchorB"{SCNVector3="x"d"y"d"z"d}"minLinearLimit"d"maxLinearLimit"d"minAngularLimit"d"maxAngularLimit"d"motorTargetLinearVelocity"d"motorMaximumForce"d"motorTargetAngularVelocity"d"motorMaximumTorque"d}
^{btSliderConstraint=^^?ii(?=i^v)fBBi^{btRigidBody}^{btRigidBody}ff^{btJointFeedback}BB{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}BffffffffffffffffffffffffffffBBi[3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}][3f][3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}]f{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffBfffBfff}
^{SCNCActionMove=^^?d@?@BdddddBB@?^{__CFString}qdddddBB}
v32@0:8^?16^v24
{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}
^{__C3DKeyframedAnimation=}16@0:8
v24@0:8^{__C3DKeyframedAnimation=}16
^{__C3DKeyframedAnimation=}
B36@0:8d16B24^v28
@24@0:8^{__C3DTimingFunction=}16
^{__C3DTimingFunction=}16@0:8
^{__C3DTimingFunction=}
@24@0:8^{__C3DAnimation=}16
v24@0:8^{__C3DAnimation=}16
^{__C3DAnimation=}16@0:8
^{__C3DAnimation=}
@"SCNTimingFunction"
@24@0:8^{__C3DAnimationPlayer=}16
^{__C3DAnimationPlayer=}16@0:8
^{__C3DAnimationPlayer=}
@"SCNAnimation"
#40@0:8@16@24@32
#40@0:8@"NSKeyedUnarchiver"16@"NSString"24@"NSArray"32
@32@0:8@"NSKeyedUnarchiver"16@24
v40@0:8@"NSKeyedUnarchiver"16@24@32
v24@0:8@"NSKeyedUnarchiver"16
@32@0:8Q16@24
@40@0:8Q16@24^@32
^{__C3DScene=}32@0:8@16@?24
@40@0:8#16@24@?32
@32@0:8@16@?24
@40@0:8#16@24^@32
^{__C3DSceneSource=}16@0:8
^{__C3DLibrary=}16@0:8
@24@0:8#16
B48@0:8@16Q24@?32@?40
^{__C3DSceneSource=}
@24@0:8^{__CFArray=}16
@24@0:8^{__C3DHitTestResult=}16
{CGPoint=dd}24@0:8q16
^{__C3DHitTestResult=}
v20@0:8I16
v48@0:8@16@?24@?32@40
v56@0:8@16@?24@?32@?40@48
v48@0:8@"<MTLTexture>"16@?<v@?@?<v@?@"<MTLComputeCommandEncoder>">>24@?<v@?@?<v@?@"<MTLBlitCommandEncoder>">>32@"<SCNMaterialPropertyTextureProviderHelper>"40
v56@0:8@"<MTLTexture>"16@?<v@?@?<v@?@"<MTLComputeCommandEncoder>">>24@?<v@?@?<v@?@"<MTLBlitCommandEncoder>">>32@?<v@?@?<v@?@"<MTLCommandBuffer>">>40@"<SCNMaterialPropertyTextureProviderHelper>"48
^{__C3DImage=}32@0:8@16Q24
^{__C3DImage=}36@0:8@16i24^B28
^{__C3DImage=}28@0:8@16i24
^{__C3DImage=}24@0:8@16
@24@0:8^{__C3DImage=}16
@28@0:8@16c24
^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture}^v)b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}20@0:8B16
v24@0:8^{__C3DImage=}16
{C3DColor4=(?=[4f]{?=ffff})}16@0:8
c16@0:8
^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture}^v)b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}16@0:8
^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}16@0:8
v80@0:8(C3DMatrix4x4=[16f][4]{?=[4]})16
^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture}^v)b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}
^{__C3DImage=}
^{CATransform3D=dddddddddddddddd}
@40@0:8d16d24@32
@48@0:8d16d24d32@40
@24@0:8^{__C3DFloor={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}ffffifffQ}16
^{__C3DFloor={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}ffffifffQ}16@0:8
v32@0:8d16q24
@"SCNPhysicsBody"
@24@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16
v24@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16
B48@0:8@16@24^@32^@40
{?=BCCC}16@0:8
v20@0:8{?=BCCC}16
{?="enableVertexWeldingAtImport"B"boundaryInterpolationRule"C"faceVaryingInterpolationRule"C"normalSmoothingMode"C}
@"SCNGeometrySource"
@"SCNGeometryElement"
@"SCNGeometryTessellator"
@"SKScene"
v28@0:8f16f20f24
v48@0:8{CGPoint=dd}16{CGSize=dd}32
v24@0:8f16f20
v52@0:8f16{CGPoint=dd}20{CGSize=dd}36
{?=}24@0:8o^f16
{?=[4]}48@0:81632
v56@0:8{CGPoint=dd}16{CGSize=dd}32d48
v64@0:8{CGPoint=dd}16{CGSize=dd}32{CGPoint=dd}48
48@0:8{CGPoint=dd}16{CGSize=dd}32
{?=}32@0:8{?=}16
B48@0:8{CGPoint=dd}16{CGSize=dd}32
v32@0:8{CGPoint=dd}16
{?="angles""initialAbsoluteAngles""initialTransformWorld"{?="columns"[4]}"initialOrientationWorld"{?="vector"}}
{?="start""current""last"}
{?="localArcballAdjustement""sphereLocationStart""sphereLocationCurrent"}
{?="inertiaEnabled"B"inertiaRunning"B"lastSimulationTime"d"friction"f"rotationSensitivity"f"translationSensitivity"f"velocity""timer"@"NSTimer"}
@"<SCNCameraControllerDelegate>"
44@0:816f24{CGSize=dd}28
v44@0:8@16@24@32f40
v32@0:8q16@24
@"SCNManipulator"
@"SCNMTLLibraryManager"
@"<MTLLibrary>"
v24@0:8^{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIdddddddddddddddIIIIIIIIIIIIIIIIIdIdIdddd[60d]Idd}16
v128@0:8{?=^{__C3DFXMetalProgram}^{__C3DMaterial}^{__C3DGeometry}^{__C3DFXPass}^{__C3DFXPass}@^{__C3DBlendStates}^{__C3DNode}CCCCCC@{?=C@?}Q}16@?120
@"SCNMTLLibrary"
@"NSMapTable"
@40@0:8@16^@24^B32
@"<MTLTexture>"32@0:8@"NSURL"16^@24
@"<MTLTexture>"40@0:8@"NSURL"16^@24^B32
@"<SCNMaterialPropertyTextureProvider>"
^{SCNCActionHide=^^?d@?@BdddddBB@?^{__CFString}qddddB}
v56@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16@48
f20@0:8f16
{CGPoint="x"d"y"d}
@24@0:8^{__C3DSkinner=}16
^{__C3DSkinner=}48@0:8@16@24@32@40
^{__C3DSkinner=}40@0:8@16Q24Q32
@56@0:8@16@24@32@40@48
@176@0:8@16@24@32@40{CATransform3D=dddddddddddddddd}48
^{__C3DSkinner=}16@0:8
^{__C3DSkinner=}
@40@0:8@16Q24^@32
@48@0:8@16@24@32Q40
B48@0:8@16@24Q32^@40
B40@0:8@16Q24^@32
{__zFlags="providerSuppliesContents"b1"providerSuppliesStreams"b1"providerSuppliesProperties"b1"noContentsCaching"b1"fileOpen"b1"reserved"b27}
[5^v]
v32@0:8{_NSRange=QQ}16
v40@0:8@16{_NSRange=QQ}24
@"<MTLTexture>"40@0:8@"MTLTextureDescriptor"16Q24Q32
v40@0:8@"NSString"16{_NSRange=QQ}24
@"<MTLBuffer>"24@0:8@"<MTLDevice>"16
v52@0:8@16^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}24c32q36q44
v68@0:8@16c24q28q36Q44Q52Q60
v24@0:8r^v16
v32@0:8^{__C3DFXMetalProgram={__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}[2^{__CFString}]^{__CFString}^{__CFString}^{__CFDictionary}^{__CFSet}^v^{__CFDictionary}i@?@?QI}16^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[8{?=CCCb1b1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}[9f]^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}C^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}@?@?^{__CFDictionary}^v}24
@24@0:8^v16
@32@0:8^{__CFData=}16Q24
v32@0:8^{__C3DMesh=}16@24
@36@0:8^{__C3DDeformerStack=}16^{__C3DNode=}24C32
@44@0:8^{__C3DSkinner=}16^{__C3DMesh=}24C32@?36
@44@0:8^{__C3DMorpher={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DGeometry}^{__C3DMorph}^{__C3DMesh}II^fII}16^{__C3DMesh=}24C32@?36
@"SCNMTLShaderBindingsGenerator"
@"SCNMTLBufferAllocator"
{?="registry"@"NSMapTable""lock"{os_unfair_lock_s="_os_unfair_lock_opaque"I}}
@"SCNMTLShadableKey"
@"MTKTextureLoader"
v24@0:8^{__C3DNode=}16
^{__C3DNode=}16@0:8
@"AVAudioNode"
@"AVAudioPlayerNode"
@"SCNAudioSource"
^{__C3DNode=}
@32@0:8r^{btPersistentManifold=i[4{btManifoldPoint={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffiiii^vBfffffffi{btVector3=(?=[4f])}{btVector3=(?=[4f])}}]^{btCollisionObject}^{btCollisionObject}iffiii^{c3dContactCallback}}16q24
v96@0:8@16@24{SCNVector3=ddd}32{SCNVector3=ddd}56d80d88
v40@0:8r^{btPersistentManifold=i[4{btManifoldPoint={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffiiii^vBfffffffi{btVector3=(?=[4f])}{btVector3=(?=[4f])}}]^{btCollisionObject}^{btCollisionObject}iffiii^{c3dContactCallback}}16q24r^{btManifoldPoint={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffiiii^vBfffffffi{btVector3=(?=[4f])}{btVector3=(?=[4f])}}32
^{btCollisionShape=^^?i^v}32@0:8@16@24
v44@0:8{SCNVector3=ddd}16B40
v68@0:8{SCNVector3=ddd}16{SCNVector3=ddd}40B64
v52@0:8{SCNVector4=dddd}16B48
@"SCNPhysicsShape"
@24@0:8^{__C3DParametricGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=ffffffffffffiiiiiiiiiiiI}{?=^?^?^?^?^?^?}^{__CFData}}16
v24@0:8^{__C3DParametricGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=ffffffffffffiiiiiiiiiiiI}{?=^?^?^?^?^?^?}^{__CFData}}16
@40@0:8d16d24d32
v64@0:8@16@24^{__C3DEngineContext=}3240d56
d40@0:8@16^{__C3DEngineContext=}24^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}32
@48@0:8@16@24Q32@?40
B36@0:8B16d20d28
^{__CVDisplayLink=}
^{SCNCActionRotate=^^?d@?@BdddddBB@?^{__CFString}qddddfBBBBB}
@40@0:8@16Q24@32
@24@0:8i16i20
@32@0:8^v16@24
^{btCollisionShape=^^?i^v}16@0:8
^{btCollisionShape=^^?i^v}
@128@0:8{?=^{__C3DFXMetalProgram}^{__C3DMaterial}^{__C3DGeometry}^{__C3DFXPass}^{__C3DFXPass}@^{__C3DBlendStates}^{__C3DNode}CCCCCC@{?=C@?}Q}16@120
^{__C3DFXMetalProgram=}20@0:8B16
v376@0:8@16{?={?=^{__C3DFXMetalProgram}^{__C3DMaterial}^{__C3DGeometry}^{__C3DFXPass}^{__C3DFXPass}@^{__C3DBlendStates}^{__C3DNode}CCCCCC@{?=C@?}Q}@{?=[8Q]QQC}^{__C3DBlendStates}[8Q]C@@@@@@@?CBBB}24@368
@360@0:8{?={?=^{__C3DFXMetalProgram}^{__C3DMaterial}^{__C3DGeometry}^{__C3DFXPass}^{__C3DFXPass}@^{__C3DBlendStates}^{__C3DNode}CCCCCC@{?=C@?}Q}@{?=[8Q]QQC}^{__C3DBlendStates}[8Q]C@@@@@@@?CBBB}16
@64@0:8{?=@@@@?BBB}16@56
@44@0:8@16@24@32B40
@56@0:8@16@24@?32@40@48
@40@0:8^{CGColorSpace=}16^{CGColorSpace=}24@32
@68@0:8I16@20@28@36^{CGColorSpace=}44^{CGColorSpace=}52@60
@"NSArrayController"
@"NSObject"
@"NSTableView"
@"NSValue"
@"SCNUIVector4TextField"
{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}24@0:8@16
v24@0:8^{__C3DEngineNotificationQueue={__CFRuntimeBase=QAQ}^{__CFDictionary}^{__CFDictionary}{os_unfair_lock_s=I}dBBB^v}16
^{__C3DEngineNotificationQueue={__CFRuntimeBase=QAQ}^{__CFDictionary}^{__CFDictionary}{os_unfair_lock_s=I}dBBB^v}16@0:8
@80@0:8@16{SCNVector3=ddd}24@48{SCNVector3=ddd}56
@48@0:8@16{SCNVector3=ddd}24
{?="bodyA"@"SCNPhysicsBody""bodyB"@"SCNPhysicsBody""anchorA"{SCNVector3="x"d"y"d"z"d}"anchorB"{SCNVector3="x"d"y"d"z"d}}
^{btPoint2PointConstraint=^^?ii(?=i^v)fBBi^{btRigidBody}^{btRigidBody}ff^{btJointFeedback}[3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}]{btVector3=(?=[4f])}{btVector3=(?=[4f])}iffB{btConstraintSetting=fff}}
^{c3dPhysicsField=^^?{?=[4]}{?=[4]}fffIBBBBf}16@0:8
^{c3dPhysicsField=^^?{?=[4]}{?=[4]}fffIBBBBf}
@24@0:8^{__C3DFXTechnique={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}qq^^{__C3DFXPass}b1b1b1b1b1I^{?}^{__CFDictionary}^{__C3DNode}^{__CFArray}^{__C3DFXTechnique}^v^{__CFString}^{__CFString}}16
^{__C3DFXTechnique={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}qq^^{__C3DFXPass}b1b1b1b1b1I^{?}^{__CFDictionary}^{__C3DNode}^{__CFArray}^{__C3DFXTechnique}^v^{__CFString}^{__CFString}}16@0:8
^{__C3DFXTechnique={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}qq^^{__C3DFXPass}b1b1b1b1b1I^{?}^{__CFDictionary}^{__C3DNode}^{__CFArray}^{__C3DFXTechnique}^v^{__CFString}^{__CFString}}
^{?=^{__C3DFXPass}^{__C3DFXTechnique}^v^{__C3DEngineContext}^{__C3DCullingContext}^{__C3DFXProgramObject}d^v^{__C3DRendererElement}qCC}
@32@0:8^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[8{?=CCCb1b1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}[9f]^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}C^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}@?@?^{__CFDictionary}^v}16@24
^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[8{?=CCCb1b1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}[9f]^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}C^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}@?@?^{__CFDictionary}^v}
@24@0:8^{__C3DMorph=}16
#24@0:8@16
^{__C3DMorph=}16@0:8
d24@0:8@16
v32@0:8d16Q24
d24@0:8Q16
d32@0:8Q16r^v24
v80@0:8@16@24@32@40@48@56@64@72
^{__C3DMorph=}
@"SCNFixedSizePage"
@"NSMutableIndexSet"
@40@0:8r^v16Q24@32
@"CALayer"16@0:8
@24@0:8@"NSString"16
@56@0:8{SCNVector4=dddd}16@48
@48@0:8{SCNVector3=ddd}16@40
@152@0:8{CATransform3D=dddddddddddddddd}16@144
v32@0:8@"CAAnimation"16@"NSString"24
v32@0:8@16@"NSString"24
@"CAMediaTimingFunction"16@0:8
v24@0:8@"CAMediaTimingFunction"16
@"NSColor"48@0:8d16d24d32d40
v24@0:8^{CGPath=}16
@"<SCNCameraControlConfiguration>"16@0:8
@"SCNCameraController"16@0:8
@"CAAnimation"16@0:8
v24@0:8@"CAAnimation"16
@24@0:8@"CAAnimation"16
@"SCNPhysicsBody"16@0:8
@128@0:8@"SCNPhysicsBody"16{SCNVector3=ddd}24{SCNVector3=ddd}48@"SCNPhysicsBody"72{SCNVector3=ddd}80{SCNVector3=ddd}104
@72@0:8@"SCNPhysicsBody"16{SCNVector3=ddd}24{SCNVector3=ddd}48
v40@0:8@"NSString"16q24@?<v@?@"<SCNBufferStream>"@"SCNNode"@"<SCNShadable>"@"SCNRenderer">32
v40@0:8@"NSString"16@"NSString"24@"NSDictionary"32
@"NSString"24@0:8@"NSString"16
@"<SCNProgramDelegate>"16@0:8
v24@0:8@"<SCNProgramDelegate>"16
v24@0:8@"<MTLLibrary>"16
d24@0:8q16
@"SCNMorpher"16@0:8
@"SCNGeometry"16@0:8
@32@0:8@"SCNGeometry"16d24
v72@0:8d16{CGRect={CGPoint=dd}{CGSize=dd}}24@"<MTLCommandBuffer>"56@"MTLRenderPassDescriptor"64
v64@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16@"<MTLCommandBuffer>"48@"MTLRenderPassDescriptor"56
v32@0:8@"NSArray"16d24
@32@0:8^v16@"NSDictionary"24
@32@0:8@"<MTLDevice>"16@"NSDictionary"24
v24@0:8@"SCNAudioPlayer"16
v32@0:8@"SCNNode"16Q24
v32@0:8@"SCNNode"16@"SCNNode"24
@"SCNNode"28@0:8@"NSString"16B24
@"NSArray"24@0:8@?<B@?@"SCNNode"^B>16
v24@0:8@?<v@?@"SCNNode"^B>16
{SCNVector3=ddd}48@0:8{SCNVector3=ddd}16@"SCNNode"40
{CATransform3D=dddddddddddddddd}152@0:8{CATransform3D=dddddddddddddddd}16@"SCNNode"144
@"NSArray"72@0:8{SCNVector3=ddd}16{SCNVector3=ddd}40@"NSDictionary"64
v24@0:8@"SCNParticleSystem"16
@"SCNNode"24@0:8@"NSString"16
@"SCNLight"16@0:8
v24@0:8@"SCNLight"16
@"SCNCamera"16@0:8
v24@0:8@"SCNCamera"16
v24@0:8@"SCNGeometry"16
@"SCNSkinner"16@0:8
v24@0:8@"SCNSkinner"16
v24@0:8@"SCNMorpher"16
v24@0:8@"SCNPhysicsBody"16
@"SCNPhysicsField"16@0:8
v24@0:8@"SCNPhysicsField"16
@"<SCNNodeRendererDelegate>"16@0:8
v24@0:8@"<SCNNodeRendererDelegate>"16
@"SCNNode"24@0:8@"SCNGeometry"16
@24@0:8@"MDLObject"16
@80@0:8@"SCNPhysicsBody"16{SCNVector3=ddd}24@"SCNPhysicsBody"48{SCNVector3=ddd}56
@48@0:8@"SCNPhysicsBody"16{SCNVector3=ddd}24
v32@0:8@"SCNMaterial"16Q24
v32@0:8Q16@"SCNMaterial"24
@"SCNMaterial"24@0:8@"NSString"16
@"NSArray"24@0:8@"NSString"16
@"SCNGeometryElement"24@0:8q16
@"SCNMaterial"16@0:8
v24@0:8@"SCNMaterial"16
@"SCNGeometryTessellator"16@0:8
v24@0:8@"SCNGeometryTessellator"16
@"SCNGeometryElement"16@0:8
v24@0:8@"SCNGeometryElement"16
@"SCNGeometrySource"16@0:8
v24@0:8@"SCNGeometrySource"16
@32@0:8@"NSArray"16@"NSArray"24
@40@0:8@"NSArray"16@"NSArray"24@"NSArray"32
@24@0:8@"MDLMesh"16
@"SCNMaterialProperty"16@0:8
@"NSURL"16@0:8
v24@0:8@"NSURL"16
@24@0:8@"MDLLight"16
@24@0:8@"MDLMaterial"16
v40@0:8q16@"NSArray"24@?<v@?^^v^Q^Iq>32
v40@0:8@"NSArray"16q24@?<v@?^^v^Qqqf>32
@"SCNParticleSystem"16@0:8
@32@0:8@"NSString"16@"NSString"24
@24@0:8@"SCNNode"16
@32@0:8@"SCNGeometry"16@"NSDictionary"24
@32@0:8@"SCNNode"16@"NSDictionary"24
{_NSRange=QQ}16@0:8
@60@0:8@16q24q32q40B48q52
@48@0:8@16q24q32q40
@60@0:8@"NSData"16q24q32q40B48q52
@48@0:8@"NSData"16q24q32q40
@24@0:8@"MDLSubmesh"16
@76@0:8@16@24q32B40q44q52q60q68
@32@0:8r^{SCNVector3=ddd}16q24
@32@0:8r^{CGPoint=dd}16q24
@76@0:8@"NSData"16@"NSString"24q32B40q44q52q60q68
@"SCNScene"32@0:8@"NSDictionary"16@?<v@?fq@"NSError"^B>24
@"SCNScene"32@0:8@"NSDictionary"16^@24
@32@0:8@"NSString"16#24
@"NSArray"24@0:8#16
@"NSArray"24@0:8@?<B@?@@"NSString"^B>16
@32@0:8@"NSURL"16@"NSDictionary"24
@32@0:8@"NSData"16@"NSDictionary"24
@24@0:8@"MDLCamera"16
v32@0:8d16@"SCNNode"24
d24@0:8@"SCNNode"16
v32@0:8@16@"<NSCopying>"24
@"SCNTechnique"24@0:8@"NSDictionary"16
@"SCNTechnique"24@0:8@"NSArray"16
v24@0:8@"SCNPhysicsBehavior"16
@"NSArray"40@0:8@"SCNPhysicsBody"16@"SCNPhysicsBody"24@"NSDictionary"32
@"NSArray"32@0:8@"SCNPhysicsBody"16@"NSDictionary"24
@"NSArray"288@0:8@"SCNPhysicsShape"16{CATransform3D=dddddddddddddddd}24{CATransform3D=dddddddddddddddd}152@"NSDictionary"280
@"<SCNPhysicsContactDelegate>"16@0:8
v24@0:8@"<SCNPhysicsContactDelegate>"16
@"SCNPhysicsShape"16@0:8
v24@0:8@"SCNPhysicsShape"16
@32@0:8q16@"SCNPhysicsShape"24
@28@0:8B16@?20
@28@0:8B16@?<{CATransform3D=dddddddddddddddd}@?@"SCNNode"{CATransform3D=dddddddddddddddd}>20
@28@0:8B16@?<{SCNVector3=ddd}@?@"SCNNode"{SCNVector3=ddd}>20
@28@0:8B16@?<{SCNVector4=dddd}@?@"SCNNode"{SCNVector4=dddd}>20
@32@0:8d16@?<v@?@"<SCNAnimation>"@B>24
@"SCNAction"16@0:8
@?<f@?f>16@0:8
v24@0:8@?<f@?f>16
@"SCNAction"48@0:8d16d24d32d40
@"SCNAction"48@0:8{SCNVector3=ddd}16d40
@"SCNAction"52@0:8d16d24d32d40B48
@"SCNAction"56@0:8d16{SCNVector3=ddd}24d48
@"SCNAction"56@0:8{SCNVector4=dddd}16d48
@"SCNAction"32@0:8d16d24
@"SCNAction"24@0:8@"NSArray"16
@"SCNAction"32@0:8@"SCNAction"16Q24
@"SCNAction"24@0:8@"SCNAction"16
@"SCNAction"24@0:8d16
@"SCNAction"24@0:8@?<v@?@"SCNNode">16
@"SCNAction"32@0:8@?<v@?@"SCNNode">16@"NSObject<OS_dispatch_queue>"24
@"SCNAction"32@0:8@"NSString"16d24
@"SCNAction"32@0:8d16@?<v@?@"SCNNode"d>24
v152@0:8@"SCNParticleSystem"16{CATransform3D=dddddddddddddddd}24
B48@0:8@"NSURL"16@"NSDictionary"24@"<SCNSceneExportDelegate>"32@?<v@?f@"NSError"^B>40
@"SCNPhysicsWorld"16@0:8
@40@0:8@"NSString"16@"NSString"24@"NSDictionary"32
@40@0:8@"NSURL"16@"NSDictionary"24^@32
@24@0:8@"MDLAsset"16
@32@0:8@"SCNPhysicsBody"16@"NSArray"24
@"SCNPhysicsField"32@0:8d16d24
@"SCNPhysicsField"24@0:8@?<{SCNVector3=ddd}@?{SCNVector3=ddd}{SCNVector3=ddd}ffd>16
v48@0:8^{__C3DEngineContext=}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24^d32^{?=BB}40
v60@0:8@16{CGSize=dd}24B40B44@48B56
v56@0:8@16{CGSize=dd}24B40B44@48
d76@0:8@16@24^{__C3DEngineContext=}3240d56B64^B68
d48@0:8@16@24^{__C3DEngineContext=}32^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}40
@40@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16^{__C3DMesh=}24@32
v40@0:8^{__C3DScene=}16@24@?32
v48@0:8^{__C3DScene=}16@24@32@?40
v64@0:8^{__C3DScene=}16@24@32Q40@48@?56
v64@0:8^{__C3DScene=}16@24@32@40@48@?56
@24@0:8^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}16
@32@0:8r^d16q24
@40@0:8r^{SCNVector3=ddd}16q24^q32
@40@0:8r^{CGPoint=dd}16q24^q32
@68@0:8@16@24q32s40Q44q52q60
@44@0:8r^f16q24B32^{CGColorSpace=}36
@76@0:8@16^{CGColorSpace=}24q32B40q44q52q60q68
@64@0:8@16Q24@32q40q48q56
@84@0:8@16@24^{CGColorSpace=}32q40B48q52q60q68q76
@96@0:8@16^{CGColorSpace=}24^^{CGColorSpace}32q40q48q56q64q72^q80^q88
s16@0:8
^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}16@0:8
@56@0:8@16Q24Q32Q40Q48
^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}
^{CGColorSpace=}
@24@0:8^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}II^{__C3DMeshElement}CCC{?=c^{__CFData}I^I^{?}SCB}^vfff^v^{__C3DMeshSource}[2]^{?}I}16
^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}II^{__C3DMeshElement}CCC{?=c^{__CFData}I^I^{?}SCB}^vfff^v^{__C3DMeshSource}[2]^{?}I}16@0:8
^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}II^{__C3DMeshElement}CCC{?=c^{__CFData}I^I^{?}SCB}^vfff^v^{__C3DMeshSource}[2]^{?}I}
@24@0:8^{__IOHIDDevice=}16
v28@0:8I16@20
^{__IOHIDDevice=}
^{__IOHIDManager=}
24@0:8@16
{CATransform3D=dddddddddddddddd}144@0:8{CATransform3D=dddddddddddddddd}16
v24@0:8f16B20
v40@0:816q32
B32@0:8^{__C3DNode=}16^{C3DSphere=}24
{C3DSphere=}16@0:8
v48@0:8{CGPoint=dd}16q32Q40
(C3DMatrix4x4="components"[16f]"m"[4]"simd"{?="columns"[4]})
{C3DSphere="vector"}
B24@0:8@"NSEvent"16
@"SCNView"16@0:8
v24@0:8@"SCNView"16
v24@0:8@"SCNCameraController"16
(?={?=ffff})16@0:8
(?="vector""center"""{?="x"f"y"f"z"f"radius"f})
{?="stickyMoveEnabled"B"direction""pickedAxis"Q"userStickyAxis"Q}
{?="automaticLocationUpToDate"B"hasAutomatic"B}
{?="lastDragLocation"{CGPoint="x"d"y"d}"velocity"{CGPoint="x"d"y"d}"lastDragTime"d}
{?="lock"{os_unfair_lock_s="_os_unfair_lock_opaque"I}"keyCodeConfiguration"@"NSDictionary""keyDown"{set<unsigned short, std::less<unsigned short>, std::allocator<unsigned short>>="__tree_"{__tree<unsigned short, std::less<unsigned short>, std::allocator<unsigned short>>="__begin_node_"^v"__pair1_"{__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<unsigned short, void *>>>="__value_"{__tree_end_node<std::__tree_node_base<void *> *>="__left_"^v}}"__pair3_"{__compressed_pair<unsigned long, std::less<unsigned short>>="__value_"Q}}}"forward"{vector<unsigned short, std::allocator<unsigned short>>="__begin_"^S"__end_"^S"__end_cap_"{__compressed_pair<unsigned short *, std::allocator<unsigned short>>="__value_"^S}}"backward"{vector<unsigned short, std::allocator<unsigned short>>="__begin_"^S"__end_"^S"__end_cap_"{__compressed_pair<unsigned short *, std::allocator<unsigned short>>="__value_"^S}}"left"{vector<unsigned short, std::allocator<unsigned short>>="__begin_"^S"__end_"^S"__end_cap_"{__compressed_pair<unsigned short *, std::allocator<unsigned short>>="__value_"^S}}"right"{vector<unsigned short, std::allocator<unsigned short>>="__begin_"^S"__end_"^S"__end_cap_"{__compressed_pair<unsigned short *, std::allocator<unsigned short>>="__value_"^S}}}
{?="hasShift"B"hasOption"B}
@"SCNCameraController"
@"<SCNCameraNavigationControllerDelegate>"
B32@0:8@16#24
B40@0:8@16^d24^d32
@32@0:8@?16i24B28
v36@0:8@16i24@?28
v40@0:8@16i24B28@?32
v40@0:8@?16@?24@?32
q40@0:8@16@24Q32
v64@0:8@16@24^{__C3DFXMetalProgram={__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}[2^{__CFString}]^{__CFString}^{__CFString}^{__CFDictionary}^{__CFSet}^v^{__CFDictionary}i@?@?QI}32^{__C3DMaterial=}40^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}48^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[8{?=CCCb1b1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}[9f]^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}C^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}@?@?^{__CFDictionary}^v}56
{?="stage"i"arguments"@"NSArray""customBlocks"@"NSDictionary""pass"^{__C3DFXPass}}
B64@0:8@16{CGSize=dd}24Q40@48^@56
@72@0:8@16{CGSize=dd}24@40@48:56^v64
@56@0:8@16@24@32:40^v48
@"NSError"
@56@0:8@16{CGSize=dd}24@40@48
v56@0:8^{CGImage=}16{?=qiIq}24@48
v72@0:8{?=qiIq}16@40^{__CVMetalTextureCache=}48@56@?64
@"AVAssetWriterInput"
@"AVAssetWriterInputPixelBufferAdaptor"
@"AVAssetWriter"
@120@0:8{?=@@{CGPoint=dd}{CGPoint=dd}{SCNVector3=ddd}{SCNVector3=ddd}d}16
v120@0:8{?=@@{CGPoint=dd}{CGPoint=dd}{SCNVector3=ddd}{SCNVector3=ddd}d}16
B120@0:8{?=@@{CGPoint=dd}{CGPoint=dd}{SCNVector3=ddd}{SCNVector3=ddd}d}16
r^{?=f^vf}32@0:8Q16Q24
v52@0:8S162036
116@0:816{SCNVector3=ddd}32d56B646884^B100^q108
@"NSOrderedSet"
(?="axisMove"{?="originalPosition""axisDirection""mouseDeltaVector"}"planeMove"{?="originalPosition""planeNormal""pointInPlane""mouseDeltaVector"}"axisRotate"{?="rotationSign"f"originalRotation"})
{?="positions"^"orientations"^"originalLocalMatrix"^{CATransform3D}"scales"^}
^{?=f^vf}
@"SCNBillboardConstraint"
^{__C3DConstraint={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__CFString}fBB{?=^?^?^?^?^?^?}^v}16@0:8
v24@0:8^{__C3DConstraint={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__CFString}fBB{?=^?^?^?^?^?^?}^v}16
^{__C3DConstraint={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__CFString}fBB{?=^?^?^?^?^?^?}^v}
@"<SCNMetalLibraryProvider>"
@"<MTLLibrary>"24@0:8@"<MTLDevice>"16
B48@0:8@16I24I28@32@40
v48@0:8@16I24I28@32@40
^{__C3DFXTechnique=}16@0:8
^{__C3DFXGLSLProgram=}24@0:8q16
v32@0:8^{__C3DFXGLSLProgram=}16@24
@"SCNProgram"
@"NSNumber"
@64@0:8@16@24@32@40q48Q56
@"<SCNShadable>"
v24@0:8^{__C3DTextGeometry={__C3DShapeGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__C3DMesh}[16C]}{?=^{__CTFrame}^v^viiBBB{CGRect={CGPoint=dd}{CGSize=dd}}}}16
@24@0:8^{__C3DTextGeometry={__C3DShapeGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__C3DMesh}[16C]}{?=^{__CTFrame}^v^viiBBB{CGRect={CGPoint=dd}{CGSize=dd}}}}16
{?={?=cddid^v^v}^v^viiBB{CGRect={CGPoint=dd}{CGSize=dd}}d}16@0:8
@"NSBezierPath"
@"NSFont"
{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}
v88@0:8^{?=fIIQQ}16^{?=I^{__C3DGeometry}^{__C3DMeshSource}^{__C3DMeshSource}Q}24*32Q40*48Q56Q64^I72@80
v72@0:8^{?=fIIQQ}16^{?=I^{__C3DGeometry}^{__C3DMeshSource}^{__C3DMeshSource}Q}24*32Q40Q48^I56@64
Q40@0:8@16@24@32
^{__C3DMorpher={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DGeometry}^{__C3DMorph}^{__C3DMesh}II^fII}
^{?=fIIQQ}
v24@0:8^{__C3DShapeGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__C3DMesh}[16C]}16
@24@0:8^{__C3DShapeGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__C3DMesh}[16C]}16
{?=cddid^v^v}16@0:8
{?="bodyA"@"SCNPhysicsBody""bodyB"@"SCNPhysicsBody""anchorA"{SCNVector3="x"d"y"d"z"d}"anchorB"{SCNVector3="x"d"y"d"z"d}"axisA"{SCNVector3="x"d"y"d"z"d}"axisB"{SCNVector3="x"d"y"d"z"d}}
^{btHingeConstraint=^^?ii(?=i^v)fBBi^{btRigidBody}^{btRigidBody}ff^{btJointFeedback}[3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}][3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}]{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}ff{btAngularLimit=fffffffB}ffffBBBBBfifff}
v40@0:8@16q24d32
@40@0:8@16q24^{__C3DLOD=}32
^{__C3DLOD=}
v40@0:8@16@24#32
@32@0:8@16^Q24
@48@0:8C16^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}20s28B32B36^Q40
@76@0:8C16^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}20^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}28s36s40B44B48^Q52^Q60^Q68
@"<MTLBuffer>"32@0:8@"<MTLBlitCommandEncoder>"16^Q24
@"<MTLBuffer>"48@0:8C16^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}20s28B32B36^Q40
@"<MTLBuffer>"76@0:8C16^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}20^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}28s36s40B44B48^Q52^Q60^Q68
@"<MTLBlitCommandEncoder>"16@0:8
@"MTLStageInputOutputDescriptor"16@0:8
v24@0:8^{SCNMTLComputeCommandEncoder=[31@][31Q][128@][16@]@@@^{SCNMTLBufferPool}I[2Q][1Q]}16
{?={?=[4]}{?=[4]}{?=[4]}}16@0:8
^{SCNMTLComputeCommandEncoder=[31@][31Q][128@][16@]@@@^{SCNMTLBufferPool}I[2Q][1Q]}16@0:8
v24@0:8@?<v@?@"<MTLCommandBuffer>">16
^{__CFString=}16@0:8
#24@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^{?}^{?}{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16
v46@0:8@?16@?24@?32{?=BBBBBB}40
v20@0:8{?=BBBB}16
v25@0:8@16{?=B}24
{?=[6]}16@0:8
v32@0:8^{?=@@@@@@@@@@@@}16@24
^{__C3DDeformerStack=}
^{__C3DMesh=}
{?="isActive"B"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}
{?="maxIndex"I}
@"<MTLBlitCommandEncoder>"
{?="modelViewTransform"{?="columns"[4]}"modelViewProjectionTransform"{?="columns"[4]}"projectionTransform"{?="columns"[4]}}
{?="screenResolution""worldPlanes"[6]}
^{SCNMTLComputeCommandEncoder=[31@][31Q][128@][16@]@@@^{SCNMTLBufferPool}I[2Q][1Q]}
{?="srcPositions"@"<MTLBuffer>""dstPositions"@"<MTLBuffer>""srcNormals"@"<MTLBuffer>""dstNormals"@"<MTLBuffer>""srcTangents"@"<MTLBuffer>""dstTangents"@"<MTLBuffer>""dependency0Positions"@"<MTLBuffer>""dependency0Normals"@"<MTLBuffer>""dependency0Tangents"@"<MTLBuffer>""dependency1Positions"@"<MTLBuffer>""dependency1Normals"@"<MTLBuffer>""dependency1Tangents"@"<MTLBuffer>"}
@"SCNMTLMorphDeformer"
@"SCNMTLSkinDeformer"
@"<SCNMTLMeshlessDeformer>"
@"SCNMTLSmoothNormalsDeformer"
v32@0:8@"MTLStageInputOutputDescriptor"16@"<MTLFunction>"24
@"<MTLComputeCommandEncoder>"16@0:8
@"SCNMTLDeformerStack"
@"SCNGeometryDeformer"
@"<SCNGeometryDeformerInstance>"
{?="srcPositions"{?="isActive"B"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"dstPositions"{?="isActive"B"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"srcNormals"{?="isActive"B"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"dstNormals"{?="isActive"B"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"srcTangents"{?="isActive"B"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"dstTangents"{?="isActive"B"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"dependency0Positions"{?="isActive"B"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"dependency0Normals"{?="isActive"B"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"dependency0Tangents"{?="isActive"B"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"dependency1Positions"{?="isActive"B"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"dependency1Normals"{?="isActive"B"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}"dependency1Tangents"{?="isActive"B"bufferAttributeFormat"Q"bufferAttributeOffset"Q"bufferLayoutStride"Q}}
@"<MTLComputeCommandEncoder>"
ABGR
ARGB
ABGR
AhGR
AfGR
v024
f024
v224
f224
v444
f444
?$R2
7> }#>
