path
encoding
files
tables
text
binary
warning
stringsAndStringsdict
stringsdictOnly
stringsdata
xcstrings
strings
_TtC13xcstringstool31SwiftLocalizableStringCollector
thingsToExtract
$__lazy_storage_$_extractableFunctionBaseNames
localizableStrings
importedSwiftUI
 (specified on command-line as 
_TtC13xcstringstool16SourceCodeBuffer
contents
indexCursor
locationCursor
cachedLineNumbersToStringIndices
_TtC13xcstringstool17XCStringsCompiler
inputFile
outputDirectory
specifiedLanguages
options
fileManager
xcstringstool/ExtractionOptions.swift
xcstringstool/ExtractionCriteria.swift
onlyTablesToProcess
_TtC13xcstringstoolP33_8C723CA5F89161A7842F8864CA90A15E15StringsdataPool
$defaultActor
stringsdataURLs
Skipping source file because it is not a supported file type: '
Failed to process source file '
_TtC13xcstringstool14SwiftExtractor
fileURL
parsedFile
sourceBuffer
The output format for individual files that can have different representations
Force all strings to build, including source strings that are already present in source code.
Caution must be used when combining with the sync command, since a sync operation may change the build result when using this option.
serializationFormat
forceBuildAllStrings
_TtC13xcstringstool27SwiftStringLiteralCollector
stringLiterals
' conflicts with compiled set element for '
Extract all Swift string literals that could potentially be string keys.
This generally includes all string literals, except for those which we can prove are definitely not being used as localization keys (without performing any type checking). If specified alongside other extraction criteria, the __PotentialKeys table will not include keys that get extracted into other tables.
Legacy name for --all-potential-swift-keys.
Extract from NSLocalizedString and sibling macros and functions.
This mode mimics genstrings.
Extract from String(localized:), AttributedString(localized:), and LocalizedStringResource inits.
Specify custom localization functions or C macros that should additionally be extracted.
Each value should be the base name of a function that matches the signature of NSLocalizedString. Variants that accept tables, bundles, and default values are automatically included. You can specify this option multiple times.
Extract from SwiftUI Text()
This mode mimics the -SwiftUI option in genstrings.
Extract from various SwiftUI APIs
This mode also extracts Text(). It is not recommended to mix this option with --SwifTUI-Text, which performs legacy genstrings-style Text() extraction.
allPotentialSwiftKeys
allSwiftLiterals
legacyLocalizableStrings
modernLocalizableStrings
userFunctionNames
_TtC13xcstringstool17SwiftSourceBuffer
converter
$__lazy_storage_$_lines
_TtC13xcstringstool15CStyleExtractor
presumedEncoding
Skipping extraction of localizable string with non-literal key
Skipping extraction of localizable string with non-static table name
The contents of string interpolations in localization comments will not be extracted
Cannot extract non-literal comment for localization
Skipping extraction of localizable string because we aren't certain about the format specifier to use for an interpolation
String interpolation may prevent proper localization in this context
Cannot extract non-literal value for localization
Skipping extraction of localizable string because string interpolation is not supported in this context
Work with .xcstrings files
Prints all string keys represented in an xcstrings file.
Produces build products for an .xcstrings file.
Updates an .xcstrings file based on strings present in .stringsdata files.
Extracts strings from source code files.
--all-potential-swift-keys is only supported with the default --output-format of "stringsdata"
The source code files to extract from.
A plist with paths to input files, which can be used instead of passing file paths directly as arguments.
The directory to place output .stringsdata files.
Don't extract from certain localization tables.
May be specified multiple times.
Only extract from certain tables.
The .xcstrings files to merge into.
.stringsdata files specifying the strings used from source.
Prevents marking strings stale and/or removing them from the .xcstrings when not found in the .stringsdata.
The path to the .xcstrings file to compile.
The directory to place output files.
The output format for the overall compilation
If specified, outputs a newline-separated list of output paths that would be produced by a compilation, but does not actually compile anything.
Optionally specify particular languages to compile.
You can pass as many of these options as you want.
The path to the .xcstrings file to print.
skipMarkingStringsStale
--append is not supported when using the default --output-format of "stringsdata"
extract-from-comments
Extract NSLocalizedString and sibling macros even from code comments.
Disables printing of detailed source code line info alongside diagnostics.
This can increase performance. This flag also changes the behavior of printed column numbers to represent UTF-8 byte offsets instead of grapheme cluster offsets. An additional column length (in UTF-8 bytes) is also added.
Prevents xcstringstool from writing .stringsdata files that would contain no strings.
Prevents inclusion of localizable strings where we don't know the format specifier to use for interpolations.
Otherwise %arg would be used when uncertain.
Specifies the final output format for extracted strings.
The default value is "stringsdata", but "xcstrings" or "strings" can also be specified. Note that Xcode separately supports auto-generating xcstrings when exporting/importing localizations without the use of this flag. You can additionally specify the --append flag if you need to add to existing files in the output directory. Because xcstringstool does not invoke the compiler, it cannot always determine the correct format specifiers to use for string interpolations.
When using an --output-format of xcstrings or strings, adds extracted strings to any existing files in the --output-directory.
For "strings" mode, entries will simply be appended to the end of the file with no duplicate key detection. When using "xcstrings" mode, newly extracted values will replace any existing values from duplicate keys. If this flag is not passed, any existing files with the same name will be overwritten.
extractFromCodeComments
shouldDisableLineHints
omitEmptyStringsdata
avoidArgPlaceholder
_TtC13xcstringstool18SwiftStringVisitor
enclosingMacroRange
enclosingMacroID
enclosingVisibilityStack
xcstringstool.SwiftStringVisitor
init(viewMode:)
    opts="$opts 
    if [[ $COMP_CWORD == "
" ]]; then
        COMPREPLY=( $(compgen -W "$opts" -- "$cur") )
        return
    fi
    case ${COMP_WORDS[
    return
    ;;
    COMPREPLY=( $(compgen -W "$opts" -- "$cur") )
cur="${COMP_WORDS[COMP_CWORD]}"
prev="${COMP_WORDS[COMP_CWORD-1]}"
COMPREPLY=()
COMPREPLY=( $(compgen -W "$("${COMP_WORDS[0]}" 
 "${COMP_WORDS[@]}")" -- "$cur") )
COMPREPLY=( $(compgen -W "
COMPREPLY=( $(compgen -d -- "$cur") )
COMPREPLY=( $(compgen -f -- "$cur") )
$("${COMP_WORDS[0]}" ---completion 
 "${COMP_WORDS[@]}")
ArgumentParser/CompletionsGenerator.swift
Invalid CompletionShell: 
SHELL
function _swift_
_using_command
    set -l cmd (commandline -opc)
    if [ (count $cmd) -eq (count $argv) ]
        for i in (seq (count $argv))
            if [ $cmd[$i] != $argv[$i] ]
                return 1
            end
        end
        return 0
    end
    return 1
-f -a '(command 
 -- --custom (commandline -opc)[1..-1])'
-f -a '(__fish_complete_directories)'
-f -a '(for i in 
local context state state_descr line
_commandname=$words[1]
typeset -A opt_args
_custom_completion() {
    local completions=("${(@f)$($*)}")
    _describe '' completions
'(-): :->command'
case $state in
    (command)
        local subcommands
        subcommands=(
        )
        _describe "subcommand" subcommands
        ;;
    (arg)
        case ${words[1]} in
        esac
        ;;
esac
() {
    integer ret=1
    local -a args
    args+=(
    )
    _arguments -w -s -S $args[@] && ret=0
    return ret
{_custom_completion $_
{local -a list; list=(${(f)"$(
)"}); _describe '''' list}
Show help information.
Show the version.
ArgumentParser/Argument.swift
--------------------------------------------------------------------
Can't read a value from a parsable
argument definition.
This error indicates that a property declared with an `@Argument`,
`@Option`, `@Flag`, or `@OptionGroup` property wrapper was neither
initialized to a value nor decoded from command-line arguments.
To get a valid value, either call one of the static parsing methods
(`parse`, `parseAsRoot`, or `main`) or define an initializer that
initializes _every_ property of your parsable type.
--------------------------------------------------------------------
Argument(*definition*)
--experimental-dump-help
ArgumentParser/Flag.swift
Flag(*definition*)
offset element 
ArgumentParser/NameSpecification.swift
' has not characters to form short option name.
ArgumentParser/Option.swift
Option(*definition*)
ArgumentParser/OptionGroup.swift
OptionGroup(*definition*)
Fatal error
Down-casted Array element failed to match the target type
Expected 
Tree<ParsableCommand.Type>
NSArray element failed to match the Swift Array Element type
Expected 
_TtC14ArgumentParser15ArgumentDecoder
values
usedOrigins
nextCommandIndex
previouslyDecoded
codingPath
userInfo
decoder
ArgumentParser/ArgumentDecoder.swift
experimental-dump-help
ArgumentParser/CommandParser.swift
Unexpected error: 
The ParsableCommand "
" can't have itself as its own subcommand.
generateCompletionScript
ArgumentParser/Parsed.swift
Trying to get the argument set from a resolved/parsed property.
Show subcommand help information.
 <subcommand>' for detailed help.
ArgumentParser/HelpGenerator.swift
' for more information.
Unspecified version
ArgumentParser/UsageGenerator.swift
preferredName cannot be nil for named arguments
Missing required subcommand.
Invalid option: -
Invalid option: 
' does not take any value, but '
' was specified.
Internal error. Invalid state while parsing command-line arguments.
Internal error. Parsing command-line arguments hit unimplemented code path.
Can't generate completion scripts for '
Please use --generate-completion-script=<shell> with one of:
    
Can't autodetect a supported shell.
Please use --generate-completion-script=<shell> with one of:
    
Unknown option '
'. Did you mean '
Missing value for '
 unexpected arguments: '
Unexpected argument '
Value to be set with 
 had already been set with 
Missing one of: '
Missing expected argument '
No value set for non-argument var 
. Replace with a static variable, or let constant.
' is invalid for '
' is invalid for '<
. Please provide one of the following:
. Please provide one of 
element
parent
children
long
short
longWithSingleDash
positional
option
flag
serializationVersion
defaultSubcommand
xcstringstool
SwiftLocalizableStringCollector
URLResourceKey
NNSURLResourceKey
Foundation
CStyleToken
Kind
CStyleLexer
XCStringsToLprojCompiler
Language
SourceCodeBuffer
SourceCodeCharacter
XCStringsCompiler
CodingKeys
SourceFileList
SourceCodeStringExtractor
StringsdataPool
FlattenedStringSetElement
FlattenedStringSet
SwiftExtractor
BalancedExpression
CStyleParser
CompilerOptions
CodingKeys
SwiftStringLiteralCollector
StringsAndStringsdictPair
LprojableFileFormat
SerializationFormat
NSFileHandle
Severity
SourceCodeDiagnostic
ExtractionCriteria
TableBasedExtractionCriteria
CodingKeys
SwiftSourceBuffer
CStyleExtractor
SourceCodeFile
StringsFile
XCStringsTool
CommandFailed
Extract
Sync
Compile
Print
CodingKeys
Format
ExtractionOptions
CodingKeys
OutputFormat
SwiftStringVisitor
ArgumentParser
CompletionShell
Argument
ArgumentArrayParsingStrategy
ArgumentHelp
ArgumentVisibility
Representation
CompletionKind
Kind
ValidationError
ExitCode
CleanExit
Representation
Flag
FlagInversion
FlagExclusivity
Representation
NameSpecification
Element
Representation
Option
SingleValueParsingStrategy
ArrayParsingStrategy
OptionGroup
AsyncParsableCommand
AsyncMainProtocol
Command
CommandConfiguration
EnumerableFlag
ExpressibleByArgument
ParsableArguments
ArgumentSetProvider
_WrappedParsableCommand
StandardError
CodingKeys
ParsableArgumentsValidator
ParsableArgumentsValidatorError
ParsableCommand
ArgumentDecoder
ParsedArgumentsContainer
ArrayWrapperProtocol
DecodedArguments
SingleValueDecoder
UnkeyedContainer
ArrayWrapper
SingleValueContainer
Error
ArgumentHelpOptionProvider
ArgumentDefinition
ParsingStrategy
Update
Help
Kind
Options
ArgumentSet
CommandError
AutodetectedGenerateCompletions
GenerateCompletions
HelpRequested
CodingKeys
InputOrigin
Element
Name
ParsedWrapper
Value
DecodableParsedWrapper
Parsed
ParsedValues
Element
InputKey
ParserError
InternalParseError
InputIndex
ParsedArgument
Value
Element
Index
SplitArguments
SubIndex
HelpCommand
CodingKeys
Element
HelpGenerator
Section
DiscussionSection
Header
MessageInfo
Tree
InitializationError
 @4D
ArgumentParserToolInfo
ToolInfoHeader
ToolInfoV0
CommandInfoV0
ArgumentInfoV0
NameInfoV0
KindV0
CodingKeys
ShySSGSg
2idt
_pSg
So8NSStringC
$sSY
$ss21_ObjectiveCBridgeableP
5lower_AA5uppert
SS_SNy
G5rangetSg
SS_SNy
G5ranget
SS3raw_t
ShySSG
SSSg
SDySi
SaySSG
So13NSFileManagerC
$sST
SnySiG
$sSl
$sSK
$sSk
ypSg
SDyS2SG
ySSG
yS2SG
$s13xcstringstool25SourceCodeStringExtractorP
SS3key_
5valuetSg
SS3key_
5valuet
Si6offset_
7elementt
Si6offset_
7elementtSg
ScGyytG
ySbG
ScPSg
ScA_pSg
ytIeghHr_
_pSg
SS3key_
5valuetSg
SS3key_
5valuet
SS3key_
5valuet
ySSG
ySnySiGG
2idtG
ySS_
SgSg
3key_SS5valuetSg
3key_SS5valuet
SS3key_
5valuetSg
$s13xcstringstool19LprojableFileFormatP
$ss12CaseIterableP
yypG
_pSg
SS3key_
_p5valuet
ySaySSGG
SDySS
ySNy
ySSSay
SaySSGSg
_pSgSg
SS3key_SSSg5valueAB7commentAB9tableName
8location
10visibilitytSg
SS3key_SSSg5valueAB7commentAB9tableName
8location
10visibilityt
_pXpG
3key_yp5valuetSg
_pXpG
ySay
ySay
SS3key_
5valuet
2idtG
_pXpG
SaySSG
SaySsG
$sSY
$ss12CaseIterableP
SSSg
ySSG
SaySSG_SSt
ySSG
qd__
$s14ArgumentParser13ParsedWrapperP
Sayqd__GSg
SSqd__
_pIeggrzo_
Sayqd__G
ypSg
_pIeggrzo_
qd__XMT
$ss32ExpressibleByStringInterpolationP
$ss26ExpressibleByStringLiteralP
$ss43ExpressibleByExtendedGraphemeClusterLiteralP
$ss33ExpressibleByUnicodeScalarLiteralP
SaySSG10extensions_t
SaySSGAAc
_pXpSg
SbSg
Sbz_Xx
$ss25ExpressibleByArrayLiteralP
SS_Sb14withSingleDasht
SJ_Sb14allowingJoinedt
_pSg
$s14ArgumentParser20AsyncParsableCommandP
$s14ArgumentParser17AsyncMainProtocolP
7Command
_pXpG
$s14ArgumentParser14EnumerableFlagP
$s14ArgumentParser013ExpressibleByA0P
yypG
$s14ArgumentParser17ParsableArgumentsP
$s14ArgumentParser0A11SetProviderP
SSSg5label_yp5valuet
_pSg
SSypSgIeggr_
$s14ArgumentParser26ParsableArgumentsValidator33_D8B6916CE93C2FC7F7BEDE789FAE65F8LLP
$s14ArgumentParser31ParsableArgumentsValidatorErrorP
$s14ArgumentParser15ParsableCommandP
_SitG
_Sit
_pXpG
ySsG
_SStG
_SSt
ySi_
_pXmTSg
$s14ArgumentParser20ArrayWrapperProtocolP
_pXp
$ss30KeyedDecodingContainerProtocolP
SayypG
yypG
_pXpGG
ySnySiGG
ySaySSG_SStG
ySiG
ySaySiGG
SaySiG
_pXp_AA_pXpt
SayxG
$s14ArgumentParser0A18HelpOptionProviderP
ztKc
ztKc
SgSS
ztKc
$ss10SetAlgebraP
$ss9OptionSetP
$sST
SnySiG
$sSl
$sSK
$sSk
yyXlG
_SStSg
SSxSgIeggr_
xXMT
_pSg
ySSG
ySbG
S2SSgIeggr_
$s14ArgumentParser22DecodableParsedWrapperP
5Value
_pXpGADG
10visibility_t
SSSg5shell_t
_SStG
8previous_AA9duplicateSaySSG13originalInputt
6forKey_t
SgSS
6forKey
_pSg13originalErrort
ypSg_
6forKeyt
Si_Sit
_SSt
Sb8inserted_
17memberAfterInsertt
ySaySSGG
SaySSGSg
_ypt
ySSSgG
yAAyABySaySSSgGACGGSSGG
yAAySaySSSgGACGGSSG
ySaySSSgGACGG
ySaySSSgGABG
SaySSSgG
ySay
GSSG
SS4text_t
SS7message_SS5usageSS4helpt
SS7message_
8exitCodet
yxGSgXw
yxGG
_pXpGACG
_pXpGACSgIegnr_
_pXp
SaySSGSg
SaySSG
$sSY
SSSg
thingsToExtract
$__lazy_storage_$_extractableFunctionBaseNames
localizableStrings
importedSwiftUI
_rawValue
RawValue
_ObjectiveCType
kind
location
secondaryContentStartingLocation
sourceBuffer
supportNestedMultiLineComments
identifier
stringLiteral
comment
other
null
comma
colon
semicolon
backslash
leftParen
rightParen
leftBracket
rightBracket
leftBrace
rightBrace
codeSpecifiedOnCommandLine
normalizedCode
contents
indexCursor
locationCursor
cachedLineNumbersToStringIndices
char
location
inputFile
outputDirectory
specifiedLanguages
options
fileManager
Element
Iterator
Index
SubSequence
Indices
path
encoding
files
tables
extractionCriteria
RawValue
$defaultActor
stringsdataURLs
Element
Iterator
Index
SubSequence
Indices
value
state
setKey
compiledElements
fileURL
parsedFile
sourceBuffer
lexer
shouldExtractFromComments
isCurrentlyExtractingFromComments
parens
brackets
braces
_serializationFormat
_forceBuildAllStrings
serializationFormat
forceBuildAllStrings
stringLiterals
stringsFile
stringsdictFile
text
binary
AllCases
RawValue
severity
message
filePath
location
lineContent
warning
RawValue
specsByTable
defaultSpec
wantsPotentialKeyExtraction
_allPotentialSwiftKeys
_allSwiftLiterals
_legacyLocalizableStrings
_modernLocalizableStrings
_userFunctionNames
_swiftUIText
_swiftUI
allPotentialSwiftKeys
allSwiftLiterals
legacyLocalizableStrings
modernLocalizableStrings
userFunctionNames
swiftUIText
swiftUI
converter
$__lazy_storage_$_lines
fileURL
presumedEncoding
sourceBuffer
fileURL
presumedEncoding
options
extractedStrings
usedCriteria
includePotentialKeysTableInStringsdata
$__lazy_storage_$_extractor
strings
comments
_inputFile
_outputDirectory
_format
_languages
_extraOptions
_dryRun
_xcstrings
_stringsdata
_skipMarkingStringsStale
_sourceFiles
_fileListPlist
_criteria
_tablesToSkip
_onlyTablesToProcess
stringsAndStringsdict
stringsdictOnly
sourceFiles
fileListPlist
outputDirectory
criteria
tablesToSkip
onlyTablesToProcess
extraOptions
xcstrings
stringsdata
skipMarkingStringsStale
inputFile
format
languages
dryRun
AllCases
RawValue
_extractFromCodeComments
_shouldDisableLineHints
_omitEmptyStringsdata
_avoidArgPlaceholder
_outputFormat
_append
stringsdata
xcstrings
strings
extractFromCodeComments
shouldDisableLineHints
omitEmptyStringsdata
avoidArgPlaceholder
outputFormat
append
RawValue
sourceBuffer
enclosingMacroRange
enclosingMacroID
enclosingVisibilityStack
RawValue
AllCases
rawValue
Value
_parsedValue
base
StringInterpolation
StringLiteralType
ExtendedGraphemeClusterLiteralType
UnicodeScalarLiteralType
abstract
discussion
valueName
visibility
base
default
hidden
private
kind
list
file
shellCommand
custom
default
directory
RawValue
message
rawValue
base
helpRequest
dumpRequest
Value
_parsedValue
base
prefixedNo
prefixedEnableDisable
exclusive
chooseFirst
chooseLast
ArrayLiteralElement
elements
base
customLong
customShort
long
short
Value
_parsedValue
base
Value
_parsedValue
_visibility
_dummy
commandName
_superCommandName
abstract
usage
discussion
version
shouldDisplay
subcommands
defaultSubcommand
helpNames
_options
options
values
usedOrigins
nextCommandIndex
previouslyDecoded
codingPath
userInfo
decoder
underlying
parsedElement
type
value
wrongKeyType
topLevelHasNoUnkeyedContainer
topLevelHasNoSingleValueContainer
singleValueDecoderHasNoContainer
base
currentIndex
array
default
scanningForValue
unconditional
upToNextOption
allRemainingInput
kind
help
completion
parsingStrategy
update
initial
options
abstract
discussion
valueName
visibility
defaultValue
keys
allValues
isComposite
nullary
unary
named
positional
rawValue
ArrayLiteralElement
Element
RawValue
Element
Iterator
Index
SubSequence
Indices
content
namePositions
commandStack
parserError
visibility
_generateCompletionScript
generateCompletionScript
_elements
ArrayLiteralElement
argumentIndex
defaultValue
long
short
longWithSingleDash
value
definition
value
inputOrigin
shouldClearArrayIfParsed
elements
originalInput
rawValue
RawValue
helpRequested
completionScriptRequested
completionScriptCustomResponse
unsupportedShell
unknownOption
invalidOption
nonAlphanumericShortOption
missingValueForOption
unexpectedValueForOption
unexpectedExtraValues
duplicateExclusiveValues
noValue
unableToParseValue
userValidationError
noArguments
versionRequested
dumpHelpRequested
notImplemented
invalidState
missingSubcommand
wrongType
subcommandLevelMismatch
subcommandLevelMissing
subcommandLevelDuplicated
subcommandNameMismatch
expectedCommandButNoneFound
_elements
firstUnused
originalInput
inputIndex
subIndex
value
index
option
terminator
name
nameWithValue
rawValue
RawValue
complete
_subcommands
_help
commandStack
visibility
subcommands
help
header
elements
discussion
isSubcommands
commandStack
abstract
usage
sections
discussionSections
label
positionalArguments
subcommands
options
title
content
help
validation
other
element
parent
children
recursiveSubcommand
RawValue
serializationVersion
command
superCommands
commandName
abstract
discussion
defaultSubcommand
subcommands
arguments
kind
shouldDisplay
isOptional
isRepeating
names
preferredName
valueName
defaultValue
allValues
name
long
short
longWithSingleDash
positional
option
flag
fileHandleForUpdatingURL:error:
closeAndReturnError:
copyItemAtURL:toURL:error:
createDirectoryAtURL:withIntermediateDirectories:attributes:error:
currentDirectoryPath
dataWithPropertyList:format:options:error:
defaultManager
fileExistsAtPath:
fileExistsAtPath:isDirectory:
fileHandleWithStandardError
fileHandleWithStandardOutput
init
initWithDictionary:
removeItemAtURL:error:
synchronizeAndReturnError:
help
version
bash
fish
path
encoding
files
tables
text
binary
warning
stringsAndStringsdict
stringsdictOnly
stringsdata
xcstrings
strings
_TtC13xcstringstool31SwiftLocalizableStringCollector
thingsToExtract
$__lazy_storage_$_extractableFunctionBaseNames
localizableStrings
importedSwiftUI
 (specified on command-line as 
_TtC13xcstringstool16SourceCodeBuffer
contents
indexCursor
locationCursor
cachedLineNumbersToStringIndices
_TtC13xcstringstool17XCStringsCompiler
inputFile
outputDirectory
specifiedLanguages
options
fileManager
xcstringstool/ExtractionOptions.swift
xcstringstool/ExtractionCriteria.swift
onlyTablesToProcess
_TtC13xcstringstoolP33_8C723CA5F89161A7842F8864CA90A15E15StringsdataPool
$defaultActor
stringsdataURLs
Skipping source file because it is not a supported file type: '
Failed to process source file '
_TtC13xcstringstool14SwiftExtractor
fileURL
parsedFile
sourceBuffer
The output format for individual files that can have different representations
Force all strings to build, including source strings that are already present in source code.
Caution must be used when combining with the sync command, since a sync operation may change the build result when using this option.
serializationFormat
forceBuildAllStrings
_TtC13xcstringstool27SwiftStringLiteralCollector
stringLiterals
' conflicts with compiled set element for '
Extract all Swift string literals that could potentially be string keys.
This generally includes all string literals, except for those which we can prove are definitely not being used as localization keys (without performing any type checking). If specified alongside other extraction criteria, the __PotentialKeys table will not include keys that get extracted into other tables.
Legacy name for --all-potential-swift-keys.
Extract from NSLocalizedString and sibling macros and functions.
This mode mimics genstrings.
Extract from String(localized:), AttributedString(localized:), and LocalizedStringResource inits.
Specify custom localization functions or C macros that should additionally be extracted.
Each value should be the base name of a function that matches the signature of NSLocalizedString. Variants that accept tables, bundles, and default values are automatically included. You can specify this option multiple times.
Extract from SwiftUI Text()
This mode mimics the -SwiftUI option in genstrings.
Extract from various SwiftUI APIs
This mode also extracts Text(). It is not recommended to mix this option with --SwifTUI-Text, which performs legacy genstrings-style Text() extraction.
allPotentialSwiftKeys
allSwiftLiterals
legacyLocalizableStrings
modernLocalizableStrings
userFunctionNames
_TtC13xcstringstool17SwiftSourceBuffer
converter
$__lazy_storage_$_lines
_TtC13xcstringstool15CStyleExtractor
presumedEncoding
Skipping extraction of localizable string with non-literal key
Skipping extraction of localizable string with non-static table name
The contents of string interpolations in localization comments will not be extracted
Cannot extract non-literal comment for localization
Skipping extraction of localizable string because we aren't certain about the format specifier to use for an interpolation
String interpolation may prevent proper localization in this context
Cannot extract non-literal value for localization
Skipping extraction of localizable string because string interpolation is not supported in this context
Work with .xcstrings files
Prints all string keys represented in an xcstrings file.
Produces build products for an .xcstrings file.
Updates an .xcstrings file based on strings present in .stringsdata files.
Extracts strings from source code files.
--all-potential-swift-keys is only supported with the default --output-format of "stringsdata"
The source code files to extract from.
A plist with paths to input files, which can be used instead of passing file paths directly as arguments.
The directory to place output .stringsdata files.
Don't extract from certain localization tables.
May be specified multiple times.
Only extract from certain tables.
The .xcstrings files to merge into.
.stringsdata files specifying the strings used from source.
Prevents marking strings stale and/or removing them from the .xcstrings when not found in the .stringsdata.
The path to the .xcstrings file to compile.
The directory to place output files.
The output format for the overall compilation
If specified, outputs a newline-separated list of output paths that would be produced by a compilation, but does not actually compile anything.
Optionally specify particular languages to compile.
You can pass as many of these options as you want.
The path to the .xcstrings file to print.
skipMarkingStringsStale
--append is not supported when using the default --output-format of "stringsdata"
extract-from-comments
Extract NSLocalizedString and sibling macros even from code comments.
Disables printing of detailed source code line info alongside diagnostics.
This can increase performance. This flag also changes the behavior of printed column numbers to represent UTF-8 byte offsets instead of grapheme cluster offsets. An additional column length (in UTF-8 bytes) is also added.
Prevents xcstringstool from writing .stringsdata files that would contain no strings.
Prevents inclusion of localizable strings where we don't know the format specifier to use for interpolations.
Otherwise %arg would be used when uncertain.
Specifies the final output format for extracted strings.
The default value is "stringsdata", but "xcstrings" or "strings" can also be specified. Note that Xcode separately supports auto-generating xcstrings when exporting/importing localizations without the use of this flag. You can additionally specify the --append flag if you need to add to existing files in the output directory. Because xcstringstool does not invoke the compiler, it cannot always determine the correct format specifiers to use for string interpolations.
When using an --output-format of xcstrings or strings, adds extracted strings to any existing files in the --output-directory.
For "strings" mode, entries will simply be appended to the end of the file with no duplicate key detection. When using "xcstrings" mode, newly extracted values will replace any existing values from duplicate keys. If this flag is not passed, any existing files with the same name will be overwritten.
extractFromCodeComments
shouldDisableLineHints
omitEmptyStringsdata
avoidArgPlaceholder
_TtC13xcstringstool18SwiftStringVisitor
enclosingMacroRange
enclosingMacroID
enclosingVisibilityStack
xcstringstool.SwiftStringVisitor
init(viewMode:)
    opts="$opts 
    if [[ $COMP_CWORD == "
" ]]; then
        COMPREPLY=( $(compgen -W "$opts" -- "$cur") )
        return
    fi
    case ${COMP_WORDS[
    return
    ;;
    COMPREPLY=( $(compgen -W "$opts" -- "$cur") )
cur="${COMP_WORDS[COMP_CWORD]}"
prev="${COMP_WORDS[COMP_CWORD-1]}"
COMPREPLY=()
COMPREPLY=( $(compgen -W "$("${COMP_WORDS[0]}" 
 "${COMP_WORDS[@]}")" -- "$cur") )
COMPREPLY=( $(compgen -W "
COMPREPLY=( $(compgen -d -- "$cur") )
COMPREPLY=( $(compgen -f -- "$cur") )
$("${COMP_WORDS[0]}" ---completion 
 "${COMP_WORDS[@]}")
ArgumentParser/CompletionsGenerator.swift
Invalid CompletionShell: 
SHELL
function _swift_
_using_command
    set -l cmd (commandline -opc)
    if [ (count $cmd) -eq (count $argv) ]
        for i in (seq (count $argv))
            if [ $cmd[$i] != $argv[$i] ]
                return 1
            end
        end
        return 0
    end
    return 1
-f -a '(command 
 -- --custom (commandline -opc)[1..-1])'
-f -a '(__fish_complete_directories)'
-f -a '(for i in 
local context state state_descr line
_commandname=$words[1]
typeset -A opt_args
_custom_completion() {
    local completions=("${(@f)$($*)}")
    _describe '' completions
'(-): :->command'
case $state in
    (command)
        local subcommands
        subcommands=(
        )
        _describe "subcommand" subcommands
        ;;
    (arg)
        case ${words[1]} in
        esac
        ;;
esac
() {
    integer ret=1
    local -a args
    args+=(
    )
    _arguments -w -s -S $args[@] && ret=0
    return ret
{_custom_completion $_
{local -a list; list=(${(f)"$(
)"}); _describe '''' list}
Show help information.
Show the version.
ArgumentParser/Argument.swift
--------------------------------------------------------------------
Can't read a value from a parsable
argument definition.
This error indicates that a property declared with an `@Argument`,
`@Option`, `@Flag`, or `@OptionGroup` property wrapper was neither
initialized to a value nor decoded from command-line arguments.
To get a valid value, either call one of the static parsing methods
(`parse`, `parseAsRoot`, or `main`) or define an initializer that
initializes _every_ property of your parsable type.
--------------------------------------------------------------------
Argument(*definition*)
--experimental-dump-help
ArgumentParser/Flag.swift
Flag(*definition*)
offset element 
ArgumentParser/NameSpecification.swift
' has not characters to form short option name.
ArgumentParser/Option.swift
Option(*definition*)
ArgumentParser/OptionGroup.swift
OptionGroup(*definition*)
Fatal error
Down-casted Array element failed to match the target type
Expected 
Tree<ParsableCommand.Type>
NSArray element failed to match the Swift Array Element type
Expected 
_TtC14ArgumentParser15ArgumentDecoder
values
usedOrigins
nextCommandIndex
previouslyDecoded
codingPath
userInfo
decoder
ArgumentParser/ArgumentDecoder.swift
experimental-dump-help
ArgumentParser/CommandParser.swift
Unexpected error: 
The ParsableCommand "
" can't have itself as its own subcommand.
generateCompletionScript
ArgumentParser/Parsed.swift
Trying to get the argument set from a resolved/parsed property.
Show subcommand help information.
 <subcommand>' for detailed help.
ArgumentParser/HelpGenerator.swift
' for more information.
Unspecified version
ArgumentParser/UsageGenerator.swift
preferredName cannot be nil for named arguments
Missing required subcommand.
Invalid option: -
Invalid option: 
' does not take any value, but '
' was specified.
Internal error. Invalid state while parsing command-line arguments.
Internal error. Parsing command-line arguments hit unimplemented code path.
Can't generate completion scripts for '
Please use --generate-completion-script=<shell> with one of:
    
Can't autodetect a supported shell.
Please use --generate-completion-script=<shell> with one of:
    
Unknown option '
'. Did you mean '
Missing value for '
 unexpected arguments: '
Unexpected argument '
Value to be set with 
 had already been set with 
Missing one of: '
Missing expected argument '
No value set for non-argument var 
. Replace with a static variable, or let constant.
' is invalid for '
' is invalid for '<
. Please provide one of the following:
. Please provide one of 
element
parent
children
long
short
longWithSingleDash
positional
option
flag
serializationVersion
defaultSubcommand
xcstringstool
SwiftLocalizableStringCollector
URLResourceKey
NNSURLResourceKey
Foundation
$,4<DLT\
CStyleToken
Kind
CStyleLexer
XCStringsToLprojCompiler
Language
SourceCodeBuffer
SourceCodeCharacter
XCStringsCompiler
CodingKeys
SourceFileList
SourceCodeStringExtractor
StringsdataPool
FlattenedStringSetElement
FlattenedStringSet
SwiftExtractor
BalancedExpression
CStyleParser
CompilerOptions
CodingKeys
SwiftStringLiteralCollector
StringsAndStringsdictPair
LprojableFileFormat
SerializationFormat
NSFileHandle
Severity
SourceCodeDiagnostic
ExtractionCriteria
TableBasedExtractionCriteria
CodingKeys
SwiftSourceBuffer
CStyleExtractor
SourceCodeFile
StringsFile
XCStringsTool
CommandFailed
Extract
Sync
Compile
Print
CodingKeys
Format
ExtractionOptions
CodingKeys
OutputFormat
SwiftStringVisitor
true
false
@help
q.Hg
ArgumentParser
CompletionShell
Argument
ArgumentArrayParsingStrategy
ArgumentHelp
ArgumentVisibility
Representation
CompletionKind
Kind
ValidationError
ExitCode
CleanExit
Representation
Flag
FlagInversion
FlagExclusivity
Representation
NameSpecification
Element
Representation
Option
SingleValueParsingStrategy
ArrayParsingStrategy
OptionGroup
AsyncParsableCommand
AsyncMainProtocol
Command
CommandConfiguration
EnumerableFlag
ExpressibleByArgument
ParsableArguments
ArgumentSetProvider
_WrappedParsableCommand
StandardError
CodingKeys
 @tw
ParsableArgumentsValidator
ParsableArgumentsValidatorError
ParsableCommand
ArgumentDecoder
ParsedArgumentsContainer
ArrayWrapperProtocol
DecodedArguments
SingleValueDecoder
UnkeyedContainer
ArrayWrapper
SingleValueContainer
Error
ArgumentHelpOptionProvider
ArgumentDefinition
ParsingStrategy
Update
Help
Kind
Options
ArgumentSet
CommandError
AutodetectedGenerateCompletions
GenerateCompletions
HelpRequested
CodingKeys
InputOrigin
Element
Name
ParsedWrapper
Value
DecodableParsedWrapper
Parsed
 @,}
ParsedValues
Element
InputKey
ParserError
InternalParseError
InputIndex
ParsedArgument
Value
Element
Index
SplitArguments
SubIndex
HelpCommand
CodingKeys
Element
HelpGenerator
Section
DiscussionSection
Header
MessageInfo
Tree
InitializationError
&-D5;
ArgumentParserToolInfo
ToolInfoHeader
ToolInfoV0
CommandInfoV0
ArgumentInfoV0
NameInfoV0
KindV0
CodingKeys
ShySSGSg
2idt
_pSg
So8NSStringC
$sSY
$ss21_ObjectiveCBridgeableP
5lower_AA5uppert
SS_SNy
G5rangetSg
SS_SNy
G5ranget
SS3raw_t
ShySSG
SSSg
SDySi
SaySSG
So13NSFileManagerC
$sST
SnySiG
$sSl
$sSK
$sSk
ypSg
SDyS2SG
ySSG
yS2SG
$s13xcstringstool25SourceCodeStringExtractorP
SS3key_
5valuetSg
SS3key_
5valuet
Si6offset_
7elementt
Si6offset_
7elementtSg
ScGyytG
ySbG
ScPSg
ScA_pSg
ytIeghHr_
_pSg
SS3key_
5valuetSg
SS3key_
5valuet
SS3key_
5valuet
ySSG
ySnySiGG
2idtG
ySS_
SgSg
3key_SS5valuetSg
3key_SS5valuet
SS3key_
5valuetSg
$s13xcstringstool19LprojableFileFormatP
$ss12CaseIterableP
yypG
_pSg
SS3key_
_p5valuet
ySaySSGG
SDySS
ySNy
ySSSay
SaySSGSg
_pSgSg
SS3key_SSSg5valueAB7commentAB9tableName
8location
10visibilitytSg
SS3key_SSSg5valueAB7commentAB9tableName
8location
10visibilityt
_pXpG
3key_yp5valuetSg
_pXpG
ySay
ySay
SS3key_
5valuet
2idtG
_pXpG
SaySSG
SaySsG
$sSY
$ss12CaseIterableP
SSSg
ySSG
SaySSG_SSt
ySSG
qd__
$s14ArgumentParser13ParsedWrapperP
Sayqd__GSg
SSqd__
_pIeggrzo_
Sayqd__G
ypSg
_pIeggrzo_
qd__XMT
$ss32ExpressibleByStringInterpolationP
$ss26ExpressibleByStringLiteralP
$ss43ExpressibleByExtendedGraphemeClusterLiteralP
$ss33ExpressibleByUnicodeScalarLiteralP
SaySSG10extensions_t
SaySSGAAc
_pXpSg
SbSg
Sbz_Xx
$ss25ExpressibleByArrayLiteralP
SS_Sb14withSingleDasht
SJ_Sb14allowingJoinedt
_pSg
$s14ArgumentParser20AsyncParsableCommandP
$s14ArgumentParser17AsyncMainProtocolP
7Command
_pXpG
$s14ArgumentParser14EnumerableFlagP
$s14ArgumentParser013ExpressibleByA0P
yypG
$s14ArgumentParser17ParsableArgumentsP
$s14ArgumentParser0A11SetProviderP
SSSg5label_yp5valuet
_pSg
SSypSgIeggr_
$s14ArgumentParser26ParsableArgumentsValidator33_D8B6916CE93C2FC7F7BEDE789FAE65F8LLP
$s14ArgumentParser31ParsableArgumentsValidatorErrorP
$s14ArgumentParser15ParsableCommandP
_SitG
_Sit
_pXpG
ySsG
_SStG
_SSt
ySi_
_pXmTSg
$s14ArgumentParser20ArrayWrapperProtocolP
_pXp
$ss30KeyedDecodingContainerProtocolP
SayypG
yypG
_pXpGG
ySnySiGG
ySaySSG_SStG
ySiG
ySaySiGG
SaySiG
_pXp_AA_pXpt
SayxG
$s14ArgumentParser0A18HelpOptionProviderP
ztKc
ztKc
SgSS
ztKc
$ss10SetAlgebraP
$ss9OptionSetP
$sST
SnySiG
$sSl
$sSK
$sSk
yyXlG
_SStSg
SSxSgIeggr_
xXMT
_pSg
ySSG
ySbG
S2SSgIeggr_
$s14ArgumentParser22DecodableParsedWrapperP
5Value
_pXpGADG
10visibility_t
SSSg5shell_t
_SStG
8previous_AA9duplicateSaySSG13originalInputt
6forKey_t
SgSS
6forKey
_pSg13originalErrort
ypSg_
6forKeyt
Si_Sit
_SSt
Sb8inserted_
17memberAfterInsertt
ySaySSGG
SaySSGSg
_ypt
ySSSgG
yAAyABySaySSSgGACGGSSGG
yAAySaySSSgGACGGSSG
ySaySSSgGACGG
ySaySSSgGABG
SaySSSgG
ySay
GSSG
SS4text_t
SS7message_SS5usageSS4helpt
SS7message_
8exitCodet
yxGSgXw
yxGG
_pXpGACG
_pXpGACSgIegnr_
_pXp
SaySSGSg
SaySSG
$sSY
SSSg
thingsToExtract
$__lazy_storage_$_extractableFunctionBaseNames
localizableStrings
importedSwiftUI
_rawValue
RawValue
_ObjectiveCType
kind
location
secondaryContentStartingLocation
sourceBuffer
supportNestedMultiLineComments
identifier
stringLiteral
comment
other
null
comma
colon
semicolon
backslash
leftParen
rightParen
leftBracket
rightBracket
leftBrace
rightBrace
codeSpecifiedOnCommandLine
normalizedCode
contents
indexCursor
locationCursor
cachedLineNumbersToStringIndices
char
location
inputFile
outputDirectory
specifiedLanguages
options
fileManager
Element
Iterator
Index
SubSequence
Indices
path
encoding
files
tables
extractionCriteria
RawValue
$defaultActor
stringsdataURLs
Element
Iterator
Index
SubSequence
Indices
value
state
setKey
compiledElements
fileURL
parsedFile
sourceBuffer
lexer
shouldExtractFromComments
isCurrentlyExtractingFromComments
parens
brackets
braces
_serializationFormat
_forceBuildAllStrings
serializationFormat
forceBuildAllStrings
stringLiterals
stringsFile
stringsdictFile
text
binary
AllCases
RawValue
severity
message
filePath
location
lineContent
warning
RawValue
specsByTable
defaultSpec
wantsPotentialKeyExtraction
_allPotentialSwiftKeys
_allSwiftLiterals
_legacyLocalizableStrings
_modernLocalizableStrings
_userFunctionNames
_swiftUIText
_swiftUI
allPotentialSwiftKeys
allSwiftLiterals
legacyLocalizableStrings
modernLocalizableStrings
userFunctionNames
swiftUIText
swiftUI
converter
$__lazy_storage_$_lines
fileURL
presumedEncoding
sourceBuffer
fileURL
presumedEncoding
options
extractedStrings
usedCriteria
includePotentialKeysTableInStringsdata
$__lazy_storage_$_extractor
strings
comments
_inputFile
_outputDirectory
_format
_languages
_extraOptions
_dryRun
_xcstrings
_stringsdata
_skipMarkingStringsStale
_sourceFiles
_fileListPlist
_criteria
_tablesToSkip
_onlyTablesToProcess
stringsAndStringsdict
stringsdictOnly
sourceFiles
fileListPlist
outputDirectory
criteria
tablesToSkip
onlyTablesToProcess
extraOptions
xcstrings
stringsdata
skipMarkingStringsStale
inputFile
format
languages
dryRun
AllCases
RawValue
_extractFromCodeComments
_shouldDisableLineHints
_omitEmptyStringsdata
_avoidArgPlaceholder
_outputFormat
_append
stringsdata
xcstrings
strings
extractFromCodeComments
shouldDisableLineHints
omitEmptyStringsdata
avoidArgPlaceholder
outputFormat
append
RawValue
sourceBuffer
enclosingMacroRange
enclosingMacroID
enclosingVisibilityStack
RawValue
AllCases
rawValue
Value
_parsedValue
base
StringInterpolation
StringLiteralType
ExtendedGraphemeClusterLiteralType
UnicodeScalarLiteralType
abstract
discussion
valueName
visibility
base
default
hidden
private
kind
list
file
shellCommand
custom
default
directory
RawValue
message
rawValue
base
helpRequest
dumpRequest
Value
_parsedValue
base
prefixedNo
prefixedEnableDisable
exclusive
chooseFirst
chooseLast
ArrayLiteralElement
elements
base
customLong
customShort
long
short
Value
_parsedValue
base
Value
_parsedValue
_visibility
_dummy
commandName
_superCommandName
abstract
usage
discussion
version
shouldDisplay
subcommands
defaultSubcommand
helpNames
_options
options
values
usedOrigins
nextCommandIndex
previouslyDecoded
codingPath
userInfo
decoder
underlying
parsedElement
type
value
wrongKeyType
topLevelHasNoUnkeyedContainer
topLevelHasNoSingleValueContainer
singleValueDecoderHasNoContainer
base
currentIndex
array
default
scanningForValue
unconditional
upToNextOption
allRemainingInput
kind
help
completion
parsingStrategy
update
initial
options
abstract
discussion
valueName
visibility
defaultValue
keys
allValues
isComposite
nullary
unary
named
positional
rawValue
ArrayLiteralElement
Element
RawValue
Element
Iterator
Index
SubSequence
Indices
content
namePositions
commandStack
parserError
visibility
_generateCompletionScript
generateCompletionScript
_elements
ArrayLiteralElement
argumentIndex
defaultValue
long
short
longWithSingleDash
value
definition
value
inputOrigin
shouldClearArrayIfParsed
elements
originalInput
rawValue
RawValue
helpRequested
completionScriptRequested
completionScriptCustomResponse
unsupportedShell
unknownOption
invalidOption
nonAlphanumericShortOption
missingValueForOption
unexpectedValueForOption
unexpectedExtraValues
duplicateExclusiveValues
noValue
unableToParseValue
userValidationError
noArguments
versionRequested
dumpHelpRequested
notImplemented
invalidState
missingSubcommand
wrongType
subcommandLevelMismatch
subcommandLevelMissing
subcommandLevelDuplicated
subcommandNameMismatch
expectedCommandButNoneFound
_elements
firstUnused
originalInput
inputIndex
subIndex
value
index
option
terminator
name
nameWithValue
rawValue
RawValue
complete
_subcommands
_help
commandStack
visibility
subcommands
help
header
elements
discussion
isSubcommands
commandStack
abstract
usage
sections
discussionSections
label
positionalArguments
subcommands
options
title
content
help
validation
other
element
parent
children
recursiveSubcommand
RawValue
serializationVersion
command
superCommands
commandName
abstract
discussion
defaultSubcommand
subcommands
arguments
kind
shouldDisplay
isOptional
isRepeating
names
preferredName
valueName
defaultValue
allValues
name
long
short
longWithSingleDash
positional
option
flag
fileHandleForUpdatingURL:error:
closeAndReturnError:
copyItemAtURL:toURL:error:
createDirectoryAtURL:withIntermediateDirectories:attributes:error:
currentDirectoryPath
dataWithPropertyList:format:options:error:
defaultManager
fileExistsAtPath:
fileExistsAtPath:isDirectory:
fileHandleWithStandardError
fileHandleWithStandardOutput
init
initWithDictionary:
removeItemAtURL:error:
synchronizeAndReturnError:
help
version
bash
fish
