socket(family=AF_INET, type=SOCK_STREAM, proto=0) -> socket object
socket(family=-1, type=-1, proto=-1, fileno=None) -> socket object
Open a socket of the given type.  The family argument specifies the
address family; it defaults to AF_INET.  The type argument specifies
whether this is a stream (SOCK_STREAM, this is the default)
or datagram (SOCK_DGRAM) socket.  The protocol argument defaults to 0,
specifying the default protocol.  Keyword arguments are accepted.
The socket is created as non-inheritable.
When a fileno is passed in, family, type and proto are auto-detected,
unless they are explicitly set.
A socket object represents one endpoint of a network connection.
Methods of socket objects (keyword arguments not allowed):
_accept() -- accept connection, returning new socket fd and client address
bind(addr) -- bind the socket to a local address
close() -- close the socket
connect(addr) -- connect the socket to a remote address
connect_ex(addr) -- connect, return an error code instead of an exception
dup() -- return a new socket fd duplicated from fileno()
fileno() -- return underlying file descriptor
getpeername() -- return remote address [*]
getsockname() -- return local address
getsockopt(level, optname[, buflen]) -- get socket options
gettimeout() -- return timeout or None
listen([n]) -- start listening for incoming connections
recv(buflen[, flags]) -- receive data
recv_into(buffer[, nbytes[, flags]]) -- receive data (into a buffer)
recvfrom(buflen[, flags]) -- receive data and sender's address
recvfrom_into(buffer[, nbytes, [, flags])
  -- receive data and sender's address (into a buffer)
sendall(data[, flags]) -- send all data
send(data[, flags]) -- send data, may not send all of it
sendto(data[, flags], addr) -- send data to a given address
setblocking(bool) -- set or clear the blocking I/O flag
getblocking() -- return True if socket is blocking, False if non-blocking
setsockopt(level, optname, value[, optlen]) -- set socket options
settimeout(None | float) -- set or clear the timeout
shutdown(how) -- shut down traffic in one or both directions
if_nameindex() -- return all network interface indices and names
if_nametoindex(name) -- return the corresponding interface index
if_indextoname(index) -- return the corresponding interface name
 [*] not available on all platforms!
_accept() -> (integer, address info)
Wait for an incoming connection.  Return a new socket file descriptor
representing the connection, and the address of the client.
For IP sockets, the address info is a pair (hostaddr, port).
bind(address)
Bind the socket to a local address.  For IP sockets, the address is a
pair (host, port); the host must refer to the local host. For raw packet
sockets the address is a tuple (ifname, proto [,pkttype [,hatype [,addr]]])
close()
Close the socket.  It cannot be used after this call.
connect(address)
Connect the socket to a remote address.  For IP sockets, the address
is a pair (host, port).
connect_ex(address) -> errno
This is like connect(address), but returns an error code (the errno value)
instead of raising an exception when an error occurs.
detach()
Close the socket object without closing the underlying file descriptor.
The object cannot be used after this call, but the file descriptor
can be reused for other purposes.  The file descriptor is returned.
fileno() -> integer
Return the integer file descriptor of the socket.
getpeername() -> address info
Return the address of the remote endpoint.  For IP sockets, the address
info is a pair (hostaddr, port).
getsockname() -> address info
Return the address of the local endpoint. The format depends on the
address family. For IPv4 sockets, the address info is a pair
(hostaddr, port).
getsockopt(level, option[, buffersize]) -> value
Get a socket option.  See the Unix manual for level and option.
If a nonzero buffersize argument is given, the return value is a
string of that length; otherwise it is an integer.
listen([backlog])
Enable a server to accept connections.  If backlog is specified, it must be
at least 0 (if it is lower, it is set to 0); it specifies the number of
unaccepted connections that the system will allow before refusing new
connections. If not specified, a default reasonable value is chosen.
recv(buffersize[, flags]) -> data
Receive up to buffersize bytes from the socket.  For the optional flags
argument, see the Unix manual.  When no data is available, block until
at least one byte is available or until the remote end is closed.  When
the remote end is closed and all data is read, return the empty string.
recv_into(buffer, [nbytes[, flags]]) -> nbytes_read
A version of recv() that stores its data into a buffer rather than creating
a new string.  Receive up to buffersize bytes from the socket.  If buffersize
is not specified (or 0), receive up to the size available in the given buffer.
See recv() for documentation about the flags.
recvfrom(buffersize[, flags]) -> (data, address info)
Like recv(buffersize, flags) but also return the sender's address info.
recvfrom_into(buffer[, nbytes[, flags]]) -> (nbytes, address info)
Like recv_into(buffer[, nbytes[, flags]]) but also return the sender's address info.
send(data[, flags]) -> count
Send a data string to the socket.  For the optional flags
argument, see the Unix manual.  Return the number of bytes
sent; this may be less than len(data) if the network is busy.
sendall(data[, flags])
Send a data string to the socket.  For the optional flags
argument, see the Unix manual.  This calls send() repeatedly
until all data is sent.  If an error occurs, it's impossible
to tell how much data has been sent.
sendto(data[, flags], address) -> count
Like send(data, flags) but allows specifying the destination address.
For IP sockets, the address is a pair (hostaddr, port).
setblocking(flag)
Set the socket to blocking (flag is true) or non-blocking (false).
setblocking(True) is equivalent to settimeout(None);
setblocking(False) is equivalent to settimeout(0.0).
getblocking()
Returns True if socket is in blocking mode, or False if it
is in non-blocking mode.
settimeout(timeout)
Set a timeout on socket operations.  'timeout' can be a float,
giving in seconds, or None.  Setting a timeout of None disables
the timeout feature and is equivalent to setblocking(1).
Setting a timeout of zero is the same as setblocking(0).
gettimeout() -> timeout
Returns the timeout in seconds (float) associated with socket
operations. A timeout of None indicates that timeouts on socket
operations are disabled.
setsockopt(level, option, value: int)
setsockopt(level, option, value: buffer)
setsockopt(level, option, None, optlen: int)
Set a socket option.  See the Unix manual for level and option.
The value argument can either be an integer, a string buffer, or
None, optlen.
shutdown(flag)
Shut down the reading side of the socket (flag == SHUT_RD), the writing side
of the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR).
recvmsg(bufsize[, ancbufsize[, flags]]) -> (data, ancdata, msg_flags, address)
Receive normal data (up to bufsize bytes) and ancillary data from the
socket.  The ancbufsize argument sets the size in bytes of the
internal buffer used to receive the ancillary data; it defaults to 0,
meaning that no ancillary data will be received.  Appropriate buffer
sizes for ancillary data can be calculated using CMSG_SPACE() or
CMSG_LEN(), and items which do not fit into the buffer might be
truncated or discarded.  The flags argument defaults to 0 and has the
same meaning as for recv().
The return value is a 4-tuple: (data, ancdata, msg_flags, address).
The data item is a bytes object holding the non-ancillary data
received.  The ancdata item is a list of zero or more tuples
(cmsg_level, cmsg_type, cmsg_data) representing the ancillary data
(control messages) received: cmsg_level and cmsg_type are integers
specifying the protocol level and protocol-specific type respectively,
and cmsg_data is a bytes object holding the associated data.  The
msg_flags item is the bitwise OR of various flags indicating
conditions on the received message; see your system documentation for
details.  If the receiving socket is unconnected, address is the
address of the sending socket, if available; otherwise, its value is
unspecified.
If recvmsg() raises an exception after the system call returns, it
will first attempt to close any file descriptors received via the
SCM_RIGHTS mechanism.
recvmsg_into(buffers[, ancbufsize[, flags]]) -> (nbytes, ancdata, msg_flags, address)
Receive normal data and ancillary data from the socket, scattering the
non-ancillary data into a series of buffers.  The buffers argument
must be an iterable of objects that export writable buffers
(e.g. bytearray objects); these will be filled with successive chunks
of the non-ancillary data until it has all been written or there are
no more buffers.  The ancbufsize argument sets the size in bytes of
the internal buffer used to receive the ancillary data; it defaults to
0, meaning that no ancillary data will be received.  Appropriate
buffer sizes for ancillary data can be calculated using CMSG_SPACE()
or CMSG_LEN(), and items which do not fit into the buffer might be
truncated or discarded.  The flags argument defaults to 0 and has the
same meaning as for recv().
The return value is a 4-tuple: (nbytes, ancdata, msg_flags, address).
The nbytes item is the total number of bytes of non-ancillary data
written into the buffers.  The ancdata item is a list of zero or more
tuples (cmsg_level, cmsg_type, cmsg_data) representing the ancillary
data (control messages) received: cmsg_level and cmsg_type are
integers specifying the protocol level and protocol-specific type
respectively, and cmsg_data is a bytes object holding the associated
data.  The msg_flags item is the bitwise OR of various flags
indicating conditions on the received message; see your system
documentation for details.  If the receiving socket is unconnected,
address is the address of the sending socket, if available; otherwise,
its value is unspecified.
If recvmsg_into() raises an exception after the system call returns,
it will first attempt to close any file descriptors received via the
SCM_RIGHTS mechanism.
sendmsg(buffers[, ancdata[, flags[, address]]]) -> count
Send normal and ancillary data to the socket, gathering the
non-ancillary data from a series of buffers and concatenating it into
a single message.  The buffers argument specifies the non-ancillary
data as an iterable of bytes-like objects (e.g. bytes objects).
The ancdata argument specifies the ancillary data (control messages)
as an iterable of zero or more tuples (cmsg_level, cmsg_type,
cmsg_data), where cmsg_level and cmsg_type are integers specifying the
protocol level and protocol-specific type respectively, and cmsg_data
is a bytes-like object holding the associated data.  The flags
argument defaults to 0 and has the same meaning as for send().  If
address is supplied and not None, it sets a destination address for
the message.  The return value is the number of bytes of non-ancillary
data sent.
Implementation module for socket operations.
See the socket module for documentation.
gethostbyname(host) -> address
Return the IP address (a string of the form '255.255.255.255') for a host.
gethostbyname_ex(host) -> (name, aliaslist, addresslist)
Return the true host name, a list of aliases, and a list of IP addresses,
for a host.  The host argument is a string giving a host name or IP number.
gethostbyaddr(host) -> (name, aliaslist, addresslist)
Return the true host name, a list of aliases, and a list of IP addresses,
for a host.  The host argument is a string giving a host name or IP number.
gethostname() -> string
Return the current host name.
sethostname(name)
Sets the hostname to name.
getservbyname(servicename[, protocolname]) -> integer
Return a port number from a service name and protocol name.
The optional protocol name, if given, should be 'tcp' or 'udp',
otherwise any protocol will match.
getservbyport(port[, protocolname]) -> string
Return the service name from a port number and protocol name.
The optional protocol name, if given, should be 'tcp' or 'udp',
otherwise any protocol will match.
getprotobyname(name) -> integer
Return the protocol number for the named protocol.  (Rarely used.)
close(integer) -> None
Close an integer socket file descriptor.  This is like os.close(), but for
sockets; on some platforms os.close() won't work for socket file descriptors.
dup(integer) -> integer
Duplicate an integer socket file descriptor.  This is like os.dup(), but for
sockets; on some platforms os.dup() won't work for socket file descriptors.
socketpair([family[, type [, proto]]]) -> (socket object, socket object)
Create a pair of socket objects from the sockets returned by the platform
socketpair() function.
The arguments are the same as for socket() except the default family is
AF_UNIX if defined on the platform; otherwise, the default is AF_INET.
ntohs(integer) -> integer
Convert a 16-bit unsigned integer from network to host byte order.
Note that in case the received integer does not fit in 16-bit unsigned
integer, but does fit in a positive C int, it is silently truncated to
16-bit unsigned integer.
However, this silent truncation feature is deprecated, and will raise an
exception in future versions of Python.
ntohl(integer) -> integer
Convert a 32-bit integer from network to host byte order.
htons(integer) -> integer
Convert a 16-bit unsigned integer from host to network byte order.
Note that in case the received integer does not fit in 16-bit unsigned
integer, but does fit in a positive C int, it is silently truncated to
16-bit unsigned integer.
However, this silent truncation feature is deprecated, and will raise an
exception in future versions of Python.
htonl(integer) -> integer
Convert a 32-bit integer from host to network byte order.
inet_aton(string) -> bytes giving packed 32-bit IP representation
Convert an IP address in string format (123.45.67.89) to the 32-bit packed
binary format used in low-level network functions.
inet_ntoa(packed_ip) -> ip_address_string
Convert an IP address from 32-bit packed binary format to string format
inet_pton(af, ip) -> packed IP address string
Convert an IP address from string format to a packed string suitable
for use with low-level network functions.
inet_ntop(af, packed_ip) -> string formatted IP address
Convert a packed IP address of the given family to string format.
getaddrinfo(host, port [, family, type, proto, flags])
    -> list of (family, type, proto, canonname, sockaddr)
Resolve host and port into addrinfo struct.
getnameinfo(sockaddr, flags) --> (host, port)
Get host and port for a sockaddr.
getdefaulttimeout() -> timeout
Returns the default timeout in seconds (float) for new socket objects.
A value of None indicates that new socket objects have no timeout.
When the socket module is first imported, the default is None.
setdefaulttimeout(timeout)
Set the default timeout in seconds (float) for new socket objects.
A value of None indicates that new socket objects have no timeout.
When the socket module is first imported, the default is None.
if_nameindex()
Returns a list of network interface information (index, name) tuples.
if_nametoindex(if_name)
Returns the interface index corresponding to the interface name if_name.
if_indextoname(if_index)
Returns the interface name corresponding to the interface index if_index.
CMSG_LEN(length) -> control message length
Return the total length, without trailing padding, of an ancillary
data item with associated data of the given length.  This value can
often be used as the buffer size for recvmsg() to receive a single
item of ancillary data, but RFC 3542 requires portable applications to
use CMSG_SPACE() and thus include space for padding, even when the
item will be the last in the buffer.  Raises OverflowError if length
is outside the permissible range of values.
CMSG_SPACE(length) -> buffer size
Return the buffer size needed for recvmsg() to receive an ancillary
data item with associated data of the given length, along with any
trailing padding.  The buffer space needed to receive multiple items
is the sum of the CMSG_SPACE() values for their associated data
lengths.  Raises OverflowError if length is outside the permissible
range of values.
error
socket.herror
herror
socket.gaierror
gaierror
socket.timeout
timeout
SocketType
socket
has_ipv6
CAPI
_socket.CAPI
AF_UNSPEC
AF_INET
AF_UNIX
AF_IPX
AF_APPLETALK
AF_INET6
AF_DECnet
AF_ROUTE
AF_LINK
AF_SNA
PF_SYSTEM
AF_SYSTEM
SOCK_STREAM
SOCK_DGRAM
SOCK_RAW
SOCK_SEQPACKET
SOCK_RDM
SO_DEBUG
SO_ACCEPTCONN
SO_REUSEADDR
SO_KEEPALIVE
SO_DONTROUTE
SO_BROADCAST
SO_USELOOPBACK
SO_LINGER
SO_OOBINLINE
SO_REUSEPORT
SO_SNDBUF
SO_RCVBUF
SO_SNDLOWAT
SO_RCVLOWAT
SO_SNDTIMEO
SO_RCVTIMEO
SO_ERROR
SO_TYPE
LOCAL_PEERCRED
SO_BINDTODEVICE
SOMAXCONN
SCM_RIGHTS
SCM_CREDS
MSG_OOB
MSG_PEEK
MSG_DONTROUTE
MSG_DONTWAIT
MSG_EOR
MSG_TRUNC
MSG_CTRUNC
MSG_WAITALL
MSG_NOSIGNAL
MSG_EOF
SOL_SOCKET
SOL_IP
SOL_TCP
SOL_UDP
IPPROTO_IP
IPPROTO_HOPOPTS
IPPROTO_ICMP
IPPROTO_IGMP
IPPROTO_GGP
IPPROTO_IPV4
IPPROTO_IPV6
IPPROTO_IPIP
IPPROTO_TCP
IPPROTO_EGP
IPPROTO_PUP
IPPROTO_UDP
IPPROTO_IDP
IPPROTO_HELLO
IPPROTO_ND
IPPROTO_TP
IPPROTO_ROUTING
IPPROTO_FRAGMENT
IPPROTO_RSVP
IPPROTO_GRE
IPPROTO_ESP
IPPROTO_AH
IPPROTO_ICMPV6
IPPROTO_NONE
IPPROTO_DSTOPTS
IPPROTO_XTP
IPPROTO_EON
IPPROTO_PIM
IPPROTO_IPCOMP
IPPROTO_SCTP
IPPROTO_RAW
IPPROTO_MAX
SYSPROTO_CONTROL
IPPORT_RESERVED
IPPORT_USERRESERVED
INADDR_ANY
INADDR_BROADCAST
INADDR_LOOPBACK
INADDR_UNSPEC_GROUP
INADDR_ALLHOSTS_GROUP
INADDR_MAX_LOCAL_GROUP
INADDR_NONE
IP_OPTIONS
IP_HDRINCL
IP_TOS
IP_TTL
IP_RECVOPTS
IP_RECVRETOPTS
IP_RECVDSTADDR
IP_RETOPTS
IP_MULTICAST_IF
IP_MULTICAST_TTL
IP_MULTICAST_LOOP
IP_ADD_MEMBERSHIP
IP_DROP_MEMBERSHIP
IP_DEFAULT_MULTICAST_TTL
IP_DEFAULT_MULTICAST_LOOP
IP_MAX_MEMBERSHIPS
IPV6_JOIN_GROUP
IPV6_LEAVE_GROUP
IPV6_MULTICAST_HOPS
IPV6_MULTICAST_IF
IPV6_MULTICAST_LOOP
IPV6_UNICAST_HOPS
IPV6_V6ONLY
IPV6_CHECKSUM
IPV6_DONTFRAG
IPV6_DSTOPTS
IPV6_HOPLIMIT
IPV6_HOPOPTS
IPV6_NEXTHOP
IPV6_PATHMTU
IPV6_PKTINFO
IPV6_RECVDSTOPTS
IPV6_RECVHOPLIMIT
IPV6_RECVHOPOPTS
IPV6_RECVPKTINFO
IPV6_RECVRTHDR
IPV6_RECVTCLASS
IPV6_RTHDR
IPV6_RTHDRDSTOPTS
IPV6_RTHDR_TYPE_0
IPV6_RECVPATHMTU
IPV6_TCLASS
IPV6_USE_MIN_MTU
TCP_NODELAY
TCP_MAXSEG
TCP_KEEPINTVL
TCP_KEEPCNT
TCP_INFO
TCP_FASTOPEN
TCP_NOTSENT_LOWAT
EAI_ADDRFAMILY
EAI_AGAIN
EAI_BADFLAGS
EAI_FAIL
EAI_FAMILY
EAI_MEMORY
EAI_NODATA
EAI_NONAME
EAI_OVERFLOW
EAI_SERVICE
EAI_SOCKTYPE
EAI_SYSTEM
EAI_BADHINTS
EAI_PROTOCOL
EAI_MAX
AI_PASSIVE
AI_CANONNAME
AI_NUMERICHOST
AI_NUMERICSERV
AI_MASK
AI_ALL
AI_V4MAPPED_CFG
AI_ADDRCONFIG
AI_V4MAPPED
AI_DEFAULT
NI_MAXHOST
NI_MAXSERV
NI_NOFQDN
NI_NUMERICHOST
NI_NAMEREQD
NI_NUMERICSERV
NI_DGRAM
SHUT_RD
SHUT_WR
SHUT_RDWR
_socket.socket
<socket object, fd=%ld, family=%d, type=%d, proto=%d>
_accept
bind
close
connect
connect_ex
detach
fileno
getpeername
getsockname
getsockopt
listen
recv
recv_into
recvfrom
recvfrom_into
send
sendall
sendto
setblocking
getblocking
settimeout
gettimeout
setsockopt
shutdown
recvmsg
recvmsg_into
sendmsg
getsockaddrlen: unknown PF_SYSTEM protocol
getsockaddrlen: bad family
timed out
OiII
(II)
Invalid address type
socket.bind
AF_UNIX path too long
%s(): AF_INET address must be tuple, not %.500s
O&i;AF_INET address must be a pair (host, port)
%s(): port must be 0-65535.
%s(): AF_INET6 address must be tuple, not %.500s
O&i|II;AF_INET6 address must be a tuple (host, port[, flowinfo[, scopeid]])
%s(): flowinfo must be 0-1048575.
provided string is too long
cannot find kernel control with provided name
%s(): PF_SYSTEM address must be a str or a pair (id, unit)
%s(): unsupported PF_SYSTEM protocol
%s(): bad family
idna
encoding of hostname failed
str, bytes or bytearray expected, not %s
host name must not contain null character
unsupported address family
wildcard resolved to multiple address
255.255.255.255
<broadcast>
address family mismatched
unknown address family
(is)
socket.connect
ii|i:getsockopt
getsockopt buflen out of range
|i:listen
n|i:recv
negative buffersize in recv
buffer
nbytes
flags
w*|ni:recv_into
negative buffersize in recv_into
buffer too small for requested bytes
n|i:recvfrom
negative buffersize in recvfrom
w*|ni:recvfrom_into
negative buffersize in recvfrom_into
nbytes is greater than the length of the buffer
y*|i:send
y*|i:sendall
y*O:sendto
y*iO:sendto
sendto() takes 2 or 3 arguments (%zd given)
socket.sendto
Timeout value out of range
iii:setsockopt
iiO!I:setsockopt
iiy*:setsockopt
n|ni:recvmsg
negative buffer size in recvmsg()
invalid ancillary data buffer length
received malformed or improperly-truncated ancillary data
NOiN
O|ni:recvmsg_into
recvmsg_into() argument 1 must be an iterable
recvmsg_into() argument 1 is too long
w*;recvmsg_into() argument 1 must be an iterable of single-segment read-write buffers
O|OiO:sendmsg
socket.sendmsg
sendmsg() argument 2 must be an iterable
(iiy*):[sendmsg() ancillary data items]
ancillary data item too large
too much ancillary data
unexpected NULL result from %s()
CMSG_FIRSTHDR
CMSG_NXTHDR
item size out of range for CMSG_LEN()
ancillary data does not fit in calculated space
sendmsg() argument 1 must be an iterable
sendmsg() argument 1 is too long
y*;sendmsg() argument 1 must be an iterable of bytes-like objects
family
the socket family
type
the socket type
proto
the socket protocol
the socket timeout
|iiiO:socket
socket.__new__
Oiii
integer argument expected, got float
negative file descriptor
unclosed %R
_socket
gethostbyname
gethostbyname_ex
gethostbyaddr
gethostname
sethostname
getservbyname
getservbyport
getprotobyname
socketpair
ntohs
ntohl
htons
htonl
inet_aton
inet_ntoa
inet_pton
inet_ntop
getaddrinfo
getnameinfo
getdefaulttimeout
setdefaulttimeout
if_nameindex
if_nametoindex
if_indextoname
CMSG_LEN
CMSG_SPACE
et:gethostbyname
socket.gethostbyname
et:gethostbyname_ex
et:gethostbyaddr
socket.gethostbyaddr
socket.gethostname
S:sethostname
O&:sethostname
socket.sethostname
s|s:getservbyname
socket.getservbyname
service/proto not found
i|s:getservbyport
getservbyport: port must be 0-65535.
socket.getservbyport
port/proto not found
s:getprotobyname
protocol not found
|iii:socketpair
i:ntohs
ntohs: can't convert negative Python int to C 16-bit unsigned integer
ntohs: Python int too large to convert to C 16-bit unsigned integer (The silent truncation is deprecated)
int larger than 32 bits
expected int, %s found
i:htons
htons: can't convert negative Python int to C 16-bit unsigned integer
htons: Python int too large to convert to C 16-bit unsigned integer (The silent truncation is deprecated)
s:inet_aton
illegal IP address string passed to inet_aton
y*:inet_ntoa
packed IP wrong length for inet_ntoa
is:inet_pton
illegal IP address string passed to inet_pton
iy*:inet_ntop
invalid length of packed IP address string
unknown address family %d
host
port
OO|iiii:getaddrinfo
getaddrinfo() argument 1 must be string or None
Int or String expected
socket.getaddrinfo
OOiii
iiisO
Oi:getnameinfo
getnameinfo() argument 1 must be a tuple
si|II;getnameinfo(): illegal sockaddr argument
getnameinfo(): flowinfo must be 0-1048575.
socket.getnameinfo
sockaddr resolved to multiple addresses
IPv4 sockaddr must be 2 tuple
O&:if_nametoindex
no interface with this name
n:CMSG_LEN
CMSG_LEN() argument out of range
n:CMSG_SPACE
CMSG_SPACE() argument out of range
(((((((((((((((((((((((((((/(L
'socket(family=AF_INET, type=SOCK_STREAM, proto=0) -> socket object
socket(family=-1, type=-1, proto=-1, fileno=None) -> socket object
Open a socket of the given type.  The family argument specifies the
address family; it defaults to AF_INET.  The type argument specifies
whether this is a stream (SOCK_STREAM, this is the default)
or datagram (SOCK_DGRAM) socket.  The protocol argument defaults to 0,
specifying the default protocol.  Keyword arguments are accepted.
The socket is created as non-inheritable.
When a fileno is passed in, family, type and proto are auto-detected,
unless they are explicitly set.
A socket object represents one endpoint of a network connection.
Methods of socket objects (keyword arguments not allowed):
_accept() -- accept connection, returning new socket fd and client address
bind(addr) -- bind the socket to a local address
close() -- close the socket
connect(addr) -- connect the socket to a remote address
connect_ex(addr) -- connect, return an error code instead of an exception
dup() -- return a new socket fd duplicated from fileno()
fileno() -- return underlying file descriptor
getpeername() -- return remote address [*]
getsockname() -- return local address
getsockopt(level, optname[, buflen]) -- get socket options
gettimeout() -- return timeout or None
listen([n]) -- start listening for incoming connections
recv(buflen[, flags]) -- receive data
recv_into(buffer[, nbytes[, flags]]) -- receive data (into a buffer)
recvfrom(buflen[, flags]) -- receive data and sender's address
recvfrom_into(buffer[, nbytes, [, flags])
  -- receive data and sender's address (into a buffer)
sendall(data[, flags]) -- send all data
send(data[, flags]) -- send data, may not send all of it
sendto(data[, flags], addr) -- send data to a given address
setblocking(bool) -- set or clear the blocking I/O flag
getblocking() -- return True if socket is blocking, False if non-blocking
setsockopt(level, optname, value[, optlen]) -- set socket options
settimeout(None | float) -- set or clear the timeout
shutdown(how) -- shut down traffic in one or both directions
if_nameindex() -- return all network interface indices and names
if_nametoindex(name) -- return the corresponding interface index
if_indextoname(index) -- return the corresponding interface name
 [*] not available on all platforms!
_accept() -> (integer, address info)
Wait for an incoming connection.  Return a new socket file descriptor
representing the connection, and the address of the client.
For IP sockets, the address info is a pair (hostaddr, port).
bind(address)
Bind the socket to a local address.  For IP sockets, the address is a
pair (host, port); the host must refer to the local host. For raw packet
sockets the address is a tuple (ifname, proto [,pkttype [,hatype [,addr]]])
close()
Close the socket.  It cannot be used after this call.
connect(address)
Connect the socket to a remote address.  For IP sockets, the address
is a pair (host, port).
connect_ex(address) -> errno
This is like connect(address), but returns an error code (the errno value)
instead of raising an exception when an error occurs.
detach()
Close the socket object without closing the underlying file descriptor.
The object cannot be used after this call, but the file descriptor
can be reused for other purposes.  The file descriptor is returned.
fileno() -> integer
Return the integer file descriptor of the socket.
getpeername() -> address info
Return the address of the remote endpoint.  For IP sockets, the address
info is a pair (hostaddr, port).
getsockname() -> address info
Return the address of the local endpoint. The format depends on the
address family. For IPv4 sockets, the address info is a pair
(hostaddr, port).
getsockopt(level, option[, buffersize]) -> value
Get a socket option.  See the Unix manual for level and option.
If a nonzero buffersize argument is given, the return value is a
string of that length; otherwise it is an integer.
listen([backlog])
Enable a server to accept connections.  If backlog is specified, it must be
at least 0 (if it is lower, it is set to 0); it specifies the number of
unaccepted connections that the system will allow before refusing new
connections. If not specified, a default reasonable value is chosen.
recv(buffersize[, flags]) -> data
Receive up to buffersize bytes from the socket.  For the optional flags
argument, see the Unix manual.  When no data is available, block until
at least one byte is available or until the remote end is closed.  When
the remote end is closed and all data is read, return the empty string.
recv_into(buffer, [nbytes[, flags]]) -> nbytes_read
A version of recv() that stores its data into a buffer rather than creating
a new string.  Receive up to buffersize bytes from the socket.  If buffersize
is not specified (or 0), receive up to the size available in the given buffer.
See recv() for documentation about the flags.
recvfrom(buffersize[, flags]) -> (data, address info)
Like recv(buffersize, flags) but also return the sender's address info.
recvfrom_into(buffer[, nbytes[, flags]]) -> (nbytes, address info)
Like recv_into(buffer[, nbytes[, flags]]) but also return the sender's address info.
send(data[, flags]) -> count
Send a data string to the socket.  For the optional flags
argument, see the Unix manual.  Return the number of bytes
sent; this may be less than len(data) if the network is busy.
sendall(data[, flags])
Send a data string to the socket.  For the optional flags
argument, see the Unix manual.  This calls send() repeatedly
until all data is sent.  If an error occurs, it's impossible
to tell how much data has been sent.
sendto(data[, flags], address) -> count
Like send(data, flags) but allows specifying the destination address.
For IP sockets, the address is a pair (hostaddr, port).
setblocking(flag)
Set the socket to blocking (flag is true) or non-blocking (false).
setblocking(True) is equivalent to settimeout(None);
setblocking(False) is equivalent to settimeout(0.0).
getblocking()
Returns True if socket is in blocking mode, or False if it
is in non-blocking mode.
settimeout(timeout)
Set a timeout on socket operations.  'timeout' can be a float,
giving in seconds, or None.  Setting a timeout of None disables
the timeout feature and is equivalent to setblocking(1).
Setting a timeout of zero is the same as setblocking(0).
gettimeout() -> timeout
Returns the timeout in seconds (float) associated with socket
operations. A timeout of None indicates that timeouts on socket
operations are disabled.
setsockopt(level, option, value: int)
setsockopt(level, option, value: buffer)
setsockopt(level, option, None, optlen: int)
Set a socket option.  See the Unix manual for level and option.
The value argument can either be an integer, a string buffer, or
None, optlen.
shutdown(flag)
Shut down the reading side of the socket (flag == SHUT_RD), the writing side
of the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR).
recvmsg(bufsize[, ancbufsize[, flags]]) -> (data, ancdata, msg_flags, address)
Receive normal data (up to bufsize bytes) and ancillary data from the
socket.  The ancbufsize argument sets the size in bytes of the
internal buffer used to receive the ancillary data; it defaults to 0,
meaning that no ancillary data will be received.  Appropriate buffer
sizes for ancillary data can be calculated using CMSG_SPACE() or
CMSG_LEN(), and items which do not fit into the buffer might be
truncated or discarded.  The flags argument defaults to 0 and has the
same meaning as for recv().
The return value is a 4-tuple: (data, ancdata, msg_flags, address).
The data item is a bytes object holding the non-ancillary data
received.  The ancdata item is a list of zero or more tuples
(cmsg_level, cmsg_type, cmsg_data) representing the ancillary data
(control messages) received: cmsg_level and cmsg_type are integers
specifying the protocol level and protocol-specific type respectively,
and cmsg_data is a bytes object holding the associated data.  The
msg_flags item is the bitwise OR of various flags indicating
conditions on the received message; see your system documentation for
details.  If the receiving socket is unconnected, address is the
address of the sending socket, if available; otherwise, its value is
unspecified.
If recvmsg() raises an exception after the system call returns, it
will first attempt to close any file descriptors received via the
SCM_RIGHTS mechanism.
recvmsg_into(buffers[, ancbufsize[, flags]]) -> (nbytes, ancdata, msg_flags, address)
Receive normal data and ancillary data from the socket, scattering the
non-ancillary data into a series of buffers.  The buffers argument
must be an iterable of objects that export writable buffers
(e.g. bytearray objects); these will be filled with successive chunks
of the non-ancillary data until it has all been written or there are
no more buffers.  The ancbufsize argument sets the size in bytes of
the internal buffer used to receive the ancillary data; it defaults to
0, meaning that no ancillary data will be received.  Appropriate
buffer sizes for ancillary data can be calculated using CMSG_SPACE()
or CMSG_LEN(), and items which do not fit into the buffer might be
truncated or discarded.  The flags argument defaults to 0 and has the
same meaning as for recv().
The return value is a 4-tuple: (nbytes, ancdata, msg_flags, address).
The nbytes item is the total number of bytes of non-ancillary data
written into the buffers.  The ancdata item is a list of zero or more
tuples (cmsg_level, cmsg_type, cmsg_data) representing the ancillary
data (control messages) received: cmsg_level and cmsg_type are
integers specifying the protocol level and protocol-specific type
respectively, and cmsg_data is a bytes object holding the associated
data.  The msg_flags item is the bitwise OR of various flags
indicating conditions on the received message; see your system
documentation for details.  If the receiving socket is unconnected,
address is the address of the sending socket, if available; otherwise,
its value is unspecified.
If recvmsg_into() raises an exception after the system call returns,
it will first attempt to close any file descriptors received via the
SCM_RIGHTS mechanism.
sendmsg(buffers[, ancdata[, flags[, address]]]) -> count
Send normal and ancillary data to the socket, gathering the
non-ancillary data from a series of buffers and concatenating it into
a single message.  The buffers argument specifies the non-ancillary
data as an iterable of bytes-like objects (e.g. bytes objects).
The ancdata argument specifies the ancillary data (control messages)
as an iterable of zero or more tuples (cmsg_level, cmsg_type,
cmsg_data), where cmsg_level and cmsg_type are integers specifying the
protocol level and protocol-specific type respectively, and cmsg_data
is a bytes-like object holding the associated data.  The flags
argument defaults to 0 and has the same meaning as for send().  If
address is supplied and not None, it sets a destination address for
the message.  The return value is the number of bytes of non-ancillary
data sent.
Implementation module for socket operations.
See the socket module for documentation.
gethostbyname(host) -> address
Return the IP address (a string of the form '255.255.255.255') for a host.
gethostbyname_ex(host) -> (name, aliaslist, addresslist)
Return the true host name, a list of aliases, and a list of IP addresses,
for a host.  The host argument is a string giving a host name or IP number.
gethostbyaddr(host) -> (name, aliaslist, addresslist)
Return the true host name, a list of aliases, and a list of IP addresses,
for a host.  The host argument is a string giving a host name or IP number.
gethostname() -> string
Return the current host name.
sethostname(name)
Sets the hostname to name.
getservbyname(servicename[, protocolname]) -> integer
Return a port number from a service name and protocol name.
The optional protocol name, if given, should be 'tcp' or 'udp',
otherwise any protocol will match.
getservbyport(port[, protocolname]) -> string
Return the service name from a port number and protocol name.
The optional protocol name, if given, should be 'tcp' or 'udp',
otherwise any protocol will match.
getprotobyname(name) -> integer
Return the protocol number for the named protocol.  (Rarely used.)
close(integer) -> None
Close an integer socket file descriptor.  This is like os.close(), but for
sockets; on some platforms os.close() won't work for socket file descriptors.
dup(integer) -> integer
Duplicate an integer socket file descriptor.  This is like os.dup(), but for
sockets; on some platforms os.dup() won't work for socket file descriptors.
socketpair([family[, type [, proto]]]) -> (socket object, socket object)
Create a pair of socket objects from the sockets returned by the platform
socketpair() function.
The arguments are the same as for socket() except the default family is
AF_UNIX if defined on the platform; otherwise, the default is AF_INET.
ntohs(integer) -> integer
Convert a 16-bit unsigned integer from network to host byte order.
Note that in case the received integer does not fit in 16-bit unsigned
integer, but does fit in a positive C int, it is silently truncated to
16-bit unsigned integer.
However, this silent truncation feature is deprecated, and will raise an
exception in future versions of Python.
ntohl(integer) -> integer
Convert a 32-bit integer from network to host byte order.
htons(integer) -> integer
Convert a 16-bit unsigned integer from host to network byte order.
Note that in case the received integer does not fit in 16-bit unsigned
integer, but does fit in a positive C int, it is silently truncated to
16-bit unsigned integer.
However, this silent truncation feature is deprecated, and will raise an
exception in future versions of Python.
htonl(integer) -> integer
Convert a 32-bit integer from host to network byte order.
inet_aton(string) -> bytes giving packed 32-bit IP representation
Convert an IP address in string format (123.45.67.89) to the 32-bit packed
binary format used in low-level network functions.
inet_ntoa(packed_ip) -> ip_address_string
Convert an IP address from 32-bit packed binary format to string format
inet_pton(af, ip) -> packed IP address string
Convert an IP address from string format to a packed string suitable
for use with low-level network functions.
inet_ntop(af, packed_ip) -> string formatted IP address
Convert a packed IP address of the given family to string format.
getaddrinfo(host, port [, family, type, proto, flags])
    -> list of (family, type, proto, canonname, sockaddr)
Resolve host and port into addrinfo struct.
getnameinfo(sockaddr, flags) --> (host, port)
Get host and port for a sockaddr.
getdefaulttimeout() -> timeout
Returns the default timeout in seconds (float) for new socket objects.
A value of None indicates that new socket objects have no timeout.
When the socket module is first imported, the default is None.
setdefaulttimeout(timeout)
Set the default timeout in seconds (float) for new socket objects.
A value of None indicates that new socket objects have no timeout.
When the socket module is first imported, the default is None.
if_nameindex()
Returns a list of network interface information (index, name) tuples.
if_nametoindex(if_name)
Returns the interface index corresponding to the interface name if_name.
if_indextoname(if_index)
Returns the interface name corresponding to the interface index if_index.
CMSG_LEN(length) -> control message length
Return the total length, without trailing padding, of an ancillary
data item with associated data of the given length.  This value can
often be used as the buffer size for recvmsg() to receive a single
item of ancillary data, but RFC 3542 requires portable applications to
use CMSG_SPACE() and thus include space for padding, even when the
item will be the last in the buffer.  Raises OverflowError if length
is outside the permissible range of values.
CMSG_SPACE(length) -> buffer size
Return the buffer size needed for recvmsg() to receive an ancillary
data item with associated data of the given length, along with any
trailing padding.  The buffer space needed to receive multiple items
is the sum of the CMSG_SPACE() values for their associated data
lengths.  Raises OverflowError if length is outside the permissible
range of values.
error
socket.herror
herror
socket.gaierror
gaierror
socket.timeout
timeout
SocketType
socket
has_ipv6
CAPI
_socket.CAPI
AF_UNSPEC
AF_INET
AF_UNIX
AF_IPX
AF_APPLETALK
AF_INET6
AF_DECnet
AF_ROUTE
AF_LINK
AF_SNA
PF_SYSTEM
AF_SYSTEM
SOCK_STREAM
SOCK_DGRAM
SOCK_RAW
SOCK_SEQPACKET
SOCK_RDM
SO_DEBUG
SO_ACCEPTCONN
SO_REUSEADDR
SO_KEEPALIVE
SO_DONTROUTE
SO_BROADCAST
SO_USELOOPBACK
SO_LINGER
SO_OOBINLINE
SO_REUSEPORT
SO_SNDBUF
SO_RCVBUF
SO_SNDLOWAT
SO_RCVLOWAT
SO_SNDTIMEO
SO_RCVTIMEO
SO_ERROR
SO_TYPE
LOCAL_PEERCRED
SO_BINDTODEVICE
SOMAXCONN
SCM_RIGHTS
SCM_CREDS
MSG_OOB
MSG_PEEK
MSG_DONTROUTE
MSG_DONTWAIT
MSG_EOR
MSG_TRUNC
MSG_CTRUNC
MSG_WAITALL
MSG_NOSIGNAL
MSG_EOF
SOL_SOCKET
SOL_IP
SOL_TCP
SOL_UDP
IPPROTO_IP
IPPROTO_HOPOPTS
IPPROTO_ICMP
IPPROTO_IGMP
IPPROTO_GGP
IPPROTO_IPV4
IPPROTO_IPV6
IPPROTO_IPIP
IPPROTO_TCP
IPPROTO_EGP
IPPROTO_PUP
IPPROTO_UDP
IPPROTO_IDP
IPPROTO_HELLO
IPPROTO_ND
IPPROTO_TP
IPPROTO_ROUTING
IPPROTO_FRAGMENT
IPPROTO_RSVP
IPPROTO_GRE
IPPROTO_ESP
IPPROTO_AH
IPPROTO_ICMPV6
IPPROTO_NONE
IPPROTO_DSTOPTS
IPPROTO_XTP
IPPROTO_EON
IPPROTO_PIM
IPPROTO_IPCOMP
IPPROTO_SCTP
IPPROTO_RAW
IPPROTO_MAX
SYSPROTO_CONTROL
IPPORT_RESERVED
IPPORT_USERRESERVED
INADDR_ANY
INADDR_BROADCAST
INADDR_LOOPBACK
INADDR_UNSPEC_GROUP
INADDR_ALLHOSTS_GROUP
INADDR_MAX_LOCAL_GROUP
INADDR_NONE
IP_OPTIONS
IP_HDRINCL
IP_TOS
IP_TTL
IP_RECVOPTS
IP_RECVRETOPTS
IP_RECVDSTADDR
IP_RETOPTS
IP_MULTICAST_IF
IP_MULTICAST_TTL
IP_MULTICAST_LOOP
IP_ADD_MEMBERSHIP
IP_DROP_MEMBERSHIP
IP_DEFAULT_MULTICAST_TTL
IP_DEFAULT_MULTICAST_LOOP
IP_MAX_MEMBERSHIPS
IPV6_JOIN_GROUP
IPV6_LEAVE_GROUP
IPV6_MULTICAST_HOPS
IPV6_MULTICAST_IF
IPV6_MULTICAST_LOOP
IPV6_UNICAST_HOPS
IPV6_V6ONLY
IPV6_CHECKSUM
IPV6_DONTFRAG
IPV6_DSTOPTS
IPV6_HOPLIMIT
IPV6_HOPOPTS
IPV6_NEXTHOP
IPV6_PATHMTU
IPV6_PKTINFO
IPV6_RECVDSTOPTS
IPV6_RECVHOPLIMIT
IPV6_RECVHOPOPTS
IPV6_RECVPKTINFO
IPV6_RECVRTHDR
IPV6_RECVTCLASS
IPV6_RTHDR
IPV6_RTHDRDSTOPTS
IPV6_RTHDR_TYPE_0
IPV6_RECVPATHMTU
IPV6_TCLASS
IPV6_USE_MIN_MTU
TCP_NODELAY
TCP_MAXSEG
TCP_KEEPINTVL
TCP_KEEPCNT
TCP_INFO
TCP_FASTOPEN
TCP_NOTSENT_LOWAT
EAI_ADDRFAMILY
EAI_AGAIN
EAI_BADFLAGS
EAI_FAIL
EAI_FAMILY
EAI_MEMORY
EAI_NODATA
EAI_NONAME
EAI_OVERFLOW
EAI_SERVICE
EAI_SOCKTYPE
EAI_SYSTEM
EAI_BADHINTS
EAI_PROTOCOL
EAI_MAX
AI_PASSIVE
AI_CANONNAME
AI_NUMERICHOST
AI_NUMERICSERV
AI_MASK
AI_ALL
AI_V4MAPPED_CFG
AI_ADDRCONFIG
AI_V4MAPPED
AI_DEFAULT
NI_MAXHOST
NI_MAXSERV
NI_NOFQDN
NI_NUMERICHOST
NI_NAMEREQD
NI_NUMERICSERV
NI_DGRAM
SHUT_RD
SHUT_WR
SHUT_RDWR
_socket.socket
<socket object, fd=%ld, family=%d, type=%d, proto=%d>
_accept
bind
close
connect
connect_ex
detach
fileno
getpeername
getsockname
getsockopt
listen
recv
recv_into
recvfrom
recvfrom_into
send
sendall
sendto
setblocking
getblocking
settimeout
gettimeout
setsockopt
shutdown
recvmsg
recvmsg_into
sendmsg
getsockaddrlen: unknown PF_SYSTEM protocol
getsockaddrlen: bad family
timed out
OiII
(II)
Invalid address type
socket.bind
AF_UNIX path too long
%s(): AF_INET address must be tuple, not %.500s
O&i;AF_INET address must be a pair (host, port)
%s(): port must be 0-65535.
%s(): AF_INET6 address must be tuple, not %.500s
O&i|II;AF_INET6 address must be a tuple (host, port[, flowinfo[, scopeid]])
%s(): flowinfo must be 0-1048575.
provided string is too long
cannot find kernel control with provided name
%s(): PF_SYSTEM address must be a str or a pair (id, unit)
%s(): unsupported PF_SYSTEM protocol
%s(): bad family
idna
encoding of hostname failed
str, bytes or bytearray expected, not %s
host name must not contain null character
unsupported address family
wildcard resolved to multiple address
255.255.255.255
<broadcast>
address family mismatched
unknown address family
(is)
socket.connect
ii|i:getsockopt
getsockopt buflen out of range
|i:listen
n|i:recv
negative buffersize in recv
buffer
nbytes
flags
w*|ni:recv_into
negative buffersize in recv_into
buffer too small for requested bytes
n|i:recvfrom
negative buffersize in recvfrom
w*|ni:recvfrom_into
negative buffersize in recvfrom_into
nbytes is greater than the length of the buffer
y*|i:send
y*|i:sendall
y*O:sendto
y*iO:sendto
sendto() takes 2 or 3 arguments (%zd given)
socket.sendto
Timeout value out of range
iii:setsockopt
iiO!I:setsockopt
iiy*:setsockopt
n|ni:recvmsg
negative buffer size in recvmsg()
invalid ancillary data buffer length
received malformed or improperly-truncated ancillary data
NOiN
O|ni:recvmsg_into
recvmsg_into() argument 1 must be an iterable
recvmsg_into() argument 1 is too long
w*;recvmsg_into() argument 1 must be an iterable of single-segment read-write buffers
O|OiO:sendmsg
socket.sendmsg
sendmsg() argument 2 must be an iterable
(iiy*):[sendmsg() ancillary data items]
ancillary data item too large
too much ancillary data
unexpected NULL result from %s()
CMSG_FIRSTHDR
CMSG_NXTHDR
item size out of range for CMSG_LEN()
ancillary data does not fit in calculated space
sendmsg() argument 1 must be an iterable
sendmsg() argument 1 is too long
y*;sendmsg() argument 1 must be an iterable of bytes-like objects
family
the socket family
type
the socket type
proto
the socket protocol
the socket timeout
|iiiO:socket
socket.__new__
Oiii
integer argument expected, got float
negative file descriptor
unclosed %R
_socket
gethostbyname
gethostbyname_ex
gethostbyaddr
gethostname
sethostname
getservbyname
getservbyport
getprotobyname
socketpair
ntohs
ntohl
htons
htonl
inet_aton
inet_ntoa
inet_pton
inet_ntop
getaddrinfo
getnameinfo
getdefaulttimeout
setdefaulttimeout
if_nameindex
if_nametoindex
if_indextoname
CMSG_LEN
CMSG_SPACE
et:gethostbyname
socket.gethostbyname
et:gethostbyname_ex
et:gethostbyaddr
socket.gethostbyaddr
socket.gethostname
S:sethostname
O&:sethostname
socket.sethostname
s|s:getservbyname
socket.getservbyname
service/proto not found
i|s:getservbyport
getservbyport: port must be 0-65535.
socket.getservbyport
port/proto not found
s:getprotobyname
protocol not found
|iii:socketpair
i:ntohs
ntohs: can't convert negative Python int to C 16-bit unsigned integer
ntohs: Python int too large to convert to C 16-bit unsigned integer (The silent truncation is deprecated)
int larger than 32 bits
expected int, %s found
i:htons
htons: can't convert negative Python int to C 16-bit unsigned integer
htons: Python int too large to convert to C 16-bit unsigned integer (The silent truncation is deprecated)
s:inet_aton
illegal IP address string passed to inet_aton
y*:inet_ntoa
packed IP wrong length for inet_ntoa
is:inet_pton
illegal IP address string passed to inet_pton
iy*:inet_ntop
invalid length of packed IP address string
unknown address family %d
host
port
OO|iiii:getaddrinfo
getaddrinfo() argument 1 must be string or None
Int or String expected
socket.getaddrinfo
OOiii
iiisO
Oi:getnameinfo
getnameinfo() argument 1 must be a tuple
si|II;getnameinfo(): illegal sockaddr argument
getnameinfo(): flowinfo must be 0-1048575.
socket.getnameinfo
sockaddr resolved to multiple addresses
IPv4 sockaddr must be 2 tuple
O&:if_nametoindex
no interface with this name
n:CMSG_LEN
CMSG_LEN() argument out of range
n:CMSG_SPACE
CMSG_SPACE() argument out of range
