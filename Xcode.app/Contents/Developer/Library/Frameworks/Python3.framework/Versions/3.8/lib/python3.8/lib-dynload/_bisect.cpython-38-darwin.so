_bisect
bisect_right
insort_right
bisect_left
insort_left
OO|nn:bisect_right
lo must be non-negative
OO|nn:insort_right
insert
OO|nn:bisect_left
OO|nn:insort_left
Bisection algorithms.
This module provides support for maintaining a list in sorted order without
having to sort the list after each insertion. For long lists of items with
expensive comparison operations, this can be an improvement over the more
common approach.
bisect_right(a, x[, lo[, hi]]) -> index
Return the index where to insert item x in list a, assuming a is sorted.
The return value i is such that all e in a[:i] have e <= x, and all e in
a[i:] have e > x.  So if x already appears in the list, i points just
beyond the rightmost x already there
Optional args lo (default 0) and hi (default len(a)) bound the
slice of a to be searched.
insort_right(a, x[, lo[, hi]])
Insert item x in list a, and keep it sorted assuming a is sorted.
If x is already in a, insert it to the right of the rightmost x.
Optional args lo (default 0) and hi (default len(a)) bound the
slice of a to be searched.
bisect_left(a, x[, lo[, hi]]) -> index
Return the index where to insert item x in list a, assuming a is sorted.
The return value i is such that all e in a[:i] have e < x, and all e in
a[i:] have e >= x.  So if x already appears in the list, i points just
before the leftmost x already there.
Optional args lo (default 0) and hi (default len(a)) bound the
slice of a to be searched.
insort_left(a, x[, lo[, hi]])
Insert item x in list a, and keep it sorted assuming a is sorted.
If x is already in a, insert it to the left of the leftmost x.
Optional args lo (default 0) and hi (default len(a)) bound the
slice of a to be searched.
_bisect
bisect_right
insort_right
bisect_left
insort_left
OO|nn:bisect_right
lo must be non-negative
OO|nn:insort_right
insert
OO|nn:bisect_left
OO|nn:insort_left
Bisection algorithms.
This module provides support for maintaining a list in sorted order without
having to sort the list after each insertion. For long lists of items with
expensive comparison operations, this can be an improvement over the more
common approach.
bisect_right(a, x[, lo[, hi]]) -> index
Return the index where to insert item x in list a, assuming a is sorted.
The return value i is such that all e in a[:i] have e <= x, and all e in
a[i:] have e > x.  So if x already appears in the list, i points just
beyond the rightmost x already there
Optional args lo (default 0) and hi (default len(a)) bound the
slice of a to be searched.
insort_right(a, x[, lo[, hi]])
Insert item x in list a, and keep it sorted assuming a is sorted.
If x is already in a, insert it to the right of the rightmost x.
Optional args lo (default 0) and hi (default len(a)) bound the
slice of a to be searched.
bisect_left(a, x[, lo[, hi]]) -> index
Return the index where to insert item x in list a, assuming a is sorted.
The return value i is such that all e in a[:i] have e < x, and all e in
a[i:] have e >= x.  So if x already appears in the list, i points just
before the leftmost x already there.
Optional args lo (default 0) and hi (default len(a)) bound the
slice of a to be searched.
insort_left(a, x[, lo[, hi]])
Insert item x in list a, and keep it sorted assuming a is sorted.
If x is already in a, insert it to the left of the leftmost x.
Optional args lo (default 0) and hi (default len(a)) bound the
slice of a to be searched.
