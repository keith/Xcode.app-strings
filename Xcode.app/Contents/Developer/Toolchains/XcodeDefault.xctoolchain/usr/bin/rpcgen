$NetBSD: rpc_clntout.c,v 1.8 1997/10/18 10:53:37 lukem Exp $
$NetBSD: rpc_cout.c,v 1.14 1998/08/25 20:59:40 ross Exp $
$NetBSD: rpc_hout.c,v 1.9 1998/02/11 23:11:17 lukem Exp $
$NetBSD: rpc_main.c,v 1.14 1997/10/18 10:53:53 lukem Exp $
$NetBSD: rpc_parse.c,v 1.9 1998/02/11 23:11:18 lukem Exp $
$NetBSD: rpc_sample.c,v 1.5 1997/10/18 10:54:01 lukem Exp $
$NetBSD: rpc_scan.c,v 1.6 1997/10/18 10:54:05 lukem Exp $
$NetBSD: rpc_svcout.c,v 1.10 1997/10/18 10:54:07 lukem Exp $
$NetBSD: rpc_tblout.c,v 1.7 1997/10/18 10:54:11 lukem Exp $
$NetBSD: rpc_util.c,v 1.8 1997/10/18 10:54:14 lukem Exp $
@(#)PROGRAM:rpcgen  PROJECT:developer_cmds-66
/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { %d, 0 };
*argp, %s%s)
(argp, %s)
*argp;
void
(%s%s)
(%s)
%s, 
 %s%s)
%s%s;
clnt
CLIENT *
 arg;
static 
char 
memset((char *)%s%s, 0, sizeof(%s));
if (clnt_call(clnt, %s, xdr_void
, NULL, xdr_%s, %s%s, TIMEOUT) != RPC_SUCCESS) {
arg.%s = %s;
if (clnt_call(clnt, %s, xdr_%s, &arg, xdr_%s, %s%s, TIMEOUT) != RPC_SUCCESS)
if (clnt_call(clnt, %s, xdr_%s, %s%s, xdr_%s, %s%s, TIMEOUT) != RPC_SUCCESS)
argp
return (NULL);
return ((void *)%s%s);
return (%s%s);
Internal error %s, %d: Case %d not handled
/Library/Caches/com.apple.xbs/Sources/developer_cmds/developer_cmds-66/rpcgen/rpc_cout.c
int i;
%s *genp;
for (i = 0, genp = objp->%s;
    i < %s; i++) {
IXDR_PUT_
objp->%s = IXDR_GET_
*genp++ = IXDR_GET_
LONG
U_INT
U_LONG
%s(buf, objp->%s);
%s(buf, *genp++);
%s(buf);
malloc failed
bool_t
xdr_%s(
XDR *xdrs, 
objp)
xdr_%s(xdrs, objp)
XDR *xdrs;
objp;
return (TRUE);
enum
(enum_t *)objp
if (!xdr_%s(xdrs
, %s
return (FALSE);
objp->%s
&objp->%s
pointer
(char **)
string
opaque
vector
(char *)
bytes
array
%s.%s_val, (u_int *)%s.%s_len
&%s->%s_val, (u_int *)&%s->%s_len
bool
, sizeof(bool_t), (xdrproc_t)xdr_bool
, sizeof(
%s), (xdrproc_t)xdr_%s
objp->%s_u.%s
&objp->%s_u.%s
switch (objp->%s) {
case %s:
break;
default:
return (FALSE);
int32_t *buf;
if (xdrs->x_op == XDR_ENCODE) {
%s%s * %d
%s%s
Fatal error : no memory
buf = (int32_t *)XDR_INLINE(xdrs, %d * BYTES_PER_XDR_UNIT);
buf = (int32_t *)XDR_INLINE(xdrs, %s * BYTES_PER_XDR_UNIT);
buf = (int32_t *)XDR_INLINE(xdrs, (%d + %s) * BYTES_PER_XDR_UNIT);
if (buf == NULL) {
} else {
} else if (xdrs->x_op == XDR_DECODE) {
} else {
objp
#ifdef __cplusplus
extern "C" bool_t xdr_%s(XDR *, %s%s);
#elif __STDC__
extern  bool_t xdr_%s(XDR *, %s%s);
#else /* Old Style C */
bool_t xdr_%s();
#endif /* Old Style C */
struct 
char *%s
bool_t
char
%s%s %s
%s%s %s[%s]
%s%s *%s
struct {
u_int %s_len;
%s%s *%s_val;
} %s
#define %s %s
struct %s {
typedef struct %s %s;
bool_t %s;
%s %s;
union {
} %s_u;
extern struct rpcgen_table %s_%s_table[];
extern %s_%s_nproc;
#ifdef __cplusplus
extern "C" 
#elif __STDC__
extern  
#else /* Old Style C */
struct svc_req *
#endif /* Old Style C */
#define %s ((rpc_uint)%s)
Internal error %s, %d: procedure not found
/Library/Caches/com.apple.xbs/Sources/developer_cmds/developer_cmds-66/rpcgen/rpc_hout.c
%s);
enum %s {
 = %s
 = %d
 = %s + %d
typedef enum %s %s;
typedef 
-DRPC_XDR
-DRPC_HDR
-DRPC_CLNT
-DRPC_SVC
-DRPC_TBL
-DRPC_SERVER
-DRPC_CLIENT
_xdr.c
_clnt.c
_svc.c
_tbl.i
_server.c
_client.c
rpcgen
netpath
#include "%s"
#include <rpc/rpc.h>
long
short
u_int
u_long
u_short
<stdin>
execv
fork
%s: 
cannot find C preprocessor: %s
/lib/cpp
cannot find any C preprocessor (cpp)
/usr/bin/cpp
rpcgen: too many defines
Out of memory
%s: output would overwrite %s
%s: unable to open 
 * Please do not edit this file.
 * It was generated using rpcgen.
#ifndef _%s
#define _%s
#define RPCGEN_VERSION
199506
#include <rpc/rpc.h>
#endif /* !_%s */
_H_RPCGEN
#include <sys/ioctl.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <rpc/pmap_clnt.h>
#include <string.h>
#include <netdb.h>
#include <signal.h>
#include <sys/ttycom.h>
#include <sysent.h>
#endif /* __cplusplus */
#include <sys/types.h>
#include <memory.h>
#include <stropts.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netconfig.h>
#include <sys/resource.h>
#include <syslog.h>
#ifdef __STDC__
#define SIG_PF void(*)(int)
#endif
#ifdef DEBUG
#define RPC_SVC_FG
#endif
#define _RPCSVC_CLOSEDOWN %s
static SVCXPRT *caller;
illegal nettype :'%s'
visible
circuit_v
datagram_v
circuit_n
datagram_n
Cannot specify more than one input file!
/cpp
Cannot use netid flag with inetd flag!
Cannot use netid flag without TIRPC!
Cannot use table flags with newstyle!
Cannot have more than one file generation flag!
usage:  %s infile
%s [-a][-b][-C][-Dname[=value]] -i size  [-I [-K seconds]] [-A][-L][-M toolkit][-N][-T] infile
%s [-c | -h | -l | -m | -t | -Sc | -Ss] [-o outfile] [infile]
%s [-s nettype]* [-o outfile] [infile]
%s [-n netid]* [-o outfile] [infile]
options:
generate svc_caller() function
generate all files, including samples
backward compatibility mode (generates code for SunOS 4.1)
generate XDR routines
ANSI C mode
-Dname[=value]
define a symbol (same as #define)
generate header file
-i size
size at which to start generating inline code
generate code for inetd support in server (for SunOS 4.1)
-K seconds
server exits after K seconds of inactivity
generate client side stubs
server errors will be printed to syslog
generate server side stubs
-n netid
generate server code that supports named netid
supports multiple arguments and call-by-value
-o outfile
name of the output file
-s nettype
generate server code that supports named nettype
generate sample client code that uses remote procedures
generate sample server code that defines remote procedures
generate RPC dispatch table
generate code to support RPC dispatch tables
-Y path
directory name to find C preprocessor (cpp)
definition keyword expected
no array-of-pointer declarations -- use typedef
array declaration expected
variable-length array declaration expected
int64_t
voids allowed only inside union and program definitions with one argument
expected type specifier
u_char
u_int64_t
illegal (reserved) name :'%s' in type definition
destroy
free
getpos
inline
reference
setpos
sizeof
union
illegal result type
only one argument is allowed
illegal use of void in program definition
%s%d
opaque -- illegal argument type
pointer to string not allowed in program arguments
arrays cannot be declared as arguments to procedures -- use typedef
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
main( int argc, char* argv[] )
main(argc, argv)
int argc;
char *argv[];
char *host;
if(argc < 2) {
printf("usage: %%s server_host\n", argv[0]);
exit(1);
host = argv[1];
( host );
void
( char* host )
(host)
char *host;
CLIENT *clnt;
 *result_%d;
char* 
_arg;
_%s;
clnt = clnt_create(host, %s, %s, "%s");
if (clnt == NULL) {
clnt_pcreateerror(host);
exit(1);
result_%d = 
(void*)
_arg, clnt);
(clnt);
_%s, 
clnt);
if (result_%d == NULL) {
clnt_perror(clnt, "call failed:");
clnt_destroy( clnt );
static 
char*
 result;
 * insert server code here
return(&result);
return((void*) &result);
constant or identifier expected
#pragma
illegal character in file: 
unterminated string constant
empty char string
const
switch
case
default
struct
typedef
unsigned
hyper
float
double
quadruple
program
version
??????
preprocessor error
extern
static
%s int _rpcpmstart;
/* Started by a port monitor ? */
%s int _rpcfdtype;
/* Whether Stream or Datagram ? */
%s int _rpcsvcdirty;
/* Still serving ? */
int main( int argc, char* argv[] );
main( int argc, char* argv[] )
main(argc, argv)
int argc;
char *argv[];
SVCXPRT *%s;
struct netconfig *nconf = NULL;
pid_t pid;
int i;
char mname[FMNAMESZ + 1];
else {
nconf = getnetconfigent("%s");
if (nconf == NULL) {
cannot find %s netid.
exit(1);
%s = svc_tli_create(RPC_ANYFD, nconf, 0, 0, 0);
if (%s == NULL) {
cannot create %s service.
(void) rpcb_unset(%s, %s, nconf);
if (!svc_reg(%s, %s, %s, 
, nconf)) {
unable to register (%s, %s, %s).
freenetconfigent(nconf);
if (!svc_create(
, %s, %s, "%s")) {
unable to create (%s, %s) for %s.
exit(1);
if (%s == (SVCXPRT *)NULL) {
could not create a handle
if (_rpcpmstart) {
(void) signal(SIGALRM, %s closedown);
(SIG_PF)
(void(*)())
(void) alarm(_RPCSVC_CLOSEDOWN);
svc_run();
svc_run returned
exit(1);
/* NOTREACHED */
static
void _msgout(msg)
char *msg;
void _msgout(char* msg)
#ifdef RPC_SVC_FG
if (_rpcpmstart)
syslog(LOG_ERR, "%%s", msg);
else
(void) fprintf(stderr, "%%s\n", msg);
#else
syslog(LOG_ERR, "%%s", msg);
#endif
if ((_rpcfdtype == 0) || (_rpcfdtype == %s)) {
SOCK_DGRAM
SOCK_STREAM
if (_rpcpmstart)
%s = svc%s_create(%s
sock
RPC_ANYSOCK
, 0, 0
else
%s = svc%s_create(%s
if (!_rpcpmstart)
proto = IPPROTO_%s;
if (!svc_register(%s, %s, %s, 
, proto)) {
, IPPROTO_%s)) {
 *argp, struct svc_req *%s)
%s *argp;
 *argp;
struct svc_req *%s;
return(
*argp, 
argp->%s, 
%s));
static 
void 
(struct svc_req *%s, 
SVCXPRT *%s);
void
SVCXPRT *%s)
(%s, %s)
int fill;
} %s;
char *%s;
xdrproc_t xdr_%s, xdr_%s;
char *(*%s)(char *, struct svc_req *);
bool_t (*xdr_%s)(), (*xdr_%s)();
char *(*%s)();
caller = transp;
_rpcsvcdirty = 1;
switch (%s->rq_proc) {
case NULLPROC:
(void) svc_sendreply(%s, (xdrproc_t) xdr_void, (char *)NULL);
%s = (char *(*)(char *, struct svc_req *)) 
%s = (char *(*)()) 
break;
noproc
(void) memset((char *)&%s, 0, sizeof (%s));
getargs
(caddr_t) &
decode
%s = (*%s)((char *)&%s, %s);
%s = (*%s)(&%s, %s);
if (%s != NULL && !svc_sendreply(%s, (xdrproc_t) xdr_%s, %s)) {
systemerr
freeargs
unable to free arguments
%sexit(0);
%s_rpcsvcdirty = 0;
%sreturn;
xdr_%s = (xdrproc_t) xdr_%s;
xdr_%s = xdr_%s;
svcerr_%s(%s);
if (!svc_%s(%s, xdr_%s, %s%s)) {
SVCXPRT *%s = NULL;
int sock;
int proto = 0;
struct sockaddr_in saddr;
int asize = sizeof (saddr);
if (getsockname(0, (struct sockaddr *)&saddr, &asize) == 0) {
int ssize = sizeof (int);
if (saddr.sin_family != AF_INET)
exit(1);
if (getsockopt(0, SOL_SOCKET, SO_TYPE,
(char *)&_rpcfdtype, &ssize) == -1)
sock = 0;
_rpcpmstart = 1;
proto = 0;
sock = RPC_ANYSOCK;
%s(void) pmap_unset(%s, %s);
%ssyslog(LOG_ERR, "%%s", "%s");
%s_msgout("%s");
%sfprintf(stderr, "%%s", "%s");
static void closedown(void);
static void
closedown()
if (_rpcsvcdirty == 0) {
extern fd_set svc_fdset;
static int size;
int i, openfd;
struct t_info tinfo;
if (!t_getinfo(0, &tinfo) && (tinfo.servtype == T_CLTS))
if (_rpcfdtype == SOCK_DGRAM)
exit(0);
if (size == 0) {
struct rlimit rl;
rl.rlim_max = 0;
getrlimit(RLIMIT_NOFILE, &rl);
if ((size = rl.rlim_max) == 0)
return;
size = getdtablesize();
for (i = 0, openfd = 0; i < size && openfd < 2; i++)
if (FD_ISSET(i, &svc_fdset))
openfd++;
if (openfd <= (_rpcpmstart?0:1))
(void) alarm(_RPCSVC_CLOSEDOWN);
char *svc_caller()
struct sockaddr_in actual;
struct hostent *hp;
static struct in_addr prev;
static char cname[128];
actual = *svc_getcaller(caller);
if (memcmp((char *)&actual.sin_addr, (char *)&prev,
 sizeof(struct in_addr)) == 0)
return (cname);
prev = actual.sin_addr;
hp = gethostbyaddr((char *) &actual.sin_addr, sizeof(actual.sin_addr), AF_INET);
if (hp == NULL) {                       /* dummy one up */
extern char *inet_ntoa();
strcpy(cname, inet_ntoa(actual.sin_addr));
strcpy(cname, hp->h_name);
return (cname);
if (!ioctl(0, I_LOOK, mname) &&
(!strcmp(mname, "sockmod") ||
 !strcmp(mname, "timod"))) {
char *netid;
struct netconfig *nconf = NULL;
SVCXPRT *%s;
int pmclose;
if ((netid = getenv("NLSPROVIDER")) == NULL) {
cannot get transport name
} else if ((nconf = getnetconfigent(netid)) == NULL) {
cannot get transport info
if (strcmp(mname, "sockmod") == 0) {
if (ioctl(0, I_POP, 0) || ioctl(0, I_PUSH, "timod")) {
could not get the right module
exit(1);
pmclose = (t_getstate(0) != T_DATAXFER);
if ((%s = svc_tli_create(0, nconf, NULL, 0, 0)) == NULL) {
cannot create server handle
if (nconf)
freenetconfigent(nconf);
if (!svc_reg(%s, %s, %s, 
, 0)) {
unable to register (%s, %s).
if (pmclose) {
(void) signal(SIGALRM, %s closedown);
(void) alarm(_RPCSVC_CLOSEDOWN);
svc_run();
/* NOTREACHED */
#ifndef RPC_SVC_FG
%sint size;
%sstruct rlimit rl;
%sint pid, i;
%spid = fork();
%sif (pid < 0) {
perror("cannot fork");
exit(1);
%sif (pid)
exit(0);
%srl.rlim_max = 0;
%sgetrlimit(RLIMIT_NOFILE, &rl);
%sif ((size = rl.rlim_max) == 0)
%ssize = getdtablesize();
%sfor (i = 0; i < size; i++)
(void) close(i);
%si = open("/dev/console", 2);
%s(void) dup2(i, 1);
%s(void) dup2(i, 2);
%ssetsid();
%si = open("/dev/tty", 2);
%sif (i >= 0) {
(void) ioctl(i, TIOCNOTTY, (char *)NULL);
%sopenlog("%s", LOG_PID, LOG_DAEMON);
%s_%s
 * WARNING: table out of order
WARNING %s table is out of order
(char *(*)())RPCGEN_ACTION(
xdr_%s,
sizeof ( 
wrapstring
enum 
bool_t 
char *
%s_%s_svc
%s, line %d: 
too many files!
expected '%s'
expected '%s' or '%s'
expected '%s', '%s' or '%s'
failed in malloc
%s_%s_%s
argument
identifier
clnt_res
struct rpcgen_table {
char
*(*proc)();
xdrproc_t
xdr_arg;
unsigned
len_arg;
xdrproc_t
xdr_res;
unsigned
len_res;
rqstp
transp
rqstp
argument
result
local
struct rpcgen_table %s_table[] = {
(char *(*)())0,
(xdrproc_t)xdr_void,
(xdrproc_t)xdr_void,
int %s_nproc =
sizeof(%s_table)/sizeof(%s_table[0]);
