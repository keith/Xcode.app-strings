""""""""""""""""
St20bad_array_new_length
St9bad_alloc
St12out_of_range
St12length_error
St11logic_error
St9exception
////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\
::::::::::::::::::::::::
************************
????????????????????????
""""""""
<<<<<<<<<<<<<<<<<<<<<<<<
>>>>>>>>>>>>>>>>>>>>>>>>
||||||||||||||||||||||||
OnlyVertexShaderIGC::PositionOnl
L ( 
L ( 
L * 
A` 
L ( 
L ( 
L * 
A` 
8 .@
8@.`
e'7d@
vX6E@
1FE#@
TgTgA
2d2dA
WWWWA
q8q8A
cTcTA
8T8TA
2424A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%
Xx!C
!B##
!4!4
V#V#
&T&T
#1#1
!#!#
    
 " "
0000
0303
@@@@
@D@D
PPPP
PUPU
PUPU
pppp
8 .@
8@.`
e'7d@
vX6E@
1FE#@
TgTgA
2d2dA
WWWWA
q8q8A
cTcTA
8T8TA
2424A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%
Xx!C
!B##
!4!4
V#V#
&T&T
#1#1
!#!#
    
 " "
0000
0303
@@@@
@D@D
PPPP
PUPU
PUPU
pppp
L ( 
L ( 
L * 
A` 
L ( 
L ( 
L * 
A` 
L ( 
L ( 
L * 
A` 
e'7d@
vX6E@
1FE#@
TgTgA
2d2dA
WWWWA
q8q8A
cTcTA
8T8TA
2424A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%
Xx!C
!B##
!4!4
V#V#
&T&T
#1#1
!#!#
    
 " "
0000
0303
@@@@
@D@D
PPPP
PUPU
PUPU
````
,I .@
,I@.`
,I`.
,I .
,I@.
,I`.
e'7d@
vX6E@
1FE#@
TgTgA
2d2dA
WWWWA
q8q8A
cTcTA
8T8TA
2424A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%
Xx!C
!B##
!4!4
V#V#
&T&T
#1#1
!#!#
    
 " "
0000
0303
@@@@
@D@D
PPPP
PUPU
PUPU
````
$K %
$K@$
$K`$
e'7d@
vX6E@
1FE#@
TgTgA
2d2dA
WWWWA
q8q8A
cTcTA
8T8TA
2424A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%
Xx!C
!B##
!4!4
V#V#
&T&T
#1#1
!#!#
    
 " "
0000
0303
@@@@
@D@D
PPPP
PUPU
PUPU
````
lyRoundedDivSqrtCorrectlyRoundedFloatRoundingMode
athOptimizationsUnsafeMathOptimiacePrivateMemoryUseScratchSpacePGreaterThan2GBBuGreaterThan4GBBuhConstantsEnablePushConstantsEnaHasBufferOffsetArg
balOffsetsByZeroreplaceGlobalOffSIMDMode
forcePixelShaderoNotAbortOnSpillpixelShaderDoNotComponentPackingdisableVertexComages
PreferBindlessImeMathRefactoringdisableMathRefacworkGroupWalkOrder
ferLocationIndexbufferLocationInferLocationCountbufferLocationCoType
NumberOfFunctioninlineSamplersMDdSubGroupsNumberCompiledSubGrouplers
hasInlineVmeSampprivateMemoryPerWI
ctToDirectCalleeindirectToDirectssSpaces
m_OpenCLArgAddreAccessQualifiersm_OpenCLArgAccesm_OpenCLArgTypesypes
m_OpenCLArgBaseTrgTypeQualifiersm_OpenCLArgTypeQm_OpenCLArgNamespushableAddresses
dBuffers
MaxNumberOfPushefferSlot
tantBufferOffsettBufferGRFOffsetsimplePushInfoArr
Used
simplePushBufferhAnalysisWIInfospushAnalysisWIInirectBufferIndexDrawIndirectBufftateDisabledMaskBlendStateDisablBlendingDisabledDualSourceBlendiForceEnableSimd32
blendToFillEnabled
hasVersionedLoopetiveInterpolanthasNonPerspetiveOptimizationModeblendOptimizatiomaxWorkGroupSizederSecondCompileComputeShaderSecl_ResWidthHeightruntimeVal_ResWiount
runtimeVal_LoopCnstantBufferSizeruntimeVal_ConstultipleSIMDModesallowMultipleSIMcheduler
forcedVISAPreRASirection
EnableTextureIndEnableSamplerIndsamplerStateStride
samplerStateOffset
textureStateStritextureStateOffsinlineDynConstants
inlineDynTextureeConstantBuffersineGlobalBuffersinlineGlobalBuffogramBinaryInfosGlobalPointerProPushConstantSizeMinNOSPushConstagramScopeOffsetsinlineProgramScoertexHeaderInputerOutput
UseBindlessImageourcesNotAliasedstatefullResourcSMemorySizePerWItotalTLSMemorySiglobalDataUniform
GlobalDataAccesshasGlobalDataAccNormalizedCoordsinterpolationModPointerBufferIndex
nteeAddressSpacePointeeAddressSpPointeeBufferInd
pler_initializer__translate_samp__builtin_spirv_
size
hint
_air.read_textureair.write_texturair.get_array_size
t_num_mip_levelsair.get_num_mip__num_samples.i32air.get_num_samp_samples_textureum_samples_depthlate_clamped_lodair.calculate_clte_unclamped_lodair.calculate_unhannel_data_typeair.get_channel_et_channel_orderture
air.get_null_texair.get_null_depth
.is_null_textureair.is_null_textair.is_null_depth
air.fence_texturexplicit_textureair.atomic_load_air.extract_bitsair.reverse_bitsair.fast_fmedian3
identifier_depthair.get_unique_ishuffle_rotate_up
ffle_rotate_downshuffle_rotate_dive_threads_maskactive_threads_mis_helper_threadterpolate_centercentroid
terpolate_sampleterpolate_offset_icb
igc.air.indirect_pso
_sample_positionair.get_sample_p
__FastRelaxedMat
.indirect_bufferair.indirect_bufinfo
air.struct_type_n_function_tableair.intersectiontrol_point_inputair.patch_controndirect_constantair.indirect_conair.command_bufft_command_bufferair.indirect_comr_pipeline_stateair.render_pipele_pipeline_stateair.compute_pipee_function_tableair.visible_func.imageblock_dataair.imageblock_dlification_countair.amplification_id
nter
air.function_poimageblock_masterair.imageblock_mata_size
_type_align_sizeair.arg_type_aliair.location_indair.arg_type_namair.arg_type_sizster_order_groupair.raster_orderair.render_target
ndirect_argumentair.indirect_arg
NSt3__117bad_function_callE
eric
air.lgamma_r.genlag_begin_marker__flag_begin_mar__flag_end_marke_compute_commandair.set_barrier_.dyld_flat_tableair.dyld_flat_ta
e_in_grid_originair.get_global_id
_local_linear_idair.get_local_li
air.kernel
air.vertex
air.version
air.language_version
air.compile_options
air.location_index
air.read
air.write
air.read_write
air.sample
air.buffer_size
air.arg_type_name
air.arg_type_size
air.arg_type_align_size
air.arg_name
air.emulation_argument
ests
early_fragment_tair.fragment_input
ay_index
air.viewport_arrd_origin
air.stage_in_gri_instance_strideair.tessellationposition_in_gridair.threadgroup_age_in_grid_sizeaccessible_inputair.inaccessiblesellation_factorair.inside_tesseint_index_bufferair.control_poin_per_threadgroupair.simdgroups_pair.quadgroups_pair.edge_tessellgrid
air.threads_per_air.base_instancair.buffer_stridrget_array_indexion_factor_scaleex_buffer_offsetair.patch_index_dex_in_simdgroupair.thread_indexdex_in_quadgrouparycentric_coordair.barycentric_osition_in_patchair.position_in_r_command_bufferair.render_commadgroups_per_gridair.threadgroupsds_per_simdgroupair.thread_positx_in_threadgroupe_command_bufferair.compute_comm_execution_widthair.thread_execu.default_uniformair.default_unifair.vertex_inputair.front_facingair.primitive_idair.sample_mask_in
.depth_unchangedair.depth_unchanair.clip_distancair.depth_greateair.vertex_outpuair.partitioningch_control_point_work_group_sizeair.max_work_grove_double_enableair.compile.nati.denorms_disablee.denorms_enableast_math_disablefast_math_disabl
.loop.peel.countspv.loop.peel.cop.iterations.maxspv.loop.iterati
-fast-relaxed-math-optimizations-unsafe-math-opt-no-signed-zeros-denorms-are-zero
-finite-math-only
-relaxed-builtinimage1d_buffer_timage2d_buffer_taa_t
ray_msaa_depth_tth_t
image2d_msaa_dep2d_array_depth_timage2d_array_deenqueuedLocalSiz
ltin_IB_to_localin_IB_to_private
ffffff
eue_kernel_basicue_kernel_vaargsel_events_vaargsel
__builtin_IB_kmp_
ivre
precompiled_s32dprecompiled_u32d
iled_s32divrem_siled_u32divrem_s__igcbuiltin_sp_di
b0$IY
2$IB
(CUUd
P$v`
clang version 4.0.1 #
cs)s
c+s1
       
ELzA
E`XB
C8QM_A
A45n0
PV~5
dPB0
1KpTd]
,A1PA
nx:0
L&SHT
t,>b&
T>b8
>b3
T>b/
WdPB0
1KpTd]A
$;KPT
7<{
[M"0OM
T>q!
B?5 
N"QA
#>bV
@A4S
J"8Me
K"8Mu
DdK
#>rR
#>bQ
#5nO
#>b1
#uoC
WdPB0
1KpTd]a
$;KPT
7<{
,A5P
3PAT
$;K0
"8Mu
#7of
LfsHT
#>bN
#8n9
#>bk
T>q!
B?5 
@A4S
J"8Me
K"8Mu
#wo_
#vo3
"8Mu
#9o7
#>bR
#yo+
T>q!Sn
#zmK
B?5 
DdL
#zoS
#>b1
#&sHG
#>bO
WdPB0
1KpTd]
A0PAT
\@Jp
,AtC
WdPB0
`aA
$c0s
XT#0OM
#vo:
#7oa
"0OM
 )>
#>bb
#>bI
=1@3
B?5 
#xnG
#8Me
#8Me
U#QA
a@#Q
B?5 
B?5 
2Y^#8M
#>bi
#0OM
WdPB0
1KpTd]
,A1PA
+2(!
@+ v
BX(e
24J0K
D7dpE
2LRPB
+2(!
A+ v
2lX0K
WdPB0
H7PATa`"]
&Tb
B+ v
Pm0PA n
Tc!5
ba5
lC+ v
Gm2
B?5 
@ITP
#8Me
#8M
#>r0h
T>q!
Dd4
z@$8M
 )>
#8Mu
 )>
S#8M
T>q!
T>q!
Q#QA
B?5 
#ynS
#>bj
Xi@#
r@$QA
 )>
$8Mu
#>bW
#8Me
 )>
Y9@3
d@$QA
m9NT
B?5 
Y#8M
#F%IG
 )>
B?5 
#{nl
#w~.
#8Mu
B?5 
c!@ H
WdPB0
1KpTd]
%DQm`\
,AtC
WdPB0
$c0s
|7dpE
%DQ7a\
`. b
7<y
1hA\
`. b
1hAy2
Td]
%DQ#b\
`. b
7<e
pC`&d0
,A+Td
%DQwb\
`. b
,A.T
0PA 
FF+ v
~!(!
0PA 
fAmhf
F+ v
3:`0
@$0OM
$8Me
#>rD
T>q!
#>r0j
T>q!
B?5 
Dt5
#V/@
#>rB
$8Mu
V$8Mu
$8Mu
%8Me
v@$8M
#&;P
@A4S
#>r[b
T>q!
#7@Y
Dtid
T>q!
`@$QA
 )>
Xp@$8M
B?5 
#f;`
$0OM
 )>
Dd}
#v;`
B?5 
 )>
XZ$QA
#|~.
#F/P
#>b|
#>rNd`
%0OM
%0OM
#6-0
 )>
/P9Q
%8Me
#8~f
B?5 
u~aj
B?5 
#v9@
;@IG
&8Mu
$8Me
LV=p
 )>
809Q
T>q!
;@IT
B?5 
f@$Q
 )>
j@$8Mu
#G0!
B?5 
#>r'
}ce`
B?5 
PV~5
dPBP
1KPTd
D4`A
L7LTPC
nX20
T>q!
 )>b+
t,>b&
tD>r
A4>b.
#vRD
WdPBP
1KPTd
+2(!
V0*0
2PAh
#VsHT
#>b7
#umE
#5n.
#>b8
#>b+GD0>
 )>
O"8M
WdPBP
1KPTd
+2(!
V0*0
2PAh
,AsC
WdPBP
TdU
#wmI
M[W"
Dd4
#>b5
#wo7
L6c8
>q!
J"8Me
#9mAID0>
#ym.
#>b8
#>bK
#:mF
K"8M
>q!
#yo6
"8Me
 )>
#wnWID0>
#voa
WdPBP
1KPTd
Bcg
L>bB
 )>
#>b,
#>b3
#>bA
 )>
#8nt
X#0OM
}[[#8M
#0OM
[^#Q
Q#8M
#5}
#>be
Ddz
WdPBP
1KPTd
2$H0K
a$sVP
20K0K
2PAD
2LR0K@
ZdLsV
,A6P
+2(!
0%/@0
h0PAhe`
F]2
L#8Me
 )>
#>b5
#>ba
@A4S
#8M
 )>
R#8M
#9mg
>r"h
>q!
#>bi
#|nu
>q!
LwAY
#>bK
Xk@$0OM
#8Me
#>bh
#>bU
#>bz
c!@ H
WdPBP
1KPTd
+2(!
2PAh
,AsC
WdPBP
TdUC
+2(!
5PAh
\7dpE
@EV]
tCI@A
%@b
nB+ v
7,a
WdPBP
sVP
WdPBP
=pcA=r
C+ v
A0KP
7dpE
Bs0PADu
"PPC
ldDJ
 Cp&32
&:RB
7dpE
K}0PAD
'PPC
r+`0
WdPBP
V0.Z
]pe
E+ v
7,#
 C 2
@$0OM
#9oi
0ITP
>rKd
>q!
>q!S
@%8M
f@$8M
Gp^B
>q!
$8Me
V.0E
&0OM
#>b_
 )>
#wnY
 )>
>q!
6809
 )>
#f+@
-@ITP
#5m[q
@%QA
>q!
#F,@
qA@3
>rGe`
 )>
U$8M
#7@Y
#}}%
$8Me
f)`9
#>bb
 )>
PD0>
Dd@
>rAb
>q!
y@%QA
]$0OM
>r@k
>q!
 )>
#9nL
,0IT
#&-0
$0OM
0ITP
#>bx
@%8Me
    
$;KPT
LVRHT
#um@
T>q!
!8Mu
 )>r
A4>b5
tD>b0
#64HT`1
    
A0PAT
f`rP
vTHT
#xmZ
#>b<
#6oi
#5m6
#>bh
T>q!
"8Me
#>bT
#uoE
D>b2
 )>
#>b]
#voe
#>bQ
    
A0PAT
f`rP
,AtC
wdPB0
#>b<
#>b,
#xmt
y)@3
#<mc
@A4S
L"8Mu
"8Mu
&sH
#>bO
#xnz
L=oHJDL
"8Me
#>b[
 )>
#>bD
#|n;
#>blLDL
"0OM
"8Mu
#>b0
#=ms
"8Me
    
A0PAT
0PA 
D 7
`. b
X-!
30\(B0
D7dpG
XA9h
2LRP
;2(!
RB+ v
2lX0K
bp![}
 )>
#>bA
#>b;
#>bI
#>b2
#wn>
#vt\N
L>bl
#zmnNDL
#yn|
nJLDL
X#0OM
#{nD
>b`
 )>
    
B0PAT
$;KPT
f`{P
,AtC
wdPB0
$c0sf
hP>1
Td]
J7PAda@.
a0PA
B<D
bA5
;2(!
Pm0PA n
D+ v
'CL7
O#8Mu
#8~(
#V&IG
#|oA
!1NT
i@$8Me
#:muPDL
#>bj
#gS!
T>q!
 )>
>q!S
#>r#
#8oG
>q!S
 )>
T>q!
#<ni
#>bf
#>bg
~@$0OM
n[d@
#>b`
j@$8Mu
|@$8Mu
@$0OM
    
PV~5P
n >301(B0
7dpG
,A1PA
;2(!
fA+ v
BX(e
24J0K
C:7
,A5P
3PAT
$;K0
Tb!%
aa%
f`.Q
7<h
X\!
|7dpG
XAhh
`. b
wdPB0
o0PA
xdaGXd
#f``R
;2(!
0*s2
P*t2
30T)B0
P{0PA |
E+ v
F!(a
c2`0
u2CL7
7dpG
0PAd
0PAT
T*T
D 7
:Y`7W
X0gt@0
,A.T
0PA 
 2pp
B0K 
!301*B0
0PAd
Di!
1Jf`
;2(!
+@ITP
#>b`
;`IG
@$0OM
$8Me
DdF
#>rf
#unp
#>rg
#5m_
}[S#
T>q!
>A&QA
 )>
$8Me
%8Mu
f:@E
]$0OM
$8Mu
#>b~
[_s9
l@4 
LF-`ITP
T>q!
>rNe`
@A4S
N`IT
 )>
HN[v@$8Mu
#v?0
 )>
#>rSf
#uN_
@%8M
~Uc`
 )>
#>r[b
T>q!
#>r=
J@IG
@%8M
0ITP
%8Mu
y}Mb
T>q!
_[p@
I0IT
#f>@
#>r>h
T>q!
#f;0
X?Au9
#WR!
#V-P
;0IT
#&/@IG
#u}[(
%8Me
%8Me
L&-@
#wQ!
#7!!
m\PDL
#wr!
#&; 
JPIT
&I0MN
#>r(
z@s9
$0OM
OpIG
X:A&8Me
>r"h
T>q!
#>rEg
#F>`I
$8Mu
-A59
w}9``
#>rhn
T>q!
z@$QA
^$QA
g@$QA
$8Me
&K`ITP
#6__
    
,A1P
L7hRPC
VRHT
#&SH
#FSHG
3`>b=
!0OM
    
,A1P
f`mP
2$H0K
&THT
,>ba
#6o-
#>bC
XL"8Me
#>b3
#>bR
 )>
#vmW
Dd+
>q!
    
,A1P
f`mP
2$H0K
Bcg
#>b;
#>bk
#>bt
#8mpID0>
#wnZ
#yoj
>q!S
#>bI
#;ox
>q!
#zm=
 )>
#xmC
O"QA
#>b1
#>by
L"8M
"8M
#>b?
m2GD0>
#>b8
    
,A1P
@+ v
,AsC
wdPBP
TdU#
XA.h
A+ v
7,#
hP#!
#zm;
>q!
#8Me
#8o{
#vnq
#5nT
#xoA
#:mb
i1@3
L>bi
>q!
#vmE
#>bB
#8m?
#>bU
`@"Q
_#QA
>by
Ddd
    
,A1P
;2(!
2PAh
Z(B0
47dpG
@EV5p
tC9HA
;2(!
5PAh
wdPBP
]|RU
B+ v
s_P
7dpG
#uot
Yv@$8M
[l@#8
@$QA
|@$8
#8Me
#>b\
y@$QA
 )>
MD0>
#0OM
[x@$0OM
) IT
#:mi
Hm[}
>q!
 )>
#>b[
#7mq
#7o?
    
PV~5P
,A1P
2$H0K
1|A,
Bcg
0E%@0
2LR0K@
f`=1
2XU0Kp
J5PAD
D 7
TdU
7PADa
 400
cA?
;2(!
h0PAhe`
&#hP3"
 C0#
D 7
A0K 
U+BL7
30_)B0
 4:0
eA_
;2(!
|0PAhy`
&3hP3#
 C03
 4?0@a
fAo
7f`}S
;2(!
0PAh
&;hP
*TdU*
)T@>w
D 7
 "W@
v>@IG
@%8M
>q!
neOD0>
#>bR
>q!
Ho[i
*A&0OM
Xs@$0OM
)@IT
Xj@$
 )>
#fIPIT
#>bFMD0>
>q!
t3b`
OD0>
+PMN
 )>
#>bk
/ IT
v*@IG
#>rC
*`ITP
>r,h
>q!
$8Me
) IT
<@ITP
@A4S
#>bg
#V80
#F>`
 )>
#>bH
#V:@I
#w0!
#5^_
"A%Q
[(A&
#>rOd
%8Me
@$8M
u}Ab
>q!
<0IT
#v9 
59@3
$0OM
$8Me
#7mu
#<mq
9@IT
TD0>
 )>
$0OM
%8Me
#8Me
#680
#;n`
f< I
#5][
IpIT
#un_
QD0>
#vm_
< IG
@%8M
%8Me
; IT
$0OM
H`ITP
 )>
9 IT
v<pIG
#6][
#u^[
Dt8e`
%0OM
9 MN
f@$8
B?5 U
p+F=c
b0$IY
= UD0
@0D"
P$v`
wchar_sizeclang version 7.0.0 
 3C@
intomnipotent charSimple C/C++ TBAA
r6J
_ (511bp!
D2b`!
,5n%
"MND0Dd
!8MU
1He
H!QAM
H!QAm[J!QA
0&aLN
precompiled_u32divrem_spGenISA_uitof_rtzGenISA_fma_rtzGenISA_mul_rtzGenISA_add_rtz7.0.0x86_64-pc-windows-msvcprecompiled_u32divrem_sp.cl
b0$IY
= UD0
@0D"
P$v`
wchar_sizeclang version 7.0.0 
 3C@
intomnipotent charSimple C/C++ TBAA
C0b`!
F1HGd<HDL
Dvm 
@A4S
D7m3
G!8M
[H!8M
!8Me%
!8MU
0HK`
I!QA}[J!QA
M[L!Q
0vo
precompiled_s32divrem_spGenISA_uitof_rtzGenISA_fma_rtzGenISA_mul_rtzGenISA_add_rtz7.0.0x86_64-pc-windows-msvcprecompiled_s32divrem_sp.cl
b0$IY
`B L
P$v`
PIC Levelclang version 4.0.1 (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-clang 3621e01986d729d27ffa6d8cc3e2020357cc420b) (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-llvm 26ebe8b7270e331f307f8d763aa5dd076abb0335)
3C@
   B
g@QA
g0bp
B0K@T
t!.
hb&`
'a0P
b0$IY
P$v`
clang version 4.0.1 (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-clang 3621e01986d729d27ffa6d8cc3e2020357cc420b) (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-llvm 26ebe8b7270e331f307f8d763aa5dd076abb0335)#
cs)s
c+s1
5@4F
intomnipotent charSimple C/C++ TBAA
Q6F
)TUt
B2b`!
SA$5
1K T
"MND0Dd
D!8MU[D!8Me
D!8Mu
F!8M
j?C-
= UD0
b0$IY
P$v`
clang version 4.0.1 (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-clang 3621e01986d729d27ffa6d8cc3e2020357cc420b) (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-llvm 26ebe8b7270e331f307f8d763aa5dd076abb0335)#
cs)s
c+s1
5P>Dc
intomnipotent charSimple C/C++ TBAA
1bp!
fR\NT
1HGd'HDL
,v0H
VA\Nt
AHGT
D5m$
)@0A
j?C-
2D$H
`B L
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
lnJP
TDT,
V?EFU
HxA@
XxA@
L0!
(T(L
pa`0
a7@0K
2H]P
NB7@0
2L]0
2PY0
`207
D`PA
Z0#0
LM@P
Tp+\D
OnpA@!
NU4,p
AP73
|37a0
pCp7`0
T@;Zds7xA@
B@-4*
!@!0
!`!0
f+`P
0w}&
#(5nP
>n[
Ddi
#(5m
)R9S}
~"II
V?EFU
6408A
n(lA
.f
p A1-
&@0K
$.Pj
2TV0
@EPd8
@GnP
Vd&[
@\.P
/C3`0
5#2h0
hX /
3xA@
hX0:
*lxG
pC ?`0
,A+T
BPx#?Z
?aP{C?:
B@*4*
4p?[
V0=YP
#(5n
0@f
Lf0\Hc
>r1JI
>b`
v0`Hc
)R9S
#VK@
2D$H
`B L
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
*llvm.identS
v67%(
TDT,
P>5P
@xA@
PxA@
PxA@
2$MP
l,`P
np^Cf
2|^py
#`0P
@E@Kd`
\XF+
f.P%s3ZB
n(L'J
:`PA
;`PA
|gT`>;
!`la
)BPB
 zAx
C0KP
`PB
%AB\
Dth
#(v~(
@D&>
fHpH
@D:m
^[(A"
D?q=N
4Cn[
08m
08o
v0`Hc
)R9S
SA5P
PqT50
HxA@
XxA@
hxA@
lxA@
^A+0
RDAM
$pA@
\d0p
BpAD
"@!H
5!F@P
BPEp
599K
`*E0
@"^@0Kp
[h`.Xi
:kf
r5-W
DaD
37h0
@@;T0
BpAD
r0K 
*LHK
?TFh0
FPur?|
BP!!FZ
)T0
dK`0
!8-0
Z1b 
+BPB
!`Tb
ZAg 
0;+BPB
&6j`0
pC0k`0
!p70
mT0r;
E@"7*`
pCpr`P
!x90
vnTPv;
pX r
!.T#
!x;0
vw`0
P"gwZ
s\!Wr<
a4T#
s}@s~
M[e@
6+p
0@f
>~[
r[qA
~^[p
@DuM
@Du]
0:n
0:o
@Dum
0;m
d4>m
0;n
FX`P
SMtK
,VipH
flpH
~MKI
7`"B
YLa(
%=|)r
(=|)r
&"$_
{S&x"B
&=|)r
&]|)r
uC&p
s{-p
q34H&
Y|d""_
'"$_
#E*g
&DP0
#E*g
s+%8R
%]|)r
%]|)r
X\py
(=|)r
K'8R
2D$H
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
lnJP
TDT,
v+Lv
l+P[`
6,_+Hx
*BQm
*^Td
*r^a
*BhA
*Ism
f%~*
w*JNY
$m*W
?f*~LM
'l_*
\*lBt
6O*^Q
L*]kt
&t?*
<*Pe{
4*bC
BD^'*ylc
*DHP
(@hn
(@hn
(@`H
(@hq
(@`b
(@@I
(@@b
(@Pl
(@hi
(@X[
(@@b
(@h@
(@pV
(@@b
(@@t
Sh%Q
R4eS8
R"ER&
S<%TDeTH
TP%UTeUX
VbEVf
WrEWv
tJg0"8
o LG&
tFb0"8
o0Pg$
#uFb0"8
o@Tg$
duFb0"8
oPXg$
uFb0"8
ujb0"8
'vLb0"8
hvLb0"8
vLb0"8
vLb0"8
+wLb0"8
lw~b0"8
wPb0"8
b0"8
b0"8
b0"8
 }Zb0"8
}Zb0"8
 ~Zb0"8
~\b0"8
Bc0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
2QK'2
bQNn2
rQO/2
QR12
QS12
QV12
QW12
"RZ"3
b3xA
J-0-
J-P-
"8)@M
`H+0
.0QH
GaG7d
V r;K
0Pa 
2@K0
('r`0
HA-.
HJ+ 
,A5P
.PHYi
DLo/0a
h1lC
Tp~Z
`/0QD
i0Pa
.0aA}
v`c0
/0aA
xv0"
v0b
obMK
@0K
vj`H
I('auD
@DW&
~0KI
0'auD
0@f
@D;}n
v0\Hsa
f~p
)R9S
2D$H
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
A#66
%QZP
2(IP
2HMP
 5Bd
2D$H
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
A#66
(~@X@
;K`T
2LU0
9('auD
B17
5`8K0T
,A1P
@pb0
F}B7
xIYpp
o3ODH
BPFpu
%0J
2$H0
PH-p
,ASH
6/ |
1('auD
5P8K0T
FqB7
2 I`
2I~m
2D$H
`@R
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
ksi{#
c+s1c
XA/h
20KPB)\
B0K 
^ PC
D0KP
r0K 
KX81
%('auD
@-S~
#(5}
`]LDH
)R9So
)R9S}
@akk!
V0\Hc
7Dd
t$r
f0@f 
_>m/
`HV$
2D$H
 0BXe`!P
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
lnJP
KP4Y
/HAL
_a*&
?c_a'G
5^!B
fa6]Q
\QJ'
g*e[
ls1[
lo0Z1
Ya[j
Yq/R
m5-Y
9gtXA
|d8X1.
W1_f
WAZ#z
 $ x@
 <nx@
 twy@
 l5z@
 dcz@
 $d{@
 xw{@
 (#|@
 |*|@
 hf|@
 ds|@
 h$}@
 h-}@
g+dVA
TA_sG
n1tS
p(8S
p*SA
*&-R17v"
QQFZ
/jkQQ
;aQQ
`?7Q
s-Q!F
)tzP
(;iPa
+w8P
i80P
%&(P
  '{@
 l4{@
 8a{@
 |#|@
 |>|@
 4o|@
 4w|@
 d-}@
 08}@
 l=}@
 |b}@
 xg}@
 hl}@
 (q}@
 <z}@
T    D
(@@@@
)@@@@
Xb0"
Bb0"
Bb0"
Bb0"
Db0"
db0"
Fb0"
Fb0"
Fb0"
Fb0"
Fb0"
Fb0"
Hb0"
Nb0"
Nb0"
Nb0"
Pb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
`D0V
(ag"2
`D0V
`D0V
`D0V
4!j$2
`D0V
8aj$2
`D0V
`D0V
`D0V
d!kd2
`D0V
hak(2
`D0V
`D0V
`D0V
t!n)2
`D0V
xan)2
`D0V
`D0V
`D0V
!o+2
`D0V
ao+2
`D0V
`D0V
`D0V
!r+2
`D0V
ar+2
`D0V
`D0V
`D0V
!s+2
`D0V
as+2
`D0V
`D0V
`D0V
!v+2
`D0V
av+2
`D0V
`D0V
`D0V
$"w 3
Ff0" 
Ff0" 
hf0" 
Jf0" 
Jf0" 
Jf0" 
Lf0" 
f0" 
Lj/e
Rf0" 
AMr/e
Rf0" 
Mz/e
Rf0" 
Tf0" 
Tf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
0Xf0" 
0Xf0" 
1Xf0" +
1Xf0" 
2Xf0" 
2Xf0" 
3Xf0" +
3Xf0" 
4Xf0" 
4Xf0" 
5Xf0" +
5Xf0" 
6Xf0" 
6Xf0" 
7Xf0" +
7Xf0" 
8Xf0" 
8Xf0" 
9Xf0" +
9Bh0" 
A;bP
@PA
n8@3
&.1bB 
TpZX
1aB 
-(``A
EMX7P
.0q
J- B`A
@(tZ
fK+ 
2HQP
x7-!
2PYp
2h]0
.?LX
ws3bP
wu5bP
3YqBB\
B3 E
+~m
 LNd
05o
0@f
et_sub_group_idv_Z16get_sub_groubindless_image2dess_image_cube_tbindless_image_cage_cube_array_tage_cube_depth_te2d_msaa_depth_te2d_array_msaa_ts_image2d_msaa_t_depth_t
_array_t
bindless_image1d_t
bindless_image3d
uiltin_IB_atomic__builtin_IB_atoirv_OpenCL_sqrt_v_OpenCL_sqrt_cr
opencl.clk_eventblock_descriptorstruct.__block_d 
_IB_media_block___builtin_IB_med_IB_vme_send_fbr_IB_vme_send_ime_IB_vme_send_sicvme_send_sic_newvme_send_fbr_new
__builtin_IB_to_
B_work_group_any__builtin_IB_wor
DDD@DDDV
pwGDl
pwGDpww
//////
zODD
DD@DD
{{{{{{{{{{{{{{{{{{{{{{{{
}}}}}}}}}}}}}}}}}}}}}}}}
&&&&&&&&&&&&&&&&&&&&&&&&
........................
DesiredTypeName =
dLoadConstVCallstypeCheckedLoadCssumeConstVCallstypeTestAssumeCoheckedLoadVCallstypeCheckedLoadVem_or_argmemonlyinaccessiblemem_ccessiblememonlyinaccessiblememoEligibleToImportnotEligibleToImpenceable_or_nulldereferenceable_x86_vectorcallccsanitize_addressvirtualConstPropally_initializedexternally_initilocal_unnamed_addr
sanitize_hwaddress
returnDoesNotAlias
ally
available_externalls
typeTestAssumeVCarameter
DITemplateValuePateTypeParameterDITemplateTypePaDILexicalBlockFiDISubroutineTypeDIGlobalVariableDIImportedEntityriableExpressiondwarfAddressSpac
splitDebugInlining
llvm.vectorizer.llvm.global_ctorllvm.global_dtor
0000000000000000
nstrument_target__llvm_profile_i
8OST
O8TS
m_personality_v0__gxx_wasm_persocessCLRExceptionProcessCLRExceptt_eh_personalityrust_eh_personal__CxxFrameHandler3
_except_handler3_except_handler4personality_seh0__gxx_personalit__gcc_personality_v0
dler
__C_specific_han__gnat_eh_person_personality_sj0c_personality_v0__objc_personali 
llvm.loop.unroll.
liveOnEntry
objc_storeStrongobjc_destroyWeakloadWeakRetainedobjc_loadWeakRetnretainedPointerobjc_unretainedPetainAutoreleaseobjc_retainAutorunretainedObjectobjc_unretainedOc_retainedObjectobjc_retainedObjtoreleasePoolPopobjc_autoreleasetain_autoreleaseobjc_retain_autoleaseReturnValueobjc_retainBlockPoolPush
Optimization Remark Emitter
ll_graph_profilellvm_call_graph_m_linker_optionsllvm_linker_optignu_unique_objecndirect_functiongnu_indirect_fun
ariable_pointersthread_local_var_local_variablesd_local_zerofillthread_local_zerters
lazy_symbol_poinular
thread_local_regpointers
non_lazy_symbol_cstring_literalsliteral_pointers
ckprotectorcheckstackprotectorchnt.group.barrierinvariant.group.arm.thread.point4.thread.pointeraarch64.thread.pe.ss
avx512.broadcastavx512.mask.sqrt.p
.mask.pbroadcastavx512.mask.pbro
avx512.kortestz.w
avx512.kortestc.avx512.mask.pcmp2.mask.fpclass.pavx512.mask.fpclavx512.mask.cmp.avx512.mask.ucmpavx512.cvtb2maskavx512.cvtw2maskavx512.cvtd2maskavx512.cvtq2maskssse3.pabs.b.128ssse3.pabs.w.128ssse3.pabs.d.128avx512.mask.pabsavx512.mask.pmaxu
avx512.mask.pmin512.pmulu.dq.512avx512.pmulu.dq.2.mask.pmulu.dq.avx512.mask.pmulavx512.pmul.dq.512
.dq.
avx.cvtdq2.pd.256
avx.cvtdq2.ps.25avx512.cvtusi2sd2.mask.cvtdq2pd.avx512.mask.cvtd.mask.cvtudq2pd.avx512.mask.cvtuavx.cvt.ps2.pd.256
sk.cvtudq2ps.128sk.cvtudq2ps.256sk.cvtuqq2pd.128sk.cvtuqq2pd.256q2ps.128
q2ps.256
q2pd.128
avx512.mask.cvtqq2pd.256
s2pd.128
avx512.mask.cvtps2pd.256
avx512.mask.loadu.
nd.load.
avx512.mask.expa.compress.store.avx512.mask.compsse42.crc32.64.8avx.vbroadcast.s512.vbroadcast.savx512.vbroadcasavx512.mask.pmovsx
avx.vbroadcastf128
2.vbroadcasti128avx2.vbroadcastiavx512.mask.shuf.i
.mask.broadcastfavx512.mask.broa.mask.broadcastiavx512.pbroadcasmask.broadcast.sgnr.
avx512.mask.pali512.mask.valign.avx512.mask.valiavx512.psll.dq.5avx512.psrl.dq.5avx.vinsertf128.avx512.mask.insert
avx2.vinserti128avx.vextractf128avx2.vextracti128
ract
avx512.mask.vext.df.
avx512.mask.perm.di.
2.mask.vpermil.pavx512.mask.vperf.d.
2.mask.pshufl.w.2.mask.pshufh.w.512.mask.movddupavx512.mask.movdhdup
avx512.mask.movsldup
512.mask.punpcklavx512.mask.punp512.mask.unpckl.avx512.mask.unpc512.mask.punpckh512.mask.unpckh.avx512.mask.pandn.
avx512.mask.por.avx512.mask.pxoravx512.mask.and.avx512.mask.andnavx512.mask.xor.avx512.mask.paddavx512.mask.psubl.
avx512.mask.add.avx512.mask.div.avx512.mask.mul.avx512.mask.sub.avx512.mask.max.avx512.mask.min.avx512.mask.lzcnt.
avx512.mask.psllavx512.mask.psrlavx512.mask.psraavx512.mask.move.s
avx512.mask.pavgdd.s
avx512.mask.vfma2.maskz.vfmadd.savx512.maskz.vfm2.mask3.vfmadd.savx512.mask3.vfm2.mask3.vfmsub.s.mask3.vfnmsub.savx512.mask3.vfndd.p
2.mask.vfnmadd.pavx512.mask.vfnm2.mask.vfnmsub.p2.mask3.vfmadd.p2.mask3.vfmsub.p.mask3.vfnmsub.p2.maskz.vfmadd.pmask.vfmaddsub.paddsub.p
subadd.p
2.mask.pternlog.avx512.mask.pter.maskz.pternlog.avx512.maskz.ptedd52
avx512.mask.vpma2.maskz.vpmadd52avx512.maskz.vpmmask.vpermi2var.mask.vpermt2var.rmt2var.
avx512.maskz.vpe2.mask.vpdpbusd..maskz.vpdpbusd..mask.vpdpbusds.maskz.vpdpbusds.2.mask.vpdpwssd..maskz.vpdpwssd..mask.vpdpwssds.maskz.vpdpwssds.
age Info SectionObjective-C Imag, __objc_catlist__DATA, __objc_cectorizer.unroll512.mask.vfmadd.add.
sub.
2.mask3.vfnmsub..mask.vfmaddsub.maskz.vfmaddsub.mask3.vfmaddsub.mask3.vfmsubadd.512.mask.pcmpeq.512.mask.pcmpgt.f.b.
avx512.mask.pshud2dq.256
d2ps.256
sk.cvttpd2dq.256avx512.mask.cvttsk.cvttps2dq.128sk.cvttps2dq.256var.
mask.pmul.hr.sw.h.w.
2.mask.pmulhu.w.2.mask.pmaddw.d.avx512.mask.pmadmask.pmaddubs.w.2.mask.packsswb.avx512.mask.pack2.mask.packssdw.2.mask.packuswb.2.mask.packusdw.b
mask.vpermilvar..d
2.mask.dbpsadbw.avx512.mask.dbps512.mask.vpshld.avx512.mask.vpsh512.mask.vpshrd.avx512.mask.prorv.
avx512.mask.prol512.mask.storeu.512.mask.store.pe.b.
e.w.
e.d.
e.q.
Debug Info Version
eritance
DIFlagVirtualInhtipleInheritanceDIFlagMultipleInePassByReferenceDIFlagTypePassByirectVirtualBaseDIFlagIndirectVigram
DIFlagMainSubproDIFlagStaticMembgLValueReferenceDIFlagLValueRefegRValueReferenceDIFlagRValueRefegTypePassByValuelagObjectPointerDIFlagObjectPoinbjcClassCompleteDIFlagObjcClassCingleInheritanceDIFlagSingleInhentroducedVirtualDIFlagIntroducedBlockByrefStructDIFlagBlockByrefDIFlagAppleBlockDIFlagArtificialDIFlagPrototyped-?:\,[]{}#&*!|>'"%@`
tion_entry_countsynthetic_functifunction_entry_c.
////////.
JJJJJJJ
JJJJJJJJJJJ
JJJJ@
?,,?
??,?
////:
////////w
JJJJJJJ
JJJJJJJJJJJ
JJJJC
??????
???????
++++
++++
..D...E
..T...D
..D...D
..D...D
..D.
MMLL[
MMLL[
MMLL[
LLLLMMMMMM
MMLL[
MMLL[
MMLL[
MMLL[
LLLLMMMMLLL
LLLLMMMMLLL
LLLLMMMMLL
MMLL[
LLLLMMMMLLLLMMMMML
MMLL[
MMLL[
MMMD
LLLLMMMMLLL
LLLLMMMMLL
MMMD
LLLLMMMMLL
MMMD
...D...D...D...D...D...D..D
,,,,YYYY;;;;JJJJ,,,
,,,,YYYY;;;;JJJJ,,,
,,,,,,,
,,,,,,,
,,,,,,,
YYJJ;;,,JJ;;YYJJ;;,,JJ;;U99
YYJJ;;,,JJ;;YYJJ;;,,JJ;;U99
zzzz
zzzz
;;;;JJJJ;;;;JJJJUD
,,,,YYYY;;;;JJJJU99
;;;;JJJJ;;;;JJJJUD
,,,,YYYY;;;;JJJJU
,,,,YYYY;;;;JJJJ@
PD33PD33PD33PDDDPDDDPDDDPD33PD33PD33P4
PD33PD33PD33PDDDPDDDPDDDPD33PD33PD33PD4
PD33PDDDPD33P4
PD33PDDDPD33PD4
,,,,,,,
zzzzzzz
;;;;;;;;zzz
;;;;J,,JJ;;JJ;;JJ,,JJ;;JJ;;J;,,
zzzzJJJ,;JJ
YYYYYYY
JJJJJJJ
JJJJJJJ
,,,,JJJ
,,,,,,,
;,,;YJJY,YY,J;;J;,,
;,,;YJJYJ;;J,,,,JJJJ;;;;;,,;YJJYJ;;J,,,,JJJJ;;;;;,,;YJJYJ;;J;,,;YJJYJ;;J;,,
,,,,;JJ
,,,,,,,,,,,
{{{{
----KKK
B|||C
 K.D0L.D [.D [.D0
GB,,,
|L|CJ
[BJzJ
L|LC
BYzY
[{[BJzJ
L|LCYzY
[{[B
BzYz
{[{B
[BL|LCYzY
[{[BJzJ
L|LCYzY
[{[B|L|C
BzYz
{[{B0
Bzzz
|||C0
|<|C;z
B|||C0
B|||C0
 K.D0L.D [.D [.D3
JJJJKKKKLLLLJJJJKKKKLLLLJJJJKKKKLLLLJJJJKKKKLLLLJJJJKKKKLLLL;;;;<<<<====
zzJz{{K{||L|YYYYZZZZ[[[[,,,,----
YYYYZZZZ[[[[YYYYZZZZ[[[[JJJ
JJJJ.
zzzz
,,,,;;
YYY"
JJJJYJJYYJJYJJJJYJJYYJJYJ;;J;;;;J;;J;;;;J;;JJ;;J,,,,,,,
))))
!!#!#
""""""""""""""
%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%
""""""""""""""""""
"""""
##########
''''''
((((
((((((((((((((((
((((((((
))))))))
))))))))
))))))))
*****
**********
******
,---
0000
0000000000000000000100
||||
)*1111101
ccccccccc
round.towardzerofpexcept.maytrapMaxInternalCountMaxFunctionCountllvm.compiler.us
z>----------------
                                                                                
[0;30m
[0;31m
[0;32m
[0;33m
[0;34m
[0;35m
[0;36m
[0;37m
[0;1;30m
[0;1;31m
[0;1;32m
[0;1;33m
[0;1;34m
[0;1;35m
[0;1;36m
[0;1;37m
[0;40m
[0;41m
[0;42m
[0;43m
[0;44m
[0;45m
[0;46m
[0;47m
[0;1;40m
[0;1;41m
[0;1;42m
[0;1;43m
[0;1;44m
[0;1;45m
[0;1;46m
[0;1;47m
e_reference_typeDW_TAG_rvalue_ree_type_parameterDW_TAG_template_DW_TAG_with_stmtDW_TAG_base_typeDW_TAG_file_typeDW_TAG_try_blockDW_TAG_namespaceDW_TAG_conditionDW_TAG_type_unit_value_parameterified_parametersDW_TAG_unspecifi_subroutine_typeDW_TAG_subroutin_dwarf_procedureDW_TAG_dwarf_pro_imported_moduleDW_TAG_imported_lined_subroutineDW_TAG_inlined_sr_to_member_typeDW_TAG_ptr_to_mecess_declarationDW_TAG_access_deG_reference_typeDW_TAG_referenceG_structure_typeDW_TAG_structureG_interface_typeDW_TAG_interfaceG_template_aliasG_immutable_typeDW_TAG_immutableG_class_templateDW_TAG_class_temTAG_pointer_typeDW_TAG_pointer_tTAG_compile_unitDW_TAG_compile_uTAG_common_blockDW_TAG_common_blTAG_variant_partDW_TAG_variant_pTAG_partial_unitDW_TAG_partial_uTAG_coarray_typeDW_TAG_coarray_tTAG_dynamic_typeDW_TAG_dynamic_tTAG_format_labelDW_TAG_format_lalock
DW_TAG_lexical_btype
DW_TAG_subrange_item
DW_TAG_namelist_DW_TAG_volatile_DW_TAG_restrict_unit
rted_declarationenumeration_typeDW_TAG_enumeratiformal_parameterDW_TAG_formal_pacommon_inclusionDW_TAG_common_inunspecified_typegeneric_subrangeDW_TAG_generic_sDW_TAG_entry_point
DW_TAG_string_type
DW_TAG_inheritance
DW_TAG_catch_block
DW_TAG_packed_tyDW_TAG_thrown_tyDW_TAG_shared_tyDW_TAG_array_typDW_TAG_class_typDW_TAG_union_typDW_TAG_const_typDW_TAG_enumeratoDW_TAG_subprogratemplate
DW_TAG_function_DW_TAG_skeleton_l_site_parameterDW_TAG_call_siteDW_TAG_MIPS_loopDW_TAG_atomic_tyD_Delphi_variantDW_TAG_BORLAND_DRLAND_Delphi_setND_Delphi_stringBORLAND_propertyDW_TAG_BORLAND_pG_APPLE_propertyDW_TAG_APPLE_proDW_TAG_GNU_call_site
l_parameter_packDW_TAG_GNU_forma_GNU_const_indexDW_OP_GNU_const_OP_LLVM_fragmentDW_OP_LLVM_fragmpush_tls_addressDW_OP_GNU_push_t_cfa
DW_OP_call_framealue
DW_OP_implicit_vndex
DW_OP_GNU_addr_iform_tls_addressDW_OP_form_tls_aimplicit_pointerDW_OP_implicit_ph_object_addressDW_OP_push_objecDW_OP_deref_sizeDW_OP_const_typeDW_OP_deref_typeDW_OP_plus_uconsDW_OP_xderef_sizDW_OP_stack_valuDW_OP_entry_valuDW_OP_regval_typDW_OP_xderef_typDW_OP_reinterpreATE_signed_fixedDW_ATE_signed_fiE_packed_decimalDW_ATE_packed_deE_numeric_stringDW_ATE_numeric_sE_unsigned_fixedDW_ATE_unsigned__imaginary_floatDW_ATE_imaginaryDW_ATE_signed_char
loat
DW_ATE_complex_fchar
DW_ATE_decimal_fITY_pure_virtualDW_VIRTUALITY_puRTUALITY_virtualDW_VIRTUALITY_viDW_VIRTUALITY_none
GLE_RenderScriptDW_LANG_GOOGLE_Rript
DW_LANG_RenderScG_ObjC_plus_plusDW_LANG_ObjC_pluG_C_plus_plus_03DW_LANG_C_plus_pG_C_plus_plus_11G_C_plus_plus_14G_Mips_AssemblerDW_LANG_Mips_AssG_BORLAND_DelphiDW_LANG_BORLAND_DW_LANG_Pascal83DW_LANG_Fortran77
DW_LANG_Fortran90
DW_LANG_Fortran0LANG_C_plus_plusDW_CC_LLVM_Win64DW_CC_LLVM_AAPCSDW_CC_LLVM_Swiftfastcall
DW_CC_BORLAND_ms_BORLAND_stdcallDW_CC_BORLAND_st_LLVM_vectorcallDW_CC_LLVM_vecto_LLVM_X86_64SysVDW_CC_LLVM_X86_6_LLVM_X86RegCallDW_CC_LLVM_X86ReBORLAND_safecallDW_CC_BORLAND_saBORLAND_msreturnBORLAND_thiscallDW_CC_BORLAND_thBORLAND_fastcallDW_CC_BORLAND_faLLVM_PreserveAllDW_CC_LLVM_Presend_fastcall_i386DW_CC_GNU_borlans_sh
DW_CC_GNU_renesascal
DW_CC_BORLAND_pa_VFP
enCL
DW_CC_GDB_IBM_OpCC_pass_by_valueDW_CC_pass_by_vaass_by_referenceDW_CC_pass_by_reLVM_IntelOclBiccDW_CC_LLVM_IntelLVM_SpirFunctionDW_CC_LLVM_SpirFLVM_OpenCLKernelDW_CC_LLVM_OpenCLVM_PreserveMostMACINFO_end_fileDW_MACINFO_end_fCINFO_start_fileDW_MACINFO_startCINFO_vendor_extDW_MACINFO_vendoDW_MACINFO_undefDW_MACINFO_defin
N3iga10FatalErrorE
St13runtime_error
N3iga11SyntaxErrorE
!"#$
)*+,
__Buffer_Typed_DIM_Resource
__1D_DIM_Resource
__1D_ARRAY_DIM_Resource
__2D_DIM_Resource
__2D_ARRAY_DIM_Resource
__3D_DIM_Resource
__Cube_DIM_Resource
__Cube_ARRAY_DIM_Resource
Warning: File name not specified with the -dump-opt-llvm option.
metadata !"image_access_qualifier"
Old LLVM IR (possibly from legacy binary) :  not supported!
<origin>
Parsing llvm module failed!
-cmc
-instcombine-code-sinking=0
gpu_64-applecl-macosx
runtime.cligc64.bc
Error loading the Generic builtin resource
Error lazily loading bitcode for generic builtins,is bitcode the right version and correctly formed?
Error loading the Generic builtin module from buffer
ci-15.36-xxxxx
vector
-cl-replace-global-offsets-by-zero
-cl-kernel-debug-enable
-cl-include-sip-csr
-cl-include-sip-kernel-debug
-cl-include-sip-kernel-local-debug
-cl-intel-use-32bit-ptr-arith
-cl-intel-greater-than-4GB-buffer-required
-cl-intel-has-buffer-offset-arg
-cl-intel-gtpin-rera
-cl-intel-no-prera-scheduling
-cl-intel-use-bindless-buffers
-cl-intel-use-bindless-images
-cl-fp32-correctly-rounded-divide-sqrt
-cl-no-subgroup-ifp
-cl-uniform-work-group-size
compilation error
 -filetype=spv
-dumpvisa
 -dumpvisa
basic_string
SmallVector capacity overflow during allocation
Allocation failed
Total
Invalid Pass 
error: 
error: backend compiler failed build.
simd
FastStage1
BestStage1
RestStage2
SinglePatch
DualPatch
EightPatch
entry
UserFunction
type
localSize
CorrectlyRoundedDivSqrt
SubgroupIndependentForwardProgressRequired
offset
size
ConstantPointerProgramBinaryInfos
IGCMetadata
vector
air64-apple-macosx
metadata
moduleHash
air.vertex
visaStackCall
 undefined reference to `jmp()' 
Invalid user defined function being processed: 
Add implicit args to all functions in the module and adjusts call to these functions
igc-add-implicit-args
coarse_phase
pixel_phase
sample_phase
legacy
vector
igc.functions
Analyzes CallGraphSCC
igc-callgraphscc-analysis
AddImplictArgs
BuiltinCallGraphAnalysis
globalSize
enqueuedLocalSize
deviceEnqueueDefaultDeviceQueue
deviceEnqueueMaxWorkgroupSize
deviceEnqueueParentEvent
deviceEnqueuePreferedWorkgroupMultiple
deviceEnqueueGetObjectId
deviceEnqueueGetBlockSimdSize
localMemStatelessWindowStartAddr
localMemStatelessWindowSize
PrivateMemStatelessSize
map::at:  key not found
Set Functions' linkage and attributes
igc-process-func-attributes
ProcessFuncAttributes
__FastRelaxedMath
referenced-indirectly
KMPLOCK
less-precise-fpmad
true
unsafe-fp-math
no-infs-fp-math
no-nans-fp-math
__builtin_IB_AllocLocalMemPool
IndirectlyCalled
Set builtin MetaData
igc-process-builtin-metaData
ProcessBuiltinMetaData
Types Legalization pass
types-legalization-pass
Types Legalization Pass
Legalize calls to functions/subroutines and their signatures
igc-legalize-function-signatures
LegalizeFunctionSignatures
llvm.
_igc_bif_%s_%s
_igc_bif_%s_%s_size
/System/Library/Frameworks/OpenCL.framework/Resources/
vector
reqd_work_group_size
vec_type_hint
work_group_size_hint
GTPIN_IGC_OCL Error: Fail to find a free BTI for GT-Pin surface %d
GTPIN_IGC_OCL Error: Failed to call GTPIN_IGC_OCL_UpdateKernelInfo
Malformed block
Invalid record
Invalid bitcode signature
Invalid bitcode wrapper header
Unexpected end of file
Invalid value
Incompatible epoch: Bitcode '
' vs current: '
Could not find function in stream
Trying to materialize functions before seeing function blocks
Expect SubBlock
Expect function block
 (Producer: '
' Reader: 'LLVM 
7.0.0')
Insufficient function protos
Invalid function metadata: incoming forward references
Invalid ID
Invalid cast
Explicit gep type does not match pointee type of pointer operand
EXTRACTVAL: Invalid instruction with 0 indices
EXTRACTVAL: Invalid type
EXTRACTVAL: Invalid struct index
EXTRACTVAL: Invalid array index
INSERTVAL: Invalid instruction with 0 indices
INSERTVAL: Invalid type
INSERTVAL: Invalid struct index
INSERTVAL: Invalid array index
Inserted value type doesn't match aggregate type
Invalid type for value
Explicit invoke type is not a function type
Callee is not a pointer
Callee is not of pointer to function type
Explicit invoke type does not match pointee type of callee operand
Insufficient operands to call
Personality function mismatch
Old-style alloca with a non-pointer type
Fast math flags indicator set for call with no FMF
Explicit call type is not a function type
Callee is not a pointer type
Explicit call type does not match pointee type of callee operand
Fast-math-flags specified for call without floating-point scalar or vector return type
Invalid instruction with no BB
Operand bundles found with no consumer
Never resolved value found in function
Invalid function metadata: outgoing forward refs
Invalid constant reference
Invalid constant type
Explicit gep operator type does not match pointee type of pointer operand
Invalid gep with no operands
Invalid value name
Invalid alignment value
Load/Store operand is not a pointer type
Explicit load/store type does not match pointee type of pointer operand
Cannot load/store from pointer
Never resolved function from blockaddress
Malformed global initializer set
Invalid multiple blocks
Unknown attribute kind (
Bitwidth for integer type out of range
Invalid type
Invalid function argument type
Invalid TYPE table
Invalid vector length
Invalid TYPE table: Only named structs can be forward referenced
Expected a constant
Alias and aliasee types don't match
Invalid multiple synchronization scope names blocks
Invalid empty synchronization scope names block
Invalid global variable comdat ID
Invalid calling convention ID
Invalid function comdat ID
llvm.linker.options
Expected a single module
opencl.kernels
llvm.global.annotations
Unify
e-p:32:32:32
e-p:64:64:64
-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v24:32:32-v32:32:32-v48:64:64-v64:64:64-v96:128:128-v128:128:128-v192:256:256-v256:256:256-v512:512:512-v1024:1024:1024-n8:16:32
opencl.compiler.options
opencl.compiler.ext.options
opencl.enable.FP_CONTRACT
opencl.used.optional.core.features
opencl.used.extensions
opencl.spir.version
opencl.ocl.version
libigcmc.so
cmc_load_and_compile
cmc_free_compile_info
cannot load symbol cmc_load_and_compile
cannot load symbol cmc_free_compile_info
ICLLP
Move static allocas to entry basic block of the function
igc-move-static-allocas
MoveStaticAllocasPass
vararg
tracepoint
llvm.dbg.cu
air.fragment
air.kernel
resID
resTy
needBufferOffset
align
texture_buffer
bindless_image1d_buffer_t
texture1d_array
bindless_image1d_array_t
texture1d
bindless_image1d_t
texture2d_array
bindless_image2d_array_t
texture2d_ms
bindless_image2d_msaa_t
texture2d_ms_array
bindless_image2d_array_msaa_t
texture2d
bindless_image2d_t
texture3d
bindless_image3d_t
texturecube_array
bindless_image_cube_array_t
texturecube
bindless_image_cube_t
depth2d_array
depth2d_ms_array
bindless_image2d_array_msaa_depth_t
depth2d_ms
bindless_image2d_msaa_depth_t
depth2d
bindless_image2d_depth_t
depthcube_array
bindless_image_cube_depth_t
depthcube
bindless_image_cube_array_depth_t
sampler
bindless_sampler_t
air.
air.atomic_store_explicit_texture
air.atomic_fetch_add_explicit_texture
air.atomic_fetch_and_explicit_texture
air.atomic_fetch_min_explicit_texture
air.atomic_fetch_max_explicit_texture
air.atomic_fetch_or_explicit_texture
air.atomic_fetch_xor_explicit_texture
air.atomic_fetch_sub_explicit_texture
air.atomic_compare_exchange_weak_explicit_texture
air.atomic_exchange_explicit_texture
air.get_unique_identifier_command_buffer
air.get_unique_identifier_sampler
air.get_unique_identifier_visible_function_table
air.get_unique_identifier_texture
air.get_unique_identifier_render_pipeline_state
air.get_unique_identifier_compute_pipeline_state
product
air.get_function_pointer_visible_function_table
air.get_size_visible_function_table
air.get_null_visible_function_table
air.is_null_visible_function_table
air.get_global_buffer_visible_function_table
air.get_buffer_visible_function_table
air.set_buffer_visible_function_table
base_vertex
base_instance
base_patch
tess_factor_scale
tess_instance_stride
patch_index_buffer_offset
msaa_sample_pattern_offset
virtual_binding_table_vs
virtual_binding_table_ps
virtual_binding_table_hs
virtual_binding_table_ds
work_dim
local_size_x
local_size_y
local_size_z
global_size_x
global_size_y
global_size_z
global_offset_x
global_offset_y
global_offset_z
num_work_groups_x
num_work_groups_y
num_work_groups_z
enqueued_local_size_x
enqueued_local_size_y
enqueued_local_size_z
stage_in_grid_origin_x
stage_in_grid_origin_y
stage_in_grid_origin_z
stage_in_grid_size_x
stage_in_grid_size_y
stage_in_grid_size_z
virtual_binding_table_cs
__builtin_IB_get_local_size
__builtin_IB_get_global_size
__builtin_IB_get_enqueued_local_size
__builtin_IB_get_num_groups
__builtin_IB_get_stage_in_grid_origin
__builtin_IB_get_stage_in_grid_size
__builtin_IB_get_simd_id
__builtin_IB_get_local_id_x
__builtin_IB_get_local_id_y
__builtin_IB_get_local_id_z
__builtin_IB_get_group_id
Legalize Global Value Usages
igc-legalize-global-value-usages
UserSubroutine
AirArgumentPropagation
_tmp
UserDefined
air.hull
This is a generic pass for builtins custom-lowering.
air-builtin-handler
AirMsaaSamplePattern
AirInlineBuiltins
air.visible
air.emulation
mainFunc
air.read
ConstSampler
TessInputControlPointCount
MaxNumOfOutputSignatureEntries
MaxNumOfInputSignatureEntries
MaxNumOfPatchConstantSignatureEntries
__TessNumControlPoints
max-work-group-size
AIR conversion to IGC
igc-air-conversion
isGlobalSizeGT0
threads_per_grid_end
globalSizeUnavaliable
thread_index_in_threadgroup_end
cond_dim3_true
cond_dim2_true
air.read_write
air.write
igc.read_only_array
AIR Conversion
air.struct_type_info
.emulation.
wrapper
air.indirect_buffer
air.buffer
air.emulation_argument
Emulate Argument Buffers
igc-emulate-argument-buffers
air.intersection
air.vertex_id
air.instance_id
air.base_vertex
air.base_instance
air.thread_position_in_grid
air.threads_per_grid
air.thread_position_in_threadgroup
air.thread_index_in_threadgroup
air.threads_per_threadgroup
air.threadgroups_per_grid
air.threadgroup_position_in_grid
air.thread_execution_width
air.patch_id
air.position_in_patch
air.stage_in_grid_origin
air.stage_in_grid_size
air.thread_index_in_quadgroup
air.thread_index_in_simdgroup
air.threads_per_quadgroup
air.threads_per_simdgroup
air.amplification_id
air.amplification_count
air.primitive_acceleration_structure
air.instance_acceleration_structure
air.location_index
air.arg_type_name
air.arg_name
air.sample
air.arg_type_size
air.arg_type_align_size
air.alias_implicit_imageblock_render_target
air.raster_order_group
const
global
local
constant
__global
__constant
float
float2
float3
float4
packed_float
packed_float2
packed_float3
packed_float4
half
half2
half3
half4
packed_half
packed_half2
packed_half3
packed_half4
int2
int3
int4
packed_int
packed_int2
packed_int3
packed_int4
uint
uint2
uint3
uint4
packed_uint
packed_uint2
packed_uint3
packed_uint4
short
short2
short3
short4
packed_short
packed_short2
packed_short3
packed_short4
ushort
ushort2
ushort3
ushort4
packed_ushort
packed_ushort2
packed_ushort3
packed_ushort4
char
char2
char3
char4
packed_char
packed_char2
packed_char3
packed_char4
uchar
uchar2
uchar3
uchar4
packed_uchar
packed_uchar2
packed_uchar3
packed_uchar4
long
long2
long3
long4
packed_long
packed_long2
packed_long3
packed_long4
ulong
ulong2
ulong3
ulong4
packed_ulong
packed_ulong2
packed_ulong3
packed_ulong4
double
double2
double3
double4
packed_double
packed_double2
packed_double3
packed_double4
bool
bool2
bool3
bool4
packed_bool
packed_bool2
packed_bool3
packed_bool4
float2x2
float2x3
float2x4
float3x2
float3x3
float3x4
float4x2
float4x3
float4x4
half2x2
half2x3
half2x4
half3x2
half3x3
half3x4
half4x2
half4x3
half4x4
void
indirect_command_buffer
visible_function_table
intersection_function_table
primitive_acceleration_structure
instance_acceleration_structure
r8unorm
r8snorm
r16unorm
r16snorm
rg8unorm
rg8snorm
rg16unorm
rg16snorm
rgba8unorm
srgba8unorm
rgba8snorm
rgba16unorm
rgba16snorm
rgb10a2
rg11b10f
rgb9e5
AirEmulateArgumentBuffers
__flag_begin_marker
__flag_end_marker
Insert markers around builtin calls marked with fast flag
air-fast-flag-propagation-mark-pass
Resolve fast flag markers to operand attributes
air-fast-flag-propagation-resolve-pass
AirFastFlagPropagationMark
AirFastFlagPropagationResolve
igc.internal_symbol
air.set_kernel_buffer_compute_command.p1i8
air.set_kernel_buffer_compute_command.p2i8
air.set_pipeline_state_compute_command
air.set_threadgroup_memory_length_compute_command
air.clear_barrier_compute_command
air.concurrent_dispatch_threadgroups_compute_command
air.concurrent_dispatch_threads_compute_command
AIR Function Attribute Update
igc-air-function-attribute-update
Air Function Attribute Update
unordered_map::at: key not found
__air_sampler_state_static
air.sampler_states
air.sampler_state
cubeMapCoordArray
struct._sampler_t
CmpXchgFail
rg11b10
rsqrt_chan
__builtin_IB_get_snap_wa_reqd
__builtin_IB_is_normalized_coords
air.get_dispatch_threads_per_threadgroup
air.get_dispatch_simdgroups_per_threadgroup
air.get_dispatch_quadgroups_per_threadgroup
air.get_simdgroups_per_threadgroup
air.get_quadgroups_per_threadgroup
air.get_simdgroup_index_in_threadgroup
air.get_quadgroup_index_in_threadgroup
air.get_thread_index_in_simdgroup
air.get_thread_index_in_quadgroup
__builtin_IB_get_group_id
__builtin_IB_get_local_id_x
__builtin_IB_get_local_id_y
__builtin_IB_get_local_id_z
Pass legalizes texture and sampler addrspaces from GLOBAL/CONSTANT to indirect
igc-air-function-builder
denorm_or_zero
sat_exp
denorm_exp
denorm_exp_loop
denorm_exp_loop_end
denorm_or_zero_end
AirFunctionBuilder
AirPropagateAssumptions
air-propagate-assumptions
for arguments marked with raster_order_group, emit sendc
air-raster-order-groups
AirRasterOrderGroups
AirResolveInlineSamplerWA
Colects read-write textures indexes and removes texture fences
air-rw-texture-analysis
AirRWModification
Pass walks through sampler uses and detects sampler to texture mappings, and converts Sample to SampleL instructions.
igc-air-samplers
AIR Samplers
Pass walks through kernel and checks if there remains any unresolved air builtin function, in which case it is flagged as an error.
igc-check-unresolved-builtin-functions
Check unresolved builtin functions
Workaround for FP16div optimization causing a overflow
igc-workaround-FP16Div
FP16DivWorkaround
Trivial greedy live range reduction to reduce register pressure for special cases.
greedy-live-range-reduction
HSOutputControlPointCount
TessInputControlPointCount
MaxNumOfInputSignatureEntries
MaxNumOfOutputSignatureEntries
MaxNumOfPatchConstantSignatureEntries
HSEntry
HullShaderForcedDispatchMask
HullShaderDispatchMode
TessellationShaderDomain
igc-air-legalize-resource-addrspace
LegalizeResourcePointer
LegalizeStructLoadStores
Loop Exit Canonicalization Pass
loop-exit-canonicalization
air.global_bindings
air.external_initializations
voidProgram
output
input
air.fragment
air.vertex
air.kernel
air.hull
air.location
air.render_target
air.simdgroup_index_in_threadgroup
air.dispatch_simdgroups_per_threadgroup
air.dispatch_threads_per_threadgroup
air.quadgroup_index_in_threadgroup
air.dispatch_quadgroups_per_threadgroup
air.arg_unused
air.perspective
air.flat
air.no_perspective
air.center
air.centroid
air.interpolation_function
AIR to IGC metadata parser
igc-air-metadata-parse
AIR Metadata Parse
Air Metadata Schema Wrapper
igc-metadata-schema-wrapper
unknown
air.compile.native_double_disable
air.compile.framebuffer_fetch_enable
air.compile.framebuffer_fetch_disable
PreprocessMetadata
air.visible_function_references
ResolveExternalVisibleFunctionName
Translate AI
igc-translate-air
Translate AIR
Translate AIR Builtins
igc-translate-air-builtins
ThreadGroupSize_X
ThreadGroupSize_Y
ThreadGroupSize_Z
error: 
error: backend compiler failed build.
IGC::PositionOnlyVertexShader
CodeGenContext Wrapper
igc-code-gen-context-wrapper
CodeGen Context Wrapper
reducedIndex
Custom Pass Optimization
igc-custom-safe-opt
TrivialLocalMemoryOpsElimination
LastPatternMatch Pass
igc-gen-specific-pattern
Custom Const-prop Pass
igc-const-prop
Indirect ICB Propagaion
IGCIndirectICBPropagaion
NAN handling
NanHandling
Gen strength reduction
GenStrengthReduction
Flatten Small Switch
FCmpPaternMatch
flattenSmallSwitch
logicalAndToBranch
LogicalAndToBranch
if.then
if.else
if.end
GenSpecificPattern
const-prop with shader-const replacement
Unsafe Optimizations Pass
igc-custom-unsafe-opt-pass
Hoist FMul in Loop Pass
igc-hoist-fmul-in-loop-pass
Custom Unsafe Optimization Pass
EarlyOutPatterns
HoistFMulInLoopPass
.seg1
.seg2
.seg3
IGC Custom Loop Opt
igc-custom-loop-opt
IGC Loop canonicalization
igc-loop-canonicalization
.backedge
llvm.loop
Custom Loop Versioning
IGC loop canonicalization
BlendToDiscard
Pass promotes indirect addrspace resource access to direct addrspace
igc-promote-resources-to-direct-addrspace
PromoteResourceToDirectAS
Pass promotes stateless accesses to bindless accesses
igc-promote-stateless-to-bindless
PromoteStatelessToBindless
copysign
copysignf
copysignl
fabs
fabsf
fabsl
fmin
fminf
fminl
fmax
fmaxf
fmaxl
sinf
sinl
cosf
cosl
sqrt
sqrtf
sqrtl
powf
powl
exp2
exp2l
exp2f
floor
floorf
ceil
round
ffsl
labs
llabs
Dummy Pass for GenTTIImpl
gen-tti-dummy-pass
target-cpu
target-features
Fix the usage of GetBufferPtr, no combination of GetBufferPtr and GetResourcePtr
igc-fix-resource-ptr
FixResourcePtrPass
splitDouble
Convert load/store on doubles into store/loads on i32 or float types
igc-dp-to-fp-load-store
HandleLoadStoreInstructionsPass
preserve-nan
Preserve NAN (default false)
UnifiedReturnBlock
UnifiedRetVal
VISA Legalizer
igc-legalization
GenOptLegalizer
Legalization Pass
Low Precision Opt
igc-low-precision-opt
LowPrecisionOpt Pass
Metadata Utils Wrapper
igc-metadata-utils-wrapper
MetaData Utils Wrapper
SampleCmpToDiscard
Unsupported required sub group size
-fp32-correctly-rounded-divide-sqrt
SPIR to IGC metadata translator
igc-spir-metadata-translation
printf
Translate ACL printf
igc-translate-acl-printf
Translate ACL Printf
enable-fmax-fmin-plus-zero
Enable fmax/fmin + 0.0f flag
Workaround pass used to fix functionality of special cases
igc-workaround
Workaround fmax/fmin
igc-wa-fminmax
WorkaroundAnalysis Pass
WAFMinFMax
ThreadGroupSize_X
ThreadGroupSize_Y
ThreadGroupSize_Z
iterBarriers
iterX
iterY
new_entry
newKernel
Perform analysis and apply optimization to combine number of software threads
igc-threadcombining
ThreadCombining
GenUpdateCB
Find interesting constants
igc-find-interesting-constants
Find Interesting Constants
dynamic texture folding
igc-dynamic-texture-folding
Dynamic Texture Folding
sample multiversioning
igc-sample-multiversioning
Sample Multiversioning
handling and lowering for data available across functions and dylibs
global-data-resolution-pass
GlobalDataResolutionPass
Cleans up symbols and relocation that are not longer needed due to various optimizations
symbol-relocation-cleanup
SymbolRelocationCleanup
Symbol Relocation Analysis provides info needed to generate symbol and relocation entries
igc-symbols-relocation-analysis
SymbolRelocation Analysis
kernel_arg_addr_space
apple.cl.arg_metadata
sampler_t
image
image1d_t
image2d_t
image3d_t
image1d_array_t
image2d_array_t
image1d_buffer_t
image2d_buffer_t
image2d_msaa_t
image2d_array_msaa_t
image2d_array_msaa_depth_t
image2d_msaa_depth_t
image2d_depth_t
image2d_array_depth_t
kernel_arg_access_qual
read
read_only
write
write_only
none
kernel_arg_type
kernel_arg_type_qual
kernel_arg_base_type
kernel_arg_name
-cl-std=CL1.2
-cl-kernel-arg-info
Resource indirection pass
igc-resource-indirection-pass
Resource Indirection Pass
Advanced Code Motion
Advanced MemOpt
Advanced Memory Optimization
igc-advmemopt
Mark empty blocks after deSSA
BlockCoalescing
Check individual type of instructions
CheckInstrTypes
InstrStatitic
KMPLOCK
label%d
-debug
-fasterRA
-noLocalSplit
igc.device.enqueue
kernel
kernel.asm
OutputAsmPath
main
ArgSize
RetValSize
Extern
Output
vector
CC Tuple
CC Tuple list: 
CC Tuple list end. 
coalesce moves coming payloads, insert and extract element
CoalescingEngine
.hoist
code sinking
CodeHoisting
Code Hoisting
GsMaxOutputVertices
GsOutputPrimitiveTopology
GsInputPrimitiveType
GsMaxInputAttributeCount
GsOutputClipDistanceMask
GsOutputCullDistanceMask
ShaderHasClipCullInput
Collect GS Properties
collectgeometryshaderproperties
CollectGeometryShaderProperties
twoScalar
chunkPtr
Constant Coalescing
igc-constant-coalescing
CE: 
Output
DebugInfoPass
---- AliasMap ----
  Aliasee: 
     
---- InsEltMap ----
  Root Value : 
       
---- Multi-value Alias (value in both AliasMap & InsEltMap) ----
  Root Value: 
 [aliasee]
       
 [aliasee]  
---- Phi-Var Isolations ----
Var isolated : 
Leader : 
    
coalesce moves coming from phi nodes
DeSSA
Collect information related to domain shader
igc-collect-domain-shader-properties
Lower inputs outputs for domain shader
igc-domain-shader-lowering
/// Inlined ASM
/// End Inlined ASM
INTEL_PATCH_PRIVATE_MEMORY_SIZE
EmitPass
V = 
I = 
.shl.outer.merge.lo
.shl.outer.merge.hi
.shl.outer.true.branch
.shl.merge.inner.lo
.shl.merge.inner.hi
.shl.inner.true.branch
.shl.inner.false.branch
.lshr.outer.merge.lo
.lshr.outer.merge.hi
.lshr.outer.true.branch
.lshr.merge.inner.lo
.lshr.merge.inner.hi
.lshr.inner.true.branch
.lshr.inner.false.branch
.ashr.outer.merge.lo
.ashr.outer.merge.hi
.ashr.outer.true.branch
.ashr.merge.inner.lo
.ashr.merge.inner.hi
.ashr.inner.true.branch
.ashr.inner.false.branch
.u2f.outer.merge
.u2f.outer.true.branch
.u2f.inner.merge.hi
.u2f.inner.merge.lo
.u2f.inner.true.branch
.u2f.rounding.merge.hi
.u2f.roudning.branch
IGC 64-bit ops emulation
igc-emu64ops
EstimateFunctionSize
Estimate Function Sizes
.fix1.addrspacecast
.fix1.bitcast
.fix2.addrspacecast
Fix invalid addrspacecast-relevant patterns
igc-addrspacecast-fix
Fixup extractvalue pairs
igc-extractvalue-pair-fixup
visaStackCall
GenXCodeGenModule
GenXFunctionGroupAnalysis
SubroutineInliner
FunctionGroup analysis
GenX CodeGen module
GenIR Lowering
Lowers GEP into primitive ones
igc-gen-ir-lowering
Gen Simplification
igc-shuffle-simplification
GeometryShaderLowering
accessTy
llvm.used
llvm.metadata
llvm.genx.
HSOutputControlPointCount
Collect information related to hull shader
igc-collect-hull-shader-properties
Lower inputs outputs for hull shader
igc-hull-shader-lowering
Clear tessellation factors
igc-cleartessfactors
ClearTessFactors
Layout blocks
igc-layout
Layout
IGC Load Shrink
igc-ldshrink
LiveVarsAnalysis
Calculate liveness based on LiveVars
igc-livenessanalysis
LivenessAnalysis
Advanced DCE on loop
igc-loop-dce
Remove dead recurisive PHINode
igc-phielimination
uniform
Lower GEP of Private Memory to Register Pass
igc-priv-mem-to-reg
LowerGEPForPrivMem
memopt-merge-load
Controls count of merged loads
memopt-merge-store
Controls count of merged stores
IGC Memory Optimization
igc-memopt
IGC Memory Optimization, the 2nd
igc-memopt2
MergeURBWrites
NONE
__local
__private
nounwind
work_group_size_hint(
reqd_work_group_size(
intel_reqd_sub_group_size(
intel_reqd_workgroup_walk_order(
Does pattern matching
CodeGenPatternMatch
CodeGenPatternMatchPass
PrimIdLocation
KillPixel
DiscardRet
postDiscard
Pixel shader lowering pass
igc-pixel-shader-addmask
This is the pixel shader lowering pass 
igc-pixel-shader-lowering
Lower discard intrinsics
igc-lower-discard
PixelShaderLowering
Lower Discard
bitset set argument out of range
PositionDepAnalysis
SetMathPrecisionForPositionOutput
PreRA rematerialize flag
igc-pre-ra-remat-flag
Use LivenessAnalysis to calculate register pressure
igc-registerestimator
RegisterEstimator
SimplifyConstant
PromoteConstant
PruneUnusedArguments
This is an analysis pass for pulling constants for short shaders 
Analyse shader to determine push const threshold
dynamicBufferOffset.bufferId
ConstantBufferIndexedWithInstanceId
promotes the values to be arguments
igc-push-analysis
PushAnalysis
Scalarizer in codegen
igc-scalarizer-in-codegen
Scalarizer in Codegen
GenX Register Pressure Analysis
igc-RegisterPressureEstimate
RegisterPressureEstimate
IGC PreRA Scheduler
igc-PreRAScheduler
__builtin_IB_memcpy_generic_to_private
__builtin_IB_memcpy_private_to_generic
__builtin_IB_memcpy_private_to_private
__builtin_IB_memcpy_global_to_private
__builtin_IB_memcpy_private_to_global
__builtin_IB_memcpy_constant_to_private
__builtin_IB_memcpy_private_to_constant
__builtin_IB_memcpy_local_to_private
__builtin_IB_memcpy_private_to_local
__builtin_IB_to_local
__builtin_IB_to_private
Resolve generic address space
igc-gas-resolve
Resolve compiler predefeind constants
igc-predefined-constant-resolve
OPTPre
UpdateOptPre
OPTPost
Check SIMD32 Profitability for OpenCL
simd32-profit
Simd32Profitability
TimeStatsCounter Start/Stop
time-stats-counter
.demoted.zext
Demote type safely
igc-type-demote
Detect non-uniform usage of textures and samplers and check if they may be assumed uniform.
UniformAssumptions
VariableReuseAnalysis
Compute-once pass that provides a translation table for mapping attributes for LLVM values
TranslationTable
Split loads/stores of big (or 3-element) vectors into smaller ones.
igc-vectorpreprocess
VectorPreProcess
split
scalarize
elt0
elt1
elt2
Elt0
Elt1
Elt2
Process vector loads/stores for explicit vISA variable layout
igc-vectorprocess
VectorProcess
IntToPtr2
vptrcast
vCastload
Collect information related to vertex shader
igc-collect-vertex-shader-properties
Lower inputs outputs for vertex shader
igc-vertex-shader-lowering
array::at
ComputeShaderLowering
print-wia-check
Debug wia-check analysis
WIAnalysis: 
Args: 
  unknown 
       ; preds =
 BB:
WIAnalysis
WIAnalysis provides work item dependency info
igc-wi-analysis
consecu
p_conse
strided
random 
Special const prop for SLM
igc-slmconstprop
Custom Pass for Position-Only Shader
igc-remove-nonposition-output
remove non-position output in vertex shader
debug_loc
vectorized
simd8
simd16
.debug_abbrev_begin
vector
info_string
func_begin
func_end
<stdin>
module_begin
module_end
line_table_start
section_line
igc.input.ir
Intel OpenCL 
debug_end
section_info
section_abbrev
dwarf_frame
debug_range
section_debug_loc
text_begin
.debug_info_begin
.debug_info_end
.debug_abbrev_begin
.debug_abbrev_end
$dup
.ptrcast
.off
.zext
.concat
.trunc
.legal
.promote
.soften
.sclr
.elt
.lsext
.rsext
.shl
.lshr
IGC Type Legalizer
igc-type-legalizer
Binary Instruction seen with illegal int type. Legalization support missing. Inst opcode:%d
IGC Int Type Legalizer
igc-int-type-legalizer
explicit_arg_num
struct_arg_offset
img_access_float_coords
img_access_int_coords
function_type
arg_desc
implicit_arg_desc
thread_group_size
thread_group_size_hint
sub_group_size
opencl_vec_type_hint
intel_reqd_sub_group_size
intel_reqd_workgroup_walk_order
PurgeMetaDataUtilsImport
igc-purgeMetaDataUtils-import
PurgeMetaDataUtilsPass
11ocl_image1d
14ocl_image1d
16ocl_image1darray
20ocl_image1d_array
17ocl_image1dbuffer
21ocl_image1d_buffer
11ocl_image2d
14ocl_image2d
16ocl_image2darray
20ocl_image2d_array
11ocl_image3d
14ocl_image3d
15ocl_image2dmsaa
19ocl_image2d_msaa
20ocl_image2darraymsaa
25ocl_image2d_array_msaa
20ocl_image2dmsaadepth
25ocl_image2d_msaa_depth
25ocl_image2darraymsaadepth
31ocl_image2d_array_msaa_depth
16ocl_image2ddepth
20ocl_image2d_depth
21ocl_image2darraydepth
26ocl_image2d_array_depth
24IGIL_EnqueueKernelShared9ocl_queuejPvjS_S_jS_jiPi9ndrange_tii12ocl_clkevent
24IGIL_EnqueueKernelShared9ocl_queuejPvjS0_S0_jS0_jiPi9ndrange_tii12ocl_clkevent
18IGIL_EnqueueKernel9ocl_queuejPvjS_S_jS_j9ndrange_ti12ocl_clkevent
18IGIL_EnqueueKernel9ocl_queuejPvjS0_S0_jS0_j9ndrange_ti12ocl_clkevent
33IGIL_EnqueueKernelWithLocalParams9ocl_queueiPijPvjS0_S0_jS0_j9ndrange_ti12ocl_clkevent
33IGIL_EnqueueKernelWithLocalParams9ocl_queueiPijPvjS1_S1_jS1_j9ndrange_ti12ocl_clkevent
28IGIL_EnqueueKernelWithEvents9ocl_queuejPvjS_S_jS_jiPi9ndrange_tiiPKU3AS412ocl_clkeventPU3AS412ocl_clkevent12ocl_clkevent
28IGIL_EnqueueKernelWithEvents9ocl_queuejPvjS0_S0_jS0_jiPi9ndrange_tiiPU3AS4K12ocl_clkeventPU3AS4S3_S3_
14enqueue_marker9ocl_queuejPKU3AS412ocl_clkeventPU3AS412ocl_clkevent
14enqueue_marker9ocl_queuejPU3AS4K12ocl_clkeventPU3AS4S0_
11read_imagef14ocl_image2d_ro11ocl_samplerDv2_fS_S_
11read_imagef14ocl_image2d_ro11ocl_samplerDv2_fS1_S1
11read_imagei14ocl_image2d_ro11ocl_samplerDv2_fS_S_
11read_imagei14ocl_image2d_ro11ocl_samplerDv2_fS1_S1_
12read_imageui14ocl_image2d_ro11ocl_samplerDv2_fS_S_
12read_imageui14ocl_image2d_ro11ocl_samplerDv2_fS1_S1_
11read_imagef20ocl_image2d_depth_ro11ocl_samplerDv2_fS_S_
11read_imagef20ocl_image2d_depth_ro11ocl_samplerDv2_fS1_S1_
11read_imagef20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS0_
11read_imagef20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS2_
11read_imagei20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS0_
11read_imagei20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS2_
12read_imageui20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS0_
12read_imageui20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS2_
11read_imagef26ocl_image2d_array_depth_ro11ocl_samplerDv4_fDv2_fS0_
11read_imagef26ocl_image2d_array_depth_ro11ocl_samplerDv4_fDv2_fS2_
11read_imagef14ocl_image3d_ro11ocl_samplerDv4_fS_S_
11read_imagef14ocl_image3d_ro11ocl_samplerDv4_fS1_S1_
11read_imagei14ocl_image3d_ro11ocl_samplerDv4_fS_S_
11read_imagei14ocl_image3d_ro11ocl_samplerDv4_fS1_S1_
12read_imageui14ocl_image3d_ro11ocl_samplerDv4_fS_S_
12read_imageui14ocl_image3d_ro11ocl_samplerDv4_fS1_S1_
12write_imagei14ocl_image3d_woDv4_iS_
12write_imagei14ocl_image3d_woDv4_iS0_
12write_imagei14ocl_image3d_rwDv4_iS_
12write_imagei14ocl_image3d_rwDv4_iS0_
12write_imagei16ocl_image2darrayDv4_iS_
12write_imagei20ocl_image2d_array_woDv4_iS0_
12write_imagei16ocl_image2d_array_woDv4_iS_
12write_imagei16ocl_image2d_array_rwDv4_iS_
12write_imagei20ocl_image2d_array_rwDv4_iS0_
12write_imagei16ocl_image2d_array_woDv4_iiS_
12write_imagei20ocl_image2d_array_woDv4_iiS0_
12write_imagei14ocl_image3d_woDv4_iiS_
12write_imagei14ocl_image3d_woDv4_iiS0_
29intel_work_group_vme_mb_queryPU3AS3jDv2_iS1_14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
29intel_work_group_vme_mb_queryPU3AS3jDv2_iS1_14ocl_image2d_roS2_11ocl_sampler
12DoMultiQueryPU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_ro14ocl_image2d_ro11ocl_samplerj
12DoMultiQueryPU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_roS3_11ocl_samplerj
37intel_work_group_vme_mb_multi_query_8PU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
37intel_work_group_vme_mb_multi_query_8PU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_roS3_11ocl_sampler
37intel_work_group_vme_mb_multi_query_4PU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
37intel_work_group_vme_mb_multi_query_4PU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_roS3_11ocl_sampler
41intel_work_group_vme_mb_multi_check_16x16PU3AS3jjjjDv2_ii14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
41intel_work_group_vme_mb_multi_check_16x16PU3AS3jjjjDv2_ii14ocl_image2d_roS2_S2_11ocl_sampler
39intel_work_group_vme_mb_multi_check_8x8PU3AS3jjjjDv2_iDv4_i14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
39intel_work_group_vme_mb_multi_check_8x8PU3AS3jjjjDv2_iDv4_i14ocl_image2d_roS3_S3_11ocl_sampler
47intel_work_group_vme_mb_multi_bidir_check_16x16PU3AS3jjjjDv2_ihhi14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
47intel_work_group_vme_mb_multi_bidir_check_16x16PU3AS3jjjjDv2_ihhi14ocl_image2d_roS2_S2_S2_11ocl_sampler
45intel_work_group_vme_mb_multi_bidir_check_8x8PU3AS3jjjjDv2_ihhS1_14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
45intel_work_group_vme_mb_multi_bidir_check_8x8PU3AS3jjjjDv2_ihhS1_14ocl_image2d_roS2_S2_S2_11ocl_sampler
52intel_sub_group_avc_ime_evaluate_with_dual_reference14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t
52intel_sub_group_avc_ime_evaluate_with_dual_reference14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_ime_payload_t
54intel_sub_group_avc_ime_evaluate_with_single_reference14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t
54intel_sub_group_avc_ime_evaluate_with_single_reference14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_ime_payload_t
64intel_sub_group_avc_ime_evaluate_with_single_reference_streamout14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t
64intel_sub_group_avc_ime_evaluate_with_single_reference_streamout14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_ime_payload_t
62intel_sub_group_avc_ime_evaluate_with_dual_reference_streamout14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t
62intel_sub_group_avc_ime_evaluate_with_dual_reference_streamout14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_ime_payload_t
63intel_sub_group_avc_ime_evaluate_with_single_reference_streamin14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t51intel_sub_group_avc_ime_single_reference_streamin_t
63intel_sub_group_avc_ime_evaluate_with_single_reference_streamin14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_ime_payload_t51intel_sub_group_avc_ime_single_reference_streamin_t
61intel_sub_group_avc_ime_evaluate_with_dual_reference_streamin14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t49intel_sub_group_avc_ime_dual_reference_streamin_t
61intel_sub_group_avc_ime_evaluate_with_dual_reference_streamin14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_ime_payload_t49intel_sub_group_avc_ime_dual_reference_streamin_t
66intel_sub_group_avc_ime_evaluate_with_single_reference_streaminout14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t51intel_sub_group_avc_ime_single_reference_streamin_t
66intel_sub_group_avc_ime_evaluate_with_single_reference_streaminout14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_ime_payload_t51intel_sub_group_avc_ime_single_reference_streamin_t
64intel_sub_group_avc_ime_evaluate_with_dual_reference_streaminout14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t49intel_sub_group_avc_ime_dual_reference_streamin_t
64intel_sub_group_avc_ime_evaluate_with_dual_reference_streaminout14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_ime_payload_t49intel_sub_group_avc_ime_dual_reference_streamin_t
52intel_sub_group_avc_ref_evaluate_with_dual_reference14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ref_payload_t
52intel_sub_group_avc_ref_evaluate_with_dual_reference14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_ref_payload_t
54intel_sub_group_avc_ref_evaluate_with_single_reference14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ref_payload_t
54intel_sub_group_avc_ref_evaluate_with_single_reference14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_ref_payload_t
54intel_sub_group_avc_sic_evaluate_with_single_reference14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_sic_payload_t
54intel_sub_group_avc_sic_evaluate_with_single_reference14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_sic_payload_t
52intel_sub_group_avc_sic_evaluate_with_dual_reference14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_sic_payload_t
52intel_sub_group_avc_sic_evaluate_with_dual_reference14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_sic_payload_t
__builtin_IB_convert_sampler_to_int
__builtin_IB_convert_pipe_ro_to_intel_pipe
__builtin_IB_convert_pipe_wo_to_intel_pipe
__UseNative64BitSubgroupBuiltin
__EnableSWSrgbWrites
__ProfilingTimerResolution
_Z17get_global_offsetj
_Z12get_local_idj
_Z12get_group_idj
__builtin_spirv_BuiltInSubgroupId
get_sub_group_id
Built-in function pass
igc-builtin-import
PreBIImportAnalysis
BIImport
__enqueue_kernel_basic
__enqueue_kernel_vaargs
__enqueue_kernel_events_vaargs
_Z14enqueue_kernel
enqueue_IB_kernel
===> Materialize Failure: 
MCSOptimization
Loop Gating Optimization
loop-gating
GatingSimilarSamples
Convert builtin functions from OpenCL to common GenISA
igc-conv-ocl-to-common
BuiltinsConverterFunction
CoordZ
CoordX
CoordY
floatColor
ColorX
ColorY
ColorZ
ColorW
Inconsistent use of image!
__builtin_IB_OCL_1d_ldui
__builtin_IB_OCL_1darr_ldui
__builtin_IB_OCL_2d_ldui
__builtin_IB_OCL_2darr_ldui
__builtin_IB_OCL_3d_ldui
__builtin_IB_OCL_1d_ld
__builtin_IB_OCL_1darr_ld
__builtin_IB_OCL_2d_ld
__builtin_IB_OCL_2darr_ld
__builtin_IB_OCL_3d_ld
__builtin_IB_OCL_2d_ldmcs
__builtin_IB_OCL_2darr_ldmcs
__builtin_IB_OCL_2d_ld2dms
__builtin_IB_OCL_2darr_ld2dms
__builtin_IB_OCL_2d_ld2dmsui
__builtin_IB_OCL_2darr_ld2dmsui
__builtin_IB_OCL_1d_sample_l
__builtin_IB_OCL_1darr_sample_l
__builtin_IB_OCL_2d_sample_l
__builtin_IB_OCL_2darr_sample_l
__builtin_IB_OCL_3d_sample_l
__builtin_IB_OCL_1d_sample_d
__builtin_IB_OCL_1darr_sample_d
__builtin_IB_OCL_2d_sample_d
__builtin_IB_OCL_2darr_sample_d
__builtin_IB_OCL_3d_sample_d
__builtin_IB_OCL_1d_sample_lui
__builtin_IB_OCL_1darr_sample_lui
__builtin_IB_OCL_2d_sample_lui
__builtin_IB_OCL_2darr_sample_lui
__builtin_IB_OCL_3d_sample_lui
__builtin_IB_OCL_1d_sample_dui
__builtin_IB_OCL_1darr_sample_dui
__builtin_IB_OCL_2d_sample_dui
__builtin_IB_OCL_2darr_sample_dui
__builtin_IB_OCL_3d_sample_dui
__builtin_IB_write_1d_ui
__builtin_IB_write_1darr_ui
__builtin_IB_write_2d_ui
__builtin_IB_write_2darr_ui
__builtin_IB_write_3d_ui
__builtin_IB_write_2d_f
__builtin_IB_write_2darr_f
__builtin_IB_frnd_ne
__builtin_IB_ftoh_rtn
__builtin_IB_ftoh_rtp
__builtin_IB_ftoh_rtz
__builtin_IB_dtoh_rtn
__builtin_IB_dtoh_rtp
__builtin_IB_dtoh_rtz
__builtin_IB_dtof_rtn
__builtin_IB_dtof_rtp
__builtin_IB_dtof_rtz
__builtin_IB_dtoi8_rtn
__builtin_IB_dtoi8_rtp
__builtin_IB_dtoi8_rte
__builtin_IB_dtoi16_rtn
__builtin_IB_dtoi16_rtp
__builtin_IB_dtoi16_rte
__builtin_IB_dtoi32_rtn
__builtin_IB_dtoi32_rtp
__builtin_IB_dtoi32_rte
__builtin_IB_dtoi64_rtn
__builtin_IB_dtoi64_rtp
__builtin_IB_dtoi64_rte
__builtin_IB_dtoui8_rtn
__builtin_IB_dtoui8_rtp
__builtin_IB_dtoui8_rte
__builtin_IB_dtoui16_rtn
__builtin_IB_dtoui16_rtp
__builtin_IB_dtoui16_rte
__builtin_IB_dtoui32_rtn
__builtin_IB_dtoui32_rtp
__builtin_IB_dtoui32_rte
__builtin_IB_dtoui64_rtn
__builtin_IB_dtoui64_rtp
__builtin_IB_dtoui64_rte
__builtin_IB_itof_rtn
__builtin_IB_itof_rtp
__builtin_IB_itof_rtz
__builtin_IB_uitof_rtn
__builtin_IB_uitof_rtp
__builtin_IB_uitof_rtz
__builtin_IB_itofp64_rtn
__builtin_IB_itofp64_rtp
__builtin_IB_itofp64_rtz
__builtin_IB_uitofp64_rtn
__builtin_IB_uitofp64_rtp
__builtin_IB_uitofp64_rtz
__builtin_IB_frnd_pi
__builtin_IB_frnd_ni
__builtin_IB_frnd_zi
__builtin_IB_native_cosf
__builtin_IB_native_cosh
__builtin_IB_native_sinf
__builtin_IB_native_sinh
__builtin_IB_native_exp2f
__builtin_IB_native_exp2h
__builtin_IB_native_log2f
__builtin_IB_native_log2h
__builtin_IB_native_sqrtf
__builtin_IB_native_sqrth
__builtin_IB_native_sqrtd
__builtin_IB_popcount_1u32
__builtin_IB_popcount_1u16
__builtin_IB_popcount_1u8
__builtin_IB_native_powrf
__builtin_IB_fma
__builtin_IB_fmah
__builtin_IB_bfi
__builtin_IB_ibfe
__builtin_IB_ubfe
__builtin_IB_bfrev
__builtin_IB_fmax
__builtin_IB_fmin
__builtin_IB_HMAX
__builtin_IB_HMIN
__builtin_IB_dmin
__builtin_IB_dmax
__builtin_IB_mul_rtz_f64
__builtin_IB_mul_rtz_f32
__builtin_IB_fma_rtz_f64
__builtin_IB_fma_rtz_f32
__builtin_IB_add_rtz_f64
__builtin_IB_add_rtz_f32
__builtin_IB_thread_group_barrier
__builtin_IB_thread_group_barrier_signal
__builtin_IB_thread_group_barrier_wait
__builtin_IB_memfence
__builtin_IB_flush_sampler_cache
__builtin_IB_typedmemfence
__builtin_IB_simd_lane_id
__builtin_IB_vme_send_ime
__builtin_IB_vme_send_fbr
__builtin_IB_vme_send_sic
__builtin_IB_vme_send_fbr_new
__builtin_IB_vme_send_sic_new
__builtin_IB_vme_send_ime_new_uint4_uint8
__builtin_IB_vme_send_ime_new_uint8_uint8
__builtin_IB_vme_send_ime_new_uint4_uint4
__builtin_IB_vme_send_ime_new_uint8_uint4
__builtin_IB_set_message_phase_legacy_dw
__builtin_IB_set_message_phase_legacy_uw
__builtin_IB_set_message_phase_legacy_ub
__builtin_IB_set_message_phase_legacy
__builtin_IB_create_message_phases
__builtin_IB_create_message_phases_uint2
__builtin_IB_create_message_phases_uint4
__builtin_IB_create_message_phases_uint8
__builtin_IB_create_message_phases_no_init
__builtin_IB_create_message_phases_no_init_uint2
__builtin_IB_create_message_phases_no_init_uint4
__builtin_IB_create_message_phases_no_init_uint8
__builtin_IB_get_message_phase_dw
__builtin_IB_get_message_phase_dw_uint2
__builtin_IB_get_message_phase_dw_uint4
__builtin_IB_get_message_phase_dw_uint8
__builtin_IB_get_message_phase_uq
__builtin_IB_get_message_phase_uq_uint2
__builtin_IB_get_message_phase_uq_uint4
__builtin_IB_get_message_phase_uq_uint8
__builtin_IB_set_message_phase_dw
__builtin_IB_set_message_phase_dw_uint2
__builtin_IB_set_message_phase_dw_uint4
__builtin_IB_set_message_phase_dw_uint8
__builtin_IB_get_message_phase_uw
__builtin_IB_get_message_phase_uw_uint2
__builtin_IB_get_message_phase_uw_uint4
__builtin_IB_get_message_phase_uw_uint8
__builtin_IB_set_message_phase_uw
__builtin_IB_set_message_phase_uw_uint2
__builtin_IB_set_message_phase_uw_uint4
__builtin_IB_set_message_phase_uw_uint8
__builtin_IB_get_message_phase_ub
__builtin_IB_get_message_phase_ub_uint2
__builtin_IB_get_message_phase_ub_uint4
__builtin_IB_get_message_phase_ub_uint8
__builtin_IB_set_message_phase_ub
__builtin_IB_set_message_phase_ub_uint2
__builtin_IB_set_message_phase_ub_uint4
__builtin_IB_set_message_phase_ub_uint8
__builtin_IB_get_message_phase
__builtin_IB_get_message_phase_uint2
__builtin_IB_get_message_phase_uint4
__builtin_IB_get_message_phase_uint8
__builtin_IB_set_message_phase
__builtin_IB_set_message_phase_uint2
__builtin_IB_set_message_phase_uint4
__builtin_IB_set_message_phase_uint8
__builtin_IB_broadcast_message_phase_ub
__builtin_IB_broadcast_message_phase_ub_uint2
__builtin_IB_broadcast_message_phase_ub_uint4
__builtin_IB_broadcast_message_phase_ub_uint8
__builtin_IB_broadcast_message_phase_uw
__builtin_IB_broadcast_message_phase_uw_uint2
__builtin_IB_broadcast_message_phase_uw_uint4
__builtin_IB_broadcast_message_phase_uw_uint8
__builtin_IB_broadcast_message_phase_dw
__builtin_IB_broadcast_message_phase_dw_uint2
__builtin_IB_broadcast_message_phase_dw_uint4
__builtin_IB_broadcast_message_phase_dw_uint8
__builtin_IB_broadcast_message_phase_uq
__builtin_IB_broadcast_message_phase_uq_uint2
__builtin_IB_broadcast_message_phase_uq_uint4
__builtin_IB_broadcast_message_phase_uq_uint8
__builtin_IB_simd_set_message_phase_ub
__builtin_IB_simd_set_message_phase_ub_uint2
__builtin_IB_simd_set_message_phase_ub_uint4
__builtin_IB_simd_set_message_phase_ub_uint8
__builtin_IB_simd_set_message_phase_uw
__builtin_IB_simd_set_message_phase_uw_uint2
__builtin_IB_simd_set_message_phase_uw_uint4
__builtin_IB_simd_set_message_phase_uw_uint8
__builtin_IB_simd_set_message_phase_dw
__builtin_IB_simd_set_message_phase_dw_uint2
__builtin_IB_simd_set_message_phase_dw_uint4
__builtin_IB_simd_set_message_phase_dw_uint8
__builtin_IB_simd_set_message_phase_uq
__builtin_IB_simd_set_message_phase_uq_uint2
__builtin_IB_simd_set_message_phase_uq_uint4
__builtin_IB_simd_set_message_phase_uq_uint8
__builtin_IB_simd_get_message_phase_uw
__builtin_IB_simd_get_message_phase_uw_uint2
__builtin_IB_simd_get_message_phase_uw_uint4
__builtin_IB_simd_get_message_phase_uw_uint8
__builtin_IB_simd_get_message_phase_uq
__builtin_IB_simd_get_message_phase_uq_uint2
__builtin_IB_simd_get_message_phase_uq_uint4
__builtin_IB_simd_get_message_phase_uq_uint8
__builtin_IB_extract_mv_and_sad
__builtin_IB_cmp_sads
__builtin_IB_simdMediaRegionCopy
__builtin_IB_ieee_sqrt
__builtin_IB_ieee_divide
__builtin_IB_ieee_divide_f64
__builtin_IB_va_erode_64x4
__builtin_IB_va_dilate_64x4
__builtin_IB_va_minmaxfilter_16x4_SLM
__builtin_IB_va_convolve_16x4_SLM
__builtin_IB_va_convolve_16x1
__builtin_IB_va_convolve_16x4
__builtin_IB_va_minmax
__builtin_IB_va_centroid
__builtin_IB_va_boolcentroid
__builtin_IB_va_boolsum
__builtin_IB_WaveBallot
__builtin_IB_samplepos
__builtin_IB_dp4a_ss
__builtin_IB_dp4a_uu
__builtin_IB_dp4a_su
__builtin_IB_dp4a_us
mcsl
mcsh
imcsl
imcsh
gradXZ
gradYZ
gradXY
gradYY
gradXX
gradYX
__precompiled_udiv
__precompiled_udiv2
__precompiled_udiv3
__precompiled_udiv4
__precompiled_udiv8
__precompiled_udiv16
__precompiled_umod
__precompiled_umod2
__precompiled_umod3
__precompiled_umod4
__precompiled_umod8
__precompiled_umod16
__precompiled_sdiv
__precompiled_sdiv2
__precompiled_sdiv3
__precompiled_sdiv4
__precompiled_sdiv8
__precompiled_sdiv16
__precompiled_smod
__precompiled_smod2
__precompiled_smod3
__precompiled_smod4
__precompiled_smod8
__precompiled_smod16
precompiled_u32divrem
precompiled_s32divrem
precompiled_u32divrem_sp
precompiled_s32divrem_sp
__igcbuiltin_dp_add
__igcbuiltin_dp_sub
__igcbuiltin_dp_fma
__igcbuiltin_dp_mul
__igcbuiltin_dp_div
__igcbuiltin_dp_cmp
__igcbuiltin_dp_to_int32
__igcbuiltin_dp_to_uint32
__igcbuiltin_int32_to_dp
__igcbuiltin_uint32_to_dp
__igcbuiltin_dp_to_sp
__igcbuiltin_sp_to_dp
__igcbuiltin_dp_sqrt
__igcbuiltin_sp_div
Remainder
__precompiled_convert_f64_to_f16
DPEmuFlag
DPEmufp16tofp32
DPEmusext
DPEmuzext
DPEmuTrunc
DPEmuCmp
DPEmuFabs
PreCompiledFuncImport
igc-precompiled-import
ptrVec2ptrScl
GEP_lane
scalar
assembled.vect
Scalarize functions
igc-scalarize
ScalarizeFunction
Fix FMF for APIs that are using legacy IR
fix-fast-math-flags
Fix Fast Math Flags
_Z13get_global_idj
__builtin_spirv_BuiltInGlobalInvocationID
__builtin_spirv_BuiltInLocalInvocationId
__builtin_spirv_BuiltInWorkgroupId
sgid
assumeCond
Mark readonly load
mark-readonly-load
MarkReadOnlyLoadPass
RectListOptimization
callees
endIndirectCallBB
funcThen
funcElse
Changes indirect calls to direct calls if possible
indirect-call-optimization
IndirectCallOptimization
Simplify return types and bodies of dead visible functions
igc-fix-dead-visible-functions
FixDeadVisibleFunctions
read_write
image1d
image1d_buffer
image2d
image2d_depth
image2d_msaa
image2d_msaa_depth
image3d
image1d_array
image2d_array
image2d_array_depth
image2d_array_msaa
image2d_array_msaa_depth
sampler_t
bindless_sampler_t
Breakdown intrinsics into simpler operations to enable better optimization
breakdown-intrinsics
BreakdownIntrinsicPass
double type is not supported on this platform
Check for input errors
igc-error-check
Error Check
Address space alias analysis
igc-address-space-alias-analysis
_alloca
Analyze aggregate arguments
igc-agg-arg-analysis
Resolve aggregate arguments
igc-agg-arg
AggregateArgumentsAnalysis
ResolveAggregateArguments
Fix the alignment of loads and stores according to OpenCL rules
igc-fix-alignment
AlignmentAnalysisPass
__builtin_IB_get_local_lock
__builtin_IB_atomic_add_global_i32
__builtin_IB_atomic_add_local_i32
__builtin_IB_atomic_sub_global_i32
__builtin_IB_atomic_sub_local_i32
__builtin_IB_atomic_xchg_global_i32
__builtin_IB_atomic_xchg_local_i32
__builtin_IB_atomic_min_global_i32
__builtin_IB_atomic_min_global_u32
__builtin_IB_atomic_min_global_f32
__builtin_IB_atomic_min_local_i32
__builtin_IB_atomic_min_local_u32
__builtin_IB_atomic_min_local_f32
__builtin_IB_atomic_max_global_i32
__builtin_IB_atomic_max_global_u32
__builtin_IB_atomic_max_global_f32
__builtin_IB_atomic_max_local_i32
__builtin_IB_atomic_max_local_u32
__builtin_IB_atomic_max_local_f32
__builtin_IB_atomic_and_global_i32
__builtin_IB_atomic_and_local_i32
__builtin_IB_atomic_or_global_i32
__builtin_IB_atomic_or_local_i32
__builtin_IB_atomic_xor_global_i32
__builtin_IB_atomic_xor_local_i32
__builtin_IB_atomic_inc_global_i32
__builtin_IB_atomic_inc_local_i32
__builtin_IB_atomic_dec_global_i32
__builtin_IB_atomic_dec_local_i32
__builtin_IB_atomic_cmpxchg_global_i32
__builtin_IB_atomic_cmpxchg_global_f32
__builtin_IB_atomic_cmpxchg_local_i32
__builtin_IB_atomic_cmpxchg_local_f32
__builtin_IB_atomic_add_global_i64
__builtin_IB_atomic_sub_global_i64
__builtin_IB_atomic_xchg_global_i64
__builtin_IB_atomic_min_global_i64
__builtin_IB_atomic_min_global_u64
__builtin_IB_atomic_min_global_f64
__builtin_IB_atomic_max_global_i64
__builtin_IB_atomic_max_global_u64
__builtin_IB_atomic_max_global_f64
__builtin_IB_atomic_and_global_i64
__builtin_IB_atomic_or_global_i64
__builtin_IB_atomic_xor_global_i64
__builtin_IB_atomic_inc_global_i64
__builtin_IB_atomic_dec_global_i64
__builtin_IB_atomic_cmpxchg_global_i64
__builtin_IB_atomic_cmpxchg_global_f64
__builtin_IB_atomic_add_global_i16
__builtin_IB_atomic_add_local_i16
__builtin_IB_atomic_sub_global_i16
__builtin_IB_atomic_sub_local_i16
__builtin_IB_atomic_xchg_global_i16
__builtin_IB_atomic_xchg_local_i16
__builtin_IB_atomic_min_global_i16
__builtin_IB_atomic_min_global_u16
__builtin_IB_atomic_min_global_f16
__builtin_IB_atomic_min_local_i16
__builtin_IB_atomic_min_local_u16
__builtin_IB_atomic_min_local_f16
__builtin_IB_atomic_max_global_i16
__builtin_IB_atomic_max_global_u16
__builtin_IB_atomic_max_global_f16
__builtin_IB_atomic_max_local_i16
__builtin_IB_atomic_max_local_u16
__builtin_IB_atomic_max_local_f16
__builtin_IB_atomic_and_global_i16
__builtin_IB_atomic_and_local_i16
__builtin_IB_atomic_or_global_i16
__builtin_IB_atomic_or_local_i16
__builtin_IB_atomic_xor_global_i16
__builtin_IB_atomic_xor_local_i16
__builtin_IB_atomic_inc_global_i16
__builtin_IB_atomic_inc_local_i16
__builtin_IB_atomic_dec_global_i16
__builtin_IB_atomic_dec_local_i16
__builtin_IB_atomic_cmpxchg_global_i16
__builtin_IB_atomic_cmpxchg_global_f16
__builtin_IB_atomic_cmpxchg_local_i16
__builtin_IB_atomic_cmpxchg_local_f16
PtrDstToInt
spinlock
init_spinlock_var.end
init_spinlock_var.start
Resolve atomic built-ins
igc-resolve-atomics
ResolveOCLAtomics
Break constant expressions into instruction sequences
igc-break-const-expr
BreakConstantExprPass
Ensures single precision divide and sqrt are correctly rounded
igc-correctly-rounded-div-sqrt
grid
__ocl_dbg_gid
__ocl_dbg_lid
__ocl_dbg_grid
long long
__builtin_spirv_BuiltInGlobalInvocationId
Implicit Global Id Pass - Add parameters for debugging
igc-add-implicit-gid
ImplicitGlobalId
__builtin_IB_get_default_device_queue
__builtin_IB_get_event_pool
__builtin_IB_get_max_workgroup_size
__builtin_IB_get_parent_event
__builtin_IB_get_prefered_workgroup_multiple
__builtin_IB_get_object_id
__builtin_IB_get_block_simd_size
Analyzes device enqueue functions
igc-device-enqueue-func-analysis
Resolve device enqueue functions
igc-device-enqueue-func-resolution
DeviceEnqueueFuncsAnalysis
DeviceEnqueueFuncsResolution
TransformBlocksOutput
Output the .llvm generated from TransformBlocks pass
__get_kernel_work_group_size_impl
_Z45get_kernel_preferred_work_group_size_multiple
__get_kernel_preferred_work_group_multiple_impl
_Z41get_kernel_max_sub_group_size_for_ndrange
_Z38get_kernel_sub_group_count_for_ndrange
__builtin_spirv_OpEnqueueKernel
__builtin_spirv_OpGetKernelNDrangeSubGroupCount
__builtin_spirv_OpGetKernelNDrangeMaxSubGroupSize
__builtin_spirv_OpGetKernelPreferredWorkGroupSizeMultiple
__builtin_spirv_OpGetKernelLocalSizeForSubgroupCount
__builtin_spirv_OpGetKernelMaxNumSubgroups
igc-block-transform
TransformBlocks Pass
indirect calls are not supported
Enqueue param is not set
Enqueue param is not a struct
Device enqueue invoke param is not a function
block_simd_size
IGIL_calc_sub_group_count_for_ndrange
NDRange type mismatch
converted_ndrange
__builtin_IB_copyNDRangeTondrange
struct.ndrange_t
enqueue_kernel signature does not match
_local
captured value is null
scalar_buf
pointer_buf
pointer_arg_map_buf
object_map_buf
unknown argument number for an object
obj_id
local_size_buf
scalarParamBuf
globalArgBuf
globalPtrArgMappingBuf
getobjectidMappingBuf
casted_ptr
__intel_calc_kernel_local_size_for_sub_group_count
__intel_calc_kernel_max_num_subgroups
OpEnqueueKernel signature does not match
invoke function should not be null
Fail parent kernel lookup: possible closed self-enqueue
_dispatch_
capture
local_ptr
.block_struct
.block_descriptor
parent calls for invoke are not set
Fail parent call lookup: possible closed self-enqueue
unknown_type
_NSConcreteStackBlock
_NSConcreteGlobalBlock
llvm.loop.unroll.enable
llvm.loop.unroll.full
Disable loop unroll on retry
igc-disable-loop-unroll
DisableLoopUnrollOnRetry
block_motion_estimate_intel
block_advanced_motion_estimate_check_intel
block_advanced_motion_estimate_bidirectional_check_intel
erode_2d_intel
dilate_2d_intel
min_filter_2d_intel
max_filter_2d_intel
convolve_2d_intel
minmax_2d_intel
centroid_2d_intel
bool_centroid_2d_intel
bool_sum_2d_intel
convolve_1d_intel
convolve_pixel_intel
lbp_image_intel
lbp_correlation_intel
floodfill_intel
correlation_search_intel
__builtin_IB_media_block_rectangle_read
Analyzes extenstion functions arguments
igc-extension-arg-analysis
SIMD16 is expected
ExtensionArgAnalysis
Resolves extension function
igc-extension-funcs-resolution
ExtensionFuncsResolution
__builtin_IB_vme_mb_block_type
__builtin_IB_vme_subpixel_mode
__builtin_IB_vme_sad_adjust_mode
__builtin_IB_vme_search_path_type
__builtin_IB_vme_helper_get_handle
__builtin_IB_vme_helper_get_as
Analyzes extension functions
igc-extension-funcs-analysis
ExtensionFuncsAnalysis
GenericAddressAnalysis
GenericAddressDynamicResolution
LocalLoadBlock
GlobalPrivateLoadBlock
localLoad
globalOrPrivateLoad
CmpWindowLowerBound
CmpWindowUpperBound
isPtrInWindow
localWindowEnd
Resolves image height, width, depth functions
igc-image-func-resolution
ImageFuncResolution
__builtin_IB_get_image_height
__builtin_IB_get_image_width
__builtin_IB_get_image_depth
__builtin_IB_get_image_num_mip_levels
__builtin_IB_get_image_channel_data_type
__builtin_IB_get_image_channel_order
__builtin_IB_get_image_srgb_channel_order
__builtin_IB_get_image_array_size
__builtin_IB_get_image_num_samples
__builtin_IB_get_address_mode
Analyzes image height, width, depth functions
igc-image-func-analysis
ImageFuncsAnalysis
-ExtSLM
localToChar
movedLocal
charToLocal
GenSLM.LocalMemPoolOnGetMemPoolPtr
mempoolcast
localSLM
Resolve inline local variables/buffers
igc-resolve-inline-locals
InlineLocalsResolutionPass
Analyzes OpenCL printf calls
igc-opencl-printf-analysis
OpenCLPrintfAnalysis
write_offset
end_offset
buffer_ptr
bblockJoin
write_offset_true
write_offset_false
write_offset_ptr
write_error_string
bblockFalseJoin
printf_ret_val
to_float
ptrBC
Resolves OpenCL printf calls
igc-opencl-printf-resolution
OpenCLPrintfResolution
OCL IGC-Internal-ERRORERROR!!!: Non-OCL is not supposed to reach here!
Resolves private memory allocation
igc-private-mem-resolution
PrivateMemoryResolution
Analyzes the presence of private memory allocation
igc-private-mem-usage-analysis
PrivateMemoryUsageAnalysis
Creates annotations for OpenCL program-scope structures
igc-programscope-constant-analysis
ProgramScopeConstantAnalysisPass
cast
Resolves references to inline constants
igc-programscope-constant-resolve
ProgramScopeConstantResolutionPass
Replace calls to instrinsics which are not supported by the codegen
igc-replace-unsupported-intrinsics
memcpy_vsrc
memcpy_vdst
memcpy
memcpy_src
memcpy_dst
memcpy_rem
.post
.body
memset_vdst
memset
memset_dst
memset_rem
memmove.post
memmove.true
memmove.false
memmmove
memmove
ReplaceUnsupportedIntrinsics
Allocates UAV and SRV numbers to kernel arguments
igc-resource-allocator
ResourceAllocatorPass
Set llvm fast math flags according to compiler options
igc-set-fast-math-flags
SetFastMathFlags
__builtin_IB_sub_group_barrier
__builtin_IB_get_simd_size
__builtin_IB_get_simd_id
__builtin_IB_simd_shuffle
__builtin_IB_simd_shuffle_us
__builtin_IB_simd_shuffle_f
__builtin_IB_simd_shuffle_h
__builtin_IB_simd_shuffle_b
__builtin_IB_simd_shuffle_df
__builtin_IB_simd_shuffle_down
__builtin_IB_simd_shuffle_down_us
__builtin_IB_simd_shuffle_down_uc
__builtin_IB_simd_block_read_1_global
__builtin_IB_simd_block_read_2_global
__builtin_IB_simd_block_read_4_global
__builtin_IB_simd_block_read_8_global
__builtin_IB_simd_block_read_1_global_h
__builtin_IB_simd_block_read_2_global_h
__builtin_IB_simd_block_read_4_global_h
__builtin_IB_simd_block_read_8_global_h
__builtin_IB_simd_block_read_16_global_h
__builtin_IB_simd_block_read_1_global_b
__builtin_IB_simd_block_read_2_global_b
__builtin_IB_simd_block_read_4_global_b
__builtin_IB_simd_block_read_8_global_b
__builtin_IB_simd_block_read_16_global_b
__builtin_IB_simd_block_read_1_global_l
__builtin_IB_simd_block_read_2_global_l
__builtin_IB_simd_block_read_4_global_l
__builtin_IB_simd_block_read_8_global_l
__builtin_IB_simd_block_write_1_global
__builtin_IB_simd_block_write_2_global
__builtin_IB_simd_block_write_4_global
__builtin_IB_simd_block_write_8_global
__builtin_IB_simd_block_write_1_global_h
__builtin_IB_simd_block_write_2_global_h
__builtin_IB_simd_block_write_4_global_h
__builtin_IB_simd_block_write_8_global_h
__builtin_IB_simd_block_write_16_global_h
__builtin_IB_simd_block_write_1_global_b
__builtin_IB_simd_block_write_2_global_b
__builtin_IB_simd_block_write_4_global_b
__builtin_IB_simd_block_write_8_global_b
__builtin_IB_simd_block_write_16_global_b
__builtin_IB_simd_block_write_1_global_l
__builtin_IB_simd_block_write_2_global_l
__builtin_IB_simd_block_write_4_global_l
__builtin_IB_simd_block_write_8_global_l
__builtin_IB_simd_media_block_read_1
__builtin_IB_simd_media_block_read_2
__builtin_IB_simd_media_block_read_4
__builtin_IB_simd_media_block_read_8
__builtin_IB_simd_media_block_read_1_h
__builtin_IB_simd_media_block_read_2_h
__builtin_IB_simd_media_block_read_4_h
__builtin_IB_simd_media_block_read_8_h
__builtin_IB_simd_media_block_read_16_h
__builtin_IB_simd_media_block_read_1_b
__builtin_IB_simd_media_block_read_2_b
__builtin_IB_simd_media_block_read_4_b
__builtin_IB_simd_media_block_read_8_b
__builtin_IB_simd_media_block_read_16_b
__builtin_IB_simd_media_block_read_1_l
__builtin_IB_simd_media_block_read_2_l
__builtin_IB_simd_media_block_read_4_l
__builtin_IB_simd_media_block_read_8_l
__builtin_IB_simd_media_block_write_1
__builtin_IB_simd_media_block_write_2
__builtin_IB_simd_media_block_write_4
__builtin_IB_simd_media_block_write_8
__builtin_IB_simd_media_block_write_1_h
__builtin_IB_simd_media_block_write_2_h
__builtin_IB_simd_media_block_write_4_h
__builtin_IB_simd_media_block_write_8_h
__builtin_IB_simd_media_block_write_16_h
__builtin_IB_simd_media_block_write_1_l
__builtin_IB_simd_media_block_write_2_l
__builtin_IB_simd_media_block_write_4_l
__builtin_IB_simd_media_block_write_8_l
__builtin_IB_simd_media_block_write_1_b
__builtin_IB_simd_media_block_write_2_b
__builtin_IB_simd_media_block_write_4_b
__builtin_IB_simd_media_block_write_8_b
__builtin_IB_simd_media_block_write_16_b
__builtin_IB_media_block_read
__builtin_IB_media_block_write
__builtin_IB_get_image_bti
__builtin_IB_sub_group_reduce_OpGroupIAdd
__builtin_IB_sub_group_reduce_OpGroupSMax
__builtin_IB_sub_group_reduce_OpGroupUMax
__builtin_IB_sub_group_reduce_OpGroupSMin
__builtin_IB_sub_group_reduce_OpGroupUMin
__builtin_IB_sub_group_reduce_OpGroupFAdd
__builtin_IB_sub_group_reduce_OpGroupFMax
__builtin_IB_sub_group_reduce_OpGroupFMin
__builtin_IB_sub_group_scan_OpGroupIAdd
__builtin_IB_sub_group_scan_OpGroupSMax
__builtin_IB_sub_group_scan_OpGroupUMax
__builtin_IB_sub_group_scan_OpGroupSMin
__builtin_IB_sub_group_scan_OpGroupUMin
__builtin_IB_sub_group_scan_OpGroupFAdd
__builtin_IB_sub_group_scan_OpGroupFMax
__builtin_IB_sub_group_scan_OpGroupFMin
BlockReadLocal not supported!
BlockWriteLocal not supported!
xOffset
yOffset
simdSize
simdLaneId16
simdLaneId
Shuffle not supported in SIMD32
simdShuffle
Shuffle Down not supported in SIMD32
simdShuffleDown
Block reads not supported in SIMD32
Block writes not supported in SIMD32
SIMD Media Block Read not supported in SIMD32
SIMD Media Block Write not supported in SIMD32
width argument supplied to intel_media_block_read*() must be constant.
height argument supplied to intel_media_block_read*() must be constant.
width argument supplied to intel_media_block_write*() must be constant.
height argument supplied to intel_media_block_write*() must be constant.
intel_media_block_read
intel_media_block_write
width for 
*() must be <= 
height for 
 bytes wide 
*() attempt of 
 bytes.  Must be <= 
 bytes.
_uc*() widths must be quad pixel aligned.
_us*() widths must be dual pixel aligned.
Resolves sub group functions
igc-sub-group-func-resolution
SubGroupFuncsResolution
invariant.load
p%d:32:32:32
p%d:
-p%d:32:32:32
Tries to convert stateless to statefull accesses
igc-stateless-to-statefull-resolution
StatelessToStatefull
Emit linker warnings to user
undefined-references
undefined reference to `
UndefinedReferencesPass
Resolve WG built-in
igc-wg-resolution
WGFuncResolution
cmpDim
tmpOffsetR0
offsetR0
groupId
globalOffset
numGroups
grid_origin
grid_size
Resolves work item functions
igc-wi-func-resolution
WIFuncResolution
__builtin_IB_get_global_offset
__builtin_IB_get_work_dim
__builtin_IB_get_sync_buffer
Analyzes work item functions
igc-wi-func-analysis
WIFuncsAnalysis
Sets a limit on unrolling metadata to control compile time
igc-clamp-loop-unroll
ClampLoopUnroll
Converts 3d images access to 2d array image accesses where possible
igc-3d-to-2darray
Image3dToImage2darray
converts get_local_size() to get_enqueued_local_size()
igc-rewrite-local-size
RewriteLocalSize
srem
urem
sext
addconv
diff.neg
.not
notmask
.masked
and.shrunk
bitfield
notlhs
notrhs
.demorgan
igc-instcombine-guard-widening-window
How wide an instruction window to bypass looking for another guard
blendv
exec
thunk
nest
nvptx-f32ftz
unmaskedload
.splatinsert
.splat
castvec
tmpcast
.lobit
.mask
.unshifted
.idx
.sext
.add
to.ptr
.ptr
.conv
sadd
sadd.result
sadd.overflow
umul
umul.value
.cast
.val
storemerge
.sub
.unpack
.repack
suba
subc
mulconv
igc-instcombine-max-num-phis
Maximum number phis to handle in intptr/ptrint folding
.shrunk
extract
extract.t
narrow
not.
.inv
.Elt
.lhs
.rhs
.extract
instcombine-visit
Controls which instructions are visited
igc-expensive-combines
Enable expensive instruction combines
igc-instcombine-maxarray-size
Maximum array size considered when doing a combine
igc-instcombine-lower-dbg-declare
phitmp
trunc
SmallVector capacity overflow during allocation
Allocation failed
igcinstcombine
.offs
not_intrinsic
llvm.genx.GenISA.CatchAllDebugLine
llvm.genx.GenISA.DCL.DSCntrlPtInputVec
llvm.genx.GenISA.DCL.DSInputTessFactor
llvm.genx.GenISA.DCL.DSPatchConstInputVec
llvm.genx.GenISA.DCL.GSinputVec
llvm.genx.GenISA.DCL.GSsystemValue
llvm.genx.GenISA.DCL.HSControlPointID
llvm.genx.GenISA.DCL.HSOutputCntrlPtInputVec
llvm.genx.GenISA.DCL.HSPatchConstInputVec
llvm.genx.GenISA.DCL.HSinputVec
llvm.genx.GenISA.DCL.ShaderInputVec
llvm.genx.GenISA.DCL.SystemValue
llvm.genx.GenISA.DCL.input
llvm.genx.GenISA.DCL.inputVec
llvm.genx.GenISA.EndPrimitive
llvm.genx.GenISA.EnqueuedLocalSizeLocation
llvm.genx.GenISA.GetBufferPtr
llvm.genx.GenISA.GetPixelMask
llvm.genx.GenISA.GlobalDataAccess
llvm.genx.GenISA.GlobalSizeLocation
llvm.genx.GenISA.GradientX
llvm.genx.GenISA.GradientXfine
llvm.genx.GenISA.GradientY
llvm.genx.GenISA.GradientYfine
llvm.genx.GenISA.GridOriginLocation
llvm.genx.GenISA.GridSizeLocation
llvm.genx.GenISA.GroupIdLocation
llvm.genx.GenISA.GsCutControlHeader
llvm.genx.GenISA.GsStreamHeader
llvm.genx.GenISA.HSURBPatchHeaderRead
llvm.genx.GenISA.IEEE.Divide
llvm.genx.GenISA.IEEE.Sqrt
llvm.genx.GenISA.InitDiscardMask
llvm.genx.GenISA.InnerScalarTessFactors
llvm.genx.GenISA.Interpolant
llvm.genx.GenISA.Interpolate
llvm.genx.GenISA.Interpolate2
llvm.genx.GenISA.IsHelperInvocation
llvm.genx.GenISA.LocalIdLocation
llvm.genx.GenISA.LocalSizeLocation
llvm.genx.GenISA.MediaBlockRead
llvm.genx.GenISA.MediaBlockRectangleRead
llvm.genx.GenISA.MediaBlockWrite
llvm.genx.GenISA.OUTPUT
llvm.genx.GenISA.OUTPUTGS
llvm.genx.GenISA.OUTPUTGS2
llvm.genx.GenISA.OWordPtr
llvm.genx.GenISA.OuterScalarTessFactors
llvm.genx.GenISA.OutputTessControlPoint
llvm.genx.GenISA.OutputTessFactors
llvm.genx.GenISA.PHASE.INPUT
llvm.genx.GenISA.PHASE.OUTPUT
llvm.genx.GenISA.PatchConstantOutput
llvm.genx.GenISA.PixelPositionX
llvm.genx.GenISA.PixelPositionY
llvm.genx.GenISA.PullCentroidBarys
llvm.genx.GenISA.PullSampleIndexBarys
llvm.genx.GenISA.PullSnappedBarys
llvm.genx.GenISA.QuadPrefix
llvm.genx.GenISA.ROUNDNE
llvm.genx.GenISA.RTDualBlendSource
llvm.genx.GenISA.RTWrite
llvm.genx.GenISA.RenderTargetRead
llvm.genx.GenISA.RenderTargetReadSampleFreq
llvm.genx.GenISA.RuntimeValue
llvm.genx.GenISA.SampleOffsetX
llvm.genx.GenISA.SampleOffsetY
llvm.genx.GenISA.SetDebugReg
llvm.genx.GenISA.SetStream
llvm.genx.GenISA.StackAlloca
llvm.genx.GenISA.URBRead
llvm.genx.GenISA.URBReadOutput
llvm.genx.GenISA.URBWrite
llvm.genx.GenISA.UpdateDiscardMask
llvm.genx.GenISA.VirtualBindingTableBaseLocation
llvm.genx.GenISA.WaveAll
llvm.genx.GenISA.WaveBallot
llvm.genx.GenISA.WaveClustered
llvm.genx.GenISA.WaveInverseBallot
llvm.genx.GenISA.WavePrefix
llvm.genx.GenISA.WaveShuffleIndex
llvm.genx.GenISA.WorkGroupAny
llvm.genx.GenISA.add.pair
llvm.genx.GenISA.add.rtz
llvm.genx.GenISA.atomiccounterinc
llvm.genx.GenISA.atomiccounterpredec
llvm.genx.GenISA.bfi
llvm.genx.GenISA.bfrev
llvm.genx.GenISA.broadcastMessagePhase
llvm.genx.GenISA.broadcastMessagePhaseV
llvm.genx.GenISA.cmpSADs
llvm.genx.GenISA.cmpxchgatomicstructured
llvm.genx.GenISA.createMessagePhases
llvm.genx.GenISA.createMessagePhasesNoInit
llvm.genx.GenISA.createMessagePhasesNoInitV
llvm.genx.GenISA.createMessagePhasesV
llvm.genx.GenISA.cycleCounter
llvm.genx.GenISA.discard
llvm.genx.GenISA.dp4a.ss
llvm.genx.GenISA.dp4a.su
llvm.genx.GenISA.dp4a.us
llvm.genx.GenISA.dp4a.uu
llvm.genx.GenISA.dwordatomicstructured
llvm.genx.GenISA.eu.id
llvm.genx.GenISA.eu.thread.id
llvm.genx.GenISA.eu.thread.pause
llvm.genx.GenISA.evaluateSampler
llvm.genx.GenISA.extractMVAndSAD
llvm.genx.GenISA.f32tof16.rtz
llvm.genx.GenISA.fcmpxchgatomicraw
llvm.genx.GenISA.fcmpxchgatomicrawA64
llvm.genx.GenISA.fcmpxchgatomicstructured
llvm.genx.GenISA.firstbitHi
llvm.genx.GenISA.firstbitLo
llvm.genx.GenISA.firstbitShi
llvm.genx.GenISA.floatatomicraw
llvm.genx.GenISA.floatatomicrawA64
llvm.genx.GenISA.floatatomicstructured
llvm.genx.GenISA.flushsampler
llvm.genx.GenISA.fma.rtz
llvm.genx.GenISA.fsat
llvm.genx.GenISA.ftof.rtn
llvm.genx.GenISA.ftof.rtp
llvm.genx.GenISA.ftof.rtz
llvm.genx.GenISA.ftoi.rte
llvm.genx.GenISA.ftoi.rtn
llvm.genx.GenISA.ftoi.rtp
llvm.genx.GenISA.ftoui.rte
llvm.genx.GenISA.ftoui.rtn
llvm.genx.GenISA.ftoui.rtp
llvm.genx.GenISA.gather4Cptr
llvm.genx.GenISA.gather4POCptr
llvm.genx.GenISA.gather4POptr
llvm.genx.GenISA.gather4ptr
llvm.genx.GenISA.getEnqueuedLocalSize
llvm.genx.GenISA.getGlobalSize
llvm.genx.GenISA.getGridOrigin
llvm.genx.GenISA.getGridSize
llvm.genx.GenISA.getGroupId
llvm.genx.GenISA.getLocalId
llvm.genx.GenISA.getLocalSize
llvm.genx.GenISA.getMessagePhase
llvm.genx.GenISA.getMessagePhaseV
llvm.genx.GenISA.getMessagePhaseX
llvm.genx.GenISA.getMessagePhaseXV
llvm.genx.GenISA.getSR0
llvm.genx.GenISA.getSimdGroupSize
llvm.genx.GenISA.globalSync
llvm.genx.GenISA.hw.thread.id
llvm.genx.GenISA.ibfe
llvm.genx.GenISA.icmpxchgatomicraw
llvm.genx.GenISA.icmpxchgatomicrawA64
llvm.genx.GenISA.icmpxchgatomictyped
llvm.genx.GenISA.imulH
llvm.genx.GenISA.intatomicraw
llvm.genx.GenISA.intatomicrawA64
llvm.genx.GenISA.intatomictyped
llvm.genx.GenISA.is.uniform
llvm.genx.GenISA.itof.rtn
llvm.genx.GenISA.itof.rtp
llvm.genx.GenISA.itof.rtz
llvm.genx.GenISA.ldmcsptr
llvm.genx.GenISA.ldmsptr
llvm.genx.GenISA.ldmsptr16bit
llvm.genx.GenISA.ldptr
llvm.genx.GenISA.ldraw.indexed
llvm.genx.GenISA.ldrawvector.indexed
llvm.genx.GenISA.ldstructured
llvm.genx.GenISA.lodptr
llvm.genx.GenISA.memoryfence
llvm.genx.GenISA.mov.identity
llvm.genx.GenISA.movcr
llvm.genx.GenISA.movflag
llvm.genx.GenISA.mul.pair
llvm.genx.GenISA.mul.rtz
llvm.genx.GenISA.pair.to.ptr
llvm.genx.GenISA.patchInstanceId
llvm.genx.GenISA.ptr.to.pair
llvm.genx.GenISA.readsurfaceinfoptr
llvm.genx.GenISA.resinfoptr
llvm.genx.GenISA.rsq
llvm.genx.GenISA.sampleBCptr
llvm.genx.GenISA.sampleBptr
llvm.genx.GenISA.sampleCptr
llvm.genx.GenISA.sampleDCptr
llvm.genx.GenISA.sampleDptr
llvm.genx.GenISA.sampleKillPix
llvm.genx.GenISA.sampleLCptr
llvm.genx.GenISA.sampleLptr
llvm.genx.GenISA.sampleinfoptr
llvm.genx.GenISA.sampleptr
llvm.genx.GenISA.setMessagePhase
llvm.genx.GenISA.setMessagePhaseV
llvm.genx.GenISA.setMessagePhaseX
llvm.genx.GenISA.setMessagePhaseXV
llvm.genx.GenISA.setMessagePhaseX.legacy
llvm.genx.GenISA.setMessagePhase.legacy
llvm.genx.GenISA.simdBlockRead
llvm.genx.GenISA.simdBlockReadBindless
llvm.genx.GenISA.simdBlockWrite
llvm.genx.GenISA.simdBlockWriteBindless
llvm.genx.GenISA.simdGetMessagePhase
llvm.genx.GenISA.simdGetMessagePhaseV
llvm.genx.GenISA.simdLaneId
llvm.genx.GenISA.simdMediaBlockRead
llvm.genx.GenISA.simdMediaBlockWrite
llvm.genx.GenISA.simdMediaRegionCopy
llvm.genx.GenISA.simdSetMessagePhase
llvm.genx.GenISA.simdSetMessagePhaseV
llvm.genx.GenISA.simdShuffleDown
llvm.genx.GenISA.simdSize
llvm.genx.GenISA.slice.id
llvm.genx.GenISA.source.value
llvm.genx.GenISA.storeraw.indexed
llvm.genx.GenISA.storerawvector.indexed
llvm.genx.GenISA.storestructured1
llvm.genx.GenISA.storestructured2
llvm.genx.GenISA.storestructured3
llvm.genx.GenISA.storestructured4
llvm.genx.GenISA.sub.pair
llvm.genx.GenISA.subslice.id
llvm.genx.GenISA.threadgroupbarrier
llvm.genx.GenISA.threadgroupbarrier.signal
llvm.genx.GenISA.threadgroupbarrier.wait
llvm.genx.GenISA.typedmemoryfence
llvm.genx.GenISA.typedread
llvm.genx.GenISA.typedwrite
llvm.genx.GenISA.uaddc
llvm.genx.GenISA.uavSerializeAll
llvm.genx.GenISA.uavSerializeOnResID
llvm.genx.GenISA.ubfe
llvm.genx.GenISA.uitof.rtn
llvm.genx.GenISA.uitof.rtp
llvm.genx.GenISA.uitof.rtz
llvm.genx.GenISA.umulH
llvm.genx.GenISA.usubb
llvm.genx.GenISA.vaBoolCentroid
llvm.genx.GenISA.vaBoolSum
llvm.genx.GenISA.vaCentroid
llvm.genx.GenISA.vaConvolve
llvm.genx.GenISA.vaConvolveGRF.16x1
llvm.genx.GenISA.vaConvolveGRF.16x4
llvm.genx.GenISA.vaDilate
llvm.genx.GenISA.vaErode
llvm.genx.GenISA.vaMinMax
llvm.genx.GenISA.vaMinMaxFilter
llvm.genx.GenISA.vmeSendFBR
llvm.genx.GenISA.vmeSendFBR2
llvm.genx.GenISA.vmeSendIME
llvm.genx.GenISA.vmeSendIME2
llvm.genx.GenISA.vmeSendSIC
llvm.genx.GenISA.vmeSendSIC2
llvm.genx.GenISA.wavebarrier
CatchAllDebugLine@
DCL_DSCntrlPtInputVec@
DCL_DSInputTessFactor@
DCL_DSPatchConstInputVec@
DCL_GSinputVec@
DCL_GSsystemValue@
DCL_HSControlPointID@
DCL_HSOutputCntrlPtInputVec@
DCL_HSPatchConstInputVec@
DCL_HSinputVec@
DCL_ShaderInputVec@
DCL_SystemValue@
DCL_input@
DCL_inputVec@
EndPrimitive@
EnqueuedLocalSizeLocation@
GetBufferPtr@
GetPixelMask@
GlobalDataAccess@
GlobalSizeLocation@
GradientX@
GradientXfine@
GradientY@
GradientYfine@
GridOriginLocation@
GridSizeLocation@
GroupIdLocation@
GsCutControlHeader@
GsStreamHeader@
HSURBPatchHeaderRead@
IEEE_Divide@
IEEE_Sqrt@
InitDiscardMask@
InnerScalarTessFactors@
Interpolant@
Interpolate@
Interpolate2@
IsHelperInvocation@
LocalIdLocation@
LocalSizeLocation@
MediaBlockRead@
MediaBlockRectangleRead@
MediaBlockWrite@
OUTPUT@
OUTPUTGS@
OUTPUTGS2@
OWordPtr@
OuterScalarTessFactors@
OutputTessControlPoint@
OutputTessFactors@
PHASE_INPUT@
PHASE_OUTPUT@
PatchConstantOutput@
PixelPositionX@
PixelPositionY@
PullCentroidBarys@
PullSampleIndexBarys@
PullSnappedBarys@
QuadPrefix@
ROUNDNE@
RTDualBlendSource@
RTWrite@
RenderTargetRead@
RenderTargetReadSampleFreq@
RuntimeValue@
SampleOffsetX@
SampleOffsetY@
SetDebugReg@
SetStream@
StackAlloca@
URBRead@
URBReadOutput@
URBWrite@
UpdateDiscardMask@
VirtualBindingTableBaseLocation@
WaveAll@
WaveBallot@
WaveClustered@
WaveInverseBallot@
WavePrefix@
WaveShuffleIndex@
WorkGroupAny@
add_pair@
add_rtz@
atomiccounterinc@
atomiccounterpredec@
bfi@
bfrev@
broadcastMessagePhase@
broadcastMessagePhaseV@
cmpSADs@
cmpxchgatomicstructured@
createMessagePhases@
createMessagePhasesNoInit@
createMessagePhasesNoInitV@
createMessagePhasesV@
cycleCounter@
discard@
dp4a_ss@
dp4a_su@
dp4a_us@
dp4a_uu@
dwordatomicstructured@
eu_id@
eu_thread_id@
eu_thread_pause@
evaluateSampler@
extractMVAndSAD@
f32tof16_rtz@
fcmpxchgatomicraw@
fcmpxchgatomicrawA64@
fcmpxchgatomicstructured@
firstbitHi@
firstbitLo@
firstbitShi@
floatatomicraw@
floatatomicrawA64@
floatatomicstructured@
flushsampler@
fma_rtz@
fsat@
ftof_rtn@
ftof_rtp@
ftof_rtz@
ftoi_rte@
ftoi_rtn@
ftoi_rtp@
ftoui_rte@
ftoui_rtn@
ftoui_rtp@
gather4Cptr@
gather4POCptr@
gather4POptr@
gather4ptr@
getEnqueuedLocalSize@
getGlobalSize@
getGridOrigin@
getGridSize@
getGroupId@
getLocalId@
getLocalSize@
getMessagePhase@
getMessagePhaseV@
getMessagePhaseX@
getMessagePhaseXV@
getSR0@
getSimdGroupSize@
globalSync@
hw_thread_id@
ibfe@
icmpxchgatomicraw@
icmpxchgatomicrawA64@
icmpxchgatomictyped@
imulH@
intatomicraw@
intatomicrawA64@
intatomictyped@
is_uniform@
itof_rtn@
itof_rtp@
itof_rtz@
ldmcsptr@
ldmsptr@
ldmsptr16bit@
ldptr@
ldraw_indexed@
ldrawvector_indexed@
ldstructured@
lodptr@
memoryfence@
mov_identity@
movcr@
movflag@
mul_pair@
mul_rtz@
pair_to_ptr@
patchInstanceId@
ptr_to_pair@
readsurfaceinfoptr@
resinfoptr@
rsq@
sampleBCptr@
sampleBptr@
sampleCptr@
sampleDCptr@
sampleDptr@
sampleKillPix@
sampleLCptr@
sampleLptr@
sampleinfoptr@
sampleptr@
setMessagePhase@
setMessagePhaseV@
setMessagePhaseX@
setMessagePhaseXV@
setMessagePhaseX_legacy@
setMessagePhase_legacy@
simdBlockRead@
simdBlockReadBindless@
simdBlockWrite@
simdBlockWriteBindless@
simdGetMessagePhase@
simdGetMessagePhaseV@
simdLaneId@
simdMediaBlockRead@
simdMediaBlockWrite@
simdMediaRegionCopy@
simdSetMessagePhase@
simdSetMessagePhaseV@
simdShuffleDown@
simdSize@
slice_id@
source_value@
storeraw_indexed@
storerawvector_indexed@
storestructured1@
storestructured2@
storestructured3@
storestructured4@
sub_pair@
subslice_id@
threadgroupbarrier@
threadgroupbarrier_signal@
threadgroupbarrier_wait@
typedmemoryfence@
typedread@
typedwrite@
uaddc@
uavSerializeAll@
uavSerializeOnResID@
ubfe@
uitof_rtn@
uitof_rtp@
uitof_rtz@
umulH@
usubb@
vaBoolCentroid@
vaBoolSum@
vaCentroid@
vaConvolve@
vaConvolveGRF_16x1@
vaConvolveGRF_16x4@
vaDilate@
vaErode@
vaMinMax@
vaMinMaxFilter@
vmeSendFBR@
vmeSendFBR2@
vmeSendIME@
vmeSendIME2@
vmeSendSIC@
vmeSendSIC2@
wavebarrier@
wait
mem_fence
pseudo_kill
spill
fill
Can't open 
             === Binary Compaction ===
 out of 
 instructions are compacted.
 instructions of 3 src (mad/pln) are compacted.
% instructions of this kernel are compacted.
xyzw
wait
mem_fence
pseudo_kill
spill
fill
INVALID opcode 
UNDEFINED_
test
bool
none
Illegal or unimplemented ISA opcode 
 at byte position 
SurfaceUsage
Target
SLMSize
Scope
FESPSize
be_fp
_AUTO_GENERATED_IF_LABEL_
__AUTO_GENERATED_ELSE_LABEL__
L_AUTO_k
L_AUTO_f
beforeRemoveRedundantLabels
afterRemoveRedundantLabels
beforeRemoveUnreachableBlocks
afterRemoveUnreachableBlocks
before_doCFGStructurizer
after_doCFGStructurizer
beforeProcessGoto
afterProcessGoto
LABEL__
LABEL__EMPTYBB__
LABEL__EMPTYBB
__AUTO_GENERATED_DUMMY_LAST_BB
__MERGED_FRET_EXIT_BLOCK_f
VCE_SAVE
%s.%03d.%s.dump
UnknownKernel
Preds: 
Succs: 
%s.%03d.%s.dot
digraph UnknownKernel
digraph 
// Setup
size = "80.0, 
page= "80.5, 110";
pagedir="TL";
 [shape=plaintext, label=<
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
<TR><TD ALIGN="CENTER">
</TD></TR>
<TR><TD>
    <TABLE BORDER="0" CELLBORDER="0" CELLSPACING="0">
black
<TR><TD ALIGN="LEFT"><FONT color="
</FONT></TD></TR>
    </TABLE>
</TD></TR>
    </TABLE>>];
 -> 
//.kernel 
//.platform 
//.stepping 
//.CISA version 
//.options 
//.instCount 
//.RA type
//.GRF count 
//.spill size 
//.spill GRF ref count 
//.spill flag store 
//.spill flag load 
//.kernel_reordering_info_start
//id
byte_offset
byte_size
kind
implicit_kind
//.arg_
//.kernel_reordering_info_end
.code
Failed to decode binary for asm output. Please report the issue and try disabling IGA disassembler for now.
// Text representation might not be correct
.end_code
.end_kernel
// Bank Conflict Statistics: 
// -- GOOD: 
// --  BAD: 
// --   OK: 
// File: 
// Line 
EL, 
OL, 
EH, 
OH, 
BAD,
GOOD,
GOOD
be_sp
vector
TRIVIAL_BC_RA
TRIVIAL_RA
LOCAL_ROUND_ROBIN_BC_RA
LOCAL_ROUND_ROBIN_RA
LOCAL_FIRST_FIT_BC_RA
LOCAL_FIRST_FIT_RA
HYBRID_BC_RA
HYBRID_RA
GRAPH_COLORING_RR_BC_RA
GRAPH_COLORING_FF_BC_RA
GRAPH_COLORING_RR_RA
GRAPH_COLORING_FF_RA
GRAPH_COLORING_SPILL_RR_BC_RA
GRAPH_COLORING_SPILL_FF_BC_RA
GRAPH_COLORING_SPILL_RR_RA
GRAPH_COLORING_SPILL_FF_RA
UNKNOWN_RA
%s_%s
Can't find src file
Align16
Switch
Atomic
NoDDChk
NoDDClr
NoMask
BreakPoint
AccWrEn
Compacted
NoCompact
NoSrcDepSet
NoPreempt
Serialize
illegal
movi
smov
csel
bfrev
bfi1
bfi2
cbit
math
rndu
rndd
rnde
rndz
mach
addc
subb
dp4a
madm
mulh
cmpn
jmpi
else
endif
while
break
cont
halt
call
return
goto
join
pseudo_fcall
pseudo_fret
pseudo_exit
pseudo_fc_call
pseudo_fc_ret
sad2
sada2
line
pseudo_mad
pseudo_sada2
wait
send
sendc
sends
sendsc
pseudo_store_be_fp
pseudo_restore_be_fp
pseudo_caller_save
pseudo_caller_restore
pseudo_callee_save
pseudo_callee_restore
lifetime
intrinsic
DebugInfoPlaceholder
pseudo_and
pseudo_or
pseudo_xor
pseudo_not
gateway
scaled untyped surface read
scaled A64 scatter read
scaled A64 untyped surface read
scaled byte scattered read
scaled untyped surface write
scaled A64 untyped surface write
scaled A64 scattered write
scaled byte scattede write
unrecognized DC2 message
render target write
render target read
unrecognized RT message
thread spawner
oword block read
unaligned oword block read
oword dual block read
dword scattered read
unrecognized DCC message
hword block read
hword aligned block read
byte scattered read
memory fence
hword block write
oword block write
hword aligned block write
oword dual block write
dword scattered write
byte scattered write
unrecognized DC0 message
scratch read
scratch write
dp_pi
transpose read
untyped surface read
untyped atomic operation
untyped atomic operation simd4x2
media block read
typed surface read
typed atomic operation
typed atomic operation simd4x2
untyped atomic float add
untyped surface write
media block write (non-iecp)
atomic counter operation
atomic counter operation simd4x2
typed surface write
a64 gathering read
a64 untyped surface read
a64 untyped atomic operation
a64 untyped atomic operation simd4x2
a64 block read
a64 block write
a64 untyped atomic float add
a64 untyped surface write
a64 scattered write
unrecognized DC1 message
.sat
 // 
, resLen=
, msgLen=
, extMsgLen=
, barrier
Align1, 
Align1}
null
acc0
acc1
dbg0
tdr0
unknown architecture reg
.noacc
.acc
//.declare 
Base=
r (spilled)
a (spilled)
f (spilled)
.declare 
Base=r
Base=a
 ElementSize=
 rf=
 size=
 type=
 alias=
 align=
 words
 (a0.
 (spilled -> 
 (spilled)
 Type=
 Input_Output
 Input
 Output
wany4h
all4h
any2h
any4h
any8h
any16h
any32h
all2h
all8h
all16h
all32h
anyv
allv
f0.0
bool
none
mem_fence
pseudo_kill
spill
fill
(abs)
-(abs)
be_fp
be_sp
StackCall
Spill candidate 
 intf:
(Liverange is local starting at line #
 and ending at line #
 --- spilled
--max RP: 
--avg # neighbors: 
--max # neighbors: 
round-robin
first-fit
 BCR
 graph coloring
--# variables: 
Caller save size: 
 bytes for fcall at cisa id 
Callee save size: 
 bytes
Total frame size: 
predicate
src0
src1
src2
Def not found for use 
) at CISA offset 
, src line 
=== Uses with reaching def - Flags ===
=== Uses with reaching def - Address ===
=== Uses with reaching def - GRF ===
(Use -nolocalra switch for accurate results of uses without reaching defs)
=== Variables used but never defined ===
 (General)
 (Address)
 (Flag)
--address RA iteration 
Address_RA
--flag RA iteration 
Flag_RA
--hybrid RA--
--skip hybrid RA due to high pressure: 
=== Register Allocation ===
Function: 
Kernel: 
--GRF RA iteration 
--split local send--
--enable failSafe RA
--rematerialize
--global send split
--# variables spilled: 
--current spill size: 
Spill_GRF
Local RA used 
 GRFs
: (Pred: 
 Succ: 
max pressure: 
 inst(s)
Dcl %s is Default32Bit but assignment is not Even aligned
's LRA assignment 
 doesnt interfere with 
Start verification for kernel: 
) is split
) and 
) are overlapping with incompatible emask but not masked as interfering
) use overlapping physical assignments but not marked as interfering
End verification for kenel: 
Default16Bit
Default32Bit
Default64Bit
NonDefault
Undetermined
-----
DefaultPredicateMask
(size = 
, spill cost = 
, degree = 
wait
mem_fence
pseudo_kill
spill
fill
--trivial RA
Allocated 100% GRF ranges without graph coloring.
--local RA--
--round-robin 
BCR 
--first-fit 
Total GRF ranges: 
GRF ranges allocated by local RA: 
% allocated by local RA
Undoing local RA assignments
bool
none
bool
none
===== LVN =====
Number of instructions removed: 
insertCallReturnVar
callReturn
===== Bank conflicts =====
Found 
 conflicts (
 locals, 
 globals) in kernel: 
 // $
before.
after.
cleanMessageHeader
renameRegister
newLocalDefHoisting
newLocalCopyPropagation
sendFusion
cselPeepHoleOpt
optimizeLogicOperation
HWConformityChk
preRA_Schedule
regAlloc
removeLifetimeOps
countBankConflicts
removeRedundMov
removeEmptyBlocks
insertFallThroughJump
reassignBlockIDs
evalAddrExp
FoldAddrImmediate
chkRegBoundary
localSchedule
NoDD
HWWorkaround
insertInstLabels
insertHashMovs
insertDummyCompactInst
mergeScalarInst
lowerMadSequence
ifCvt
dumpPayload
normalizeRegion
checkBarrierUsage
createR0Copy
initializePayload
cleanupBindless
countGRFUsage
splitVariables
changeMoveType
reRAPostSchedule
accSubPostSchedule
reassociateConst
split4GRFVars
addFFIDProlog
loadThreadPayload
insertFenceBeforeEOT
insertScratchReadBeforeEOT
mapOrphans
_UIP
             === Local Definition Hoisting Optimization ===
Number of defs hoisted: 
             === Message Header Optimization ===
 is reduced from 
 to 
 instructions. 
% instructions of this kernel are removed.
%s_optreport.txt
             === Merge Scalar Optimization ===
Number of optimized bundles:
Number of instructions saved:
wait
mem_fence
pseudo_kill
spill
fill
C:\Intel\nodd.txt
bool
none
bool
none
Fix Inst Size for:
split into: 
's live in: 
's live in size: 
's live out: 
's live out size: 
PreRegAlloc
SP_GRF
TM_GRF
SP_MSG
FL_MSG
FL_GRF
FL_Send
tmp_shl_dst_bti
tmp_shl_y_offset
tmp_shl
bool
none
%s.asm
Fail to open 
SpillMemOffset
AsmName
ArgSize
RetValSize
perThreadInputSize
Extern
Callable
Caller
Composable
Entry
Input
Input_Output
NoWidening
Wrong input variable is used
ONLY ADDC AND SUBB are supported by this API
Destination for Arithmetic Instruction is NULL
BuiltinR0
BuiltinA0
BuiltinA0Dot2
hw_tid
samplerHeader
Number of parameters does not match
LINE: 
FUNCTION: 
CHECK_NUM_OPNDS
NEGABS
thread_x
thread_y
local_id_x
local_id_y
group_id_x
group_id_y
group_id_z
group_count_x
group_count_y
retval
hw_id
color
global_data_base
bitset test argument out of range
before.remat
after.remat
Skip block with instructions 
Skip block with rp 
Before scheduling, 
After scheduling for presssure, 
After scheduling for latency, 
[---] 
the max pressure is 
Max pressure instructions are: 
schedule reverted due to mischeduling.
schedule not committed due to no change.
schedule committed for latency.
the pressure is increased to 
schedule committed with reduced pressure.
the reduced pressure is 
schedule reverted, 
%s.bb%d.schedule
 ... 
+++++++++++ 
 empty cycles 
 +++++++++++
nodes
 Prio:
 Earl:
 Occu:
%s.bb%d.dag.dot
digraph DAG {
#CCCCCC
#FFEE99
#FFFFFF
[label="
, style="filled", fillcolor="
%d->%d
orange
grey
,color="
%s.bb%d.nodes
,type="
%s.%s.dot
size = "80, 100";
// Nodes
[shape=record, label="{ID : 
 PRIORITY : 
 ETIME : 
Label: 
} "];
// Edges
Number of operands mismatch between CISA instruction description and value passed in.
ONE OF THE OPERANDS IS NULL!
temp.isa
Could not open %s
Cannot open file %s
isaasmListFile.txt
.visaasm
.errors.txt
 errors in vISA files.
Please see error report written to the file 
Found a total of 
T252
T255
word
dword
qword
oword
2GRF
byte
(abs)
(-abs)
reserved0
line
mulh
rndd
rndu
rnde
rndz
sad2
rsqrt
reserved1C
reserved1D
reserved1E
cbit
addr_add
setp
movs
func
label
call
oword_ld
oword_st
media_ld
media_st
gather
scatter
reserved3b
oword_ld_unaligned
reserved3d
reserved3e
reserved3f
sample
sample_unorm
load
fminmax
bfrev
addc
subb
gather4_typed
scatter4_typed
va_skl_plus
ifcall
faddr
file
reserved53
vme_ime
vme_sic
vme_fbr
vme_idm
reserved58
barrier
sampler_cache_flush
fence
raw_send
reserved5E
yield
reserved60
reserved61
reserved62
reserved63
reserved64
reserved65
reserved66
fcall
fret
switchjmp
sad2add
plane
goto
sample_3d
load_3d
gather4_3d
info_3d
rt_write_3d
urb_write_3d
typed_atomic
gather4_scaled
scatter4_scaled
reserved76
reserved77
gather_scaled
scatter_scaled
raw_sends
lifetime
sbarrier
dword_atomic
sqrtm
divm
dp4a
RESERVED_0
reserved_1c
reserved_1d
reserved_1e
reserved_3B
reserved_3D
reserved_3E
reserved_3F
reserved_53
reserved_58
samplr_cache_flush
reserved_5e
reserved_60
reserved_61
reserved_62
reserved_63
reserved_64
reserved_65
reserved_66
3d_sample
3d_load
3d_gather4
3d_info
3d_rt_write
3d_urb_write
reserved_76
reserved_77
va_convolve_2d
va_minmax
va_minmaxfilter
va_erode
va_dilate
va_boolcentroid
va_centroid
va_convolve_1d_v
va_convolve_1d_h
va_convolve_1pixel
va_floodfill
va_lbpcreation
va_lbpcorrelation
va_correlationsearch
va_hdc_convolve_2d
va_hdc_minmaxfilter
va_hdc_erode
va_hdc_dilate
va_hdc_lbpcorrelation
va_hdc_lbpcreation
va_hdc_convolve_1d_h
va_hdc_convolve_1d_v
va_hdc_convolve_1pixel
svm_block_ld
svm_block_st
svm_gather
svm_scatter
svm_atomic
svm_gather4scaled
svm_scatter4scaled
kernel_
attr 
"cm"
"3d"
"cs"
.decl P
v_type=P 
num_elts=
.decl A
v_type=A 
.decl S
 v_type=S
 num_elts=
 v_name=
.decl T
 v_type=T
.parameter 
.input 
 offset=
.decl 
 v_type=G
 alias=<
.version 
.global_function 
.kernel 
.funcdecl 
/// VISA Predefined Variables
// .decl V
// .decl T
.kernel_attr Target=
Illegal or unimplemented CISA instruction (opcode, type): (
 /// $
_global
.signal
.wait
.any
.all
svm_
block_
.unaligned
atomic
gather4scaled
scatter4scaled
.function 
FILE 
LOC 
raw_sendc 
raw_send 
raw_sendsc.
raw_sends.
eot.
start 
end 
pixel_null_mask.
cps.
divS.
illegal
31x31
15x15
 4x16
 1x16
 1x1
8_connect
4_connect
 31x31
 15x15
.mod
<RTI>
<ST>
<LRTW>
<CPS>
<PS>
Kernel Header / Declare Errors: 
Instruction / Operand / Region Errors: 
label%d's name index(%d) is not valid
S%d's name index(%d) is not valid
S%d's number of elements(%d) is not vaild
T%d's name index(%d) is not valid
T%d's number of elements(%d) is not valid
Input V%d is out of bound [%d, %d)
Input V%d = [%d, %d) intersects with V%d = [%d, %d)
Explicit input %d must not follow an implicit input %d
Input %d points to an invalid variable(%d)
Input %d's size(%d) does not agree with its variable (V%d)'s
Input%d points to an invalid sampler index(%d)
Input%d points to an invalid/predefined surface index(%d)
Input%d's size(%d) does not agree with its surface's
Input%d has invalid operand class(%d)
Invalid opcode, value: 
vISA instruction not supported on this platform
CISA instruction uses an illegal execution size.
CISA instruction uses an illegal predicate value.
 Error in CISA variable decl: 
V%d's name index(%d) is not valid: %s
V%d's type(%s) is not legal: %s
V%d's number of elements(%d) is out of range: %s
V%d's alias offset must be zero when it is not aliased: %s
Circular alias detected, alias index: %d
Aliased variable aliases to an invalid alias index. Variable count: %d. invalid index: %d. %s
Variable decl's alias offset exceeds the bounds of the aliased variable decl allocation size: %s
V%d's variable alignment is not a valid alignment value: %s
V%d's alias index must point to a valid CISA variable index between 0 and %d. Currently points to invalid index V%d: %s
 Error in address variable decl: 
A%d's name index(%d) is not valid: %s
Max possible address registers are 16 on BDW+: %s
 Error in predicate variable decl: 
P%d's name index(%d) is not valid: %s
P%d's number of elements(%d) is not valid: %s
/-------------------------------------------!!!KERNEL HEADER ERRORS FOUND!!!-------------------------------------------\
/--------------------------------------------!!!INSTRUCTION ERROR FOUND!!!---------------------------------------------\
Error in CISA routine with name: 
Error Message: 
Diagnostics: 
 Instruction variables' decls: 
 Violating Instruction: 
\----------------------------------------------------------------------------------------------------------------------/
ADDRESSOF Operand decl... are those even allowed>
Immediate operand: 
Operand type: 
 unable to print.
unknown operand?
                               
More than 1 kernel attribute defined SLMSize
Operand modifier for non-general and non-indirect operands must be MODIFIER_NONE.
Only arithmetic modifiers should be used with arithmetic instruction general or indirect operands.
Only logical modifiers should be used with logical instruction general or indirect operands.
Boolean types for immediate (constant literals) operands are disallowed.
Variable V%d is not declaired in CISA symtab.
Constant Immediate operands are not allowed to be used as destination operands.
Not allowed to write to a read only variable
CISA region has width of 0
Invalid execution size
Horizontal Stride should not be 0 for a destination operand.
There's no reason, to set the vertical stride or width of a destination operand. They are ignored.
Horizontal Stride should not be REGION_NULL
Legal CISA region horizontal stride parameter values: {0, 1, 2, 4}.
Legal CISA region width parameter values: {1, 2, 4, 8, 16}.
Execution size must be greater than width.
Legal CISA region vertical stride parameter values: {0, 1, 2, 4, 8, 16, 32}.
CISA operand region access out of 2 GRF boundary (within %d bytes): %d
CISA operand accesses more than 2 GRF due to mis-alignment: start byte offset = %d, end byte offset = %d
WARNING: CISA region and offset cause an out of bounds byte access: 
An access should not exceed the declared allocation size: 
  The access fails the following check to determine correct bounds (see CISA manual section 5.1 Region-based Addressing):
  (row_offset * GRF_SIZE + col_offset) + (((i * v_stride) + (j * h_stride)) * type_size) <= type_size * num_elements:
) + (((
) + (
)) * 
) <= 
Violating Instruction: 
For 3 source operand instructions, the destination operand's horizontal stride must be 1.
LRP instruction only supports sources and destination of type F.
For 3 source operand instructions, region must be either scalar or contiguous
Aliased variable aliases to an invalid alias index. Variable count: %d. invalid index: %d
Raw operand should be GRF-aligned: Raw offset is %d
A CISA raw operand's offset field must be within the allocated operand size. Raw offset is %d, allocated number of elements is %d
Execution size for a flag copy mov instruction should be 1, as it is a scalar copy.
dst operand type for a flag copy mov instruction should be UD/UW/UB.
dst operand type for a flag copy mov instruction should be greater than or equal to the size of the src0 operand's type size.
saturation is not allowed for dst operands of a flag copy mov instruction
predication is not allowed for dst operands of a flag copy mov instruction
Destination operand of CISA MOVS instruction only supports general and indirect operands.
Source0 operand of CISA MOVS instruction only supports general, indirect, and immediate operands.
Destination operand of CISA SETP instruction only supports predicate operands.
Source0 operand of CISA SETP instruction only supports general, indirect, and immediate operands.
FMINMAX opext must be either 0x0 or 0x1 (min or max).
Destination operand of CISA SEL instruction only supports general and indirect operands.
Source0 operand of CISA SEL instruction only supports general, indirect, and immediate operands.
Source1 operand of CISA SEL instruction only supports general, indirect, and immediate operands.
Illegal Move Instruction Opcode: %d, %s.
Illegal Synchronization Instruction Opcode: %d, %s.
Illegal Scalar Control Flow Instruction Opcode: %d, %s.
CISA ISA_VME_IME instruction uses illegal stream mode.
CISA ISA_VME_IME instruction uses illegal search ctrl.
CISA ISA_VME_IME uses undeclared surface.
CISA ISA_VME_SIC uses undeclared surface.
CISA ISA_VME_FBR uses undeclared surface.
FBRMbMode operand of CISA VME_FBR instrution should be either a general, indirect, or immediate operand.
FBRSubMbShape operand of CISA VME_FBR instrution should be either a general, indirect, or immediate operand.
FBRSubPredMode operand of CISA VME_FBR instrution should be either a general, indirect, or immediate operand.
Number of message source GRFs must be between 1 and 15
Number of message destination GRFs must be between 0 and 16
desc operand of CISA RAW_SEND instrution should be either a general, indirect, or immediate operand.
Number of source0 GRFs must be between 1 and 32
Number of source1 GRFs must be between 1 and 32
Number of message destination GRFs must be between 0 and 32
Valid range for num_out parameter of URB write is [1,8]
Valid range for global_offset parameter of URB write is [0,2047]
Only execution size of 8 is supported for URB write
Invalid encoding for register file
Illegal Miscellaneous Flow Instruction Opcode: %d, %s.
Destination of CISA arithmetic instruction should be general or indirect operand.
Illegal destination modifier for CISA arithmetic instruction.
%s does not support saturation
%s does not support saturation on integer types.
Only mul/add/mad/div/inv/sqrtm/sqrt/divm are allowed to use double precision floating point operands.
%s only supports single and half float type
%s only supports single float type
%s only supports integer and single precision float types
%s only supports integer type
lzd only supports UD type
%s only support D/UD dst type
sad2/sad2add only supports W/UW dst type.
%s only supports single UD type
%s has illegal dst type
unsupported source modifier for arithmetic instruction
source in arithmetic instruction must be general, indirect, or immediate
Arithmetic instructions that use single or double precision or half float types must use the same type for all of their operannds: dst(%s) and src%d(%s).
immediate src%d has %d type, and it must have integer type
sad2/sad2add only supports B/UB types for src0 and src1; W/UW for src2 (sad2add). src%d has invalid type.
mul/div does not support Q/UQ types for src%d
ieee div does not support types for src%d, other than F/DF
ieee sqrt does not support types for src%d, other than F/DF
%s src0 and src1 only supports single UD type
lrp only supports general/immediate operands
Common ISA Logic instrutions are not allowed to have address operands.
Operand type of logic operantion for predicate operands should all be BOOL (ie if one operand is BOOL they all have to be BOOL).
ror/rol does not support i8/i64 types
fbl/fbh/cbit does not support Q/UQ type.
Predicate can not be used in logic operantion for predicate operands.
All operands of logic instructions must be of integral type! opnd %d has float type %d
All operands of logic instructions must be of integral type! opnd %d has unknow type %d
CISA compare instruction destination only supports a predicate operand.
CISA compare instruction sources do not support address or predicate operands.
CISA address instruction destination only supports an address operand.
CISA ADDR_ADD instruction sources do not support predicate operands.
Can not take the address of a pre-defined variable
Can not take the address of a pre-defined surface
Data type of the second source of ADDR_ADD should be WORD or BYTE.
CISA SAMPLER ISA_SAMPLE_UNORM instruction only accepts non-zero channel masks.
CISA SAMPLER ISA_SAMPLE_UNORM instruction uses undeclared sampler.
Surface T0 (the SLM surface) is not allowed for the SAMPLER instruction ISA_SAMPLE_UNORM.
CISA SAMPLER instruction ISA_SAMPLE_UNORM uses undefined surface.
u_offset operand of CISA SAMPLER ISA_SAMPLE_UNORM instrution should be either a general, indirect, or immediate operand.
v_offset operand of CISA SAMPLER ISA_SAMPLE_UNORM instrution should be either a general, indirect, or immediate operand.
u_delta operand of CISA SAMPLER ISA_SAMPLE_UNORM instrution should be either a general, indirect, or immediate operand.
v_delta operand of CISA SAMPLER ISA_SAMPLE_UNORM instrution should be either a general, indirect, or immediate operand.
CISA SAMPLER SAMPLE/LOAD instruction uses undeclared sampler.
Surface T0 (the SLM surface) is not allowed for the SAMPLER instruction ISA_SAMPLE/ISA_LOAD.
CISA SAMPLER instruction ISA_SAMPLE/ISA_LOAD uses undefined surface.
CISA SAMPLER ISA_SAMPLE/ISA_LOAD instruction only accepts non-zero channel masks.
Illegal SIMD mode used in ISA_SAMPLE/ISA_LOAD inst.
Pixel Null Mask Enable only valid for SKL+
CPS LOD Compensation Enable must be disabled unless SIMD mode is simd8* or simd16*
CPS LOD Compensation Enable is only supported for sample, sample_b, sample_b_c, sample_c and LOD
CISA SAMPLER AVS instruction only accepts non-zero channel masks.
CISA VA MINMAXFILTER instruction uses undeclared sampler.
Surface T0 (the SLM surface) is not allowed for the SAMPLER AVS instruction.
CISA VA instruction MINMAX uses undefined surface.
u_offset operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
v_offset operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
u_delta operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
v_delta operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
u2d operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
groupid operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
verticalBlockNumber operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
cntrl for CISA SAMPLER AVS intruction should be a value 0-3 (8/16bit full/chrominance down sample).
v2d operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
execMode for CISA SAMPLER AVS intruction should be a value 0-3 (16x4, 8x4, 16x8, or 4x4).
iefbypass operand of CISA SAMPLER AVS instruction should be either a general, indirect, or immediate operand.
Surface T0 (the SLM surface) is not allowed for VA instructions.
u_offset operand of CISA MINMAX instrution should be either a general, indirect, or immediate operand.
v_offset operand of CISA MINMAX instrution should be either a general, indirect, or immediate operand.
CISA VA instruction MINMAXFILTER uses undefined surface.
u_offset operand of CISA MINMAXFILTER instrution should be either a general, indirect, or immediate operand.
v_offset operand of CISA MINMAXFILTER instrution should be either a general, indirect, or immediate operand.
CISA VA VA CENTROID/BOOLCENTROID instruction MINMAX uses undefined surface.
u_offset operand of CISA VA CENTROID/BOOLCENTROID instrution should be either a general, indirect, or immediate operand.
v_offset operand of CISA VA CENTROID/BOOLCENTROID instrution should be either a general, indirect, or immediate operand.
v_size operand of CISA VA CENTROID/BOOLCENTROID instrution should be either a general, indirect, or immediate operand.
h_size operand of CISA VA CENTROID/BOOLCENTROID instrution should be either a general, indirect, or immediate operand.
CISA VA CONVOLVE/ERODE/DILATE instruction uses undeclared sampler.
CISA VA CONVOLVE/ERODE/DILATE instruction MINMAX uses undefined surface.
u_offset operand of CISA CONVOLVE/ERODE/DILATE instrution should be either a general, indirect, or immediate operand.
v_offset operand of CISA CONVOLVE/ERODE/DILATE instrution should be either a general, indirect, or immediate operand.
Invalid VA sub-opcode: %d.
Surface T0 (the SLM surface) is not allowed for VA++ instructions.
CISA VA++ instruction LBP Correlation uses undefined surface.
u_offset operand of CISA LBP Correlation instrution should be either a general, indirect, or immediate operand.
v_offset operand of CISA LBP Correlation instrution should be either a general, indirect, or immediate operand.
Disparity operand of CISA LBP Correlation instrution should be either a general, indirect, or immediate operand.
CISA VA++ instruction uses undeclared sampler.
CISA VA++ instruction uses undefined surface.
u_offset operand of CISA VA++ instrution should be either a general, indirect, or immediate operand.
v_offset operand of CISA VA++ instrution should be either a general, indirect, or immediate operand.
Invalid mode field for CISA VA++ instruction. Only 4x16, 1x16, and 1x1 (in the case of 1 pixel convolve) are supported.
CISA LBP Creation VA++ instruction uses undefined surface.
u_offset operand of CISA LBP Creation VA++ instrution should be either a general, indirect, or immediate operand.
v_offset operand of CISA LBP Creation VA++ instrution should be either a general, indirect, or immediate operand.
Invalid mode field for CISA LBP Creation VA++ instruction. Only 5x5, 3x3, or both modes are supported.
Pixel direction v-mask left of CISA VA++ FloodFill instruction only supports general, indirect, and immediate operands.
Pixel direction v-mask right of CISA VA++ FloodFill instruction only supports general, indirect, and immediate operands.
loop_count of Common ISA sample instrution is invalid type.
u_offset of Common ISA Meida LD/ST instrution should not be address or predicate operand.
v_offset of Common ISA Meida LD/ST instrution should not be address or predicate operand.
CISA VA++ instruction Correlation search operand verticalOrigin can only be of operand class general, indirect, or immediate.
CISA VA++ instruction Correlation search operand horizontalOrigin can only be of operand class general, indirect, or immediate.
CISA VA++ instruction Correlation search operand xDirectionSize can only be of operand class general, indirect, or immediate.
CISA VA++ instruction Correlation search operand yDirectionSize can only be of operand class general, indirect, or immediate.
CISA VA++ instruction Correlation search operand xDirectionSearchSize can only be of operand class general, indirect, or immediate.
CISA VA++ instruction Correlation search operand yDirectionSearchSize can only be of operand class general, indirect, or immediate.
u_offset of Common ISA HDC INSTRUCTION should not be address or predicate operand.
v_offset of Common ISA HDC instruction should not be address or predicate operand.
CISA VA++ instruction uses invalid output pixel size.
CISA VA++ instruction uses invalid mode.
disparity of Common ISA HDC LBPCORRELATION should not be address or predicate operand.
CISA VA++ instruction uses undefined destination surface.
x_offset of Common ISA HDC instruction should not be address or predicate operand.
y_offset of Common ISA HDC instruction should not be address or predicate operand.
Invalid VA++ sub-opcode: %d.
Illegal Sampler Instruction Opcode: %d, %s.
Illegal SIMD CF Instruction Opcode: %d, %s.
MEDIA_LD modifier must be 0-5 not %d
MEDIA_ST modifier must be 0-3 not %d
Surface T0 (the SLM surface) is not allowed for MEDIA_LD/MEDIA_ST
CISA dataport instruction uses an undeclared surface.
MEDIA_LD/MEDIA_ST plane must be in the range [0, 3]: %d
MEDIA_LD/MEDIA_ST block width must be in the range [1, 32]: %d
MEDIA_LD/MEDIA_ST block height must be in the range [1, 64]: %d
MEDIA_LD only supports objects that fit into a single dataport transaction where block width <= 64 bytes and size <= 256 bytes. Block width: %d. Block height: %d
MEDIA_ST only supports objects that fit into a single dataport transaction where block width <= 64 bytes and size <= 256 bytes. Block width: %d. Block height: %d
x_offset of Common ISA Meida LD/ST instrution should not be address or predicate operand.
y_offset of Common ISA Meida LD/ST instrution should not be address or predicate operand.
OWORD_LD*/OWORD_ST size must be in the range [0, 3] (ie, OWord block size must be 1/2/4/8. OWord block size: %d
Surface T0 (the SLM surface) is not allowed for OWORD_LD*/OWORD_ST
Offset of Common ISA OWORD LD/ST instrutions should not be address or predicate operands.
Incorrect element size for Gather/Scatter CISA inst.
global_offset of Common ISA gather/scatter instrution should not be address or predicate operand.
At least one channel must be enabled for TYPED GATEHR4/SCATTER4
Surface T0/T5 (the SLM surface) is not allowed for TYPED SCATTTER4/GATHER4
CISA dataport TYPED SCATTTER4/GATHER4 instruction uses an undeclared surface.
Invalid DWORD ATOMIC sub op.
src0 in ISA_DWORD_ATOMIC inst must be V0 for INC/DEC/PREDEC.
src1 in ISA_DWORD_ATOMIC inst must be V0 for non CMPXCHG operations.
Illegal dataport Instruction Opcode: %d, %s.
Raw Operand %s has incorrect type %s
EXPLICIT
LOCAL_SIZE
GROUP_COUNT
LOCAL_ID
PSEUDO_INPUT
nomod
modified
bottom
top_mod
bottom_mod
reserved
RGBA
0000
16-full
16-downsampled
8-full
8-downsampled
M1_NM
M2_NM
M3_NM
M4_NM
M5_NM
M6_NM
M7_NM
M8_NM
sample_b
sample_l
sample_c
sample_d
sample_b_c
sample_l_c
sample4
resinfo
sampleinfo
sample+killpix
sample4_c
sample4_po
sample4_po_c
sample_d_c
sample_lz
sample_c_lz
load_lz
load_2dms_w
load_mcs
convolve
minmax
minmaxfilter
erode
dilate
boolcentroid
centroid
CONV_1D_HORIZONTAL
CONV_1D_VERTICAL
CONV_1PIXEL
FLOOD_FILL
LBP_CREATION
LBP_CORRELATION
CORRELATION_SEARCH
HDC_CONVOLVE_2D
HDC_MIN_MAX_FILTER
HDC_ERODE
HDC_DILATE
HDC_LBP_CORRELATION
HDC_LBP_CREATION
HDC_CONVOLVE_1D_H
HDC_CONVOLVE_1D_V
HDC_CONVOLVE_1P
UNDEFINED
CM_Y16_FORMAT
CM_Y8_FORMAT
CM_5x5_mode
CM_3x3_mode
CM_BOTH_mode
CM_16_FULL
CM_16_DOWN_SAMPLE
CM_8_FULL
CM_8_DOWN_SAMPLE
CM_AVS_16x4
CM_AVS_INVALID
CM_AVS_16x8
CM_MMF_16x4
CM_MMF_INVALID
CM_MMF_16x1
CM_MMF_1x1
CM_MINMAX_ENABLE
CM_MAX_ENABLE
CM_MIN_ENABLE
CM_ED_64x4
CM_ED_32x4
CM_ED_64x1
CM_ED_32x1
CM_CONV_16x4
CM_CONV_INVALID
CM_CONV_16x1
CM_CONV_1x1
xchg
cmpxchg
minsint
maxsint
fcmpwr
ICLLP
gen11
gen11lp
none
USAGE: Unrecognized option "
unrecognized platform string: 
USAGE: GenX_IR <InputFilename.isa> {Option List}
Converts a CISA file into Gen binary or assembly
Options :
    -output
- Emit target assembly code to a file.
    -noschedule
- Turn off code scheduling.
    -nocompaction
- Turn off binary compaction.
    -dumpcommonisa
- Emit CISA assembly.
USAGE: GenX_IR <InputFilename.visaasm> {Option List}
Converting a CISA assembly file into CISA binary file
    -outputCisaBinaryName <CISABinaryName>
- name for the CISA binary file.
vISA_DumpPasses
vISA_DumpPassesLocation
vISA_DumpDot
vISA_DumpDotAll
VISA_FullIRVerify
vISA_dumpVISAOptions
vISA_dumpVISAOptionsAll
vISA_Debug
vISA_DebugConsoleDump
vISA_Gtpin
vISA_EmitLocation
vISA_dumpRPE
vISA_dumpLiveness
vISA_EnableAlways
vISA_EnableSendFusion
vISA_EnableWriteFusion
vISA_EnableAtomicFusion
vISA_LocalCopyProp
vISA_LocalFlagOpt
vISA_LocalMACopt
vISA_LocalCleanMessageHeader
vISA_LocalRenameRegister
vISA_LocalDefHoist
vISA_FoldAddrImmed
vISA_enableCSEL
vISA_OptReport
vISA_MergeScalar
vISA_EnableMACOpt
vISA_EnableDCE
vISA_DisableleHFOpt
vISA_enableUnsafeCP_DF
vISA_EnableStructurizer
vISA_StructurizeCF
vISA_EnableScalarJmp
vISA_enableCleanupBindless
vISA_EnableSplitVariables
vISA_ChangeMoveType
vISA_accSubstitution
vISA_doAccSubAfterSchedule
vISA_ifCvt
vISA_LVN
vISA_numGeneralAcc
vISA_reassociate
vISA_unsafeMath
vISA_split4GRFVar
vISA_noSrc1Byte
vISA_expandPlane
vISA_FImmToHFImm
vISA_cacheSamplerHeader
vISA_forceSamplerHeader
vISA_noncoherentStateless
vISA_enablePreemption
VISA_EnableBarrierInstCounterBits
vISA_forceFPMAD
vISA_DisableMixMode
vISA_DisableHFMath
vISA_ForceMixMode
vISA_UseSends
vISA_doAlign1Ternary
vISA_loadThreadPayload
vISA_foldEOTtoPrevSend
vISA_hasRNEandDenorm
vISA_forceNoFP64bRegioning
vISA_alignBindlessSampler
vISA_RoundRobin
vISA_PrintRegUsage
vISA_IPA
vISA_LocalRA
vISA_LocalRARoundRobin
vISA_ForceSpills
vISA_NoIndirectForceSpills
vISA_AbortOnSpill
vISA_VerifyRA
vISA_LocalBankConflictReduction
vISA_FailSafeRA
vISA_FlagSpillCodeCleanup
vISA_GRFSpillCodeCleanup
vISA_SpillSpaceCompression
vISA_ConsiderLoopInfoInRA
vISA_ReserveR0
vISA_SpiltLLR
vISA_EnableGlobalScopeAnalysis
vISA_LocalDeclareSplitInGlobalRA
vISA_DisableSpillCoalescing
vISA_GlobalSendVarSplit
vISA_NoRemat
vISA_ForceRemat
vISA_SpillMemOffset
vISA_ReservedGRFNum
vISA_TotalGRFNum
vISA_GRFNumToUse
vISA_RATrace
vISA_FastSpill
vISA_AbortOnSpillThreshold
vISA_enableBCR
vISA_hierarchicaIPA
vISA_VerifyAugmentation
vISA_LocalScheduling
vISA_preRA_Schedule
vISA_preRA_ScheduleForce
vISA_preRA_ScheduleCtrl
vISA_preRA_ScheduleRPThreshold
vISA_DumpSchedule
vISA_DumpDagDot
vISA_EnableNoDD
vISA_DebugNoDD
vISA_NoDDLookBack
vISA_EnableNoSrcDep
vISA_EnableNoSrcDepScen1
vISA_EnableNoSrcDepScen2
vISA_DumpNoSrcDep
vISA_stopNoSrcDepSetAt
vISA_FuseTypedWrites
vISA_ReorderDPSendToDifferentBti
vISA_WAWSubregHazardAvoidance
vISA_useMultiThreadedLatencies
vISA_SchedulerWindowSize
vISA_UnifiedSendCycle
vISA_HWThreadNumberPerEU
vISA_NoAtomicSend
vISA_ReadSuppressionDepth
vISA_Compaction
vISA_BXMLEncoder
vISA_IGAEncoder
vISA_outputToFile
vISA_SymbolReg
vISA_PrintASMCount
vISA_GenerateBinary
vISA_GeneratevISABInary
vISA_IsaAssembly
vISA_GenerateISAASM
vISA_DumpIsaVarNames
vISA_GenIsaAsmList
vISA_UniqueLabels
vISA_IsaasmNamesFileUsed
vISA_DumpvISA
vISA_StripComments
vISA_dumpNewSyntax
vISA_NumGenBinariesWillBePatched
vISA_ISAASMNamesFile
vISA_GetvISABinaryName
vISA_OutputvISABinaryName
vISA_LabelStr
VISA_AsmFileName
vISA_DecodeDbg
vISA_encoderFile
vISA_CISAbinary
vISA_PlatformIsSet
vISA_NoVerifyvISA
vISA_InitPayload
vISA_isParseMode
vISA_ReRAPostSchedule
vISA_GetFreeGRFInfo
vISA_clearScratchWritesBeforeEOT
vISA_clearHDCWritesBeforeEOT
vISA_setA0toTdrForSendc
vISA_addFFIDProlog
vISA_setFFID
vISA_clearAccBeforeEOT
vISA_replaceIndirectCallWithJmpi
vISA_GenerateDebugInfo
vISA_setStartBreakPoint
vISA_InsertHashMovs
vISA_InsertDummyCompactInst
VISA_AsmFileNameUser
vISA_HashVal
vISA_HashVal1
vISA_easyIsaasm
vISA_AddKernelID
vISA_dumpPayload
vISA_dumpToCurrentDir
vISA_dumpTimer
vISA_DumpCompilerStats
vISA_3DOption
vISA_Stepping
vISA_Platform
-dumpPassesAll
-dumpPassesLocation
-dot
-dotAll
-fullIRVerify
-dumpVisaOptions
-dumpVisaOptionsAll
-dumpDebugConsoleOutput
-gtpin
-emitLocation
-dumpRPE
-dumpLiveness
-enableSendFusion
-enableWriteFusion
-enableAtomicFusion
-nocopyprop
-noflagopt
-nomacopt
-nomsgheaderopt
-noregrenaming
-nodefhoist
-nofoldaddrimmed
-disablecsel
-optreport
-nomergescalar
-nomac
-dce
-disableHFOpt
-enableUnsafeCP_DF
-disableStructurizer
-noStructurize
-noScalarJmp
-noSplitVariables
-ALTMode
-noAccSub
-accSubPostSchedule
-noifcvt
-nolvn
-numGeneralAcc
-noreassoc
-unsafeMath
-no4GRFSplit
-nosrc1byte
-expandPlane
-noSamplerHeaderCache
-forceSamplerHeader
-ncstateless
-enablePreemption
-enableBarrierInstCounterBits
-disableMixMode
-disableHFMath
-forceMixMode
-nosends
-noalign1ternary
-noLoadPayload
-foldEOT
-hasRNEandDenorm
-noFP64bRegion
-alignBS
-noroundrobin
-printregusage
-noipa
-nolocalra
-nolocalraroundrobin
-forcespills
-noindirectforcespills
-abortonspill
-verifyra
-nolocalBCR
-nofailsafera
-disableFlagSpillClean
-noloopra
-reserveR0
-nosplitllr
-enableGlobalScopeAnalysis
-nospillcleanup
-globalSendVarSplit
-noremat
-forceremat
-spilloffset
-reservedGRFNum
-TotalGRFNum
-GRFNumToUse
-ratrace
-abortonspillthreshold
-enableBCR
-oldIPA
-verifyaugmentation
-noschedule
-nopresched
-presched
-presched-ctrl
-presched-rp
-dumpSchedule
-dumpDagDot
-enable-noDD
-debug-noDD
-noDD-lookback
-enable-noSrcDep
-disable-noSrcDep-scen1
-disable-noSrcDep-scen2
-dump-noSrcDep
-stop-noSrcDep-at
-nofuse-typedWrites
-nodpsendreorder
-noWAWSubregHazardAvoidance
-dontUseMultiThreadedLatencies
-schedulerwindow
-unifiedSendCycle
-HWThreadNumberPerEU
-noAtomicSend
-readSuppressionDepth
-nocompaction
-nobxmlencoder
-IGAEncoder
-output
-symbolreg
-printasmcount
-binary
-dumpcommonisa
-dumpisavarnames
-genIsaasmList
-stripcomments
-disableIGASyntax
-numGenBinariesWillBePatched
-isaasmNamesOutputFile
-outputCisaBinaryName
-uniqueLabels
-asmNameUser
-decodedbg
-encoderStatisticsFile
-CISAbinary
-noverifyCISA
-initializePayload
-rerapostschedule
-getfreegrfinfo
-setA0toTdrForSendc
-noFFIDProlog
-setFFID
-clearAccBeforeEOT
-replaceIndirectCallWithJmpi
-generateDebugInfo
-setstartbp
-insertDummyCompactInst
-hashmovs
-hashmovs1
-easyisaasm
-addKernelID
-dumpPayload
-dumpToCurrentDir
-timestats
-compilerStats
-stepping
-platform
USAGE: Directory to dump VISA passes into
USAGE: -numGeneralAcc <accNum>
USAGE: -spilloffset <offset>
USAGE: -reservedGRFNum <regNum>
USAGE: -TotalGRFNum <regNum>
USAGE: -GRFNumToUse <regNum>
USAGE: -abortonspillthreshold <threshold>
USAGE: -presched-ctrl <ctrl>
USAGE: -presched-rp <threshold>
USAGE: -noDD-lookback <NUM>
Usage: -stop-noSrcDep-at <NUMBER>
USAGE: -schedulerwindow <window-size>
USAGE: -unifiedSendCycle <cycle>
USAGE: -HWThreadNumberPerEU <num>
USAGE: missing number of gen binaries that will be patched.
USAGE: File Name with isaasm paths.
Label String is not provided for the -uniqueLabels option.
USAGE: -asmNameUser <FILE>
USAGE: -decodedbg <dbg filename>
USAGE: -encoderStatisticsFile <reloc file>
encoderStatistics.csv
USAGE: File Name with isaasm paths. 
USAGE: -setFFID <ffid>
USAGE: -hashmovs hi32 lo32
USAGE: -hashmovs1 hi32 lo32
USAGE: missing stepping string. 
USAGE: missing platform string. 
UNDEFINED 
false
unordered_map::at: key not found
NULL
jit_time.txt
timers.
IR_Build
Optimizer
HW_Conformity
Misc_opts
Total_RA
Addr_Flag_RA
GRF_Local_RA
GRF_Hybrid_RA
GRF_Global_RA
  Interference
  Graph Coloring
preRA_Scheduling
Scheduling
Encode+Emit
Compaction
IGA_Encoding
VB_Append_Instruction
VB_Create_Var
VB_Create_Operand
VB_IR_Construction
liveness
Reg Pressure Estimate
Inliner for always_inline functions
always-inline
A No-Op Barrier Pass
enable-nonnull-arg-prop
Try to propagate nonnull argument attributes from callsites to caller functions.
disable-nounwind-inference
Stop inferring nounwind attribute during function-attrs pass
functionattrs
Deduce function attributes
..., 
Dead Global Elimination
globaldce
StringRef llvm::getTypeName() [DesiredTypeName = llvm::InnerAnalysisManagerProxy<FunctionAnalysisManager, Module>]
enable-coldcc-stress-test
Enable stress test of coldcc by adding calling conv to all internal functions.
coldcc-rel-freq
Maximum block frequency, expressed as a percentage of caller's entry frequency, for a call site to be considered cold for enablingcoldcc
globalopt
newgv
.init
notinit
isneg
isnull
malloc_cont
malloc_ret_null
free_it
next
Global Variable Optimizer
Interprocedural constant propagation
ipconstprop
Function Integration/Inlining
inline
disable-inlined-alloca-merging
inliner-function-import-stats
basic
basic statistics
verbose
printing of statistics for each inlined function
Enable inliner stats for imported functions
Cannot find option named '
NoDefinition
Callee
 will not be inlined into 
 because its definition is unavailable
NotInlined
AlwaysInline
Inlined
 inlined into 
 with cost=always
 with cost=
 (threshold=
NeverInline
 not inlined into 
 because it should never be inlined (cost=never)
TooCostly
 because too costly to inline (cost=
, threshold=
IncreaseCostInOtherContexts
Not inlining. Cost of inlining 
 increases the cost of inlining 
 in other contexts
parse
Parse IR
irparse
LLVM IR Parsing
bitcode-mdindex-threshold
Number of metadatas above which we emit an index to enable lazy-loading
write-relbf-to-summary
Write relative block frequency to function summary 
Invalid encoding
Unexpected anonymous function when writing summary
Write Bitcode
write-bitcode
Bitcode Writer
Default
MetaData
Map Name: 
Size: 
Value: 
Value: [null]
 Uses(
 [null]
Metadata: slot = 
Metadata: function = 
constant bigger than 64 bits detected!
constant bigger than 128 bits detected!
end of file in COMDAT variable name
Null bytes are not allowed in names
end of file in string constant
invalid value number (too large)!
end of file in global variable name
bitwidth for integer type out of range!
declare
available_externally
unnamed_addr
local_unnamed_addr
zeroinitializer
undef
unwind
unordered
monotonic
acquire
release
acq_rel
seq_cst
alias
alignstack
fastcc
coldcc
x86_stdcallcc
x86_fastcallcc
x86_thiscallcc
x86_vectorcallcc
arm_apcscc
arm_aapcscc
arm_aapcs_vfpcc
msp430_intrcc
ptx_kernel
ptx_device
spir_kernel
spir_func
intel_ocl_bicc
x86_64_sysvcc
win64cc
x86_regcallcc
webkit_jscc
swiftcc
anyregcc
preserve_mostcc
preserve_allcc
ghccc
x86_intrcc
hhvmcc
hhvm_ccc
cxx_fast_tlscc
amdgpu_vs
amdgpu_ls
amdgpu_hs
amdgpu_es
amdgpu_gs
amdgpu_ps
amdgpu_cs
amdgpu_kernel
attributes
builtin
byval
inalloca
cold
convergent
dereferenceable
dereferenceable_or_null
inaccessiblememonly
inaccessiblemem_or_argmemonly
inlinehint
inreg
jumptable
minsize
naked
noalias
nobuiltin
nocapture
noduplicate
noimplicitfloat
noinline
norecurse
nonlazybind
nonnull
noredzone
noreturn
nocf_check
optforfuzzing
optnone
optsize
readnone
readonly
returned
returns_twice
signext
speculatable
sret
sspreq
sspstrong
strictfp
safestack
shadowcallstack
sanitize_address
sanitize_hwaddress
sanitize_thread
sanitize_memory
swifterror
swiftself
uwtable
writeonly
zeroext
opaque
exactmatch
largest
noduplicates
samesize
umax
uselistorder
name
flags
function
critical
variable
typeTestAssumeVCalls
typeCheckedLoadVCalls
typeTestAssumeConstVCalls
typeCheckedLoadConstVCalls
unsat
byteArray
single
allOnes
indir
singleImpl
branchFunnel
uniformRetVal
uniqueRetVal
virtualConstProp
x86_fp80
fp128
ppc_fp128
x86_mmx
token
zext
switch
store
extractelement
Can't read textual IR with a Context that discards named Values
expected function name in blockaddress
use of undefined type '%
use of undefined type named '
use of undefined comdat '$
use of undefined value '@
use of undefined metadata '!
use of undefined summary '^
use of undefined type id summary '^
expected top-level entity
expected 'module asm'
unknown target property
expected '=' after target triple
expected '=' after target datalayout
expected '=' after source_filename
expected '=' after deplibs
expected ']' at end of list
expected '=' after name
expected 'type' after '='
non-struct types may not be recursive
expected 'type' after name
expected 'global' or 'constant'
variable expected to be numbered '%
expected '=' in global variable
expected '=' here
expected comdat keyword
expected comdat type
unknown selection kind
redefinition of comdat '$
Expected '!' here
Expected '{' here
expected end of metadata node
unexpected type in metadata definition
Metadata id is already used
Expected 'gv', 'module', or 'typeid' at the start of summary entry
expected ':' at start of summary entry
expected '(' at start of summary entry
found end of file while parsing summary entry
unexpected summary kind
invalid linkage type for alias
symbol with local linkage must have default visibility
expected comma after alias or ifunc's type
invalid aliasee
An alias or ifunc must have pointer type
explicit pointee type doesn't match operand's pointee type
explicit pointee type should be a function type
redefinition of global '@
forward reference and definition of alias have different types
invalid type for global variable
forward reference and definition of global have different types
expected global section string
unknown global variable property!
expected attribute group id
expected '{' here
expected end of attribute group
attribute group has no attributes
unterminated attribute group
cannot have an attribute group reference in an attribute group
invalid use of attribute on a function
invalid use of parameter-only attribute on a function
global variable reference must have pointer type
' defined with type '
expected string constant
expected integer
expected 32-bit integer (too large)
expected localdynamic, initialexec or localexec
expected ')' after thread local model
expected '(' in address space
expected ')' in address space
invalid use of function-only attribute
invalid use of parameter-only attribute
invalid use of attribute on return type
dso_location and DLL-StorageClass mismatch
expected metadata after comma
alignment is not a power of two
huge alignments are not supported yet
expected '('
expected ')'
dereferenceable bytes must be non-zero
expected metadata or 'align'
expected metadata or 'addrspace'
'allocsize' indices can't refer to the same parameter
Expected '(' in syncscope
Expected synchronization scope name
Expected ')' in syncscope
Expected ordering on atomic instruction
stack alignment is not a power of two
expected ',' as start of index list
expected index
expected '>' at end of packed struct
void type only allowed for function results
basic block pointers are invalid
pointers to void are invalid - use i8* instead
pointer to this type is invalid
pointers to void are invalid; use i8* instead
expected '*' in address space
expected '(' in call
expected ',' in argument list
unexpected ellipsis in argument list for 
non-musttail call
musttail call in non-varargs function
expected ')' at end of argument list
expected '...' at end of argument list for musttail call in varargs function
expected ',' in input list
expected '(' in operand bundle
operand bundle set must not be empty
argument can not have void type
invalid type for function argument
invalid function return type
argument name invalid in function type
argument attributes invalid in function type
redefinition of type
forward references to non-struct type
expected '>' in packed struct
invalid element type for struct
expected '}' at end of struct
expected number in address space
expected 'x' after element count
expected end of sequential type
zero element vector is illegal
size too large for vector
invalid vector element type
invalid array element type
use of undefined value '%
' is not a basic block
invalid use of a non-first-class type
instructions returning void cannot have a name
instruction expected to be numbered '%
instruction forward referenced with type '
multiple definition of local value named '
expected value token
expected end of struct constant
expected end of packed struct
expected end of constant
constant vector must not be empty
vector elements must have integer, pointer or floating point type
vector element #
 is not of type '
expected end of array constant
invalid array element type: 
array element #
expected string
expected comma in inline asm expression
expected constraint string
expected '(' in block address expression
expected comma in block address expression
expected ')' in block address expression
expected basic block name in blockaddress
cannot take blockaddress inside a declaration
referenced value is not a basic block
cannot take address of numeric label after the function is defined
expected '(' after constantexpr cast
expected 'to' in constantexpr cast
expected ')' at end of constantexpr cast
invalid cast opcode for cast from '
' to '
expected '(' in extractvalue constantexpr
expected ')' in extractvalue constantexpr
extractvalue operand must be aggregate type
invalid indices for extractvalue
expected '(' in insertvalue constantexpr
expected comma in insertvalue constantexpr
expected ')' in insertvalue constantexpr
insertvalue operand must be aggregate type
invalid indices for insertvalue
insertvalue operand and field disagree in type: '
' instead of '
expected '(' in compare constantexpr
expected comma in compare constantexpr
expected ')' in compare constantexpr
compare operands must have the same type
fcmp requires floating point operands
icmp requires pointer or integer operands
expected '(' in binary constantexpr
expected comma in binary constantexpr
expected ')' in binary constantexpr
operands of constexpr must have same type
nuw only applies to integer operations
nsw only applies to integer operations
constexpr requires integer operands
constexpr requires fp operands
expected '(' in logical constantexpr
expected comma in logical constantexpr
expected ')' in logical constantexpr
constexpr requires integer or integer vector operands
expected '(' in constantexpr
expected comma after getelementptr's type
expected ')' in constantexpr
base of getelementptr must be a pointer
getelementptr index must be an integer
getelementptr vector index has a wrong number of elements
base element of getelementptr must be sized
invalid getelementptr indices
inrange keyword may not appear on pointer operand
expected three operands to select
expected three operands to shufflevector
invalid operands to shufflevector
expected two operands to extractelement
invalid extractelement operands
expected three operands to insertelement
invalid insertelement operands
global values must be constants
expected comdat variable
expected ')' after comdat var
comdat cannot be unnamed
expected '!' here
expected metadata type
missing required field 'scope'
missing required field 'tag'
missing required field 'count'
missing required field 'name'
missing required field 'value'
unsigned enumerator with negative value
missing required field 'baseType'
missing required field 'types'
missing required field 'filename'
missing required field 'directory'
'checksumkind' and 'checksum' must be provided together
missing 'distinct', required for !DICompileUnit
missing required field 'language'
missing required field 'file'
missing 'distinct', required for !DISubprogram when 'isDefinition'
missing required field 'discriminator'
missing required field 'type'
missing required field 'line'
expected '(' here
invalid DWARF op '
expected unsigned integer
element too large, limit is 
expected ')' here
missing required field 'var'
missing required field 'expr'
invalid metadata-value-metadata roundtrip
expected metadata operand
functions are not values, refer to them as pointers
invalid use of function-local name
invalid type for inline asm constraint string
integer constant must have integer type
floating point constant invalid for type
floating point constant does not have type '
null must be a pointer type
invalid type for undef constant
invalid empty array initializer
invalid type for null constant
invalid type for none constant
constant expression type mismatch
initializer with struct type has wrong # elements
packed'ness of initializer and type don't match
element 
 of struct initializer doesn't match struct element type
expected a basic block
invalid linkage for function definition
invalid linkage for function declaration
invalid function linkage type
function expected to be numbered '%
expected function name
expected '(' in function argument list
'builtin' attribute not valid on function
functions with 'sret' argument must return void
invalid forward reference to function as global value!
invalid forward reference to function '
' with wrong type!
invalid redefinition of function '
redefinition of function '@
type of definition and forward reference of '@
' disagree
redefinition of argument '%
expected '{' in function body
function body requires at least one basic block
unable to create block named '
expected '=' after instruction id
expected '=' after instruction name
found end of file when expecting more instructions
expected instruction opcode
expected fcmp predicate (e.g. 'oeq')
expected icmp predicate (e.g. 'eq')
value doesn't match function result type '
branch condition must have 'i1' type
expected ',' after branch condition
expected ',' after true destination
expected ',' after switch condition
expected '[' with switch table
switch condition must have integer type
expected ',' after case value
duplicate case value in switch
case value is not a constant integer
expected ',' after indirectbr address
expected '[' with indirectbr
indirectbr address must have pointer type
expected ']' at end of block list
expected 'to' in invoke
expected 'unwind' in invoke
Invalid result type for LLVM function
too many arguments specified
argument is not of expected type '
not enough parameters specified for call
invoke instructions may not have an alignment
expected '[' in catchpad/cleanuppad
expected 'from' after cleanupret
expected 'unwind' in cleanupret
expected 'caller' in cleanupret
expected 'from' after catchret
expected 'to' in catchret
expected 'within' after catchswitch
expected scope value for catchswitch
expected '[' with catchswitch labels
expected ']' after catchswitch labels
expected 'unwind' after catchswitch scope
expected 'caller' in catchswitch
expected 'within' after catchpad
expected scope value for catchpad
expected 'within' after cleanuppad
expected scope value for cleanuppad
expected ',' in arithmetic operation
invalid operand type for instruction
expected ',' in logical operation
instruction requires integer or integer vector operands
expected ',' after compare value
icmp requires integer operands
expected 'to' after cast value
expected ',' after select condition
expected ',' after select value
expected ',' after vaarg operand
va_arg requires operand with first class type
expected ',' after extract value
expected ',' after insertelement value
expected ',' after shuffle mask
expected ',' after shuffle value
invalid shufflevector operands
expected '[' in phi value list
expected ']' in phi value list
phi node must have first class type
'catch' clause has an invalid type
'filter' clause has an invalid type
clause argument must be a constant
expected 'tail call', 'musttail call', or 'notail call'
fast-math-flags specified for call without floating-point scalar or vector return type
call instructions may not have an alignment
invalid type for alloca
element count must have integer type
expected comma after load's type
load operand must be a pointer to a first class type
atomic load must have explicit non-zero alignment
atomic load cannot use Release ordering
expected ',' after store operand
store operand must be a pointer
store operand must be a first class value
stored value and pointer type do not match
atomic store must have explicit non-zero alignment
atomic store cannot use Acquire ordering
expected ',' after cmpxchg address
expected ',' after cmpxchg cmp operand
cmpxchg cannot be unordered
cmpxchg failure argument shall be no stronger than the success argument
cmpxchg failure ordering cannot include release semantics
cmpxchg operand must be a pointer
compare value and pointer type do not match
new value and pointer type do not match
cmpxchg operand must be a first class value
expected binary operation in atomicrmw
expected ',' after atomicrmw address
atomicrmw cannot be unordered
atomicrmw operand must be a pointer
atomicrmw value and pointer type do not match
atomicrmw operand must be an integer
atomicrmw operand must be power-of-two byte-sized integer
fence cannot be unordered
fence cannot be monotonic
expected comma after insertvalue operand
value has no uses
value only has one use
wrong number of indexes, expected 
expected non-empty list of uselistorder indexes
expected '}' here
expected >= 2 uselistorder indexes
expected distinct uselistorder indexes in range [0, size)
expected uselistorder indexes to change the order
expected uselistorder directive
expected comma in uselistorder directive
expected comma in uselistorder_bb directive
expected function name in uselistorder_bb
invalid function forward reference in uselistorder_bb
invalid declaration in uselistorder_bb
invalid numeric label in uselistorder_bb
expected basic block name in uselistorder_bb
invalid basic block in uselistorder_bb
expected basic block in uselistorder_bb
expected ':' here
expected 'path' here
expected ',' here
expected 'hash' here
expected 'name' here
expected 'summary' here
expected 'typeTestRes' here
expected 'kind' here
unexpected TypeTestResolution kind
expected 'sizeM1BitWidth' here
expected ':'
expected optional TypeTestResolution field
expected 'wpdResolutions' here
expected 'offset' here
expected 'wpdRes' here
unexpected WholeProgramDevirtResolution kind
expected optional WholeProgramDevirtResolution field
expected 'byArg here
unexpected WholeProgramDevirtResolution::ByArg kind
expected optional whole program devirt field
expected 'args' here
expected name or guid tag
expected 'summaries' here
expected summary type
expected 'insts' here
expected optional function summary field
expected 'aliasee' here
expected ':' in funcFlags
expected '(' in funcFlags
expected function flag type
expected ')' in funcFlags
expected ':' in calls
expected '(' in calls
expected 'callee' in call
expected relbf
expected ')' in call
expected ')' in calls
invalid call edge hotness
expected ':' in refs
expected '(' in refs
expected ')' in refs
expected '(' in typeIdInfo
invalid typeIdInfo list type
expected ')' in typeIdInfo
expected 'guid' here
expected 'linkage' here
expected 'notEligibleToImport' here
expected 'live' here
expected 'dsoLocal' here
expected 'module' here
expected module ID
expected GV ID
expected type
expected field label here
column
scope
inlinedAt
invalid field '
field '
' cannot be specified more than once
value for '
' too large, limit is 
' cannot be null
header
operands
expected DWARF tag
invalid DWARF tag
' cannot be empty
count
lowerBound
expected signed integer
' too small, limit is 
value
isUnsigned
expected 'true' or 'false'
encoding
expected DWARF type attribute encoding
invalid DWARF type attribute encoding
baseType
extraData
dwarfAddressSpace
expected debug info flag
invalid debug info flag flag '
elements
runtimeLang
vtableHolder
templateParams
identifier
discriminator
expected DWARF language
invalid DWARF language
types
expected DWARF calling convention
invalid DWARF calling convention
filename
directory
checksumkind
checksum
source
invalid checksum kind
language
producer
isOptimized
runtimeVersion
splitDebugFilename
emissionKind
enums
retainedTypes
globals
imports
macros
dwoId
splitDebugInlining
debugInfoForProfiling
gnuPubnames
expected emission kind
invalid emission kind
linkageName
isLocal
isDefinition
scopeLine
containingType
virtuality
virtualIndex
thisAdjustment
unit
declaration
retainedNodes
thrownTypes
expected DWARF virtuality code
invalid DWARF virtuality code
exportSymbols
expected DWARF macinfo type
invalid DWARF macinfo type
configMacros
includePath
isysroot
expr
setter
getter
entity
print-summary-global-ids
Print the global id for each value when reading the module summary
Expected a single module
llvm.bitcode
Corrupted bitcode
Abbreviation starts with an Array or a Blob
Array element type can't be an Array or a Blob
Array op not second to last
Array element type has to be an encoding of a type
Fixed or VBR abbrev record with size > MaxChunkData
Abbrev record with no operands
Invalid abbrev number
abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._
import-full-type-definitions
Import full type definitions for ThinLTO.
disable-ondemand-mds-loading
Force disable the lazy-loading on-demand of metadata when loading bitcode for importing.
Corrupted Metadata block
Invalid metadata: fwd refs into function blocks
Invalid record: metadata strings layout
Invalid record: metadata strings with no strings
Invalid record: metadata strings corrupt offset
Invalid record: metadata strings bad length
Invalid record: metadata strings truncated chars
Invalid metadata attachment
Conflicting METADATA_KIND records
METADATA_NAME not followed by METADATA_NAMED_NODE
Invalid record: Unsupported version of DISubrange
Alignment value is too large
Can't lazyload MD
Type mismatch in constant table!
llvm.global_ctors
llvm.global_dtors
Linking globals named '
': can only link appending global with another appending global!
Appending variables with different element types!
Appending variables linked with different const'ness!
Appending variables with different alignment need to be linked!
Appending variables with different visibility need to be linked!
Appending variables with different unnamed_addr need to be linked!
Appending variables with different section name need to be linked!
Linking two modules of different data layouts: '
' is '
' whereas '
Linking two modules of different target triples: 
.text
.balign 2
.thumb
.text
.balign 4
.arm
linking module flags '
': IDs have conflicting override values
': IDs have conflicting behaviors
': IDs have conflicting values
': does not have the required value
Linking COMDATs named '
': invalid selection kinds!
': noduplicates has been violated!
': ExactMatch violated!
': SameSize violated!
': COMDAT key involves incomputable alias size.
': GlobalVariable required for data dependent selection!
': symbol multiply defined!
Allocation failed
DFSIn: 
 DFSOut: 
Abstract Scope
Children ...
live-debug-variables
Enable the live debug variables pass
Allocation failed
********** DEBUG VARIABLES **********
 ind
 Loc
 @[ 
use-segment-set-for-physregs
Use segment set for the computation of the live ranges of physregs.
********** MACHINEINSTRS **********
EMPTY
-phi
 weight:
Clean updater: 
Null updater.
 updater with gap = 
, last start = 
  Area 1:
  Spills:
  Area 2:
%08X
  Alive in blocks: 
  Killed by:
 No instructions.
    #
regalloc=... not currently supported with -O0
Live Variable Analysis
livevars
Can't print out MachineBasicBlock because parent MachineFunction
 is null
<ir-block badref>
%ir-block.
address-taken
landing-pad
align 
; predecessors: 
successors: 
0x%08x
%.2f%%
liveins: 
; Irreducible loop header weight: 
%bb.
%08X
view-machine-block-freq-propagation-dags
Pop up a window to show a dag displaying how machine block frequencies propagate through the CFG.
do not display graphs.
fraction
display a graph using the fractional block frequency representation.
integer
display a graph using the raw integer fractional block frequency representation.
display a graph using the real profile count if available.
view-block-layout-with-bfi
Pop up a window to show a dag displaying MBP layout and associated block frequencies of the CFG.
print-machine-bfi
Print the machine block frequency info.
static-likely-prob
branch probability threshold in percentageto be considered very likely
profile-likely-prob
branch probability threshold in percentage to be considered very likely when profile is available
verify-machine-dom-info
Verify machine dominator info (time consuming)
=============================--------------------------------
Inorder Dominator Tree: 
DFSNumbers invalid: 
 slow queries.
cl::location(x) specified more than once!
 <<exit node>>
Frame Objects:
  fi#
dead
variable sized
size=
, align=
, fixed
, at location [SP
align-all-functions
Force the alignment of all functions.
no-realign-stack
# Machine code for function 
Function Live Ins: 
 in 
# End machine code for function 
Jump Tables:
Constant Pool:
  cp#
FailedISel
IsSSA
Legalized
NoPHIs
NoVRegs
RegBankSelected
Selected
TracksLiveness
Allocation failed
%jump-table.
MachineFunction Printer
frame-setup 
frame-destroy 
nnan 
ninf 
nsz 
arcp 
contract 
afn 
reassoc 
UNKNOWN
 [sideeffect]
 [mayload]
 [maystore]
 [isconvergent]
 [alignstack]
 [attdialect]
 [inteldialect]
:[reguse
:[regdef
:[regdef-ec
:[clobber
:[imm
:[mem
:[??
 tiedto:$
 debug-location 
 :: 
 line no:
 indirect
Loop at depth 
 containing: 
<header>
<latch>
<exiting>
print-regmask-num-regs
Number of registers to limit to when printing regmask operands in IR dumps. unlimited = -1
%subreg.
target-flags(
<unknown>) 
<unknown target flag>
<unknown bitmask target flag>
<mcsymbol 
%fixed-stack.
%stack.
<badref>
implicit-def 
implicit 
def 
internal 
dead 
killed 
undef 
early-clobber 
debug-use 
renamable 
.subreg
(tied-def 
%const.
target-index(
<unknown>
blockaddress(
<regmask
 and 
 more...
 ...
liveout(
<cfi directive>
intrinsic(@
intrinsic(
pred(
volatile 
non-temporal 
dereferenceable 
invariant 
load 
store 
 on 
 from 
 into 
stack
jump-table
constant-pool
call-entry 
call-entry &
custom 
, align 
, !tbaa 
, !alias.scope 
, !noalias 
, !range 
, addrspace 
same_value 
remember_state 
restore_state 
offset 
def_cfa_register 
def_cfa_offset 
def_cfa 
rel_offset 
adjust_cfa_offset 
restore 
escape 
0x%02x
undefined 
register 
window_save 
<unserializable cfi directive>
%dwarfreg.
<badreg>
syncscope("
not_atomic
consume
%ir.
enable-subreg-liveness
Enable subregister liveness tracking.
TargetCustom
FixedStack
Stack
JumpTable
ConstantPool
GlobalValueCallEntry
ExternalSymbolCallEntry
stress-regalloc
Limit all regclasses to N registers
join-liveintervals
Coalesce copies (default=true)
terminal-rule
Apply the terminal rule
join-splitedges
Coalesce copies on split edges (default=subtarget)
join-globalcopies
Coalesce copies that span blocks (default=subtarget)
verify-coalescing
Verify machine instrs before and after register coalescing
Data
Anti
Out 
Ord 
 Latency=
 Reg=
 Barrier
 Memory
 Artificial
 Weak
 Cluster
EntrySU
ExitSU
  # preds left       : 
  # succs left       : 
  # weak preds left  : 
  # weak succs left  : 
  # rdefs left       : 
  Latency            : 
  Depth              : 
  Height             : 
  Predecessors:
  Successors:
Scoreboard:
%bb.
Berd
invalid
stackmap-version
Specify the stackmap encoding version (default = 3)
disable-sched-hazard
Disable hazard detection during preRA scheduling
$noreg
physreg
:sub(
schedmodel
Use TargetSchedModel for latency lookup
scheditins
Use InstrItineraryData for latency lookup
Remove unreachable machine basic blocks
unreachable-mbb-elimination
i128
f128
ppcf128
isVoid
glue
x86mmx
v1i1
v2i1
v4i1
v8i1
v16i1
v32i1
v64i1
v128i1
v512i1
v1024i1
v1i8
v2i8
v4i8
v8i8
v16i8
v32i8
v64i8
v128i8
v256i8
v1i16
v2i16
v4i16
v8i16
v16i16
v32i16
v64i16
v128i16
v1i32
v2i32
v4i32
v8i32
v16i32
v32i32
v64i32
v1i64
v2i64
v4i64
v8i64
v16i64
v32i64
v1i128
v1f32
v2f32
v2f16
v4f16
v8f16
v4f32
v8f32
v16f32
v1f64
v2f64
v4f64
v8f64
Metadata
Untyped
ExceptRef
disable-demotion
Clone multicolor basic blocks but do not demote cross scopes
disable-cleanups
Do not remove implausible terminators or other similar cleanups
demote-catchswitch-only
Demote catchswitch BBs only (for wasm EH)
adce-remove-control-flow
adce-remove-loops
adce
Aggressive Dead Code Elimination
callsite-splitting-duplication-threshold
Only allow instructions before a call, if their cost is below DuplicationThreshold
consthoist-with-block-frequency
Enable the use of the block frequency analysis to reduce the chance to execute const materialization more frequently than without hoisting.
Simple constant propagation
constprop
cvp-dont-process-adds
Value Propagation
correlated-propagation
.lhs.trunc
.rhs.trunc
Dead Code Elimination
enable-dse-partial-overwrite-tracking
Enable partial-overwrite tracking in DSE
enable-dse-partial-store-merging
Enable partial store merging in DSE
Dead Store Elimination
early-cse
Controls which instructions are removed
Early CSE
Early CSE w/ MemorySSA
early-cse-memssa
float2int-max-integer-bw
Max integer bitwidth to consider in float2int(default=64)
Base: 
 Offset: 
 Length: 
enable-pre
enable-load-pre
max-recurse-depth
Max recurse depth (default = 1000)
.pre
.pre-phi
LoadClobbered
load of type 
 not eliminated
 in favor of 
OtherAccess
 because it is clobbered by 
ClobberedBy
LoadElim
 eliminated
InfavorOfValue
Global Value Numbering
LoadPRE
load eliminated by PRE
gvn-max-hoisted
Max number of instructions to hoist (default unlimited = -1)
gvn-hoist-max-bbs
Max number of basic blocks on the path between hoisting locations (default = 4, unlimited = -1)
gvn-hoist-max-depth
Hoist instructions from the beginning of the BB up to the maximum specified depth (default = 100, unlimited = -1)
gvn-hoist-max-chain-length
Maximum length of dependent chains to hoist (default = 10, unlimited = -1)
.sink
irce-loop-size-cutoff
irce-print-changed-loops
irce-print-range-checks
irce-max-exit-prob-reciprocal
irce-skip-profitability-checks
irce-allow-unsigned-latch
InductiveRangeCheck:
  Kind: 
  Begin: 
  Step: 
  End: 
  CheckUse: 
 Operand: 
RANGE_CHECK_UNKNOWN
RANGE_CHECK_UPPER
RANGE_CHECK_LOWER
RANGE_CHECK_BOTH
llvm.loop.unroll.disable
verify-indvars
Verify the ScalarEvolution result after running indvars
replexitval
Choose the strategy to replace exit value in IndVarSimplify
never
never replace exit value
cheap
only replace exit value when the cost is cheap
always
always replace exit value whenever possible
indvars-post-increment-ranges
Use post increment control-dependent ranges in IndVarSimplify
disable-lftr
Disable Linear Function Test Replace optimization
.int
Remove redundant instructions
instsimplify
jump-threading-threshold
Max block size to duplicate for jump threading
jump-threading-implication-search-threshold
The number of predecessors to search for a stronger condition to use to thread over a weaker condition
print-lvi-after-jump-threading
Print the LazyValueInfo cache after JumpThreading
thread-pre-split
.thr_comm
.thread
.split-lp
select.unfold
Jump Threading
jump-threading
LVI for function '
disable-licm-promotion
Disable memory promotion in LICM pass
licm-max-num-uses-traversed
Max num uses visited for identifying load invariance in loop using invariant start (default = 8)
.promoted
Loop Invariant Code Motion
licm
InstSunk
sinking 
Inst
.split.loop.exit
funclet
.lcssa
Hoisted
hoisting 
LoadWithLoopInvariantAddressCondExecuted
failed to hoist load with loop-invariant address because load is conditionally executed
LoadWithLoopInvariantAddressInvalidated
failed to move load with loop-invariant address because the loop may invalidate its value
PromoteLoopAccessesToScalar
Moving accesses to memory location out of the loop
sink-freq-percent-threshold
Do not sink instructions that require cloning unless they execute less than this percent of the time.
max-uses-for-sinking
Do not sink instructions that have too many uses.
Delete dead loops
loop-deletion
loop-prefetch-writes
Prefetch write addresses
prefetch-distance
Number of instructions to prefetch ahead
min-prefetch-stride
Min stride to add prefetches
max-prefetch-iters-ahead
Max number of iterations to prefetch ahead
loop-distribute-verify
Turn on DominatorTree and LoopInfo verification after Loop Distribution
loop-distribute-non-if-convertible
Whether to distribute into a loop that may not be if-convertible by the loop vectorizer
loop-distribute-scev-check-threshold
The maximum number of SCEV checks allowed for Loop Distribution
loop-distribute-scev-check-threshold-with-pragma
The maximum number of SCEV checks allowed for Loop Distribution for loop marked with #pragma loop distribute(enable)
enable-loop-distribute
Enable the new, experimental LoopDistribution Pass
use-lir-code-size-heurs
Use loop idiom recognition code size heuristics when compilingwith -Os/-Oz
memset_pattern16
loop-interchange-threshold
Interchange if you gain more than this number
runtime-check-per-loop-load-elim
Max number of memchecks allowed per eliminated load on average
loop-load-elimination-scev-check-threshold
The maximum number of SCEV checks allowed for Loop Load Elimination
loop-predication-enable-iv-truncation
loop-predication-enable-count-down-loop
loop-predication-skip-profitability-checks
loop-predication-latch-probability-scale
scale factor for the latch probability. Value should be greater than 1. Lower values are ignored
reroll-num-tolerated-failed-matches
The maximum number of failures to tolerate during fuzzy matching. (default: 400)
rotation-max-header-size
The default maximum header size for automatic loop rotation
Rotate Loops
loop-rotate
enable-lsr-phielim
Enable LSR phi elimination
lsr-insns-cost
Add instruction count to a LSR cost model
lsr-exp-narrow
Narrow LSR complex solution using expectation of registers number
lsr-filter-same-scaled-reg
Narrow LSR search space by filtering non-optimal formulae with the same ScaledReg and Scale
[NumUses=
reg(
**error: HasBaseReg**
**error: !HasBaseReg**
*reg(
imm(
 instruction
 reg
, with addrec cost 
, plus 
 IV mul
 base add
 scale cost
 imm cost
 setup cost
UserInst=
, OperandValToReplace=
, PostIncLoop=
, Offset=
LSR Use: Kind=
Basic
Special
ICmpZero
Address of 
pointer
 in addrspace(
, Offsets={
, all-fixups-outside-loop
, widest fixup type: 
in formulae referencing 
 in use 
 , add offset 
LSR has identified the following interesting factors and types: 
LSR is examining the following fixup sites:
LSR is examining the following uses:
unroll-threshold
The cost threshold for loop unrolling
unroll-partial-threshold
The cost threshold for partial loop unrolling
unroll-max-percent-threshold-boost
The maximum 'boost' (represented as a percentage >= 100) applied to the threshold when aggressively unrolling a loop due to the dynamic cost savings. If completely unrolling a loop will reduce the total runtime from X to Y, we boost the loop unroll threshold to DefaultThreshold*std::min(MaxPercentThresholdBoost, X/Y). This limit avoids excessive code bloat.
unroll-max-iteration-count-to-analyze
Don't allow loop unrolling to simulate more than this number ofiterations when checking full unroll profitability
unroll-count
Use this unroll count for all loops including those with unroll_count pragma values, for testing purposes
unroll-max-count
Set the max unroll count for partial and runtime unrolling, fortesting purposes
unroll-full-max-count
Set the max unroll count for full unrolling, for testing purposes
unroll-peel-count
Set the unroll peeling count, for testing purposes
unroll-allow-partial
Allows loops to be partially unrolled until -unroll-threshold loop size is reached.
unroll-allow-remainder
Allow generation of a loop remainder (extra iterations) when unrolling a loop.
unroll-runtime
Unroll loops with run-time trip counts
unroll-max-upperbound
The max of trip count upper bound that is considered in unrolling
pragma-unroll-threshold
Unrolled size limit for loops with an unroll(full) or unroll_count pragma.
flat-loop-tripcount-threshold
If the runtime tripcount for the loop is lower than the threshold, the loop is considered as flat and will be less aggressively unrolled.
unroll-allow-peeling
Allows loops to be peeled when the dynamic trip count is known to be low.
unroll-remainder
Allow the loop remainder to be unrolled.
unroll-revisit-child-loops
Enqueue and re-visit child loops in the loop PM after unrolling. This shouldn't typically be needed as child loops (or their clones) were already visited.
llvm.loop.unroll.count
llvm.loop.unroll.runtime.disable
Unroll loops
loop-unroll
UnrollAsDirectedTooLarge
Unable to unroll loop as directed by unroll(enable) pragma because unrolled size is too large.
FullUnrollAsDirectedTooLarge
Unable to fully unroll loop as directed by unroll pragma because unrolled size is too large.
CantFullUnrollAsDirectedRuntimeTripCount
Unable to fully unroll loop as directed by unroll(full) pragma because loop has a runtime trip count.
DifferentUnrollCountFromDirected
Unable to unroll loop the number of times directed by unroll_count pragma because remainder loop is restricted (that could architecture specific or because the loop contains a convergent instruction) and so must have an unroll count that divides the loop trip multiple of 
TripMultiple
.  Unrolling instead 
UnrollCount
 time(s).
allow-unroll-and-jam
Allows loops to be unroll-and-jammed.
unroll-and-jam-count
Use this unroll count for all loops including those with unroll_and_jam_count pragma values, for testing purposes
unroll-and-jam-threshold
Threshold to use for inner loop when doing unroll and jam.
pragma-unroll-and-jam-threshold
Unrolled size limit for loops with an unroll_and_jam(full) or unroll_count pragma.
loop-unswitch-threshold
Max loop size to unswitch
licm-versioning-invariant-threshold
LoopVersioningLICM's minimum allowed percentageof possible invariant instructions per loop
licm-versioning-max-depth-threshold
LoopVersioningLICM's threshold for maximum allowed loop nest/depth
llvm.mem.parallel_loop_access
likely-branch-weight
Weight of the branch likely to be taken (default = 2000)
unlikely-branch-weight
Weight of the branch unlikely to be taken (default = 1)
guards-predicate-pass-branch-weight
The probability of a guard failing is assumed to be the reciprocal of this value (default = 1 << 20)
deopt
MemCpy Optimization
memcpyopt
Controls which instructions are value numbered
Controls which instructions we create phi of ops for
enable-store-refinement
enable-phi-of-ops
spp-all-backedges
spp-counted-loop-trip-width
spp-split-backedge
spp-no-entry
spp-no-call
spp-no-backedge
spp-print-liveset
spp-print-liveset-size
spp-print-base-pointers
spp-rematerialization-threshold
rs4gc-clobber-non-live
rs4gc-allow-statepoint-with-no-deopt-info
nullptr
__llvm_deoptimize
Sparse Conditional Constant Propagation
sccp
sroa-random-shuffle-slices
sroa-strict-inbounds
Can't analyze slices for alloca: 
  A pointer to this alloca escaped by:
Slices of alloca: 
.sroa.
 slice #
 (splittable)
  used by: 
sroa_raw_cast
sroa_raw_idx
sroa_cast
sroa_idx
sroa
load.ext
endian_shift
insert
.shift
.ext
.insert
load.trunc
.expand
blend
oldload
copyload
isplat
vsplat
.fca
.gep
.load
.sroa.speculated
.sroa.speculate.load.
.sroa.speculate.load.true
.sroa.speculate.load.false
SROA
Scalar Replacement Of Aggregates
disable-separate-const-offset-from-gep
Do not separate the constant offset from a GEP instruction
reassociate-geps-verify-no-dead-code
Verify this pass produces no dead code
uglygep
enable-nontrivial-unswitch
Forcibly enables non-trivial loop unswitching rather than following the configuration passed into the pass.
unswitch-threshold
The cost threshold for unswitching a loop.
.split
bonus-inst-threshold
Control the number of bonus instructions (default = 1)
keep-loops
Preserve canonical loop structure (default = true)
switch-to-lookup
Convert switches to lookup tables (default = false)
forward-switch-cond
Forward switch condition to phi ops (default = false)
sink-common-insts
Sink common instructions (default = false)
merge
simplifycfg
Simplify the CFG
spec-exec-max-speculation-cost
Speculative execution is not applied to basic blocks where the cost of the instructions to speculatively execute exceeds this limit.
spec-exec-max-not-hoisted
Speculative execution is not applied to basic blocks where the number of instructions that would not be speculatively executed exceeds this limit.
spec-exec-only-if-divergent-target
Speculative execution is applied only to targets with divergent branches, even if the pass was configured to apply only to all targets.
structurizecfg-skip-uniform-regions
Force whether the StructurizeCFG pass skips uniform regions
lpad
lpad.phi
_crit_edge
Break critical edges in CFG
break-crit-edges
cstr
strlen
strchr
strncmp
strncpy
__memcpy_chk
memchr
memcmp
putchar
chari
puts
fputc
fputc_unlocked
fputs
fputs_unlocked
malloc
calloc
fgetc_unlocked
fgets_unlocked
enable-noalias-to-md-conversion
Convert noalias attributes to metadata during inlining.
preserve-alignment-assumptions-during-inlining
Convert align attributes to assumptions during inlining.
savedstack
.exit
ptrint
maskedptr
maskcond
: argument 
.lpad-body
eh.lpad-body
thinlto_src_module
------- Dumping inliner stats for [
] -------
-- List of inlined functions:
Inlined 
imported 
not imported 
function [
: #inlines = 
, #inlines_to_importing_module = 
-- Summary:
All functions: 
, imported functions: 
inlined functions
all functions
imported functions inlined anywhere
imported functions
imported functions inlined into importing module
, remaining
non-imported functions inlined anywhere
non-imported functions
non-imported functions inlined into importing module
% of 
verify-loop-lcssa
Verify loop lcssa form (time consuming)
lcssa
Loop-Closed SSA Form Pass
cond
.noexc
.lr.ph
.preheader
.outer
loop-simplify
Canonicalize natural loops
unroll-runtime-epilog
Allow runtime unrolled loops to be unrolled with epilog instead of prolog.
unroll-verify-domtree
Verify domtree after unrolling
FullyUnrolled
completely unrolled loop with 
 iterations
Peeled
 peeled loop by 
PeelCount
 with a breakout at trip 
BreakoutTrip
PartialUnrolled
unrolled loop by a factor of 
 with 
 trips per branch
 with run-time trip count
unroll-peel-max-count
Max average trip count which will cause loop peeling.
unroll-force-peel-count
Force a peel count regardless of profiling information.
.peel.begin
.peel.next
.peel.newph
.peel
unroll-runtime-multi-exit
Allow runtime unrolling for loops with multiple exits, when epilog is generated
.new
.unr-lcssa
.epil.preheader
.prol.preheader
.prol.loopexit
xtraiter
lcmp.mod
unroll_iter
niter
.nsub
.ncmp
epil
prol
.iter
.cmp
.unr
.epilog-lcssa
.loopexit
loop-version-annotate-no-alias
Add no-alias annotation for instructions that are disambiguated by memchecks
Lower SwitchInst's to branches
lowerswitch
NewDefault
NodeBlock
Pivot
LeafBlock
SwitchLeaf
mem2reg
Promote Memory to Register
verify-predicateinfo
Verify PredicateInfo in legacy printer pass.
predicateinfo-rename
Controls which variables are renamed with predicateinfo
phi-node-folding-threshold
Control the amount of phi node folding to perform (default = 2)
simplifycfg-dup-ret
Duplicate return instructions into unconditional branches
simplifycfg-sink-common
Sink common instructions down to the end block
simplifycfg-hoist-cond-stores
Hoist conditional stores if an unconditional store precedes
simplifycfg-merge-cond-stores
Hoist conditional stores even if an unconditional store does not precede - hoist multiple conditional stores into a single predicated store
simplifycfg-merge-cond-stores-aggressively
When merging conditional stores, do so even if the resultant basic blocks are unlikely to be if-converted as a result
speculate-one-expensive-inst
Allow exactly one expensive instruction to be speculatively executed
max-speculation-depth
Limit maximum recursion depth when calculating costs of speculatively executed instructions
.old
or.cond
not.cond
and.cond
.sink.split
switch.edge
.fold.split
magicptr
infloop
switch.early.test
spec.store.select
spec.select
.critedge
brmerge
.mux
condstore.split
simplifycfg.merge
switch.selectcmp
switch.select
no-jump-tables
switch.lookup
switch.tableidx
switch.hole_check
switch.maskindex
switch.shifted
switch.lobit
switch.table.
switch.idx.cast
switch.idx.mult
switch.offset
switch.cast
switch.shiftamt
switch.downshift
switch.masked
switch.tableidx.zext
switch.gep
switch.load
inverted.cmp
indvars
iv.rem
.urem
.udiv
enable-double-float-shrink
Enable unsafe double to float shrinking for math lib calls
endptr
strchr
strrchr
strcmpload
strlenfirst
strpbrk
strstr
memchr.bounds
memchr.bits
memchr
lhsc
lhsv
rhsc
rhsv
chardiff
memcmp
real
imag
cabs
reciprocal
square
isinf
log2
log10
logmul
tanf
tanl
cttz
ctlz
isdigittmp
isdigit
isascii
iprintf
leninc
siprintf
fiprintf
__sincospif_stret
__sincospi_stret
sincospi
sinpi
cospi
instcombine
simplify-libcalls
folded strlen(select) to select of constants
disable-basicaa
NoAlias
MustAlias
MayAlias
PartialAlias
External Alias Analysis
external-aa
Function Alias Analysis Results
alias-set-saturation-threshold
The maximum number of pointers may-alias sets may contain before degradation
  AliasSet[
must
 alias, 
No access 
Ref       
Mod       
Mod/Ref   
[volatile] 
 forwarding to 
Pointers: 
    
 Unknown instructions: 
Alias Set Tracker: 
 alias sets for 
 pointer values.
verify-assumption-cache
Enable verification of assumption cache
Assumption in scanned function not in cache
Assumption Cache Tracker
assumption-cache-tracker
basicaa-recphi
basicaa
Basic Alias Analysis (stateless AA impl)
view-block-freq-propagation-dags
Pop up a window to show a dag displaying how block frequencies propagation through the CFG.
view-bfi-func-name
The option to specify the name of the function whose CFG will be displayed.
view-hot-freq-percent
An integer in percent used to specify the hot blocks/edges to be displayed in red: a block or edge whose frequency is no less than the max frequency of the function multiplied by this percent.
pgo-view-counts
A boolean option to show CFG dag or text with block profile counts and branch probabilities right after PGO profile annotation step. The profile counts are computed using branch probabilities from the runtime profile data and block frequency propagation algorithm. To view the raw counts from the profile, use option -pgo-view-raw-counts instead. To limit graph display to only one function, use filtering option -view-bfi-func-name.
do not show.
graph
show a graph.
text
show in text.
print-bfi
Print the block frequency info.
print-bfi-func-name
The option to specify the name of the function whose block frequency info is printed.
BlockFrequencyDAGs
block-frequency-info: 
: float = 
, int = 
, count = 
, irr_loop_header_weight = 
Block Frequency Analysis
block-freq
error opening file '
' for writing!
 done. 
digraph "
digraph unnamed {
label="
Node
 [shape=record,
label="{
}"];
color="red"
Unknown
 -> Node
label="%.1f%%"
,color="red"
print-bpi
Print the branch probability info.
print-bpi-func-name
The option to specify the name of the function whose branch probability info is printed.
---- Branch Probabilities ----
edge 
 probability is 
 [HOT edge]
Branch Probability Analysis
branch-prob
Inclusion-Based CFL Alias Analysis
cfl-anders-aa
Unification-Based CFL Alias Analysis
cfl-steens-aa
Invalidating all non-preserved analyses for: 
Invalidating analysis: 
Call graph node for function: '
Call graph node <<null function>>
>>  #uses=
  CS<
> calls 
function '
external node
No call graph has been built!
CallGraph Construction
basiccg
max-cg-scc-iterations
CallGraph Pass Manager
Call Graph SCC Pass Manager
size-info
Print CallGraph IR
Printing <null> Function
acos
asin
atan
atan2
acosf
asinf
atanf
atan2f
cosh
ceilf
coshf
expf
fmod
fmodf
logf
log10f
roundf
sinh
sinhf
tanh
tanhf
__acos_finite
__acosf_finite
__asin_finite
__asinf_finite
__atan2_finite
__atan2f_finite
__cosh_finite
__coshf_finite
__exp_finite
__expf_finite
__exp2_finite
__exp2f_finite
__log_finite
__logf_finite
__log10_finite
__log10f_finite
__pow_finite
__powf_finite
__sinh_finite
__sinhf_finite
da-delinearize
Try to delinearize array references.
 Empty
 Any
 Point is <
 Distance is 
*X + 
*Y = 
 Line is 
enable-unsafe-globalsmodref-alias-results
Globals Alias Analysis
globals-aa
IV Users for loop 
 with backedge-taken count 
 (post-inc with loop 
 in  
Printing <null> User
icp-remaining-percent-threshold
The percentage threshold against remaining unpromoted indirect call count for the promotion
icp-total-percent-threshold
The percentage threshold against total count for the promotion
icp-max-prom
Max number of promotions for a single indirect call callsite
inline-threshold
Control the amount of inlining to perform (default = 225)
inlinehint-threshold
Threshold for inlining functions with inline hint
inline-cold-callsite-threshold
Threshold for inlining cold callsites
inlinecold-threshold
Threshold for inlining functions with cold attribute
hot-callsite-threshold
Threshold for hot callsites 
locally-hot-callsite-threshold
Threshold for locally hot callsites 
cold-callsite-rel-freq
Maxmimum block frequency, expressed as a percentage of caller's entry frequency, for a callsite to be cold in the absence of profile information.
hot-callsite-rel-freq
Minimum block frequency, expressed as a multiple of caller's entry frequency, for a callsite to be hot in the absence of profile information.
inline-cost-full
Compute the full inline cost of a call site even when the cost exceeds the threshold.
      NumConstantArgs: 
      NumConstantOffsetPtrArgs: 
      NumAllocaArgs: 
      NumConstantPtrCmps: 
      NumConstantPtrDiffs: 
      NumInstructionsSimplified: 
      NumInstructions: 
      SROACostSavings: 
      SROACostSavingsLost: 
      LoadEliminationCost: 
      ContainsNoDuplicateCall: 
      Cost: 
      Threshold: 
inline-cost
 has uninlinable pattern and cost is not fully computed
 is recursive and allocates too much stack space. Cost is not fully computed
Lazy Branch Probability Analysis
lazy-branch-prob
Lazy Block Frequency Analysis
lazy-block-freq
Lazy Value Information Analysis
lazy-value-info
; LatticeVal for: '
' is: 
' in BB: '
available-load-scan-limit
Use this to specify the default maximum number of instructions to scan backward from a given instruction, when searching for available loaded value
force-vector-width
Sets the SIMD width. Zero is autoselect.
force-vector-interleave
Sets the vectorization interleave count. Zero is autoselect.
runtime-memory-check-threshold
When performing memory disambiguation checks at runtime do not generate more than this number of comparisons (default = 8).
memory-check-merge-threshold
Maximum number of comparisons done when trying to merge runtime memory checks. (default = 100)
max-dependences
Maximum number of dependences collected by loop-access analysis (default = 100)
enable-mem-access-versioning
Enable symbolic stride memory access versioning
store-to-load-forwarding-conflict-detection
Enable conflict detection in loop-access analysis
enable-mssa-loop-dependency
Enable MemorySSA dependency for loop pass manager
<unnamed loop>
verify-loop-info
Verify loop info (time consuming)
 (loop: 
; Preheader:
; Loop:
Printing <null> block
; Exit blocks
Natural Loop Information
loops
<deleted loop>
<deleted>
Loop Pass Manager
Print Loop IR
LCSSA Verifier
lcssa-verification
Loop Pass Manager
memdep-block-scan-limit
The number of instructions to scan in a block in memory dependency analysis (default = 100)
memdep-block-number-limit
The number of blocks to scan during memory dependency analysis (default = 1000)
memdep
Memory Dependence Analysis
memssa-check-limit
The maximum number of stores/phis MemorySSAwill consider trying to walk past (default = 100)
verify-memoryssa
Verify MemorySSA in legacy printer pass.
 = MemoryDef(
 = MemoryPhi(
MemoryUse(
Memory SSA
memoryssa
force-summary-edges-cold
Force all edges in the function summary to cold
None.
all-non-critical
All non-critical edges.
All edges.
llvm.compiler.used
Module Summary Analysis
module-summary-analysis
ObjC-ARC-Based Alias Analysis
objc-arc-aa
enable-objc-arc-opts
enable/disable all ARC Optimizations
objc_retainAutoreleasedReturnValue
objc_unsafeClaimAutoreleasedReturnValue
objc_retainAutoreleaseReturnValue
llvm.arc.annotation.topdown.bbstart
llvm.arc.annotation.topdown.bbend
llvm.arc.annotation.bottomup.bbstart
llvm.arc.annotation.bottomup.bbend
opt-remark-emitter
PHITransAddr: null
PHITransAddr: 
  Input #
 is 
.phi.trans.insert
Phi Values Analysis
phi-values
Post-Dominator Tree Construction
postdomtree
profile-summary-cutoff-hot
A count is hot if it exceeds the minimum count to reach this percentile of total counts.
profile-summary-cutoff-cold
A count is cold if it is below the minimum count to reach this percentile of total counts.
profile-sample-accurate
If the sample profile is accurate, we will mark all un-sampled callsite as cold. Otherwise, treat un-sampled callsites as if we have no profile.
profile-summary-huge-working-set-size-threshold
The code working set size is considered huge if the number of blocks required to reach the -profile-summary-cutoff-hot percentile exceeds this count.
Desired percentile exceeds the maximum cutoff
Profile summary info
profile-summary-info
<Function Return>
Region tree:
End region tree
verify-region-info
Verify region info (time consuming)
print-region-style
style of printing regions
print no details
print regions in detail with block_iterator
print regions in detail with element_iterator
scalar-evolution-max-iterations
Maximum number of iterations SCEV will symbolically execute a constant derived loop
verify-scev
Verify ScalarEvolution's backedge taken counts (slow)
verify-scev-maps
Verify no dangling value in ScalarEvolution's ExprValueMap (slow)
scev-mulops-inline-threshold
Threshold for inlining multiplication operands into a SCEV
scev-addops-inline-threshold
Threshold for inlining addition operands into a SCEV
scalar-evolution-max-scev-compare-depth
Maximum depth of recursive SCEV complexity comparisons
scalar-evolution-max-scev-operations-implication-depth
Maximum depth of recursive SCEV operations implication analysis
scalar-evolution-max-value-compare-depth
Maximum depth of recursive value complexity comparisons
scalar-evolution-max-arith-depth
Maximum depth of recursive arithmetics
scalar-evolution-max-constant-evolving-depth
Maximum depth of recursive constant evolving
scalar-evolution-max-cast-depth
Maximum depth of recursive SExt/ZExt/Trunc
scalar-evolution-max-add-rec-size
Max coefficients in AddRec during evolving
(trunc 
(zext 
(sext 
nuw><
nsw><
nw><
 umax 
 smax 
<nuw>
<nsw>
 /u 
sizeof(
alignof(
offsetof(
***COULDNOTCOMPUTE***
Classifying expressions for: 
  -->  
 U: 
 S: 
Exits: 
<<Unknown>>
LoopDispositions: { 
Determining loop execution counts for: 
Trip Count Changed!
Old: 
New: 
Delta: 
Equal predicate: 
 == 
 Added Flags: 
<nusw>
<nssw>
scalar-evolution
Variant
Invariant
Computable
Loop 
<multiple exits> 
backedge-taken count is 
Unpredictable backedge-taken count. 
Loop 
max backedge-taken count is 
, actual taken count either this or zero.
Unpredictable max backedge-taken count. 
Predicated backedge-taken count is 
 Predicates:
Unpredictable predicated backedge-taken count. 
Trip multiple is 
Scalar Evolution Analysis
ScalarEvolution-based Alias Analysis
scev-aa
scevgep
.iv.next
indvar
indvar.next
smax
vector-library
Vector functions library
No vector functions library
Accelerate
Accelerate framework
SVML
Intel SVML library
??2@YAPAXI@Z
??2@YAPAXIABUnothrow_t@std@@@Z
??2@YAPEAX_K@Z
??2@YAPEAX_KAEBUnothrow_t@std@@@Z
??3@YAXPAX@Z
??3@YAXPAXABUnothrow_t@std@@@Z
??3@YAXPAXI@Z
??3@YAXPEAX@Z
??3@YAXPEAXAEBUnothrow_t@std@@@Z
??3@YAXPEAX_K@Z
??_U@YAPAXI@Z
??_U@YAPAXIABUnothrow_t@std@@@Z
??_U@YAPEAX_K@Z
??_U@YAPEAX_KAEBUnothrow_t@std@@@Z
??_V@YAXPAX@Z
??_V@YAXPAXABUnothrow_t@std@@@Z
??_V@YAXPAXI@Z
??_V@YAXPEAX@Z
??_V@YAXPEAXAEBUnothrow_t@std@@@Z
??_V@YAXPEAX_K@Z
_IO_getc
_IO_putc
_ZdaPv
_ZdaPvRKSt9nothrow_t
_ZdaPvSt11align_val_t
_ZdaPvSt11align_val_tRKSt9nothrow_t
_ZdaPvj
_ZdaPvm
_ZdlPv
_ZdlPvRKSt9nothrow_t
_ZdlPvSt11align_val_t
_ZdlPvSt11align_val_tRKSt9nothrow_t
_ZdlPvj
_ZdlPvm
_Znaj
_ZnajRKSt9nothrow_t
_ZnajSt11align_val_t
_ZnajSt11align_val_tRKSt9nothrow_t
_Znam
_ZnamRKSt9nothrow_t
_ZnamSt11align_val_t
_ZnamSt11align_val_tRKSt9nothrow_t
_Znwj
_ZnwjRKSt9nothrow_t
_ZnwjSt11align_val_t
_ZnwjSt11align_val_tRKSt9nothrow_t
_Znwm
_ZnwmRKSt9nothrow_t
_ZnwmSt11align_val_t
_ZnwmSt11align_val_tRKSt9nothrow_t
__acosh_finite
__acoshf_finite
__acoshl_finite
__acosl_finite
__asinl_finite
__atan2l_finite
__atanh_finite
__atanhf_finite
__atanhl_finite
__coshl_finite
__cospi
__cospif
__cxa_atexit
__cxa_guard_abort
__cxa_guard_acquire
__cxa_guard_release
__exp10_finite
__exp10f_finite
__exp10l_finite
__exp2l_finite
__expl_finite
__isoc99_scanf
__isoc99_sscanf
__log10l_finite
__log2_finite
__log2f_finite
__log2l_finite
__logl_finite
__memcpy_chk
__memmove_chk
__memset_chk
__nvvm_reflect
__powl_finite
__sinhl_finite
__sinpi
__sinpif
__sqrt_finite
__sqrtf_finite
__sqrtl_finite
__stpcpy_chk
__stpncpy_chk
__strcpy_chk
__strdup
__strncpy_chk
__strndup
__strtok_r
access
acosh
acoshf
acoshl
acosl
asinh
asinhf
asinhl
asinl
atan2l
atanh
atanhf
atanhl
atanl
atof
atoi
atol
atoll
bcmp
bcopy
bzero
cabsf
cabsl
calloc
cbrt
cbrtf
cbrtl
ceill
chmod
chown
clearerr
closedir
coshl
ctermid
exp10
exp10f
exp10l
expl
expm1
expm1f
expm1l
fclose
fdopen
feof
ferror
fflush
ffsll
fgetc
fgetc_unlocked
fgetpos
fgets
fgets_unlocked
fileno
flockfile
floorl
flsl
flsll
fmodl
fopen
fopen64
fprintf
fread
fread_unlocked
free
frexp
frexpf
frexpl
fscanf
fseek
fseeko
fseeko64
fsetpos
fstat
fstat64
fstatvfs
fstatvfs64
ftell
ftello
ftello64
ftrylockfile
funlockfile
fwrite
fwrite_unlocked
getc
getc_unlocked
getchar
getchar_unlocked
getenv
getitimer
getlogin_r
getpwnam
gets
gettimeofday
htonl
htons
lchown
ldexp
ldexpf
ldexpl
log10l
log1p
log1pf
log1pl
log2f
log2l
logb
logbf
logbl
logl
lstat
lstat64
malloc
memalign
memccpy
mempcpy
memrchr
mkdir
mktime
modf
modff
modfl
nearbyint
nearbyintf
nearbyintl
ntohl
ntohs
open
open64
opendir
pclose
perror
popen
posix_memalign
pread
putc
putc_unlocked
putchar
putchar_unlocked
puts
pwrite
qsort
readlink
realloc
reallocf
realpath
remove
rename
rewind
rint
rintf
rintl
rmdir
roundl
scanf
setbuf
setitimer
setvbuf
sinhl
snprintf
sprintf
sscanf
stat
stat64
statvfs
statvfs64
stpcpy
stpncpy
strcasecmp
strcat
strcmp
strcoll
strcpy
strcspn
strdup
strlen
strncasecmp
strncat
strncmp
strncpy
strndup
strnlen
strspn
strtod
strtof
strtok
strtok_r
strtol
strtold
strtoll
strtoul
strtoull
strxfrm
system
tanhl
times
tmpfile
tmpfile64
toascii
truncf
truncl
uname
ungetc
unlink
unsetenv
utime
utimes
valloc
vfprintf
vfscanf
vprintf
vscanf
vsnprintf
vsprintf
vsscanf
wcslen
vceilf
vfabsf
llvm.fabs.f32
vfloorf
vsqrtf
llvm.sqrt.f32
vexpf
llvm.exp.f32
vexpm1f
vlogf
llvm.log.f32
vlog1pf
vlog10f
llvm.log10.f32
vlogbf
vsinf
llvm.sin.f32
vcosf
llvm.cos.f32
vtanf
vasinf
vacosf
vatanf
vsinhf
vcoshf
vtanhf
vasinhf
vacoshf
vatanhf
__svml_sin2
__svml_sin4
__svml_sin8
__svml_sinf4
__svml_sinf8
__svml_sinf16
llvm.sin.f64
__svml_cos2
__svml_cos4
__svml_cos8
__svml_cosf4
__svml_cosf8
__svml_cosf16
llvm.cos.f64
__svml_pow2
__svml_pow4
__svml_pow8
__svml_powf4
__svml_powf8
__svml_powf16
llvm.pow.f64
llvm.pow.f32
__svml_exp2
__svml_exp4
__svml_exp8
__svml_expf4
__svml_expf8
__svml_expf16
llvm.exp.f64
__svml_log2
__svml_log4
__svml_log8
__svml_logf4
__svml_logf8
__svml_logf16
llvm.log.f64
wchar_size
fwrite$UNIX2003
fputs$UNIX2003
_copysign
__exp10
__exp10f
Target Library Information
targetlibinfo
costmodel-reduxcost
Recognize reduction patterns.
Target Transform Information
enable-tbaa
Cycle found in TBAA metadata.
Type-Based Alias Analysis
tbaa
enable-scoped-noalias
Scoped NoAlias Alias Analysis
scoped-noalias
undefined
overdefined
notconstant<
constantrange<
constant<
dom-conditions-max-uses
value-tracking
BadAssumption
Detected conflicting code assumptions. Program may have undefined behavior, or compiler may have internal error.
LLVM_OVERRIDE_PRODUCER
input module has no datalayout
Unable to determine comdat of alias!
Invalid weak external
__ashlhi3
__ashlsi3
__ashldi3
__ashlti3
__lshrhi3
__lshrsi3
__lshrdi3
__lshrti3
__ashrhi3
__ashrsi3
__ashrdi3
__ashrti3
__mulqi3
__mulhi3
__mulsi3
__muldi3
__multi3
__mulosi4
__mulodi4
__muloti4
__divqi3
__divhi3
__divsi3
__divdi3
__divti3
__udivqi3
__udivhi3
__udivsi3
__udivdi3
__udivti3
__modqi3
__modhi3
__modsi3
__moddi3
__modti3
__umodqi3
__umodhi3
__umodsi3
__umoddi3
__umodti3
__negsi2
__negdi2
__addsf3
__adddf3
__addxf3
__addtf3
__gcc_qadd
__subsf3
__subdf3
__subxf3
__subtf3
__gcc_qsub
__mulsf3
__muldf3
__mulxf3
__multf3
__gcc_qmul
__divsf3
__divdf3
__divxf3
__divtf3
__gcc_qdiv
fmaf
fmal
__powisf2
__powidf2
__powixf2
__powitf2
__gcc_stoq
__gcc_dtoq
__extendxftf2
__extenddftf2
__extendsftf2
__extendsfdf2
__gnu_h2f_ieee
__gnu_f2h_ieee
__truncdfhf2
__truncxfhf2
__trunctfhf2
__truncdfsf2
__truncxfsf2
__trunctfsf2
__gcc_qtos
__truncxfdf2
__trunctfdf2
__gcc_qtod
__trunctfxf2
__fixsfsi
__fixsfdi
__fixsfti
__fixdfsi
__fixdfdi
__fixdfti
__fixxfsi
__fixxfdi
__fixxfti
__fixtfsi
__fixtfdi
__fixtfti
__gcc_qtou
__fixunssfsi
__fixunssfdi
__fixunssfti
__fixunsdfsi
__fixunsdfdi
__fixunsdfti
__fixunsxfsi
__fixunsxfdi
__fixunsxfti
__fixunstfsi
__fixunstfdi
__fixunstfti
__floatsisf
__floatsidf
__floatsixf
__floatsitf
__gcc_itoq
__floatdisf
__floatdidf
__floatdixf
__floatditf
__floattisf
__floattidf
__floattixf
__floattitf
__floatunsisf
__floatunsidf
__floatunsixf
__floatunsitf
__gcc_utoq
__floatundisf
__floatundidf
__floatundixf
__floatunditf
__floatuntisf
__floatuntidf
__floatuntixf
__floatuntitf
__eqsf2
__eqdf2
__eqtf2
__gcc_qeq
__nesf2
__nedf2
__netf2
__gcc_qne
__gesf2
__gedf2
__getf2
__gcc_qge
__ltsf2
__ltdf2
__lttf2
__gcc_qlt
__lesf2
__ledf2
__letf2
__gcc_qle
__gtsf2
__gtdf2
__gttf2
__gcc_qgt
__unordsf2
__unorddf2
__unordtf2
__gcc_qunord
__llvm_memcpy_element_unordered_atomic_1
__llvm_memcpy_element_unordered_atomic_2
__llvm_memcpy_element_unordered_atomic_4
__llvm_memcpy_element_unordered_atomic_8
__llvm_memcpy_element_unordered_atomic_16
__llvm_memmove_element_unordered_atomic_1
__llvm_memmove_element_unordered_atomic_2
__llvm_memmove_element_unordered_atomic_4
__llvm_memmove_element_unordered_atomic_8
__llvm_memmove_element_unordered_atomic_16
__llvm_memset_element_unordered_atomic_1
__llvm_memset_element_unordered_atomic_2
__llvm_memset_element_unordered_atomic_4
__llvm_memset_element_unordered_atomic_8
__llvm_memset_element_unordered_atomic_16
_Unwind_Resume
__sync_val_compare_and_swap_1
__sync_val_compare_and_swap_2
__sync_val_compare_and_swap_4
__sync_val_compare_and_swap_8
__sync_val_compare_and_swap_16
__sync_lock_test_and_set_1
__sync_lock_test_and_set_2
__sync_lock_test_and_set_4
__sync_lock_test_and_set_8
__sync_lock_test_and_set_16
__sync_fetch_and_add_1
__sync_fetch_and_add_2
__sync_fetch_and_add_4
__sync_fetch_and_add_8
__sync_fetch_and_add_16
__sync_fetch_and_sub_1
__sync_fetch_and_sub_2
__sync_fetch_and_sub_4
__sync_fetch_and_sub_8
__sync_fetch_and_sub_16
__sync_fetch_and_and_1
__sync_fetch_and_and_2
__sync_fetch_and_and_4
__sync_fetch_and_and_8
__sync_fetch_and_and_16
__sync_fetch_and_or_1
__sync_fetch_and_or_2
__sync_fetch_and_or_4
__sync_fetch_and_or_8
__sync_fetch_and_or_16
__sync_fetch_and_xor_1
__sync_fetch_and_xor_2
__sync_fetch_and_xor_4
__sync_fetch_and_xor_8
__sync_fetch_and_xor_16
__sync_fetch_and_nand_1
__sync_fetch_and_nand_2
__sync_fetch_and_nand_4
__sync_fetch_and_nand_8
__sync_fetch_and_nand_16
__sync_fetch_and_max_1
__sync_fetch_and_max_2
__sync_fetch_and_max_4
__sync_fetch_and_max_8
__sync_fetch_and_max_16
__sync_fetch_and_umax_1
__sync_fetch_and_umax_2
__sync_fetch_and_umax_4
__sync_fetch_and_umax_8
__sync_fetch_and_umax_16
__sync_fetch_and_min_1
__sync_fetch_and_min_2
__sync_fetch_and_min_4
__sync_fetch_and_min_8
__sync_fetch_and_min_16
__sync_fetch_and_umin_1
__sync_fetch_and_umin_2
__sync_fetch_and_umin_4
__sync_fetch_and_umin_8
__sync_fetch_and_umin_16
__atomic_load
__atomic_load_1
__atomic_load_2
__atomic_load_4
__atomic_load_8
__atomic_load_16
__atomic_store
__atomic_store_1
__atomic_store_2
__atomic_store_4
__atomic_store_8
__atomic_store_16
__atomic_exchange
__atomic_exchange_1
__atomic_exchange_2
__atomic_exchange_4
__atomic_exchange_8
__atomic_exchange_16
__atomic_compare_exchange
__atomic_compare_exchange_1
__atomic_compare_exchange_2
__atomic_compare_exchange_4
__atomic_compare_exchange_8
__atomic_compare_exchange_16
__atomic_fetch_add_1
__atomic_fetch_add_2
__atomic_fetch_add_4
__atomic_fetch_add_8
__atomic_fetch_add_16
__atomic_fetch_sub_1
__atomic_fetch_sub_2
__atomic_fetch_sub_4
__atomic_fetch_sub_8
__atomic_fetch_sub_16
__atomic_fetch_and_1
__atomic_fetch_and_2
__atomic_fetch_and_4
__atomic_fetch_and_8
__atomic_fetch_and_16
__atomic_fetch_or_1
__atomic_fetch_or_2
__atomic_fetch_or_4
__atomic_fetch_or_8
__atomic_fetch_or_16
__atomic_fetch_xor_1
__atomic_fetch_xor_2
__atomic_fetch_xor_4
__atomic_fetch_xor_8
__atomic_fetch_xor_16
__atomic_fetch_nand_1
__atomic_fetch_nand_2
__atomic_fetch_nand_4
__atomic_fetch_nand_8
__atomic_fetch_nand_16
__stack_chk_fail
Could not find leader
__imp_
invalid hexadecimal floating-point constant: expected at least one significand digit
invalid hexadecimal floating-point constant: expected exponent part 'p'
invalid hexadecimal floating-point constant: expected at least one exponent digit
unterminated comment
invalid binary number
invalid hexdecimal number
invalid decimal number
invalid hexadecimal number
invalid octal number
unterminated single quote
single quote way too long
unterminated string constant
invalid character in input
higher
highest
tlsgd
asm-macro-max-nesting-depth
The maximum nesting depth allowed for assembly macros.
missing expression
unexpected token
Recursive use of '
redefinition of '
invalid assignment to '
invalid reassignment of non-absolute variable '
.set
.equ
.equiv
.ascii
.asciz
.string
.byte
.short
.value
.2byte
.long
.4byte
.quad
.8byte
.octa
.single
.float
.double
.align
.align32
.balign
.balignw
.balignl
.p2align
.p2alignw
.p2alignl
.org
.fill
.zero
.extern
.globl
.global
.lazy_reference
.no_dead_strip
.symbol_resolver
.private_extern
.reference
.weak_definition
.weak_reference
.weak_def_can_be_hidden
.comm
.common
.lcomm
.abort
.include
.incbin
.code16
.code16gcc
.rept
.rep
.irp
.irpc
.endr
.bundle_align_mode
.bundle_lock
.bundle_unlock
.ifeq
.ifge
.ifgt
.ifle
.iflt
.ifne
.ifb
.ifnb
.ifc
.ifeqs
.ifnc
.ifnes
.ifdef
.ifndef
.ifnotdef
.elseif
.else
.end
.endif
.skip
.space
.line
.loc
.stabs
.cv_file
.cv_func_id
.cv_loc
.cv_linetable
.cv_inline_linetable
.cv_inline_site_id
.cv_def_range
.cv_stringtable
.cv_filechecksums
.cv_filechecksumoffset
.cv_fpo_data
.sleb128
.uleb128
.cfi_sections
.cfi_startproc
.cfi_endproc
.cfi_def_cfa
.cfi_def_cfa_offset
.cfi_adjust_cfa_offset
.cfi_def_cfa_register
.cfi_offset
.cfi_rel_offset
.cfi_personality
.cfi_lsda
.cfi_remember_state
.cfi_restore_state
.cfi_same_value
.cfi_restore
.cfi_escape
.cfi_return_column
.cfi_signal_frame
.cfi_undefined
.cfi_register
.cfi_window_save
.macros_on
.macros_off
.macro
.exitm
.endm
.endmacro
.purgem
.err
.error
.warning
.altmacro
.noaltmacro
.reloc
.dc.a
.dc.b
.dc.d
.dc.l
.dc.s
.dc.w
.dc.x
.dcb
.dcb.b
.dcb.d
.dcb.l
.dcb.s
.dcb.w
.dcb.x
.ds.b
.ds.d
.ds.l
.ds.p
.ds.s
.ds.w
.ds.x
.print
.addrsig
.addrsig_sym
unmatched .ifs or .elses
unassigned file number: 
 for .file directives
assembler local symbol '
' not defined
directional label undefined
unexpected token at start of statement
invalid use of pseudo-symbol '.' as a label
 not currently supported for this target
unknown directive
parsed instruction: [
unexpected token in '.if' directive
unexpected token in '.ifb' directive
unexpected token in '.ifc' directive
expected string parameter for '.ifeqs' directive
expected string parameter for '.ifnes' directive
expected comma after first string for '.ifeqs' directive
expected comma after first string for '.ifnes' directive
expected identifier after '.ifdef'
unexpected token in '.ifdef'
Encountered a .elseif that doesn't follow an .if or  an .elseif
unexpected token in '.elseif' directive
unexpected token in '.else' directive
Encountered a .else that doesn't follow  an .if or an .elseif
unexpected token in '.endif' directive
Encountered a .endif that doesn't follow an .if or .else
macros cannot be nested more than 
 levels deep.
 Use -asm-macro-max-nesting-depth to increase this limit.
.endmacro
<instantiation>
invalid argument identifier for formal argument
expected '=' after formal parameter identifier
cannot mix positional and keyword arguments
expected absolute expression
parameter named '
' does not exist for macro '
missing value for required parameter '
' in macro '
too many positional arguments
unexpected token in macro instantiation
unbalanced parentheses in macro argument
Wrong number of arguments
expected identifier
 in '
' directive
out of range literal value
unknown token in expression
unexpected token in directive
invalid floating point literal
 in directive
p2align directive with no operand(s) is ignored
invalid alignment value
alignment must be a power of 2
alignment directive can never be satisfied in this many bytes, ignoring maximum bytes expression
maximum bytes expression exceeds alignment and has no effect
 in '.org' directive
unexpected token in '.fill' directive
'.fill' directive with negative size has no effect
'.fill' directive with size greater than 8 has been truncated to 8
'.fill' directive pattern has been truncated to 32-bits
unexpected token in '.zero' directive
non-local symbol required
unable to emit symbol attribute
expected identifier in directive
alignment not supported on this target
unexpected token in '.comm' or '.lcomm' directive
invalid '.comm' or '.lcomm' directive size, can't be less than zero
invalid '.comm' or '.lcomm' directive alignment, can't be less than zero
invalid symbol redefinition
unexpected token in '.abort' directive
.abort detected. Assembly stopping.
.abort '
' detected. Assembly stopping.
expected string in '.include' directive
unexpected token in '.include' directive
Could not find include file '
expected string in '.incbin' directive
unexpected token in '.incbin' directive
skip is negative
Could not find incbin file '
negative count has no effect
unexpected token in '
Count is negative
no matching '.endr' in definition
unexpected token in '.endr' directive
.endr
expected identifier in '.irp' directive
expected comma in '.irp' directive
expected End of Statement
expected identifier in '.irpc' directive
expected comma in '.irpc' directive
unexpected token in '.irpc' directive
expected end of statement
unmatched '.endr' directive
unexpected token after expression in '.bundle_align_mode' directive
invalid bundle alignment size (expected between 0 and 30)
invalid option for '.bundle_lock' directive
unexpected token after '.bundle_lock' directive option
unexpected token in '.bundle_unlock' directive
in '
negative file number
unexpected token in '.file' directive
explicit path specified, but no file number
MD5 checksum specified, but no file number
source specified, but no file number
file 0 not supported prior to DWARF-5
inconsistent use of MD5 checksums
unexpected token in '.line' directive
unexpected token in '.loc' directive
file number less than one in '.loc' directive
unassigned file number in '.loc' directive
line number less than zero in '.loc' directive
column position less than zero in '.loc' directive
is_stmt value not 0 or 1
is_stmt value not the constant value of 0 or 1
isa number less than zero
isa number not a constant value
unknown sub-directive in '.loc' directive
unsupported directive '.stabs'
expected file number in '.cv_file' directive
file number less than one
unexpected token in '.cv_file' directive
expected checksum kind in '.cv_file' directive
file number already allocated
unexpected token in '.cv_func_id' directive
function id already allocated
expected function id in '
expected function id within range [0, UINT_MAX)
expected 'within' identifier in '.cv_inline_site_id' directive
expected 'inlined_at' identifier in '.cv_inline_site_id' directive
expected line number after 'inlined_at'
unexpected token in '.cv_inline_site_id' directive
expected integer in '
file number less than one in '
unassigned file number in '
line number less than zero in '.cv_loc' directive
column position less than zero in '.cv_loc' directive
unexpected token in '.cv_loc' directive
unknown sub-directive in '.cv_loc' directive
unexpected token in '.cv_linetable' directive
expected SourceField in '.cv_inline_linetable' directive
File id less than zero in '.cv_inline_linetable' directive
expected SourceLineNum in '.cv_inline_linetable' directive
Line number less than zero in '.cv_inline_linetable' directive
Expected End of Statement
expected symbol name
unexpected tokens
 in '.cv_fpo_data' directive
Expected an identifier
.eh_frame
.debug_frame
 in '.cfi_startproc' directive
unsupported encoding.
unexpected token in '.cfi_signal_frame'
expected identifier in '.macro' directive
Vararg parameter '
' should be last one in the list of parameters.
macro '
' has multiple parameters named '
missing parameter qualifier for '
 is not a valid parameter qualifier for '
pointless default value for required parameter '
no matching '.endmacro' in definition
' is already defined
macro defined with named parameters which are not used in macro body, possible positional parameter found in body which will have no effect
unexpected '
' in file, no current macro definition
expected identifier in '.purgem' directive
unexpected token in '.purgem' directive
' is not defined
unexpected token in '.end' directive
.err encountered
.error directive invoked in source file
.error argument must be a string
.warning directive invoked in source file
.warning argument must be a string
expected end of statement in '.warning' directive
expression is not a constant value
expression is negative
expected comma
expected relocation name
expression must be relocatable
unexpected token in .reloc directive
unknown relocation name
' directive with negative repeat count has no effect
literal value out of range for directive
expected double quoted string after .print
expected identifier in '.addrsig_sym' directive
unexpected expression in _emit
unexpected expression in align
literal value not a power of two greater then zero
 * $$
 + $$
byte ptr 
word ptr 
dword ptr 
qword ptr 
xword ptr 
xmmword ptr 
ymmword ptr 
.even
while in macro instantiation
unexpected backslash at end of string
invalid octal escape sequence (out of range)
invalid escape sequence (unrecognized character)
unexpected symbol modifier following '@'
invalid variant '
invalid modifier '
' (no symbols present)
invalid variant on expression '
' (already modified)
invalid token in expression
expected symbol variant after '@'
unexpected token in variant, expected ')'
unexpected modifier on variable reference
brackets expression not supported on this target
expected '(' after operator
expected ')' in parentheses expression
expected ']' in brackets expression
expected section directive before assembly directive
.text
.data
.bss
.section
.def
.scl
.type
.endef
.secrel32
.symidx
.safeseh
.secidx
.linkonce
.rva
.seh_proc
.seh_endproc
.seh_startchained
.seh_endchained
.seh_handler
.seh_handlerdata
.seh_pushreg
.seh_setframe
.seh_stackalloc
.seh_savereg
.seh_savexmm
.seh_pushframe
.seh_endprologue
.weak
unexpected token in section switching directive
expected string in directive
expected comdat type such as 'discard' or 'largest' after protection bits
expected comma in directive
conflicting section flags 'b' and 'd'.
unknown flag
one_only
discard
same_size
same_contents
associative
newest
unrecognized COMDAT type '
invalid '.secrel32' directive offset, can't be less than zero or greater than std::numeric_limits<uint32_t>::max()
cannot make section associative with .linkonce
section '
' is already linkonce
invalid '.rva' directive offset, can't be less than -2147483648 or greater than 2147483647
you must specify one or both of @unwind or @except
a handler attribute must begin with '@'
expected @unwind or @except
register can't be represented in SEH unwind info
register number is too high
you must specify a stack pointer offset
you must specify an offset on the stack
expected @code
.alt_entry
.desc
.indirect_symbol
.lsym
.subsections_via_symbols
.dump
.pushsection
.popsection
.previous
.secure_log_unique
.secure_log_reset
.tbss
.zerofill
.data_region
.end_data_region
.const
.const_data
.constructor
.cstring
.destructor
.dyld
.fvmlib_init0
.fvmlib_init1
.lazy_symbol_pointer
.linker_option
.literal16
.literal4
.literal8
.mod_init_func
.mod_term_func
.non_lazy_symbol_pointer
.thread_local_variable_pointer
.objc_cat_cls_meth
.objc_cat_inst_meth
.objc_category
.objc_class
.objc_class_names
.objc_class_vars
.objc_cls_meth
.objc_cls_refs
.objc_inst_meth
.objc_instance_vars
.objc_message_refs
.objc_meta_class
.objc_meth_var_names
.objc_meth_var_types
.objc_module_info
.objc_protocol
.objc_selector_strs
.objc_string_object
.objc_symbols
.picsymbol_stub
.static_const
.static_data
.symbol_stub
.tdata
.thread_init_func
.tlv
.ident
.watchos_version_min
.tvos_version_min
.ios_version_min
.macosx_version_min
.build_version
.alt_entry must preceed symbol definition
unexpected token in '.desc' directive
indirect symbol not in a symbol pointer or stub section
expected identifier in .indirect_symbol directive
non-local symbol required in directive
unable to emit indirect symbol attribute for: 
unexpected token in '.indirect_symbol' directive
unexpected token in '.lsym' directive
directive '.lsym' is unsupported
unexpected token in '.subsections_via_symbols' directive
expected string in '.dump' or '.load' directive
unexpected token in '.dump' or '.load' directive
ignoring directive .dump for now
ignoring directive .load for now
expected identifier after '.section' directive
unexpected token in '.section' directive
__textcoal_nt
__text
__const_coal
__const
__datacoal_nt
__data
section "
" is deprecated
change section name to "
__TEXT
.popsection without corresponding .pushsection
.previous without corresponding .section
unexpected token in '.secure_log_unique' directive
.secure_log_unique specified multiple times
.secure_log_unique used but AS_SECURE_LOG_FILE environment variable unset.
can't open secure log file: 
unexpected token in '.secure_log_reset' directive
unexpected token in '.tbss' directive
invalid '.tbss' directive size, can't be less thanzero
invalid '.tbss' alignment, can't be lessthan zero
__DATA
__thread_bss
expected segment name after '.zerofill' directive
expected section name after comma in '.zerofill' directive
unexpected token in '.zerofill' directive
invalid '.zerofill' directive size, can't be less than zero
invalid '.zerofill' directive alignment, can't be less than zero
expected region type after '.data_region' directive
unknown region type in '.data_region' directive
unexpected token in '.end_data_region' directive
__bss
__constructor
__cstring
__destructor
__dyld
__fvmlib_init0
__fvmlib_init1
__la_symbol_ptr
expected string in '
__literal16
__literal4
__literal8
__mod_init_func
__mod_term_func
__nl_symbol_ptr
__thread_ptr
__OBJC
__cat_cls_meth
__cat_inst_meth
__category
__class
__class_vars
__cls_meth
__cls_refs
__inst_meth
__instance_vars
__message_refs
__meta_class
__module_info
__protocol
__selector_strs
__string_object
__symbols
__picsymbol_stub
__static_const
__static_data
__symbol_stub
__thread_data
__thread_init
__thread_vars
invalid OS major version number, integer expected
invalid OS major version number
OS minor version number required, comma expected
invalid OS minor version number, integer expected
invalid OS minor version number
invalid OS update specifier, comma expected
invalid OS update version number, integer expected
invalid OS update version number
 used while targeting 
overriding previous version directive
previous definition is here
platform name expected
tvos
watchos
unknown platform name
version number required, comma expected
 in '.build_version' directive
.rodata
.data.rel
.data.rel.ro
.size
.symver
.version
.weakref
.local
.protected
.internal
.hidden
.subsection
.cg_profile
.bss.
.fini_array.
.preinit_array.
.tdata.
.tbss.
Section cannot specifiy a group name while also acting as a member of the last group
Mergeable section must specify the type
Group section must specify the type
.note
init_array
fini_array
preinit_array
nobits
progbits
note
llvm_odrtab
llvm_linker_options
llvm_call_graph_profile
unknown section type
DWARF2 only supports one section per compilation unit
expected '@<type>', '%<type>' or "<type>"
expected '%<type>' or "<type>"
expected the entry size
entry size must be positive
expected group name
invalid group name
invalid linkage
Linkage must be 'comdat'
expected metadata symbol
invalid metadata symbol
symbol is not in a section: 
expected 'unique'
expected commma
unique id must be positive
unique id is too large
expected STT_<TYPE_IN_UPPER_CASE>, '#<type>', '%<type>' or "<type>"
expected STT_<TYPE_IN_UPPER_CASE>, '#<type>', '@<type>', '%<type>' or "<type>"
expected symbol type in directive
unsupported attribute in '.type' directive
unexpected token in '.type' directive
unexpected token in '.ident' directive
expected a comma
expected a '@' in the name
unexpected token in '.version' directive
expected integer count in '.cg_profile' directive
unexpected token
A @@ version cannot be undefined
Multiple symbol versions defined for 
No relocation available to represent this relative expression
Cannot represent a difference across sections
.strtab
.llvm.call-graph-profile
.llvm_addrsig
.rela
.rel
.symtab
Undefined temporary symbol
.symtab_shndxr
Size expression must be absolute.
FK_Data_1
FK_Data_2
FK_Data_4
FK_Data_8
FK_PCRel_1
FK_PCRel_2
FK_PCRel_4
FK_PCRel_8
FK_GPRel_1
FK_GPRel_2
FK_GPRel_4
FK_GPRel_8
FK_DTPRel_4
FK_DTPRel_8
FK_TPRel_4
FK_TPRel_8
FK_SecRel_1
FK_SecRel_2
FK_SecRel_4
FK_SecRel_8
FK_Data_Add_1
FK_Data_Add_2
FK_Data_Add_4
FK_Data_Add_8
FK_Data_Sub_1
FK_Data_Sub_2
FK_Data_Sub_4
FK_Data_Sub_8
dwarf-extended-loc
Disable emission of the extended flags in .loc directives.
Default for platform
Enable
Enabled
Disable
Disabled
NO_APP
.code32
.code64
.zero
.ascii
.asciz
.byte
.short
.long
.quad
.globl
.weak
.note.GNU-stack
.weak
expected relocatable expression
unsupported subtraction of qualified symbol
expected assembly-time absolute expression
invalid number of bytes
invalid .org offset '
' (at offset '
Fragment can't be larger than a bundle size
Padding cannot exceed 255 bytes
unable to write NOP sequence of 
 bytes
cannot have fixups in virtual section!
non-zero initializer found in section '
non-zero initializer found in virtual section
sleb128 and uleb128 expressions must be absolute
<MCAssembler
  Sections:[
    
    
  Symbols:[
           
, Index:
undefined .align directive, value size '
' is not a divisor of padding size '
unable to write nop sequence of 
<stdin>
checksum_offset
strtab_begin
strtab_end
filechecksums_begin
filechecksums_end
linetable_begin
linetable_end
Segment for file '
' begins
Allocation failed
as-secure-log-file-name
As secure log file name (initialized from AS_SECURE_LOG_FILE env variable)
AS_SECURE_LOG_FILE
.group
Allocation failed
inconsistent use of embedded source
llvm-mc (based on LLVM 7.0.0)
Unterminated .bundle_lock when changing a section
Symbol: 
 redeclared as different type
Emitting values inside a locked bundle is forbidden
.comment
Reference to undefined temporary symbol 
.bundle_align_mode cannot be changed once set
.bundle_lock forbidden when bundling is disabled
.bundle_unlock forbidden when bundling is disabled
.bundle_unlock without matching lock
Empty bundle-locked group is forbidden
A Bundle can only have one Subtarget.
<<invalid>>
<<none>>
DTPOFF
DTPREL
GOTOFF
GOTREL
GOTPCREL
GOTTPOFF
INDNTPOFF
NTPOFF
GOTNTPOFF
TLSGD
TLSLD
TLSLDM
TPOFF
TPREL
tlscall
tlsdesc
TLVP
TLVPPAGE
TLVPPAGEOFF
PAGE
PAGEOFF
GOTPAGE
GOTPAGEOFF
SECREL32
SIZE
WEAKREF
ABS8
GOT_PREL
target1
target2
prel31
sbrel
tlsldo
tlsdescseq
hlo8
diff8
diff16
diff32
high
higha
highera
highesta
got@l
got@h
got@ha
tocbase
toc@l
toc@h
toc@ha
dtpmod
tprel@l
tprel@h
tprel@ha
tprel@high
tprel@higha
tprel@higher
tprel@highera
tprel@highest
tprel@highesta
dtprel@l
dtprel@h
dtprel@ha
dtprel@high
dtprel@higha
dtprel@higher
dtprel@highera
dtprel@highest
dtprel@highesta
got@tprel
got@tprel@l
got@tprel@h
got@tprel@ha
got@dtprel
got@dtprel@l
got@dtprel@h
got@dtprel@ha
got@tlsgd
got@tlsgd@l
got@tlsgd@h
got@tlsgd@ha
got@tlsld
got@tlsld@l
got@tlsld@h
got@tlsld@ha
tlsld
IMGREL
PCREL
LO16
HI16
GPREL
GDGOT
LDGOT
GDPLT
LDPLT
IEGOT
FUNCTION
TYPEINDEX
gotpcrel32@lo
gotpcrel32@hi
rel32@lo
rel32@hi
rel64
Allocation failed
expression could not be evaluated
' could not be evaluated in a subtraction expression
Common symbol '
' cannot be used in assignment expr
<MCFixup
 Offset:
 Value:
 Kind:
MCAlignFragment
MCDataFragment
MCCompactEncodedInstFragment
MCFillFragment
MCRelaxableFragment
MCOrgFragment
MCDwarfFragment
MCDwarfCallFrameFragment
MCLEBFragment
MCPaddingFragment
MCSymbolIdFragment
MCCVInlineLineTableFragment
MCCVDefRangeTableFragment
MCDummyFragment
<MCFragment 
 LayoutOrder:
 HasInstructions:
 BundlePadding:
 (emit nops)
 Alignment:
 ValueSize:
 MaxBytesToEmit:
 Contents:[
 bytes)
       
 Fixups:[
                
 NumValues:
 Inst:
 AddrDelta:
 LineDelta:
 Signed:
 PaddingPoliciesMask:
 IsInsertionPoint:
 Size:
 InstSize:
 Sym:
 RangeStart:
 RangeEnd:
unable to evaluate offset for variable '
unable to evaluate offset to undefined symbol '
<MCOperand 
INVALID
Reg:
Imm:
FPImm:
Expr:(
Inst:(
<MCInst 
<MCInst #
__eh_frame
__ustring
__common
__gcc_except_tab
__LD
__compact_unwind
__DWARF
__debug_names
debug_names_begin
__apple_names
names_begin
__apple_objc
objc_begin
__apple_namespac
namespac_begin
__apple_types
types_begin
__swift_ast
__debug_abbrev
__debug_info
__debug_line
__debug_line_str
section_line_str
__debug_frame
__debug_pubnames
__debug_pubtypes
__debug_gnu_pubn
__debug_gnu_pubt
__debug_str
__debug_str_offs
section_str_off
__debug_loc
__debug_aranges
__debug_ranges
__debug_rnglists
__debug_macinfo
debug_macinfo
__debug_inlined
__debug_cu_index
__debug_tu_index
__LLVM_STACKMAPS
__llvm_stackmaps
__LLVM_FAULTMAPS
__llvm_faultmaps
.rodata.cst4
.rodata.cst8
.rodata.cst16
.rodata.cst32
.gcc_except_table
.debug_abbrev
.debug_info
.debug_line
.debug_line_str
.debug_pubnames
.debug_pubtypes
.debug_gnu_pubnames
.debug_gnu_pubtypes
.debug_str
.debug_loc
.debug_aranges
.debug_ranges
.debug_macinfo
.debug_names
.apple_names
.apple_objc
.apple_namespaces
.apple_types
.debug_str_offsets
.debug_addr
.debug_rnglists
.debug_info.dwo
.debug_types.dwo
.debug_abbrev.dwo
.debug_str.dwo
.debug_line.dwo
.debug_loc.dwo
.debug_str_offsets.dwo
.debug_rnglists.dwo
.debug_cu_index
.debug_tu_index
.llvm_stackmaps
.llvm_faultmaps
.stack_sizes
.rdata
.debug$S
.debug$T
.debug$H
section_info_dwo
section_types_dwo
section_abbrev_dwo
skel_string
skel_loc
section_str_off_dwo
addr_sec
.drectve
.pdata
.xdata
.sxdata
.gfids$y
.tls$
Cannot initialize MC for non-Windows COFF object files.
Cannot initialize MC for unknown object file format.
value evaluated as 
 is out of range.
This file format doesn't support weak aliases.
Cannot evaluate subsection number
Subsection number out of range
'.fill' directive with negative repeat count has no effect
sec_end
Mismatched bundle_lock/unlock directives
<MCSection
 Fragments:[
      
      
.section
.linkonce
,#alloc
,#execinstr
,#write
,#exclude
,#tls
0x7000001e
unsupported type 0x
 for section 
,comdat
,unique,
.subsection
0123456789_.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
,none,
mach-o section specifier requires a segment whose length is between 1 and 16 characters
mach-o section specifier requires a segment and section separated by a comma
mach-o section specifier requires a section whose length is between 1 and 16 characters
mach-o section specifier uses an unknown section type
mach-o section specifier of type 'symbol_stubs' requires a size specifier
mach-o section specifier has invalid attribute
mach-o section specifier cannot have a stub size specified because it does not have type 'symbol_stubs'
mach-o section specifier has a malformed stub size
regular
S_REGULAR
S_ZEROFILL
cstring_literals
S_CSTRING_LITERALS
4byte_literals
S_4BYTE_LITERALS
8byte_literals
S_8BYTE_LITERALS
literal_pointers
S_LITERAL_POINTERS
non_lazy_symbol_pointers
S_NON_LAZY_SYMBOL_POINTERS
lazy_symbol_pointers
S_LAZY_SYMBOL_POINTERS
symbol_stubs
S_SYMBOL_STUBS
mod_init_funcs
S_MOD_INIT_FUNC_POINTERS
mod_term_funcs
S_MOD_TERM_FUNC_POINTERS
coalesced
S_COALESCED
S_GB_ZEROFILL
interposing
S_INTERPOSING
16byte_literals
S_16BYTE_LITERALS
S_DTRACE_DOF
S_LAZY_DYLIB_SYMBOL_POINTERS
thread_local_regular
S_THREAD_LOCAL_REGULAR
thread_local_zerofill
S_THREAD_LOCAL_ZEROFILL
thread_local_variables
S_THREAD_LOCAL_VARIABLES
thread_local_variable_pointers
S_THREAD_LOCAL_VARIABLE_POINTERS
thread_local_init_function_pointers
S_THREAD_LOCAL_INIT_FUNCTION_POINTERS
pure_instructions
S_ATTR_PURE_INSTRUCTIONS
no_toc
S_ATTR_NO_TOC
strip_static_syms
S_ATTR_STRIP_STATIC_SYMS
no_dead_strip
S_ATTR_NO_DEAD_STRIP
live_support
S_ATTR_LIVE_SUPPORT
self_modifying_code
S_ATTR_SELF_MODIFYING_CODE
debug
S_ATTR_DEBUG
S_ATTR_SOME_INSTRUCTIONS
S_ATTR_EXT_RELOC
S_ATTR_LOC_RELOC
unsupported directive in streamer
this directive must appear between .cfi_startproc and .cfi_endproc directives
parent function id not introduced by .cv_func_id or .cv_inline_site_id
function id not introduced by .cv_func_id or .cv_inline_site_id
all .cv_loc directives for a function must be in the same section
invalid symbol redefinition
starting new .cfi frame before finishing the previous one
.seh_* directives are not supported on this target
.seh_ directive must appear within an active frame
Starting a function before ending the previous one!
Not all chained regions terminated!
End of a chained region outside a chained region!
Chained unwind areas can't have handlers!
Don't know what kind of handler this is!
frame register and offset can be set at most once
offset is not a multiple of 16
frame offset must be less than or equal to 240
stack allocation size must be non-zero
stack allocation size is not a multiple of 8
register save offset is not 8 byte aligned
If present, PushMachFrame must be the first UOP
EmitRawText called on an MCStreamer that doesn't support it,  something must not be fully mc'ized
Unfinished frame!
Symbol name with unsupported characters
help
 Off=
, Sym=
, Addend=
, FixupSection=
symbol '
' can not be undefined in a subtraction expression
.file
 = comdat 
 = type 
; Materializable
; Function Attrs: 
define 
 section "
 align 
 gc "
 prefix 
 prologue 
 personality 
!<unknown kind #
<empty name> 
!DIExpression(
dso_local 
hidden 
protected 
dllimport 
dllexport 
avr_intrcc 
avr_signalcc 
asm 
sideeffect 
alignstack 
inteldialect 
", "
 comdat
<null operand!>
; uselistorder directives
_bb 
, { 
; ModuleID = '
source_filename = "
target datalayout = "
target triple = "
module asm "
attributes #
 = { 
distinct 
<temporary!> 
!DILocation(
!DIGlobalVariableExpression(
!GenericDINode(
operands: {
tag: 
!DISubrange(
!DIEnumerator(
!DIBasicType(
!DIDerivedType(
!DICompositeType(
!DISubroutineType(
!DIFile(
checksumkind: 
!DICompileUnit(
!DISubprogram(
!DILexicalBlock(
!DILexicalBlockFile(
!DINamespace(
!DIModule(
!DITemplateTypeParameter(
!DITemplateValueParameter(
!DIGlobalVariable(
!DILocalVariable(
!DILabel(
!DIObjCProperty(
!DIImportedEntity(
!DIMacro(
type: 
!DIMacroFile(
 = !{
%"type 
 addrspace(
<badref> = 
musttail 
tail 
notail 
 atomic
 weak
 volatile
          cleanup
          catch 
          filter 
 within 
] unwind 
to caller
 void
 unwind 
, ...
          to 
inalloca 
swifterror 
, addrspace(
 fast
 reassoc
 nnan
 ninf
 nsz
 arcp
 contract
 afn
 nuw
 nsw
 exact
 inbounds
 <unknown operation 
 xchg
 add
 sub
 and
 nand
 xor
 max
 min
 umax
 umin
 syncscope("
 ; (
; <label>:
; Error: Block without parent!
 No predecessors!
 preds = 
external 
addrspace(
externally_initialized 
constant 
global 
, section "
thread_local 
thread_local(localdynamic) 
thread_local(initialexec) 
thread_local(localexec) 
alias 
ifunc 
 <<NULL ALIASEE>>
inrange 
<placeholder or erroneous Constant>
 = module: (
path: "
", hash: (
 = typeid: (name: "
) ; guid = 
 = gv: (
name: "
guid: 
, summaries: (
 ; guid = 
(module: ^
, flags: (
linkage: 
, notEligibleToImport: 
, live: 
, dsoLocal: 
, refs: (
, aliasee: 
, insts: 
, funcFlags: (
readNone: 
, readOnly: 
, noRecurse: 
, returnDoesNotAlias: 
, calls: (
(callee: ^
, hotness: 
, relbf: 
, typeIdInfo: (
typeTests: (
vFuncId: (
, offset: 
args: (
, summary: (
, wpdResolutions: (
(offset: 
typeTestRes: (kind: 
, sizeM1BitWidth: 
, alignLog2: 
, sizeM1: 
, bitMask: 
, inlineBits: 
wpdRes: (kind: 
, singleImplName: "
, resByArg: (
, byArg: (kind: 
, info: 
, byte: 
, bit: 
allocsize(
AS =
  { 
PAL[
 => 
profile-sample-accurate
probe-stack
stack-probe-size
min-legal-vector-width
null-pointer-is-valid
nontemporal
cvtu
cvtps2pd
pmovsx
avx512.mask.movshdup.
abs.cond
max.cond
min.cond
ctlz.trunc
ctpop
ctpop.trunc
Broken module found, compilation aborted!
clang.arc.retainAutoreleasedReturnValueMarker
Objective-C Image Info Version
Objective-C Class Properties
llvm.ctlz.
^arm\.neon\.vld([1234]|[234]lane)\.v[a-z0-9]*$
.p0i8
^arm\.neon\.vst([1234]|[234]lane)\.v[a-z0-9]*$
lane
palignr
vpmovm2
llvm.loop.interleave.count
llvm.loop.vectorize.
loop_header_weight
full-set
empty-set
Allocation failed
use-dbg-addr
Use llvm.dbg.addr for all local variables
Address space 0 can never be non-integral
Invalid address space, must be a 24bit integer
Missing size specification for pointer in datalayout string
Invalid pointer size of 0 bytes
Missing alignment specification for pointer in datalayout string
Pointer ABI alignment must be a power of 2
Pointer preferred alignment must be a power of 2
Invalid index size of 0 bytes
Sized aggregate specification in datalayout string
Missing alignment specification in datalayout string
ABI alignment specification must be >0 for non-aggregate types
Zero width native integer type in datalayout string
Unexpected trailing characters after mangling specifier in datalayout string
Expected mangling specifier in datalayout string
Unknown mangling specifier in datalayout string
Unknown mangling in datalayout string
Unknown specifier in datalayout string
Invalid bit width, must be a 24bit integer
Invalid ABI alignment, must be a 16bit integer
Invalid preferred alignment, must be a 16bit integer
Invalid ABI alignment, must be a power of 2
Invalid preferred alignment, must be a power of 2
Preferred alignment cannot be less than the ABI alignment
Trailing separator in datalayout string
Expected token before separator in datalayout string
not a number, or does not fit in an unsigned int
number of bits must be a byte width multiple
Invalid address space, must be a 24-bit integer
Allocation failed
DIFlagZero
DIFlagPrivate
DIFlagProtected
DIFlagPublic
DIFlagFwdDecl
DIFlagAppleBlock
DIFlagBlockByrefStruct
DIFlagVirtual
DIFlagArtificial
DIFlagExplicit
DIFlagPrototyped
DIFlagObjcClassComplete
DIFlagObjectPointer
DIFlagVector
DIFlagStaticMember
DIFlagLValueReference
DIFlagRValueReference
DIFlagReserved
DIFlagSingleInheritance
DIFlagMultipleInheritance
DIFlagVirtualInheritance
DIFlagIntroducedVirtual
DIFlagBitField
DIFlagNoReturn
DIFlagMainSubprogram
DIFlagTypePassByValue
DIFlagTypePassByReference
DIFlagFixedEnum
DIFlagThunk
DIFlagTrivial
DIFlagIndirectVirtualBase
CSK_MD5
CSK_SHA1
NoDebug
FullDebug
LineTablesOnly
pass-remarks
pattern
Enable optimization remarks from passes whose name match the given regular expression
pass-remarks-missed
Enable missed optimization remarks from passes whose name match the given regular expression
pass-remarks-analysis
Enable optimization analysis remarks from passes whose name match the given regular expression
Invalid regular expression '
' in -pass-remarks: 
 at line 
) in 
ignoring debug info with an invalid version (
ignoring invalid debug info in 
 (hotness: 
!Passed
!Missed
!Analysis
!AnalysisFPCommute
!AnalysisAliasing
!Failure
Pass
Name
DebugLoc
Function
Hotness
Args
String
^(\.[0-9]+|[0-9]+(\.[0-9]*)?)([eE][-+]?[0-9]+)?$
File
Line
Column
verify-dom-info
Verify dominator info (time consuming)
Inorder PostDominator Tree: 
Roots: 
PendUpdates:
Insert, 
Delete, 
(no name)
(badref), 
(no_name)
(badref)
DeletedBBs:
(no_name)(
Dominator Tree Construction
domtree
llvm.
aarch64
amdgcn
hexagon
mips
nvvm
r600
s390
xcore
null-pointer-is-valid
true
wasm
not_intrinsic
llvm.addressofreturnaddress
llvm.adjust.trampoline
llvm.annotation
llvm.assume
llvm.bitreverse
llvm.bswap
llvm.canonicalize
llvm.ceil
llvm.clear_cache
llvm.codeview.annotation
llvm.convert.from.fp16
llvm.convert.to.fp16
llvm.copysign
llvm.coro.alloc
llvm.coro.begin
llvm.coro.destroy
llvm.coro.done
llvm.coro.end
llvm.coro.frame
llvm.coro.free
llvm.coro.id
llvm.coro.noop
llvm.coro.param
llvm.coro.promise
llvm.coro.resume
llvm.coro.save
llvm.coro.size
llvm.coro.subfn.addr
llvm.coro.suspend
llvm.cos
llvm.ctlz
llvm.ctpop
llvm.cttz
llvm.dbg.addr
llvm.dbg.declare
llvm.dbg.label
llvm.dbg.value
llvm.debugtrap
llvm.donothing
llvm.eh.dwarf.cfa
llvm.eh.exceptioncode
llvm.eh.exceptionpointer
llvm.eh.return.i32
llvm.eh.return.i64
llvm.eh.sjlj.callsite
llvm.eh.sjlj.functioncontext
llvm.eh.sjlj.longjmp
llvm.eh.sjlj.lsda
llvm.eh.sjlj.setjmp
llvm.eh.sjlj.setup.dispatch
llvm.eh.typeid.for
llvm.eh.unwind.init
llvm.exp
llvm.exp2
llvm.expect
llvm.experimental.constrained.cos
llvm.experimental.constrained.exp
llvm.experimental.constrained.exp2
llvm.experimental.constrained.fadd
llvm.experimental.constrained.fdiv
llvm.experimental.constrained.fma
llvm.experimental.constrained.fmul
llvm.experimental.constrained.frem
llvm.experimental.constrained.fsub
llvm.experimental.constrained.log
llvm.experimental.constrained.log10
llvm.experimental.constrained.log2
llvm.experimental.constrained.nearbyint
llvm.experimental.constrained.pow
llvm.experimental.constrained.powi
llvm.experimental.constrained.rint
llvm.experimental.constrained.sin
llvm.experimental.constrained.sqrt
llvm.experimental.deoptimize
llvm.experimental.gc.relocate
llvm.experimental.gc.result
llvm.experimental.gc.statepoint
llvm.experimental.guard
llvm.experimental.patchpoint.i64
llvm.experimental.patchpoint.void
llvm.experimental.stackmap
llvm.experimental.vector.reduce.add
llvm.experimental.vector.reduce.and
llvm.experimental.vector.reduce.fadd
llvm.experimental.vector.reduce.fmax
llvm.experimental.vector.reduce.fmin
llvm.experimental.vector.reduce.fmul
llvm.experimental.vector.reduce.mul
llvm.experimental.vector.reduce.or
llvm.experimental.vector.reduce.smax
llvm.experimental.vector.reduce.smin
llvm.experimental.vector.reduce.umax
llvm.experimental.vector.reduce.umin
llvm.experimental.vector.reduce.xor
llvm.fabs
llvm.floor
llvm.flt.rounds
llvm.fma
llvm.fmuladd
llvm.frameaddress
llvm.fshl
llvm.fshr
llvm.gcread
llvm.gcroot
llvm.gcwrite
llvm.get.dynamic.area.offset
llvm.icall.branch.funnel
llvm.init.trampoline
llvm.instrprof.increment
llvm.instrprof.increment.step
llvm.instrprof.value.profile
llvm.invariant.end
llvm.invariant.start
llvm.launder.invariant.group
llvm.lifetime.end
llvm.lifetime.start
llvm.load.relative
llvm.localaddress
llvm.localescape
llvm.localrecover
llvm.log
llvm.log10
llvm.log2
llvm.longjmp
llvm.masked.compressstore
llvm.masked.expandload
llvm.masked.gather
llvm.masked.load
llvm.masked.scatter
llvm.masked.store
llvm.maxnum
llvm.memcpy
llvm.memcpy.element.unordered.atomic
llvm.memmove
llvm.memmove.element.unordered.atomic
llvm.memset
llvm.memset.element.unordered.atomic
llvm.minnum
llvm.nearbyint
llvm.objectsize
llvm.pcmarker
llvm.pow
llvm.powi
llvm.prefetch
llvm.ptr.annotation
llvm.read_register
llvm.readcyclecounter
llvm.returnaddress
llvm.rint
llvm.round
llvm.sadd.with.overflow
llvm.setjmp
llvm.sideeffect
llvm.siglongjmp
llvm.sigsetjmp
llvm.sin
llvm.smul.with.overflow
llvm.sqrt
llvm.ssa.copy
llvm.ssub.with.overflow
llvm.stackguard
llvm.stackprotector
llvm.stackrestore
llvm.stacksave
llvm.strip.invariant.group
llvm.thread.pointer
llvm.trap
llvm.trunc
llvm.type.checked.load
llvm.type.test
llvm.uadd.with.overflow
llvm.umul.with.overflow
llvm.usub.with.overflow
llvm.va_copy
llvm.va_end
llvm.va_start
llvm.var.annotation
llvm.write_register
llvm.xray.customevent
llvm.xray.typedevent
llvm.aarch64.clrex
llvm.aarch64.crc32b
llvm.aarch64.crc32cb
llvm.aarch64.crc32ch
llvm.aarch64.crc32cw
llvm.aarch64.crc32cx
llvm.aarch64.crc32h
llvm.aarch64.crc32w
llvm.aarch64.crc32x
llvm.aarch64.crypto.aesd
llvm.aarch64.crypto.aese
llvm.aarch64.crypto.aesimc
llvm.aarch64.crypto.aesmc
llvm.aarch64.crypto.sha1c
llvm.aarch64.crypto.sha1h
llvm.aarch64.crypto.sha1m
llvm.aarch64.crypto.sha1p
llvm.aarch64.crypto.sha1su0
llvm.aarch64.crypto.sha1su1
llvm.aarch64.crypto.sha256h
llvm.aarch64.crypto.sha256h2
llvm.aarch64.crypto.sha256su0
llvm.aarch64.crypto.sha256su1
llvm.aarch64.dmb
llvm.aarch64.dsb
llvm.aarch64.get.fpcr
llvm.aarch64.hint
llvm.aarch64.isb
llvm.aarch64.ldaxp
llvm.aarch64.ldaxr
llvm.aarch64.ldxp
llvm.aarch64.ldxr
llvm.aarch64.neon.abs
llvm.aarch64.neon.addhn
llvm.aarch64.neon.addp
llvm.aarch64.neon.cls
llvm.aarch64.neon.fabd
llvm.aarch64.neon.facge
llvm.aarch64.neon.facgt
llvm.aarch64.neon.faddv
llvm.aarch64.neon.fcvtas
llvm.aarch64.neon.fcvtau
llvm.aarch64.neon.fcvtms
llvm.aarch64.neon.fcvtmu
llvm.aarch64.neon.fcvtns
llvm.aarch64.neon.fcvtnu
llvm.aarch64.neon.fcvtps
llvm.aarch64.neon.fcvtpu
llvm.aarch64.neon.fcvtxn
llvm.aarch64.neon.fcvtzs
llvm.aarch64.neon.fcvtzu
llvm.aarch64.neon.fmax
llvm.aarch64.neon.fmaxnm
llvm.aarch64.neon.fmaxnmp
llvm.aarch64.neon.fmaxnmv
llvm.aarch64.neon.fmaxp
llvm.aarch64.neon.fmaxv
llvm.aarch64.neon.fmin
llvm.aarch64.neon.fminnm
llvm.aarch64.neon.fminnmp
llvm.aarch64.neon.fminnmv
llvm.aarch64.neon.fminp
llvm.aarch64.neon.fminv
llvm.aarch64.neon.fmulx
llvm.aarch64.neon.frecpe
llvm.aarch64.neon.frecps
llvm.aarch64.neon.frecpx
llvm.aarch64.neon.frintn
llvm.aarch64.neon.frsqrte
llvm.aarch64.neon.frsqrts
llvm.aarch64.neon.ld1x2
llvm.aarch64.neon.ld1x3
llvm.aarch64.neon.ld1x4
llvm.aarch64.neon.ld2
llvm.aarch64.neon.ld2lane
llvm.aarch64.neon.ld2r
llvm.aarch64.neon.ld3
llvm.aarch64.neon.ld3lane
llvm.aarch64.neon.ld3r
llvm.aarch64.neon.ld4
llvm.aarch64.neon.ld4lane
llvm.aarch64.neon.ld4r
llvm.aarch64.neon.pmul
llvm.aarch64.neon.pmull
llvm.aarch64.neon.pmull64
llvm.aarch64.neon.raddhn
llvm.aarch64.neon.rbit
llvm.aarch64.neon.rshrn
llvm.aarch64.neon.rsubhn
llvm.aarch64.neon.sabd
llvm.aarch64.neon.saddlp
llvm.aarch64.neon.saddlv
llvm.aarch64.neon.saddv
llvm.aarch64.neon.scalar.sqxtn
llvm.aarch64.neon.scalar.sqxtun
llvm.aarch64.neon.scalar.uqxtn
llvm.aarch64.neon.sdot
llvm.aarch64.neon.shadd
llvm.aarch64.neon.shll
llvm.aarch64.neon.shsub
llvm.aarch64.neon.smax
llvm.aarch64.neon.smaxp
llvm.aarch64.neon.smaxv
llvm.aarch64.neon.smin
llvm.aarch64.neon.sminp
llvm.aarch64.neon.sminv
llvm.aarch64.neon.smull
llvm.aarch64.neon.sqabs
llvm.aarch64.neon.sqadd
llvm.aarch64.neon.sqdmulh
llvm.aarch64.neon.sqdmull
llvm.aarch64.neon.sqdmulls.scalar
llvm.aarch64.neon.sqneg
llvm.aarch64.neon.sqrdmulh
llvm.aarch64.neon.sqrshl
llvm.aarch64.neon.sqrshrn
llvm.aarch64.neon.sqrshrun
llvm.aarch64.neon.sqshl
llvm.aarch64.neon.sqshlu
llvm.aarch64.neon.sqshrn
llvm.aarch64.neon.sqshrun
llvm.aarch64.neon.sqsub
llvm.aarch64.neon.sqxtn
llvm.aarch64.neon.sqxtun
llvm.aarch64.neon.srhadd
llvm.aarch64.neon.srshl
llvm.aarch64.neon.sshl
llvm.aarch64.neon.sshll
llvm.aarch64.neon.st1x2
llvm.aarch64.neon.st1x3
llvm.aarch64.neon.st1x4
llvm.aarch64.neon.st2
llvm.aarch64.neon.st2lane
llvm.aarch64.neon.st3
llvm.aarch64.neon.st3lane
llvm.aarch64.neon.st4
llvm.aarch64.neon.st4lane
llvm.aarch64.neon.subhn
llvm.aarch64.neon.suqadd
llvm.aarch64.neon.tbl1
llvm.aarch64.neon.tbl2
llvm.aarch64.neon.tbl3
llvm.aarch64.neon.tbl4
llvm.aarch64.neon.tbx1
llvm.aarch64.neon.tbx2
llvm.aarch64.neon.tbx3
llvm.aarch64.neon.tbx4
llvm.aarch64.neon.uabd
llvm.aarch64.neon.uaddlp
llvm.aarch64.neon.uaddlv
llvm.aarch64.neon.uaddv
llvm.aarch64.neon.udot
llvm.aarch64.neon.uhadd
llvm.aarch64.neon.uhsub
llvm.aarch64.neon.umax
llvm.aarch64.neon.umaxp
llvm.aarch64.neon.umaxv
llvm.aarch64.neon.umin
llvm.aarch64.neon.uminp
llvm.aarch64.neon.uminv
llvm.aarch64.neon.umull
llvm.aarch64.neon.uqadd
llvm.aarch64.neon.uqrshl
llvm.aarch64.neon.uqrshrn
llvm.aarch64.neon.uqshl
llvm.aarch64.neon.uqshrn
llvm.aarch64.neon.uqsub
llvm.aarch64.neon.uqxtn
llvm.aarch64.neon.urecpe
llvm.aarch64.neon.urhadd
llvm.aarch64.neon.urshl
llvm.aarch64.neon.ursqrte
llvm.aarch64.neon.ushl
llvm.aarch64.neon.ushll
llvm.aarch64.neon.usqadd
llvm.aarch64.neon.vcopy.lane
llvm.aarch64.neon.vcvtfp2fxs
llvm.aarch64.neon.vcvtfp2fxu
llvm.aarch64.neon.vcvtfp2hf
llvm.aarch64.neon.vcvtfxs2fp
llvm.aarch64.neon.vcvtfxu2fp
llvm.aarch64.neon.vcvthf2fp
llvm.aarch64.neon.vsli
llvm.aarch64.neon.vsri
llvm.aarch64.sdiv
llvm.aarch64.sisd.fabd
llvm.aarch64.sisd.fcvtxn
llvm.aarch64.stlxp
llvm.aarch64.stlxr
llvm.aarch64.stxp
llvm.aarch64.stxr
llvm.aarch64.udiv
llvm.amdgcn.alignbit
llvm.amdgcn.alignbyte
llvm.amdgcn.atomic.dec
llvm.amdgcn.atomic.inc
llvm.amdgcn.break
llvm.amdgcn.buffer.atomic.add
llvm.amdgcn.buffer.atomic.and
llvm.amdgcn.buffer.atomic.cmpswap
llvm.amdgcn.buffer.atomic.or
llvm.amdgcn.buffer.atomic.smax
llvm.amdgcn.buffer.atomic.smin
llvm.amdgcn.buffer.atomic.sub
llvm.amdgcn.buffer.atomic.swap
llvm.amdgcn.buffer.atomic.umax
llvm.amdgcn.buffer.atomic.umin
llvm.amdgcn.buffer.atomic.xor
llvm.amdgcn.buffer.load
llvm.amdgcn.buffer.load.format
llvm.amdgcn.buffer.store
llvm.amdgcn.buffer.store.format
llvm.amdgcn.buffer.wbinvl1
llvm.amdgcn.buffer.wbinvl1.sc
llvm.amdgcn.buffer.wbinvl1.vol
llvm.amdgcn.class
llvm.amdgcn.cos
llvm.amdgcn.cubeid
llvm.amdgcn.cubema
llvm.amdgcn.cubesc
llvm.amdgcn.cubetc
llvm.amdgcn.cvt.pk.i16
llvm.amdgcn.cvt.pk.u16
llvm.amdgcn.cvt.pk.u8.f32
llvm.amdgcn.cvt.pknorm.i16
llvm.amdgcn.cvt.pknorm.u16
llvm.amdgcn.cvt.pkrtz
llvm.amdgcn.dispatch.id
llvm.amdgcn.dispatch.ptr
llvm.amdgcn.div.fixup
llvm.amdgcn.div.fmas
llvm.amdgcn.div.scale
llvm.amdgcn.ds.bpermute
llvm.amdgcn.ds.fadd
llvm.amdgcn.ds.fmax
llvm.amdgcn.ds.fmin
llvm.amdgcn.ds.permute
llvm.amdgcn.ds.swizzle
llvm.amdgcn.else
llvm.amdgcn.else.break
llvm.amdgcn.end.cf
llvm.amdgcn.exp
llvm.amdgcn.exp.compr
llvm.amdgcn.fcmp
llvm.amdgcn.fdiv.fast
llvm.amdgcn.fdot2
llvm.amdgcn.fmad.ftz
llvm.amdgcn.fmed3
llvm.amdgcn.fmul.legacy
llvm.amdgcn.fract
llvm.amdgcn.frexp.exp
llvm.amdgcn.frexp.mant
llvm.amdgcn.groupstaticsize
llvm.amdgcn.icmp
llvm.amdgcn.if
llvm.amdgcn.if.break
llvm.amdgcn.image.atomic.add.1d
llvm.amdgcn.image.atomic.add.1darray
llvm.amdgcn.image.atomic.add.2d
llvm.amdgcn.image.atomic.add.2darray
llvm.amdgcn.image.atomic.add.2darraymsaa
llvm.amdgcn.image.atomic.add.2dmsaa
llvm.amdgcn.image.atomic.add.3d
llvm.amdgcn.image.atomic.add.cube
llvm.amdgcn.image.atomic.and.1d
llvm.amdgcn.image.atomic.and.1darray
llvm.amdgcn.image.atomic.and.2d
llvm.amdgcn.image.atomic.and.2darray
llvm.amdgcn.image.atomic.and.2darraymsaa
llvm.amdgcn.image.atomic.and.2dmsaa
llvm.amdgcn.image.atomic.and.3d
llvm.amdgcn.image.atomic.and.cube
llvm.amdgcn.image.atomic.cmpswap.1d
llvm.amdgcn.image.atomic.cmpswap.1darray
llvm.amdgcn.image.atomic.cmpswap.2d
llvm.amdgcn.image.atomic.cmpswap.2darray
llvm.amdgcn.image.atomic.cmpswap.2darraymsaa
llvm.amdgcn.image.atomic.cmpswap.2dmsaa
llvm.amdgcn.image.atomic.cmpswap.3d
llvm.amdgcn.image.atomic.cmpswap.cube
llvm.amdgcn.image.atomic.dec.1d
llvm.amdgcn.image.atomic.dec.1darray
llvm.amdgcn.image.atomic.dec.2d
llvm.amdgcn.image.atomic.dec.2darray
llvm.amdgcn.image.atomic.dec.2darraymsaa
llvm.amdgcn.image.atomic.dec.2dmsaa
llvm.amdgcn.image.atomic.dec.3d
llvm.amdgcn.image.atomic.dec.cube
llvm.amdgcn.image.atomic.inc.1d
llvm.amdgcn.image.atomic.inc.1darray
llvm.amdgcn.image.atomic.inc.2d
llvm.amdgcn.image.atomic.inc.2darray
llvm.amdgcn.image.atomic.inc.2darraymsaa
llvm.amdgcn.image.atomic.inc.2dmsaa
llvm.amdgcn.image.atomic.inc.3d
llvm.amdgcn.image.atomic.inc.cube
llvm.amdgcn.image.atomic.or.1d
llvm.amdgcn.image.atomic.or.1darray
llvm.amdgcn.image.atomic.or.2d
llvm.amdgcn.image.atomic.or.2darray
llvm.amdgcn.image.atomic.or.2darraymsaa
llvm.amdgcn.image.atomic.or.2dmsaa
llvm.amdgcn.image.atomic.or.3d
llvm.amdgcn.image.atomic.or.cube
llvm.amdgcn.image.atomic.smax.1d
llvm.amdgcn.image.atomic.smax.1darray
llvm.amdgcn.image.atomic.smax.2d
llvm.amdgcn.image.atomic.smax.2darray
llvm.amdgcn.image.atomic.smax.2darraymsaa
llvm.amdgcn.image.atomic.smax.2dmsaa
llvm.amdgcn.image.atomic.smax.3d
llvm.amdgcn.image.atomic.smax.cube
llvm.amdgcn.image.atomic.smin.1d
llvm.amdgcn.image.atomic.smin.1darray
llvm.amdgcn.image.atomic.smin.2d
llvm.amdgcn.image.atomic.smin.2darray
llvm.amdgcn.image.atomic.smin.2darraymsaa
llvm.amdgcn.image.atomic.smin.2dmsaa
llvm.amdgcn.image.atomic.smin.3d
llvm.amdgcn.image.atomic.smin.cube
llvm.amdgcn.image.atomic.sub.1d
llvm.amdgcn.image.atomic.sub.1darray
llvm.amdgcn.image.atomic.sub.2d
llvm.amdgcn.image.atomic.sub.2darray
llvm.amdgcn.image.atomic.sub.2darraymsaa
llvm.amdgcn.image.atomic.sub.2dmsaa
llvm.amdgcn.image.atomic.sub.3d
llvm.amdgcn.image.atomic.sub.cube
llvm.amdgcn.image.atomic.swap.1d
llvm.amdgcn.image.atomic.swap.1darray
llvm.amdgcn.image.atomic.swap.2d
llvm.amdgcn.image.atomic.swap.2darray
llvm.amdgcn.image.atomic.swap.2darraymsaa
llvm.amdgcn.image.atomic.swap.2dmsaa
llvm.amdgcn.image.atomic.swap.3d
llvm.amdgcn.image.atomic.swap.cube
llvm.amdgcn.image.atomic.umax.1d
llvm.amdgcn.image.atomic.umax.1darray
llvm.amdgcn.image.atomic.umax.2d
llvm.amdgcn.image.atomic.umax.2darray
llvm.amdgcn.image.atomic.umax.2darraymsaa
llvm.amdgcn.image.atomic.umax.2dmsaa
llvm.amdgcn.image.atomic.umax.3d
llvm.amdgcn.image.atomic.umax.cube
llvm.amdgcn.image.atomic.umin.1d
llvm.amdgcn.image.atomic.umin.1darray
llvm.amdgcn.image.atomic.umin.2d
llvm.amdgcn.image.atomic.umin.2darray
llvm.amdgcn.image.atomic.umin.2darraymsaa
llvm.amdgcn.image.atomic.umin.2dmsaa
llvm.amdgcn.image.atomic.umin.3d
llvm.amdgcn.image.atomic.umin.cube
llvm.amdgcn.image.atomic.xor.1d
llvm.amdgcn.image.atomic.xor.1darray
llvm.amdgcn.image.atomic.xor.2d
llvm.amdgcn.image.atomic.xor.2darray
llvm.amdgcn.image.atomic.xor.2darraymsaa
llvm.amdgcn.image.atomic.xor.2dmsaa
llvm.amdgcn.image.atomic.xor.3d
llvm.amdgcn.image.atomic.xor.cube
llvm.amdgcn.image.gather4.2d
llvm.amdgcn.image.gather4.2darray
llvm.amdgcn.image.gather4.b.2d
llvm.amdgcn.image.gather4.b.2darray
llvm.amdgcn.image.gather4.b.cl.2d
llvm.amdgcn.image.gather4.b.cl.2darray
llvm.amdgcn.image.gather4.b.cl.cube
llvm.amdgcn.image.gather4.b.cl.o.2d
llvm.amdgcn.image.gather4.b.cl.o.2darray
llvm.amdgcn.image.gather4.b.cl.o.cube
llvm.amdgcn.image.gather4.b.cube
llvm.amdgcn.image.gather4.b.o.2d
llvm.amdgcn.image.gather4.b.o.2darray
llvm.amdgcn.image.gather4.b.o.cube
llvm.amdgcn.image.gather4.c.2d
llvm.amdgcn.image.gather4.c.2darray
llvm.amdgcn.image.gather4.c.b.2d
llvm.amdgcn.image.gather4.c.b.2darray
llvm.amdgcn.image.gather4.c.b.cl.2d
llvm.amdgcn.image.gather4.c.b.cl.2darray
llvm.amdgcn.image.gather4.c.b.cl.cube
llvm.amdgcn.image.gather4.c.b.cl.o.2d
llvm.amdgcn.image.gather4.c.b.cl.o.2darray
llvm.amdgcn.image.gather4.c.b.cl.o.cube
llvm.amdgcn.image.gather4.c.b.cube
llvm.amdgcn.image.gather4.c.b.o.2d
llvm.amdgcn.image.gather4.c.b.o.2darray
llvm.amdgcn.image.gather4.c.b.o.cube
llvm.amdgcn.image.gather4.c.cl.2d
llvm.amdgcn.image.gather4.c.cl.2darray
llvm.amdgcn.image.gather4.c.cl.cube
llvm.amdgcn.image.gather4.c.cl.o.2d
llvm.amdgcn.image.gather4.c.cl.o.2darray
llvm.amdgcn.image.gather4.c.cl.o.cube
llvm.amdgcn.image.gather4.c.cube
llvm.amdgcn.image.gather4.c.l.2d
llvm.amdgcn.image.gather4.c.l.2darray
llvm.amdgcn.image.gather4.c.l.cube
llvm.amdgcn.image.gather4.c.l.o.2d
llvm.amdgcn.image.gather4.c.l.o.2darray
llvm.amdgcn.image.gather4.c.l.o.cube
llvm.amdgcn.image.gather4.c.lz.2d
llvm.amdgcn.image.gather4.c.lz.2darray
llvm.amdgcn.image.gather4.c.lz.cube
llvm.amdgcn.image.gather4.c.lz.o.2d
llvm.amdgcn.image.gather4.c.lz.o.2darray
llvm.amdgcn.image.gather4.c.lz.o.cube
llvm.amdgcn.image.gather4.c.o.2d
llvm.amdgcn.image.gather4.c.o.2darray
llvm.amdgcn.image.gather4.c.o.cube
llvm.amdgcn.image.gather4.cl.2d
llvm.amdgcn.image.gather4.cl.2darray
llvm.amdgcn.image.gather4.cl.cube
llvm.amdgcn.image.gather4.cl.o.2d
llvm.amdgcn.image.gather4.cl.o.2darray
llvm.amdgcn.image.gather4.cl.o.cube
llvm.amdgcn.image.gather4.cube
llvm.amdgcn.image.gather4.l.2d
llvm.amdgcn.image.gather4.l.2darray
llvm.amdgcn.image.gather4.l.cube
llvm.amdgcn.image.gather4.l.o.2d
llvm.amdgcn.image.gather4.l.o.2darray
llvm.amdgcn.image.gather4.l.o.cube
llvm.amdgcn.image.gather4.lz.2d
llvm.amdgcn.image.gather4.lz.2darray
llvm.amdgcn.image.gather4.lz.cube
llvm.amdgcn.image.gather4.lz.o.2d
llvm.amdgcn.image.gather4.lz.o.2darray
llvm.amdgcn.image.gather4.lz.o.cube
llvm.amdgcn.image.gather4.o.2d
llvm.amdgcn.image.gather4.o.2darray
llvm.amdgcn.image.gather4.o.cube
llvm.amdgcn.image.getlod.1d
llvm.amdgcn.image.getlod.1darray
llvm.amdgcn.image.getlod.2d
llvm.amdgcn.image.getlod.2darray
llvm.amdgcn.image.getlod.3d
llvm.amdgcn.image.getlod.cube
llvm.amdgcn.image.getresinfo.1d
llvm.amdgcn.image.getresinfo.1darray
llvm.amdgcn.image.getresinfo.2d
llvm.amdgcn.image.getresinfo.2darray
llvm.amdgcn.image.getresinfo.2darraymsaa
llvm.amdgcn.image.getresinfo.2dmsaa
llvm.amdgcn.image.getresinfo.3d
llvm.amdgcn.image.getresinfo.cube
llvm.amdgcn.image.load.1d
llvm.amdgcn.image.load.1darray
llvm.amdgcn.image.load.2d
llvm.amdgcn.image.load.2darray
llvm.amdgcn.image.load.2darraymsaa
llvm.amdgcn.image.load.2dmsaa
llvm.amdgcn.image.load.3d
llvm.amdgcn.image.load.cube
llvm.amdgcn.image.load.mip.1d
llvm.amdgcn.image.load.mip.1darray
llvm.amdgcn.image.load.mip.2d
llvm.amdgcn.image.load.mip.2darray
llvm.amdgcn.image.load.mip.3d
llvm.amdgcn.image.load.mip.cube
llvm.amdgcn.image.sample.1d
llvm.amdgcn.image.sample.1darray
llvm.amdgcn.image.sample.2d
llvm.amdgcn.image.sample.2darray
llvm.amdgcn.image.sample.3d
llvm.amdgcn.image.sample.b.1d
llvm.amdgcn.image.sample.b.1darray
llvm.amdgcn.image.sample.b.2d
llvm.amdgcn.image.sample.b.2darray
llvm.amdgcn.image.sample.b.3d
llvm.amdgcn.image.sample.b.cl.1d
llvm.amdgcn.image.sample.b.cl.1darray
llvm.amdgcn.image.sample.b.cl.2d
llvm.amdgcn.image.sample.b.cl.2darray
llvm.amdgcn.image.sample.b.cl.3d
llvm.amdgcn.image.sample.b.cl.cube
llvm.amdgcn.image.sample.b.cl.o.1d
llvm.amdgcn.image.sample.b.cl.o.1darray
llvm.amdgcn.image.sample.b.cl.o.2d
llvm.amdgcn.image.sample.b.cl.o.2darray
llvm.amdgcn.image.sample.b.cl.o.3d
llvm.amdgcn.image.sample.b.cl.o.cube
llvm.amdgcn.image.sample.b.cube
llvm.amdgcn.image.sample.b.o.1d
llvm.amdgcn.image.sample.b.o.1darray
llvm.amdgcn.image.sample.b.o.2d
llvm.amdgcn.image.sample.b.o.2darray
llvm.amdgcn.image.sample.b.o.3d
llvm.amdgcn.image.sample.b.o.cube
llvm.amdgcn.image.sample.c.1d
llvm.amdgcn.image.sample.c.1darray
llvm.amdgcn.image.sample.c.2d
llvm.amdgcn.image.sample.c.2darray
llvm.amdgcn.image.sample.c.3d
llvm.amdgcn.image.sample.c.b.1d
llvm.amdgcn.image.sample.c.b.1darray
llvm.amdgcn.image.sample.c.b.2d
llvm.amdgcn.image.sample.c.b.2darray
llvm.amdgcn.image.sample.c.b.3d
llvm.amdgcn.image.sample.c.b.cl.1d
llvm.amdgcn.image.sample.c.b.cl.1darray
llvm.amdgcn.image.sample.c.b.cl.2d
llvm.amdgcn.image.sample.c.b.cl.2darray
llvm.amdgcn.image.sample.c.b.cl.3d
llvm.amdgcn.image.sample.c.b.cl.cube
llvm.amdgcn.image.sample.c.b.cl.o.1d
llvm.amdgcn.image.sample.c.b.cl.o.1darray
llvm.amdgcn.image.sample.c.b.cl.o.2d
llvm.amdgcn.image.sample.c.b.cl.o.2darray
llvm.amdgcn.image.sample.c.b.cl.o.3d
llvm.amdgcn.image.sample.c.b.cl.o.cube
llvm.amdgcn.image.sample.c.b.cube
llvm.amdgcn.image.sample.c.b.o.1d
llvm.amdgcn.image.sample.c.b.o.1darray
llvm.amdgcn.image.sample.c.b.o.2d
llvm.amdgcn.image.sample.c.b.o.2darray
llvm.amdgcn.image.sample.c.b.o.3d
llvm.amdgcn.image.sample.c.b.o.cube
llvm.amdgcn.image.sample.c.cd.1d
llvm.amdgcn.image.sample.c.cd.1darray
llvm.amdgcn.image.sample.c.cd.2d
llvm.amdgcn.image.sample.c.cd.2darray
llvm.amdgcn.image.sample.c.cd.3d
llvm.amdgcn.image.sample.c.cd.cl.1d
llvm.amdgcn.image.sample.c.cd.cl.1darray
llvm.amdgcn.image.sample.c.cd.cl.2d
llvm.amdgcn.image.sample.c.cd.cl.2darray
llvm.amdgcn.image.sample.c.cd.cl.3d
llvm.amdgcn.image.sample.c.cd.cl.cube
llvm.amdgcn.image.sample.c.cd.cl.o.1d
llvm.amdgcn.image.sample.c.cd.cl.o.1darray
llvm.amdgcn.image.sample.c.cd.cl.o.2d
llvm.amdgcn.image.sample.c.cd.cl.o.2darray
llvm.amdgcn.image.sample.c.cd.cl.o.3d
llvm.amdgcn.image.sample.c.cd.cl.o.cube
llvm.amdgcn.image.sample.c.cd.cube
llvm.amdgcn.image.sample.c.cd.o.1d
llvm.amdgcn.image.sample.c.cd.o.1darray
llvm.amdgcn.image.sample.c.cd.o.2d
llvm.amdgcn.image.sample.c.cd.o.2darray
llvm.amdgcn.image.sample.c.cd.o.3d
llvm.amdgcn.image.sample.c.cd.o.cube
llvm.amdgcn.image.sample.c.cl.1d
llvm.amdgcn.image.sample.c.cl.1darray
llvm.amdgcn.image.sample.c.cl.2d
llvm.amdgcn.image.sample.c.cl.2darray
llvm.amdgcn.image.sample.c.cl.3d
llvm.amdgcn.image.sample.c.cl.cube
llvm.amdgcn.image.sample.c.cl.o.1d
llvm.amdgcn.image.sample.c.cl.o.1darray
llvm.amdgcn.image.sample.c.cl.o.2d
llvm.amdgcn.image.sample.c.cl.o.2darray
llvm.amdgcn.image.sample.c.cl.o.3d
llvm.amdgcn.image.sample.c.cl.o.cube
llvm.amdgcn.image.sample.c.cube
llvm.amdgcn.image.sample.c.d.1d
llvm.amdgcn.image.sample.c.d.1darray
llvm.amdgcn.image.sample.c.d.2d
llvm.amdgcn.image.sample.c.d.2darray
llvm.amdgcn.image.sample.c.d.3d
llvm.amdgcn.image.sample.c.d.cl.1d
llvm.amdgcn.image.sample.c.d.cl.1darray
llvm.amdgcn.image.sample.c.d.cl.2d
llvm.amdgcn.image.sample.c.d.cl.2darray
llvm.amdgcn.image.sample.c.d.cl.3d
llvm.amdgcn.image.sample.c.d.cl.cube
llvm.amdgcn.image.sample.c.d.cl.o.1d
llvm.amdgcn.image.sample.c.d.cl.o.1darray
llvm.amdgcn.image.sample.c.d.cl.o.2d
llvm.amdgcn.image.sample.c.d.cl.o.2darray
llvm.amdgcn.image.sample.c.d.cl.o.3d
llvm.amdgcn.image.sample.c.d.cl.o.cube
llvm.amdgcn.image.sample.c.d.cube
llvm.amdgcn.image.sample.c.d.o.1d
llvm.amdgcn.image.sample.c.d.o.1darray
llvm.amdgcn.image.sample.c.d.o.2d
llvm.amdgcn.image.sample.c.d.o.2darray
llvm.amdgcn.image.sample.c.d.o.3d
llvm.amdgcn.image.sample.c.d.o.cube
llvm.amdgcn.image.sample.c.l.1d
llvm.amdgcn.image.sample.c.l.1darray
llvm.amdgcn.image.sample.c.l.2d
llvm.amdgcn.image.sample.c.l.2darray
llvm.amdgcn.image.sample.c.l.3d
llvm.amdgcn.image.sample.c.l.cube
llvm.amdgcn.image.sample.c.l.o.1d
llvm.amdgcn.image.sample.c.l.o.1darray
llvm.amdgcn.image.sample.c.l.o.2d
llvm.amdgcn.image.sample.c.l.o.2darray
llvm.amdgcn.image.sample.c.l.o.3d
llvm.amdgcn.image.sample.c.l.o.cube
llvm.amdgcn.image.sample.c.lz.1d
llvm.amdgcn.image.sample.c.lz.1darray
llvm.amdgcn.image.sample.c.lz.2d
llvm.amdgcn.image.sample.c.lz.2darray
llvm.amdgcn.image.sample.c.lz.3d
llvm.amdgcn.image.sample.c.lz.cube
llvm.amdgcn.image.sample.c.lz.o.1d
llvm.amdgcn.image.sample.c.lz.o.1darray
llvm.amdgcn.image.sample.c.lz.o.2d
llvm.amdgcn.image.sample.c.lz.o.2darray
llvm.amdgcn.image.sample.c.lz.o.3d
llvm.amdgcn.image.sample.c.lz.o.cube
llvm.amdgcn.image.sample.c.o.1d
llvm.amdgcn.image.sample.c.o.1darray
llvm.amdgcn.image.sample.c.o.2d
llvm.amdgcn.image.sample.c.o.2darray
llvm.amdgcn.image.sample.c.o.3d
llvm.amdgcn.image.sample.c.o.cube
llvm.amdgcn.image.sample.cd.1d
llvm.amdgcn.image.sample.cd.1darray
llvm.amdgcn.image.sample.cd.2d
llvm.amdgcn.image.sample.cd.2darray
llvm.amdgcn.image.sample.cd.3d
llvm.amdgcn.image.sample.cd.cl.1d
llvm.amdgcn.image.sample.cd.cl.1darray
llvm.amdgcn.image.sample.cd.cl.2d
llvm.amdgcn.image.sample.cd.cl.2darray
llvm.amdgcn.image.sample.cd.cl.3d
llvm.amdgcn.image.sample.cd.cl.cube
llvm.amdgcn.image.sample.cd.cl.o.1d
llvm.amdgcn.image.sample.cd.cl.o.1darray
llvm.amdgcn.image.sample.cd.cl.o.2d
llvm.amdgcn.image.sample.cd.cl.o.2darray
llvm.amdgcn.image.sample.cd.cl.o.3d
llvm.amdgcn.image.sample.cd.cl.o.cube
llvm.amdgcn.image.sample.cd.cube
llvm.amdgcn.image.sample.cd.o.1d
llvm.amdgcn.image.sample.cd.o.1darray
llvm.amdgcn.image.sample.cd.o.2d
llvm.amdgcn.image.sample.cd.o.2darray
llvm.amdgcn.image.sample.cd.o.3d
llvm.amdgcn.image.sample.cd.o.cube
llvm.amdgcn.image.sample.cl.1d
llvm.amdgcn.image.sample.cl.1darray
llvm.amdgcn.image.sample.cl.2d
llvm.amdgcn.image.sample.cl.2darray
llvm.amdgcn.image.sample.cl.3d
llvm.amdgcn.image.sample.cl.cube
llvm.amdgcn.image.sample.cl.o.1d
llvm.amdgcn.image.sample.cl.o.1darray
llvm.amdgcn.image.sample.cl.o.2d
llvm.amdgcn.image.sample.cl.o.2darray
llvm.amdgcn.image.sample.cl.o.3d
llvm.amdgcn.image.sample.cl.o.cube
llvm.amdgcn.image.sample.cube
llvm.amdgcn.image.sample.d.1d
llvm.amdgcn.image.sample.d.1darray
llvm.amdgcn.image.sample.d.2d
llvm.amdgcn.image.sample.d.2darray
llvm.amdgcn.image.sample.d.3d
llvm.amdgcn.image.sample.d.cl.1d
llvm.amdgcn.image.sample.d.cl.1darray
llvm.amdgcn.image.sample.d.cl.2d
llvm.amdgcn.image.sample.d.cl.2darray
llvm.amdgcn.image.sample.d.cl.3d
llvm.amdgcn.image.sample.d.cl.cube
llvm.amdgcn.image.sample.d.cl.o.1d
llvm.amdgcn.image.sample.d.cl.o.1darray
llvm.amdgcn.image.sample.d.cl.o.2d
llvm.amdgcn.image.sample.d.cl.o.2darray
llvm.amdgcn.image.sample.d.cl.o.3d
llvm.amdgcn.image.sample.d.cl.o.cube
llvm.amdgcn.image.sample.d.cube
llvm.amdgcn.image.sample.d.o.1d
llvm.amdgcn.image.sample.d.o.1darray
llvm.amdgcn.image.sample.d.o.2d
llvm.amdgcn.image.sample.d.o.2darray
llvm.amdgcn.image.sample.d.o.3d
llvm.amdgcn.image.sample.d.o.cube
llvm.amdgcn.image.sample.l.1d
llvm.amdgcn.image.sample.l.1darray
llvm.amdgcn.image.sample.l.2d
llvm.amdgcn.image.sample.l.2darray
llvm.amdgcn.image.sample.l.3d
llvm.amdgcn.image.sample.l.cube
llvm.amdgcn.image.sample.l.o.1d
llvm.amdgcn.image.sample.l.o.1darray
llvm.amdgcn.image.sample.l.o.2d
llvm.amdgcn.image.sample.l.o.2darray
llvm.amdgcn.image.sample.l.o.3d
llvm.amdgcn.image.sample.l.o.cube
llvm.amdgcn.image.sample.lz.1d
llvm.amdgcn.image.sample.lz.1darray
llvm.amdgcn.image.sample.lz.2d
llvm.amdgcn.image.sample.lz.2darray
llvm.amdgcn.image.sample.lz.3d
llvm.amdgcn.image.sample.lz.cube
llvm.amdgcn.image.sample.lz.o.1d
llvm.amdgcn.image.sample.lz.o.1darray
llvm.amdgcn.image.sample.lz.o.2d
llvm.amdgcn.image.sample.lz.o.2darray
llvm.amdgcn.image.sample.lz.o.3d
llvm.amdgcn.image.sample.lz.o.cube
llvm.amdgcn.image.sample.o.1d
llvm.amdgcn.image.sample.o.1darray
llvm.amdgcn.image.sample.o.2d
llvm.amdgcn.image.sample.o.2darray
llvm.amdgcn.image.sample.o.3d
llvm.amdgcn.image.sample.o.cube
llvm.amdgcn.image.store.1d
llvm.amdgcn.image.store.1darray
llvm.amdgcn.image.store.2d
llvm.amdgcn.image.store.2darray
llvm.amdgcn.image.store.2darraymsaa
llvm.amdgcn.image.store.2dmsaa
llvm.amdgcn.image.store.3d
llvm.amdgcn.image.store.cube
llvm.amdgcn.image.store.mip.1d
llvm.amdgcn.image.store.mip.1darray
llvm.amdgcn.image.store.mip.2d
llvm.amdgcn.image.store.mip.2darray
llvm.amdgcn.image.store.mip.3d
llvm.amdgcn.image.store.mip.cube
llvm.amdgcn.implicit.buffer.ptr
llvm.amdgcn.implicitarg.ptr
llvm.amdgcn.init.exec
llvm.amdgcn.init.exec.from.input
llvm.amdgcn.interp.mov
llvm.amdgcn.interp.p1
llvm.amdgcn.interp.p2
llvm.amdgcn.kernarg.segment.ptr
llvm.amdgcn.kill
llvm.amdgcn.ldexp
llvm.amdgcn.lerp
llvm.amdgcn.log.clamp
llvm.amdgcn.loop
llvm.amdgcn.mbcnt.hi
llvm.amdgcn.mbcnt.lo
llvm.amdgcn.mov.dpp
llvm.amdgcn.mqsad.pk.u16.u8
llvm.amdgcn.mqsad.u32.u8
llvm.amdgcn.msad.u8
llvm.amdgcn.ps.live
llvm.amdgcn.qsad.pk.u16.u8
llvm.amdgcn.queue.ptr
llvm.amdgcn.rcp
llvm.amdgcn.rcp.legacy
llvm.amdgcn.readfirstlane
llvm.amdgcn.readlane
llvm.amdgcn.rsq
llvm.amdgcn.rsq.clamp
llvm.amdgcn.rsq.legacy
llvm.amdgcn.s.barrier
llvm.amdgcn.s.dcache.inv
llvm.amdgcn.s.dcache.inv.vol
llvm.amdgcn.s.dcache.wb
llvm.amdgcn.s.dcache.wb.vol
llvm.amdgcn.s.decperflevel
llvm.amdgcn.s.getpc
llvm.amdgcn.s.getreg
llvm.amdgcn.s.incperflevel
llvm.amdgcn.s.memrealtime
llvm.amdgcn.s.memtime
llvm.amdgcn.s.sendmsg
llvm.amdgcn.s.sendmsghalt
llvm.amdgcn.s.sleep
llvm.amdgcn.s.waitcnt
llvm.amdgcn.sad.hi.u8
llvm.amdgcn.sad.u16
llvm.amdgcn.sad.u8
llvm.amdgcn.sbfe
llvm.amdgcn.sdot2
llvm.amdgcn.sdot4
llvm.amdgcn.sdot8
llvm.amdgcn.set.inactive
llvm.amdgcn.sffbh
llvm.amdgcn.sin
llvm.amdgcn.tbuffer.load
llvm.amdgcn.tbuffer.store
llvm.amdgcn.trig.preop
llvm.amdgcn.ubfe
llvm.amdgcn.udot2
llvm.amdgcn.udot4
llvm.amdgcn.udot8
llvm.amdgcn.unreachable
llvm.amdgcn.update.dpp
llvm.amdgcn.wave.barrier
llvm.amdgcn.workgroup.id.x
llvm.amdgcn.workgroup.id.y
llvm.amdgcn.workgroup.id.z
llvm.amdgcn.workitem.id.x
llvm.amdgcn.workitem.id.y
llvm.amdgcn.workitem.id.z
llvm.amdgcn.wqm
llvm.amdgcn.wqm.vote
llvm.amdgcn.writelane
llvm.amdgcn.wwm
llvm.arm.cdp
llvm.arm.cdp2
llvm.arm.clrex
llvm.arm.crc32b
llvm.arm.crc32cb
llvm.arm.crc32ch
llvm.arm.crc32cw
llvm.arm.crc32h
llvm.arm.crc32w
llvm.arm.dbg
llvm.arm.dmb
llvm.arm.dsb
llvm.arm.get.fpscr
llvm.arm.hint
llvm.arm.isb
llvm.arm.ldaex
llvm.arm.ldaexd
llvm.arm.ldc
llvm.arm.ldc2
llvm.arm.ldc2l
llvm.arm.ldcl
llvm.arm.ldrex
llvm.arm.ldrexd
llvm.arm.mcr
llvm.arm.mcr2
llvm.arm.mcrr
llvm.arm.mcrr2
llvm.arm.mrc
llvm.arm.mrc2
llvm.arm.mrrc
llvm.arm.mrrc2
llvm.arm.neon.aesd
llvm.arm.neon.aese
llvm.arm.neon.aesimc
llvm.arm.neon.aesmc
llvm.arm.neon.sdot
llvm.arm.neon.sha1c
llvm.arm.neon.sha1h
llvm.arm.neon.sha1m
llvm.arm.neon.sha1p
llvm.arm.neon.sha1su0
llvm.arm.neon.sha1su1
llvm.arm.neon.sha256h
llvm.arm.neon.sha256h2
llvm.arm.neon.sha256su0
llvm.arm.neon.sha256su1
llvm.arm.neon.udot
llvm.arm.neon.vabds
llvm.arm.neon.vabdu
llvm.arm.neon.vabs
llvm.arm.neon.vacge
llvm.arm.neon.vacgt
llvm.arm.neon.vbsl
llvm.arm.neon.vcls
llvm.arm.neon.vcvtas
llvm.arm.neon.vcvtau
llvm.arm.neon.vcvtfp2fxs
llvm.arm.neon.vcvtfp2fxu
llvm.arm.neon.vcvtfp2hf
llvm.arm.neon.vcvtfxs2fp
llvm.arm.neon.vcvtfxu2fp
llvm.arm.neon.vcvthf2fp
llvm.arm.neon.vcvtms
llvm.arm.neon.vcvtmu
llvm.arm.neon.vcvtns
llvm.arm.neon.vcvtnu
llvm.arm.neon.vcvtps
llvm.arm.neon.vcvtpu
llvm.arm.neon.vhadds
llvm.arm.neon.vhaddu
llvm.arm.neon.vhsubs
llvm.arm.neon.vhsubu
llvm.arm.neon.vld1
llvm.arm.neon.vld1x2
llvm.arm.neon.vld1x3
llvm.arm.neon.vld1x4
llvm.arm.neon.vld2
llvm.arm.neon.vld2dup
llvm.arm.neon.vld2lane
llvm.arm.neon.vld3
llvm.arm.neon.vld3dup
llvm.arm.neon.vld3lane
llvm.arm.neon.vld4
llvm.arm.neon.vld4dup
llvm.arm.neon.vld4lane
llvm.arm.neon.vmaxnm
llvm.arm.neon.vmaxs
llvm.arm.neon.vmaxu
llvm.arm.neon.vminnm
llvm.arm.neon.vmins
llvm.arm.neon.vminu
llvm.arm.neon.vmullp
llvm.arm.neon.vmulls
llvm.arm.neon.vmullu
llvm.arm.neon.vmulp
llvm.arm.neon.vpadals
llvm.arm.neon.vpadalu
llvm.arm.neon.vpadd
llvm.arm.neon.vpaddls
llvm.arm.neon.vpaddlu
llvm.arm.neon.vpmaxs
llvm.arm.neon.vpmaxu
llvm.arm.neon.vpmins
llvm.arm.neon.vpminu
llvm.arm.neon.vqabs
llvm.arm.neon.vqadds
llvm.arm.neon.vqaddu
llvm.arm.neon.vqdmulh
llvm.arm.neon.vqdmull
llvm.arm.neon.vqmovns
llvm.arm.neon.vqmovnsu
llvm.arm.neon.vqmovnu
llvm.arm.neon.vqneg
llvm.arm.neon.vqrdmulh
llvm.arm.neon.vqrshiftns
llvm.arm.neon.vqrshiftnsu
llvm.arm.neon.vqrshiftnu
llvm.arm.neon.vqrshifts
llvm.arm.neon.vqrshiftu
llvm.arm.neon.vqshiftns
llvm.arm.neon.vqshiftnsu
llvm.arm.neon.vqshiftnu
llvm.arm.neon.vqshifts
llvm.arm.neon.vqshiftsu
llvm.arm.neon.vqshiftu
llvm.arm.neon.vqsubs
llvm.arm.neon.vqsubu
llvm.arm.neon.vraddhn
llvm.arm.neon.vrecpe
llvm.arm.neon.vrecps
llvm.arm.neon.vrhadds
llvm.arm.neon.vrhaddu
llvm.arm.neon.vrinta
llvm.arm.neon.vrintm
llvm.arm.neon.vrintn
llvm.arm.neon.vrintp
llvm.arm.neon.vrintx
llvm.arm.neon.vrintz
llvm.arm.neon.vrshiftn
llvm.arm.neon.vrshifts
llvm.arm.neon.vrshiftu
llvm.arm.neon.vrsqrte
llvm.arm.neon.vrsqrts
llvm.arm.neon.vrsubhn
llvm.arm.neon.vshiftins
llvm.arm.neon.vshifts
llvm.arm.neon.vshiftu
llvm.arm.neon.vst1
llvm.arm.neon.vst1x2
llvm.arm.neon.vst1x3
llvm.arm.neon.vst1x4
llvm.arm.neon.vst2
llvm.arm.neon.vst2lane
llvm.arm.neon.vst3
llvm.arm.neon.vst3lane
llvm.arm.neon.vst4
llvm.arm.neon.vst4lane
llvm.arm.neon.vtbl1
llvm.arm.neon.vtbl2
llvm.arm.neon.vtbl3
llvm.arm.neon.vtbl4
llvm.arm.neon.vtbx1
llvm.arm.neon.vtbx2
llvm.arm.neon.vtbx3
llvm.arm.neon.vtbx4
llvm.arm.qadd
llvm.arm.qadd16
llvm.arm.qadd8
llvm.arm.qasx
llvm.arm.qsax
llvm.arm.qsub
llvm.arm.qsub16
llvm.arm.qsub8
llvm.arm.sadd16
llvm.arm.sadd8
llvm.arm.sasx
llvm.arm.sel
llvm.arm.set.fpscr
llvm.arm.shadd16
llvm.arm.shadd8
llvm.arm.shasx
llvm.arm.shsax
llvm.arm.shsub16
llvm.arm.shsub8
llvm.arm.smlabb
llvm.arm.smlabt
llvm.arm.smlad
llvm.arm.smladx
llvm.arm.smlald
llvm.arm.smlaldx
llvm.arm.smlatb
llvm.arm.smlatt
llvm.arm.smlawb
llvm.arm.smlawt
llvm.arm.smlsd
llvm.arm.smlsdx
llvm.arm.smlsld
llvm.arm.smlsldx
llvm.arm.smuad
llvm.arm.smuadx
llvm.arm.smulbb
llvm.arm.smulbt
llvm.arm.smultb
llvm.arm.smultt
llvm.arm.smulwb
llvm.arm.smulwt
llvm.arm.smusd
llvm.arm.smusdx
llvm.arm.space
llvm.arm.ssat
llvm.arm.ssat16
llvm.arm.ssax
llvm.arm.ssub16
llvm.arm.ssub8
llvm.arm.stc
llvm.arm.stc2
llvm.arm.stc2l
llvm.arm.stcl
llvm.arm.stlex
llvm.arm.stlexd
llvm.arm.strex
llvm.arm.strexd
llvm.arm.sxtab16
llvm.arm.sxtb16
llvm.arm.uadd16
llvm.arm.uadd8
llvm.arm.uasx
llvm.arm.uhadd16
llvm.arm.uhadd8
llvm.arm.uhasx
llvm.arm.uhsax
llvm.arm.uhsub16
llvm.arm.uhsub8
llvm.arm.undefined
llvm.arm.uqadd16
llvm.arm.uqadd8
llvm.arm.uqasx
llvm.arm.uqsax
llvm.arm.uqsub16
llvm.arm.uqsub8
llvm.arm.usad8
llvm.arm.usada8
llvm.arm.usat
llvm.arm.usat16
llvm.arm.usax
llvm.arm.usub16
llvm.arm.usub8
llvm.arm.uxtab16
llvm.arm.uxtb16
llvm.arm.vcvtr
llvm.arm.vcvtru
llvm.bpf.load.byte
llvm.bpf.load.half
llvm.bpf.load.word
llvm.bpf.pseudo
llvm.hexagon.A2.abs
llvm.hexagon.A2.absp
llvm.hexagon.A2.abssat
llvm.hexagon.A2.add
llvm.hexagon.A2.addh.h16.hh
llvm.hexagon.A2.addh.h16.hl
llvm.hexagon.A2.addh.h16.lh
llvm.hexagon.A2.addh.h16.ll
llvm.hexagon.A2.addh.h16.sat.hh
llvm.hexagon.A2.addh.h16.sat.hl
llvm.hexagon.A2.addh.h16.sat.lh
llvm.hexagon.A2.addh.h16.sat.ll
llvm.hexagon.A2.addh.l16.hl
llvm.hexagon.A2.addh.l16.ll
llvm.hexagon.A2.addh.l16.sat.hl
llvm.hexagon.A2.addh.l16.sat.ll
llvm.hexagon.A2.addi
llvm.hexagon.A2.addp
llvm.hexagon.A2.addpsat
llvm.hexagon.A2.addsat
llvm.hexagon.A2.addsp
llvm.hexagon.A2.and
llvm.hexagon.A2.andir
llvm.hexagon.A2.andp
llvm.hexagon.A2.aslh
llvm.hexagon.A2.asrh
llvm.hexagon.A2.combine.hh
llvm.hexagon.A2.combine.hl
llvm.hexagon.A2.combine.lh
llvm.hexagon.A2.combine.ll
llvm.hexagon.A2.combineii
llvm.hexagon.A2.combinew
llvm.hexagon.A2.max
llvm.hexagon.A2.maxp
llvm.hexagon.A2.maxu
llvm.hexagon.A2.maxup
llvm.hexagon.A2.min
llvm.hexagon.A2.minp
llvm.hexagon.A2.minu
llvm.hexagon.A2.minup
llvm.hexagon.A2.neg
llvm.hexagon.A2.negp
llvm.hexagon.A2.negsat
llvm.hexagon.A2.not
llvm.hexagon.A2.notp
llvm.hexagon.A2.or
llvm.hexagon.A2.orir
llvm.hexagon.A2.orp
llvm.hexagon.A2.roundsat
llvm.hexagon.A2.sat
llvm.hexagon.A2.satb
llvm.hexagon.A2.sath
llvm.hexagon.A2.satub
llvm.hexagon.A2.satuh
llvm.hexagon.A2.sub
llvm.hexagon.A2.subh.h16.hh
llvm.hexagon.A2.subh.h16.hl
llvm.hexagon.A2.subh.h16.lh
llvm.hexagon.A2.subh.h16.ll
llvm.hexagon.A2.subh.h16.sat.hh
llvm.hexagon.A2.subh.h16.sat.hl
llvm.hexagon.A2.subh.h16.sat.lh
llvm.hexagon.A2.subh.h16.sat.ll
llvm.hexagon.A2.subh.l16.hl
llvm.hexagon.A2.subh.l16.ll
llvm.hexagon.A2.subh.l16.sat.hl
llvm.hexagon.A2.subh.l16.sat.ll
llvm.hexagon.A2.subp
llvm.hexagon.A2.subri
llvm.hexagon.A2.subsat
llvm.hexagon.A2.svaddh
llvm.hexagon.A2.svaddhs
llvm.hexagon.A2.svadduhs
llvm.hexagon.A2.svavgh
llvm.hexagon.A2.svavghs
llvm.hexagon.A2.svnavgh
llvm.hexagon.A2.svsubh
llvm.hexagon.A2.svsubhs
llvm.hexagon.A2.svsubuhs
llvm.hexagon.A2.swiz
llvm.hexagon.A2.sxtb
llvm.hexagon.A2.sxth
llvm.hexagon.A2.sxtw
llvm.hexagon.A2.tfr
llvm.hexagon.A2.tfrih
llvm.hexagon.A2.tfril
llvm.hexagon.A2.tfrp
llvm.hexagon.A2.tfrpi
llvm.hexagon.A2.tfrsi
llvm.hexagon.A2.vabsh
llvm.hexagon.A2.vabshsat
llvm.hexagon.A2.vabsw
llvm.hexagon.A2.vabswsat
llvm.hexagon.A2.vaddb.map
llvm.hexagon.A2.vaddh
llvm.hexagon.A2.vaddhs
llvm.hexagon.A2.vaddub
llvm.hexagon.A2.vaddubs
llvm.hexagon.A2.vadduhs
llvm.hexagon.A2.vaddw
llvm.hexagon.A2.vaddws
llvm.hexagon.A2.vavgh
llvm.hexagon.A2.vavghcr
llvm.hexagon.A2.vavghr
llvm.hexagon.A2.vavgub
llvm.hexagon.A2.vavgubr
llvm.hexagon.A2.vavguh
llvm.hexagon.A2.vavguhr
llvm.hexagon.A2.vavguw
llvm.hexagon.A2.vavguwr
llvm.hexagon.A2.vavgw
llvm.hexagon.A2.vavgwcr
llvm.hexagon.A2.vavgwr
llvm.hexagon.A2.vcmpbeq
llvm.hexagon.A2.vcmpbgtu
llvm.hexagon.A2.vcmpheq
llvm.hexagon.A2.vcmphgt
llvm.hexagon.A2.vcmphgtu
llvm.hexagon.A2.vcmpweq
llvm.hexagon.A2.vcmpwgt
llvm.hexagon.A2.vcmpwgtu
llvm.hexagon.A2.vconj
llvm.hexagon.A2.vmaxb
llvm.hexagon.A2.vmaxh
llvm.hexagon.A2.vmaxub
llvm.hexagon.A2.vmaxuh
llvm.hexagon.A2.vmaxuw
llvm.hexagon.A2.vmaxw
llvm.hexagon.A2.vminb
llvm.hexagon.A2.vminh
llvm.hexagon.A2.vminub
llvm.hexagon.A2.vminuh
llvm.hexagon.A2.vminuw
llvm.hexagon.A2.vminw
llvm.hexagon.A2.vnavgh
llvm.hexagon.A2.vnavghcr
llvm.hexagon.A2.vnavghr
llvm.hexagon.A2.vnavgw
llvm.hexagon.A2.vnavgwcr
llvm.hexagon.A2.vnavgwr
llvm.hexagon.A2.vraddub
llvm.hexagon.A2.vraddub.acc
llvm.hexagon.A2.vrsadub
llvm.hexagon.A2.vrsadub.acc
llvm.hexagon.A2.vsubb.map
llvm.hexagon.A2.vsubh
llvm.hexagon.A2.vsubhs
llvm.hexagon.A2.vsubub
llvm.hexagon.A2.vsububs
llvm.hexagon.A2.vsubuhs
llvm.hexagon.A2.vsubw
llvm.hexagon.A2.vsubws
llvm.hexagon.A2.xor
llvm.hexagon.A2.xorp
llvm.hexagon.A2.zxtb
llvm.hexagon.A2.zxth
llvm.hexagon.A4.andn
llvm.hexagon.A4.andnp
llvm.hexagon.A4.bitsplit
llvm.hexagon.A4.bitspliti
llvm.hexagon.A4.boundscheck
llvm.hexagon.A4.cmpbeq
llvm.hexagon.A4.cmpbeqi
llvm.hexagon.A4.cmpbgt
llvm.hexagon.A4.cmpbgti
llvm.hexagon.A4.cmpbgtu
llvm.hexagon.A4.cmpbgtui
llvm.hexagon.A4.cmpheq
llvm.hexagon.A4.cmpheqi
llvm.hexagon.A4.cmphgt
llvm.hexagon.A4.cmphgti
llvm.hexagon.A4.cmphgtu
llvm.hexagon.A4.cmphgtui
llvm.hexagon.A4.combineir
llvm.hexagon.A4.combineri
llvm.hexagon.A4.cround.ri
llvm.hexagon.A4.cround.rr
llvm.hexagon.A4.modwrapu
llvm.hexagon.A4.orn
llvm.hexagon.A4.ornp
llvm.hexagon.A4.rcmpeq
llvm.hexagon.A4.rcmpeqi
llvm.hexagon.A4.rcmpneq
llvm.hexagon.A4.rcmpneqi
llvm.hexagon.A4.round.ri
llvm.hexagon.A4.round.ri.sat
llvm.hexagon.A4.round.rr
llvm.hexagon.A4.round.rr.sat
llvm.hexagon.A4.tlbmatch
llvm.hexagon.A4.vcmpbeq.any
llvm.hexagon.A4.vcmpbeqi
llvm.hexagon.A4.vcmpbgt
llvm.hexagon.A4.vcmpbgti
llvm.hexagon.A4.vcmpbgtui
llvm.hexagon.A4.vcmpheqi
llvm.hexagon.A4.vcmphgti
llvm.hexagon.A4.vcmphgtui
llvm.hexagon.A4.vcmpweqi
llvm.hexagon.A4.vcmpwgti
llvm.hexagon.A4.vcmpwgtui
llvm.hexagon.A4.vrmaxh
llvm.hexagon.A4.vrmaxuh
llvm.hexagon.A4.vrmaxuw
llvm.hexagon.A4.vrmaxw
llvm.hexagon.A4.vrminh
llvm.hexagon.A4.vrminuh
llvm.hexagon.A4.vrminuw
llvm.hexagon.A4.vrminw
llvm.hexagon.A5.vaddhubs
llvm.hexagon.A6.vcmpbeq.notany
llvm.hexagon.A6.vcmpbeq.notany.128B
llvm.hexagon.C2.all8
llvm.hexagon.C2.and
llvm.hexagon.C2.andn
llvm.hexagon.C2.any8
llvm.hexagon.C2.bitsclr
llvm.hexagon.C2.bitsclri
llvm.hexagon.C2.bitsset
llvm.hexagon.C2.cmpeq
llvm.hexagon.C2.cmpeqi
llvm.hexagon.C2.cmpeqp
llvm.hexagon.C2.cmpgei
llvm.hexagon.C2.cmpgeui
llvm.hexagon.C2.cmpgt
llvm.hexagon.C2.cmpgti
llvm.hexagon.C2.cmpgtp
llvm.hexagon.C2.cmpgtu
llvm.hexagon.C2.cmpgtui
llvm.hexagon.C2.cmpgtup
llvm.hexagon.C2.cmplt
llvm.hexagon.C2.cmpltu
llvm.hexagon.C2.mask
llvm.hexagon.C2.mux
llvm.hexagon.C2.muxii
llvm.hexagon.C2.muxir
llvm.hexagon.C2.muxri
llvm.hexagon.C2.not
llvm.hexagon.C2.or
llvm.hexagon.C2.orn
llvm.hexagon.C2.pxfer.map
llvm.hexagon.C2.tfrpr
llvm.hexagon.C2.tfrrp
llvm.hexagon.C2.vitpack
llvm.hexagon.C2.vmux
llvm.hexagon.C2.xor
llvm.hexagon.C4.and.and
llvm.hexagon.C4.and.andn
llvm.hexagon.C4.and.or
llvm.hexagon.C4.and.orn
llvm.hexagon.C4.cmplte
llvm.hexagon.C4.cmpltei
llvm.hexagon.C4.cmplteu
llvm.hexagon.C4.cmplteui
llvm.hexagon.C4.cmpneq
llvm.hexagon.C4.cmpneqi
llvm.hexagon.C4.fastcorner9
llvm.hexagon.C4.fastcorner9.not
llvm.hexagon.C4.nbitsclr
llvm.hexagon.C4.nbitsclri
llvm.hexagon.C4.nbitsset
llvm.hexagon.C4.or.and
llvm.hexagon.C4.or.andn
llvm.hexagon.C4.or.or
llvm.hexagon.C4.or.orn
llvm.hexagon.F2.conv.d2df
llvm.hexagon.F2.conv.d2sf
llvm.hexagon.F2.conv.df2d
llvm.hexagon.F2.conv.df2d.chop
llvm.hexagon.F2.conv.df2sf
llvm.hexagon.F2.conv.df2ud
llvm.hexagon.F2.conv.df2ud.chop
llvm.hexagon.F2.conv.df2uw
llvm.hexagon.F2.conv.df2uw.chop
llvm.hexagon.F2.conv.df2w
llvm.hexagon.F2.conv.df2w.chop
llvm.hexagon.F2.conv.sf2d
llvm.hexagon.F2.conv.sf2d.chop
llvm.hexagon.F2.conv.sf2df
llvm.hexagon.F2.conv.sf2ud
llvm.hexagon.F2.conv.sf2ud.chop
llvm.hexagon.F2.conv.sf2uw
llvm.hexagon.F2.conv.sf2uw.chop
llvm.hexagon.F2.conv.sf2w
llvm.hexagon.F2.conv.sf2w.chop
llvm.hexagon.F2.conv.ud2df
llvm.hexagon.F2.conv.ud2sf
llvm.hexagon.F2.conv.uw2df
llvm.hexagon.F2.conv.uw2sf
llvm.hexagon.F2.conv.w2df
llvm.hexagon.F2.conv.w2sf
llvm.hexagon.F2.dfclass
llvm.hexagon.F2.dfcmpeq
llvm.hexagon.F2.dfcmpge
llvm.hexagon.F2.dfcmpgt
llvm.hexagon.F2.dfcmpuo
llvm.hexagon.F2.dfimm.n
llvm.hexagon.F2.dfimm.p
llvm.hexagon.F2.sfadd
llvm.hexagon.F2.sfclass
llvm.hexagon.F2.sfcmpeq
llvm.hexagon.F2.sfcmpge
llvm.hexagon.F2.sfcmpgt
llvm.hexagon.F2.sfcmpuo
llvm.hexagon.F2.sffixupd
llvm.hexagon.F2.sffixupn
llvm.hexagon.F2.sffixupr
llvm.hexagon.F2.sffma
llvm.hexagon.F2.sffma.lib
llvm.hexagon.F2.sffma.sc
llvm.hexagon.F2.sffms
llvm.hexagon.F2.sffms.lib
llvm.hexagon.F2.sfimm.n
llvm.hexagon.F2.sfimm.p
llvm.hexagon.F2.sfmax
llvm.hexagon.F2.sfmin
llvm.hexagon.F2.sfmpy
llvm.hexagon.F2.sfsub
llvm.hexagon.L2.loadrb.pbr
llvm.hexagon.L2.loadrb.pci
llvm.hexagon.L2.loadrb.pcr
llvm.hexagon.L2.loadrd.pbr
llvm.hexagon.L2.loadrd.pci
llvm.hexagon.L2.loadrd.pcr
llvm.hexagon.L2.loadrh.pbr
llvm.hexagon.L2.loadrh.pci
llvm.hexagon.L2.loadrh.pcr
llvm.hexagon.L2.loadri.pbr
llvm.hexagon.L2.loadri.pci
llvm.hexagon.L2.loadri.pcr
llvm.hexagon.L2.loadrub.pbr
llvm.hexagon.L2.loadrub.pci
llvm.hexagon.L2.loadrub.pcr
llvm.hexagon.L2.loadruh.pbr
llvm.hexagon.L2.loadruh.pci
llvm.hexagon.L2.loadruh.pcr
llvm.hexagon.L2.loadw.locked
llvm.hexagon.L4.loadd.locked
llvm.hexagon.M2.acci
llvm.hexagon.M2.accii
llvm.hexagon.M2.cmaci.s0
llvm.hexagon.M2.cmacr.s0
llvm.hexagon.M2.cmacs.s0
llvm.hexagon.M2.cmacs.s1
llvm.hexagon.M2.cmacsc.s0
llvm.hexagon.M2.cmacsc.s1
llvm.hexagon.M2.cmpyi.s0
llvm.hexagon.M2.cmpyr.s0
llvm.hexagon.M2.cmpyrs.s0
llvm.hexagon.M2.cmpyrs.s1
llvm.hexagon.M2.cmpyrsc.s0
llvm.hexagon.M2.cmpyrsc.s1
llvm.hexagon.M2.cmpys.s0
llvm.hexagon.M2.cmpys.s1
llvm.hexagon.M2.cmpysc.s0
llvm.hexagon.M2.cmpysc.s1
llvm.hexagon.M2.cnacs.s0
llvm.hexagon.M2.cnacs.s1
llvm.hexagon.M2.cnacsc.s0
llvm.hexagon.M2.cnacsc.s1
llvm.hexagon.M2.dpmpyss.acc.s0
llvm.hexagon.M2.dpmpyss.nac.s0
llvm.hexagon.M2.dpmpyss.rnd.s0
llvm.hexagon.M2.dpmpyss.s0
llvm.hexagon.M2.dpmpyuu.acc.s0
llvm.hexagon.M2.dpmpyuu.nac.s0
llvm.hexagon.M2.dpmpyuu.s0
llvm.hexagon.M2.hmmpyh.rs1
llvm.hexagon.M2.hmmpyh.s1
llvm.hexagon.M2.hmmpyl.rs1
llvm.hexagon.M2.hmmpyl.s1
llvm.hexagon.M2.maci
llvm.hexagon.M2.macsin
llvm.hexagon.M2.macsip
llvm.hexagon.M2.mmachs.rs0
llvm.hexagon.M2.mmachs.rs1
llvm.hexagon.M2.mmachs.s0
llvm.hexagon.M2.mmachs.s1
llvm.hexagon.M2.mmacls.rs0
llvm.hexagon.M2.mmacls.rs1
llvm.hexagon.M2.mmacls.s0
llvm.hexagon.M2.mmacls.s1
llvm.hexagon.M2.mmacuhs.rs0
llvm.hexagon.M2.mmacuhs.rs1
llvm.hexagon.M2.mmacuhs.s0
llvm.hexagon.M2.mmacuhs.s1
llvm.hexagon.M2.mmaculs.rs0
llvm.hexagon.M2.mmaculs.rs1
llvm.hexagon.M2.mmaculs.s0
llvm.hexagon.M2.mmaculs.s1
llvm.hexagon.M2.mmpyh.rs0
llvm.hexagon.M2.mmpyh.rs1
llvm.hexagon.M2.mmpyh.s0
llvm.hexagon.M2.mmpyh.s1
llvm.hexagon.M2.mmpyl.rs0
llvm.hexagon.M2.mmpyl.rs1
llvm.hexagon.M2.mmpyl.s0
llvm.hexagon.M2.mmpyl.s1
llvm.hexagon.M2.mmpyuh.rs0
llvm.hexagon.M2.mmpyuh.rs1
llvm.hexagon.M2.mmpyuh.s0
llvm.hexagon.M2.mmpyuh.s1
llvm.hexagon.M2.mmpyul.rs0
llvm.hexagon.M2.mmpyul.rs1
llvm.hexagon.M2.mmpyul.s0
llvm.hexagon.M2.mmpyul.s1
llvm.hexagon.M2.mpy.acc.hh.s0
llvm.hexagon.M2.mpy.acc.hh.s1
llvm.hexagon.M2.mpy.acc.hl.s0
llvm.hexagon.M2.mpy.acc.hl.s1
llvm.hexagon.M2.mpy.acc.lh.s0
llvm.hexagon.M2.mpy.acc.lh.s1
llvm.hexagon.M2.mpy.acc.ll.s0
llvm.hexagon.M2.mpy.acc.ll.s1
llvm.hexagon.M2.mpy.acc.sat.hh.s0
llvm.hexagon.M2.mpy.acc.sat.hh.s1
llvm.hexagon.M2.mpy.acc.sat.hl.s0
llvm.hexagon.M2.mpy.acc.sat.hl.s1
llvm.hexagon.M2.mpy.acc.sat.lh.s0
llvm.hexagon.M2.mpy.acc.sat.lh.s1
llvm.hexagon.M2.mpy.acc.sat.ll.s0
llvm.hexagon.M2.mpy.acc.sat.ll.s1
llvm.hexagon.M2.mpy.hh.s0
llvm.hexagon.M2.mpy.hh.s1
llvm.hexagon.M2.mpy.hl.s0
llvm.hexagon.M2.mpy.hl.s1
llvm.hexagon.M2.mpy.lh.s0
llvm.hexagon.M2.mpy.lh.s1
llvm.hexagon.M2.mpy.ll.s0
llvm.hexagon.M2.mpy.ll.s1
llvm.hexagon.M2.mpy.nac.hh.s0
llvm.hexagon.M2.mpy.nac.hh.s1
llvm.hexagon.M2.mpy.nac.hl.s0
llvm.hexagon.M2.mpy.nac.hl.s1
llvm.hexagon.M2.mpy.nac.lh.s0
llvm.hexagon.M2.mpy.nac.lh.s1
llvm.hexagon.M2.mpy.nac.ll.s0
llvm.hexagon.M2.mpy.nac.ll.s1
llvm.hexagon.M2.mpy.nac.sat.hh.s0
llvm.hexagon.M2.mpy.nac.sat.hh.s1
llvm.hexagon.M2.mpy.nac.sat.hl.s0
llvm.hexagon.M2.mpy.nac.sat.hl.s1
llvm.hexagon.M2.mpy.nac.sat.lh.s0
llvm.hexagon.M2.mpy.nac.sat.lh.s1
llvm.hexagon.M2.mpy.nac.sat.ll.s0
llvm.hexagon.M2.mpy.nac.sat.ll.s1
llvm.hexagon.M2.mpy.rnd.hh.s0
llvm.hexagon.M2.mpy.rnd.hh.s1
llvm.hexagon.M2.mpy.rnd.hl.s0
llvm.hexagon.M2.mpy.rnd.hl.s1
llvm.hexagon.M2.mpy.rnd.lh.s0
llvm.hexagon.M2.mpy.rnd.lh.s1
llvm.hexagon.M2.mpy.rnd.ll.s0
llvm.hexagon.M2.mpy.rnd.ll.s1
llvm.hexagon.M2.mpy.sat.hh.s0
llvm.hexagon.M2.mpy.sat.hh.s1
llvm.hexagon.M2.mpy.sat.hl.s0
llvm.hexagon.M2.mpy.sat.hl.s1
llvm.hexagon.M2.mpy.sat.lh.s0
llvm.hexagon.M2.mpy.sat.lh.s1
llvm.hexagon.M2.mpy.sat.ll.s0
llvm.hexagon.M2.mpy.sat.ll.s1
llvm.hexagon.M2.mpy.sat.rnd.hh.s0
llvm.hexagon.M2.mpy.sat.rnd.hh.s1
llvm.hexagon.M2.mpy.sat.rnd.hl.s0
llvm.hexagon.M2.mpy.sat.rnd.hl.s1
llvm.hexagon.M2.mpy.sat.rnd.lh.s0
llvm.hexagon.M2.mpy.sat.rnd.lh.s1
llvm.hexagon.M2.mpy.sat.rnd.ll.s0
llvm.hexagon.M2.mpy.sat.rnd.ll.s1
llvm.hexagon.M2.mpy.up
llvm.hexagon.M2.mpy.up.s1
llvm.hexagon.M2.mpy.up.s1.sat
llvm.hexagon.M2.mpyd.acc.hh.s0
llvm.hexagon.M2.mpyd.acc.hh.s1
llvm.hexagon.M2.mpyd.acc.hl.s0
llvm.hexagon.M2.mpyd.acc.hl.s1
llvm.hexagon.M2.mpyd.acc.lh.s0
llvm.hexagon.M2.mpyd.acc.lh.s1
llvm.hexagon.M2.mpyd.acc.ll.s0
llvm.hexagon.M2.mpyd.acc.ll.s1
llvm.hexagon.M2.mpyd.hh.s0
llvm.hexagon.M2.mpyd.hh.s1
llvm.hexagon.M2.mpyd.hl.s0
llvm.hexagon.M2.mpyd.hl.s1
llvm.hexagon.M2.mpyd.lh.s0
llvm.hexagon.M2.mpyd.lh.s1
llvm.hexagon.M2.mpyd.ll.s0
llvm.hexagon.M2.mpyd.ll.s1
llvm.hexagon.M2.mpyd.nac.hh.s0
llvm.hexagon.M2.mpyd.nac.hh.s1
llvm.hexagon.M2.mpyd.nac.hl.s0
llvm.hexagon.M2.mpyd.nac.hl.s1
llvm.hexagon.M2.mpyd.nac.lh.s0
llvm.hexagon.M2.mpyd.nac.lh.s1
llvm.hexagon.M2.mpyd.nac.ll.s0
llvm.hexagon.M2.mpyd.nac.ll.s1
llvm.hexagon.M2.mpyd.rnd.hh.s0
llvm.hexagon.M2.mpyd.rnd.hh.s1
llvm.hexagon.M2.mpyd.rnd.hl.s0
llvm.hexagon.M2.mpyd.rnd.hl.s1
llvm.hexagon.M2.mpyd.rnd.lh.s0
llvm.hexagon.M2.mpyd.rnd.lh.s1
llvm.hexagon.M2.mpyd.rnd.ll.s0
llvm.hexagon.M2.mpyd.rnd.ll.s1
llvm.hexagon.M2.mpyi
llvm.hexagon.M2.mpysmi
llvm.hexagon.M2.mpysu.up
llvm.hexagon.M2.mpyu.acc.hh.s0
llvm.hexagon.M2.mpyu.acc.hh.s1
llvm.hexagon.M2.mpyu.acc.hl.s0
llvm.hexagon.M2.mpyu.acc.hl.s1
llvm.hexagon.M2.mpyu.acc.lh.s0
llvm.hexagon.M2.mpyu.acc.lh.s1
llvm.hexagon.M2.mpyu.acc.ll.s0
llvm.hexagon.M2.mpyu.acc.ll.s1
llvm.hexagon.M2.mpyu.hh.s0
llvm.hexagon.M2.mpyu.hh.s1
llvm.hexagon.M2.mpyu.hl.s0
llvm.hexagon.M2.mpyu.hl.s1
llvm.hexagon.M2.mpyu.lh.s0
llvm.hexagon.M2.mpyu.lh.s1
llvm.hexagon.M2.mpyu.ll.s0
llvm.hexagon.M2.mpyu.ll.s1
llvm.hexagon.M2.mpyu.nac.hh.s0
llvm.hexagon.M2.mpyu.nac.hh.s1
llvm.hexagon.M2.mpyu.nac.hl.s0
llvm.hexagon.M2.mpyu.nac.hl.s1
llvm.hexagon.M2.mpyu.nac.lh.s0
llvm.hexagon.M2.mpyu.nac.lh.s1
llvm.hexagon.M2.mpyu.nac.ll.s0
llvm.hexagon.M2.mpyu.nac.ll.s1
llvm.hexagon.M2.mpyu.up
llvm.hexagon.M2.mpyud.acc.hh.s0
llvm.hexagon.M2.mpyud.acc.hh.s1
llvm.hexagon.M2.mpyud.acc.hl.s0
llvm.hexagon.M2.mpyud.acc.hl.s1
llvm.hexagon.M2.mpyud.acc.lh.s0
llvm.hexagon.M2.mpyud.acc.lh.s1
llvm.hexagon.M2.mpyud.acc.ll.s0
llvm.hexagon.M2.mpyud.acc.ll.s1
llvm.hexagon.M2.mpyud.hh.s0
llvm.hexagon.M2.mpyud.hh.s1
llvm.hexagon.M2.mpyud.hl.s0
llvm.hexagon.M2.mpyud.hl.s1
llvm.hexagon.M2.mpyud.lh.s0
llvm.hexagon.M2.mpyud.lh.s1
llvm.hexagon.M2.mpyud.ll.s0
llvm.hexagon.M2.mpyud.ll.s1
llvm.hexagon.M2.mpyud.nac.hh.s0
llvm.hexagon.M2.mpyud.nac.hh.s1
llvm.hexagon.M2.mpyud.nac.hl.s0
llvm.hexagon.M2.mpyud.nac.hl.s1
llvm.hexagon.M2.mpyud.nac.lh.s0
llvm.hexagon.M2.mpyud.nac.lh.s1
llvm.hexagon.M2.mpyud.nac.ll.s0
llvm.hexagon.M2.mpyud.nac.ll.s1
llvm.hexagon.M2.mpyui
llvm.hexagon.M2.nacci
llvm.hexagon.M2.naccii
llvm.hexagon.M2.subacc
llvm.hexagon.M2.vabsdiffh
llvm.hexagon.M2.vabsdiffw
llvm.hexagon.M2.vcmac.s0.sat.i
llvm.hexagon.M2.vcmac.s0.sat.r
llvm.hexagon.M2.vcmpy.s0.sat.i
llvm.hexagon.M2.vcmpy.s0.sat.r
llvm.hexagon.M2.vcmpy.s1.sat.i
llvm.hexagon.M2.vcmpy.s1.sat.r
llvm.hexagon.M2.vdmacs.s0
llvm.hexagon.M2.vdmacs.s1
llvm.hexagon.M2.vdmpyrs.s0
llvm.hexagon.M2.vdmpyrs.s1
llvm.hexagon.M2.vdmpys.s0
llvm.hexagon.M2.vdmpys.s1
llvm.hexagon.M2.vmac2
llvm.hexagon.M2.vmac2es
llvm.hexagon.M2.vmac2es.s0
llvm.hexagon.M2.vmac2es.s1
llvm.hexagon.M2.vmac2s.s0
llvm.hexagon.M2.vmac2s.s1
llvm.hexagon.M2.vmac2su.s0
llvm.hexagon.M2.vmac2su.s1
llvm.hexagon.M2.vmpy2es.s0
llvm.hexagon.M2.vmpy2es.s1
llvm.hexagon.M2.vmpy2s.s0
llvm.hexagon.M2.vmpy2s.s0pack
llvm.hexagon.M2.vmpy2s.s1
llvm.hexagon.M2.vmpy2s.s1pack
llvm.hexagon.M2.vmpy2su.s0
llvm.hexagon.M2.vmpy2su.s1
llvm.hexagon.M2.vraddh
llvm.hexagon.M2.vradduh
llvm.hexagon.M2.vrcmaci.s0
llvm.hexagon.M2.vrcmaci.s0c
llvm.hexagon.M2.vrcmacr.s0
llvm.hexagon.M2.vrcmacr.s0c
llvm.hexagon.M2.vrcmpyi.s0
llvm.hexagon.M2.vrcmpyi.s0c
llvm.hexagon.M2.vrcmpyr.s0
llvm.hexagon.M2.vrcmpyr.s0c
llvm.hexagon.M2.vrcmpys.acc.s1
llvm.hexagon.M2.vrcmpys.s1
llvm.hexagon.M2.vrcmpys.s1rp
llvm.hexagon.M2.vrmac.s0
llvm.hexagon.M2.vrmpy.s0
llvm.hexagon.M2.xor.xacc
llvm.hexagon.M4.and.and
llvm.hexagon.M4.and.andn
llvm.hexagon.M4.and.or
llvm.hexagon.M4.and.xor
llvm.hexagon.M4.cmpyi.wh
llvm.hexagon.M4.cmpyi.whc
llvm.hexagon.M4.cmpyr.wh
llvm.hexagon.M4.cmpyr.whc
llvm.hexagon.M4.mac.up.s1.sat
llvm.hexagon.M4.mpyri.addi
llvm.hexagon.M4.mpyri.addr
llvm.hexagon.M4.mpyri.addr.u2
llvm.hexagon.M4.mpyrr.addi
llvm.hexagon.M4.mpyrr.addr
llvm.hexagon.M4.nac.up.s1.sat
llvm.hexagon.M4.or.and
llvm.hexagon.M4.or.andn
llvm.hexagon.M4.or.or
llvm.hexagon.M4.or.xor
llvm.hexagon.M4.pmpyw
llvm.hexagon.M4.pmpyw.acc
llvm.hexagon.M4.vpmpyh
llvm.hexagon.M4.vpmpyh.acc
llvm.hexagon.M4.vrmpyeh.acc.s0
llvm.hexagon.M4.vrmpyeh.acc.s1
llvm.hexagon.M4.vrmpyeh.s0
llvm.hexagon.M4.vrmpyeh.s1
llvm.hexagon.M4.vrmpyoh.acc.s0
llvm.hexagon.M4.vrmpyoh.acc.s1
llvm.hexagon.M4.vrmpyoh.s0
llvm.hexagon.M4.vrmpyoh.s1
llvm.hexagon.M4.xor.and
llvm.hexagon.M4.xor.andn
llvm.hexagon.M4.xor.or
llvm.hexagon.M4.xor.xacc
llvm.hexagon.M5.vdmacbsu
llvm.hexagon.M5.vdmpybsu
llvm.hexagon.M5.vmacbsu
llvm.hexagon.M5.vmacbuu
llvm.hexagon.M5.vmpybsu
llvm.hexagon.M5.vmpybuu
llvm.hexagon.M5.vrmacbsu
llvm.hexagon.M5.vrmacbuu
llvm.hexagon.M5.vrmpybsu
llvm.hexagon.M5.vrmpybuu
llvm.hexagon.M6.vabsdiffb
llvm.hexagon.M6.vabsdiffub
llvm.hexagon.S2.addasl.rrri
llvm.hexagon.S2.asl.i.p
llvm.hexagon.S2.asl.i.p.acc
llvm.hexagon.S2.asl.i.p.and
llvm.hexagon.S2.asl.i.p.nac
llvm.hexagon.S2.asl.i.p.or
llvm.hexagon.S2.asl.i.p.xacc
llvm.hexagon.S2.asl.i.r
llvm.hexagon.S2.asl.i.r.acc
llvm.hexagon.S2.asl.i.r.and
llvm.hexagon.S2.asl.i.r.nac
llvm.hexagon.S2.asl.i.r.or
llvm.hexagon.S2.asl.i.r.sat
llvm.hexagon.S2.asl.i.r.xacc
llvm.hexagon.S2.asl.i.vh
llvm.hexagon.S2.asl.i.vw
llvm.hexagon.S2.asl.r.p
llvm.hexagon.S2.asl.r.p.acc
llvm.hexagon.S2.asl.r.p.and
llvm.hexagon.S2.asl.r.p.nac
llvm.hexagon.S2.asl.r.p.or
llvm.hexagon.S2.asl.r.p.xor
llvm.hexagon.S2.asl.r.r
llvm.hexagon.S2.asl.r.r.acc
llvm.hexagon.S2.asl.r.r.and
llvm.hexagon.S2.asl.r.r.nac
llvm.hexagon.S2.asl.r.r.or
llvm.hexagon.S2.asl.r.r.sat
llvm.hexagon.S2.asl.r.vh
llvm.hexagon.S2.asl.r.vw
llvm.hexagon.S2.asr.i.p
llvm.hexagon.S2.asr.i.p.acc
llvm.hexagon.S2.asr.i.p.and
llvm.hexagon.S2.asr.i.p.nac
llvm.hexagon.S2.asr.i.p.or
llvm.hexagon.S2.asr.i.p.rnd
llvm.hexagon.S2.asr.i.p.rnd.goodsyntax
llvm.hexagon.S2.asr.i.r
llvm.hexagon.S2.asr.i.r.acc
llvm.hexagon.S2.asr.i.r.and
llvm.hexagon.S2.asr.i.r.nac
llvm.hexagon.S2.asr.i.r.or
llvm.hexagon.S2.asr.i.r.rnd
llvm.hexagon.S2.asr.i.r.rnd.goodsyntax
llvm.hexagon.S2.asr.i.svw.trun
llvm.hexagon.S2.asr.i.vh
llvm.hexagon.S2.asr.i.vw
llvm.hexagon.S2.asr.r.p
llvm.hexagon.S2.asr.r.p.acc
llvm.hexagon.S2.asr.r.p.and
llvm.hexagon.S2.asr.r.p.nac
llvm.hexagon.S2.asr.r.p.or
llvm.hexagon.S2.asr.r.p.xor
llvm.hexagon.S2.asr.r.r
llvm.hexagon.S2.asr.r.r.acc
llvm.hexagon.S2.asr.r.r.and
llvm.hexagon.S2.asr.r.r.nac
llvm.hexagon.S2.asr.r.r.or
llvm.hexagon.S2.asr.r.r.sat
llvm.hexagon.S2.asr.r.svw.trun
llvm.hexagon.S2.asr.r.vh
llvm.hexagon.S2.asr.r.vw
llvm.hexagon.S2.brev
llvm.hexagon.S2.brevp
llvm.hexagon.S2.cabacencbin
llvm.hexagon.S2.cl0
llvm.hexagon.S2.cl0p
llvm.hexagon.S2.cl1
llvm.hexagon.S2.cl1p
llvm.hexagon.S2.clb
llvm.hexagon.S2.clbnorm
llvm.hexagon.S2.clbp
llvm.hexagon.S2.clrbit.i
llvm.hexagon.S2.clrbit.r
llvm.hexagon.S2.ct0
llvm.hexagon.S2.ct0p
llvm.hexagon.S2.ct1
llvm.hexagon.S2.ct1p
llvm.hexagon.S2.deinterleave
llvm.hexagon.S2.extractu
llvm.hexagon.S2.extractu.rp
llvm.hexagon.S2.extractup
llvm.hexagon.S2.extractup.rp
llvm.hexagon.S2.insert
llvm.hexagon.S2.insert.rp
llvm.hexagon.S2.insertp
llvm.hexagon.S2.insertp.rp
llvm.hexagon.S2.interleave
llvm.hexagon.S2.lfsp
llvm.hexagon.S2.lsl.r.p
llvm.hexagon.S2.lsl.r.p.acc
llvm.hexagon.S2.lsl.r.p.and
llvm.hexagon.S2.lsl.r.p.nac
llvm.hexagon.S2.lsl.r.p.or
llvm.hexagon.S2.lsl.r.p.xor
llvm.hexagon.S2.lsl.r.r
llvm.hexagon.S2.lsl.r.r.acc
llvm.hexagon.S2.lsl.r.r.and
llvm.hexagon.S2.lsl.r.r.nac
llvm.hexagon.S2.lsl.r.r.or
llvm.hexagon.S2.lsl.r.vh
llvm.hexagon.S2.lsl.r.vw
llvm.hexagon.S2.lsr.i.p
llvm.hexagon.S2.lsr.i.p.acc
llvm.hexagon.S2.lsr.i.p.and
llvm.hexagon.S2.lsr.i.p.nac
llvm.hexagon.S2.lsr.i.p.or
llvm.hexagon.S2.lsr.i.p.xacc
llvm.hexagon.S2.lsr.i.r
llvm.hexagon.S2.lsr.i.r.acc
llvm.hexagon.S2.lsr.i.r.and
llvm.hexagon.S2.lsr.i.r.nac
llvm.hexagon.S2.lsr.i.r.or
llvm.hexagon.S2.lsr.i.r.xacc
llvm.hexagon.S2.lsr.i.vh
llvm.hexagon.S2.lsr.i.vw
llvm.hexagon.S2.lsr.r.p
llvm.hexagon.S2.lsr.r.p.acc
llvm.hexagon.S2.lsr.r.p.and
llvm.hexagon.S2.lsr.r.p.nac
llvm.hexagon.S2.lsr.r.p.or
llvm.hexagon.S2.lsr.r.p.xor
llvm.hexagon.S2.lsr.r.r
llvm.hexagon.S2.lsr.r.r.acc
llvm.hexagon.S2.lsr.r.r.and
llvm.hexagon.S2.lsr.r.r.nac
llvm.hexagon.S2.lsr.r.r.or
llvm.hexagon.S2.lsr.r.vh
llvm.hexagon.S2.lsr.r.vw
llvm.hexagon.S2.packhl
llvm.hexagon.S2.parityp
llvm.hexagon.S2.setbit.i
llvm.hexagon.S2.setbit.r
llvm.hexagon.S2.shuffeb
llvm.hexagon.S2.shuffeh
llvm.hexagon.S2.shuffob
llvm.hexagon.S2.shuffoh
llvm.hexagon.S2.storerb.pbr
llvm.hexagon.S2.storerb.pci
llvm.hexagon.S2.storerb.pcr
llvm.hexagon.S2.storerd.pbr
llvm.hexagon.S2.storerd.pci
llvm.hexagon.S2.storerd.pcr
llvm.hexagon.S2.storerf.pbr
llvm.hexagon.S2.storerf.pci
llvm.hexagon.S2.storerf.pcr
llvm.hexagon.S2.storerh.pbr
llvm.hexagon.S2.storerh.pci
llvm.hexagon.S2.storerh.pcr
llvm.hexagon.S2.storeri.pbr
llvm.hexagon.S2.storeri.pci
llvm.hexagon.S2.storeri.pcr
llvm.hexagon.S2.storew.locked
llvm.hexagon.S2.svsathb
llvm.hexagon.S2.svsathub
llvm.hexagon.S2.tableidxb.goodsyntax
llvm.hexagon.S2.tableidxd.goodsyntax
llvm.hexagon.S2.tableidxh.goodsyntax
llvm.hexagon.S2.tableidxw.goodsyntax
llvm.hexagon.S2.togglebit.i
llvm.hexagon.S2.togglebit.r
llvm.hexagon.S2.tstbit.i
llvm.hexagon.S2.tstbit.r
llvm.hexagon.S2.valignib
llvm.hexagon.S2.valignrb
llvm.hexagon.S2.vcnegh
llvm.hexagon.S2.vcrotate
llvm.hexagon.S2.vrcnegh
llvm.hexagon.S2.vrndpackwh
llvm.hexagon.S2.vrndpackwhs
llvm.hexagon.S2.vsathb
llvm.hexagon.S2.vsathb.nopack
llvm.hexagon.S2.vsathub
llvm.hexagon.S2.vsathub.nopack
llvm.hexagon.S2.vsatwh
llvm.hexagon.S2.vsatwh.nopack
llvm.hexagon.S2.vsatwuh
llvm.hexagon.S2.vsatwuh.nopack
llvm.hexagon.S2.vsplatrb
llvm.hexagon.S2.vsplatrh
llvm.hexagon.S2.vspliceib
llvm.hexagon.S2.vsplicerb
llvm.hexagon.S2.vsxtbh
llvm.hexagon.S2.vsxthw
llvm.hexagon.S2.vtrunehb
llvm.hexagon.S2.vtrunewh
llvm.hexagon.S2.vtrunohb
llvm.hexagon.S2.vtrunowh
llvm.hexagon.S2.vzxtbh
llvm.hexagon.S2.vzxthw
llvm.hexagon.S4.addaddi
llvm.hexagon.S4.addi.asl.ri
llvm.hexagon.S4.addi.lsr.ri
llvm.hexagon.S4.andi.asl.ri
llvm.hexagon.S4.andi.lsr.ri
llvm.hexagon.S4.clbaddi
llvm.hexagon.S4.clbpaddi
llvm.hexagon.S4.clbpnorm
llvm.hexagon.S4.extract
llvm.hexagon.S4.extract.rp
llvm.hexagon.S4.extractp
llvm.hexagon.S4.extractp.rp
llvm.hexagon.S4.lsli
llvm.hexagon.S4.ntstbit.i
llvm.hexagon.S4.ntstbit.r
llvm.hexagon.S4.or.andi
llvm.hexagon.S4.or.andix
llvm.hexagon.S4.or.ori
llvm.hexagon.S4.ori.asl.ri
llvm.hexagon.S4.ori.lsr.ri
llvm.hexagon.S4.parity
llvm.hexagon.S4.stored.locked
llvm.hexagon.S4.subaddi
llvm.hexagon.S4.subi.asl.ri
llvm.hexagon.S4.subi.lsr.ri
llvm.hexagon.S4.vrcrotate
llvm.hexagon.S4.vrcrotate.acc
llvm.hexagon.S4.vxaddsubh
llvm.hexagon.S4.vxaddsubhr
llvm.hexagon.S4.vxaddsubw
llvm.hexagon.S4.vxsubaddh
llvm.hexagon.S4.vxsubaddhr
llvm.hexagon.S4.vxsubaddw
llvm.hexagon.S5.asrhub.rnd.sat.goodsyntax
llvm.hexagon.S5.asrhub.sat
llvm.hexagon.S5.popcountp
llvm.hexagon.S5.vasrhrnd.goodsyntax
llvm.hexagon.S6.rol.i.p
llvm.hexagon.S6.rol.i.p.acc
llvm.hexagon.S6.rol.i.p.and
llvm.hexagon.S6.rol.i.p.nac
llvm.hexagon.S6.rol.i.p.or
llvm.hexagon.S6.rol.i.p.xacc
llvm.hexagon.S6.rol.i.r
llvm.hexagon.S6.rol.i.r.acc
llvm.hexagon.S6.rol.i.r.and
llvm.hexagon.S6.rol.i.r.nac
llvm.hexagon.S6.rol.i.r.or
llvm.hexagon.S6.rol.i.r.xacc
llvm.hexagon.S6.vsplatrbp
llvm.hexagon.S6.vtrunehb.ppp
llvm.hexagon.S6.vtrunohb.ppp
llvm.hexagon.V6.extractw
llvm.hexagon.V6.extractw.128B
llvm.hexagon.V6.hi
llvm.hexagon.V6.hi.128B
llvm.hexagon.V6.lo
llvm.hexagon.V6.lo.128B
llvm.hexagon.V6.lvsplatb
llvm.hexagon.V6.lvsplatb.128B
llvm.hexagon.V6.lvsplath
llvm.hexagon.V6.lvsplath.128B
llvm.hexagon.V6.lvsplatw
llvm.hexagon.V6.lvsplatw.128B
llvm.hexagon.V6.pred.and
llvm.hexagon.V6.pred.and.128B
llvm.hexagon.V6.pred.and.n
llvm.hexagon.V6.pred.and.n.128B
llvm.hexagon.V6.pred.not
llvm.hexagon.V6.pred.not.128B
llvm.hexagon.V6.pred.or
llvm.hexagon.V6.pred.or.128B
llvm.hexagon.V6.pred.or.n
llvm.hexagon.V6.pred.or.n.128B
llvm.hexagon.V6.pred.scalar2
llvm.hexagon.V6.pred.scalar2.128B
llvm.hexagon.V6.pred.scalar2v2
llvm.hexagon.V6.pred.scalar2v2.128B
llvm.hexagon.V6.pred.xor
llvm.hexagon.V6.pred.xor.128B
llvm.hexagon.V6.shuffeqh
llvm.hexagon.V6.shuffeqh.128B
llvm.hexagon.V6.shuffeqw
llvm.hexagon.V6.shuffeqw.128B
llvm.hexagon.V6.vS32b.nqpred.ai
llvm.hexagon.V6.vS32b.nqpred.ai.128B
llvm.hexagon.V6.vS32b.nt.nqpred.ai
llvm.hexagon.V6.vS32b.nt.nqpred.ai.128B
llvm.hexagon.V6.vS32b.nt.qpred.ai
llvm.hexagon.V6.vS32b.nt.qpred.ai.128B
llvm.hexagon.V6.vS32b.qpred.ai
llvm.hexagon.V6.vS32b.qpred.ai.128B
llvm.hexagon.V6.vabsb
llvm.hexagon.V6.vabsb.128B
llvm.hexagon.V6.vabsb.sat
llvm.hexagon.V6.vabsb.sat.128B
llvm.hexagon.V6.vabsdiffh
llvm.hexagon.V6.vabsdiffh.128B
llvm.hexagon.V6.vabsdiffub
llvm.hexagon.V6.vabsdiffub.128B
llvm.hexagon.V6.vabsdiffuh
llvm.hexagon.V6.vabsdiffuh.128B
llvm.hexagon.V6.vabsdiffw
llvm.hexagon.V6.vabsdiffw.128B
llvm.hexagon.V6.vabsh
llvm.hexagon.V6.vabsh.128B
llvm.hexagon.V6.vabsh.sat
llvm.hexagon.V6.vabsh.sat.128B
llvm.hexagon.V6.vabsw
llvm.hexagon.V6.vabsw.128B
llvm.hexagon.V6.vabsw.sat
llvm.hexagon.V6.vabsw.sat.128B
llvm.hexagon.V6.vaddb
llvm.hexagon.V6.vaddb.128B
llvm.hexagon.V6.vaddb.dv
llvm.hexagon.V6.vaddb.dv.128B
llvm.hexagon.V6.vaddbnq
llvm.hexagon.V6.vaddbnq.128B
llvm.hexagon.V6.vaddbq
llvm.hexagon.V6.vaddbq.128B
llvm.hexagon.V6.vaddbsat
llvm.hexagon.V6.vaddbsat.128B
llvm.hexagon.V6.vaddbsat.dv
llvm.hexagon.V6.vaddbsat.dv.128B
llvm.hexagon.V6.vaddcarry
llvm.hexagon.V6.vaddcarry.128B
llvm.hexagon.V6.vaddclbh
llvm.hexagon.V6.vaddclbh.128B
llvm.hexagon.V6.vaddclbw
llvm.hexagon.V6.vaddclbw.128B
llvm.hexagon.V6.vaddh
llvm.hexagon.V6.vaddh.128B
llvm.hexagon.V6.vaddh.dv
llvm.hexagon.V6.vaddh.dv.128B
llvm.hexagon.V6.vaddhnq
llvm.hexagon.V6.vaddhnq.128B
llvm.hexagon.V6.vaddhq
llvm.hexagon.V6.vaddhq.128B
llvm.hexagon.V6.vaddhsat
llvm.hexagon.V6.vaddhsat.128B
llvm.hexagon.V6.vaddhsat.dv
llvm.hexagon.V6.vaddhsat.dv.128B
llvm.hexagon.V6.vaddhw
llvm.hexagon.V6.vaddhw.128B
llvm.hexagon.V6.vaddhw.acc
llvm.hexagon.V6.vaddhw.acc.128B
llvm.hexagon.V6.vaddubh
llvm.hexagon.V6.vaddubh.128B
llvm.hexagon.V6.vaddubh.acc
llvm.hexagon.V6.vaddubh.acc.128B
llvm.hexagon.V6.vaddubsat
llvm.hexagon.V6.vaddubsat.128B
llvm.hexagon.V6.vaddubsat.dv
llvm.hexagon.V6.vaddubsat.dv.128B
llvm.hexagon.V6.vaddububb.sat
llvm.hexagon.V6.vaddububb.sat.128B
llvm.hexagon.V6.vadduhsat
llvm.hexagon.V6.vadduhsat.128B
llvm.hexagon.V6.vadduhsat.dv
llvm.hexagon.V6.vadduhsat.dv.128B
llvm.hexagon.V6.vadduhw
llvm.hexagon.V6.vadduhw.128B
llvm.hexagon.V6.vadduhw.acc
llvm.hexagon.V6.vadduhw.acc.128B
llvm.hexagon.V6.vadduwsat
llvm.hexagon.V6.vadduwsat.128B
llvm.hexagon.V6.vadduwsat.dv
llvm.hexagon.V6.vadduwsat.dv.128B
llvm.hexagon.V6.vaddw
llvm.hexagon.V6.vaddw.128B
llvm.hexagon.V6.vaddw.dv
llvm.hexagon.V6.vaddw.dv.128B
llvm.hexagon.V6.vaddwnq
llvm.hexagon.V6.vaddwnq.128B
llvm.hexagon.V6.vaddwq
llvm.hexagon.V6.vaddwq.128B
llvm.hexagon.V6.vaddwsat
llvm.hexagon.V6.vaddwsat.128B
llvm.hexagon.V6.vaddwsat.dv
llvm.hexagon.V6.vaddwsat.dv.128B
llvm.hexagon.V6.valignb
llvm.hexagon.V6.valignb.128B
llvm.hexagon.V6.valignbi
llvm.hexagon.V6.valignbi.128B
llvm.hexagon.V6.vand
llvm.hexagon.V6.vand.128B
llvm.hexagon.V6.vandnqrt
llvm.hexagon.V6.vandnqrt.128B
llvm.hexagon.V6.vandnqrt.acc
llvm.hexagon.V6.vandnqrt.acc.128B
llvm.hexagon.V6.vandqrt
llvm.hexagon.V6.vandqrt.128B
llvm.hexagon.V6.vandqrt.acc
llvm.hexagon.V6.vandqrt.acc.128B
llvm.hexagon.V6.vandvnqv
llvm.hexagon.V6.vandvnqv.128B
llvm.hexagon.V6.vandvqv
llvm.hexagon.V6.vandvqv.128B
llvm.hexagon.V6.vandvrt
llvm.hexagon.V6.vandvrt.128B
llvm.hexagon.V6.vandvrt.acc
llvm.hexagon.V6.vandvrt.acc.128B
llvm.hexagon.V6.vaslh
llvm.hexagon.V6.vaslh.128B
llvm.hexagon.V6.vaslh.acc
llvm.hexagon.V6.vaslh.acc.128B
llvm.hexagon.V6.vaslhv
llvm.hexagon.V6.vaslhv.128B
llvm.hexagon.V6.vaslw
llvm.hexagon.V6.vaslw.128B
llvm.hexagon.V6.vaslw.acc
llvm.hexagon.V6.vaslw.acc.128B
llvm.hexagon.V6.vaslwv
llvm.hexagon.V6.vaslwv.128B
llvm.hexagon.V6.vasrh
llvm.hexagon.V6.vasrh.128B
llvm.hexagon.V6.vasrh.acc
llvm.hexagon.V6.vasrh.acc.128B
llvm.hexagon.V6.vasrhbrndsat
llvm.hexagon.V6.vasrhbrndsat.128B
llvm.hexagon.V6.vasrhbsat
llvm.hexagon.V6.vasrhbsat.128B
llvm.hexagon.V6.vasrhubrndsat
llvm.hexagon.V6.vasrhubrndsat.128B
llvm.hexagon.V6.vasrhubsat
llvm.hexagon.V6.vasrhubsat.128B
llvm.hexagon.V6.vasrhv
llvm.hexagon.V6.vasrhv.128B
llvm.hexagon.V6.vasruhubrndsat
llvm.hexagon.V6.vasruhubrndsat.128B
llvm.hexagon.V6.vasruhubsat
llvm.hexagon.V6.vasruhubsat.128B
llvm.hexagon.V6.vasruwuhrndsat
llvm.hexagon.V6.vasruwuhrndsat.128B
llvm.hexagon.V6.vasruwuhsat
llvm.hexagon.V6.vasruwuhsat.128B
llvm.hexagon.V6.vasrw
llvm.hexagon.V6.vasrw.128B
llvm.hexagon.V6.vasrw.acc
llvm.hexagon.V6.vasrw.acc.128B
llvm.hexagon.V6.vasrwh
llvm.hexagon.V6.vasrwh.128B
llvm.hexagon.V6.vasrwhrndsat
llvm.hexagon.V6.vasrwhrndsat.128B
llvm.hexagon.V6.vasrwhsat
llvm.hexagon.V6.vasrwhsat.128B
llvm.hexagon.V6.vasrwuhrndsat
llvm.hexagon.V6.vasrwuhrndsat.128B
llvm.hexagon.V6.vasrwuhsat
llvm.hexagon.V6.vasrwuhsat.128B
llvm.hexagon.V6.vasrwv
llvm.hexagon.V6.vasrwv.128B
llvm.hexagon.V6.vassign
llvm.hexagon.V6.vassign.128B
llvm.hexagon.V6.vassignp
llvm.hexagon.V6.vassignp.128B
llvm.hexagon.V6.vavgb
llvm.hexagon.V6.vavgb.128B
llvm.hexagon.V6.vavgbrnd
llvm.hexagon.V6.vavgbrnd.128B
llvm.hexagon.V6.vavgh
llvm.hexagon.V6.vavgh.128B
llvm.hexagon.V6.vavghrnd
llvm.hexagon.V6.vavghrnd.128B
llvm.hexagon.V6.vavgub
llvm.hexagon.V6.vavgub.128B
llvm.hexagon.V6.vavgubrnd
llvm.hexagon.V6.vavgubrnd.128B
llvm.hexagon.V6.vavguh
llvm.hexagon.V6.vavguh.128B
llvm.hexagon.V6.vavguhrnd
llvm.hexagon.V6.vavguhrnd.128B
llvm.hexagon.V6.vavguw
llvm.hexagon.V6.vavguw.128B
llvm.hexagon.V6.vavguwrnd
llvm.hexagon.V6.vavguwrnd.128B
llvm.hexagon.V6.vavgw
llvm.hexagon.V6.vavgw.128B
llvm.hexagon.V6.vavgwrnd
llvm.hexagon.V6.vavgwrnd.128B
llvm.hexagon.V6.vcl0h
llvm.hexagon.V6.vcl0h.128B
llvm.hexagon.V6.vcl0w
llvm.hexagon.V6.vcl0w.128B
llvm.hexagon.V6.vcombine
llvm.hexagon.V6.vcombine.128B
llvm.hexagon.V6.vd0
llvm.hexagon.V6.vd0.128B
llvm.hexagon.V6.vdd0
llvm.hexagon.V6.vdd0.128B
llvm.hexagon.V6.vdealb
llvm.hexagon.V6.vdealb.128B
llvm.hexagon.V6.vdealb4w
llvm.hexagon.V6.vdealb4w.128B
llvm.hexagon.V6.vdealh
llvm.hexagon.V6.vdealh.128B
llvm.hexagon.V6.vdealvdd
llvm.hexagon.V6.vdealvdd.128B
llvm.hexagon.V6.vdelta
llvm.hexagon.V6.vdelta.128B
llvm.hexagon.V6.vdmpybus
llvm.hexagon.V6.vdmpybus.128B
llvm.hexagon.V6.vdmpybus.acc
llvm.hexagon.V6.vdmpybus.acc.128B
llvm.hexagon.V6.vdmpybus.dv
llvm.hexagon.V6.vdmpybus.dv.128B
llvm.hexagon.V6.vdmpybus.dv.acc
llvm.hexagon.V6.vdmpybus.dv.acc.128B
llvm.hexagon.V6.vdmpyhb
llvm.hexagon.V6.vdmpyhb.128B
llvm.hexagon.V6.vdmpyhb.acc
llvm.hexagon.V6.vdmpyhb.acc.128B
llvm.hexagon.V6.vdmpyhb.dv
llvm.hexagon.V6.vdmpyhb.dv.128B
llvm.hexagon.V6.vdmpyhb.dv.acc
llvm.hexagon.V6.vdmpyhb.dv.acc.128B
llvm.hexagon.V6.vdmpyhisat
llvm.hexagon.V6.vdmpyhisat.128B
llvm.hexagon.V6.vdmpyhisat.acc
llvm.hexagon.V6.vdmpyhisat.acc.128B
llvm.hexagon.V6.vdmpyhsat
llvm.hexagon.V6.vdmpyhsat.128B
llvm.hexagon.V6.vdmpyhsat.acc
llvm.hexagon.V6.vdmpyhsat.acc.128B
llvm.hexagon.V6.vdmpyhsuisat
llvm.hexagon.V6.vdmpyhsuisat.128B
llvm.hexagon.V6.vdmpyhsuisat.acc
llvm.hexagon.V6.vdmpyhsuisat.acc.128B
llvm.hexagon.V6.vdmpyhsusat
llvm.hexagon.V6.vdmpyhsusat.128B
llvm.hexagon.V6.vdmpyhsusat.acc
llvm.hexagon.V6.vdmpyhsusat.acc.128B
llvm.hexagon.V6.vdmpyhvsat
llvm.hexagon.V6.vdmpyhvsat.128B
llvm.hexagon.V6.vdmpyhvsat.acc
llvm.hexagon.V6.vdmpyhvsat.acc.128B
llvm.hexagon.V6.vdsaduh
llvm.hexagon.V6.vdsaduh.128B
llvm.hexagon.V6.vdsaduh.acc
llvm.hexagon.V6.vdsaduh.acc.128B
llvm.hexagon.V6.veqb
llvm.hexagon.V6.veqb.128B
llvm.hexagon.V6.veqb.and
llvm.hexagon.V6.veqb.and.128B
llvm.hexagon.V6.veqb.or
llvm.hexagon.V6.veqb.or.128B
llvm.hexagon.V6.veqb.xor
llvm.hexagon.V6.veqb.xor.128B
llvm.hexagon.V6.veqh
llvm.hexagon.V6.veqh.128B
llvm.hexagon.V6.veqh.and
llvm.hexagon.V6.veqh.and.128B
llvm.hexagon.V6.veqh.or
llvm.hexagon.V6.veqh.or.128B
llvm.hexagon.V6.veqh.xor
llvm.hexagon.V6.veqh.xor.128B
llvm.hexagon.V6.veqw
llvm.hexagon.V6.veqw.128B
llvm.hexagon.V6.veqw.and
llvm.hexagon.V6.veqw.and.128B
llvm.hexagon.V6.veqw.or
llvm.hexagon.V6.veqw.or.128B
llvm.hexagon.V6.veqw.xor
llvm.hexagon.V6.veqw.xor.128B
llvm.hexagon.V6.vgathermh
llvm.hexagon.V6.vgathermh.128B
llvm.hexagon.V6.vgathermhq
llvm.hexagon.V6.vgathermhq.128B
llvm.hexagon.V6.vgathermhw
llvm.hexagon.V6.vgathermhw.128B
llvm.hexagon.V6.vgathermhwq
llvm.hexagon.V6.vgathermhwq.128B
llvm.hexagon.V6.vgathermw
llvm.hexagon.V6.vgathermw.128B
llvm.hexagon.V6.vgathermwq
llvm.hexagon.V6.vgathermwq.128B
llvm.hexagon.V6.vgtb
llvm.hexagon.V6.vgtb.128B
llvm.hexagon.V6.vgtb.and
llvm.hexagon.V6.vgtb.and.128B
llvm.hexagon.V6.vgtb.or
llvm.hexagon.V6.vgtb.or.128B
llvm.hexagon.V6.vgtb.xor
llvm.hexagon.V6.vgtb.xor.128B
llvm.hexagon.V6.vgth
llvm.hexagon.V6.vgth.128B
llvm.hexagon.V6.vgth.and
llvm.hexagon.V6.vgth.and.128B
llvm.hexagon.V6.vgth.or
llvm.hexagon.V6.vgth.or.128B
llvm.hexagon.V6.vgth.xor
llvm.hexagon.V6.vgth.xor.128B
llvm.hexagon.V6.vgtub
llvm.hexagon.V6.vgtub.128B
llvm.hexagon.V6.vgtub.and
llvm.hexagon.V6.vgtub.and.128B
llvm.hexagon.V6.vgtub.or
llvm.hexagon.V6.vgtub.or.128B
llvm.hexagon.V6.vgtub.xor
llvm.hexagon.V6.vgtub.xor.128B
llvm.hexagon.V6.vgtuh
llvm.hexagon.V6.vgtuh.128B
llvm.hexagon.V6.vgtuh.and
llvm.hexagon.V6.vgtuh.and.128B
llvm.hexagon.V6.vgtuh.or
llvm.hexagon.V6.vgtuh.or.128B
llvm.hexagon.V6.vgtuh.xor
llvm.hexagon.V6.vgtuh.xor.128B
llvm.hexagon.V6.vgtuw
llvm.hexagon.V6.vgtuw.128B
llvm.hexagon.V6.vgtuw.and
llvm.hexagon.V6.vgtuw.and.128B
llvm.hexagon.V6.vgtuw.or
llvm.hexagon.V6.vgtuw.or.128B
llvm.hexagon.V6.vgtuw.xor
llvm.hexagon.V6.vgtuw.xor.128B
llvm.hexagon.V6.vgtw
llvm.hexagon.V6.vgtw.128B
llvm.hexagon.V6.vgtw.and
llvm.hexagon.V6.vgtw.and.128B
llvm.hexagon.V6.vgtw.or
llvm.hexagon.V6.vgtw.or.128B
llvm.hexagon.V6.vgtw.xor
llvm.hexagon.V6.vgtw.xor.128B
llvm.hexagon.V6.vinsertwr
llvm.hexagon.V6.vinsertwr.128B
llvm.hexagon.V6.vlalignb
llvm.hexagon.V6.vlalignb.128B
llvm.hexagon.V6.vlalignbi
llvm.hexagon.V6.vlalignbi.128B
llvm.hexagon.V6.vlsrb
llvm.hexagon.V6.vlsrb.128B
llvm.hexagon.V6.vlsrh
llvm.hexagon.V6.vlsrh.128B
llvm.hexagon.V6.vlsrhv
llvm.hexagon.V6.vlsrhv.128B
llvm.hexagon.V6.vlsrw
llvm.hexagon.V6.vlsrw.128B
llvm.hexagon.V6.vlsrwv
llvm.hexagon.V6.vlsrwv.128B
llvm.hexagon.V6.vlut4
llvm.hexagon.V6.vlut4.128B
llvm.hexagon.V6.vlutvvb
llvm.hexagon.V6.vlutvvb.128B
llvm.hexagon.V6.vlutvvb.nm
llvm.hexagon.V6.vlutvvb.nm.128B
llvm.hexagon.V6.vlutvvb.oracc
llvm.hexagon.V6.vlutvvb.oracc.128B
llvm.hexagon.V6.vlutvvb.oracci
llvm.hexagon.V6.vlutvvb.oracci.128B
llvm.hexagon.V6.vlutvvbi
llvm.hexagon.V6.vlutvvbi.128B
llvm.hexagon.V6.vlutvwh
llvm.hexagon.V6.vlutvwh.128B
llvm.hexagon.V6.vlutvwh.nm
llvm.hexagon.V6.vlutvwh.nm.128B
llvm.hexagon.V6.vlutvwh.oracc
llvm.hexagon.V6.vlutvwh.oracc.128B
llvm.hexagon.V6.vlutvwh.oracci
llvm.hexagon.V6.vlutvwh.oracci.128B
llvm.hexagon.V6.vlutvwhi
llvm.hexagon.V6.vlutvwhi.128B
llvm.hexagon.V6.vmaskedstorenq
llvm.hexagon.V6.vmaskedstorenq.128B
llvm.hexagon.V6.vmaskedstorentnq
llvm.hexagon.V6.vmaskedstorentnq.128B
llvm.hexagon.V6.vmaskedstorentq
llvm.hexagon.V6.vmaskedstorentq.128B
llvm.hexagon.V6.vmaskedstoreq
llvm.hexagon.V6.vmaskedstoreq.128B
llvm.hexagon.V6.vmaxb
llvm.hexagon.V6.vmaxb.128B
llvm.hexagon.V6.vmaxh
llvm.hexagon.V6.vmaxh.128B
llvm.hexagon.V6.vmaxub
llvm.hexagon.V6.vmaxub.128B
llvm.hexagon.V6.vmaxuh
llvm.hexagon.V6.vmaxuh.128B
llvm.hexagon.V6.vmaxw
llvm.hexagon.V6.vmaxw.128B
llvm.hexagon.V6.vminb
llvm.hexagon.V6.vminb.128B
llvm.hexagon.V6.vminh
llvm.hexagon.V6.vminh.128B
llvm.hexagon.V6.vminub
llvm.hexagon.V6.vminub.128B
llvm.hexagon.V6.vminuh
llvm.hexagon.V6.vminuh.128B
llvm.hexagon.V6.vminw
llvm.hexagon.V6.vminw.128B
llvm.hexagon.V6.vmpabus
llvm.hexagon.V6.vmpabus.128B
llvm.hexagon.V6.vmpabus.acc
llvm.hexagon.V6.vmpabus.acc.128B
llvm.hexagon.V6.vmpabusv
llvm.hexagon.V6.vmpabusv.128B
llvm.hexagon.V6.vmpabuu
llvm.hexagon.V6.vmpabuu.128B
llvm.hexagon.V6.vmpabuu.acc
llvm.hexagon.V6.vmpabuu.acc.128B
llvm.hexagon.V6.vmpabuuv
llvm.hexagon.V6.vmpabuuv.128B
llvm.hexagon.V6.vmpahb
llvm.hexagon.V6.vmpahb.128B
llvm.hexagon.V6.vmpahb.acc
llvm.hexagon.V6.vmpahb.acc.128B
llvm.hexagon.V6.vmpahhsat
llvm.hexagon.V6.vmpahhsat.128B
llvm.hexagon.V6.vmpauhb
llvm.hexagon.V6.vmpauhb.128B
llvm.hexagon.V6.vmpauhb.acc
llvm.hexagon.V6.vmpauhb.acc.128B
llvm.hexagon.V6.vmpauhuhsat
llvm.hexagon.V6.vmpauhuhsat.128B
llvm.hexagon.V6.vmpsuhuhsat
llvm.hexagon.V6.vmpsuhuhsat.128B
llvm.hexagon.V6.vmpybus
llvm.hexagon.V6.vmpybus.128B
llvm.hexagon.V6.vmpybus.acc
llvm.hexagon.V6.vmpybus.acc.128B
llvm.hexagon.V6.vmpybusv
llvm.hexagon.V6.vmpybusv.128B
llvm.hexagon.V6.vmpybusv.acc
llvm.hexagon.V6.vmpybusv.acc.128B
llvm.hexagon.V6.vmpybv
llvm.hexagon.V6.vmpybv.128B
llvm.hexagon.V6.vmpybv.acc
llvm.hexagon.V6.vmpybv.acc.128B
llvm.hexagon.V6.vmpyewuh
llvm.hexagon.V6.vmpyewuh.128B
llvm.hexagon.V6.vmpyewuh.64
llvm.hexagon.V6.vmpyewuh.64.128B
llvm.hexagon.V6.vmpyh
llvm.hexagon.V6.vmpyh.128B
llvm.hexagon.V6.vmpyh.acc
llvm.hexagon.V6.vmpyh.acc.128B
llvm.hexagon.V6.vmpyhsat.acc
llvm.hexagon.V6.vmpyhsat.acc.128B
llvm.hexagon.V6.vmpyhsrs
llvm.hexagon.V6.vmpyhsrs.128B
llvm.hexagon.V6.vmpyhss
llvm.hexagon.V6.vmpyhss.128B
llvm.hexagon.V6.vmpyhus
llvm.hexagon.V6.vmpyhus.128B
llvm.hexagon.V6.vmpyhus.acc
llvm.hexagon.V6.vmpyhus.acc.128B
llvm.hexagon.V6.vmpyhv
llvm.hexagon.V6.vmpyhv.128B
llvm.hexagon.V6.vmpyhv.acc
llvm.hexagon.V6.vmpyhv.acc.128B
llvm.hexagon.V6.vmpyhvsrs
llvm.hexagon.V6.vmpyhvsrs.128B
llvm.hexagon.V6.vmpyieoh
llvm.hexagon.V6.vmpyieoh.128B
llvm.hexagon.V6.vmpyiewh.acc
llvm.hexagon.V6.vmpyiewh.acc.128B
llvm.hexagon.V6.vmpyiewuh
llvm.hexagon.V6.vmpyiewuh.128B
llvm.hexagon.V6.vmpyiewuh.acc
llvm.hexagon.V6.vmpyiewuh.acc.128B
llvm.hexagon.V6.vmpyih
llvm.hexagon.V6.vmpyih.128B
llvm.hexagon.V6.vmpyih.acc
llvm.hexagon.V6.vmpyih.acc.128B
llvm.hexagon.V6.vmpyihb
llvm.hexagon.V6.vmpyihb.128B
llvm.hexagon.V6.vmpyihb.acc
llvm.hexagon.V6.vmpyihb.acc.128B
llvm.hexagon.V6.vmpyiowh
llvm.hexagon.V6.vmpyiowh.128B
llvm.hexagon.V6.vmpyiwb
llvm.hexagon.V6.vmpyiwb.128B
llvm.hexagon.V6.vmpyiwb.acc
llvm.hexagon.V6.vmpyiwb.acc.128B
llvm.hexagon.V6.vmpyiwh
llvm.hexagon.V6.vmpyiwh.128B
llvm.hexagon.V6.vmpyiwh.acc
llvm.hexagon.V6.vmpyiwh.acc.128B
llvm.hexagon.V6.vmpyiwub
llvm.hexagon.V6.vmpyiwub.128B
llvm.hexagon.V6.vmpyiwub.acc
llvm.hexagon.V6.vmpyiwub.acc.128B
llvm.hexagon.V6.vmpyowh
llvm.hexagon.V6.vmpyowh.128B
llvm.hexagon.V6.vmpyowh.64.acc
llvm.hexagon.V6.vmpyowh.64.acc.128B
llvm.hexagon.V6.vmpyowh.rnd
llvm.hexagon.V6.vmpyowh.rnd.128B
llvm.hexagon.V6.vmpyowh.rnd.sacc
llvm.hexagon.V6.vmpyowh.rnd.sacc.128B
llvm.hexagon.V6.vmpyowh.sacc
llvm.hexagon.V6.vmpyowh.sacc.128B
llvm.hexagon.V6.vmpyub
llvm.hexagon.V6.vmpyub.128B
llvm.hexagon.V6.vmpyub.acc
llvm.hexagon.V6.vmpyub.acc.128B
llvm.hexagon.V6.vmpyubv
llvm.hexagon.V6.vmpyubv.128B
llvm.hexagon.V6.vmpyubv.acc
llvm.hexagon.V6.vmpyubv.acc.128B
llvm.hexagon.V6.vmpyuh
llvm.hexagon.V6.vmpyuh.128B
llvm.hexagon.V6.vmpyuh.acc
llvm.hexagon.V6.vmpyuh.acc.128B
llvm.hexagon.V6.vmpyuhe
llvm.hexagon.V6.vmpyuhe.128B
llvm.hexagon.V6.vmpyuhe.acc
llvm.hexagon.V6.vmpyuhe.acc.128B
llvm.hexagon.V6.vmpyuhv
llvm.hexagon.V6.vmpyuhv.128B
llvm.hexagon.V6.vmpyuhv.acc
llvm.hexagon.V6.vmpyuhv.acc.128B
llvm.hexagon.V6.vmux
llvm.hexagon.V6.vmux.128B
llvm.hexagon.V6.vnavgb
llvm.hexagon.V6.vnavgb.128B
llvm.hexagon.V6.vnavgh
llvm.hexagon.V6.vnavgh.128B
llvm.hexagon.V6.vnavgub
llvm.hexagon.V6.vnavgub.128B
llvm.hexagon.V6.vnavgw
llvm.hexagon.V6.vnavgw.128B
llvm.hexagon.V6.vnormamth
llvm.hexagon.V6.vnormamth.128B
llvm.hexagon.V6.vnormamtw
llvm.hexagon.V6.vnormamtw.128B
llvm.hexagon.V6.vnot
llvm.hexagon.V6.vnot.128B
llvm.hexagon.V6.vor
llvm.hexagon.V6.vor.128B
llvm.hexagon.V6.vpackeb
llvm.hexagon.V6.vpackeb.128B
llvm.hexagon.V6.vpackeh
llvm.hexagon.V6.vpackeh.128B
llvm.hexagon.V6.vpackhb.sat
llvm.hexagon.V6.vpackhb.sat.128B
llvm.hexagon.V6.vpackhub.sat
llvm.hexagon.V6.vpackhub.sat.128B
llvm.hexagon.V6.vpackob
llvm.hexagon.V6.vpackob.128B
llvm.hexagon.V6.vpackoh
llvm.hexagon.V6.vpackoh.128B
llvm.hexagon.V6.vpackwh.sat
llvm.hexagon.V6.vpackwh.sat.128B
llvm.hexagon.V6.vpackwuh.sat
llvm.hexagon.V6.vpackwuh.sat.128B
llvm.hexagon.V6.vpopcounth
llvm.hexagon.V6.vpopcounth.128B
llvm.hexagon.V6.vprefixqb
llvm.hexagon.V6.vprefixqb.128B
llvm.hexagon.V6.vprefixqh
llvm.hexagon.V6.vprefixqh.128B
llvm.hexagon.V6.vprefixqw
llvm.hexagon.V6.vprefixqw.128B
llvm.hexagon.V6.vrdelta
llvm.hexagon.V6.vrdelta.128B
llvm.hexagon.V6.vrmpybub.rtt
llvm.hexagon.V6.vrmpybub.rtt.128B
llvm.hexagon.V6.vrmpybub.rtt.acc
llvm.hexagon.V6.vrmpybub.rtt.acc.128B
llvm.hexagon.V6.vrmpybus
llvm.hexagon.V6.vrmpybus.128B
llvm.hexagon.V6.vrmpybus.acc
llvm.hexagon.V6.vrmpybus.acc.128B
llvm.hexagon.V6.vrmpybusi
llvm.hexagon.V6.vrmpybusi.128B
llvm.hexagon.V6.vrmpybusi.acc
llvm.hexagon.V6.vrmpybusi.acc.128B
llvm.hexagon.V6.vrmpybusv
llvm.hexagon.V6.vrmpybusv.128B
llvm.hexagon.V6.vrmpybusv.acc
llvm.hexagon.V6.vrmpybusv.acc.128B
llvm.hexagon.V6.vrmpybv
llvm.hexagon.V6.vrmpybv.128B
llvm.hexagon.V6.vrmpybv.acc
llvm.hexagon.V6.vrmpybv.acc.128B
llvm.hexagon.V6.vrmpyub
llvm.hexagon.V6.vrmpyub.128B
llvm.hexagon.V6.vrmpyub.acc
llvm.hexagon.V6.vrmpyub.acc.128B
llvm.hexagon.V6.vrmpyub.rtt
llvm.hexagon.V6.vrmpyub.rtt.128B
llvm.hexagon.V6.vrmpyub.rtt.acc
llvm.hexagon.V6.vrmpyub.rtt.acc.128B
llvm.hexagon.V6.vrmpyubi
llvm.hexagon.V6.vrmpyubi.128B
llvm.hexagon.V6.vrmpyubi.acc
llvm.hexagon.V6.vrmpyubi.acc.128B
llvm.hexagon.V6.vrmpyubv
llvm.hexagon.V6.vrmpyubv.128B
llvm.hexagon.V6.vrmpyubv.acc
llvm.hexagon.V6.vrmpyubv.acc.128B
llvm.hexagon.V6.vror
llvm.hexagon.V6.vror.128B
llvm.hexagon.V6.vroundhb
llvm.hexagon.V6.vroundhb.128B
llvm.hexagon.V6.vroundhub
llvm.hexagon.V6.vroundhub.128B
llvm.hexagon.V6.vrounduhub
llvm.hexagon.V6.vrounduhub.128B
llvm.hexagon.V6.vrounduwuh
llvm.hexagon.V6.vrounduwuh.128B
llvm.hexagon.V6.vroundwh
llvm.hexagon.V6.vroundwh.128B
llvm.hexagon.V6.vroundwuh
llvm.hexagon.V6.vroundwuh.128B
llvm.hexagon.V6.vrsadubi
llvm.hexagon.V6.vrsadubi.128B
llvm.hexagon.V6.vrsadubi.acc
llvm.hexagon.V6.vrsadubi.acc.128B
llvm.hexagon.V6.vsathub
llvm.hexagon.V6.vsathub.128B
llvm.hexagon.V6.vsatuwuh
llvm.hexagon.V6.vsatuwuh.128B
llvm.hexagon.V6.vsatwh
llvm.hexagon.V6.vsatwh.128B
llvm.hexagon.V6.vsb
llvm.hexagon.V6.vsb.128B
llvm.hexagon.V6.vscattermh
llvm.hexagon.V6.vscattermh.128B
llvm.hexagon.V6.vscattermh.add
llvm.hexagon.V6.vscattermh.add.128B
llvm.hexagon.V6.vscattermhq
llvm.hexagon.V6.vscattermhq.128B
llvm.hexagon.V6.vscattermhw
llvm.hexagon.V6.vscattermhw.128B
llvm.hexagon.V6.vscattermhw.add
llvm.hexagon.V6.vscattermhw.add.128B
llvm.hexagon.V6.vscattermhwq
llvm.hexagon.V6.vscattermhwq.128B
llvm.hexagon.V6.vscattermw
llvm.hexagon.V6.vscattermw.128B
llvm.hexagon.V6.vscattermw.add
llvm.hexagon.V6.vscattermw.add.128B
llvm.hexagon.V6.vscattermwq
llvm.hexagon.V6.vscattermwq.128B
llvm.hexagon.V6.vsh
llvm.hexagon.V6.vsh.128B
llvm.hexagon.V6.vshufeh
llvm.hexagon.V6.vshufeh.128B
llvm.hexagon.V6.vshuffb
llvm.hexagon.V6.vshuffb.128B
llvm.hexagon.V6.vshuffeb
llvm.hexagon.V6.vshuffeb.128B
llvm.hexagon.V6.vshuffh
llvm.hexagon.V6.vshuffh.128B
llvm.hexagon.V6.vshuffob
llvm.hexagon.V6.vshuffob.128B
llvm.hexagon.V6.vshuffvdd
llvm.hexagon.V6.vshuffvdd.128B
llvm.hexagon.V6.vshufoeb
llvm.hexagon.V6.vshufoeb.128B
llvm.hexagon.V6.vshufoeh
llvm.hexagon.V6.vshufoeh.128B
llvm.hexagon.V6.vshufoh
llvm.hexagon.V6.vshufoh.128B
llvm.hexagon.V6.vsubb
llvm.hexagon.V6.vsubb.128B
llvm.hexagon.V6.vsubb.dv
llvm.hexagon.V6.vsubb.dv.128B
llvm.hexagon.V6.vsubbnq
llvm.hexagon.V6.vsubbnq.128B
llvm.hexagon.V6.vsubbq
llvm.hexagon.V6.vsubbq.128B
llvm.hexagon.V6.vsubbsat
llvm.hexagon.V6.vsubbsat.128B
llvm.hexagon.V6.vsubbsat.dv
llvm.hexagon.V6.vsubbsat.dv.128B
llvm.hexagon.V6.vsubcarry
llvm.hexagon.V6.vsubcarry.128B
llvm.hexagon.V6.vsubh
llvm.hexagon.V6.vsubh.128B
llvm.hexagon.V6.vsubh.dv
llvm.hexagon.V6.vsubh.dv.128B
llvm.hexagon.V6.vsubhnq
llvm.hexagon.V6.vsubhnq.128B
llvm.hexagon.V6.vsubhq
llvm.hexagon.V6.vsubhq.128B
llvm.hexagon.V6.vsubhsat
llvm.hexagon.V6.vsubhsat.128B
llvm.hexagon.V6.vsubhsat.dv
llvm.hexagon.V6.vsubhsat.dv.128B
llvm.hexagon.V6.vsubhw
llvm.hexagon.V6.vsubhw.128B
llvm.hexagon.V6.vsububh
llvm.hexagon.V6.vsububh.128B
llvm.hexagon.V6.vsububsat
llvm.hexagon.V6.vsububsat.128B
llvm.hexagon.V6.vsububsat.dv
llvm.hexagon.V6.vsububsat.dv.128B
llvm.hexagon.V6.vsubububb.sat
llvm.hexagon.V6.vsubububb.sat.128B
llvm.hexagon.V6.vsubuhsat
llvm.hexagon.V6.vsubuhsat.128B
llvm.hexagon.V6.vsubuhsat.dv
llvm.hexagon.V6.vsubuhsat.dv.128B
llvm.hexagon.V6.vsubuhw
llvm.hexagon.V6.vsubuhw.128B
llvm.hexagon.V6.vsubuwsat
llvm.hexagon.V6.vsubuwsat.128B
llvm.hexagon.V6.vsubuwsat.dv
llvm.hexagon.V6.vsubuwsat.dv.128B
llvm.hexagon.V6.vsubw
llvm.hexagon.V6.vsubw.128B
llvm.hexagon.V6.vsubw.dv
llvm.hexagon.V6.vsubw.dv.128B
llvm.hexagon.V6.vsubwnq
llvm.hexagon.V6.vsubwnq.128B
llvm.hexagon.V6.vsubwq
llvm.hexagon.V6.vsubwq.128B
llvm.hexagon.V6.vsubwsat
llvm.hexagon.V6.vsubwsat.128B
llvm.hexagon.V6.vsubwsat.dv
llvm.hexagon.V6.vsubwsat.dv.128B
llvm.hexagon.V6.vswap
llvm.hexagon.V6.vswap.128B
llvm.hexagon.V6.vtmpyb
llvm.hexagon.V6.vtmpyb.128B
llvm.hexagon.V6.vtmpyb.acc
llvm.hexagon.V6.vtmpyb.acc.128B
llvm.hexagon.V6.vtmpybus
llvm.hexagon.V6.vtmpybus.128B
llvm.hexagon.V6.vtmpybus.acc
llvm.hexagon.V6.vtmpybus.acc.128B
llvm.hexagon.V6.vtmpyhb
llvm.hexagon.V6.vtmpyhb.128B
llvm.hexagon.V6.vtmpyhb.acc
llvm.hexagon.V6.vtmpyhb.acc.128B
llvm.hexagon.V6.vunpackb
llvm.hexagon.V6.vunpackb.128B
llvm.hexagon.V6.vunpackh
llvm.hexagon.V6.vunpackh.128B
llvm.hexagon.V6.vunpackob
llvm.hexagon.V6.vunpackob.128B
llvm.hexagon.V6.vunpackoh
llvm.hexagon.V6.vunpackoh.128B
llvm.hexagon.V6.vunpackub
llvm.hexagon.V6.vunpackub.128B
llvm.hexagon.V6.vunpackuh
llvm.hexagon.V6.vunpackuh.128B
llvm.hexagon.V6.vxor
llvm.hexagon.V6.vxor.128B
llvm.hexagon.V6.vzb
llvm.hexagon.V6.vzb.128B
llvm.hexagon.V6.vzh
llvm.hexagon.V6.vzh.128B
llvm.hexagon.Y2.dccleana
llvm.hexagon.Y2.dccleaninva
llvm.hexagon.Y2.dcinva
llvm.hexagon.Y2.dczeroa
llvm.hexagon.Y4.l2fetch
llvm.hexagon.Y5.l2fetch
llvm.hexagon.circ.ldb
llvm.hexagon.circ.ldd
llvm.hexagon.circ.ldh
llvm.hexagon.circ.ldub
llvm.hexagon.circ.lduh
llvm.hexagon.circ.ldw
llvm.hexagon.circ.stb
llvm.hexagon.circ.std
llvm.hexagon.circ.sth
llvm.hexagon.circ.sthhi
llvm.hexagon.circ.stw
llvm.hexagon.mm256i.vaddw
llvm.hexagon.prefetch
llvm.mips.absq.s.ph
llvm.mips.absq.s.qb
llvm.mips.absq.s.w
llvm.mips.add.a.b
llvm.mips.add.a.d
llvm.mips.add.a.h
llvm.mips.add.a.w
llvm.mips.addq.ph
llvm.mips.addq.s.ph
llvm.mips.addq.s.w
llvm.mips.addqh.ph
llvm.mips.addqh.r.ph
llvm.mips.addqh.r.w
llvm.mips.addqh.w
llvm.mips.adds.a.b
llvm.mips.adds.a.d
llvm.mips.adds.a.h
llvm.mips.adds.a.w
llvm.mips.adds.s.b
llvm.mips.adds.s.d
llvm.mips.adds.s.h
llvm.mips.adds.s.w
llvm.mips.adds.u.b
llvm.mips.adds.u.d
llvm.mips.adds.u.h
llvm.mips.adds.u.w
llvm.mips.addsc
llvm.mips.addu.ph
llvm.mips.addu.qb
llvm.mips.addu.s.ph
llvm.mips.addu.s.qb
llvm.mips.adduh.qb
llvm.mips.adduh.r.qb
llvm.mips.addv.b
llvm.mips.addv.d
llvm.mips.addv.h
llvm.mips.addv.w
llvm.mips.addvi.b
llvm.mips.addvi.d
llvm.mips.addvi.h
llvm.mips.addvi.w
llvm.mips.addwc
llvm.mips.and.v
llvm.mips.andi.b
llvm.mips.append
llvm.mips.asub.s.b
llvm.mips.asub.s.d
llvm.mips.asub.s.h
llvm.mips.asub.s.w
llvm.mips.asub.u.b
llvm.mips.asub.u.d
llvm.mips.asub.u.h
llvm.mips.asub.u.w
llvm.mips.ave.s.b
llvm.mips.ave.s.d
llvm.mips.ave.s.h
llvm.mips.ave.s.w
llvm.mips.ave.u.b
llvm.mips.ave.u.d
llvm.mips.ave.u.h
llvm.mips.ave.u.w
llvm.mips.aver.s.b
llvm.mips.aver.s.d
llvm.mips.aver.s.h
llvm.mips.aver.s.w
llvm.mips.aver.u.b
llvm.mips.aver.u.d
llvm.mips.aver.u.h
llvm.mips.aver.u.w
llvm.mips.balign
llvm.mips.bclr.b
llvm.mips.bclr.d
llvm.mips.bclr.h
llvm.mips.bclr.w
llvm.mips.bclri.b
llvm.mips.bclri.d
llvm.mips.bclri.h
llvm.mips.bclri.w
llvm.mips.binsl.b
llvm.mips.binsl.d
llvm.mips.binsl.h
llvm.mips.binsl.w
llvm.mips.binsli.b
llvm.mips.binsli.d
llvm.mips.binsli.h
llvm.mips.binsli.w
llvm.mips.binsr.b
llvm.mips.binsr.d
llvm.mips.binsr.h
llvm.mips.binsr.w
llvm.mips.binsri.b
llvm.mips.binsri.d
llvm.mips.binsri.h
llvm.mips.binsri.w
llvm.mips.bitrev
llvm.mips.bmnz.v
llvm.mips.bmnzi.b
llvm.mips.bmz.v
llvm.mips.bmzi.b
llvm.mips.bneg.b
llvm.mips.bneg.d
llvm.mips.bneg.h
llvm.mips.bneg.w
llvm.mips.bnegi.b
llvm.mips.bnegi.d
llvm.mips.bnegi.h
llvm.mips.bnegi.w
llvm.mips.bnz.b
llvm.mips.bnz.d
llvm.mips.bnz.h
llvm.mips.bnz.v
llvm.mips.bnz.w
llvm.mips.bposge32
llvm.mips.bsel.v
llvm.mips.bseli.b
llvm.mips.bset.b
llvm.mips.bset.d
llvm.mips.bset.h
llvm.mips.bset.w
llvm.mips.bseti.b
llvm.mips.bseti.d
llvm.mips.bseti.h
llvm.mips.bseti.w
llvm.mips.bz.b
llvm.mips.bz.d
llvm.mips.bz.h
llvm.mips.bz.v
llvm.mips.bz.w
llvm.mips.ceq.b
llvm.mips.ceq.d
llvm.mips.ceq.h
llvm.mips.ceq.w
llvm.mips.ceqi.b
llvm.mips.ceqi.d
llvm.mips.ceqi.h
llvm.mips.ceqi.w
llvm.mips.cfcmsa
llvm.mips.cle.s.b
llvm.mips.cle.s.d
llvm.mips.cle.s.h
llvm.mips.cle.s.w
llvm.mips.cle.u.b
llvm.mips.cle.u.d
llvm.mips.cle.u.h
llvm.mips.cle.u.w
llvm.mips.clei.s.b
llvm.mips.clei.s.d
llvm.mips.clei.s.h
llvm.mips.clei.s.w
llvm.mips.clei.u.b
llvm.mips.clei.u.d
llvm.mips.clei.u.h
llvm.mips.clei.u.w
llvm.mips.clt.s.b
llvm.mips.clt.s.d
llvm.mips.clt.s.h
llvm.mips.clt.s.w
llvm.mips.clt.u.b
llvm.mips.clt.u.d
llvm.mips.clt.u.h
llvm.mips.clt.u.w
llvm.mips.clti.s.b
llvm.mips.clti.s.d
llvm.mips.clti.s.h
llvm.mips.clti.s.w
llvm.mips.clti.u.b
llvm.mips.clti.u.d
llvm.mips.clti.u.h
llvm.mips.clti.u.w
llvm.mips.cmp.eq.ph
llvm.mips.cmp.le.ph
llvm.mips.cmp.lt.ph
llvm.mips.cmpgdu.eq.qb
llvm.mips.cmpgdu.le.qb
llvm.mips.cmpgdu.lt.qb
llvm.mips.cmpgu.eq.qb
llvm.mips.cmpgu.le.qb
llvm.mips.cmpgu.lt.qb
llvm.mips.cmpu.eq.qb
llvm.mips.cmpu.le.qb
llvm.mips.cmpu.lt.qb
llvm.mips.copy.s.b
llvm.mips.copy.s.d
llvm.mips.copy.s.h
llvm.mips.copy.s.w
llvm.mips.copy.u.b
llvm.mips.copy.u.d
llvm.mips.copy.u.h
llvm.mips.copy.u.w
llvm.mips.ctcmsa
llvm.mips.div.s.b
llvm.mips.div.s.d
llvm.mips.div.s.h
llvm.mips.div.s.w
llvm.mips.div.u.b
llvm.mips.div.u.d
llvm.mips.div.u.h
llvm.mips.div.u.w
llvm.mips.dlsa
llvm.mips.dotp.s.d
llvm.mips.dotp.s.h
llvm.mips.dotp.s.w
llvm.mips.dotp.u.d
llvm.mips.dotp.u.h
llvm.mips.dotp.u.w
llvm.mips.dpa.w.ph
llvm.mips.dpadd.s.d
llvm.mips.dpadd.s.h
llvm.mips.dpadd.s.w
llvm.mips.dpadd.u.d
llvm.mips.dpadd.u.h
llvm.mips.dpadd.u.w
llvm.mips.dpaq.s.w.ph
llvm.mips.dpaq.sa.l.w
llvm.mips.dpaqx.s.w.ph
llvm.mips.dpaqx.sa.w.ph
llvm.mips.dpau.h.qbl
llvm.mips.dpau.h.qbr
llvm.mips.dpax.w.ph
llvm.mips.dps.w.ph
llvm.mips.dpsq.s.w.ph
llvm.mips.dpsq.sa.l.w
llvm.mips.dpsqx.s.w.ph
llvm.mips.dpsqx.sa.w.ph
llvm.mips.dpsu.h.qbl
llvm.mips.dpsu.h.qbr
llvm.mips.dpsub.s.d
llvm.mips.dpsub.s.h
llvm.mips.dpsub.s.w
llvm.mips.dpsub.u.d
llvm.mips.dpsub.u.h
llvm.mips.dpsub.u.w
llvm.mips.dpsx.w.ph
llvm.mips.extp
llvm.mips.extpdp
llvm.mips.extr.r.w
llvm.mips.extr.rs.w
llvm.mips.extr.s.h
llvm.mips.extr.w
llvm.mips.fadd.d
llvm.mips.fadd.w
llvm.mips.fcaf.d
llvm.mips.fcaf.w
llvm.mips.fceq.d
llvm.mips.fceq.w
llvm.mips.fclass.d
llvm.mips.fclass.w
llvm.mips.fcle.d
llvm.mips.fcle.w
llvm.mips.fclt.d
llvm.mips.fclt.w
llvm.mips.fcne.d
llvm.mips.fcne.w
llvm.mips.fcor.d
llvm.mips.fcor.w
llvm.mips.fcueq.d
llvm.mips.fcueq.w
llvm.mips.fcule.d
llvm.mips.fcule.w
llvm.mips.fcult.d
llvm.mips.fcult.w
llvm.mips.fcun.d
llvm.mips.fcun.w
llvm.mips.fcune.d
llvm.mips.fcune.w
llvm.mips.fdiv.d
llvm.mips.fdiv.w
llvm.mips.fexdo.h
llvm.mips.fexdo.w
llvm.mips.fexp2.d
llvm.mips.fexp2.w
llvm.mips.fexupl.d
llvm.mips.fexupl.w
llvm.mips.fexupr.d
llvm.mips.fexupr.w
llvm.mips.ffint.s.d
llvm.mips.ffint.s.w
llvm.mips.ffint.u.d
llvm.mips.ffint.u.w
llvm.mips.ffql.d
llvm.mips.ffql.w
llvm.mips.ffqr.d
llvm.mips.ffqr.w
llvm.mips.fill.b
llvm.mips.fill.d
llvm.mips.fill.h
llvm.mips.fill.w
llvm.mips.flog2.d
llvm.mips.flog2.w
llvm.mips.fmadd.d
llvm.mips.fmadd.w
llvm.mips.fmax.a.d
llvm.mips.fmax.a.w
llvm.mips.fmax.d
llvm.mips.fmax.w
llvm.mips.fmin.a.d
llvm.mips.fmin.a.w
llvm.mips.fmin.d
llvm.mips.fmin.w
llvm.mips.fmsub.d
llvm.mips.fmsub.w
llvm.mips.fmul.d
llvm.mips.fmul.w
llvm.mips.frcp.d
llvm.mips.frcp.w
llvm.mips.frint.d
llvm.mips.frint.w
llvm.mips.frsqrt.d
llvm.mips.frsqrt.w
llvm.mips.fsaf.d
llvm.mips.fsaf.w
llvm.mips.fseq.d
llvm.mips.fseq.w
llvm.mips.fsle.d
llvm.mips.fsle.w
llvm.mips.fslt.d
llvm.mips.fslt.w
llvm.mips.fsne.d
llvm.mips.fsne.w
llvm.mips.fsor.d
llvm.mips.fsor.w
llvm.mips.fsqrt.d
llvm.mips.fsqrt.w
llvm.mips.fsub.d
llvm.mips.fsub.w
llvm.mips.fsueq.d
llvm.mips.fsueq.w
llvm.mips.fsule.d
llvm.mips.fsule.w
llvm.mips.fsult.d
llvm.mips.fsult.w
llvm.mips.fsun.d
llvm.mips.fsun.w
llvm.mips.fsune.d
llvm.mips.fsune.w
llvm.mips.ftint.s.d
llvm.mips.ftint.s.w
llvm.mips.ftint.u.d
llvm.mips.ftint.u.w
llvm.mips.ftq.h
llvm.mips.ftq.w
llvm.mips.ftrunc.s.d
llvm.mips.ftrunc.s.w
llvm.mips.ftrunc.u.d
llvm.mips.ftrunc.u.w
llvm.mips.hadd.s.d
llvm.mips.hadd.s.h
llvm.mips.hadd.s.w
llvm.mips.hadd.u.d
llvm.mips.hadd.u.h
llvm.mips.hadd.u.w
llvm.mips.hsub.s.d
llvm.mips.hsub.s.h
llvm.mips.hsub.s.w
llvm.mips.hsub.u.d
llvm.mips.hsub.u.h
llvm.mips.hsub.u.w
llvm.mips.ilvev.b
llvm.mips.ilvev.d
llvm.mips.ilvev.h
llvm.mips.ilvev.w
llvm.mips.ilvl.b
llvm.mips.ilvl.d
llvm.mips.ilvl.h
llvm.mips.ilvl.w
llvm.mips.ilvod.b
llvm.mips.ilvod.d
llvm.mips.ilvod.h
llvm.mips.ilvod.w
llvm.mips.ilvr.b
llvm.mips.ilvr.d
llvm.mips.ilvr.h
llvm.mips.ilvr.w
llvm.mips.insert.b
llvm.mips.insert.d
llvm.mips.insert.h
llvm.mips.insert.w
llvm.mips.insv
llvm.mips.insve.b
llvm.mips.insve.d
llvm.mips.insve.h
llvm.mips.insve.w
llvm.mips.lbux
llvm.mips.ld.b
llvm.mips.ld.d
llvm.mips.ld.h
llvm.mips.ld.w
llvm.mips.ldi.b
llvm.mips.ldi.d
llvm.mips.ldi.h
llvm.mips.ldi.w
llvm.mips.lhx
llvm.mips.lsa
llvm.mips.lwx
llvm.mips.madd
llvm.mips.madd.q.h
llvm.mips.madd.q.w
llvm.mips.maddr.q.h
llvm.mips.maddr.q.w
llvm.mips.maddu
llvm.mips.maddv.b
llvm.mips.maddv.d
llvm.mips.maddv.h
llvm.mips.maddv.w
llvm.mips.maq.s.w.phl
llvm.mips.maq.s.w.phr
llvm.mips.maq.sa.w.phl
llvm.mips.maq.sa.w.phr
llvm.mips.max.a.b
llvm.mips.max.a.d
llvm.mips.max.a.h
llvm.mips.max.a.w
llvm.mips.max.s.b
llvm.mips.max.s.d
llvm.mips.max.s.h
llvm.mips.max.s.w
llvm.mips.max.u.b
llvm.mips.max.u.d
llvm.mips.max.u.h
llvm.mips.max.u.w
llvm.mips.maxi.s.b
llvm.mips.maxi.s.d
llvm.mips.maxi.s.h
llvm.mips.maxi.s.w
llvm.mips.maxi.u.b
llvm.mips.maxi.u.d
llvm.mips.maxi.u.h
llvm.mips.maxi.u.w
llvm.mips.min.a.b
llvm.mips.min.a.d
llvm.mips.min.a.h
llvm.mips.min.a.w
llvm.mips.min.s.b
llvm.mips.min.s.d
llvm.mips.min.s.h
llvm.mips.min.s.w
llvm.mips.min.u.b
llvm.mips.min.u.d
llvm.mips.min.u.h
llvm.mips.min.u.w
llvm.mips.mini.s.b
llvm.mips.mini.s.d
llvm.mips.mini.s.h
llvm.mips.mini.s.w
llvm.mips.mini.u.b
llvm.mips.mini.u.d
llvm.mips.mini.u.h
llvm.mips.mini.u.w
llvm.mips.mod.s.b
llvm.mips.mod.s.d
llvm.mips.mod.s.h
llvm.mips.mod.s.w
llvm.mips.mod.u.b
llvm.mips.mod.u.d
llvm.mips.mod.u.h
llvm.mips.mod.u.w
llvm.mips.modsub
llvm.mips.move.v
llvm.mips.msub
llvm.mips.msub.q.h
llvm.mips.msub.q.w
llvm.mips.msubr.q.h
llvm.mips.msubr.q.w
llvm.mips.msubu
llvm.mips.msubv.b
llvm.mips.msubv.d
llvm.mips.msubv.h
llvm.mips.msubv.w
llvm.mips.mthlip
llvm.mips.mul.ph
llvm.mips.mul.q.h
llvm.mips.mul.q.w
llvm.mips.mul.s.ph
llvm.mips.muleq.s.w.phl
llvm.mips.muleq.s.w.phr
llvm.mips.muleu.s.ph.qbl
llvm.mips.muleu.s.ph.qbr
llvm.mips.mulq.rs.ph
llvm.mips.mulq.rs.w
llvm.mips.mulq.s.ph
llvm.mips.mulq.s.w
llvm.mips.mulr.q.h
llvm.mips.mulr.q.w
llvm.mips.mulsa.w.ph
llvm.mips.mulsaq.s.w.ph
llvm.mips.mult
llvm.mips.multu
llvm.mips.mulv.b
llvm.mips.mulv.d
llvm.mips.mulv.h
llvm.mips.mulv.w
llvm.mips.nloc.b
llvm.mips.nloc.d
llvm.mips.nloc.h
llvm.mips.nloc.w
llvm.mips.nlzc.b
llvm.mips.nlzc.d
llvm.mips.nlzc.h
llvm.mips.nlzc.w
llvm.mips.nor.v
llvm.mips.nori.b
llvm.mips.or.v
llvm.mips.ori.b
llvm.mips.packrl.ph
llvm.mips.pckev.b
llvm.mips.pckev.d
llvm.mips.pckev.h
llvm.mips.pckev.w
llvm.mips.pckod.b
llvm.mips.pckod.d
llvm.mips.pckod.h
llvm.mips.pckod.w
llvm.mips.pcnt.b
llvm.mips.pcnt.d
llvm.mips.pcnt.h
llvm.mips.pcnt.w
llvm.mips.pick.ph
llvm.mips.pick.qb
llvm.mips.preceq.w.phl
llvm.mips.preceq.w.phr
llvm.mips.precequ.ph.qbl
llvm.mips.precequ.ph.qbla
llvm.mips.precequ.ph.qbr
llvm.mips.precequ.ph.qbra
llvm.mips.preceu.ph.qbl
llvm.mips.preceu.ph.qbla
llvm.mips.preceu.ph.qbr
llvm.mips.preceu.ph.qbra
llvm.mips.precr.qb.ph
llvm.mips.precr.sra.ph.w
llvm.mips.precr.sra.r.ph.w
llvm.mips.precrq.ph.w
llvm.mips.precrq.qb.ph
llvm.mips.precrq.rs.ph.w
llvm.mips.precrqu.s.qb.ph
llvm.mips.prepend
llvm.mips.raddu.w.qb
llvm.mips.rddsp
llvm.mips.repl.ph
llvm.mips.repl.qb
llvm.mips.sat.s.b
llvm.mips.sat.s.d
llvm.mips.sat.s.h
llvm.mips.sat.s.w
llvm.mips.sat.u.b
llvm.mips.sat.u.d
llvm.mips.sat.u.h
llvm.mips.sat.u.w
llvm.mips.shf.b
llvm.mips.shf.h
llvm.mips.shf.w
llvm.mips.shilo
llvm.mips.shll.ph
llvm.mips.shll.qb
llvm.mips.shll.s.ph
llvm.mips.shll.s.w
llvm.mips.shra.ph
llvm.mips.shra.qb
llvm.mips.shra.r.ph
llvm.mips.shra.r.qb
llvm.mips.shra.r.w
llvm.mips.shrl.ph
llvm.mips.shrl.qb
llvm.mips.sld.b
llvm.mips.sld.d
llvm.mips.sld.h
llvm.mips.sld.w
llvm.mips.sldi.b
llvm.mips.sldi.d
llvm.mips.sldi.h
llvm.mips.sldi.w
llvm.mips.sll.b
llvm.mips.sll.d
llvm.mips.sll.h
llvm.mips.sll.w
llvm.mips.slli.b
llvm.mips.slli.d
llvm.mips.slli.h
llvm.mips.slli.w
llvm.mips.splat.b
llvm.mips.splat.d
llvm.mips.splat.h
llvm.mips.splat.w
llvm.mips.splati.b
llvm.mips.splati.d
llvm.mips.splati.h
llvm.mips.splati.w
llvm.mips.sra.b
llvm.mips.sra.d
llvm.mips.sra.h
llvm.mips.sra.w
llvm.mips.srai.b
llvm.mips.srai.d
llvm.mips.srai.h
llvm.mips.srai.w
llvm.mips.srar.b
llvm.mips.srar.d
llvm.mips.srar.h
llvm.mips.srar.w
llvm.mips.srari.b
llvm.mips.srari.d
llvm.mips.srari.h
llvm.mips.srari.w
llvm.mips.srl.b
llvm.mips.srl.d
llvm.mips.srl.h
llvm.mips.srl.w
llvm.mips.srli.b
llvm.mips.srli.d
llvm.mips.srli.h
llvm.mips.srli.w
llvm.mips.srlr.b
llvm.mips.srlr.d
llvm.mips.srlr.h
llvm.mips.srlr.w
llvm.mips.srlri.b
llvm.mips.srlri.d
llvm.mips.srlri.h
llvm.mips.srlri.w
llvm.mips.st.b
llvm.mips.st.d
llvm.mips.st.h
llvm.mips.st.w
llvm.mips.subq.ph
llvm.mips.subq.s.ph
llvm.mips.subq.s.w
llvm.mips.subqh.ph
llvm.mips.subqh.r.ph
llvm.mips.subqh.r.w
llvm.mips.subqh.w
llvm.mips.subs.s.b
llvm.mips.subs.s.d
llvm.mips.subs.s.h
llvm.mips.subs.s.w
llvm.mips.subs.u.b
llvm.mips.subs.u.d
llvm.mips.subs.u.h
llvm.mips.subs.u.w
llvm.mips.subsus.u.b
llvm.mips.subsus.u.d
llvm.mips.subsus.u.h
llvm.mips.subsus.u.w
llvm.mips.subsuu.s.b
llvm.mips.subsuu.s.d
llvm.mips.subsuu.s.h
llvm.mips.subsuu.s.w
llvm.mips.subu.ph
llvm.mips.subu.qb
llvm.mips.subu.s.ph
llvm.mips.subu.s.qb
llvm.mips.subuh.qb
llvm.mips.subuh.r.qb
llvm.mips.subv.b
llvm.mips.subv.d
llvm.mips.subv.h
llvm.mips.subv.w
llvm.mips.subvi.b
llvm.mips.subvi.d
llvm.mips.subvi.h
llvm.mips.subvi.w
llvm.mips.vshf.b
llvm.mips.vshf.d
llvm.mips.vshf.h
llvm.mips.vshf.w
llvm.mips.wrdsp
llvm.mips.xor.v
llvm.mips.xori.b
llvm.nvvm.add.rm.d
llvm.nvvm.add.rm.f
llvm.nvvm.add.rm.ftz.f
llvm.nvvm.add.rn.d
llvm.nvvm.add.rn.f
llvm.nvvm.add.rn.ftz.f
llvm.nvvm.add.rp.d
llvm.nvvm.add.rp.f
llvm.nvvm.add.rp.ftz.f
llvm.nvvm.add.rz.d
llvm.nvvm.add.rz.f
llvm.nvvm.add.rz.ftz.f
llvm.nvvm.atomic.add.gen.f.cta
llvm.nvvm.atomic.add.gen.f.sys
llvm.nvvm.atomic.add.gen.i.cta
llvm.nvvm.atomic.add.gen.i.sys
llvm.nvvm.atomic.and.gen.i.cta
llvm.nvvm.atomic.and.gen.i.sys
llvm.nvvm.atomic.cas.gen.i.cta
llvm.nvvm.atomic.cas.gen.i.sys
llvm.nvvm.atomic.dec.gen.i.cta
llvm.nvvm.atomic.dec.gen.i.sys
llvm.nvvm.atomic.exch.gen.i.cta
llvm.nvvm.atomic.exch.gen.i.sys
llvm.nvvm.atomic.inc.gen.i.cta
llvm.nvvm.atomic.inc.gen.i.sys
llvm.nvvm.atomic.load.add.f32
llvm.nvvm.atomic.load.add.f64
llvm.nvvm.atomic.load.dec.32
llvm.nvvm.atomic.load.inc.32
llvm.nvvm.atomic.max.gen.i.cta
llvm.nvvm.atomic.max.gen.i.sys
llvm.nvvm.atomic.min.gen.i.cta
llvm.nvvm.atomic.min.gen.i.sys
llvm.nvvm.atomic.or.gen.i.cta
llvm.nvvm.atomic.or.gen.i.sys
llvm.nvvm.atomic.xor.gen.i.cta
llvm.nvvm.atomic.xor.gen.i.sys
llvm.nvvm.bar.sync
llvm.nvvm.bar.warp.sync
llvm.nvvm.barrier
llvm.nvvm.barrier.n
llvm.nvvm.barrier.sync
llvm.nvvm.barrier.sync.cnt
llvm.nvvm.barrier0
llvm.nvvm.barrier0.and
llvm.nvvm.barrier0.or
llvm.nvvm.barrier0.popc
llvm.nvvm.bitcast.d2ll
llvm.nvvm.bitcast.f2i
llvm.nvvm.bitcast.i2f
llvm.nvvm.bitcast.ll2d
llvm.nvvm.ceil.d
llvm.nvvm.ceil.f
llvm.nvvm.ceil.ftz.f
llvm.nvvm.compiler.error
llvm.nvvm.compiler.warn
llvm.nvvm.cos.approx.f
llvm.nvvm.cos.approx.ftz.f
llvm.nvvm.d2f.rm
llvm.nvvm.d2f.rm.ftz
llvm.nvvm.d2f.rn
llvm.nvvm.d2f.rn.ftz
llvm.nvvm.d2f.rp
llvm.nvvm.d2f.rp.ftz
llvm.nvvm.d2f.rz
llvm.nvvm.d2f.rz.ftz
llvm.nvvm.d2i.hi
llvm.nvvm.d2i.lo
llvm.nvvm.d2i.rm
llvm.nvvm.d2i.rn
llvm.nvvm.d2i.rp
llvm.nvvm.d2i.rz
llvm.nvvm.d2ll.rm
llvm.nvvm.d2ll.rn
llvm.nvvm.d2ll.rp
llvm.nvvm.d2ll.rz
llvm.nvvm.d2ui.rm
llvm.nvvm.d2ui.rn
llvm.nvvm.d2ui.rp
llvm.nvvm.d2ui.rz
llvm.nvvm.d2ull.rm
llvm.nvvm.d2ull.rn
llvm.nvvm.d2ull.rp
llvm.nvvm.d2ull.rz
llvm.nvvm.div.approx.f
llvm.nvvm.div.approx.ftz.f
llvm.nvvm.div.rm.d
llvm.nvvm.div.rm.f
llvm.nvvm.div.rm.ftz.f
llvm.nvvm.div.rn.d
llvm.nvvm.div.rn.f
llvm.nvvm.div.rn.ftz.f
llvm.nvvm.div.rp.d
llvm.nvvm.div.rp.f
llvm.nvvm.div.rp.ftz.f
llvm.nvvm.div.rz.d
llvm.nvvm.div.rz.f
llvm.nvvm.div.rz.ftz.f
llvm.nvvm.ex2.approx.d
llvm.nvvm.ex2.approx.f
llvm.nvvm.ex2.approx.ftz.f
llvm.nvvm.f2h.rn
llvm.nvvm.f2h.rn.ftz
llvm.nvvm.f2i.rm
llvm.nvvm.f2i.rm.ftz
llvm.nvvm.f2i.rn
llvm.nvvm.f2i.rn.ftz
llvm.nvvm.f2i.rp
llvm.nvvm.f2i.rp.ftz
llvm.nvvm.f2i.rz
llvm.nvvm.f2i.rz.ftz
llvm.nvvm.f2ll.rm
llvm.nvvm.f2ll.rm.ftz
llvm.nvvm.f2ll.rn
llvm.nvvm.f2ll.rn.ftz
llvm.nvvm.f2ll.rp
llvm.nvvm.f2ll.rp.ftz
llvm.nvvm.f2ll.rz
llvm.nvvm.f2ll.rz.ftz
llvm.nvvm.f2ui.rm
llvm.nvvm.f2ui.rm.ftz
llvm.nvvm.f2ui.rn
llvm.nvvm.f2ui.rn.ftz
llvm.nvvm.f2ui.rp
llvm.nvvm.f2ui.rp.ftz
llvm.nvvm.f2ui.rz
llvm.nvvm.f2ui.rz.ftz
llvm.nvvm.f2ull.rm
llvm.nvvm.f2ull.rm.ftz
llvm.nvvm.f2ull.rn
llvm.nvvm.f2ull.rn.ftz
llvm.nvvm.f2ull.rp
llvm.nvvm.f2ull.rp.ftz
llvm.nvvm.f2ull.rz
llvm.nvvm.f2ull.rz.ftz
llvm.nvvm.fabs.d
llvm.nvvm.fabs.f
llvm.nvvm.fabs.ftz.f
llvm.nvvm.floor.d
llvm.nvvm.floor.f
llvm.nvvm.floor.ftz.f
llvm.nvvm.fma.rm.d
llvm.nvvm.fma.rm.f
llvm.nvvm.fma.rm.ftz.f
llvm.nvvm.fma.rn.d
llvm.nvvm.fma.rn.f
llvm.nvvm.fma.rn.ftz.f
llvm.nvvm.fma.rp.d
llvm.nvvm.fma.rp.f
llvm.nvvm.fma.rp.ftz.f
llvm.nvvm.fma.rz.d
llvm.nvvm.fma.rz.f
llvm.nvvm.fma.rz.ftz.f
llvm.nvvm.fmax.d
llvm.nvvm.fmax.f
llvm.nvvm.fmax.ftz.f
llvm.nvvm.fmin.d
llvm.nvvm.fmin.f
llvm.nvvm.fmin.ftz.f
llvm.nvvm.fns
llvm.nvvm.i2d.rm
llvm.nvvm.i2d.rn
llvm.nvvm.i2d.rp
llvm.nvvm.i2d.rz
llvm.nvvm.i2f.rm
llvm.nvvm.i2f.rn
llvm.nvvm.i2f.rp
llvm.nvvm.i2f.rz
llvm.nvvm.isspacep.const
llvm.nvvm.isspacep.global
llvm.nvvm.isspacep.local
llvm.nvvm.isspacep.shared
llvm.nvvm.istypep.sampler
llvm.nvvm.istypep.surface
llvm.nvvm.istypep.texture
llvm.nvvm.ldg.global.f
llvm.nvvm.ldg.global.i
llvm.nvvm.ldg.global.p
llvm.nvvm.ldu.global.f
llvm.nvvm.ldu.global.i
llvm.nvvm.ldu.global.p
llvm.nvvm.lg2.approx.d
llvm.nvvm.lg2.approx.f
llvm.nvvm.lg2.approx.ftz.f
llvm.nvvm.ll2d.rm
llvm.nvvm.ll2d.rn
llvm.nvvm.ll2d.rp
llvm.nvvm.ll2d.rz
llvm.nvvm.ll2f.rm
llvm.nvvm.ll2f.rn
llvm.nvvm.ll2f.rp
llvm.nvvm.ll2f.rz
llvm.nvvm.lohi.i2d
llvm.nvvm.match.all.sync.i32p
llvm.nvvm.match.all.sync.i64p
llvm.nvvm.match.any.sync.i32
llvm.nvvm.match.any.sync.i64
llvm.nvvm.membar.cta
llvm.nvvm.membar.gl
llvm.nvvm.membar.sys
llvm.nvvm.move.double
llvm.nvvm.move.float
llvm.nvvm.move.i16
llvm.nvvm.move.i32
llvm.nvvm.move.i64
llvm.nvvm.move.ptr
llvm.nvvm.mul.rm.d
llvm.nvvm.mul.rm.f
llvm.nvvm.mul.rm.ftz.f
llvm.nvvm.mul.rn.d
llvm.nvvm.mul.rn.f
llvm.nvvm.mul.rn.ftz.f
llvm.nvvm.mul.rp.d
llvm.nvvm.mul.rp.f
llvm.nvvm.mul.rp.ftz.f
llvm.nvvm.mul.rz.d
llvm.nvvm.mul.rz.f
llvm.nvvm.mul.rz.ftz.f
llvm.nvvm.mul24.i
llvm.nvvm.mul24.ui
llvm.nvvm.mulhi.i
llvm.nvvm.mulhi.ll
llvm.nvvm.mulhi.ui
llvm.nvvm.mulhi.ull
llvm.nvvm.prmt
llvm.nvvm.ptr.constant.to.gen
llvm.nvvm.ptr.gen.to.constant
llvm.nvvm.ptr.gen.to.global
llvm.nvvm.ptr.gen.to.local
llvm.nvvm.ptr.gen.to.param
llvm.nvvm.ptr.gen.to.shared
llvm.nvvm.ptr.global.to.gen
llvm.nvvm.ptr.local.to.gen
llvm.nvvm.ptr.shared.to.gen
llvm.nvvm.rcp.approx.ftz.d
llvm.nvvm.rcp.rm.d
llvm.nvvm.rcp.rm.f
llvm.nvvm.rcp.rm.ftz.f
llvm.nvvm.rcp.rn.d
llvm.nvvm.rcp.rn.f
llvm.nvvm.rcp.rn.ftz.f
llvm.nvvm.rcp.rp.d
llvm.nvvm.rcp.rp.f
llvm.nvvm.rcp.rp.ftz.f
llvm.nvvm.rcp.rz.d
llvm.nvvm.rcp.rz.f
llvm.nvvm.rcp.rz.ftz.f
llvm.nvvm.read.ptx.sreg.clock
llvm.nvvm.read.ptx.sreg.clock64
llvm.nvvm.read.ptx.sreg.ctaid.w
llvm.nvvm.read.ptx.sreg.ctaid.x
llvm.nvvm.read.ptx.sreg.ctaid.y
llvm.nvvm.read.ptx.sreg.ctaid.z
llvm.nvvm.read.ptx.sreg.envreg0
llvm.nvvm.read.ptx.sreg.envreg1
llvm.nvvm.read.ptx.sreg.envreg10
llvm.nvvm.read.ptx.sreg.envreg11
llvm.nvvm.read.ptx.sreg.envreg12
llvm.nvvm.read.ptx.sreg.envreg13
llvm.nvvm.read.ptx.sreg.envreg14
llvm.nvvm.read.ptx.sreg.envreg15
llvm.nvvm.read.ptx.sreg.envreg16
llvm.nvvm.read.ptx.sreg.envreg17
llvm.nvvm.read.ptx.sreg.envreg18
llvm.nvvm.read.ptx.sreg.envreg19
llvm.nvvm.read.ptx.sreg.envreg2
llvm.nvvm.read.ptx.sreg.envreg20
llvm.nvvm.read.ptx.sreg.envreg21
llvm.nvvm.read.ptx.sreg.envreg22
llvm.nvvm.read.ptx.sreg.envreg23
llvm.nvvm.read.ptx.sreg.envreg24
llvm.nvvm.read.ptx.sreg.envreg25
llvm.nvvm.read.ptx.sreg.envreg26
llvm.nvvm.read.ptx.sreg.envreg27
llvm.nvvm.read.ptx.sreg.envreg28
llvm.nvvm.read.ptx.sreg.envreg29
llvm.nvvm.read.ptx.sreg.envreg3
llvm.nvvm.read.ptx.sreg.envreg30
llvm.nvvm.read.ptx.sreg.envreg31
llvm.nvvm.read.ptx.sreg.envreg4
llvm.nvvm.read.ptx.sreg.envreg5
llvm.nvvm.read.ptx.sreg.envreg6
llvm.nvvm.read.ptx.sreg.envreg7
llvm.nvvm.read.ptx.sreg.envreg8
llvm.nvvm.read.ptx.sreg.envreg9
llvm.nvvm.read.ptx.sreg.gridid
llvm.nvvm.read.ptx.sreg.laneid
llvm.nvvm.read.ptx.sreg.lanemask.eq
llvm.nvvm.read.ptx.sreg.lanemask.ge
llvm.nvvm.read.ptx.sreg.lanemask.gt
llvm.nvvm.read.ptx.sreg.lanemask.le
llvm.nvvm.read.ptx.sreg.lanemask.lt
llvm.nvvm.read.ptx.sreg.nctaid.w
llvm.nvvm.read.ptx.sreg.nctaid.x
llvm.nvvm.read.ptx.sreg.nctaid.y
llvm.nvvm.read.ptx.sreg.nctaid.z
llvm.nvvm.read.ptx.sreg.nsmid
llvm.nvvm.read.ptx.sreg.ntid.w
llvm.nvvm.read.ptx.sreg.ntid.x
llvm.nvvm.read.ptx.sreg.ntid.y
llvm.nvvm.read.ptx.sreg.ntid.z
llvm.nvvm.read.ptx.sreg.nwarpid
llvm.nvvm.read.ptx.sreg.pm0
llvm.nvvm.read.ptx.sreg.pm1
llvm.nvvm.read.ptx.sreg.pm2
llvm.nvvm.read.ptx.sreg.pm3
llvm.nvvm.read.ptx.sreg.smid
llvm.nvvm.read.ptx.sreg.tid.w
llvm.nvvm.read.ptx.sreg.tid.x
llvm.nvvm.read.ptx.sreg.tid.y
llvm.nvvm.read.ptx.sreg.tid.z
llvm.nvvm.read.ptx.sreg.warpid
llvm.nvvm.read.ptx.sreg.warpsize
llvm.nvvm.reflect
llvm.nvvm.rotate.b32
llvm.nvvm.rotate.b64
llvm.nvvm.rotate.right.b64
llvm.nvvm.round.d
llvm.nvvm.round.f
llvm.nvvm.round.ftz.f
llvm.nvvm.rsqrt.approx.d
llvm.nvvm.rsqrt.approx.f
llvm.nvvm.rsqrt.approx.ftz.f
llvm.nvvm.sad.i
llvm.nvvm.sad.ui
llvm.nvvm.saturate.d
llvm.nvvm.saturate.f
llvm.nvvm.saturate.ftz.f
llvm.nvvm.shfl.bfly.f32
llvm.nvvm.shfl.bfly.i32
llvm.nvvm.shfl.down.f32
llvm.nvvm.shfl.down.i32
llvm.nvvm.shfl.idx.f32
llvm.nvvm.shfl.idx.i32
llvm.nvvm.shfl.sync.bfly.f32
llvm.nvvm.shfl.sync.bfly.i32
llvm.nvvm.shfl.sync.down.f32
llvm.nvvm.shfl.sync.down.i32
llvm.nvvm.shfl.sync.idx.f32
llvm.nvvm.shfl.sync.idx.i32
llvm.nvvm.shfl.sync.up.f32
llvm.nvvm.shfl.sync.up.i32
llvm.nvvm.shfl.up.f32
llvm.nvvm.shfl.up.i32
llvm.nvvm.sin.approx.f
llvm.nvvm.sin.approx.ftz.f
llvm.nvvm.sqrt.approx.f
llvm.nvvm.sqrt.approx.ftz.f
llvm.nvvm.sqrt.f
llvm.nvvm.sqrt.rm.d
llvm.nvvm.sqrt.rm.f
llvm.nvvm.sqrt.rm.ftz.f
llvm.nvvm.sqrt.rn.d
llvm.nvvm.sqrt.rn.f
llvm.nvvm.sqrt.rn.ftz.f
llvm.nvvm.sqrt.rp.d
llvm.nvvm.sqrt.rp.f
llvm.nvvm.sqrt.rp.ftz.f
llvm.nvvm.sqrt.rz.d
llvm.nvvm.sqrt.rz.f
llvm.nvvm.sqrt.rz.ftz.f
llvm.nvvm.suld.1d.array.i16.clamp
llvm.nvvm.suld.1d.array.i16.trap
llvm.nvvm.suld.1d.array.i16.zero
llvm.nvvm.suld.1d.array.i32.clamp
llvm.nvvm.suld.1d.array.i32.trap
llvm.nvvm.suld.1d.array.i32.zero
llvm.nvvm.suld.1d.array.i64.clamp
llvm.nvvm.suld.1d.array.i64.trap
llvm.nvvm.suld.1d.array.i64.zero
llvm.nvvm.suld.1d.array.i8.clamp
llvm.nvvm.suld.1d.array.i8.trap
llvm.nvvm.suld.1d.array.i8.zero
llvm.nvvm.suld.1d.array.v2i16.clamp
llvm.nvvm.suld.1d.array.v2i16.trap
llvm.nvvm.suld.1d.array.v2i16.zero
llvm.nvvm.suld.1d.array.v2i32.clamp
llvm.nvvm.suld.1d.array.v2i32.trap
llvm.nvvm.suld.1d.array.v2i32.zero
llvm.nvvm.suld.1d.array.v2i64.clamp
llvm.nvvm.suld.1d.array.v2i64.trap
llvm.nvvm.suld.1d.array.v2i64.zero
llvm.nvvm.suld.1d.array.v2i8.clamp
llvm.nvvm.suld.1d.array.v2i8.trap
llvm.nvvm.suld.1d.array.v2i8.zero
llvm.nvvm.suld.1d.array.v4i16.clamp
llvm.nvvm.suld.1d.array.v4i16.trap
llvm.nvvm.suld.1d.array.v4i16.zero
llvm.nvvm.suld.1d.array.v4i32.clamp
llvm.nvvm.suld.1d.array.v4i32.trap
llvm.nvvm.suld.1d.array.v4i32.zero
llvm.nvvm.suld.1d.array.v4i8.clamp
llvm.nvvm.suld.1d.array.v4i8.trap
llvm.nvvm.suld.1d.array.v4i8.zero
llvm.nvvm.suld.1d.i16.clamp
llvm.nvvm.suld.1d.i16.trap
llvm.nvvm.suld.1d.i16.zero
llvm.nvvm.suld.1d.i32.clamp
llvm.nvvm.suld.1d.i32.trap
llvm.nvvm.suld.1d.i32.zero
llvm.nvvm.suld.1d.i64.clamp
llvm.nvvm.suld.1d.i64.trap
llvm.nvvm.suld.1d.i64.zero
llvm.nvvm.suld.1d.i8.clamp
llvm.nvvm.suld.1d.i8.trap
llvm.nvvm.suld.1d.i8.zero
llvm.nvvm.suld.1d.v2i16.clamp
llvm.nvvm.suld.1d.v2i16.trap
llvm.nvvm.suld.1d.v2i16.zero
llvm.nvvm.suld.1d.v2i32.clamp
llvm.nvvm.suld.1d.v2i32.trap
llvm.nvvm.suld.1d.v2i32.zero
llvm.nvvm.suld.1d.v2i64.clamp
llvm.nvvm.suld.1d.v2i64.trap
llvm.nvvm.suld.1d.v2i64.zero
llvm.nvvm.suld.1d.v2i8.clamp
llvm.nvvm.suld.1d.v2i8.trap
llvm.nvvm.suld.1d.v2i8.zero
llvm.nvvm.suld.1d.v4i16.clamp
llvm.nvvm.suld.1d.v4i16.trap
llvm.nvvm.suld.1d.v4i16.zero
llvm.nvvm.suld.1d.v4i32.clamp
llvm.nvvm.suld.1d.v4i32.trap
llvm.nvvm.suld.1d.v4i32.zero
llvm.nvvm.suld.1d.v4i8.clamp
llvm.nvvm.suld.1d.v4i8.trap
llvm.nvvm.suld.1d.v4i8.zero
llvm.nvvm.suld.2d.array.i16.clamp
llvm.nvvm.suld.2d.array.i16.trap
llvm.nvvm.suld.2d.array.i16.zero
llvm.nvvm.suld.2d.array.i32.clamp
llvm.nvvm.suld.2d.array.i32.trap
llvm.nvvm.suld.2d.array.i32.zero
llvm.nvvm.suld.2d.array.i64.clamp
llvm.nvvm.suld.2d.array.i64.trap
llvm.nvvm.suld.2d.array.i64.zero
llvm.nvvm.suld.2d.array.i8.clamp
llvm.nvvm.suld.2d.array.i8.trap
llvm.nvvm.suld.2d.array.i8.zero
llvm.nvvm.suld.2d.array.v2i16.clamp
llvm.nvvm.suld.2d.array.v2i16.trap
llvm.nvvm.suld.2d.array.v2i16.zero
llvm.nvvm.suld.2d.array.v2i32.clamp
llvm.nvvm.suld.2d.array.v2i32.trap
llvm.nvvm.suld.2d.array.v2i32.zero
llvm.nvvm.suld.2d.array.v2i64.clamp
llvm.nvvm.suld.2d.array.v2i64.trap
llvm.nvvm.suld.2d.array.v2i64.zero
llvm.nvvm.suld.2d.array.v2i8.clamp
llvm.nvvm.suld.2d.array.v2i8.trap
llvm.nvvm.suld.2d.array.v2i8.zero
llvm.nvvm.suld.2d.array.v4i16.clamp
llvm.nvvm.suld.2d.array.v4i16.trap
llvm.nvvm.suld.2d.array.v4i16.zero
llvm.nvvm.suld.2d.array.v4i32.clamp
llvm.nvvm.suld.2d.array.v4i32.trap
llvm.nvvm.suld.2d.array.v4i32.zero
llvm.nvvm.suld.2d.array.v4i8.clamp
llvm.nvvm.suld.2d.array.v4i8.trap
llvm.nvvm.suld.2d.array.v4i8.zero
llvm.nvvm.suld.2d.i16.clamp
llvm.nvvm.suld.2d.i16.trap
llvm.nvvm.suld.2d.i16.zero
llvm.nvvm.suld.2d.i32.clamp
llvm.nvvm.suld.2d.i32.trap
llvm.nvvm.suld.2d.i32.zero
llvm.nvvm.suld.2d.i64.clamp
llvm.nvvm.suld.2d.i64.trap
llvm.nvvm.suld.2d.i64.zero
llvm.nvvm.suld.2d.i8.clamp
llvm.nvvm.suld.2d.i8.trap
llvm.nvvm.suld.2d.i8.zero
llvm.nvvm.suld.2d.v2i16.clamp
llvm.nvvm.suld.2d.v2i16.trap
llvm.nvvm.suld.2d.v2i16.zero
llvm.nvvm.suld.2d.v2i32.clamp
llvm.nvvm.suld.2d.v2i32.trap
llvm.nvvm.suld.2d.v2i32.zero
llvm.nvvm.suld.2d.v2i64.clamp
llvm.nvvm.suld.2d.v2i64.trap
llvm.nvvm.suld.2d.v2i64.zero
llvm.nvvm.suld.2d.v2i8.clamp
llvm.nvvm.suld.2d.v2i8.trap
llvm.nvvm.suld.2d.v2i8.zero
llvm.nvvm.suld.2d.v4i16.clamp
llvm.nvvm.suld.2d.v4i16.trap
llvm.nvvm.suld.2d.v4i16.zero
llvm.nvvm.suld.2d.v4i32.clamp
llvm.nvvm.suld.2d.v4i32.trap
llvm.nvvm.suld.2d.v4i32.zero
llvm.nvvm.suld.2d.v4i8.clamp
llvm.nvvm.suld.2d.v4i8.trap
llvm.nvvm.suld.2d.v4i8.zero
llvm.nvvm.suld.3d.i16.clamp
llvm.nvvm.suld.3d.i16.trap
llvm.nvvm.suld.3d.i16.zero
llvm.nvvm.suld.3d.i32.clamp
llvm.nvvm.suld.3d.i32.trap
llvm.nvvm.suld.3d.i32.zero
llvm.nvvm.suld.3d.i64.clamp
llvm.nvvm.suld.3d.i64.trap
llvm.nvvm.suld.3d.i64.zero
llvm.nvvm.suld.3d.i8.clamp
llvm.nvvm.suld.3d.i8.trap
llvm.nvvm.suld.3d.i8.zero
llvm.nvvm.suld.3d.v2i16.clamp
llvm.nvvm.suld.3d.v2i16.trap
llvm.nvvm.suld.3d.v2i16.zero
llvm.nvvm.suld.3d.v2i32.clamp
llvm.nvvm.suld.3d.v2i32.trap
llvm.nvvm.suld.3d.v2i32.zero
llvm.nvvm.suld.3d.v2i64.clamp
llvm.nvvm.suld.3d.v2i64.trap
llvm.nvvm.suld.3d.v2i64.zero
llvm.nvvm.suld.3d.v2i8.clamp
llvm.nvvm.suld.3d.v2i8.trap
llvm.nvvm.suld.3d.v2i8.zero
llvm.nvvm.suld.3d.v4i16.clamp
llvm.nvvm.suld.3d.v4i16.trap
llvm.nvvm.suld.3d.v4i16.zero
llvm.nvvm.suld.3d.v4i32.clamp
llvm.nvvm.suld.3d.v4i32.trap
llvm.nvvm.suld.3d.v4i32.zero
llvm.nvvm.suld.3d.v4i8.clamp
llvm.nvvm.suld.3d.v4i8.trap
llvm.nvvm.suld.3d.v4i8.zero
llvm.nvvm.suq.array.size
llvm.nvvm.suq.channel.data.type
llvm.nvvm.suq.channel.order
llvm.nvvm.suq.depth
llvm.nvvm.suq.height
llvm.nvvm.suq.width
llvm.nvvm.sust.b.1d.array.i16.clamp
llvm.nvvm.sust.b.1d.array.i16.trap
llvm.nvvm.sust.b.1d.array.i16.zero
llvm.nvvm.sust.b.1d.array.i32.clamp
llvm.nvvm.sust.b.1d.array.i32.trap
llvm.nvvm.sust.b.1d.array.i32.zero
llvm.nvvm.sust.b.1d.array.i64.clamp
llvm.nvvm.sust.b.1d.array.i64.trap
llvm.nvvm.sust.b.1d.array.i64.zero
llvm.nvvm.sust.b.1d.array.i8.clamp
llvm.nvvm.sust.b.1d.array.i8.trap
llvm.nvvm.sust.b.1d.array.i8.zero
llvm.nvvm.sust.b.1d.array.v2i16.clamp
llvm.nvvm.sust.b.1d.array.v2i16.trap
llvm.nvvm.sust.b.1d.array.v2i16.zero
llvm.nvvm.sust.b.1d.array.v2i32.clamp
llvm.nvvm.sust.b.1d.array.v2i32.trap
llvm.nvvm.sust.b.1d.array.v2i32.zero
llvm.nvvm.sust.b.1d.array.v2i64.clamp
llvm.nvvm.sust.b.1d.array.v2i64.trap
llvm.nvvm.sust.b.1d.array.v2i64.zero
llvm.nvvm.sust.b.1d.array.v2i8.clamp
llvm.nvvm.sust.b.1d.array.v2i8.trap
llvm.nvvm.sust.b.1d.array.v2i8.zero
llvm.nvvm.sust.b.1d.array.v4i16.clamp
llvm.nvvm.sust.b.1d.array.v4i16.trap
llvm.nvvm.sust.b.1d.array.v4i16.zero
llvm.nvvm.sust.b.1d.array.v4i32.clamp
llvm.nvvm.sust.b.1d.array.v4i32.trap
llvm.nvvm.sust.b.1d.array.v4i32.zero
llvm.nvvm.sust.b.1d.array.v4i8.clamp
llvm.nvvm.sust.b.1d.array.v4i8.trap
llvm.nvvm.sust.b.1d.array.v4i8.zero
llvm.nvvm.sust.b.1d.i16.clamp
llvm.nvvm.sust.b.1d.i16.trap
llvm.nvvm.sust.b.1d.i16.zero
llvm.nvvm.sust.b.1d.i32.clamp
llvm.nvvm.sust.b.1d.i32.trap
llvm.nvvm.sust.b.1d.i32.zero
llvm.nvvm.sust.b.1d.i64.clamp
llvm.nvvm.sust.b.1d.i64.trap
llvm.nvvm.sust.b.1d.i64.zero
llvm.nvvm.sust.b.1d.i8.clamp
llvm.nvvm.sust.b.1d.i8.trap
llvm.nvvm.sust.b.1d.i8.zero
llvm.nvvm.sust.b.1d.v2i16.clamp
llvm.nvvm.sust.b.1d.v2i16.trap
llvm.nvvm.sust.b.1d.v2i16.zero
llvm.nvvm.sust.b.1d.v2i32.clamp
llvm.nvvm.sust.b.1d.v2i32.trap
llvm.nvvm.sust.b.1d.v2i32.zero
llvm.nvvm.sust.b.1d.v2i64.clamp
llvm.nvvm.sust.b.1d.v2i64.trap
llvm.nvvm.sust.b.1d.v2i64.zero
llvm.nvvm.sust.b.1d.v2i8.clamp
llvm.nvvm.sust.b.1d.v2i8.trap
llvm.nvvm.sust.b.1d.v2i8.zero
llvm.nvvm.sust.b.1d.v4i16.clamp
llvm.nvvm.sust.b.1d.v4i16.trap
llvm.nvvm.sust.b.1d.v4i16.zero
llvm.nvvm.sust.b.1d.v4i32.clamp
llvm.nvvm.sust.b.1d.v4i32.trap
llvm.nvvm.sust.b.1d.v4i32.zero
llvm.nvvm.sust.b.1d.v4i8.clamp
llvm.nvvm.sust.b.1d.v4i8.trap
llvm.nvvm.sust.b.1d.v4i8.zero
llvm.nvvm.sust.b.2d.array.i16.clamp
llvm.nvvm.sust.b.2d.array.i16.trap
llvm.nvvm.sust.b.2d.array.i16.zero
llvm.nvvm.sust.b.2d.array.i32.clamp
llvm.nvvm.sust.b.2d.array.i32.trap
llvm.nvvm.sust.b.2d.array.i32.zero
llvm.nvvm.sust.b.2d.array.i64.clamp
llvm.nvvm.sust.b.2d.array.i64.trap
llvm.nvvm.sust.b.2d.array.i64.zero
llvm.nvvm.sust.b.2d.array.i8.clamp
llvm.nvvm.sust.b.2d.array.i8.trap
llvm.nvvm.sust.b.2d.array.i8.zero
llvm.nvvm.sust.b.2d.array.v2i16.clamp
llvm.nvvm.sust.b.2d.array.v2i16.trap
llvm.nvvm.sust.b.2d.array.v2i16.zero
llvm.nvvm.sust.b.2d.array.v2i32.clamp
llvm.nvvm.sust.b.2d.array.v2i32.trap
llvm.nvvm.sust.b.2d.array.v2i32.zero
llvm.nvvm.sust.b.2d.array.v2i64.clamp
llvm.nvvm.sust.b.2d.array.v2i64.trap
llvm.nvvm.sust.b.2d.array.v2i64.zero
llvm.nvvm.sust.b.2d.array.v2i8.clamp
llvm.nvvm.sust.b.2d.array.v2i8.trap
llvm.nvvm.sust.b.2d.array.v2i8.zero
llvm.nvvm.sust.b.2d.array.v4i16.clamp
llvm.nvvm.sust.b.2d.array.v4i16.trap
llvm.nvvm.sust.b.2d.array.v4i16.zero
llvm.nvvm.sust.b.2d.array.v4i32.clamp
llvm.nvvm.sust.b.2d.array.v4i32.trap
llvm.nvvm.sust.b.2d.array.v4i32.zero
llvm.nvvm.sust.b.2d.array.v4i8.clamp
llvm.nvvm.sust.b.2d.array.v4i8.trap
llvm.nvvm.sust.b.2d.array.v4i8.zero
llvm.nvvm.sust.b.2d.i16.clamp
llvm.nvvm.sust.b.2d.i16.trap
llvm.nvvm.sust.b.2d.i16.zero
llvm.nvvm.sust.b.2d.i32.clamp
llvm.nvvm.sust.b.2d.i32.trap
llvm.nvvm.sust.b.2d.i32.zero
llvm.nvvm.sust.b.2d.i64.clamp
llvm.nvvm.sust.b.2d.i64.trap
llvm.nvvm.sust.b.2d.i64.zero
llvm.nvvm.sust.b.2d.i8.clamp
llvm.nvvm.sust.b.2d.i8.trap
llvm.nvvm.sust.b.2d.i8.zero
llvm.nvvm.sust.b.2d.v2i16.clamp
llvm.nvvm.sust.b.2d.v2i16.trap
llvm.nvvm.sust.b.2d.v2i16.zero
llvm.nvvm.sust.b.2d.v2i32.clamp
llvm.nvvm.sust.b.2d.v2i32.trap
llvm.nvvm.sust.b.2d.v2i32.zero
llvm.nvvm.sust.b.2d.v2i64.clamp
llvm.nvvm.sust.b.2d.v2i64.trap
llvm.nvvm.sust.b.2d.v2i64.zero
llvm.nvvm.sust.b.2d.v2i8.clamp
llvm.nvvm.sust.b.2d.v2i8.trap
llvm.nvvm.sust.b.2d.v2i8.zero
llvm.nvvm.sust.b.2d.v4i16.clamp
llvm.nvvm.sust.b.2d.v4i16.trap
llvm.nvvm.sust.b.2d.v4i16.zero
llvm.nvvm.sust.b.2d.v4i32.clamp
llvm.nvvm.sust.b.2d.v4i32.trap
llvm.nvvm.sust.b.2d.v4i32.zero
llvm.nvvm.sust.b.2d.v4i8.clamp
llvm.nvvm.sust.b.2d.v4i8.trap
llvm.nvvm.sust.b.2d.v4i8.zero
llvm.nvvm.sust.b.3d.i16.clamp
llvm.nvvm.sust.b.3d.i16.trap
llvm.nvvm.sust.b.3d.i16.zero
llvm.nvvm.sust.b.3d.i32.clamp
llvm.nvvm.sust.b.3d.i32.trap
llvm.nvvm.sust.b.3d.i32.zero
llvm.nvvm.sust.b.3d.i64.clamp
llvm.nvvm.sust.b.3d.i64.trap
llvm.nvvm.sust.b.3d.i64.zero
llvm.nvvm.sust.b.3d.i8.clamp
llvm.nvvm.sust.b.3d.i8.trap
llvm.nvvm.sust.b.3d.i8.zero
llvm.nvvm.sust.b.3d.v2i16.clamp
llvm.nvvm.sust.b.3d.v2i16.trap
llvm.nvvm.sust.b.3d.v2i16.zero
llvm.nvvm.sust.b.3d.v2i32.clamp
llvm.nvvm.sust.b.3d.v2i32.trap
llvm.nvvm.sust.b.3d.v2i32.zero
llvm.nvvm.sust.b.3d.v2i64.clamp
llvm.nvvm.sust.b.3d.v2i64.trap
llvm.nvvm.sust.b.3d.v2i64.zero
llvm.nvvm.sust.b.3d.v2i8.clamp
llvm.nvvm.sust.b.3d.v2i8.trap
llvm.nvvm.sust.b.3d.v2i8.zero
llvm.nvvm.sust.b.3d.v4i16.clamp
llvm.nvvm.sust.b.3d.v4i16.trap
llvm.nvvm.sust.b.3d.v4i16.zero
llvm.nvvm.sust.b.3d.v4i32.clamp
llvm.nvvm.sust.b.3d.v4i32.trap
llvm.nvvm.sust.b.3d.v4i32.zero
llvm.nvvm.sust.b.3d.v4i8.clamp
llvm.nvvm.sust.b.3d.v4i8.trap
llvm.nvvm.sust.b.3d.v4i8.zero
llvm.nvvm.sust.p.1d.array.i16.trap
llvm.nvvm.sust.p.1d.array.i32.trap
llvm.nvvm.sust.p.1d.array.i8.trap
llvm.nvvm.sust.p.1d.array.v2i16.trap
llvm.nvvm.sust.p.1d.array.v2i32.trap
llvm.nvvm.sust.p.1d.array.v2i8.trap
llvm.nvvm.sust.p.1d.array.v4i16.trap
llvm.nvvm.sust.p.1d.array.v4i32.trap
llvm.nvvm.sust.p.1d.array.v4i8.trap
llvm.nvvm.sust.p.1d.i16.trap
llvm.nvvm.sust.p.1d.i32.trap
llvm.nvvm.sust.p.1d.i8.trap
llvm.nvvm.sust.p.1d.v2i16.trap
llvm.nvvm.sust.p.1d.v2i32.trap
llvm.nvvm.sust.p.1d.v2i8.trap
llvm.nvvm.sust.p.1d.v4i16.trap
llvm.nvvm.sust.p.1d.v4i32.trap
llvm.nvvm.sust.p.1d.v4i8.trap
llvm.nvvm.sust.p.2d.array.i16.trap
llvm.nvvm.sust.p.2d.array.i32.trap
llvm.nvvm.sust.p.2d.array.i8.trap
llvm.nvvm.sust.p.2d.array.v2i16.trap
llvm.nvvm.sust.p.2d.array.v2i32.trap
llvm.nvvm.sust.p.2d.array.v2i8.trap
llvm.nvvm.sust.p.2d.array.v4i16.trap
llvm.nvvm.sust.p.2d.array.v4i32.trap
llvm.nvvm.sust.p.2d.array.v4i8.trap
llvm.nvvm.sust.p.2d.i16.trap
llvm.nvvm.sust.p.2d.i32.trap
llvm.nvvm.sust.p.2d.i8.trap
llvm.nvvm.sust.p.2d.v2i16.trap
llvm.nvvm.sust.p.2d.v2i32.trap
llvm.nvvm.sust.p.2d.v2i8.trap
llvm.nvvm.sust.p.2d.v4i16.trap
llvm.nvvm.sust.p.2d.v4i32.trap
llvm.nvvm.sust.p.2d.v4i8.trap
llvm.nvvm.sust.p.3d.i16.trap
llvm.nvvm.sust.p.3d.i32.trap
llvm.nvvm.sust.p.3d.i8.trap
llvm.nvvm.sust.p.3d.v2i16.trap
llvm.nvvm.sust.p.3d.v2i32.trap
llvm.nvvm.sust.p.3d.v2i8.trap
llvm.nvvm.sust.p.3d.v4i16.trap
llvm.nvvm.sust.p.3d.v4i32.trap
llvm.nvvm.sust.p.3d.v4i8.trap
llvm.nvvm.swap.lo.hi.b64
llvm.nvvm.tex.1d.array.grad.v4f32.f32
llvm.nvvm.tex.1d.array.grad.v4s32.f32
llvm.nvvm.tex.1d.array.grad.v4u32.f32
llvm.nvvm.tex.1d.array.level.v4f32.f32
llvm.nvvm.tex.1d.array.level.v4s32.f32
llvm.nvvm.tex.1d.array.level.v4u32.f32
llvm.nvvm.tex.1d.array.v4f32.f32
llvm.nvvm.tex.1d.array.v4f32.s32
llvm.nvvm.tex.1d.array.v4s32.f32
llvm.nvvm.tex.1d.array.v4s32.s32
llvm.nvvm.tex.1d.array.v4u32.f32
llvm.nvvm.tex.1d.array.v4u32.s32
llvm.nvvm.tex.1d.grad.v4f32.f32
llvm.nvvm.tex.1d.grad.v4s32.f32
llvm.nvvm.tex.1d.grad.v4u32.f32
llvm.nvvm.tex.1d.level.v4f32.f32
llvm.nvvm.tex.1d.level.v4s32.f32
llvm.nvvm.tex.1d.level.v4u32.f32
llvm.nvvm.tex.1d.v4f32.f32
llvm.nvvm.tex.1d.v4f32.s32
llvm.nvvm.tex.1d.v4s32.f32
llvm.nvvm.tex.1d.v4s32.s32
llvm.nvvm.tex.1d.v4u32.f32
llvm.nvvm.tex.1d.v4u32.s32
llvm.nvvm.tex.2d.array.grad.v4f32.f32
llvm.nvvm.tex.2d.array.grad.v4s32.f32
llvm.nvvm.tex.2d.array.grad.v4u32.f32
llvm.nvvm.tex.2d.array.level.v4f32.f32
llvm.nvvm.tex.2d.array.level.v4s32.f32
llvm.nvvm.tex.2d.array.level.v4u32.f32
llvm.nvvm.tex.2d.array.v4f32.f32
llvm.nvvm.tex.2d.array.v4f32.s32
llvm.nvvm.tex.2d.array.v4s32.f32
llvm.nvvm.tex.2d.array.v4s32.s32
llvm.nvvm.tex.2d.array.v4u32.f32
llvm.nvvm.tex.2d.array.v4u32.s32
llvm.nvvm.tex.2d.grad.v4f32.f32
llvm.nvvm.tex.2d.grad.v4s32.f32
llvm.nvvm.tex.2d.grad.v4u32.f32
llvm.nvvm.tex.2d.level.v4f32.f32
llvm.nvvm.tex.2d.level.v4s32.f32
llvm.nvvm.tex.2d.level.v4u32.f32
llvm.nvvm.tex.2d.v4f32.f32
llvm.nvvm.tex.2d.v4f32.s32
llvm.nvvm.tex.2d.v4s32.f32
llvm.nvvm.tex.2d.v4s32.s32
llvm.nvvm.tex.2d.v4u32.f32
llvm.nvvm.tex.2d.v4u32.s32
llvm.nvvm.tex.3d.grad.v4f32.f32
llvm.nvvm.tex.3d.grad.v4s32.f32
llvm.nvvm.tex.3d.grad.v4u32.f32
llvm.nvvm.tex.3d.level.v4f32.f32
llvm.nvvm.tex.3d.level.v4s32.f32
llvm.nvvm.tex.3d.level.v4u32.f32
llvm.nvvm.tex.3d.v4f32.f32
llvm.nvvm.tex.3d.v4f32.s32
llvm.nvvm.tex.3d.v4s32.f32
llvm.nvvm.tex.3d.v4s32.s32
llvm.nvvm.tex.3d.v4u32.f32
llvm.nvvm.tex.3d.v4u32.s32
llvm.nvvm.tex.cube.array.level.v4f32.f32
llvm.nvvm.tex.cube.array.level.v4s32.f32
llvm.nvvm.tex.cube.array.level.v4u32.f32
llvm.nvvm.tex.cube.array.v4f32.f32
llvm.nvvm.tex.cube.array.v4s32.f32
llvm.nvvm.tex.cube.array.v4u32.f32
llvm.nvvm.tex.cube.level.v4f32.f32
llvm.nvvm.tex.cube.level.v4s32.f32
llvm.nvvm.tex.cube.level.v4u32.f32
llvm.nvvm.tex.cube.v4f32.f32
llvm.nvvm.tex.cube.v4s32.f32
llvm.nvvm.tex.cube.v4u32.f32
llvm.nvvm.tex.unified.1d.array.grad.v4f32.f32
llvm.nvvm.tex.unified.1d.array.grad.v4s32.f32
llvm.nvvm.tex.unified.1d.array.grad.v4u32.f32
llvm.nvvm.tex.unified.1d.array.level.v4f32.f32
llvm.nvvm.tex.unified.1d.array.level.v4s32.f32
llvm.nvvm.tex.unified.1d.array.level.v4u32.f32
llvm.nvvm.tex.unified.1d.array.v4f32.f32
llvm.nvvm.tex.unified.1d.array.v4f32.s32
llvm.nvvm.tex.unified.1d.array.v4s32.f32
llvm.nvvm.tex.unified.1d.array.v4s32.s32
llvm.nvvm.tex.unified.1d.array.v4u32.f32
llvm.nvvm.tex.unified.1d.array.v4u32.s32
llvm.nvvm.tex.unified.1d.grad.v4f32.f32
llvm.nvvm.tex.unified.1d.grad.v4s32.f32
llvm.nvvm.tex.unified.1d.grad.v4u32.f32
llvm.nvvm.tex.unified.1d.level.v4f32.f32
llvm.nvvm.tex.unified.1d.level.v4s32.f32
llvm.nvvm.tex.unified.1d.level.v4u32.f32
llvm.nvvm.tex.unified.1d.v4f32.f32
llvm.nvvm.tex.unified.1d.v4f32.s32
llvm.nvvm.tex.unified.1d.v4s32.f32
llvm.nvvm.tex.unified.1d.v4s32.s32
llvm.nvvm.tex.unified.1d.v4u32.f32
llvm.nvvm.tex.unified.1d.v4u32.s32
llvm.nvvm.tex.unified.2d.array.grad.v4f32.f32
llvm.nvvm.tex.unified.2d.array.grad.v4s32.f32
llvm.nvvm.tex.unified.2d.array.grad.v4u32.f32
llvm.nvvm.tex.unified.2d.array.level.v4f32.f32
llvm.nvvm.tex.unified.2d.array.level.v4s32.f32
llvm.nvvm.tex.unified.2d.array.level.v4u32.f32
llvm.nvvm.tex.unified.2d.array.v4f32.f32
llvm.nvvm.tex.unified.2d.array.v4f32.s32
llvm.nvvm.tex.unified.2d.array.v4s32.f32
llvm.nvvm.tex.unified.2d.array.v4s32.s32
llvm.nvvm.tex.unified.2d.array.v4u32.f32
llvm.nvvm.tex.unified.2d.array.v4u32.s32
llvm.nvvm.tex.unified.2d.grad.v4f32.f32
llvm.nvvm.tex.unified.2d.grad.v4s32.f32
llvm.nvvm.tex.unified.2d.grad.v4u32.f32
llvm.nvvm.tex.unified.2d.level.v4f32.f32
llvm.nvvm.tex.unified.2d.level.v4s32.f32
llvm.nvvm.tex.unified.2d.level.v4u32.f32
llvm.nvvm.tex.unified.2d.v4f32.f32
llvm.nvvm.tex.unified.2d.v4f32.s32
llvm.nvvm.tex.unified.2d.v4s32.f32
llvm.nvvm.tex.unified.2d.v4s32.s32
llvm.nvvm.tex.unified.2d.v4u32.f32
llvm.nvvm.tex.unified.2d.v4u32.s32
llvm.nvvm.tex.unified.3d.grad.v4f32.f32
llvm.nvvm.tex.unified.3d.grad.v4s32.f32
llvm.nvvm.tex.unified.3d.grad.v4u32.f32
llvm.nvvm.tex.unified.3d.level.v4f32.f32
llvm.nvvm.tex.unified.3d.level.v4s32.f32
llvm.nvvm.tex.unified.3d.level.v4u32.f32
llvm.nvvm.tex.unified.3d.v4f32.f32
llvm.nvvm.tex.unified.3d.v4f32.s32
llvm.nvvm.tex.unified.3d.v4s32.f32
llvm.nvvm.tex.unified.3d.v4s32.s32
llvm.nvvm.tex.unified.3d.v4u32.f32
llvm.nvvm.tex.unified.3d.v4u32.s32
llvm.nvvm.tex.unified.cube.array.level.v4f32.f32
llvm.nvvm.tex.unified.cube.array.level.v4s32.f32
llvm.nvvm.tex.unified.cube.array.level.v4u32.f32
llvm.nvvm.tex.unified.cube.array.v4f32.f32
llvm.nvvm.tex.unified.cube.array.v4s32.f32
llvm.nvvm.tex.unified.cube.array.v4u32.f32
llvm.nvvm.tex.unified.cube.level.v4f32.f32
llvm.nvvm.tex.unified.cube.level.v4s32.f32
llvm.nvvm.tex.unified.cube.level.v4u32.f32
llvm.nvvm.tex.unified.cube.v4f32.f32
llvm.nvvm.tex.unified.cube.v4s32.f32
llvm.nvvm.tex.unified.cube.v4u32.f32
llvm.nvvm.texsurf.handle
llvm.nvvm.texsurf.handle.internal
llvm.nvvm.tld4.a.2d.v4f32.f32
llvm.nvvm.tld4.a.2d.v4s32.f32
llvm.nvvm.tld4.a.2d.v4u32.f32
llvm.nvvm.tld4.b.2d.v4f32.f32
llvm.nvvm.tld4.b.2d.v4s32.f32
llvm.nvvm.tld4.b.2d.v4u32.f32
llvm.nvvm.tld4.g.2d.v4f32.f32
llvm.nvvm.tld4.g.2d.v4s32.f32
llvm.nvvm.tld4.g.2d.v4u32.f32
llvm.nvvm.tld4.r.2d.v4f32.f32
llvm.nvvm.tld4.r.2d.v4s32.f32
llvm.nvvm.tld4.r.2d.v4u32.f32
llvm.nvvm.tld4.unified.a.2d.v4f32.f32
llvm.nvvm.tld4.unified.a.2d.v4s32.f32
llvm.nvvm.tld4.unified.a.2d.v4u32.f32
llvm.nvvm.tld4.unified.b.2d.v4f32.f32
llvm.nvvm.tld4.unified.b.2d.v4s32.f32
llvm.nvvm.tld4.unified.b.2d.v4u32.f32
llvm.nvvm.tld4.unified.g.2d.v4f32.f32
llvm.nvvm.tld4.unified.g.2d.v4s32.f32
llvm.nvvm.tld4.unified.g.2d.v4u32.f32
llvm.nvvm.tld4.unified.r.2d.v4f32.f32
llvm.nvvm.tld4.unified.r.2d.v4s32.f32
llvm.nvvm.tld4.unified.r.2d.v4u32.f32
llvm.nvvm.trunc.d
llvm.nvvm.trunc.f
llvm.nvvm.trunc.ftz.f
llvm.nvvm.txq.array.size
llvm.nvvm.txq.channel.data.type
llvm.nvvm.txq.channel.order
llvm.nvvm.txq.depth
llvm.nvvm.txq.height
llvm.nvvm.txq.num.mipmap.levels
llvm.nvvm.txq.num.samples
llvm.nvvm.txq.width
llvm.nvvm.ui2d.rm
llvm.nvvm.ui2d.rn
llvm.nvvm.ui2d.rp
llvm.nvvm.ui2d.rz
llvm.nvvm.ui2f.rm
llvm.nvvm.ui2f.rn
llvm.nvvm.ui2f.rp
llvm.nvvm.ui2f.rz
llvm.nvvm.ull2d.rm
llvm.nvvm.ull2d.rn
llvm.nvvm.ull2d.rp
llvm.nvvm.ull2d.rz
llvm.nvvm.ull2f.rm
llvm.nvvm.ull2f.rn
llvm.nvvm.ull2f.rp
llvm.nvvm.ull2f.rz
llvm.nvvm.vote.all
llvm.nvvm.vote.all.sync
llvm.nvvm.vote.any
llvm.nvvm.vote.any.sync
llvm.nvvm.vote.ballot
llvm.nvvm.vote.ballot.sync
llvm.nvvm.vote.uni
llvm.nvvm.vote.uni.sync
llvm.nvvm.wmma.m16n16k16.load.a.col.f16
llvm.nvvm.wmma.m16n16k16.load.a.col.stride.f16
llvm.nvvm.wmma.m16n16k16.load.a.row.f16
llvm.nvvm.wmma.m16n16k16.load.a.row.stride.f16
llvm.nvvm.wmma.m16n16k16.load.b.col.f16
llvm.nvvm.wmma.m16n16k16.load.b.col.stride.f16
llvm.nvvm.wmma.m16n16k16.load.b.row.f16
llvm.nvvm.wmma.m16n16k16.load.b.row.stride.f16
llvm.nvvm.wmma.m16n16k16.load.c.col.f16
llvm.nvvm.wmma.m16n16k16.load.c.col.f32
llvm.nvvm.wmma.m16n16k16.load.c.col.stride.f16
llvm.nvvm.wmma.m16n16k16.load.c.col.stride.f32
llvm.nvvm.wmma.m16n16k16.load.c.row.f16
llvm.nvvm.wmma.m16n16k16.load.c.row.f32
llvm.nvvm.wmma.m16n16k16.load.c.row.stride.f16
llvm.nvvm.wmma.m16n16k16.load.c.row.stride.f32
llvm.nvvm.wmma.m16n16k16.mma.col.col.f16.f16
llvm.nvvm.wmma.m16n16k16.mma.col.col.f16.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.col.f16.f32
llvm.nvvm.wmma.m16n16k16.mma.col.col.f16.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.col.f32.f16
llvm.nvvm.wmma.m16n16k16.mma.col.col.f32.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.col.f32.f32
llvm.nvvm.wmma.m16n16k16.mma.col.col.f32.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.row.f16.f16
llvm.nvvm.wmma.m16n16k16.mma.col.row.f16.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.row.f16.f32
llvm.nvvm.wmma.m16n16k16.mma.col.row.f16.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.row.f32.f16
llvm.nvvm.wmma.m16n16k16.mma.col.row.f32.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.row.f32.f32
llvm.nvvm.wmma.m16n16k16.mma.col.row.f32.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.col.f16.f16
llvm.nvvm.wmma.m16n16k16.mma.row.col.f16.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.col.f16.f32
llvm.nvvm.wmma.m16n16k16.mma.row.col.f16.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.col.f32.f16
llvm.nvvm.wmma.m16n16k16.mma.row.col.f32.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.col.f32.f32
llvm.nvvm.wmma.m16n16k16.mma.row.col.f32.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.row.f16.f16
llvm.nvvm.wmma.m16n16k16.mma.row.row.f16.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.row.f16.f32
llvm.nvvm.wmma.m16n16k16.mma.row.row.f16.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.row.f32.f16
llvm.nvvm.wmma.m16n16k16.mma.row.row.f32.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.row.f32.f32
llvm.nvvm.wmma.m16n16k16.mma.row.row.f32.f32.satfinite
llvm.nvvm.wmma.m16n16k16.store.d.col.f16
llvm.nvvm.wmma.m16n16k16.store.d.col.f32
llvm.nvvm.wmma.m16n16k16.store.d.col.stride.f16
llvm.nvvm.wmma.m16n16k16.store.d.col.stride.f32
llvm.nvvm.wmma.m16n16k16.store.d.row.f16
llvm.nvvm.wmma.m16n16k16.store.d.row.f32
llvm.nvvm.wmma.m16n16k16.store.d.row.stride.f16
llvm.nvvm.wmma.m16n16k16.store.d.row.stride.f32
llvm.nvvm.wmma.m32n8k16.load.a.col.f16
llvm.nvvm.wmma.m32n8k16.load.a.col.stride.f16
llvm.nvvm.wmma.m32n8k16.load.a.row.f16
llvm.nvvm.wmma.m32n8k16.load.a.row.stride.f16
llvm.nvvm.wmma.m32n8k16.load.b.col.f16
llvm.nvvm.wmma.m32n8k16.load.b.col.stride.f16
llvm.nvvm.wmma.m32n8k16.load.b.row.f16
llvm.nvvm.wmma.m32n8k16.load.b.row.stride.f16
llvm.nvvm.wmma.m32n8k16.load.c.col.f16
llvm.nvvm.wmma.m32n8k16.load.c.col.f32
llvm.nvvm.wmma.m32n8k16.load.c.col.stride.f16
llvm.nvvm.wmma.m32n8k16.load.c.col.stride.f32
llvm.nvvm.wmma.m32n8k16.load.c.row.f16
llvm.nvvm.wmma.m32n8k16.load.c.row.f32
llvm.nvvm.wmma.m32n8k16.load.c.row.stride.f16
llvm.nvvm.wmma.m32n8k16.load.c.row.stride.f32
llvm.nvvm.wmma.m32n8k16.mma.col.col.f16.f16
llvm.nvvm.wmma.m32n8k16.mma.col.col.f16.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.col.f16.f32
llvm.nvvm.wmma.m32n8k16.mma.col.col.f16.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.col.f32.f16
llvm.nvvm.wmma.m32n8k16.mma.col.col.f32.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.col.f32.f32
llvm.nvvm.wmma.m32n8k16.mma.col.col.f32.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.row.f16.f16
llvm.nvvm.wmma.m32n8k16.mma.col.row.f16.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.row.f16.f32
llvm.nvvm.wmma.m32n8k16.mma.col.row.f16.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.row.f32.f16
llvm.nvvm.wmma.m32n8k16.mma.col.row.f32.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.row.f32.f32
llvm.nvvm.wmma.m32n8k16.mma.col.row.f32.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.col.f16.f16
llvm.nvvm.wmma.m32n8k16.mma.row.col.f16.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.col.f16.f32
llvm.nvvm.wmma.m32n8k16.mma.row.col.f16.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.col.f32.f16
llvm.nvvm.wmma.m32n8k16.mma.row.col.f32.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.col.f32.f32
llvm.nvvm.wmma.m32n8k16.mma.row.col.f32.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.row.f16.f16
llvm.nvvm.wmma.m32n8k16.mma.row.row.f16.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.row.f16.f32
llvm.nvvm.wmma.m32n8k16.mma.row.row.f16.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.row.f32.f16
llvm.nvvm.wmma.m32n8k16.mma.row.row.f32.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.row.f32.f32
llvm.nvvm.wmma.m32n8k16.mma.row.row.f32.f32.satfinite
llvm.nvvm.wmma.m32n8k16.store.d.col.f16
llvm.nvvm.wmma.m32n8k16.store.d.col.f32
llvm.nvvm.wmma.m32n8k16.store.d.col.stride.f16
llvm.nvvm.wmma.m32n8k16.store.d.col.stride.f32
llvm.nvvm.wmma.m32n8k16.store.d.row.f16
llvm.nvvm.wmma.m32n8k16.store.d.row.f32
llvm.nvvm.wmma.m32n8k16.store.d.row.stride.f16
llvm.nvvm.wmma.m32n8k16.store.d.row.stride.f32
llvm.nvvm.wmma.m8n32k16.load.a.col.f16
llvm.nvvm.wmma.m8n32k16.load.a.col.stride.f16
llvm.nvvm.wmma.m8n32k16.load.a.row.f16
llvm.nvvm.wmma.m8n32k16.load.a.row.stride.f16
llvm.nvvm.wmma.m8n32k16.load.b.col.f16
llvm.nvvm.wmma.m8n32k16.load.b.col.stride.f16
llvm.nvvm.wmma.m8n32k16.load.b.row.f16
llvm.nvvm.wmma.m8n32k16.load.b.row.stride.f16
llvm.nvvm.wmma.m8n32k16.load.c.col.f16
llvm.nvvm.wmma.m8n32k16.load.c.col.f32
llvm.nvvm.wmma.m8n32k16.load.c.col.stride.f16
llvm.nvvm.wmma.m8n32k16.load.c.col.stride.f32
llvm.nvvm.wmma.m8n32k16.load.c.row.f16
llvm.nvvm.wmma.m8n32k16.load.c.row.f32
llvm.nvvm.wmma.m8n32k16.load.c.row.stride.f16
llvm.nvvm.wmma.m8n32k16.load.c.row.stride.f32
llvm.nvvm.wmma.m8n32k16.mma.col.col.f16.f16
llvm.nvvm.wmma.m8n32k16.mma.col.col.f16.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.col.f16.f32
llvm.nvvm.wmma.m8n32k16.mma.col.col.f16.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.col.f32.f16
llvm.nvvm.wmma.m8n32k16.mma.col.col.f32.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.col.f32.f32
llvm.nvvm.wmma.m8n32k16.mma.col.col.f32.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.row.f16.f16
llvm.nvvm.wmma.m8n32k16.mma.col.row.f16.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.row.f16.f32
llvm.nvvm.wmma.m8n32k16.mma.col.row.f16.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.row.f32.f16
llvm.nvvm.wmma.m8n32k16.mma.col.row.f32.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.row.f32.f32
llvm.nvvm.wmma.m8n32k16.mma.col.row.f32.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.col.f16.f16
llvm.nvvm.wmma.m8n32k16.mma.row.col.f16.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.col.f16.f32
llvm.nvvm.wmma.m8n32k16.mma.row.col.f16.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.col.f32.f16
llvm.nvvm.wmma.m8n32k16.mma.row.col.f32.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.col.f32.f32
llvm.nvvm.wmma.m8n32k16.mma.row.col.f32.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.row.f16.f16
llvm.nvvm.wmma.m8n32k16.mma.row.row.f16.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.row.f16.f32
llvm.nvvm.wmma.m8n32k16.mma.row.row.f16.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.row.f32.f16
llvm.nvvm.wmma.m8n32k16.mma.row.row.f32.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.row.f32.f32
llvm.nvvm.wmma.m8n32k16.mma.row.row.f32.f32.satfinite
llvm.nvvm.wmma.m8n32k16.store.d.col.f16
llvm.nvvm.wmma.m8n32k16.store.d.col.f32
llvm.nvvm.wmma.m8n32k16.store.d.col.stride.f16
llvm.nvvm.wmma.m8n32k16.store.d.col.stride.f32
llvm.nvvm.wmma.m8n32k16.store.d.row.f16
llvm.nvvm.wmma.m8n32k16.store.d.row.f32
llvm.nvvm.wmma.m8n32k16.store.d.row.stride.f16
llvm.nvvm.wmma.m8n32k16.store.d.row.stride.f32
llvm.ppc.addf128.round.to.odd
llvm.ppc.altivec.crypto.vcipher
llvm.ppc.altivec.crypto.vcipherlast
llvm.ppc.altivec.crypto.vncipher
llvm.ppc.altivec.crypto.vncipherlast
llvm.ppc.altivec.crypto.vpermxor
llvm.ppc.altivec.crypto.vpmsumb
llvm.ppc.altivec.crypto.vpmsumd
llvm.ppc.altivec.crypto.vpmsumh
llvm.ppc.altivec.crypto.vpmsumw
llvm.ppc.altivec.crypto.vsbox
llvm.ppc.altivec.crypto.vshasigmad
llvm.ppc.altivec.crypto.vshasigmaw
llvm.ppc.altivec.dss
llvm.ppc.altivec.dssall
llvm.ppc.altivec.dst
llvm.ppc.altivec.dstst
llvm.ppc.altivec.dststt
llvm.ppc.altivec.dstt
llvm.ppc.altivec.lvebx
llvm.ppc.altivec.lvehx
llvm.ppc.altivec.lvewx
llvm.ppc.altivec.lvsl
llvm.ppc.altivec.lvsr
llvm.ppc.altivec.lvx
llvm.ppc.altivec.lvxl
llvm.ppc.altivec.mfvscr
llvm.ppc.altivec.mtvscr
llvm.ppc.altivec.stvebx
llvm.ppc.altivec.stvehx
llvm.ppc.altivec.stvewx
llvm.ppc.altivec.stvx
llvm.ppc.altivec.stvxl
llvm.ppc.altivec.vabsdub
llvm.ppc.altivec.vabsduh
llvm.ppc.altivec.vabsduw
llvm.ppc.altivec.vaddcuq
llvm.ppc.altivec.vaddcuw
llvm.ppc.altivec.vaddecuq
llvm.ppc.altivec.vaddeuqm
llvm.ppc.altivec.vaddsbs
llvm.ppc.altivec.vaddshs
llvm.ppc.altivec.vaddsws
llvm.ppc.altivec.vaddubs
llvm.ppc.altivec.vadduhs
llvm.ppc.altivec.vadduws
llvm.ppc.altivec.vavgsb
llvm.ppc.altivec.vavgsh
llvm.ppc.altivec.vavgsw
llvm.ppc.altivec.vavgub
llvm.ppc.altivec.vavguh
llvm.ppc.altivec.vavguw
llvm.ppc.altivec.vbpermq
llvm.ppc.altivec.vcfsx
llvm.ppc.altivec.vcfux
llvm.ppc.altivec.vclzlsbb
llvm.ppc.altivec.vcmpbfp
llvm.ppc.altivec.vcmpbfp.p
llvm.ppc.altivec.vcmpeqfp
llvm.ppc.altivec.vcmpeqfp.p
llvm.ppc.altivec.vcmpequb
llvm.ppc.altivec.vcmpequb.p
llvm.ppc.altivec.vcmpequd
llvm.ppc.altivec.vcmpequd.p
llvm.ppc.altivec.vcmpequh
llvm.ppc.altivec.vcmpequh.p
llvm.ppc.altivec.vcmpequw
llvm.ppc.altivec.vcmpequw.p
llvm.ppc.altivec.vcmpgefp
llvm.ppc.altivec.vcmpgefp.p
llvm.ppc.altivec.vcmpgtfp
llvm.ppc.altivec.vcmpgtfp.p
llvm.ppc.altivec.vcmpgtsb
llvm.ppc.altivec.vcmpgtsb.p
llvm.ppc.altivec.vcmpgtsd
llvm.ppc.altivec.vcmpgtsd.p
llvm.ppc.altivec.vcmpgtsh
llvm.ppc.altivec.vcmpgtsh.p
llvm.ppc.altivec.vcmpgtsw
llvm.ppc.altivec.vcmpgtsw.p
llvm.ppc.altivec.vcmpgtub
llvm.ppc.altivec.vcmpgtub.p
llvm.ppc.altivec.vcmpgtud
llvm.ppc.altivec.vcmpgtud.p
llvm.ppc.altivec.vcmpgtuh
llvm.ppc.altivec.vcmpgtuh.p
llvm.ppc.altivec.vcmpgtuw
llvm.ppc.altivec.vcmpgtuw.p
llvm.ppc.altivec.vcmpneb
llvm.ppc.altivec.vcmpneb.p
llvm.ppc.altivec.vcmpneh
llvm.ppc.altivec.vcmpneh.p
llvm.ppc.altivec.vcmpnew
llvm.ppc.altivec.vcmpnew.p
llvm.ppc.altivec.vcmpnezb
llvm.ppc.altivec.vcmpnezb.p
llvm.ppc.altivec.vcmpnezh
llvm.ppc.altivec.vcmpnezh.p
llvm.ppc.altivec.vcmpnezw
llvm.ppc.altivec.vcmpnezw.p
llvm.ppc.altivec.vctsxs
llvm.ppc.altivec.vctuxs
llvm.ppc.altivec.vctzlsbb
llvm.ppc.altivec.vexptefp
llvm.ppc.altivec.vgbbd
llvm.ppc.altivec.vlogefp
llvm.ppc.altivec.vmaddfp
llvm.ppc.altivec.vmaxfp
llvm.ppc.altivec.vmaxsb
llvm.ppc.altivec.vmaxsd
llvm.ppc.altivec.vmaxsh
llvm.ppc.altivec.vmaxsw
llvm.ppc.altivec.vmaxub
llvm.ppc.altivec.vmaxud
llvm.ppc.altivec.vmaxuh
llvm.ppc.altivec.vmaxuw
llvm.ppc.altivec.vmhaddshs
llvm.ppc.altivec.vmhraddshs
llvm.ppc.altivec.vminfp
llvm.ppc.altivec.vminsb
llvm.ppc.altivec.vminsd
llvm.ppc.altivec.vminsh
llvm.ppc.altivec.vminsw
llvm.ppc.altivec.vminub
llvm.ppc.altivec.vminud
llvm.ppc.altivec.vminuh
llvm.ppc.altivec.vminuw
llvm.ppc.altivec.vmladduhm
llvm.ppc.altivec.vmsummbm
llvm.ppc.altivec.vmsumshm
llvm.ppc.altivec.vmsumshs
llvm.ppc.altivec.vmsumubm
llvm.ppc.altivec.vmsumuhm
llvm.ppc.altivec.vmsumuhs
llvm.ppc.altivec.vmulesb
llvm.ppc.altivec.vmulesh
llvm.ppc.altivec.vmulesw
llvm.ppc.altivec.vmuleub
llvm.ppc.altivec.vmuleuh
llvm.ppc.altivec.vmuleuw
llvm.ppc.altivec.vmulosb
llvm.ppc.altivec.vmulosh
llvm.ppc.altivec.vmulosw
llvm.ppc.altivec.vmuloub
llvm.ppc.altivec.vmulouh
llvm.ppc.altivec.vmulouw
llvm.ppc.altivec.vnmsubfp
llvm.ppc.altivec.vperm
llvm.ppc.altivec.vpkpx
llvm.ppc.altivec.vpksdss
llvm.ppc.altivec.vpksdus
llvm.ppc.altivec.vpkshss
llvm.ppc.altivec.vpkshus
llvm.ppc.altivec.vpkswss
llvm.ppc.altivec.vpkswus
llvm.ppc.altivec.vpkudus
llvm.ppc.altivec.vpkuhus
llvm.ppc.altivec.vpkuwus
llvm.ppc.altivec.vprtybd
llvm.ppc.altivec.vprtybq
llvm.ppc.altivec.vprtybw
llvm.ppc.altivec.vrefp
llvm.ppc.altivec.vrfim
llvm.ppc.altivec.vrfin
llvm.ppc.altivec.vrfip
llvm.ppc.altivec.vrfiz
llvm.ppc.altivec.vrlb
llvm.ppc.altivec.vrld
llvm.ppc.altivec.vrldmi
llvm.ppc.altivec.vrldnm
llvm.ppc.altivec.vrlh
llvm.ppc.altivec.vrlw
llvm.ppc.altivec.vrlwmi
llvm.ppc.altivec.vrlwnm
llvm.ppc.altivec.vrsqrtefp
llvm.ppc.altivec.vsel
llvm.ppc.altivec.vsl
llvm.ppc.altivec.vslb
llvm.ppc.altivec.vslh
llvm.ppc.altivec.vslo
llvm.ppc.altivec.vslv
llvm.ppc.altivec.vslw
llvm.ppc.altivec.vsr
llvm.ppc.altivec.vsrab
llvm.ppc.altivec.vsrah
llvm.ppc.altivec.vsraw
llvm.ppc.altivec.vsrb
llvm.ppc.altivec.vsrh
llvm.ppc.altivec.vsro
llvm.ppc.altivec.vsrv
llvm.ppc.altivec.vsrw
llvm.ppc.altivec.vsubcuq
llvm.ppc.altivec.vsubcuw
llvm.ppc.altivec.vsubecuq
llvm.ppc.altivec.vsubeuqm
llvm.ppc.altivec.vsubsbs
llvm.ppc.altivec.vsubshs
llvm.ppc.altivec.vsubsws
llvm.ppc.altivec.vsububs
llvm.ppc.altivec.vsubuhs
llvm.ppc.altivec.vsubuws
llvm.ppc.altivec.vsum2sws
llvm.ppc.altivec.vsum4sbs
llvm.ppc.altivec.vsum4shs
llvm.ppc.altivec.vsum4ubs
llvm.ppc.altivec.vsumsws
llvm.ppc.altivec.vupkhpx
llvm.ppc.altivec.vupkhsb
llvm.ppc.altivec.vupkhsh
llvm.ppc.altivec.vupkhsw
llvm.ppc.altivec.vupklpx
llvm.ppc.altivec.vupklsb
llvm.ppc.altivec.vupklsh
llvm.ppc.altivec.vupklsw
llvm.ppc.bpermd
llvm.ppc.cfence
llvm.ppc.dcba
llvm.ppc.dcbf
llvm.ppc.dcbi
llvm.ppc.dcbst
llvm.ppc.dcbt
llvm.ppc.dcbtst
llvm.ppc.dcbz
llvm.ppc.dcbzl
llvm.ppc.divde
llvm.ppc.divdeu
llvm.ppc.divf128.round.to.odd
llvm.ppc.divwe
llvm.ppc.divweu
llvm.ppc.fmaf128.round.to.odd
llvm.ppc.get.texasr
llvm.ppc.get.texasru
llvm.ppc.get.tfhar
llvm.ppc.get.tfiar
llvm.ppc.is.decremented.ctr.nonzero
llvm.ppc.lwsync
llvm.ppc.mtctr
llvm.ppc.mulf128.round.to.odd
llvm.ppc.qpx.qvfabs
llvm.ppc.qpx.qvfadd
llvm.ppc.qpx.qvfadds
llvm.ppc.qpx.qvfcfid
llvm.ppc.qpx.qvfcfids
llvm.ppc.qpx.qvfcfidu
llvm.ppc.qpx.qvfcfidus
llvm.ppc.qpx.qvfcmpeq
llvm.ppc.qpx.qvfcmpgt
llvm.ppc.qpx.qvfcmplt
llvm.ppc.qpx.qvfcpsgn
llvm.ppc.qpx.qvfctid
llvm.ppc.qpx.qvfctidu
llvm.ppc.qpx.qvfctiduz
llvm.ppc.qpx.qvfctidz
llvm.ppc.qpx.qvfctiw
llvm.ppc.qpx.qvfctiwu
llvm.ppc.qpx.qvfctiwuz
llvm.ppc.qpx.qvfctiwz
llvm.ppc.qpx.qvflogical
llvm.ppc.qpx.qvfmadd
llvm.ppc.qpx.qvfmadds
llvm.ppc.qpx.qvfmsub
llvm.ppc.qpx.qvfmsubs
llvm.ppc.qpx.qvfmul
llvm.ppc.qpx.qvfmuls
llvm.ppc.qpx.qvfnabs
llvm.ppc.qpx.qvfneg
llvm.ppc.qpx.qvfnmadd
llvm.ppc.qpx.qvfnmadds
llvm.ppc.qpx.qvfnmsub
llvm.ppc.qpx.qvfnmsubs
llvm.ppc.qpx.qvfperm
llvm.ppc.qpx.qvfre
llvm.ppc.qpx.qvfres
llvm.ppc.qpx.qvfrim
llvm.ppc.qpx.qvfrin
llvm.ppc.qpx.qvfrip
llvm.ppc.qpx.qvfriz
llvm.ppc.qpx.qvfrsp
llvm.ppc.qpx.qvfrsqrte
llvm.ppc.qpx.qvfrsqrtes
llvm.ppc.qpx.qvfsel
llvm.ppc.qpx.qvfsub
llvm.ppc.qpx.qvfsubs
llvm.ppc.qpx.qvftstnan
llvm.ppc.qpx.qvfxmadd
llvm.ppc.qpx.qvfxmadds
llvm.ppc.qpx.qvfxmul
llvm.ppc.qpx.qvfxmuls
llvm.ppc.qpx.qvfxxcpnmadd
llvm.ppc.qpx.qvfxxcpnmadds
llvm.ppc.qpx.qvfxxmadd
llvm.ppc.qpx.qvfxxmadds
llvm.ppc.qpx.qvfxxnpmadd
llvm.ppc.qpx.qvfxxnpmadds
llvm.ppc.qpx.qvgpci
llvm.ppc.qpx.qvlfcd
llvm.ppc.qpx.qvlfcda
llvm.ppc.qpx.qvlfcs
llvm.ppc.qpx.qvlfcsa
llvm.ppc.qpx.qvlfd
llvm.ppc.qpx.qvlfda
llvm.ppc.qpx.qvlfiwa
llvm.ppc.qpx.qvlfiwaa
llvm.ppc.qpx.qvlfiwz
llvm.ppc.qpx.qvlfiwza
llvm.ppc.qpx.qvlfs
llvm.ppc.qpx.qvlfsa
llvm.ppc.qpx.qvlpcld
llvm.ppc.qpx.qvlpcls
llvm.ppc.qpx.qvlpcrd
llvm.ppc.qpx.qvlpcrs
llvm.ppc.qpx.qvstfcd
llvm.ppc.qpx.qvstfcda
llvm.ppc.qpx.qvstfcs
llvm.ppc.qpx.qvstfcsa
llvm.ppc.qpx.qvstfd
llvm.ppc.qpx.qvstfda
llvm.ppc.qpx.qvstfiw
llvm.ppc.qpx.qvstfiwa
llvm.ppc.qpx.qvstfs
llvm.ppc.qpx.qvstfsa
llvm.ppc.set.texasr
llvm.ppc.set.texasru
llvm.ppc.set.tfhar
llvm.ppc.set.tfiar
llvm.ppc.sqrtf128.round.to.odd
llvm.ppc.subf128.round.to.odd
llvm.ppc.sync
llvm.ppc.tabort
llvm.ppc.tabortdc
llvm.ppc.tabortdci
llvm.ppc.tabortwc
llvm.ppc.tabortwci
llvm.ppc.tbegin
llvm.ppc.tcheck
llvm.ppc.tend
llvm.ppc.tendall
llvm.ppc.trechkpt
llvm.ppc.treclaim
llvm.ppc.tresume
llvm.ppc.truncf128.round.to.odd
llvm.ppc.tsr
llvm.ppc.tsuspend
llvm.ppc.ttest
llvm.ppc.vsx.lxvd2x
llvm.ppc.vsx.lxvd2x.be
llvm.ppc.vsx.lxvl
llvm.ppc.vsx.lxvll
llvm.ppc.vsx.lxvw4x
llvm.ppc.vsx.lxvw4x.be
llvm.ppc.vsx.stxvd2x
llvm.ppc.vsx.stxvd2x.be
llvm.ppc.vsx.stxvl
llvm.ppc.vsx.stxvll
llvm.ppc.vsx.stxvw4x
llvm.ppc.vsx.stxvw4x.be
llvm.ppc.vsx.xsmaxdp
llvm.ppc.vsx.xsmindp
llvm.ppc.vsx.xvcmpeqdp
llvm.ppc.vsx.xvcmpeqdp.p
llvm.ppc.vsx.xvcmpeqsp
llvm.ppc.vsx.xvcmpeqsp.p
llvm.ppc.vsx.xvcmpgedp
llvm.ppc.vsx.xvcmpgedp.p
llvm.ppc.vsx.xvcmpgesp
llvm.ppc.vsx.xvcmpgesp.p
llvm.ppc.vsx.xvcmpgtdp
llvm.ppc.vsx.xvcmpgtdp.p
llvm.ppc.vsx.xvcmpgtsp
llvm.ppc.vsx.xvcmpgtsp.p
llvm.ppc.vsx.xvcvdpsp
llvm.ppc.vsx.xvcvdpsxws
llvm.ppc.vsx.xvcvdpuxws
llvm.ppc.vsx.xvcvhpsp
llvm.ppc.vsx.xvcvspdp
llvm.ppc.vsx.xvcvsphp
llvm.ppc.vsx.xvcvsxdsp
llvm.ppc.vsx.xvcvsxwdp
llvm.ppc.vsx.xvcvuxdsp
llvm.ppc.vsx.xvcvuxwdp
llvm.ppc.vsx.xvdivdp
llvm.ppc.vsx.xvdivsp
llvm.ppc.vsx.xviexpdp
llvm.ppc.vsx.xviexpsp
llvm.ppc.vsx.xvmaxdp
llvm.ppc.vsx.xvmaxsp
llvm.ppc.vsx.xvmindp
llvm.ppc.vsx.xvminsp
llvm.ppc.vsx.xvrdpip
llvm.ppc.vsx.xvredp
llvm.ppc.vsx.xvresp
llvm.ppc.vsx.xvrspip
llvm.ppc.vsx.xvrsqrtedp
llvm.ppc.vsx.xvrsqrtesp
llvm.ppc.vsx.xvtstdcdp
llvm.ppc.vsx.xvtstdcsp
llvm.ppc.vsx.xvxexpdp
llvm.ppc.vsx.xvxexpsp
llvm.ppc.vsx.xvxsigdp
llvm.ppc.vsx.xvxsigsp
llvm.ppc.vsx.xxextractuw
llvm.ppc.vsx.xxinsertw
llvm.ppc.vsx.xxleqv
llvm.r600.cube
llvm.r600.ddx
llvm.r600.ddy
llvm.r600.dot4
llvm.r600.group.barrier
llvm.r600.implicitarg.ptr
llvm.r600.kill
llvm.r600.rat.store.typed
llvm.r600.read.global.size.x
llvm.r600.read.global.size.y
llvm.r600.read.global.size.z
llvm.r600.read.local.size.x
llvm.r600.read.local.size.y
llvm.r600.read.local.size.z
llvm.r600.read.ngroups.x
llvm.r600.read.ngroups.y
llvm.r600.read.ngroups.z
llvm.r600.read.tgid.x
llvm.r600.read.tgid.y
llvm.r600.read.tgid.z
llvm.r600.read.tidig.x
llvm.r600.read.tidig.y
llvm.r600.read.tidig.z
llvm.r600.recipsqrt.clamped
llvm.r600.recipsqrt.ieee
llvm.r600.store.stream.output
llvm.r600.store.swizzle
llvm.r600.tex
llvm.r600.texc
llvm.r600.txb
llvm.r600.txbc
llvm.r600.txf
llvm.r600.txl
llvm.r600.txlc
llvm.r600.txq
llvm.s390.efpc
llvm.s390.etnd
llvm.s390.lcbb
llvm.s390.ntstg
llvm.s390.ppa.txassist
llvm.s390.sfpc
llvm.s390.tabort
llvm.s390.tbegin
llvm.s390.tbegin.nofloat
llvm.s390.tbeginc
llvm.s390.tdc
llvm.s390.tend
llvm.s390.vaccb
llvm.s390.vacccq
llvm.s390.vaccf
llvm.s390.vaccg
llvm.s390.vacch
llvm.s390.vaccq
llvm.s390.vacq
llvm.s390.vaq
llvm.s390.vavgb
llvm.s390.vavgf
llvm.s390.vavgg
llvm.s390.vavgh
llvm.s390.vavglb
llvm.s390.vavglf
llvm.s390.vavglg
llvm.s390.vavglh
llvm.s390.vbperm
llvm.s390.vceqbs
llvm.s390.vceqfs
llvm.s390.vceqgs
llvm.s390.vceqhs
llvm.s390.vchbs
llvm.s390.vchfs
llvm.s390.vchgs
llvm.s390.vchhs
llvm.s390.vchlbs
llvm.s390.vchlfs
llvm.s390.vchlgs
llvm.s390.vchlhs
llvm.s390.vcksm
llvm.s390.verimb
llvm.s390.verimf
llvm.s390.verimg
llvm.s390.verimh
llvm.s390.verllb
llvm.s390.verllf
llvm.s390.verllg
llvm.s390.verllh
llvm.s390.verllvb
llvm.s390.verllvf
llvm.s390.verllvg
llvm.s390.verllvh
llvm.s390.vfaeb
llvm.s390.vfaebs
llvm.s390.vfaef
llvm.s390.vfaefs
llvm.s390.vfaeh
llvm.s390.vfaehs
llvm.s390.vfaezb
llvm.s390.vfaezbs
llvm.s390.vfaezf
llvm.s390.vfaezfs
llvm.s390.vfaezh
llvm.s390.vfaezhs
llvm.s390.vfcedbs
llvm.s390.vfcesbs
llvm.s390.vfchdbs
llvm.s390.vfchedbs
llvm.s390.vfchesbs
llvm.s390.vfchsbs
llvm.s390.vfeeb
llvm.s390.vfeebs
llvm.s390.vfeef
llvm.s390.vfeefs
llvm.s390.vfeeh
llvm.s390.vfeehs
llvm.s390.vfeezb
llvm.s390.vfeezbs
llvm.s390.vfeezf
llvm.s390.vfeezfs
llvm.s390.vfeezh
llvm.s390.vfeezhs
llvm.s390.vfeneb
llvm.s390.vfenebs
llvm.s390.vfenef
llvm.s390.vfenefs
llvm.s390.vfeneh
llvm.s390.vfenehs
llvm.s390.vfenezb
llvm.s390.vfenezbs
llvm.s390.vfenezf
llvm.s390.vfenezfs
llvm.s390.vfenezh
llvm.s390.vfenezhs
llvm.s390.vfidb
llvm.s390.vfisb
llvm.s390.vfmaxdb
llvm.s390.vfmaxsb
llvm.s390.vfmindb
llvm.s390.vfminsb
llvm.s390.vftcidb
llvm.s390.vftcisb
llvm.s390.vgfmab
llvm.s390.vgfmaf
llvm.s390.vgfmag
llvm.s390.vgfmah
llvm.s390.vgfmb
llvm.s390.vgfmf
llvm.s390.vgfmg
llvm.s390.vgfmh
llvm.s390.vistrb
llvm.s390.vistrbs
llvm.s390.vistrf
llvm.s390.vistrfs
llvm.s390.vistrh
llvm.s390.vistrhs
llvm.s390.vlbb
llvm.s390.vll
llvm.s390.vlrl
llvm.s390.vmaeb
llvm.s390.vmaef
llvm.s390.vmaeh
llvm.s390.vmahb
llvm.s390.vmahf
llvm.s390.vmahh
llvm.s390.vmaleb
llvm.s390.vmalef
llvm.s390.vmaleh
llvm.s390.vmalhb
llvm.s390.vmalhf
llvm.s390.vmalhh
llvm.s390.vmalob
llvm.s390.vmalof
llvm.s390.vmaloh
llvm.s390.vmaob
llvm.s390.vmaof
llvm.s390.vmaoh
llvm.s390.vmeb
llvm.s390.vmef
llvm.s390.vmeh
llvm.s390.vmhb
llvm.s390.vmhf
llvm.s390.vmhh
llvm.s390.vmleb
llvm.s390.vmlef
llvm.s390.vmleh
llvm.s390.vmlhb
llvm.s390.vmlhf
llvm.s390.vmlhh
llvm.s390.vmlob
llvm.s390.vmlof
llvm.s390.vmloh
llvm.s390.vmob
llvm.s390.vmof
llvm.s390.vmoh
llvm.s390.vmslg
llvm.s390.vpdi
llvm.s390.vperm
llvm.s390.vpklsf
llvm.s390.vpklsfs
llvm.s390.vpklsg
llvm.s390.vpklsgs
llvm.s390.vpklsh
llvm.s390.vpklshs
llvm.s390.vpksf
llvm.s390.vpksfs
llvm.s390.vpksg
llvm.s390.vpksgs
llvm.s390.vpksh
llvm.s390.vpkshs
llvm.s390.vsbcbiq
llvm.s390.vsbiq
llvm.s390.vscbib
llvm.s390.vscbif
llvm.s390.vscbig
llvm.s390.vscbih
llvm.s390.vscbiq
llvm.s390.vsl
llvm.s390.vslb
llvm.s390.vsldb
llvm.s390.vsq
llvm.s390.vsra
llvm.s390.vsrab
llvm.s390.vsrl
llvm.s390.vsrlb
llvm.s390.vstl
llvm.s390.vstrcb
llvm.s390.vstrcbs
llvm.s390.vstrcf
llvm.s390.vstrcfs
llvm.s390.vstrch
llvm.s390.vstrchs
llvm.s390.vstrczb
llvm.s390.vstrczbs
llvm.s390.vstrczf
llvm.s390.vstrczfs
llvm.s390.vstrczh
llvm.s390.vstrczhs
llvm.s390.vstrl
llvm.s390.vsumb
llvm.s390.vsumgf
llvm.s390.vsumgh
llvm.s390.vsumh
llvm.s390.vsumqf
llvm.s390.vsumqg
llvm.s390.vtm
llvm.s390.vuphb
llvm.s390.vuphf
llvm.s390.vuphh
llvm.s390.vuplb
llvm.s390.vuplf
llvm.s390.vuplhb
llvm.s390.vuplhf
llvm.s390.vuplhh
llvm.s390.vuplhw
llvm.s390.vupllb
llvm.s390.vupllf
llvm.s390.vupllh
llvm.wasm.catch
llvm.wasm.current.memory
llvm.wasm.get.ehselector
llvm.wasm.get.exception
llvm.wasm.grow.memory
llvm.wasm.landingpad.index
llvm.wasm.lsda
llvm.wasm.mem.grow
llvm.wasm.mem.size
llvm.wasm.memory.grow
llvm.wasm.memory.size
llvm.wasm.rethrow
llvm.wasm.throw
llvm.x86.3dnow.pavgusb
llvm.x86.3dnow.pf2id
llvm.x86.3dnow.pfacc
llvm.x86.3dnow.pfadd
llvm.x86.3dnow.pfcmpeq
llvm.x86.3dnow.pfcmpge
llvm.x86.3dnow.pfcmpgt
llvm.x86.3dnow.pfmax
llvm.x86.3dnow.pfmin
llvm.x86.3dnow.pfmul
llvm.x86.3dnow.pfrcp
llvm.x86.3dnow.pfrcpit1
llvm.x86.3dnow.pfrcpit2
llvm.x86.3dnow.pfrsqit1
llvm.x86.3dnow.pfrsqrt
llvm.x86.3dnow.pfsub
llvm.x86.3dnow.pfsubr
llvm.x86.3dnow.pi2fd
llvm.x86.3dnow.pmulhrw
llvm.x86.3dnowa.pf2iw
llvm.x86.3dnowa.pfnacc
llvm.x86.3dnowa.pfpnacc
llvm.x86.3dnowa.pi2fw
llvm.x86.3dnowa.pswapd
llvm.x86.addcarry.u32
llvm.x86.addcarry.u64
llvm.x86.addcarryx.u32
llvm.x86.addcarryx.u64
llvm.x86.aesni.aesdec
llvm.x86.aesni.aesdec.256
llvm.x86.aesni.aesdec.512
llvm.x86.aesni.aesdeclast
llvm.x86.aesni.aesdeclast.256
llvm.x86.aesni.aesdeclast.512
llvm.x86.aesni.aesenc
llvm.x86.aesni.aesenc.256
llvm.x86.aesni.aesenc.512
llvm.x86.aesni.aesenclast
llvm.x86.aesni.aesenclast.256
llvm.x86.aesni.aesenclast.512
llvm.x86.aesni.aesimc
llvm.x86.aesni.aeskeygenassist
llvm.x86.avx.addsub.pd.256
llvm.x86.avx.addsub.ps.256
llvm.x86.avx.blendv.pd.256
llvm.x86.avx.blendv.ps.256
llvm.x86.avx.cmp.pd.256
llvm.x86.avx.cmp.ps.256
llvm.x86.avx.cvt.pd2.ps.256
llvm.x86.avx.cvt.pd2dq.256
llvm.x86.avx.cvt.ps2dq.256
llvm.x86.avx.cvtt.pd2dq.256
llvm.x86.avx.cvtt.ps2dq.256
llvm.x86.avx.dp.ps.256
llvm.x86.avx.hadd.pd.256
llvm.x86.avx.hadd.ps.256
llvm.x86.avx.hsub.pd.256
llvm.x86.avx.hsub.ps.256
llvm.x86.avx.ldu.dq.256
llvm.x86.avx.maskload.pd
llvm.x86.avx.maskload.pd.256
llvm.x86.avx.maskload.ps
llvm.x86.avx.maskload.ps.256
llvm.x86.avx.maskstore.pd
llvm.x86.avx.maskstore.pd.256
llvm.x86.avx.maskstore.ps
llvm.x86.avx.maskstore.ps.256
llvm.x86.avx.max.pd.256
llvm.x86.avx.max.ps.256
llvm.x86.avx.min.pd.256
llvm.x86.avx.min.ps.256
llvm.x86.avx.movmsk.pd.256
llvm.x86.avx.movmsk.ps.256
llvm.x86.avx.ptestc.256
llvm.x86.avx.ptestnzc.256
llvm.x86.avx.ptestz.256
llvm.x86.avx.rcp.ps.256
llvm.x86.avx.round.pd.256
llvm.x86.avx.round.ps.256
llvm.x86.avx.rsqrt.ps.256
llvm.x86.avx.vpermilvar.pd
llvm.x86.avx.vpermilvar.pd.256
llvm.x86.avx.vpermilvar.ps
llvm.x86.avx.vpermilvar.ps.256
llvm.x86.avx.vtestc.pd
llvm.x86.avx.vtestc.pd.256
llvm.x86.avx.vtestc.ps
llvm.x86.avx.vtestc.ps.256
llvm.x86.avx.vtestnzc.pd
llvm.x86.avx.vtestnzc.pd.256
llvm.x86.avx.vtestnzc.ps
llvm.x86.avx.vtestnzc.ps.256
llvm.x86.avx.vtestz.pd
llvm.x86.avx.vtestz.pd.256
llvm.x86.avx.vtestz.ps
llvm.x86.avx.vtestz.ps.256
llvm.x86.avx.vzeroall
llvm.x86.avx.vzeroupper
llvm.x86.avx2.gather.d.d
llvm.x86.avx2.gather.d.d.256
llvm.x86.avx2.gather.d.pd
llvm.x86.avx2.gather.d.pd.256
llvm.x86.avx2.gather.d.ps
llvm.x86.avx2.gather.d.ps.256
llvm.x86.avx2.gather.d.q
llvm.x86.avx2.gather.d.q.256
llvm.x86.avx2.gather.q.d
llvm.x86.avx2.gather.q.d.256
llvm.x86.avx2.gather.q.pd
llvm.x86.avx2.gather.q.pd.256
llvm.x86.avx2.gather.q.ps
llvm.x86.avx2.gather.q.ps.256
llvm.x86.avx2.gather.q.q
llvm.x86.avx2.gather.q.q.256
llvm.x86.avx2.maskload.d
llvm.x86.avx2.maskload.d.256
llvm.x86.avx2.maskload.q
llvm.x86.avx2.maskload.q.256
llvm.x86.avx2.maskstore.d
llvm.x86.avx2.maskstore.d.256
llvm.x86.avx2.maskstore.q
llvm.x86.avx2.maskstore.q.256
llvm.x86.avx2.mpsadbw
llvm.x86.avx2.packssdw
llvm.x86.avx2.packsswb
llvm.x86.avx2.packusdw
llvm.x86.avx2.packuswb
llvm.x86.avx2.padds.b
llvm.x86.avx2.padds.w
llvm.x86.avx2.paddus.b
llvm.x86.avx2.paddus.w
llvm.x86.avx2.pblendvb
llvm.x86.avx2.permd
llvm.x86.avx2.permps
llvm.x86.avx2.phadd.d
llvm.x86.avx2.phadd.sw
llvm.x86.avx2.phadd.w
llvm.x86.avx2.phsub.d
llvm.x86.avx2.phsub.sw
llvm.x86.avx2.phsub.w
llvm.x86.avx2.pmadd.ub.sw
llvm.x86.avx2.pmadd.wd
llvm.x86.avx2.pmovmskb
llvm.x86.avx2.pmul.hr.sw
llvm.x86.avx2.pmulh.w
llvm.x86.avx2.pmulhu.w
llvm.x86.avx2.psad.bw
llvm.x86.avx2.pshuf.b
llvm.x86.avx2.psign.b
llvm.x86.avx2.psign.d
llvm.x86.avx2.psign.w
llvm.x86.avx2.psll.d
llvm.x86.avx2.psll.q
llvm.x86.avx2.psll.w
llvm.x86.avx2.pslli.d
llvm.x86.avx2.pslli.q
llvm.x86.avx2.pslli.w
llvm.x86.avx2.psllv.d
llvm.x86.avx2.psllv.d.256
llvm.x86.avx2.psllv.q
llvm.x86.avx2.psllv.q.256
llvm.x86.avx2.psra.d
llvm.x86.avx2.psra.w
llvm.x86.avx2.psrai.d
llvm.x86.avx2.psrai.w
llvm.x86.avx2.psrav.d
llvm.x86.avx2.psrav.d.256
llvm.x86.avx2.psrl.d
llvm.x86.avx2.psrl.q
llvm.x86.avx2.psrl.w
llvm.x86.avx2.psrli.d
llvm.x86.avx2.psrli.q
llvm.x86.avx2.psrli.w
llvm.x86.avx2.psrlv.d
llvm.x86.avx2.psrlv.d.256
llvm.x86.avx2.psrlv.q
llvm.x86.avx2.psrlv.q.256
llvm.x86.avx2.psubs.b
llvm.x86.avx2.psubs.w
llvm.x86.avx2.psubus.b
llvm.x86.avx2.psubus.w
llvm.x86.avx512.add.pd.512
llvm.x86.avx512.add.ps.512
llvm.x86.avx512.broadcastmb.128
llvm.x86.avx512.broadcastmb.256
llvm.x86.avx512.broadcastmb.512
llvm.x86.avx512.broadcastmw.128
llvm.x86.avx512.broadcastmw.256
llvm.x86.avx512.broadcastmw.512
llvm.x86.avx512.cmp.pd.128
llvm.x86.avx512.cmp.pd.256
llvm.x86.avx512.cmp.pd.512
llvm.x86.avx512.cmp.ps.128
llvm.x86.avx512.cmp.ps.256
llvm.x86.avx512.cmp.ps.512
llvm.x86.avx512.cvtsi2sd64
llvm.x86.avx512.cvtsi2ss32
llvm.x86.avx512.cvtsi2ss64
llvm.x86.avx512.cvttsd2si
llvm.x86.avx512.cvttsd2si64
llvm.x86.avx512.cvttsd2usi
llvm.x86.avx512.cvttsd2usi64
llvm.x86.avx512.cvttss2si
llvm.x86.avx512.cvttss2si64
llvm.x86.avx512.cvttss2usi
llvm.x86.avx512.cvttss2usi64
llvm.x86.avx512.cvtusi2ss
llvm.x86.avx512.cvtusi642sd
llvm.x86.avx512.cvtusi642ss
llvm.x86.avx512.dbpsadbw.128
llvm.x86.avx512.dbpsadbw.256
llvm.x86.avx512.dbpsadbw.512
llvm.x86.avx512.div.pd.512
llvm.x86.avx512.div.ps.512
llvm.x86.avx512.exp2.pd
llvm.x86.avx512.exp2.ps
llvm.x86.avx512.fpclass.pd.128
llvm.x86.avx512.fpclass.pd.256
llvm.x86.avx512.fpclass.pd.512
llvm.x86.avx512.fpclass.ps.128
llvm.x86.avx512.fpclass.ps.256
llvm.x86.avx512.fpclass.ps.512
llvm.x86.avx512.gather.dpd.512
llvm.x86.avx512.gather.dpi.512
llvm.x86.avx512.gather.dpq.512
llvm.x86.avx512.gather.dps.512
llvm.x86.avx512.gather.qpd.512
llvm.x86.avx512.gather.qpi.512
llvm.x86.avx512.gather.qpq.512
llvm.x86.avx512.gather.qps.512
llvm.x86.avx512.gather3div2.df
llvm.x86.avx512.gather3div2.di
llvm.x86.avx512.gather3div4.df
llvm.x86.avx512.gather3div4.di
llvm.x86.avx512.gather3div4.sf
llvm.x86.avx512.gather3div4.si
llvm.x86.avx512.gather3div8.sf
llvm.x86.avx512.gather3div8.si
llvm.x86.avx512.gather3siv2.df
llvm.x86.avx512.gather3siv2.di
llvm.x86.avx512.gather3siv4.df
llvm.x86.avx512.gather3siv4.di
llvm.x86.avx512.gather3siv4.sf
llvm.x86.avx512.gather3siv4.si
llvm.x86.avx512.gather3siv8.sf
llvm.x86.avx512.gather3siv8.si
llvm.x86.avx512.gatherpf.dpd.512
llvm.x86.avx512.gatherpf.dps.512
llvm.x86.avx512.gatherpf.qpd.512
llvm.x86.avx512.gatherpf.qps.512
llvm.x86.avx512.mask.add.sd.round
llvm.x86.avx512.mask.add.ss.round
llvm.x86.avx512.mask.cmp.sd
llvm.x86.avx512.mask.cmp.ss
llvm.x86.avx512.mask.compress.b.128
llvm.x86.avx512.mask.compress.b.256
llvm.x86.avx512.mask.compress.b.512
llvm.x86.avx512.mask.compress.d.128
llvm.x86.avx512.mask.compress.d.256
llvm.x86.avx512.mask.compress.d.512
llvm.x86.avx512.mask.compress.pd.128
llvm.x86.avx512.mask.compress.pd.256
llvm.x86.avx512.mask.compress.pd.512
llvm.x86.avx512.mask.compress.ps.128
llvm.x86.avx512.mask.compress.ps.256
llvm.x86.avx512.mask.compress.ps.512
llvm.x86.avx512.mask.compress.q.128
llvm.x86.avx512.mask.compress.q.256
llvm.x86.avx512.mask.compress.q.512
llvm.x86.avx512.mask.compress.w.128
llvm.x86.avx512.mask.compress.w.256
llvm.x86.avx512.mask.compress.w.512
llvm.x86.avx512.mask.conflict.d.128
llvm.x86.avx512.mask.conflict.d.256
llvm.x86.avx512.mask.conflict.d.512
llvm.x86.avx512.mask.conflict.q.128
llvm.x86.avx512.mask.conflict.q.256
llvm.x86.avx512.mask.conflict.q.512
llvm.x86.avx512.mask.cvtdq2ps.512
llvm.x86.avx512.mask.cvtpd2dq.128
llvm.x86.avx512.mask.cvtpd2dq.512
llvm.x86.avx512.mask.cvtpd2ps
llvm.x86.avx512.mask.cvtpd2ps.512
llvm.x86.avx512.mask.cvtpd2qq.128
llvm.x86.avx512.mask.cvtpd2qq.256
llvm.x86.avx512.mask.cvtpd2qq.512
llvm.x86.avx512.mask.cvtpd2udq.128
llvm.x86.avx512.mask.cvtpd2udq.256
llvm.x86.avx512.mask.cvtpd2udq.512
llvm.x86.avx512.mask.cvtpd2uqq.128
llvm.x86.avx512.mask.cvtpd2uqq.256
llvm.x86.avx512.mask.cvtpd2uqq.512
llvm.x86.avx512.mask.cvtps2dq.128
llvm.x86.avx512.mask.cvtps2dq.256
llvm.x86.avx512.mask.cvtps2dq.512
llvm.x86.avx512.mask.cvtps2pd.512
llvm.x86.avx512.mask.cvtps2qq.128
llvm.x86.avx512.mask.cvtps2qq.256
llvm.x86.avx512.mask.cvtps2qq.512
llvm.x86.avx512.mask.cvtps2udq.128
llvm.x86.avx512.mask.cvtps2udq.256
llvm.x86.avx512.mask.cvtps2udq.512
llvm.x86.avx512.mask.cvtps2uqq.128
llvm.x86.avx512.mask.cvtps2uqq.256
llvm.x86.avx512.mask.cvtps2uqq.512
llvm.x86.avx512.mask.cvtqq2pd.512
llvm.x86.avx512.mask.cvtqq2ps.128
llvm.x86.avx512.mask.cvtqq2ps.256
llvm.x86.avx512.mask.cvtqq2ps.512
llvm.x86.avx512.mask.cvtsd2ss.round
llvm.x86.avx512.mask.cvtss2sd.round
llvm.x86.avx512.mask.cvttpd2dq.128
llvm.x86.avx512.mask.cvttpd2dq.512
llvm.x86.avx512.mask.cvttpd2qq.128
llvm.x86.avx512.mask.cvttpd2qq.256
llvm.x86.avx512.mask.cvttpd2qq.512
llvm.x86.avx512.mask.cvttpd2udq.128
llvm.x86.avx512.mask.cvttpd2udq.256
llvm.x86.avx512.mask.cvttpd2udq.512
llvm.x86.avx512.mask.cvttpd2uqq.128
llvm.x86.avx512.mask.cvttpd2uqq.256
llvm.x86.avx512.mask.cvttpd2uqq.512
llvm.x86.avx512.mask.cvttps2dq.512
llvm.x86.avx512.mask.cvttps2qq.128
llvm.x86.avx512.mask.cvttps2qq.256
llvm.x86.avx512.mask.cvttps2qq.512
llvm.x86.avx512.mask.cvttps2udq.128
llvm.x86.avx512.mask.cvttps2udq.256
llvm.x86.avx512.mask.cvttps2udq.512
llvm.x86.avx512.mask.cvttps2uqq.128
llvm.x86.avx512.mask.cvttps2uqq.256
llvm.x86.avx512.mask.cvttps2uqq.512
llvm.x86.avx512.mask.cvtudq2ps.512
llvm.x86.avx512.mask.cvtuqq2pd.512
llvm.x86.avx512.mask.cvtuqq2ps.128
llvm.x86.avx512.mask.cvtuqq2ps.256
llvm.x86.avx512.mask.cvtuqq2ps.512
llvm.x86.avx512.mask.div.sd.round
llvm.x86.avx512.mask.div.ss.round
llvm.x86.avx512.mask.expand.b.128
llvm.x86.avx512.mask.expand.b.256
llvm.x86.avx512.mask.expand.b.512
llvm.x86.avx512.mask.expand.d.128
llvm.x86.avx512.mask.expand.d.256
llvm.x86.avx512.mask.expand.d.512
llvm.x86.avx512.mask.expand.pd.128
llvm.x86.avx512.mask.expand.pd.256
llvm.x86.avx512.mask.expand.pd.512
llvm.x86.avx512.mask.expand.ps.128
llvm.x86.avx512.mask.expand.ps.256
llvm.x86.avx512.mask.expand.ps.512
llvm.x86.avx512.mask.expand.q.128
llvm.x86.avx512.mask.expand.q.256
llvm.x86.avx512.mask.expand.q.512
llvm.x86.avx512.mask.expand.w.128
llvm.x86.avx512.mask.expand.w.256
llvm.x86.avx512.mask.expand.w.512
llvm.x86.avx512.mask.fixupimm.pd.128
llvm.x86.avx512.mask.fixupimm.pd.256
llvm.x86.avx512.mask.fixupimm.pd.512
llvm.x86.avx512.mask.fixupimm.ps.128
llvm.x86.avx512.mask.fixupimm.ps.256
llvm.x86.avx512.mask.fixupimm.ps.512
llvm.x86.avx512.mask.fixupimm.sd
llvm.x86.avx512.mask.fixupimm.ss
llvm.x86.avx512.mask.fpclass.sd
llvm.x86.avx512.mask.fpclass.ss
llvm.x86.avx512.mask.getexp.pd.128
llvm.x86.avx512.mask.getexp.pd.256
llvm.x86.avx512.mask.getexp.pd.512
llvm.x86.avx512.mask.getexp.ps.128
llvm.x86.avx512.mask.getexp.ps.256
llvm.x86.avx512.mask.getexp.ps.512
llvm.x86.avx512.mask.getexp.sd
llvm.x86.avx512.mask.getexp.ss
llvm.x86.avx512.mask.getmant.pd.128
llvm.x86.avx512.mask.getmant.pd.256
llvm.x86.avx512.mask.getmant.pd.512
llvm.x86.avx512.mask.getmant.ps.128
llvm.x86.avx512.mask.getmant.ps.256
llvm.x86.avx512.mask.getmant.ps.512
llvm.x86.avx512.mask.getmant.sd
llvm.x86.avx512.mask.getmant.ss
llvm.x86.avx512.mask.max.sd.round
llvm.x86.avx512.mask.max.ss.round
llvm.x86.avx512.mask.min.sd.round
llvm.x86.avx512.mask.min.ss.round
llvm.x86.avx512.mask.mul.sd.round
llvm.x86.avx512.mask.mul.ss.round
llvm.x86.avx512.mask.padds.b.128
llvm.x86.avx512.mask.padds.b.256
llvm.x86.avx512.mask.padds.b.512
llvm.x86.avx512.mask.padds.w.128
llvm.x86.avx512.mask.padds.w.256
llvm.x86.avx512.mask.padds.w.512
llvm.x86.avx512.mask.paddus.b.128
llvm.x86.avx512.mask.paddus.b.256
llvm.x86.avx512.mask.paddus.b.512
llvm.x86.avx512.mask.paddus.w.128
llvm.x86.avx512.mask.paddus.w.256
llvm.x86.avx512.mask.paddus.w.512
llvm.x86.avx512.mask.pmov.db.128
llvm.x86.avx512.mask.pmov.db.256
llvm.x86.avx512.mask.pmov.db.512
llvm.x86.avx512.mask.pmov.db.mem.128
llvm.x86.avx512.mask.pmov.db.mem.256
llvm.x86.avx512.mask.pmov.db.mem.512
llvm.x86.avx512.mask.pmov.dw.128
llvm.x86.avx512.mask.pmov.dw.256
llvm.x86.avx512.mask.pmov.dw.512
llvm.x86.avx512.mask.pmov.dw.mem.128
llvm.x86.avx512.mask.pmov.dw.mem.256
llvm.x86.avx512.mask.pmov.dw.mem.512
llvm.x86.avx512.mask.pmov.qb.128
llvm.x86.avx512.mask.pmov.qb.256
llvm.x86.avx512.mask.pmov.qb.512
llvm.x86.avx512.mask.pmov.qb.mem.128
llvm.x86.avx512.mask.pmov.qb.mem.256
llvm.x86.avx512.mask.pmov.qb.mem.512
llvm.x86.avx512.mask.pmov.qd.128
llvm.x86.avx512.mask.pmov.qd.256
llvm.x86.avx512.mask.pmov.qd.512
llvm.x86.avx512.mask.pmov.qd.mem.128
llvm.x86.avx512.mask.pmov.qd.mem.256
llvm.x86.avx512.mask.pmov.qd.mem.512
llvm.x86.avx512.mask.pmov.qw.128
llvm.x86.avx512.mask.pmov.qw.256
llvm.x86.avx512.mask.pmov.qw.512
llvm.x86.avx512.mask.pmov.qw.mem.128
llvm.x86.avx512.mask.pmov.qw.mem.256
llvm.x86.avx512.mask.pmov.qw.mem.512
llvm.x86.avx512.mask.pmov.wb.128
llvm.x86.avx512.mask.pmov.wb.256
llvm.x86.avx512.mask.pmov.wb.512
llvm.x86.avx512.mask.pmov.wb.mem.128
llvm.x86.avx512.mask.pmov.wb.mem.256
llvm.x86.avx512.mask.pmov.wb.mem.512
llvm.x86.avx512.mask.pmovs.db.128
llvm.x86.avx512.mask.pmovs.db.256
llvm.x86.avx512.mask.pmovs.db.512
llvm.x86.avx512.mask.pmovs.db.mem.128
llvm.x86.avx512.mask.pmovs.db.mem.256
llvm.x86.avx512.mask.pmovs.db.mem.512
llvm.x86.avx512.mask.pmovs.dw.128
llvm.x86.avx512.mask.pmovs.dw.256
llvm.x86.avx512.mask.pmovs.dw.512
llvm.x86.avx512.mask.pmovs.dw.mem.128
llvm.x86.avx512.mask.pmovs.dw.mem.256
llvm.x86.avx512.mask.pmovs.dw.mem.512
llvm.x86.avx512.mask.pmovs.qb.128
llvm.x86.avx512.mask.pmovs.qb.256
llvm.x86.avx512.mask.pmovs.qb.512
llvm.x86.avx512.mask.pmovs.qb.mem.128
llvm.x86.avx512.mask.pmovs.qb.mem.256
llvm.x86.avx512.mask.pmovs.qb.mem.512
llvm.x86.avx512.mask.pmovs.qd.128
llvm.x86.avx512.mask.pmovs.qd.256
llvm.x86.avx512.mask.pmovs.qd.512
llvm.x86.avx512.mask.pmovs.qd.mem.128
llvm.x86.avx512.mask.pmovs.qd.mem.256
llvm.x86.avx512.mask.pmovs.qd.mem.512
llvm.x86.avx512.mask.pmovs.qw.128
llvm.x86.avx512.mask.pmovs.qw.256
llvm.x86.avx512.mask.pmovs.qw.512
llvm.x86.avx512.mask.pmovs.qw.mem.128
llvm.x86.avx512.mask.pmovs.qw.mem.256
llvm.x86.avx512.mask.pmovs.qw.mem.512
llvm.x86.avx512.mask.pmovs.wb.128
llvm.x86.avx512.mask.pmovs.wb.256
llvm.x86.avx512.mask.pmovs.wb.512
llvm.x86.avx512.mask.pmovs.wb.mem.128
llvm.x86.avx512.mask.pmovs.wb.mem.256
llvm.x86.avx512.mask.pmovs.wb.mem.512
llvm.x86.avx512.mask.pmovus.db.128
llvm.x86.avx512.mask.pmovus.db.256
llvm.x86.avx512.mask.pmovus.db.512
llvm.x86.avx512.mask.pmovus.db.mem.128
llvm.x86.avx512.mask.pmovus.db.mem.256
llvm.x86.avx512.mask.pmovus.db.mem.512
llvm.x86.avx512.mask.pmovus.dw.128
llvm.x86.avx512.mask.pmovus.dw.256
llvm.x86.avx512.mask.pmovus.dw.512
llvm.x86.avx512.mask.pmovus.dw.mem.128
llvm.x86.avx512.mask.pmovus.dw.mem.256
llvm.x86.avx512.mask.pmovus.dw.mem.512
llvm.x86.avx512.mask.pmovus.qb.128
llvm.x86.avx512.mask.pmovus.qb.256
llvm.x86.avx512.mask.pmovus.qb.512
llvm.x86.avx512.mask.pmovus.qb.mem.128
llvm.x86.avx512.mask.pmovus.qb.mem.256
llvm.x86.avx512.mask.pmovus.qb.mem.512
llvm.x86.avx512.mask.pmovus.qd.128
llvm.x86.avx512.mask.pmovus.qd.256
llvm.x86.avx512.mask.pmovus.qd.512
llvm.x86.avx512.mask.pmovus.qd.mem.128
llvm.x86.avx512.mask.pmovus.qd.mem.256
llvm.x86.avx512.mask.pmovus.qd.mem.512
llvm.x86.avx512.mask.pmovus.qw.128
llvm.x86.avx512.mask.pmovus.qw.256
llvm.x86.avx512.mask.pmovus.qw.512
llvm.x86.avx512.mask.pmovus.qw.mem.128
llvm.x86.avx512.mask.pmovus.qw.mem.256
llvm.x86.avx512.mask.pmovus.qw.mem.512
llvm.x86.avx512.mask.pmovus.wb.128
llvm.x86.avx512.mask.pmovus.wb.256
llvm.x86.avx512.mask.pmovus.wb.512
llvm.x86.avx512.mask.pmovus.wb.mem.128
llvm.x86.avx512.mask.pmovus.wb.mem.256
llvm.x86.avx512.mask.pmovus.wb.mem.512
llvm.x86.avx512.mask.pmultishift.qb.128
llvm.x86.avx512.mask.pmultishift.qb.256
llvm.x86.avx512.mask.pmultishift.qb.512
llvm.x86.avx512.mask.psubs.b.128
llvm.x86.avx512.mask.psubs.b.256
llvm.x86.avx512.mask.psubs.b.512
llvm.x86.avx512.mask.psubs.w.128
llvm.x86.avx512.mask.psubs.w.256
llvm.x86.avx512.mask.psubs.w.512
llvm.x86.avx512.mask.psubus.b.128
llvm.x86.avx512.mask.psubus.b.256
llvm.x86.avx512.mask.psubus.b.512
llvm.x86.avx512.mask.psubus.w.128
llvm.x86.avx512.mask.psubus.w.256
llvm.x86.avx512.mask.psubus.w.512
llvm.x86.avx512.mask.range.pd.128
llvm.x86.avx512.mask.range.pd.256
llvm.x86.avx512.mask.range.pd.512
llvm.x86.avx512.mask.range.ps.128
llvm.x86.avx512.mask.range.ps.256
llvm.x86.avx512.mask.range.ps.512
llvm.x86.avx512.mask.range.sd
llvm.x86.avx512.mask.range.ss
llvm.x86.avx512.mask.reduce.pd.128
llvm.x86.avx512.mask.reduce.pd.256
llvm.x86.avx512.mask.reduce.pd.512
llvm.x86.avx512.mask.reduce.ps.128
llvm.x86.avx512.mask.reduce.ps.256
llvm.x86.avx512.mask.reduce.ps.512
llvm.x86.avx512.mask.reduce.sd
llvm.x86.avx512.mask.reduce.ss
llvm.x86.avx512.mask.rndscale.pd.128
llvm.x86.avx512.mask.rndscale.pd.256
llvm.x86.avx512.mask.rndscale.pd.512
llvm.x86.avx512.mask.rndscale.ps.128
llvm.x86.avx512.mask.rndscale.ps.256
llvm.x86.avx512.mask.rndscale.ps.512
llvm.x86.avx512.mask.rndscale.sd
llvm.x86.avx512.mask.rndscale.ss
llvm.x86.avx512.mask.scalef.pd.128
llvm.x86.avx512.mask.scalef.pd.256
llvm.x86.avx512.mask.scalef.pd.512
llvm.x86.avx512.mask.scalef.ps.128
llvm.x86.avx512.mask.scalef.ps.256
llvm.x86.avx512.mask.scalef.ps.512
llvm.x86.avx512.mask.scalef.sd
llvm.x86.avx512.mask.scalef.ss
llvm.x86.avx512.mask.sqrt.sd
llvm.x86.avx512.mask.sqrt.ss
llvm.x86.avx512.mask.sub.sd.round
llvm.x86.avx512.mask.sub.ss.round
llvm.x86.avx512.mask.vcvtph2ps.128
llvm.x86.avx512.mask.vcvtph2ps.256
llvm.x86.avx512.mask.vcvtph2ps.512
llvm.x86.avx512.mask.vcvtps2ph.128
llvm.x86.avx512.mask.vcvtps2ph.256
llvm.x86.avx512.mask.vcvtps2ph.512
llvm.x86.avx512.mask.vpshldv.d.128
llvm.x86.avx512.mask.vpshldv.d.256
llvm.x86.avx512.mask.vpshldv.d.512
llvm.x86.avx512.mask.vpshldv.q.128
llvm.x86.avx512.mask.vpshldv.q.256
llvm.x86.avx512.mask.vpshldv.q.512
llvm.x86.avx512.mask.vpshldv.w.128
llvm.x86.avx512.mask.vpshldv.w.256
llvm.x86.avx512.mask.vpshldv.w.512
llvm.x86.avx512.mask.vpshrdv.d.128
llvm.x86.avx512.mask.vpshrdv.d.256
llvm.x86.avx512.mask.vpshrdv.d.512
llvm.x86.avx512.mask.vpshrdv.q.128
llvm.x86.avx512.mask.vpshrdv.q.256
llvm.x86.avx512.mask.vpshrdv.q.512
llvm.x86.avx512.mask.vpshrdv.w.128
llvm.x86.avx512.mask.vpshrdv.w.256
llvm.x86.avx512.mask.vpshrdv.w.512
llvm.x86.avx512.mask.vpshufbitqmb.128
llvm.x86.avx512.mask.vpshufbitqmb.256
llvm.x86.avx512.mask.vpshufbitqmb.512
llvm.x86.avx512.maskz.fixupimm.pd.128
llvm.x86.avx512.maskz.fixupimm.pd.256
llvm.x86.avx512.maskz.fixupimm.pd.512
llvm.x86.avx512.maskz.fixupimm.ps.128
llvm.x86.avx512.maskz.fixupimm.ps.256
llvm.x86.avx512.maskz.fixupimm.ps.512
llvm.x86.avx512.maskz.fixupimm.sd
llvm.x86.avx512.maskz.fixupimm.ss
llvm.x86.avx512.maskz.vpshldv.d.128
llvm.x86.avx512.maskz.vpshldv.d.256
llvm.x86.avx512.maskz.vpshldv.d.512
llvm.x86.avx512.maskz.vpshldv.q.128
llvm.x86.avx512.maskz.vpshldv.q.256
llvm.x86.avx512.maskz.vpshldv.q.512
llvm.x86.avx512.maskz.vpshldv.w.128
llvm.x86.avx512.maskz.vpshldv.w.256
llvm.x86.avx512.maskz.vpshldv.w.512
llvm.x86.avx512.maskz.vpshrdv.d.128
llvm.x86.avx512.maskz.vpshrdv.d.256
llvm.x86.avx512.maskz.vpshrdv.d.512
llvm.x86.avx512.maskz.vpshrdv.q.128
llvm.x86.avx512.maskz.vpshrdv.q.256
llvm.x86.avx512.maskz.vpshrdv.q.512
llvm.x86.avx512.maskz.vpshrdv.w.128
llvm.x86.avx512.maskz.vpshrdv.w.256
llvm.x86.avx512.maskz.vpshrdv.w.512
llvm.x86.avx512.max.pd.512
llvm.x86.avx512.max.ps.512
llvm.x86.avx512.min.pd.512
llvm.x86.avx512.min.ps.512
llvm.x86.avx512.mul.pd.512
llvm.x86.avx512.mul.ps.512
llvm.x86.avx512.packssdw.512
llvm.x86.avx512.packsswb.512
llvm.x86.avx512.packusdw.512
llvm.x86.avx512.packuswb.512
llvm.x86.avx512.permvar.df.256
llvm.x86.avx512.permvar.df.512
llvm.x86.avx512.permvar.di.256
llvm.x86.avx512.permvar.di.512
llvm.x86.avx512.permvar.hi.128
llvm.x86.avx512.permvar.hi.256
llvm.x86.avx512.permvar.hi.512
llvm.x86.avx512.permvar.qi.128
llvm.x86.avx512.permvar.qi.256
llvm.x86.avx512.permvar.qi.512
llvm.x86.avx512.permvar.sf.512
llvm.x86.avx512.permvar.si.512
llvm.x86.avx512.pmaddubs.w.512
llvm.x86.avx512.pmaddw.d.512
llvm.x86.avx512.pmul.hr.sw.512
llvm.x86.avx512.pmulh.w.512
llvm.x86.avx512.pmulhu.w.512
llvm.x86.avx512.prol.d.128
llvm.x86.avx512.prol.d.256
llvm.x86.avx512.prol.d.512
llvm.x86.avx512.prol.q.128
llvm.x86.avx512.prol.q.256
llvm.x86.avx512.prol.q.512
llvm.x86.avx512.prolv.d.128
llvm.x86.avx512.prolv.d.256
llvm.x86.avx512.prolv.d.512
llvm.x86.avx512.prolv.q.128
llvm.x86.avx512.prolv.q.256
llvm.x86.avx512.prolv.q.512
llvm.x86.avx512.pror.d.128
llvm.x86.avx512.pror.d.256
llvm.x86.avx512.pror.d.512
llvm.x86.avx512.pror.q.128
llvm.x86.avx512.pror.q.256
llvm.x86.avx512.pror.q.512
llvm.x86.avx512.prorv.d.128
llvm.x86.avx512.prorv.d.256
llvm.x86.avx512.prorv.d.512
llvm.x86.avx512.prorv.q.128
llvm.x86.avx512.prorv.q.256
llvm.x86.avx512.prorv.q.512
llvm.x86.avx512.psad.bw.512
llvm.x86.avx512.pshuf.b.512
llvm.x86.avx512.psll.d.512
llvm.x86.avx512.psll.q.512
llvm.x86.avx512.psll.w.512
llvm.x86.avx512.pslli.d.512
llvm.x86.avx512.pslli.q.512
llvm.x86.avx512.pslli.w.512
llvm.x86.avx512.psllv.d.512
llvm.x86.avx512.psllv.q.512
llvm.x86.avx512.psllv.w.128
llvm.x86.avx512.psllv.w.256
llvm.x86.avx512.psllv.w.512
llvm.x86.avx512.psra.d.512
llvm.x86.avx512.psra.q.128
llvm.x86.avx512.psra.q.256
llvm.x86.avx512.psra.q.512
llvm.x86.avx512.psra.w.512
llvm.x86.avx512.psrai.d.512
llvm.x86.avx512.psrai.q.128
llvm.x86.avx512.psrai.q.256
llvm.x86.avx512.psrai.q.512
llvm.x86.avx512.psrai.w.512
llvm.x86.avx512.psrav.d.512
llvm.x86.avx512.psrav.q.128
llvm.x86.avx512.psrav.q.256
llvm.x86.avx512.psrav.q.512
llvm.x86.avx512.psrav.w.128
llvm.x86.avx512.psrav.w.256
llvm.x86.avx512.psrav.w.512
llvm.x86.avx512.psrl.d.512
llvm.x86.avx512.psrl.q.512
llvm.x86.avx512.psrl.w.512
llvm.x86.avx512.psrli.d.512
llvm.x86.avx512.psrli.q.512
llvm.x86.avx512.psrli.w.512
llvm.x86.avx512.psrlv.d.512
llvm.x86.avx512.psrlv.q.512
llvm.x86.avx512.psrlv.w.128
llvm.x86.avx512.psrlv.w.256
llvm.x86.avx512.psrlv.w.512
llvm.x86.avx512.pternlog.d.128
llvm.x86.avx512.pternlog.d.256
llvm.x86.avx512.pternlog.d.512
llvm.x86.avx512.pternlog.q.128
llvm.x86.avx512.pternlog.q.256
llvm.x86.avx512.pternlog.q.512
llvm.x86.avx512.rcp14.pd.128
llvm.x86.avx512.rcp14.pd.256
llvm.x86.avx512.rcp14.pd.512
llvm.x86.avx512.rcp14.ps.128
llvm.x86.avx512.rcp14.ps.256
llvm.x86.avx512.rcp14.ps.512
llvm.x86.avx512.rcp14.sd
llvm.x86.avx512.rcp14.ss
llvm.x86.avx512.rcp28.pd
llvm.x86.avx512.rcp28.ps
llvm.x86.avx512.rcp28.sd
llvm.x86.avx512.rcp28.ss
llvm.x86.avx512.rsqrt14.pd.128
llvm.x86.avx512.rsqrt14.pd.256
llvm.x86.avx512.rsqrt14.pd.512
llvm.x86.avx512.rsqrt14.ps.128
llvm.x86.avx512.rsqrt14.ps.256
llvm.x86.avx512.rsqrt14.ps.512
llvm.x86.avx512.rsqrt14.sd
llvm.x86.avx512.rsqrt14.ss
llvm.x86.avx512.rsqrt28.pd
llvm.x86.avx512.rsqrt28.ps
llvm.x86.avx512.rsqrt28.sd
llvm.x86.avx512.rsqrt28.ss
llvm.x86.avx512.scatter.dpd.512
llvm.x86.avx512.scatter.dpi.512
llvm.x86.avx512.scatter.dpq.512
llvm.x86.avx512.scatter.dps.512
llvm.x86.avx512.scatter.qpd.512
llvm.x86.avx512.scatter.qpi.512
llvm.x86.avx512.scatter.qpq.512
llvm.x86.avx512.scatter.qps.512
llvm.x86.avx512.scatterdiv2.df
llvm.x86.avx512.scatterdiv2.di
llvm.x86.avx512.scatterdiv4.df
llvm.x86.avx512.scatterdiv4.di
llvm.x86.avx512.scatterdiv4.sf
llvm.x86.avx512.scatterdiv4.si
llvm.x86.avx512.scatterdiv8.sf
llvm.x86.avx512.scatterdiv8.si
llvm.x86.avx512.scatterpf.dpd.512
llvm.x86.avx512.scatterpf.dps.512
llvm.x86.avx512.scatterpf.qpd.512
llvm.x86.avx512.scatterpf.qps.512
llvm.x86.avx512.scattersiv2.df
llvm.x86.avx512.scattersiv2.di
llvm.x86.avx512.scattersiv4.df
llvm.x86.avx512.scattersiv4.di
llvm.x86.avx512.scattersiv4.sf
llvm.x86.avx512.scattersiv4.si
llvm.x86.avx512.scattersiv8.sf
llvm.x86.avx512.scattersiv8.si
llvm.x86.avx512.sqrt.pd.512
llvm.x86.avx512.sqrt.ps.512
llvm.x86.avx512.sub.pd.512
llvm.x86.avx512.sub.ps.512
llvm.x86.avx512.vcomi.sd
llvm.x86.avx512.vcomi.ss
llvm.x86.avx512.vcvtsd2si32
llvm.x86.avx512.vcvtsd2si64
llvm.x86.avx512.vcvtsd2usi32
llvm.x86.avx512.vcvtsd2usi64
llvm.x86.avx512.vcvtss2si32
llvm.x86.avx512.vcvtss2si64
llvm.x86.avx512.vcvtss2usi32
llvm.x86.avx512.vcvtss2usi64
llvm.x86.avx512.vfmadd.f32
llvm.x86.avx512.vfmadd.f64
llvm.x86.avx512.vfmadd.pd.512
llvm.x86.avx512.vfmadd.ps.512
llvm.x86.avx512.vfmaddsub.pd.512
llvm.x86.avx512.vfmaddsub.ps.512
llvm.x86.avx512.vpdpbusd.128
llvm.x86.avx512.vpdpbusd.256
llvm.x86.avx512.vpdpbusd.512
llvm.x86.avx512.vpdpbusds.128
llvm.x86.avx512.vpdpbusds.256
llvm.x86.avx512.vpdpbusds.512
llvm.x86.avx512.vpdpwssd.128
llvm.x86.avx512.vpdpwssd.256
llvm.x86.avx512.vpdpwssd.512
llvm.x86.avx512.vpdpwssds.128
llvm.x86.avx512.vpdpwssds.256
llvm.x86.avx512.vpdpwssds.512
llvm.x86.avx512.vpermi2var.d.128
llvm.x86.avx512.vpermi2var.d.256
llvm.x86.avx512.vpermi2var.d.512
llvm.x86.avx512.vpermi2var.hi.128
llvm.x86.avx512.vpermi2var.hi.256
llvm.x86.avx512.vpermi2var.hi.512
llvm.x86.avx512.vpermi2var.pd.128
llvm.x86.avx512.vpermi2var.pd.256
llvm.x86.avx512.vpermi2var.pd.512
llvm.x86.avx512.vpermi2var.ps.128
llvm.x86.avx512.vpermi2var.ps.256
llvm.x86.avx512.vpermi2var.ps.512
llvm.x86.avx512.vpermi2var.q.128
llvm.x86.avx512.vpermi2var.q.256
llvm.x86.avx512.vpermi2var.q.512
llvm.x86.avx512.vpermi2var.qi.128
llvm.x86.avx512.vpermi2var.qi.256
llvm.x86.avx512.vpermi2var.qi.512
llvm.x86.avx512.vpermilvar.pd.512
llvm.x86.avx512.vpermilvar.ps.512
llvm.x86.avx512.vpmadd52h.uq.128
llvm.x86.avx512.vpmadd52h.uq.256
llvm.x86.avx512.vpmadd52h.uq.512
llvm.x86.avx512.vpmadd52l.uq.128
llvm.x86.avx512.vpmadd52l.uq.256
llvm.x86.avx512.vpmadd52l.uq.512
llvm.x86.avx512.vpshld.d.128
llvm.x86.avx512.vpshld.d.256
llvm.x86.avx512.vpshld.d.512
llvm.x86.avx512.vpshld.q.128
llvm.x86.avx512.vpshld.q.256
llvm.x86.avx512.vpshld.q.512
llvm.x86.avx512.vpshld.w.128
llvm.x86.avx512.vpshld.w.256
llvm.x86.avx512.vpshld.w.512
llvm.x86.avx512.vpshrd.d.128
llvm.x86.avx512.vpshrd.d.256
llvm.x86.avx512.vpshrd.d.512
llvm.x86.avx512.vpshrd.q.128
llvm.x86.avx512.vpshrd.q.256
llvm.x86.avx512.vpshrd.q.512
llvm.x86.avx512.vpshrd.w.128
llvm.x86.avx512.vpshrd.w.256
llvm.x86.avx512.vpshrd.w.512
llvm.x86.bmi.bextr.32
llvm.x86.bmi.bextr.64
llvm.x86.bmi.bzhi.32
llvm.x86.bmi.bzhi.64
llvm.x86.bmi.pdep.32
llvm.x86.bmi.pdep.64
llvm.x86.bmi.pext.32
llvm.x86.bmi.pext.64
llvm.x86.cldemote
llvm.x86.clflushopt
llvm.x86.clrssbsy
llvm.x86.clwb
llvm.x86.clzero
llvm.x86.directstore32
llvm.x86.directstore64
llvm.x86.flags.read.u32
llvm.x86.flags.read.u64
llvm.x86.flags.write.u32
llvm.x86.flags.write.u64
llvm.x86.fxrstor
llvm.x86.fxrstor64
llvm.x86.fxsave
llvm.x86.fxsave64
llvm.x86.incsspd
llvm.x86.incsspq
llvm.x86.int
llvm.x86.invpcid
llvm.x86.llwpcb
llvm.x86.lwpins32
llvm.x86.lwpins64
llvm.x86.lwpval32
llvm.x86.lwpval64
llvm.x86.mmx.emms
llvm.x86.mmx.femms
llvm.x86.mmx.maskmovq
llvm.x86.mmx.movnt.dq
llvm.x86.mmx.packssdw
llvm.x86.mmx.packsswb
llvm.x86.mmx.packuswb
llvm.x86.mmx.padd.b
llvm.x86.mmx.padd.d
llvm.x86.mmx.padd.q
llvm.x86.mmx.padd.w
llvm.x86.mmx.padds.b
llvm.x86.mmx.padds.w
llvm.x86.mmx.paddus.b
llvm.x86.mmx.paddus.w
llvm.x86.mmx.palignr.b
llvm.x86.mmx.pand
llvm.x86.mmx.pandn
llvm.x86.mmx.pavg.b
llvm.x86.mmx.pavg.w
llvm.x86.mmx.pcmpeq.b
llvm.x86.mmx.pcmpeq.d
llvm.x86.mmx.pcmpeq.w
llvm.x86.mmx.pcmpgt.b
llvm.x86.mmx.pcmpgt.d
llvm.x86.mmx.pcmpgt.w
llvm.x86.mmx.pextr.w
llvm.x86.mmx.pinsr.w
llvm.x86.mmx.pmadd.wd
llvm.x86.mmx.pmaxs.w
llvm.x86.mmx.pmaxu.b
llvm.x86.mmx.pmins.w
llvm.x86.mmx.pminu.b
llvm.x86.mmx.pmovmskb
llvm.x86.mmx.pmulh.w
llvm.x86.mmx.pmulhu.w
llvm.x86.mmx.pmull.w
llvm.x86.mmx.pmulu.dq
llvm.x86.mmx.por
llvm.x86.mmx.psad.bw
llvm.x86.mmx.psll.d
llvm.x86.mmx.psll.q
llvm.x86.mmx.psll.w
llvm.x86.mmx.pslli.d
llvm.x86.mmx.pslli.q
llvm.x86.mmx.pslli.w
llvm.x86.mmx.psra.d
llvm.x86.mmx.psra.w
llvm.x86.mmx.psrai.d
llvm.x86.mmx.psrai.w
llvm.x86.mmx.psrl.d
llvm.x86.mmx.psrl.q
llvm.x86.mmx.psrl.w
llvm.x86.mmx.psrli.d
llvm.x86.mmx.psrli.q
llvm.x86.mmx.psrli.w
llvm.x86.mmx.psub.b
llvm.x86.mmx.psub.d
llvm.x86.mmx.psub.q
llvm.x86.mmx.psub.w
llvm.x86.mmx.psubs.b
llvm.x86.mmx.psubs.w
llvm.x86.mmx.psubus.b
llvm.x86.mmx.psubus.w
llvm.x86.mmx.punpckhbw
llvm.x86.mmx.punpckhdq
llvm.x86.mmx.punpckhwd
llvm.x86.mmx.punpcklbw
llvm.x86.mmx.punpckldq
llvm.x86.mmx.punpcklwd
llvm.x86.mmx.pxor
llvm.x86.monitorx
llvm.x86.movdir64b
llvm.x86.mwaitx
llvm.x86.pclmulqdq
llvm.x86.pclmulqdq.256
llvm.x86.pclmulqdq.512
llvm.x86.ptwrite32
llvm.x86.ptwrite64
llvm.x86.rdfsbase.32
llvm.x86.rdfsbase.64
llvm.x86.rdgsbase.32
llvm.x86.rdgsbase.64
llvm.x86.rdpid
llvm.x86.rdpkru
llvm.x86.rdpmc
llvm.x86.rdrand.16
llvm.x86.rdrand.32
llvm.x86.rdrand.64
llvm.x86.rdseed.16
llvm.x86.rdseed.32
llvm.x86.rdseed.64
llvm.x86.rdsspd
llvm.x86.rdsspq
llvm.x86.rdtsc
llvm.x86.rdtscp
llvm.x86.rstorssp
llvm.x86.saveprevssp
llvm.x86.seh.ehguard
llvm.x86.seh.ehregnode
llvm.x86.seh.lsda
llvm.x86.seh.recoverfp
llvm.x86.setssbsy
llvm.x86.sha1msg1
llvm.x86.sha1msg2
llvm.x86.sha1nexte
llvm.x86.sha1rnds4
llvm.x86.sha256msg1
llvm.x86.sha256msg2
llvm.x86.sha256rnds2
llvm.x86.slwpcb
llvm.x86.sse.cmp.ps
llvm.x86.sse.cmp.ss
llvm.x86.sse.comieq.ss
llvm.x86.sse.comige.ss
llvm.x86.sse.comigt.ss
llvm.x86.sse.comile.ss
llvm.x86.sse.comilt.ss
llvm.x86.sse.comineq.ss
llvm.x86.sse.cvtpd2pi
llvm.x86.sse.cvtpi2pd
llvm.x86.sse.cvtpi2ps
llvm.x86.sse.cvtps2pi
llvm.x86.sse.cvtss2si
llvm.x86.sse.cvtss2si64
llvm.x86.sse.cvttpd2pi
llvm.x86.sse.cvttps2pi
llvm.x86.sse.cvttss2si
llvm.x86.sse.cvttss2si64
llvm.x86.sse.ldmxcsr
llvm.x86.sse.max.ps
llvm.x86.sse.max.ss
llvm.x86.sse.min.ps
llvm.x86.sse.min.ss
llvm.x86.sse.movmsk.ps
llvm.x86.sse.pshuf.w
llvm.x86.sse.rcp.ps
llvm.x86.sse.rcp.ss
llvm.x86.sse.rsqrt.ps
llvm.x86.sse.rsqrt.ss
llvm.x86.sse.sfence
llvm.x86.sse.stmxcsr
llvm.x86.sse.ucomieq.ss
llvm.x86.sse.ucomige.ss
llvm.x86.sse.ucomigt.ss
llvm.x86.sse.ucomile.ss
llvm.x86.sse.ucomilt.ss
llvm.x86.sse.ucomineq.ss
llvm.x86.sse2.clflush
llvm.x86.sse2.cmp.pd
llvm.x86.sse2.cmp.sd
llvm.x86.sse2.comieq.sd
llvm.x86.sse2.comige.sd
llvm.x86.sse2.comigt.sd
llvm.x86.sse2.comile.sd
llvm.x86.sse2.comilt.sd
llvm.x86.sse2.comineq.sd
llvm.x86.sse2.cvtpd2dq
llvm.x86.sse2.cvtpd2ps
llvm.x86.sse2.cvtps2dq
llvm.x86.sse2.cvtsd2si
llvm.x86.sse2.cvtsd2si64
llvm.x86.sse2.cvtsd2ss
llvm.x86.sse2.cvttpd2dq
llvm.x86.sse2.cvttps2dq
llvm.x86.sse2.cvttsd2si
llvm.x86.sse2.cvttsd2si64
llvm.x86.sse2.lfence
llvm.x86.sse2.maskmov.dqu
llvm.x86.sse2.max.pd
llvm.x86.sse2.max.sd
llvm.x86.sse2.mfence
llvm.x86.sse2.min.pd
llvm.x86.sse2.min.sd
llvm.x86.sse2.movmsk.pd
llvm.x86.sse2.packssdw.128
llvm.x86.sse2.packsswb.128
llvm.x86.sse2.packuswb.128
llvm.x86.sse2.padds.b
llvm.x86.sse2.padds.w
llvm.x86.sse2.paddus.b
llvm.x86.sse2.paddus.w
llvm.x86.sse2.pause
llvm.x86.sse2.pmadd.wd
llvm.x86.sse2.pmovmskb.128
llvm.x86.sse2.pmulh.w
llvm.x86.sse2.pmulhu.w
llvm.x86.sse2.psad.bw
llvm.x86.sse2.psll.d
llvm.x86.sse2.psll.q
llvm.x86.sse2.psll.w
llvm.x86.sse2.pslli.d
llvm.x86.sse2.pslli.q
llvm.x86.sse2.pslli.w
llvm.x86.sse2.psra.d
llvm.x86.sse2.psra.w
llvm.x86.sse2.psrai.d
llvm.x86.sse2.psrai.w
llvm.x86.sse2.psrl.d
llvm.x86.sse2.psrl.q
llvm.x86.sse2.psrl.w
llvm.x86.sse2.psrli.d
llvm.x86.sse2.psrli.q
llvm.x86.sse2.psrli.w
llvm.x86.sse2.psubs.b
llvm.x86.sse2.psubs.w
llvm.x86.sse2.psubus.b
llvm.x86.sse2.psubus.w
llvm.x86.sse2.ucomieq.sd
llvm.x86.sse2.ucomige.sd
llvm.x86.sse2.ucomigt.sd
llvm.x86.sse2.ucomile.sd
llvm.x86.sse2.ucomilt.sd
llvm.x86.sse2.ucomineq.sd
llvm.x86.sse3.addsub.pd
llvm.x86.sse3.addsub.ps
llvm.x86.sse3.hadd.pd
llvm.x86.sse3.hadd.ps
llvm.x86.sse3.hsub.pd
llvm.x86.sse3.hsub.ps
llvm.x86.sse3.ldu.dq
llvm.x86.sse3.monitor
llvm.x86.sse3.mwait
llvm.x86.sse41.blendvpd
llvm.x86.sse41.blendvps
llvm.x86.sse41.dppd
llvm.x86.sse41.dpps
llvm.x86.sse41.insertps
llvm.x86.sse41.mpsadbw
llvm.x86.sse41.packusdw
llvm.x86.sse41.pblendvb
llvm.x86.sse41.phminposuw
llvm.x86.sse41.ptestc
llvm.x86.sse41.ptestnzc
llvm.x86.sse41.ptestz
llvm.x86.sse41.round.pd
llvm.x86.sse41.round.ps
llvm.x86.sse41.round.sd
llvm.x86.sse41.round.ss
llvm.x86.sse42.crc32.32.16
llvm.x86.sse42.crc32.32.32
llvm.x86.sse42.crc32.32.8
llvm.x86.sse42.crc32.64.64
llvm.x86.sse42.pcmpestri128
llvm.x86.sse42.pcmpestria128
llvm.x86.sse42.pcmpestric128
llvm.x86.sse42.pcmpestrio128
llvm.x86.sse42.pcmpestris128
llvm.x86.sse42.pcmpestriz128
llvm.x86.sse42.pcmpestrm128
llvm.x86.sse42.pcmpistri128
llvm.x86.sse42.pcmpistria128
llvm.x86.sse42.pcmpistric128
llvm.x86.sse42.pcmpistrio128
llvm.x86.sse42.pcmpistris128
llvm.x86.sse42.pcmpistriz128
llvm.x86.sse42.pcmpistrm128
llvm.x86.sse4a.extrq
llvm.x86.sse4a.extrqi
llvm.x86.sse4a.insertq
llvm.x86.sse4a.insertqi
llvm.x86.ssse3.pabs.b
llvm.x86.ssse3.pabs.d
llvm.x86.ssse3.pabs.w
llvm.x86.ssse3.phadd.d
llvm.x86.ssse3.phadd.d.128
llvm.x86.ssse3.phadd.sw
llvm.x86.ssse3.phadd.sw.128
llvm.x86.ssse3.phadd.w
llvm.x86.ssse3.phadd.w.128
llvm.x86.ssse3.phsub.d
llvm.x86.ssse3.phsub.d.128
llvm.x86.ssse3.phsub.sw
llvm.x86.ssse3.phsub.sw.128
llvm.x86.ssse3.phsub.w
llvm.x86.ssse3.phsub.w.128
llvm.x86.ssse3.pmadd.ub.sw
llvm.x86.ssse3.pmadd.ub.sw.128
llvm.x86.ssse3.pmul.hr.sw
llvm.x86.ssse3.pmul.hr.sw.128
llvm.x86.ssse3.pshuf.b
llvm.x86.ssse3.pshuf.b.128
llvm.x86.ssse3.psign.b
llvm.x86.ssse3.psign.b.128
llvm.x86.ssse3.psign.d
llvm.x86.ssse3.psign.d.128
llvm.x86.ssse3.psign.w
llvm.x86.ssse3.psign.w.128
llvm.x86.subborrow.u32
llvm.x86.subborrow.u64
llvm.x86.tbm.bextri.u32
llvm.x86.tbm.bextri.u64
llvm.x86.tpause
llvm.x86.umonitor
llvm.x86.umwait
llvm.x86.vcvtph2ps.128
llvm.x86.vcvtph2ps.256
llvm.x86.vcvtps2ph.128
llvm.x86.vcvtps2ph.256
llvm.x86.vgf2p8affineinvqb.128
llvm.x86.vgf2p8affineinvqb.256
llvm.x86.vgf2p8affineinvqb.512
llvm.x86.vgf2p8affineqb.128
llvm.x86.vgf2p8affineqb.256
llvm.x86.vgf2p8affineqb.512
llvm.x86.vgf2p8mulb.128
llvm.x86.vgf2p8mulb.256
llvm.x86.vgf2p8mulb.512
llvm.x86.wbinvd
llvm.x86.wbnoinvd
llvm.x86.wrfsbase.32
llvm.x86.wrfsbase.64
llvm.x86.wrgsbase.32
llvm.x86.wrgsbase.64
llvm.x86.wrpkru
llvm.x86.wrssd
llvm.x86.wrssq
llvm.x86.wrussd
llvm.x86.wrussq
llvm.x86.xabort
llvm.x86.xbegin
llvm.x86.xend
llvm.x86.xgetbv
llvm.x86.xop.vfrcz.pd
llvm.x86.xop.vfrcz.pd.256
llvm.x86.xop.vfrcz.ps
llvm.x86.xop.vfrcz.ps.256
llvm.x86.xop.vfrcz.sd
llvm.x86.xop.vfrcz.ss
llvm.x86.xop.vpcomb
llvm.x86.xop.vpcomd
llvm.x86.xop.vpcomq
llvm.x86.xop.vpcomub
llvm.x86.xop.vpcomud
llvm.x86.xop.vpcomuq
llvm.x86.xop.vpcomuw
llvm.x86.xop.vpcomw
llvm.x86.xop.vpermil2pd
llvm.x86.xop.vpermil2pd.256
llvm.x86.xop.vpermil2ps
llvm.x86.xop.vpermil2ps.256
llvm.x86.xop.vphaddbd
llvm.x86.xop.vphaddbq
llvm.x86.xop.vphaddbw
llvm.x86.xop.vphadddq
llvm.x86.xop.vphaddubd
llvm.x86.xop.vphaddubq
llvm.x86.xop.vphaddubw
llvm.x86.xop.vphaddudq
llvm.x86.xop.vphadduwd
llvm.x86.xop.vphadduwq
llvm.x86.xop.vphaddwd
llvm.x86.xop.vphaddwq
llvm.x86.xop.vphsubbw
llvm.x86.xop.vphsubdq
llvm.x86.xop.vphsubwd
llvm.x86.xop.vpmacsdd
llvm.x86.xop.vpmacsdqh
llvm.x86.xop.vpmacsdql
llvm.x86.xop.vpmacssdd
llvm.x86.xop.vpmacssdqh
llvm.x86.xop.vpmacssdql
llvm.x86.xop.vpmacsswd
llvm.x86.xop.vpmacssww
llvm.x86.xop.vpmacswd
llvm.x86.xop.vpmacsww
llvm.x86.xop.vpmadcsswd
llvm.x86.xop.vpmadcswd
llvm.x86.xop.vpperm
llvm.x86.xop.vprotb
llvm.x86.xop.vprotbi
llvm.x86.xop.vprotd
llvm.x86.xop.vprotdi
llvm.x86.xop.vprotq
llvm.x86.xop.vprotqi
llvm.x86.xop.vprotw
llvm.x86.xop.vprotwi
llvm.x86.xop.vpshab
llvm.x86.xop.vpshad
llvm.x86.xop.vpshaq
llvm.x86.xop.vpshaw
llvm.x86.xop.vpshlb
llvm.x86.xop.vpshld
llvm.x86.xop.vpshlq
llvm.x86.xop.vpshlw
llvm.x86.xrstor
llvm.x86.xrstor64
llvm.x86.xrstors
llvm.x86.xrstors64
llvm.x86.xsave
llvm.x86.xsave64
llvm.x86.xsavec
llvm.x86.xsavec64
llvm.x86.xsaveopt
llvm.x86.xsaveopt64
llvm.x86.xsaves
llvm.x86.xsaves64
llvm.x86.xsetbv
llvm.x86.xtest
llvm.xcore.bitrev
llvm.xcore.checkevent
llvm.xcore.chkct
llvm.xcore.clre
llvm.xcore.clrpt
llvm.xcore.clrsr
llvm.xcore.crc32
llvm.xcore.crc8
llvm.xcore.edu
llvm.xcore.eeu
llvm.xcore.endin
llvm.xcore.freer
llvm.xcore.geted
llvm.xcore.getet
llvm.xcore.getid
llvm.xcore.getps
llvm.xcore.getr
llvm.xcore.getst
llvm.xcore.getts
llvm.xcore.in
llvm.xcore.inct
llvm.xcore.initcp
llvm.xcore.initdp
llvm.xcore.initlr
llvm.xcore.initpc
llvm.xcore.initsp
llvm.xcore.inshr
llvm.xcore.int
llvm.xcore.mjoin
llvm.xcore.msync
llvm.xcore.out
llvm.xcore.outct
llvm.xcore.outshr
llvm.xcore.outt
llvm.xcore.peek
llvm.xcore.setc
llvm.xcore.setclk
llvm.xcore.setd
llvm.xcore.setev
llvm.xcore.setps
llvm.xcore.setpsc
llvm.xcore.setpt
llvm.xcore.setrdy
llvm.xcore.setsr
llvm.xcore.settw
llvm.xcore.setv
llvm.xcore.sext
llvm.xcore.ssync
llvm.xcore.syncr
llvm.xcore.testct
llvm.xcore.testwct
llvm.xcore.waitevent
llvm.xcore.zext
<unknown>:
 (function: 
Print Module IR
Print Function IR
Print BasicBlock IR
switch
indirectbr
invoke
resume
unreachable
cleanupret
catchret
catchpad
catchswitch
fadd
fsub
fmul
udiv
sdiv
fdiv
urem
srem
frem
alloca
load
store
cmpxchg
atomicrmw
fence
getelementptr
trunc
zext
sext
fptrunc
fpext
fptoui
fptosi
uitofp
sitofp
inttoptr
ptrtoint
bitcast
addrspacecast
icmp
fcmp
select
call
lshr
ashr
va_arg
extractelement
insertelement
shufflevector
extractvalue
insertvalue
landingpad
cleanuppad
<Invalid operator> 
both values to select must have same type
select values cannot have token type
vector select condition element type must be i1
selected values for vector select must be vectors
vector select requires selected vectors to have the same vector length as select condition
select condition must be i1 or <n x i1>
unknown
false
true
mallocsize
malloccall
prof
fpmath
range
tbaa.struct
alias.scope
make.implicit
unpredictable
invariant.group
section_prefix
absolute_symbol
associated
irr_loop
gc-transition
singlethread
error
warning
remark
Allocation failed
debug-pass
Print PassManager debugging information
disable debug output
Arguments
print pass arguments to pass to 'opt'
Structure
print pass structure before run()
Executions
print pass name before it is executed
Details
print pass details when it is executed
print-before
Print IR before specified passes
print-after
Print IR after specified passes
print-before-all
Print IR before each pass
print-after-all
Print IR after each pass
print-module-scope
When printing IR for print-[before|after]{-all} always print a module IR
filter-print-funcs
function names
Only print IR for functions whose name match this for all print-[before|after][-all] options
IRSizeChange
: IR instruction count changed from 
IRInstrsBefore
IRInstrsAfter
; Delta: 
Releasing pass '
Running pass '
 on module '
basic block
Pass '
' is not initialized.
Verify if there is a pass dependency cycle.
Required Passes:
Error: Required pass not found! Possible causes:
- Pass misconfiguration (e.g.: missing macros)
- Corruption of the global PassRegistry
*** IR Dump Before 
 ***
*** IR Dump After 
Pass Arguments: 
 -- '
' is not preserving '
 -*- '
' is the last user of following pass instances.
 Free these instances
Executing Pass '
Made Modification '
 Freeing Pass '
' on BasicBlock '
'...
' on Function '
' on Module '
' on Region '
' on Loop '
' on Call Graph Nodes '
Required
Preserved
Used
 Analyses:
 Uninitialized Pass
FunctionPass Manager
time-passes
Time each pass, printing elapsed time for each on exit
Module Pass Manager
ModulePass Manager
pass
... Pass execution timing report ...
BasicBlock Pass Manager
BasicBlockPass Manager
Function Pass Manager
branch_weights
synthetic_function_entry_count
function_entry_count
__unnamed_
 /EXPORT:
 -export:
,DATA
,data
llvm.module.flags
ProfileSummary
RtLibUseGOT
Allocation failed
SCC (
 node
External
 (has loop)
opt-bisect-limit
Maximum optimization to perform
module (
function (
basic block (
) in function (
<<null function>>
NOT 
BISECT: 
running pass 
Unnamed pass: implement Pass::getPassName()
Pass::print not implemented for pass: '
Two passes with the same argument (-
) attempted to be registered!
safepoint-ir-verifier-print-only
NumCounts
NumFunctions
Allocation failed
non-global-value-max-name-size
Maximum size for the name of non-global values.
Allocation failed
Base nodes must have at least two operands
Access tag nodes must have the number of operands that is a multiple of 3!
Struct tag nodes must have an odd number of operands!
Type size nodes must be constants!
Struct tag nodes have a string as their first operand
Incorrect field entry in struct type node!
Offset entries must be constants!
Bitwidth between the offsets and struct type entries must match
Offsets must be increasing!
Member size entries must be constants!
Could not find TBAA parent in struct type node
This instruction shall not have a TBAA access tag!
Old-style TBAA is no longer allowed, use struct-path TBAA instead
Access tag metadata must have either 4 or 5 operands
Struct tag metadata must have either 3 or 4 operands
Access size field must be a constant
Immutability tag on struct tag metadata must be a constant
Immutability part of the struct tag metadata must be either 0 or 1
Malformed struct tag metadata: base and access-type should be non-null and point to Metadata nodes
Access type node must be a valid scalar type
Offset must be constant integer
Cycle detected in struct path
Offset not zero at the point of scalar access
Access bit-width not the same as description bit-width
Did not see access type in access path!
Basic Block in function '
' does not have terminator!
Function context does not match Module context!
Functions may not have common linkage
# formal arguments must match # of arguments for function type!
Functions cannot return aggregate values!
Invalid struct return type!
Attribute after last parameter!
Attribute 'builtin' can only be applied to a callsite.
Calling convention requires void return type
Calling convention does not allow sret
Calling convention does not support varargs or perfect forwarding!
Argument value does not match function argument type!
Function arguments must have first-class types!
Function takes metadata but isn't an intrinsic
Function takes token but isn't an intrinsic
Functions returns a token but isn't an intrinsic
Referencing personality function in another module!
unmaterialized function cannot have metadata
function declaration may not have a !dbg attachment
function declaration may not have a !prof attachment
Function declaration shouldn't have a personality routine
llvm intrinsics cannot be defined!
Entry block to function must not have predecessors!
blockaddress may not be used with the entry block!
function must have a single !dbg attachment
function !dbg attachment must be a subprogram
DISubprogram attached to more than one function
function must have a single !prof attachment
Invalid user of intrinsic instruction!
!dbg attachment points at wrong subprogram for function
Global is external, but doesn't have external or weak linkage!
huge alignment values are unsupported
Only global variables can have appending linkage!
Only global arrays can have appending linkage!
Declaration may not be in a Comdat!
GlobalValue with DLLImport Storage is dso_local!
Global is marked as dllimport, but not external
GlobalValue with private or internal linkage must be dso_local!
GlobalValue with non default visibility must be dso_local!
Global is referenced by parentless instruction!
Global is referenced in a different module!
Global is used by function in a different module
Attributes 'byval', 'inalloca', 'nest', 'sret', 'nocapture', 'returned', 'swiftself', and 'swifterror' do not apply to return values!
Attribute '
' does not apply to function returns
More than one parameter has attribute nest!
More than one parameter has attribute returned!
Incompatible argument and return types for 'returned' attribute
Cannot have multiple 'sret' parameters!
Attribute 'sret' is not on first or second parameter!
Cannot have multiple 'swiftself' parameters!
Cannot have multiple 'swifterror' parameters!
inalloca isn't on the last parameter!
Attributes 'readnone and readonly' are incompatible!
Attributes 'readnone and writeonly' are incompatible!
Attributes 'readonly and writeonly' are incompatible!
Attributes 'readnone and inaccessiblemem_or_argmemonly' are incompatible!
Attributes 'readnone and inaccessiblememonly' are incompatible!
Attributes 'noinline and alwaysinline' are incompatible!
Attribute 'optnone' requires 'noinline'!
Attributes 'optsize and optnone' are incompatible!
Attributes 'minsize and optnone' are incompatible!
Attribute 'jumptable' requires 'unnamed_addr'
element size
number of elements
Attributes 'byval', 'inalloca', 'inreg', 'nest', and 'sret' are incompatible!
Attributes 'inalloca and readonly' are incompatible!
Attributes 'sret and returned' are incompatible!
Attributes 'zeroext and signext' are incompatible!
Wrong types for attribute: 
Attributes 'byval' and 'inalloca' do not support unsized types!
Attribute 'swifterror' only applies to parameters with pointer to pointer type!
Attribute 'byval' only applies to parameters with pointer type!
Attribute 'swifterror' only applies to parameters with pointer type!
' only applies to functions!
' does not apply to functions!
'allocsize' 
 argument is out of bounds
 argument must refer to an integer parameter
swifterror value can only be loaded and stored from, or as a swifterror argument!
swifterror value should be the second operand when used by stores
swifterror value when used in a callsite should be marked with swifterror attribute
!prof annotations should have no less than 2 operands
first operand should not be null
expected string with name of the !prof annotation
first operand should be 'function_entry_count' or 'synthetic_function_entry_count'
second operand should not be null
expected integer argument to function_entry_count
Invalid operand for global metadata!
Expected no forward declarations!
All nodes should be resolved!
location requires a valid scope
inlined-at should be a location
scope points into the type hierarchy
invalid expression
missing variable
fragment is larger than or outside of variable
fragment covers entire variable
invalid tag
Count must either be a signed constant or a DIVariable
invalid subrange count
invalid pointer to member type
invalid scope
invalid base type
DWARF address space only applies to pointer or reference types
invalid file
invalid composite elements
invalid vtable holder
invalid reference flags
invalid vector, expected one element of type subrange
class/union requires a filename
discriminator can only appear on variant part
invalid template params
invalid template parameter
invalid subroutine type ref
invalid checksum length
invalid checksum
compile units must be distinct
invalid filename
invalid enum list
invalid enum type
invalid retained type list
invalid retained type
invalid global variable list
invalid global variable ref
invalid imported entity list
invalid imported entity ref
invalid macro list
invalid macro ref
line specified with no file
invalid subroutine type
invalid containing type
invalid subprogram declaration
invalid retained nodes list
invalid retained nodes, expected DILocalVariable or DILabel
subprogram definitions must be distinct
subprogram definitions must have a compile unit
invalid unit type
subprogram declarations must not have a compile unit
invalid thrown types list
invalid thrown type
cannot have column info without line info
invalid local scope
invalid scope ref
anonymous module
invalid type ref
missing global variable name
missing global variable type
invalid static data member declaration
local variable requires a valid scope
label requires a valid scope
invalid scope for imported entity
invalid imported entity
invalid macinfo type
anonymous macro
Expected valid value
Unexpected metadata round-trip through values
function-local metadata used outside a function
function-local metadata not in basic block
function-local metadata used in wrong function
Basic Block does not have terminator!
PHI nodes must have at least one entry.  If the block is dead, the PHI should be removed!
PHINode should have one entry for each predecessor of its parent basic block!
PHI node has multiple entries for the same basic block with different incoming values!
PHI node entries do not match predecessors!
Instruction has bogus parent pointer!
Operand is null
Found return instr that returns non-void in Function of void return type!
Function return type does not match operand type of return inst!
Terminator found in the middle of a basic block!
Instruction not embedded in basic block!
Only PHI nodes may reference their own value!
Instruction has a name, but provides a void value!
Instruction returns a non-scalar type!
Invalid use of metadata!
Instruction referencing instruction not embedded in a basic block!
Use of instruction is not an instruction!
Instruction has null operand!
Instruction operands must be first-class values!
Cannot take the address of an intrinsic!
Cannot invoke an intrinsic other than donothing, patchpoint, statepoint, coro_resume or coro_destroy
Referencing function in another module!
Referring to a basic block in another function!
Referring to an argument in another function!
Referencing global in another module!
Cannot take the address of an inline asm!
fpmath requires a floating point result!
fpmath takes one operand!
fpmath accuracy must have float type
fpmath accuracy not a positive number!
invalid fpmath accuracy!
Ranges are only for loads, calls and invokes!
nonnull applies only to pointer types
nonnull applies only to load instructions, use attributes for calls or invokes
align applies only to pointer types
align applies only to load instructions, use attributes for calls or invokes
align takes one operand!
align metadata value must be an i64!
align metadata value must be a power of 2!
alignment is larger that implementation defined limit
invalid !dbg metadata attachment
Instruction does not dominate all uses!
Invalid bitcast
inttoptr not supported for non-integral pointers
ptrtoint not supported for non-integral pointers
Unfinished range!
It should have at least one range!
The lower limit must be an integer!
The upper limit must be an integer!
Range types must match instruction type!
Range must not be empty!
Intervals are overlapping
Intervals are not in order
Intervals are contiguous
dereferenceable, dereferenceable_or_null apply only to pointer types
dereferenceable, dereferenceable_or_null apply only to load instructions, use attributes for calls or invokes
dereferenceable, dereferenceable_or_null take one operand!
dereferenceable, dereferenceable_or_null metadata value must be an i64!
Branch condition is not 'i1' type!
Switch constants must all be same type as switch value!
Duplicate integer as switch case
Indirectbr operand must have pointer type!
Indirectbr destinations must all have pointer type!
The unwind destination does not have an exception handling instruction!
Called function must be a pointer!
Called function is not pointer to function type!
Called function is not the same type as the call!
Called function requires more parameters than were provided!
Incorrect number of arguments passed to called function!
Call parameter type does not match function signature!
speculatable attribute may not apply to call sites
inalloca argument for call has mismatched alloca
swifterror argument for call has mismatched alloca
swifterror argument should come from an alloca or parameter
swifterror argument for call has mismatched parameter
Attribute 'sret' cannot be used for vararg call arguments!
inalloca isn't on the last argument!
Function has metadata parameter but isn't an intrinsic
Function has token parameter but isn't an intrinsic
Return type cannot be token for indirect call!
Multiple deopt operand bundles
Multiple gc-transition operand bundles
Multiple funclet operand bundles
Expected exactly one funclet bundle operand
Funclet bundle operands should correspond to a FuncletPadInst
inlinable function call in a function with debug info must have a !dbg location
Intrinsic functions should never be defined!
Intrinsic has incorrect return type!
Intrinsic has incorrect argument type!
Intrinsic was not defined with variable arguments!
Callsite was not defined with variable arguments!
Intrinsic name not mangled correctly for type arguments! Should be: 
info argument of llvm.coro.begin must refer to an initialized constant
info argument of llvm.coro.begin must refer to either a struct or an array
is_zero_undef argument of bit counting intrinsics must be a constant int
invalid llvm.dbg.declare intrinsic call 1
addr
alignment of arg 0 of memory intrinsic must be 0 or a power of 2
alignment of arg 1 of memory intrinsic must be 0 or a power of 2
isvolatile argument of memory intrinsics must be a constant int
element size of the element-wise unordered atomic memory intrinsic must be a constant int
element size of the element-wise atomic memory intrinsic must be a power of 2
constant length must be a multiple of the element size in the element-wise atomic memory intrinsic
incorrect alignment of the destination argument
incorrect alignment of the source argument
llvm.gcroot parameter #1 must be an alloca.
llvm.gcroot parameter #2 must be a constant.
llvm.gcroot parameter #1 must either be a pointer alloca, or argument #2 must be a non-null constant.
Enclosing function does not use GC.
llvm.init_trampoline parameter #2 must resolve to a function.
invalid arguments to llvm.prefetch
llvm.stackprotector parameter #2 must resolve to an alloca.
size argument of memory use markers must be a constant integer
llvm.invariant.end parameter #2 must be a constant integer
llvm.localescape used outside of entry block
multiple calls to llvm.localescape in one function
llvm.localescape only accepts static allocas
llvm.localrecover first argument must be function defined in this module
idx argument of llvm.localrecover must be a constant int
gc.statepoint support for inline assembly unimplemented
gc.result operand #1 must be from a statepoint
gc.result result type does not match wrapped callee
wrong number of arguments
gc.relocate must return a pointer or a vector of pointers
safepoints should have unique landingpads
safepoint block should be well formed
gc relocate should be linked to a statepoint
gc relocate is incorrectly tied to the statepoint
gc.relocate operand #2 must be integer offset
gc.relocate operand #3 must be integer offset
gc.relocate: statepoint base index out of bounds
gc.relocate: statepoint derived index out of bounds
gc.statepoint: insufficient arguments
gc.statement: number of call arguments must be constant integer
gc.statepoint: mismatch in number of call arguments
gc.statepoint: number of transition arguments must be a constant integer
gc.statepoint: number of deoptimization arguments must be a constant integer
gc.relocate: statepoint base index doesn't fall within the 'gc parameters' section of the statepoint call
gc.relocate: statepoint derived index doesn't fall within the 'gc parameters' section of the statepoint call
gc.relocate: relocated value must be a gc pointer
gc.relocate: vector relocates to vector and pointer to pointer
gc.relocate: relocating a pointer shouldn't change its address space
eh.exceptionpointer argument must be a catchpad
masked_load: must return a vector
masked_load: mask must be vector
masked_load: return must match pointer type
masked_load: pass through and data type must match
masked_load: vector mask must be same length as data
masked_store: mask must be vector
masked_store: storee must match pointer type
masked_store: vector mask must be same length as data
experimental_guard cannot be invoked
experimental_guard must have exactly one "deopt" operand bundle
experimental_deoptimize cannot be invoked
experimental_deoptimize must have exactly one "deopt" operand bundle
experimental_deoptimize return type must match caller return type
calls to experimental_deoptimize must be followed by a return
calls to experimental_deoptimize must be followed by a return of the value computed by experimental_deoptimize
invalid arguments for constrained FP intrinsic
invalid exception behavior argument
invalid rounding mode argument
invalid llvm.dbg.
 intrinsic address/value
 intrinsic variable
 intrinsic expression
llvm.dbg.
 intrinsic requires a !dbg attachment
mismatched subprogram between llvm.dbg.
 variable and !dbg attachment
dbg intrinsic without variable
conflicting debug info for argument
 label and !dbg attachment
gc.statepoint must read and write all memory to preserve reordering restrictions required by safepoint semantics
gc.statepoint ID must be a constant integer
gc.statepoint number of patchable bytes must be a constant integer
gc.statepoint number of patchable bytes must be positive
gc.statepoint callee must be of function pointer type
gc.statepoint number of arguments to underlying call must be constant integer
gc.statepoint number of arguments to underlying call must be positive
gc.statepoint mismatch in number of vararg call args
gc.statepoint doesn't support wrapping non-void vararg functions yet
gc.statepoint mismatch in number of call args
gc.statepoint flags must be constant integer
unknown flag used in gc.statepoint flags argument
gc.statepoint call argument does not match wrapped function type
gc.statepoint number of transition arguments must be constant integer
gc.statepoint number of transition arguments must be positive
gc.statepoint number of deoptimization arguments must be constant integer
gc.statepoint number of deoptimization arguments must be positive
gc.statepoint too few arguments according to length fields
illegal use of statepoint token
gc.result or gc.relocate are the only value uses of a gc.statepoint
gc.result connected to wrong gc.statepoint
gc.relocate connected to wrong gc.statepoint
ResumeInst needs to be in a function with a personality.
The resume instruction should have a consistent result type inside a function.
CleanupReturnInst needs to be provided a CleanupPad
CleanupReturnInst must unwind to an EH block which is not a landingpad.
CatchReturnInst needs to be provided a CatchPad
CatchSwitchInst needs to be in a function with a personality.
CatchSwitchInst not the first non-PHI instruction in the block.
CatchSwitchInst has an invalid parent.
CatchSwitchInst must unwind to an EH block which is not a landingpad.
CatchSwitchInst cannot have empty handler list
CatchSwitchInst handlers must be catchpads
EH pad cannot be in entry block.
Block containing LandingPadInst must be jumped to only by the unwind edge of an invoke.
Block containg CatchPadInst must be jumped to only by its catchswitch.
Catchswitch cannot unwind to one of its catchpads
EH pad must be jumped to via an unwind edge
A cleanupret must exit its cleanup
EH pad cannot handle exceptions raised within it
A single unwind edge may only enter one EH pad
EH pad jumps through a cycle of pads
Both operands to a binary operator are not of the same type!
Integer arithmetic operators only work with integral types!
Integer arithmetic operators must have same type for operands and result!
Floating-point arithmetic operators only work with floating-point types!
Floating-point arithmetic operators must have same type for operands and result!
Logical operators only work with integral types!
Logical operators must have same type for operands and result!
Shifts only work with integral types!
Shift return type must be same as operands!
Allocation instruction pointer not in the stack address space!
Cannot allocate unsized type
Alloca array size must have integer type
Load operand must be a pointer.
loading unsized types is not allowed
Load cannot have Release ordering
Atomic load must specify explicit alignment
atomic load operand must have integer, pointer, or floating point type!
Non-atomic load cannot have SynchronizationScope specified
atomic memory access' size must be byte-sized
atomic memory access' operand must have a power-of-two size
Store operand must be a pointer.
Stored value type does not match pointer operand type!
storing unsized types is not allowed
Store cannot have Acquire ordering
Atomic store must specify explicit alignment
atomic store operand must have integer, pointer, or floating point type!
Non-atomic store cannot have SynchronizationScope specified
GEP base pointer is not a vector or a vector of pointers
GEP into unsized type!
GEP indexes must be integers
Invalid indices for GEP pointer type!
GEP is not of right type for indices!
Vector GEP result width doesn't match operand's
Invalid GEP index vector width
All GEP indices should be of integer type
fence instructions may only have acquire, release, acq_rel, or seq_cst ordering.
cmpxchg instructions must be atomic.
cmpxchg instructions cannot be unordered.
cmpxchg instructions failure argument shall be no stronger than the success argument
First cmpxchg operand must be a pointer.
cmpxchg operand must have integer or pointer type
Expected value type does not match pointer operand type!
atomicrmw instructions must be atomic.
atomicrmw instructions cannot be unordered.
First atomicrmw operand must be a pointer.
atomicrmw operand must have integer type!
Argument value type does not match pointer operand type!
Invalid binary operation!
Trunc only operates on integer
Trunc only produces integer
trunc source and destination must both be a vector or neither
DestTy too big for Trunc
ZExt only operates on integer
ZExt only produces an integer
zext source and destination must both be a vector or neither
Type too small for ZExt
SExt only operates on integer
SExt only produces an integer
sext source and destination must both be a vector or neither
Type too small for SExt
FPToUI source and dest must both be vector or scalar
FPToUI source must be FP or FP vector
FPToUI result must be integer or integer vector
FPToUI source and dest vector length mismatch
FPToSI source and dest must both be vector or scalar
FPToSI source must be FP or FP vector
FPToSI result must be integer or integer vector
FPToSI source and dest vector length mismatch
UIToFP source and dest must both be vector or scalar
UIToFP source must be integer or integer vector
UIToFP result must be FP or FP vector
UIToFP source and dest vector length mismatch
SIToFP source and dest must both be vector or scalar
SIToFP source must be integer or integer vector
SIToFP result must be FP or FP vector
SIToFP source and dest vector length mismatch
FPTrunc only operates on FP
FPTrunc only produces an FP
fptrunc source and destination must both be a vector or neither
DestTy too big for FPTrunc
FPExt only operates on FP
FPExt only produces an FP
fpext source and destination must both be a vector or neither
DestTy too small for FPExt
PtrToInt source must be pointer
PtrToInt result must be integral
PtrToInt type mismatch
PtrToInt Vector width mismatch
IntToPtr source must be an integral
IntToPtr result must be a pointer
IntToPtr type mismatch
IntToPtr Vector width mismatch
AddrSpaceCast source must be a pointer
AddrSpaceCast result must be a pointer
AddrSpaceCast must be between different address spaces
AddrSpaceCast vector pointer number of elements mismatch
CleanupPadInst needs to be in a function with a personality.
CleanupPadInst not the first non-PHI instruction in the block.
CleanupPadInst has an invalid parent.
FuncletPadInst must not be nested within itself
Bogus funclet pad use
Unwind edges out of a funclet pad must have the same unwind dest
Unwind edges out of a catch must have the same unwind dest as the parent catchswitch
CatchPadInst needs to be in a function with a personality.
CatchPadInst needs to be directly nested in a CatchSwitchInst.
CatchPadInst not the first non-PHI instruction in the block.
Both operands to ICmp instruction are not of the same type!
Invalid operand types for ICmp instruction
Invalid predicate in ICmp instruction!
Both operands to FCmp instruction are not of the same type!
Invalid operand types for FCmp instruction
Invalid predicate in FCmp instruction!
PHI nodes not grouped at top of basic block!
PHI nodes cannot have token type!
PHI node operands are not the same type as the result!
cannot use musttail call with inline asm
cannot guarantee tail call due to mismatched parameter counts
cannot guarantee tail call due to mismatched parameter types
cannot guarantee tail call due to mismatched varargs
cannot guarantee tail call due to mismatched return types
cannot guarantee tail call due to mismatched calling conv
cannot guarantee tail call due to mismatched ABI impacting function attributes
bitcast following musttail call must use the call
musttail call must precede a ret with an optional bitcast
musttail call result must be returned
Invalid operands for select instruction!
Select values must have same type as select instruction!
User-defined operators should not live outside of a pass!
Invalid extractelement operands!
Invalid insertelement operands!
Invalid shufflevector operands!
Invalid ExtractValueInst operands!
Invalid InsertValueInst operands!
LandingPadInst needs at least one clause or to be a cleanup.
The landingpad instruction should have a consistent result type inside a function.
LandingPadInst needs to be in a function with a personality.
LandingPadInst not the first non-PHI instruction in the block.
Catch operand does not have pointer type!
Filter operand is not an array of constants!
EH pads can't handle each other's exceptions
all indices passed to llvm.localrecover must be less than the number of arguments passed ot llvm.localescape in the parent function
Global variable initializer type does not match global variable type!
'common' global must have a zero initializer!
'common' global may not be marked constant!
'common' global may not be in a Comdat!
invalid linkage for intrinsic global variable
wrong type for intrinsic global variable
wrong initalizer for intrinsic global variable
invalid llvm.used member
members of llvm.used must be named
!dbg attachment of global variable must be a DIGlobalVariableExpression
Alias should have private, internal, linkonce, weak, linkonce_odr, weak_odr, or external linkage!
Aliasee cannot be NULL!
Alias and aliasee types should match!
Aliasee should be either GlobalValue or ConstantExpr
Alias must point to a definition
Aliases cannot form a cycle
Alias cannot point to an interposable alias
unrecognized named metadata node in the llvm.dbg namespace
invalid compile unit
comdat global value has private linkage
invalid requirement on flag, flag is not present in module
invalid requirement on flag, flag does not have the required value
incorrect number of operands in module flag
invalid behavior operand in module flag (expected constant integer)
invalid behavior operand in module flag (unexpected constant)
invalid ID operand in module flag (expected metadata string)
invalid value for 'max' module flag (expected constant integer)
invalid value for 'require' module flag (expected metadata pair)
invalid value for 'require' module flag (first value operand should be a string)
invalid value for 'append'-type module flag (expected a metadata node)
module flag identifiers must be unique (or of 'require' type)
wchar_size metadata requires constant integer argument
'Linker Options' named metadata no longer supported
expected a MDNode triple
expected an integer constant
expected a Function or null
llvm.ident
incorrect number of operands in llvm.ident metadata
invalid value for llvm.ident metadata entry operand(the operand should be a string)
DICompileUnit not listed in llvm.dbg.cu
All llvm.experimental.deoptimize declarations must have the same calling convention
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ
APInt(
0x%08x / 0x%08x = %.2f%%
%Y-%m-%d %H:%M:%S
%.9lu
General options
: for the -
 option: 
may only occur zero or one times!
must occur exactly one time!
>...
' is invalid value for boolean argument! Try 0 or 1
' value invalid for integer argument!
' value invalid for uint argument!
    =
 -   
    -
 (default: 
= *unknown option value*
*no default*
= *cannot print option value*
Generic Options
help-list
Display list of available options (-help-list-hidden for more)
help-list-hidden
Display list of all available options
Display available options (-help-hidden for more)
help-hidden
Display all available options
print-options
Print non-default options after command line parsing
print-all-options
Print all option values after command line parsing
version
Display the version of this program
: CommandLine Error: Option '
' registered more than once!
inconsistency in registered CommandLine options
Cannot specify more than one option with cl::ConsumeAfter!
error - this positional option will never be matched, because it does not Require a value, and a cl::ConsumeAfter option is active!
error - option can never match, because another positional argument will match an unbounded number of values, and this option does not require a value!
' is all messed up!
: Unknown command line argument '
'.  Try: '
 -help'
: Did you mean '-
This argument does not take a value.
Instead, it consumes any positional arguments until the next recognized option.
: Not enough positional command line arguments specified!
Must specify at least 
 positional argument
: See: 
 -help
: Too many positional arguments specified!
Can specify at most 
 positional arguments: See: 
must be specified at least once!
requires a value!
multi-valued option specified with ValueDisallowed modifier!
does not allow a value! '
' specified.
not enough values!
' value invalid for floating point argument!
  This option category has no options.
OVERVIEW: 
USAGE: 
 [subcommand]
 [options]
SUBCOMMAND '
SUBCOMMANDS:
  Type "
 <subcommand> -help" to get more help on a specific subcommand
OPTIONS:
LLVM (http://llvm.org/):
LLVM
 version 
7.0.0
Optimized build
generic
(unknown)
  Default target: 
  Host CPU: 
number
string
debug-counter
Comma separated list of debug counter skip and count
DebugCounter Error: 
 does not have an = in it
 is not a number
 is not a registered counter
 does not end with -skip or -count
Counters and values:
Multiple errors:
Error
Inconvertible error value. An error has occurred that could not be converted to a known std::error_code. Please file a bug.
LLVM ERROR: 
LLVM ERROR: out of memory
Allocation failed
view-background
Execute graph viewer in the background. Creates tmp file litter.
Error: 
Writing '
'... 
Trying 'open' program... 
xdg-open
Trying 'xdg-open' program... 
Graphviz
Running 'Graphviz' program... 
xdot|xdot.py
Running 'xdot.py' program... 
dot|fdp|neato|twopi|circo
-Tps
-Nfontname=Courier
-Gsize=7.5,10
Running '
' program... 
--spartan
dotty
Running 'dotty' program... 
Error: Couldn't find a usable graph viewer program:
  Tried '
Remember to erase graph file: 
neato
twopi
circo
LLT_invalid
rng-seed
seed
Seed for the random number generator
Allocation failed
SmallVector capacity overflow during allocation
Allocation failed
Included from 
error: 
warning: 
note: 
remark: 
Allocation failed
iwmmxt
xscale
invalid
arm64
thumb
aarch64
armv2
armv2a
armv3
armv3m
armv4
armv4t
armv5t
armv5te
armv5tej
5TEJ
armv6
armv6k
armv6t2
v6t2
armv6kz
v6kz
armv6-m
armv7-a
armv7ve
v7ve
armv7-r
armv7-m
armv7e-m
7E-M
v7em
armv8-a
armv8.1-a
8.1-A
v8.1a
armv8.2-a
8.2-A
v8.2a
armv8.3-a
8.3-A
v8.3a
armv8.4-a
8.4-A
v8.4a
armv8-r
armv8-m.base
8-M.Baseline
v8m.base
armv8-m.main
8-M.Mainline
v8m.main
iwmmxt2
armv7s
armv7k
v5te
v6-m
v7-a
v7-r
v7-m
v7e-m
v8-a
v8.1-a
v8.2-a
v8.3-a
v8.4-a
v8-r
v8-m.base
v8-m.main
track-memory
Enable -time-passes memory tracking (this may be slow)
info-output-file
File to append -stats and -timer output to
Error opening info-output-file '
 for appending!
%9lld  
  Total Execution Time: %5.4f seconds (%5.4f wall clock)
   ---User Time---
   --System Time--
   --User+System--
   ---Wall Time---
  ---Mem---
  --- Name ---
Total
misc
Miscellaneous Ungrouped Timers
        -----     
  %7.4f (%5.1f%%)
unknown
aarch64
aarch64_be
mips64
mips64el
powerpc64
riscv64
sparcv9
i386
x86_64
nvptx64
le64
amdil64
hsail64
spir64
wasm64
renderscript64
ananas
cloudabi
darwin
dragonfly
freebsd
fuchsia
kfreebsd
linux
macosx
netbsd
openbsd
solaris
windows
haiku
minix
rtems
nacl
cuda
nvcl
amdhsa
elfiamcu
mesa3d
contiki
amdpal
gnuabin32
gnuabi64
gnueabihf
gnueabi
gnux32
code16
eabi
eabihf
android
musl
musleabi
musleabihf
msvc
itanium
cygnus
coreclr
simulator
i486
macho
empty
rope:
cstring:"
std::string:"
stringref:"
smallstring:"
formatv:"
char:"
decUI:"
decI:"
decUL:"
decL:"
decULL:"
decLL:"
uhex:"
(Twine 
invalid number
out of range number
IO failure on output stream: 
[:<:]]
[:>:]]
alnum
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
alpha
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
blank
cntrl
digit
0123456789
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
lower
abcdefghijklmnopqrstuvwxyz
print
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~ 
punct
!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
space
upper
ABCDEFGHIJKLMNOPQRSTUVWXYZ
xdigit
0123456789ABCDEFabcdef
alert
backspace
newline
vertical-tab
form-feed
carriage-return
exclamation-mark
quotation-mark
number-sign
dollar-sign
percent-sign
ampersand
apostrophe
left-parenthesis
right-parenthesis
asterisk
plus-sign
comma
hyphen
hyphen-minus
period
full-stop
slash
solidus
zero
three
four
five
seven
eight
nine
colon
semicolon
less-than-sign
equals-sign
greater-than-sign
question-mark
commercial-at
left-square-bracket
backslash
reverse-solidus
right-square-bracket
circumflex
circumflex-accent
underscore
low-line
grave-accent
left-brace
left-curly-bracket
vertical-line
right-brace
right-curly-bracket
tilde
REG_0x%x
REG_NOMATCH
llvm_regexec() failed to match
REG_BADPAT
invalid regular expression
REG_ECOLLATE
invalid collating element
REG_ECTYPE
invalid character class
REG_EESCAPE
trailing backslash (\)
REG_ESUBREG
invalid backreference number
REG_EBRACK
brackets ([ ]) not balanced
REG_EPAREN
parentheses not balanced
REG_EBRACE
braces not balanced
REG_BADBR
invalid repetition count(s)
REG_ERANGE
invalid character range
REG_ESPACE
out of memory
REG_BADRPT
repetition-operator operand invalid
REG_EMPTY
empty (sub)expression
REG_ASSERT
"can't happen" -- you found a bug
REG_INVARG
invalid argument to regex routine
*** unknown regexp error code ***
x86_64-apple-darwin22.1.0
nehalem
westmere
sandybridge
amdfam10
bdver1
bdver2
bdver3
bdver4
znver1
ivybridge
haswell
broadwell
skylake
skylake-avx512
cannonlake
core2
penryn
k6-2
k6-3
geode
bonnell
silvermont
btver1
btver2
pentium
pentium-mmx
pentiumpro
pentium2
pentium3
pentium4
pentium-m
yonah
nocona
prescott
athlon
athlon-xp
k8-sse3
goldmont
goldmont-plus
-darwin
Allocation failed
-%%%%%%
0123456789abcdef
-%%%%%%.
TMPDIR
TEMP
TEMPDIR
TERM
PATH
Child timed out but wouldn't die
Error waiting for child process
Program could not be executed
 (core dumped)
" doesn't exist!
Can't redirect stderr to stdout
posix_spawn failed
/dev/null
Cannot open file '
' for 
Allocation failed
disable-symbolication
Disable symbolizing crash backtraces.
llvm-symbolizer
Unable to find target for this triple (no targets are registered)
DW_TAG_null
DW_TAG_array_type
DW_TAG_class_type
DW_TAG_entry_point
DW_TAG_enumeration_type
DW_TAG_formal_parameter
DW_TAG_imported_declaration
DW_TAG_label
DW_TAG_lexical_block
DW_TAG_member
DW_TAG_pointer_type
DW_TAG_reference_type
DW_TAG_compile_unit
DW_TAG_string_type
DW_TAG_structure_type
DW_TAG_subroutine_type
DW_TAG_typedef
DW_TAG_union_type
DW_TAG_unspecified_parameters
DW_TAG_variant
DW_TAG_common_block
DW_TAG_common_inclusion
DW_TAG_inheritance
DW_TAG_inlined_subroutine
DW_TAG_module
DW_TAG_ptr_to_member_type
DW_TAG_set_type
DW_TAG_subrange_type
DW_TAG_with_stmt
DW_TAG_access_declaration
DW_TAG_base_type
DW_TAG_catch_block
DW_TAG_const_type
DW_TAG_constant
DW_TAG_enumerator
DW_TAG_file_type
DW_TAG_friend
DW_TAG_namelist
DW_TAG_namelist_item
DW_TAG_packed_type
DW_TAG_subprogram
DW_TAG_template_type_parameter
DW_TAG_template_value_parameter
DW_TAG_thrown_type
DW_TAG_try_block
DW_TAG_variant_part
DW_TAG_variable
DW_TAG_volatile_type
DW_TAG_dwarf_procedure
DW_TAG_restrict_type
DW_TAG_interface_type
DW_TAG_namespace
DW_TAG_imported_module
DW_TAG_unspecified_type
DW_TAG_partial_unit
DW_TAG_imported_unit
DW_TAG_condition
DW_TAG_shared_type
DW_TAG_type_unit
DW_TAG_rvalue_reference_type
DW_TAG_template_alias
DW_TAG_coarray_type
DW_TAG_generic_subrange
DW_TAG_dynamic_type
DW_TAG_atomic_type
DW_TAG_call_site
DW_TAG_call_site_parameter
DW_TAG_skeleton_unit
DW_TAG_immutable_type
DW_TAG_MIPS_loop
DW_TAG_format_label
DW_TAG_function_template
DW_TAG_class_template
DW_TAG_GNU_template_template_param
DW_TAG_GNU_template_parameter_pack
DW_TAG_GNU_formal_parameter_pack
DW_TAG_GNU_call_site
DW_TAG_GNU_call_site_parameter
DW_TAG_APPLE_property
DW_TAG_BORLAND_property
DW_TAG_BORLAND_Delphi_string
DW_TAG_BORLAND_Delphi_dynamic_array
DW_TAG_BORLAND_Delphi_set
DW_TAG_BORLAND_Delphi_variant
DW_AT_sibling
DW_AT_location
DW_AT_name
DW_AT_ordering
DW_AT_byte_size
DW_AT_bit_offset
DW_AT_bit_size
DW_AT_stmt_list
DW_AT_low_pc
DW_AT_high_pc
DW_AT_language
DW_AT_discr
DW_AT_discr_value
DW_AT_visibility
DW_AT_import
DW_AT_string_length
DW_AT_common_reference
DW_AT_comp_dir
DW_AT_const_value
DW_AT_containing_type
DW_AT_default_value
DW_AT_inline
DW_AT_is_optional
DW_AT_lower_bound
DW_AT_producer
DW_AT_prototyped
DW_AT_return_addr
DW_AT_start_scope
DW_AT_bit_stride
DW_AT_upper_bound
DW_AT_abstract_origin
DW_AT_accessibility
DW_AT_address_class
DW_AT_artificial
DW_AT_base_types
DW_AT_calling_convention
DW_AT_count
DW_AT_data_member_location
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_declaration
DW_AT_discr_list
DW_AT_encoding
DW_AT_external
DW_AT_frame_base
DW_AT_friend
DW_AT_identifier_case
DW_AT_macro_info
DW_AT_namelist_item
DW_AT_priority
DW_AT_segment
DW_AT_specification
DW_AT_static_link
DW_AT_type
DW_AT_use_location
DW_AT_variable_parameter
DW_AT_virtuality
DW_AT_vtable_elem_location
DW_AT_allocated
DW_AT_associated
DW_AT_data_location
DW_AT_byte_stride
DW_AT_entry_pc
DW_AT_use_UTF8
DW_AT_extension
DW_AT_ranges
DW_AT_trampoline
DW_AT_call_column
DW_AT_call_file
DW_AT_call_line
DW_AT_description
DW_AT_binary_scale
DW_AT_decimal_scale
DW_AT_small
DW_AT_decimal_sign
DW_AT_digit_count
DW_AT_picture_string
DW_AT_mutable
DW_AT_threads_scaled
DW_AT_explicit
DW_AT_object_pointer
DW_AT_endianity
DW_AT_elemental
DW_AT_pure
DW_AT_recursive
DW_AT_signature
DW_AT_main_subprogram
DW_AT_data_bit_offset
DW_AT_const_expr
DW_AT_enum_class
DW_AT_linkage_name
DW_AT_string_length_bit_size
DW_AT_string_length_byte_size
DW_AT_rank
DW_AT_str_offsets_base
DW_AT_addr_base
DW_AT_rnglists_base
DW_AT_dwo_id
DW_AT_dwo_name
DW_AT_reference
DW_AT_rvalue_reference
DW_AT_macros
DW_AT_call_all_calls
DW_AT_call_all_source_calls
DW_AT_call_all_tail_calls
DW_AT_call_return_pc
DW_AT_call_value
DW_AT_call_origin
DW_AT_call_parameter
DW_AT_call_pc
DW_AT_call_tail_call
DW_AT_call_target
DW_AT_call_target_clobbered
DW_AT_call_data_location
DW_AT_call_data_value
DW_AT_noreturn
DW_AT_alignment
DW_AT_export_symbols
DW_AT_deleted
DW_AT_defaulted
DW_AT_loclists_base
DW_AT_MIPS_loop_begin
DW_AT_MIPS_tail_loop_begin
DW_AT_MIPS_epilog_begin
DW_AT_MIPS_loop_unroll_factor
DW_AT_MIPS_software_pipeline_depth
DW_AT_MIPS_linkage_name
DW_AT_MIPS_stride
DW_AT_MIPS_abstract_name
DW_AT_MIPS_clone_origin
DW_AT_MIPS_has_inlines
DW_AT_MIPS_stride_byte
DW_AT_MIPS_stride_elem
DW_AT_MIPS_ptr_dopetype
DW_AT_MIPS_allocatable_dopetype
DW_AT_MIPS_assumed_shape_dopetype
DW_AT_MIPS_assumed_size
DW_AT_sf_names
DW_AT_src_info
DW_AT_mac_info
DW_AT_src_coords
DW_AT_body_begin
DW_AT_body_end
DW_AT_GNU_vector
DW_AT_GNU_template_name
DW_AT_GNU_odr_signature
DW_AT_GNU_call_site_value
DW_AT_GNU_all_call_sites
DW_AT_GNU_macros
DW_AT_GNU_dwo_name
DW_AT_GNU_dwo_id
DW_AT_GNU_ranges_base
DW_AT_GNU_addr_base
DW_AT_GNU_pubnames
DW_AT_GNU_pubtypes
DW_AT_GNU_discriminator
DW_AT_BORLAND_property_read
DW_AT_BORLAND_property_write
DW_AT_BORLAND_property_implements
DW_AT_BORLAND_property_index
DW_AT_BORLAND_property_default
DW_AT_BORLAND_Delphi_unit
DW_AT_BORLAND_Delphi_class
DW_AT_BORLAND_Delphi_record
DW_AT_BORLAND_Delphi_metaclass
DW_AT_BORLAND_Delphi_constructor
DW_AT_BORLAND_Delphi_destructor
DW_AT_BORLAND_Delphi_anonymous_method
DW_AT_BORLAND_Delphi_interface
DW_AT_BORLAND_Delphi_ABI
DW_AT_BORLAND_Delphi_return
DW_AT_BORLAND_Delphi_frameptr
DW_AT_BORLAND_closure
DW_AT_LLVM_include_path
DW_AT_LLVM_config_macros
DW_AT_LLVM_isysroot
DW_AT_APPLE_optimized
DW_AT_APPLE_flags
DW_AT_APPLE_isa
DW_AT_APPLE_block
DW_AT_APPLE_major_runtime_vers
DW_AT_APPLE_runtime_class
DW_AT_APPLE_omit_frame_ptr
DW_AT_APPLE_property_name
DW_AT_APPLE_property_getter
DW_AT_APPLE_property_setter
DW_AT_APPLE_property_attribute
DW_AT_APPLE_objc_complete_type
DW_AT_APPLE_property
DW_OP_addr
DW_OP_deref
DW_OP_const1u
DW_OP_const1s
DW_OP_const2u
DW_OP_const2s
DW_OP_const4u
DW_OP_const4s
DW_OP_const8u
DW_OP_const8s
DW_OP_constu
DW_OP_consts
DW_OP_dup
DW_OP_drop
DW_OP_over
DW_OP_pick
DW_OP_swap
DW_OP_rot
DW_OP_xderef
DW_OP_abs
DW_OP_and
DW_OP_div
DW_OP_minus
DW_OP_mod
DW_OP_mul
DW_OP_neg
DW_OP_not
DW_OP_or
DW_OP_plus
DW_OP_plus_uconst
DW_OP_shl
DW_OP_shr
DW_OP_shra
DW_OP_xor
DW_OP_bra
DW_OP_eq
DW_OP_ge
DW_OP_gt
DW_OP_le
DW_OP_lt
DW_OP_ne
DW_OP_skip
DW_OP_lit0
DW_OP_lit1
DW_OP_lit2
DW_OP_lit3
DW_OP_lit4
DW_OP_lit5
DW_OP_lit6
DW_OP_lit7
DW_OP_lit8
DW_OP_lit9
DW_OP_lit10
DW_OP_lit11
DW_OP_lit12
DW_OP_lit13
DW_OP_lit14
DW_OP_lit15
DW_OP_lit16
DW_OP_lit17
DW_OP_lit18
DW_OP_lit19
DW_OP_lit20
DW_OP_lit21
DW_OP_lit22
DW_OP_lit23
DW_OP_lit24
DW_OP_lit25
DW_OP_lit26
DW_OP_lit27
DW_OP_lit28
DW_OP_lit29
DW_OP_lit30
DW_OP_lit31
DW_OP_reg0
DW_OP_reg1
DW_OP_reg2
DW_OP_reg3
DW_OP_reg4
DW_OP_reg5
DW_OP_reg6
DW_OP_reg7
DW_OP_reg8
DW_OP_reg9
DW_OP_reg10
DW_OP_reg11
DW_OP_reg12
DW_OP_reg13
DW_OP_reg14
DW_OP_reg15
DW_OP_reg16
DW_OP_reg17
DW_OP_reg18
DW_OP_reg19
DW_OP_reg20
DW_OP_reg21
DW_OP_reg22
DW_OP_reg23
DW_OP_reg24
DW_OP_reg25
DW_OP_reg26
DW_OP_reg27
DW_OP_reg28
DW_OP_reg29
DW_OP_reg30
DW_OP_reg31
DW_OP_breg0
DW_OP_breg1
DW_OP_breg2
DW_OP_breg3
DW_OP_breg4
DW_OP_breg5
DW_OP_breg6
DW_OP_breg7
DW_OP_breg8
DW_OP_breg9
DW_OP_breg10
DW_OP_breg11
DW_OP_breg12
DW_OP_breg13
DW_OP_breg14
DW_OP_breg15
DW_OP_breg16
DW_OP_breg17
DW_OP_breg18
DW_OP_breg19
DW_OP_breg20
DW_OP_breg21
DW_OP_breg22
DW_OP_breg23
DW_OP_breg24
DW_OP_breg25
DW_OP_breg26
DW_OP_breg27
DW_OP_breg28
DW_OP_breg29
DW_OP_breg30
DW_OP_breg31
DW_OP_regx
DW_OP_fbreg
DW_OP_bregx
DW_OP_piece
DW_OP_deref_size
DW_OP_xderef_size
DW_OP_nop
DW_OP_push_object_address
DW_OP_call2
DW_OP_call4
DW_OP_call_ref
DW_OP_form_tls_address
DW_OP_call_frame_cfa
DW_OP_bit_piece
DW_OP_implicit_value
DW_OP_stack_value
DW_OP_implicit_pointer
DW_OP_addrx
DW_OP_constx
DW_OP_entry_value
DW_OP_const_type
DW_OP_regval_type
DW_OP_deref_type
DW_OP_xderef_type
DW_OP_convert
DW_OP_reinterpret
DW_OP_GNU_push_tls_address
DW_OP_GNU_addr_index
DW_OP_GNU_const_index
DW_OP_LLVM_fragment
DW_ATE_address
DW_ATE_boolean
DW_ATE_complex_float
DW_ATE_float
DW_ATE_signed
DW_ATE_signed_char
DW_ATE_unsigned
DW_ATE_unsigned_char
DW_ATE_imaginary_float
DW_ATE_packed_decimal
DW_ATE_numeric_string
DW_ATE_edited
DW_ATE_signed_fixed
DW_ATE_unsigned_fixed
DW_ATE_decimal_float
DW_ATE_UTF
DW_ATE_UCS
DW_ATE_ASCII
DW_VIRTUALITY_none
DW_VIRTUALITY_virtual
DW_VIRTUALITY_pure_virtual
DW_LANG_C89
DW_LANG_C
DW_LANG_Ada83
DW_LANG_C_plus_plus
DW_LANG_Cobol74
DW_LANG_Cobol85
DW_LANG_Fortran77
DW_LANG_Fortran90
DW_LANG_Pascal83
DW_LANG_Modula2
DW_LANG_Java
DW_LANG_C99
DW_LANG_Ada95
DW_LANG_Fortran95
DW_LANG_PLI
DW_LANG_ObjC
DW_LANG_ObjC_plus_plus
DW_LANG_UPC
DW_LANG_D
DW_LANG_Python
DW_LANG_OpenCL
DW_LANG_Go
DW_LANG_Modula3
DW_LANG_Haskell
DW_LANG_C_plus_plus_03
DW_LANG_C_plus_plus_11
DW_LANG_OCaml
DW_LANG_Rust
DW_LANG_C11
DW_LANG_Swift
DW_LANG_Julia
DW_LANG_Dylan
DW_LANG_C_plus_plus_14
DW_LANG_Fortran03
DW_LANG_Fortran08
DW_LANG_RenderScript
DW_LANG_BLISS
DW_LANG_Mips_Assembler
DW_LANG_GOOGLE_RenderScript
DW_LANG_BORLAND_Delphi
DW_CC_normal
DW_CC_program
DW_CC_nocall
DW_CC_pass_by_reference
DW_CC_pass_by_value
DW_CC_GNU_renesas_sh
DW_CC_GNU_borland_fastcall_i386
DW_CC_BORLAND_safecall
DW_CC_BORLAND_stdcall
DW_CC_BORLAND_pascal
DW_CC_BORLAND_msfastcall
DW_CC_BORLAND_msreturn
DW_CC_BORLAND_thiscall
DW_CC_BORLAND_fastcall
DW_CC_LLVM_vectorcall
DW_CC_LLVM_Win64
DW_CC_LLVM_X86_64SysV
DW_CC_LLVM_AAPCS
DW_CC_LLVM_AAPCS_VFP
DW_CC_LLVM_IntelOclBicc
DW_CC_LLVM_SpirFunction
DW_CC_LLVM_OpenCLKernel
DW_CC_LLVM_Swift
DW_CC_LLVM_PreserveMost
DW_CC_LLVM_PreserveAll
DW_CC_LLVM_X86RegCall
DW_CC_GDB_IBM_OpenCL
DW_MACINFO_define
DW_MACINFO_undef
DW_MACINFO_start_file
DW_MACINFO_end_file
DW_MACINFO_vendor_ext
R_WEBASSEMBLY_FUNCTION_INDEX_LEB
R_WEBASSEMBLY_TABLE_INDEX_SLEB
R_WEBASSEMBLY_TABLE_INDEX_I32
R_WEBASSEMBLY_MEMORY_ADDR_LEB
R_WEBASSEMBLY_MEMORY_ADDR_SLEB
R_WEBASSEMBLY_MEMORY_ADDR_I32
R_WEBASSEMBLY_TYPE_INDEX_LEB
R_WEBASSEMBLY_GLOBAL_INDEX_LEB
R_WEBASSEMBLY_FUNCTION_OFFSET_I32
R_WEBASSEMBLY_SECTION_OFFSET_I32
static-func-full-module-prefix
Use full module build paths in the profile counter names for static functions.
static-func-strip-dirname-prefix
Strip specified level of directory name from source path in the profile counter name for static functions.
GED ERROR: 
/AppleInternal/Library/BuildRoots/37485203-f0ff-11ee-b9af-a65dcee5a99e/Library/Caches/com.apple.xbs/Sources/GPUDriversIntel/igc/gfx-driver/Source/visa/iga/GEDLibrary/GED_internal/Source/ged/xcoder/ged_ins.cpp
MapRawBytes
 is not yet implemented
GED VERSION: 
        
0.41 (982f76f)
Breakpoint
mme0
mme1
mme2
mme3
mme4
mme5
mme6
mme7
nomme
MSD0R_HWB
MSD0W_HWB
MT0R_OWB
MT0R_OWUB
MT0R_OWDB
MT0R_DWS
MT0R_BS
MT0_MEMFENCE
MT0W_OWB
MT0W_OWDB
MT0W_DWS
MT0W_BS
MT1R_T
MT1R_US
MT1A_UI
MT1A_UI4x2
MT1R_MB
MT1R_TS
MT1A_TA
MT1A_TA4x2
MT1W_US
MT1W_MB
MT1A_TC
MT1A_TC4x2
MT1W_TS
MT1R_A64_SB
MT1R_A64_US
MT1A_A64_UI
MT1A_A64_UI4x2
MT1R_A64_B
MT1W_A64_B
MT1W_A64_US
MT1W_A64_SB
MT2R_US
MT2R_A64_SB
MT2R_A64_US
MT2R_BS
MT2W_US
MT2W_A64_US
MT2W_A64_SB
MT2W_BS
MT_CC_OWB
MT_CC_OWUB
MT_CC_OWDB
MT_CC_DWS
MT_SC_OWUB
MT_SC_MB
MT_RSI
MT_RTW
MT_RTR
MTR_MB
MTRR_TS
MTRA_TA
MT_MEMFENCE
MTW_MB
MTRW_TS
MT0R_US
MT0A_UI
MT0W_US
MT1A_UF4x2
MT1A_UF
MT1A_A64_UF
MT1A_A64_UF4x2
Scratch Block Read
Scratch Block Write
OWord Block Read
Unaligned OWord Block Read
OWord Dual Block Read
DWord Scattered Read
Byte Scattered Read
Memory Fence
OWord Block Write
OWord Dual Block Write
DWord Scattered Write
Byte Scattered Write
Transpose Read
Untyped Surface Read
Untyped Atomic Integer Operation
Untyped Atomic Integer Operation SIMD4x2
Media Block Read
Typed Surface Read
Typed Atomic Integer Operation
Typed Atomic Integer Operation SIMD4x2
Untyped Surface Write
Media Block Write
Typed Atomic Counter Operation
Typed Atomic Counter Operation SIMD4x2
Typed Surface Write
A64 Scattered Read
A64 Untyped Surface Read
A64 Untyped Atomic Integer Operation
A64 Untyped Atomic Integer Operation SIMD4x2
A64 Block Read
A64 Block Write
A64 Untyped Surface Write
A64 Scattered Write
Oword Block Read Constant Cache
Unaligned Oword Block Read Constant Cache
Oword Dual Block Read Constant Cache
Dword Scattered Read Constant Cache
Unaligned Oword Block Read Sampler Cache
Media Block Read Sampler Cache
Read Surface Info
Render Target Write
Render Target Read
Typed Atomic Operation
Untyped Atomic Operation
A64 Untyped Atomic Float Add
Untyped Atomic Float Operation
A64 Untyped Atomic Float Operation
A64 Untyped Atomic Float Operation SIMD4x2
SIMD16
SIMD8
bits set in undefined field
MType
const_load_block
unaligned_const_load_block
constant oword block read
constant unaligned oword block read
7041
7043
constant dword gathering read
LegacySimdMode
7084
unsupported DCRO op
MessageType
load_block
7028
aligned oword block read
aligned_load_block
7030
store_block
7032
aligned_store_block
aligned oword block write
20862
7029
oword dual block read decode not supported
7033
oword dual block write decode not supported
byte gathering read
byte scattering write
7066
7068
dword gathering read
dword scattering write
7067
7069
Commit
off (return immediately)
on (wait for fence commit)
sync_
synchronized 
slm_fence
SLM fence
global_fence
global fence
L3 implies L1 flush
 flushing
L1Flush
Flush L3
FLush L1
L3 Flush Targets
 all L3 data
.dcti
 r/w data
 constant data
 texture data
 instruction data
invalid BTI for fence (must be 0x0 or 0xFE)
7049
hword scratch block read
hword scratch block write
HWordOffset
ChannelMode
OWord
DWord
7027
7031
unsupported dc0 op
7091
7086
7089
a64 byte gathering read
a64 byte scattering write
SubType
7070
7073
Byte with Status Return
19316
a64 byte scattering with status return message
a64 scattering write
a64 dword gathering read
a64 dword scattering write
a64 qword gathering read
a64 qword scattering write
QWord
7071
7074
7072
7075
7034
7038
HWord aligned unsupported on this platform
7037
33440
7039
7036
7040
a64 dual block 
 read
 write
MSD1R_A64_OWDB
MSD1W_A64_OWDB
 unaligned
 aligned
_aligned
 hword
 oword
 block
a64 float atomic
7126
7118
float atomic
7130
7122
a64 untyped atomic int32
DataWidth
untyped
7161
7155
7143
7137
untyped atomic int32
7167
7149
media block 
mlen == 0 on write
 with vertical line stride 
override
skip
, and 
stride offset meaningless when override not set
7046
7048
7087
7090
typed
atomic 32-bit counter
7109
7099
typed_sgh
atomic 32-bit integer (slot group high)
atomic 32-bit integer
7113
7103
unsupported DC1 op
ChannelMaskEnable
enabled
disabled
MSDUW_DWS
urb dword 
masked 
 with per-slot offset enabled
44779
44778
MSDUR_DWS
urb dword read
44777
unsupported URB op
URBOpcode
signal
signal event
monitor
monitor event
unmonitor
unmonitor event
wait for event
unsupported GTWY op
GatewayOpcode
unknown render target op
unsupported RC op
MessageTypeRC
DataSize
FP32
FP16
full-precision
.f32
half-precision
half-precision not supported on render target read
.f16
.simd16
 SIMD16
.rep16
 replicated SIMD16
.lo8ds
 of low SIMD8
.hi8ds
 of high SIMD8
.simd8
 SIMD8
.???
unknown write subop
unknown read subop
Subop
PerCoarsePixelPSOutputs
 with Per-Coarse Pixel PS outputs enable
.cpo
PerSamplePS
 with Per-Sample Pixel PS outputs enable
.psp
LastRenderTargetSelect
; last render target
.lrts
SlotGroupSelect
SLOTGRP_LO
SLOTGRP_HI
 slot group high
.sgh
SIMD[2]
12484
invalid sampler SIMD mode
simd32/64
simd32
invalid SIMD mode
simd8h
simd8 high
simd16h
simd16 high
SIMD[1:0]
ReturnFormat
 16b
sample+LOD bias
sample override LOD
sample compare
sample gradient
sample compare+LOD bias
sample compare+override LOD
sample_ld
sample load
sample_gather4
sample gather4
sample_lod
sample override lod
sample_resinfo
sample res info
sample_info
sample info
sample_killpix
sample_gather4_c
sample gather4+compare
sample_gather4_po
sample gather4+pixel offset
sample_gather4_po_c
sample gather4 pixel offset+compare
sample derivatives+compare
sample_min
sample min
sample_max
sample max
sample with lod forced to 0
sample compare+with lod forced to 0
sample_ld_lz
sample load with lod forced to 0
sample_ld2dms_w
sample ld2 multi-sample wide
sample_ld_mcs
sample load mcs auxilary data
sample_ld2dms
sample load multi-sample
sample_ld2ds
sample multi-sample without mcs
sample_
sample unorm
sample_unorm_killpix
sample unorm+killpix
sample_deinterlace
sample deinterlace
sample_unorm_media
sample unorm for media
sample_unorm_killpix_media
sample unorm+killpix for media
sample_8x8
sample 8x8
sample_flush
sampler cache flush
SamplerMessageType
SamplerIndex
 using sampler index 
Mlen
Rlen
Xlen
unsupported DC2 op
unsupported TS op
unsupported sfid
DataElements:MDC_A64_DB_OW
1L (1 Oword accessed in low half of GRF)
1H (1 Oword accessed in high half of GRF)
2 OWords
4 OWords
8 OWords
DataElements:MDC_DB_OW
MDC_IAR
this message requires a header (and it's absent)
Fill 1 byte per DW
Fill 2 bytes per DW
Fill all 4 bytes per DW
DataElements:MDC_DWS_DS
SimdMode:MDC_SM2
field should be 
Header
absent
included
hdc_
_simd
scratch
stateless
_incoherent
bti[
must have 0xFF or 0xFD BTI
DataElements:MDC_DS
DE1 (1 data element per addr.)
DE2 (2 data elements per addr.)
DE4 (4 data elements per addr.)
DE8 (8 data elements per addr.)
surface 
 (SLM)
A64 
A32 
 (coherent stateless)
 A64
 A32
 (incoherent stateless)
 (SSO)
DataElements:MDC_A64_DB_HW
 256b blocks
DataElements:MDC_DB_HW
untyped_load
untyped_store
channel mask must have one element not disabled
no channels enabled
 enabled
ChannelDisableMask:MDC_CMASK
invalid MDC_SM3
SimdMode:MDC_SM3
this message forbids a header (and it's included)
DataElements:MDC_A64_DS
atomic_fmax
atomic_fmin
atomic_fcas
fp-compare and swap 
 (unknown float op)
AtomicOp:MDC_AOP
ReturnDataControl
no return value
returns new value
_ret
 with return
atomic_icas
64b integer compare and swap
atomic_and
logical AND
atomic_or
logical OR
atomic_xor
logical XOR
atomic_store
atomic_iinc
integer increment
atomic_idec
integer decrement
atomic_iipdec
integer pre-decrement (returns pre-decrement value)
atomic_iadd
integer add
atomic_isub
integer subtract
atomic_irsub
commuted integer subtract
atomic_smax
signed-integer max
atomic_smin
signed-integer min
atomic_umax
unsigned-integer max
atomic_umin
unsigned-integer min
integer compare and swap (non-64b)
AtomicIntegerOp
SimdMode:MDC_SM2R
typed_load
typed_store
 (high slot group)
_sgh
SG4x2
SG8L
SG8U
invalid slot group value
SlotGroup:MDC_SG3
SlotGroup:MDC_SG2
GlobalUrbOffset
 (in owords)
PerSlotOffsetPresent
per-slot offset in payload
DualHeader
included (two register header)
 HWords from scratch base
oword unaligned
oword aligned
hword unaligned
dual block
a64 dual block read/write unsupported
 to surface 
.bti[
sampler 
 address registers written
 registers read back
 data registers written
encoder line %d: unsupported GED setter %s (%s)
failed to allocate memory for kernel binary
GED unable to compact instruction
MathFC
GED failed to create instruction template
AccessMode
ExecSize
ChannelOffset
MaskCtrl
PredCtrl
CondModifier
PredInv
FlagRegNum
FlagSubRegNum
AccWrCtrl
Saturate
DstDataType
DstRegFile
DstMathMacroExt
DstHorzStride
src0: unsupported type for ternary align1 encoding
ExecutionDataType
BranchCtrl
Src1DataType
Src1RegFile
Src0VertStride
Src0Width
Src0HorzStride
Src0RegFile
Src0DataType
ExDescRegFile
ExMsgDesc
ex_desc register not supported on this platform for this instruction
ExDescAddrSubRegNum
DescRegFile
MsgDesc
DescRegNum
DstAddrMode
dst has inconvertible region for Align16 encoding
DstChanEn
Align1 dst math macro unsupported on this platform.
DstAddrImm
DstAddrSubRegNum
dst region should be %s
DstRegNum
dst: unsupported destination operand kind/addrMode (malformed IR)
Src0AddrMode
src%d: unsupported source operand kind/addrMode (malformed IR)
Src0RegNum
Src0SubRegNum
Src0AddrSubRegNum
Src0AddrImm
Src1RegNum
align16 ternary dst must be to GRF
%s: invalid register name for this platform
%s: %s%d number out of range
operand has invalid math macro register
ThreadCtrl
NoPreempt not supported on this platform (dropping)
DstSubRegNum
DebugCtrl
DepCtrl
nop doesn't support Switch option (dropping)
jip label invalid
uip label invalid
GED_EncodeIns failed: %s
Src1VertStride
cyclic dependency
null pointer
unsupported opcode
no compact form
invalid field
invalid value
invalid interpreter
other error
src%d source modifier not supported (invalid IR)
src%d: unsupported source operand kind (malformed IR)
src%d: unsupported region for translation to align16 encoding
Src1SrcMod
Src1AddrMode
src%d: unexpected register on this platform
Src1SubRegNum
Src1MathMacroExt
Src1AddrImm
Src1AddrSubRegNum
Src1ChanSel
invalid region vertical stride on src1
invalid region width on src1
invalid region horizontal stride on src1
Src1Width
Src1HorzStride
Src0SrcMod
Src0MathMacroExt
Src0ChanSel
invalid region vertical stride on src0
invalid region width on src0
invalid region horizontal stride on src0
SrcDataType
src%d: unsupported region for Align16 encoding
Src0RepCtrl
src%d: mixed types require :f and :hf (or vice versa)
Src1RepCtrl
Src2SrcMod
Src2DataType
Src2RepCtrl
Src2ChanSel
Src2RegNum
Src2SubRegNum
Src2MathMacroExt
src%d: align1 ternary is not supported on this platform.
src%d: math macro operands require Align16
src%d: invalid operand kind
Src0TernaryImm
src1: immediate operand in ternary align1 must be src0 or src2
Src2RegFile
Src2HorzStride
Src2TernaryImm
qnan
snan
(sat)
Operand::Kind::?
 wr:
h:INVALID
, rd:
 from scratch offset 0x
 msc:
, to 
INVALID BTI
global memory
bti 
Type
MathMacroExt::INVALID
MathMacroExt
dst region is not binary normal
SrcModifier
on <v;h> region w must be Region::WI_INVALID
on <h> region v must be Region::VT_INVALID
on <h> region w must be Region::WI_INVALID
<Region::INVALID>
InstOpt
/* [
 */ 
|ChannelOffset
]: #
 // 
 from #
FlagModifier
not a send
has reg descs
src0 must be GRF
no mapping for descriptors
dst must be GRF for load
dst must be null for store
unsupported format kind (for now)
error decoding SIMD size from descriptor
descriptor SIMD size mismatches instruction ExecSize
an operand is indirect
store as send must have a null dst
src0 is null (doesn't fit operand mapping)
store needs binary send with non-null src1
-<ERR>
a32c
a32o
a64c
a64o
surf
scratch
xga8
xsc8
xga32
xsc32
xga64
xsc64
ga32
sc32
ga32c
xbl256
xbl128
xubl128
bl128
abl128
cbl128
cubl128
sbl256
PackedData
DE(0x
BTS_SLM_A32
HW64
HW64(0x
OWs(0x
HWSB
HWSB(0x
ScratchOffset
CMask
rgba
CMask(0x
CMaskUW
CMaskUW(0x
sg4x2
sg8l
sg8h
SG3(0x
: numeric label targets the middle of an instruction
 targets
 before kernel start
 after kernel end
: PC 
destination register ARF access requires {Switch} ThreadCtrl
not a macro instruction
invalid operand type combination for instruction
src type is not binary normal form
register regioning restriction warning: ExecSize * sizeof(Type) exceeds 2 GRF
see Programmer's Reference Manual (Restriction 1.1)
register regioning restriction warning: ExecSize <= Src.W (partial row)
see Programmer's Reference Manual (Restriction 2.1)
register regioning restriction warning: ExecSize == Src.W && Src.H != 0 && Src.V != Src.W * Src.H (vertical misalignment)
see Programmer's Reference Manual (Restriction 2.2)
register regioning restriction warning: SIMD1 requires horizontal stride of 0 (scalar region access)
see Programmer's Reference Manual (Restriction 2.4)
register regioning restriction warning: SIMD1 requires vertical and horiztonal to be 0 (scalar region access)
see Programmer's Reference Manual (Restriction 2.5)
register regioning restriction warning: If vertical stride and horizontal stride are 0, width must be 1.
see Programmer's Reference Manual (Restriction 2.6)
register regioning restriction warning: Vertical stride must be used to cross GRF boundaries.
see Programmer's Reference Manual (Restriction 2.8)
General
null
Null
Index
Accumulator
Math Macro
Flag Register
Channel Enable
Message Control
Stack Pointer
State Register
Control Register
Notification Register
Instruction Pointer
Thread Dependency Register
Timestamp Register
Flow Control
Debug
Addition
The add instruction performs component-wise addition of src0 and src1 and stores the results in dst.
Addition of two floating-point numbers follows rules in add (IEEE mode) or add (ALT mode).
Format:
[(pred)] add[.cmod] (exec_size) dst src0 src1
Use a source modifier with add to implement subtraction.
addc
Addition with Carry
The addc instruction performs component-wise addition of src0 and src1 and stores the results in dst; it also stores the carry into acc.
If the operation produces a carry out, 0x00000001 is stored in acc, else 0x00000000 is stored in acc.
Format:
[(pred)] addc[.cmod] (exec_size) dst src0 src1
Logic And
The and instruction performs component-wise logic AND operation between src0 and src1 and stores the results in dst.
Register source operands can use source modifiers:
[Pre-DevBDW]: Any source modifier is numeric, optionally changing a source value s to -s, abs(s), or -abs(s) before the AND operation.
[DevBDW+]: Any source modifier is logical, optionally changing a source value s to ~s (inverting all source bits). This capability allows expressions like a AND (NOT b) to be calculated with one instruction.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
Format:
Source modifier is not allowed if source is an accumulator.
Arithmetic Shift Right
Perform component-wise arithmetic right shift of the bits in src0 by the shift count indicated in src1, storing the results in dst. If src0 has a signed type, insert copies of src0's sign bit in the number of MSBs indicated by the shift count. Otherwise insert 0 bits.
[Pre-DevBDW]: The shift count is taken from the low five bits of src1, regardless of the src1 type and treated as an unsigned integer in the range 0 to 31.
[DevBDW+]: In QWord mode, the shift count is taken from the low six bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 63. Otherwise the shift count is taken from the low five bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 31. The operation uses QWord mode if src0 or dst has the Q or UQ type but not if src1 is the only operand with the Q or UQ type.
For positive values, this operation is src0 / 2shiftCount and for negative values, this operation is src0 / 2shiftCount - 1.
Format:
[(pred)] asr[.cmod] (exec_size) dst src0 src1
If src0 is -1, the result is -1 regardless of the shift count.
For unsigned src0 types, asr and shr produce the same result.
Average
The avg instruction performs component-wise integer average of src0 and src1 and stores the results in dst. An integer average uses integer upward rounding. It is equivalent to increment one to the addition of src0 and src1 and then apply an arithmetic right shift to this intermediate value.
Format:
The avg instruction performs component-wise integer average of src0 and src1 and stores the results in dst. An integer average uses integer upward rounding. It is equivalent to increment one to the addition of src0 and src1 and then apply an arithmetic right shift to this intermediate value.
Bit Field Extract
Component-wise extract a bit field from src2 using the bit field width from src0 and the bit field offset from src1. Store the extracted bit field value in the low bits of dst and sign extend (if D type) or zero extend (if UD type).
The width and offset values are from the low five bits of src0 and src1 respectively, or src0 & 0x1f and src1 & 0x1f.
If width is zero, the result is zero.
If offset + width > 32 then the extracted bit field is bits offset to 31 of src2, extracting only 32 - offset bits, less than width as the bit field cannot extend past the MSB of the source value. Otherwise extract width bits extending from bit positions offset to offset + width - 1.
Format:
[(pred)] bfe (exec_size) dst src0 src1 src2
bfi1
Bit Field Insert 1
The bfi1 instruction is the first instruction in a two-instruction macro for bfi (Bit Field Insert).
The bfi1 instruction component-wise generates mask with control from src0 and src1 and stores the results in dst. The mask is used in the bfi2 instruction to generate the final result of bfi.
Create a bit mask corresponding to the bit field width and offset in src0 and src1. Store the bit mask in dst. The mask has all bits in the bit field set to 1 and all other bits as 0.
The width and offset values are from the low five bits of src0 and src1 respectively, or src0 & 0x1f and src1 & 0x1f.
If width is zero, the result is zero.
The bfi macro has four source operands: src0 - bit field width in low five bits, src1 - bit field offset/starting bit position in low five bits, src2 - bit field value to insert, using only the number of least significant bits given by width in src0, and src3 - overall value into which the bit field is inserted, providing all bits other than the inserted bits for the result value.
bfi dst src0 src1 src2 src3
// Translates to these two instructions:
bfi1 dst src0 src1
bfi2 dst dst src2 src3
Format:
[(pred)] bfi1 (exec_size) dst src0 src1
No accumulator access, implicit or explicit.
A SIMD16 instruction is not allowed.
bfi2
Bit Field Insert 2
The bfi2 instruction is the second instruction in a two-instruction macro for bfi (Bit Field Insert).
The bfi2 instruction component-wise performs the bitfield insert operation on src1 and src2 based on the mask in src0.
Use the mask in src0 to take a bit field value from the low bits of src1 and combine it with the value from src2 (so src2 provides all bits other than those masked out and replaced by the bit field value). Store the result in dst.
The bfi macro has four source operands: src0 - bit field width in low five bits, src1 - bit field offset/starting bit position in low five bits, src2 - bit field value to insert, using only the number of least significant bits given by width in src0, and src3 - overall value into which the bit field is inserted, providing all bits other than the inserted bits for the result value.
bfi dst src0 src1 src2 src3
// Translates to these two instructions:
bfi1 dst src0 src1
bfi2 dst dst src2 src3
Format:
[(pred)] bfi2 (exec_size) dst src0 src1 src2
bfrev
Bit Field Reverse
The bfrev instruction component-wise reverses all the bits in src0 and stores the results in dst.
Format:
[(pred)] bfrev (exec_size) dst src0
Branch Converging
The brc instruction redirects the execution forward or backward to the instruction pointed by (current IP + offset). The jump will occur if all channels are branched away.
UIP should reference the instruction where all channels are expected to come together. JIP should reference the end of the innermost conditional block.
In GEN binary, JIP and UIP are at location src1 when immediates and at location src0 when reg64, where reg64 is accessed as paired DWord (regioning being <2;2,1>). The ip register must be used (for example, by the assembler) as dst. When offsets are immediate, src0 must be null.
Format:
[(pred)] brc (exec_size) JIP UIP
Branch Diverging
The brd instruction redirects the execution forward or backward to the instruction pointed by (current IP + offset). The jump will occur if any channels are branched away.
In GEN binary, JIP is at location src1 when immediate and at location src0 when reg32, where reg32 is accessed as a scalar DWord. The ip register must be used (for example, by the assembler) as dst.
Format:
[(pred)] brd (exec_size) JIP
break
Break
The break instruction is used to early-out from the inner most loop, or early out from the inner most switch block.
When used in a loop, upon execution, the break instruction terminates the loop for all execution channels enabled. If all the enabled channels hit the break instruction, jump to the instruction referenced by JIP. JIP should be the offset to the end of the inner most conditional or loop block, UIP should be the offset to the while instruction of the loop block.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case
The following table describes the two 16-bit instruction pointer offsets. Both the JIP and UIP are signed 16-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at location src1 and must be of type W (signed word integer).
Format:
[(pred)] break (exec_size) JIP UIP
call
Call
The call instruction jumps to a subroutine. It can be predicated or non-predicated. If non-predicated, all enabled channels jump to the subroutine. If predicated, only the channels enabled by PMask jump to the subroutine; the rest of the channels move to the next instruction after the call instruction. If none of the channels jump into the subroutine, the call instruction is treated as a nop.
In case of a jump, the call instruction stores the return IP onto the first DWord of the destination register and stores the CallMask in the second DWord of the destination register.
When SPF is on, the predication control must be scalar.
The following section describes JIP, the jump offset, for DevHSW+.
JIP can be an immediate or register value. When a jump occurs, this value is added to IP pre-increment. For DevHSW+, in GEN binary, JIP is at location src1 and src0 must be null. The GRF register must be put (for example, by the assembler) at dst location.
Format: [(pred)] call (exec_size) dst JIP
Format: [(pred)] call (exec_size) dst JIP
calla
Call Absolute
The calla instruction jumps to a subroutine. It can be predicated or non-predicated. If non-predicated, all enabled channels jump to the subroutine. If predicated, only the channels enabled by PMask jump to the subroutine; the rest of the channels move to the next instruction after the calla instruction. If none of the channels jump into the subroutine, the calla instruction is treated as a nop.
In case of a jump, the call instruction stores the return IP onto the first DWord of the destination register and stores the CallMask in the second DWord of the destination register.
If SPF is ON, none of the PcIP are updated.
When SPF is on, the predication control must be scalar.
The difference between calla and call is that calla uses JIP as the IP value rather than adding it to the IP value.
Format: [(pred)] calla (exec_size) dst JIP
cbit
Count Bits Set
The cbit instruction counts component-wise the total bits set in src0 and stores the resulting counts in dst.
Format:
[(pred)] cbit (exec_size) dst src0
Compare
The cmp instruction performs component-wise comparison of src0 and src1 and stores the results in the selected flag register and in dst. It takes component-wise subtraction of src0 and src1, evaluating the conditional code (excluding NS signal) based on the conditional modifier, and storing the conditional bits in bit-packed form in the destination flag register and all bits of dst channels. If the dst is not null, for the enabled channels, then all bits of the destination channel will contain the flag value for the channel. When the instruction operates on packed word format, one general register may store up to 16 such comparison results. In DWord format, one general register may store up to 8 results.
A conditional modifier must be specified; the conditional modifier field cannot be 0000b. The comparison does not use the NS (NaN source) signals, as described in the Creating Conditional Flags section. Accordingly the conditional modifier should not be .u (unordered).
For each enabled channel 0b or 1b is assigned to the appropriate flag bit and 0/all zeros or all ones (e.g, byte 0xFF, word 0xFFFF, DWord 0xFFFFFFFF) is assigned to dst.
When any source type is floating-point, the cmp instruction obeys the rules described in the tables in the Floating Point Modes section of the Data Types chapter.
Format:
[(pred)] cmp[.cmod] (exec_size) dst src0 src1
cmpn
Compare NaN
The cmpn instruction performs component-wise special-NaN comparison of src0 and src1 and stores the results in the selected flag register and in dst. It takes component-wise subtraction of src0 and src1, evaluating the conditional signals including NS based on the conditional modifier, and storing the conditional flag bits in bit-packed form in the destination flag register and all bits of dst channels. If the dst is not null, for the enabled channels, then all bits of the destination channel will contain the flag value for the channel. When the instruction operates on packed word format, one general register may store up to 16 such comparison results. In DWord format, one general register may store up to 8 results.
A conditional modifier must be specified; the conditional modifier field cannot be 0000b. More information about the conditional signals used is in the Creating Conditional Flags section.
For each enabled channel 0b or 1b is assigned to the appropriate flag bit and 0/all zeros or all ones (e.g, byte 0xFF, word 0xFFFF, DWord 0xFFFFFFFF) is assigned to dst.
Min/Max instructions use cmpn to select the destination from the input sources (see the Min Max of Floating Point Numbers section for details).
Format:
[(pred)] cmpn[.cmod] (exec_size) dst src0 src1
cont
Continue
The cont instruction disables execution for the subset of channels for the remainder of the current loop iteration. Channels remain disabled until right before the while instuction or right before the condition check code block for the while instruction. If all enabled channels hit this instruction, jump to the instruction referenced by JIP where execution continues.
UIP should always reference the loop's associated while instruction. JIP should point to the last instruction of the inner most conditional block if the cont instruction is inside a conditional block. In case of the break instruction directly under the loop, the JIP and the UIP are the same.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the two 16-bit instruction pointer offsets. Both the JIP and UIP are signed 16-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at location src1 and must be of type W (signed word integer).
Format:
[(pred)] cont (exec_size) JIP UIP
Double Precision Floating Point Immediate Data Move
The dim instruction moves the 64-bit immediate value into enabled channels of dst.
Format:
[(pred)] dim[.cmod] (exec_size) dst src0
Dot Product 2
The dp2 instruction performs a two-wide dot product on four-tuple vector basis and storing the same scalar result per four tuple to all four channels in dst. This instruction is similar to dp4 except that every third and fourth element of src0 (post-source-swizzle if present) are not involved in the computation.
The dot product of two vectors of equal length is the sum of the products of each pair of corresponding elements.
The dp4 instruction includes all four elements of each vector in the dot product. The dp3 instruction includes the first three elements of each vector in the dot product.
Format:
[(pred)] dp2[.cmod] (exec_size) dst src0 src1
Dot Product 3
The dp3 instruction performs a three-wide dot product on four-tuple vector basis and storing the same scalar result per four tuple to all four channels in dst. This instruction is similar to dp4 except that every fourth element of src0 (post-source-swizzle if present) is not involved in the computation.
The dot product of two vectors of equal length is the sum of the products of each pair of corresponding elements.
The dp4 instruction includes all four elements of each vector in the dot product. The dp2 instruction includes the first two elements of each vector in the dot product.
Format:
[(pred)] dp3[.cmod] (exec_size) dst src0 src1
Dot Product 4
The dp4 instruction performs a four-wide dot product on four-tuple vector basis and storing the same scalar result per four tuple to all four channels in dst.
The dot product of two vectors of equal length is the sum of the products of each pair of corresponding elements.
Format:
[(pred)] dp4[.cmod] (exec_size) dst src0 src1
Dot Product Homogeneous
The dph instruction performs a four-wide homogeneous dot product on four-tuple vector basis and storing the same scalar result per four tuple to all four channels in dst. This instruction is similar to dp4 except that every fourth element of src0 (post-source-swizzle if present) is forced to 1.0f.
Use the dp4 instruction to do a four-wide dot product that includes all elements of src0 and src1.
Format:
[(pred)] dph[.cmod] (exec_size) dst src0 src1
else
Else
The else instruction is an optional statement within an if/else/endif block of code. It restricts execution within the else/endif portion to the opposite set of channels enabled under the if/else portion. Channels which were inactive before entering the if/endif block remain inactive throughout the entire block.
All enabled channels upon arriving at the else instruction are redirected to the matching endif. If all channels are redirected (by else or before else), a relative jump is performed to the location specified by JIP. The jump target should be the the matching endif instruction for that conditional block.
The following table describes the 16-bit JIP. In GEN binary, JIP is at location src1 and must be of type W (signed word integer). JIP must be an immediate operand, it is a signed 16-bit number and is intended to be forward referencing. This value is added to IP pre-increment.
Format:
else (exec_size) JIP
endif
End If
The endif instruction terminates an if/else/endif block of code. It restores execution to the channels that were active prior to the if/else/endif block.
The endif instruction is also used to hop out of nested conditionals by jumping to the end of the next outer conditional block when all channels are disabled.
The following table describes the 16-bit JIP. In GEN binary, JIP is at location src1 and must be of type W (signed word integer). JIP must be an immediate operand, it is a signed 16-bit number. This value is added to IP pre-increment.
Format:
endif JIP
f16to32
Half Precision Float to Single Precision Float
The f16to32 instruction converts the half precision float in src0 to single precision float and storing in dst.
Because this instruction does not have a 16-bit floating-point type, the source data type must be Word (W). The destination type must be F (Float).
Format:
[(pred)] f16to32[.cmod] (exec_size) dst src0
f32to16
Single Precision Float to Half Precision Float
The f32to16 instruction converts the single precision float in src0 to half precision float and storing in the lower word of each channel in dst.
Because this instruction does not have a 16-bit floating-point type, the destination data type must be Word (W).
Format:
[(pred)] f32to16[.cmod] (exec_size) dst src0
Find First Bit from MSB Side
If src0 is unsigned, the fbh instruction counts component-wise the leading zeros from src0 and stores the resulting counts in dst.
If src0 is signed and positive, the fbh instruction counts component-wise the leading zeros from src0 and stores the resulting counts in dst.
If src0 is signed and negative, the fbh instruction counts component-wise the leading ones from src0 and stores the resulting counts in dst.
Format:
[(pred)] fbh (exec_size) dst src0
If src0 is zero, store 0xFFFFFFFF in dst.
If src0 is signed and is -1 (0xFFFFFFFF), store 0xFFFFFFFF in dst.
Find First Bit from LSB Side
The fbl instruction counts component-wise the number of LSB 0 bits before the first 1 bit in src0, storing that number in dst.
Format:
[(pred)] fbl (exec_size) dst src0
If src0 contains no 1 bits, store 0xFFFFFFFF in dst.
Fraction
The frc instruction computes, component-wise, the truncate-to-minus-infinity fractional values of src0 and stores the results in dst. The results, in the range of [0.0, 1.0], are the fractional portion of the source data. The result is in the range [0.0, 1.0] irrespective of the rounding mode. Floating-point fraction computation follows the rules in the following tables, based on the current floating-point mode.
Format:
[(pred)] frc[.cmod] (exec_size) dst src0
halt
Halt
The halt instruction temporarily suspends execution for all enabled compute channels. Upon execution, the enabled channels are sent to the instruction at (IP + UIP), if all channels are enabled at HALT, jump to the instruction at (IP + JIP).
If the halt instruction is not inside any conditional code block, the values of JIP and UIP should be the same. If the halt instruction is inside a conditional code block, the UIP should be the end of the program and the JIP should be the end of the inner most conditional code block.
The UIP must point to a HALT Instruction.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the two 16-bit instruction pointer offsets. Both the JIP and UIP are signed 16-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at location src1 and must be of type W (signed word integer).
Format:
[(pred)] halt (exec_size) JIP UIP
An if instruction starts an if/endif or an if/else/endif block of code. It restricts execution within the conditional block to only those channels that were enabled via the predicate control.
Each if instruction must have a matching endif instruction and may have up to one matching else instruction before the matching endif.
If all channels are inactive (for the if/endif or if/else/endif block), a jump is performed to the instruction referenced by JIP. This jump must be to right after the matching else instruction when present, or otherwise to the matching endif instruction of the conditional block.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the two 16-bit instruction pointer offsets. Both the JIP and UIP are signed 16-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at location src1 and must be of type W (signed word integer).
Format:
[(pred)] if (exec_size) JIP UIP
illegal
Illegal
The Illegal Opcode Exception Enable flag in cr0.1 is normally set so the normal processing of an illegal opcode is to transfer control to the System Routine.
Instruction dispatch treats any unused 8-bit opcode (including bit 7 of the instruction, reserved for future opcode expansion) as if it is the illegal opcode.
The illegal opcode is zero because that byte value is more likely than most to be read via a wayward instruction pointer.
The illegal instruction is an instruction only in the same way that a NULL pointer in software is a pointer. Both are special values indicating invalid instances.
Format:
illegal
jmpi
Jump Indexed
The jmpi instruction redirects program execution to an index offset relative to the post-incremented instruction pointer. The index is a signed integer value, with positive or zero integers for forward jumps, and negative integers for backward jumps. In GEN binary, index is at location src1. The ip register must be put (for example, by the assembler) at the dst and src0 locations. Predication is allowed to provide conditional jump with a scalar condition. As the execution size is 1, the first channel of PMASK (flags post prediction control and negate) is used to determine whether the jump is taken or not. If the condition is false, the jump is not taken and execution continues with the next instruction.
Note: Unlike other flow control instructions, the offset used by jmpi is relative to the incremented instruction pointer rather than the IP value for the instruction itself.
Format:
[(pred)] jmpi (1) index {NoMask}
An index of 0 does nothing, continuing execution with the next instruction.
An index of -16 (if the jmpi instruction is in native format) or -8 (if the jmpi instruction is in compact format) is an infinite loop on the jmpi instruction.
line
Line
The line instruction computes a component-wise line equation (v = p * u + q where u, v are vectors and p, q are scalars) of src0 and src1 and stores the results in dst. src1 is the input vector u. src0 provides input scalars p and q, where p is the scalar value based on the region description of src0 and q is the scalar value implied from src0 region. Specifically, q is the fourth component of the 4-tuple (128-bit aligned) that p belongs to.
Format:
[(pred)] line[.cmod] (exec_size) dst src0 src1
Linear Interpolation
The lrp instruction takes component-wise multiplication of src0 and src1, and adds the result to the component-wise multiplication of src2 and (1 - src0), and then stores the final results in dst.
Format:
[(pred)] lrp[.cmod] (exec_size) dst src0 src1 src2
Leading Zero Detection
The lzd instruction counts component-wise the leading zeros from src0 and stores the resulting counts in dst.
If src0 is zero, store 32 in dst.
Format:
[(pred)] lzd[.cmod] (exec_size) dst src0
Multiply Accumulate
The mac instruction takes component-wise multiplication of src0 and src1, adds the results with the corresponding accumulator values, and then stores the final results in dst.
Format:
[(pred)] mac[.cmod] (exec_size) dst src0 src1
mach
Multiply Accumulate High
The mach instruction performs DWord integer multiply-accumulate operation and outputs the high DWord (bits 63:32). For each enabled channel, this instruction multiplies the DWord in src1 with the high word of the DWord in src0, left shifts the result by 16 bits, adds it with the corresponding accumulator values, and keeps the whole 64-bit result in the accumulator. It then stores the high DWord (bits 63:32) of the results in dst.
This instruction is intended to be used to emulate 32-bit DWord integer multiplication by using the large number of bits available in the accumulator. For example, the following four instructions perform vector multiplication of two 32-bit signed integer sources from r2 and r3 and store the resulting vectors with the high 32 bits in r5 and the low 32 bits in r6.
mul (8) acc0:d r2.0<8;8,1>:d r3.0<8;8,1>:d //All channels must be enabled
mach (8) rTemp<1>:d r2.0<8;8,1>:d r3.0<8;8,1>:d //All channels must be enabled
mov (8) r5.0<1>:d rTemp<8;8,1>:d // High 32 bits
mov (8) r6.0<1>:d acc0:d // Low 32 bits
The mul and mach instructions must have all channels enabled. The first mov should have channel enable from the destHI of IMUL, the second mov should have the channel enable from the destLO of IMUL. As mach is used to generate part of the 64-bit DWord integer results, saturation modifier should not be used. In fact, saturation modifier should not be used for any of these four instructions. Source and destination operands must be DWord integers. Source and destination must be of the same type, signed integer or unsigned integer. If dst is UD, src0 and src1 may be UD and/or D. However, if any of src0 and src1 is D, source modifier (abs) must be present to convert it to match with dst. If dst is D, src0 and src1 must also be D. They cannot be UD as it may cause unexpected overflow because the computed results are limited to 64 bits.
Format:
[(pred)] mach[.cmod] (exec_size) dst src0 src1
Multiply Add
The mad instruction takes component-wise multiplication of src1 and src2, adds the results with the corresponding src0 values, and then stores the final results in dst.
The conditional modifier and saturation (.sat) must not be used when src1 or src2 are dwords.
Format:
[(pred)] mad[.cmod] (exec_size) dst src0 src1 src2
math
Extended Math Function
The math instruction performs extended math function on the components in src0, or src0 and src1, and write the output to the channels of dst. The type of extended math function are based on the FC[3:0] encoding in the table below.
Format:
[(pred)] math (exec_size) dst src0 src1 <FC>
MathFC[3:0]
math.cos
Cosine function. cos(src0)
math.exp
Exponential (E^src0)
fdiv
math.fdiv
FDIV
Floating-Point Divide function. src0/src1
idiv
math.idiv
IDIV
Integer Divide with Quotient and Remainder. The quotient goes in the destination register; the remainder goes in the following register.
math.inv
Reciprocal (Multiplicative Inverse): 1/src0
iqot
math.iqot
IQOT
Integer Quotient only
irem
math.irem
IREM
Integer Remainder only
math.log
Natural log: ln(src0)
math.pow
src0^src1
rsqt
math.rsqt
RSQT
Reciprocal Square Root: 1/sqt(src)
math.sin
Sine function. sin(src0)
math.sqt
Square Root
Move
The mov instruction moves the components in src0 into the channels of dst. If src0 and dst are of different types, format conversion is performed. If src0 is a scalar immediate, the immediate value is loaded into enabled channels of dst.
A mov with the same source and destination type, no source modifier, and no saturation is a raw move. A packed byte destination region (B or UB type with HorzStride == 1 and ExecSize > 1) can only be written using raw move.
When denorm mode is flush to zero, a raw mov instruction with saturation modifier will not flush the denorm input or output to zero (Denorm is preserved).
Format: [(pred)] mov[.cmod] (exec_size) dst src0
A mov instruction with a source modifier always copies a denorm source value to a denorm destination value
(in the manner of a raw move).
There is no direct conversion from B/UB to DF or DF to B/UB. Use two instructions and a word or DWord intermediate type.
movi
Move Indexed
The movi instruction performs a fast component-wise indexed move for subfields from src0 to dst. The source
operand must be an indirectly-addressed register. All channels of the source operand share the same register
number, which is provided by the register field of the first address subregister, with a possible immediate
register offset. The register fields of the subsequent address subregisters are ignored by hardware. The
subregister number of a source channel is provided by the subregister field of the corresponding address
subregister, with a possible immediate subregister offset.
The destination register may be either a directly-addressed or an indirectly-addressed register.
This instruction effectively performs a subfield shuffling from one register to another. Up to eight
subfields can be selected by an instruction.
Format: [(pred)] movi (exec_size) dst src0
HW Implementation Details:
The source register is calculated by adding the register portion of the first index register with the
register portion of the address immediate, a0.0[11:5] + addr_imm[9:5]
For byte movi, byte0 of the destination is selected by (a0.0[4:0]), byte1 is selected by (a0.1[4:0]), ...,
and byte7 is selected by (a0.7[4:0]). The rest of the bytes are undefined.
For word movi, byte0 of the destination is selected by (a0.0[4:1] & 0), byte1 is selected by (a0.0[4:1]
& 1), byte2 is selected by (a0.1[4:1] & 0), byte3 is selected by (a0.1[4:1] & 1), ..., and byte15
is selected by (a0.7[4:1] & 1). The rest of the bytes are undefined.
For DWord or float movi, byte0 of the destination is selected by (a0.0[4:2] & 00b), byte1 is selected
by (a0.0[4:2] & 01b), byte2 is selected by (a0.0[4:2] & 10b), byte3 is selected by (a0.0[4:2] &
11b), byte4 is selected by (a0.1[4:2] & 00b), byte5 is selected by (a0.1[4:2] & 01b), ..., byte31
is selected by (a0.7[4:2] & 11b).
For all 3 conditions above, a0.n[4:0] = a0.n[4:0] + addr_imm[4:0].
Multiply
The mul instruction performs component-wise multiplication of src0 and src1 and stores the results in dst.
When both src0 and src1 are of type D or UD, only the low 16 bits of each element of src1 are used. The accumulator maintains full 48-bit precision. The macro described in the mach instruction should be used to obtain the full precision 64-bit multiplication result.
Multiplication of two floating-point numbers follows the rules in mul - Multiply [Pre-DevBDW] or mul - Multiply [Pre-DevBDW]) based on the applicable floating-point mode.
Format:
[(pred)] mul[.cmod] (exec_size) dst src0 src1
No Operation
Do nothing. The nop instruction takes an instruction dispatch but performs no operation. It can be used for assembly patching in memory, or to insert a delay in the program sequence.
Format:
Logic Not
The not instruction performs logical NOT operation (or one's complement) of src0 and storing the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
A register source operand can use a source modifier:
Any source modifier is numeric, optionally changing a source value s to -s, abs(s), or -abs(s) before the NOT operation.
Format:
[(pred)] not[.cmod] (exec_size) dst src0
Logic Or
The or instruction performs component-wise logic OR operation between src0 and src1 and stores the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
Register source operands can use source modifiers:
Any source modifier is numeric, optionally changing a source value s to -s, abs(s), or -abs(s) before the OR operation.
Format:
[(pred)] or[.cmod] (exec_size) dst src0 src1
Plane
The pln instruction computes a component-wise plane equation (w = p*u+q*v+r where u/v/w are vectors and p/q/r are scalars) of src0 and src1 and stores the results in dst. src1 is the input vector u.
src0 provides input scalars p, q, and r, where p is the scalar value based on the region description of src0 and q and r are the scalar values implied from the src0 region. Specifically, q is the second component and r is the fourth component of the 4-tuple (128-bit aligned) that p belongs to.
Format:
[(pred)] pln[.cmod] (exec_size) dst src0 src1
Return
Return execution to the code sequence that called a subroutine.
The ret instruction can be predicated or non-predicated. If non-predicated, all channels jump to the return IP in the first channel of src0 and restore CallMask from the second channel of src0. If predicated, the enabled channels jump to the return IP from the first channel of src0 and the corresponding bits in the CallMask are cleared to zero; if all CallMask bits are zero after the ret instruction, then execution jumps to the return IP from the first channel of src0.
When SPF is on, the predication control must be scalar.
Format:
[(pred)] ret (exec_size) null src0
rndd
Round Down
The rndd instruction takes component-wise floating point downward rounding (to the integral float number closer to negative infinity) of src0 and storing the rounded integral float results in dst. This is commonly referred to as the floor() function.
Each result follows the rules in the following tables based on the floating-point mode.
Format:
[(pred)] rndd[.cmod] (exec_size) dst src0
rnde
Round to Nearest or Even
The rnde instruction takes component-wise floating point round-to-even operation of src0 with results in two pieces - a downward rounded integral float results stored in dst and the round-to-even increments stored in the rounding increment bits. The round-to-even increment must be added to the results in dst to create the final round-to-even values to emulate the round-to-even operation, commonly known as the round() function. The final results are the one of the two integral float values that is nearer to the input values. If the neither possibility is nearer, the even alternative is chosen.
Each result follows the rules in the following tables based on the floating-point mode.
Format:
[(pred)] rnde[.cmod] (exec_size) dst src0
rndu
Round Up
The rndu instruction takes component-wise floating point upward rounding (to the integral float number closer to positive infinity) of src0, commonly known as the ceiling() function.
Each result follows the rules in the following tables based on the floating-point mode.
Format:
[(pred)] rndu[.cmod] (exec_size) dst src0
rndz
Round to Zero
The rndz instruction takes component-wise floating point round-to-zero operation of src0 with results in two pieces - a downward rounded integral float results stored in dst and the round-to-zero increments stored in the rounding increment bits. The round-to-zero increment must be added to the results in dst to create the final round-to-zero values to emulate the round-to-zero operation, commonly known as the truncate() function. The final results are the one of the two closest integral float values to the input values that is nearer to zero.
Format:
[(pred)] rndz[.cmod] (exec_size) dst src0
sad2
Sum of Absolute Difference 2
The sad2 instruction takes source data channels from src0 and src1 in groups of 2-tuples. For each 2-tuple, it computes the sum-of-absolute-difference (SAD) between src0 and src1 and stores the scalar result in the first channel of the 2-tuple in dst.
The results are also stored in the accumulator register. The destination operand and the accumulator maintain 16 bits per channel precision.
The destination register must be aligned to even word (DWord). The even words in the destination region will contain the correct data. The odd words are also written but with undefined values.
Format:
[(pred)] sad2[.cmod] (exec_size) dst src0 src1
sada2
Sum of Absolute Difference Accumulate 2
The sada2 instruction takes source data channels from src0 and src1 in groups of 2-tuples. For each 2-tuple, it computes the sum-of-absolute-difference (SAD) between src0 and src1, adds the intermediate result with the accumulator value corresponding to the first channel, and stores the scalar result in the first channel of the 2-tuple in dst.
The destination operand and the accumulator maintain 16 bits per channel precision. Higher precision (guide bits) stored in the accumulator allows up to 64 rounds of sada2 instructions to be issued back to back without overflowing the accumulator.
The destination register must be aligned to even word (DWord). The even words in the destination region will contain the correct data. The odd words are also written but with undefined values.
Format:
[(pred)] sada2[.cmod] (exec_size) dst src0 src1
Select
The sel instruction selectively moves the components in src0 or src1 into the channels of dst based on the predication. On a channel by channel basis, if the channel condition is true, data in src0 is moved into dst. Otherwise, data in src1 is moved into dst.
As the predication is used to select the two sources, it is not included in the evaluation of WrEn. The predicate clause is mandatory if cmod is omitted/0000b. If both predication and the conditional modifier are omitted, the results are undefined.
If the conditional modifier is specified (not 0000b, a compare is performed and the resulting condition flag is used for the sel instruction. Conditional modifiers .ge and .l follow the cmpn rules, and all other conditional modifiers follow the cmp rules. Predication is not allowed in this mode.
A sel instruction with cmod .l is used to emulate a MIN instruction.
A sel instruction with cmod .ge is used to emulate a MAX instruction.
For a sel instruction with a .l or .ge conditional modifier, if one source is NaN and the other not NaN, the non-NaN source is the result. If both sources are NaNs, the result is NaN. For all other conditional modifiers, if either source is NaN then src1 is selected.
A sel instruction without a conditional modifier always copies a denorm source value to a denorm destination value (in the manner of a raw move). This applies even if the source modifies are set on the sel instruction sources.
The sel instruction uses any conditional modifier internally and does not update the flag register if a conditional modifier is used.
A sel instruction with a conditional modifier flushes any selected denorm source value to a zero destination value.
Format:
(pred) sel[.cmod] (exec_size) dst src0 src1
send
Send Message
Send a message stored in GRF starting at <src> to a shared function identified by <ex_desc> along with control from <desc> with a GRF writeback location at <dest>.
The send instruction performs data communication between a thread and external function units, including shared functions (Sampler, Data Port Read, Data Port Write, URB, and Message Gateway) and some fixed functions (e.g. Thread Spawner, who also have an unique Shared Function ID). The send instruction adds an entry to the EU's message request queue. The request message is stored in a block of contiguous GRF registers. The response message, if present, will be returned to a block of contiguous GRF registers. The return GRF writes may be in any order depending on the external function units. <src> is the lead GRF register for request. <dest> is the lead GRF register for response. The message descriptor field <desc> contains the Message Length (the number of consecutive GRF registers) and the Response Length (the number of consecutive GRF registers). It also contains the header present bit, and the function control signals. The extend mesage descriptor field <ex_desc> contains the target function ID. WrEn is forwarded to the target function in the message sideband.
The send instruction is the only way to terminate a thread. When the EOT (End of Thread) bit of <ex_desc> is set, it indicates the end of thread to the EU, the Thread Dispatcher and, in most cases, the parent fixed function.
Message descriptor field <desc> can be a 32-bit immediate, imm32, or a 32-bit scalar register, <reg32a>. GEN restricts that the 32-bit scalar register <reg32a> must be the leading dword of the address register. It should be in the form of a0.0<0;1,0>:ud. When <desc> is a register operand, only the lower 29 bits of <reg32a> are used.
<ex_desc> is a 6-bit immediate, imm6. The lower 4bits of the <ex_desc> specifies the SFID for the message. The MSb of the message descriptor, the EOT field, always comes from bit 127 of the instruction word, which is the MSb of imm6. A thread must terminate with a send instruction with EOT turned on.
<src> is a 256-bit aligned GRF register. It serves as the leading GRF register of the request.
<dest> serves for two purposes: to provide the leading GRF register location for the response message if present, and to provide parameters to form the channel enable sideband signals.
<dest> signals whether there is a response to the message request. It can be either a null register, a direct-addressed GRF register or a register-indirect GRF register. Otherwise, hardware behavior is undefined.
If <dest> is null, there is no response to the request. Meanwhile, the Response Length field in <desc> must be 0. Certain types of message requests, such as memory write (store) through the Data Port, do not want response data from the function unit. If so, the posted destination operand can be null.
If <dest> is a GRF register, the register number is forwarded to the shared function. In this case, the target function unit must send one or more response message phases back to the requesting thread. The number of response message phases must match the Response Length field in <desc>, which of course cannot be zero. For some cases, it could be an empty return message. An empty return message is defined as a single phase message with all channel enables turned off.
The subregister number, horizontal stride, destination mask and type fields of <dest> are always valid and are used in part to generate on the WrEn. This is true even if <dest> is a null register (this is an exception for null as for most cases these fields are ignored by hardware).
The 16-bit channel enables of the message sideband are formed based on the WrEn. Interpretation of the channel enable sideband signals is subject to the target external function. In general for a 'send' instruction with return messages, they are used as the destination dword write mask for the GRF registers starting at <dest>. For a message that has multiple return phases, the same set of channel enable signals applies to all the return phases.
Thread managed memory coherency: A special usage of using non-null <dest> is to support write-commit signaling for memory write service by the Data Port Write unit. If <post_dest> is not null for a memory write request, the Data Port along with the Data Cache or Render Cache will wait until all the posted writes for the request have reached the coherent domain before sending back to the requesting thread an empty message to <dest> register. A memory write reaching the coherent domain, also referred to as reaching the global observable state, means that subsequent read to the same memory location, no matter which thread issues the read, must return the data of the write.
The destination dependency control, {NoDDClr}, can be used in this instruction. This allows software to control the destination dependencies for multiple 'read'-type messages similar to that for multiple instructions using EU execution pipeline. As send does not check register dependencies for the post destination, {NoDDChk} should not be used for this instruction.
sendc
Conditional Send Message
The sendc instruction has the same behavior as the send instruction except the following.
sendc first checks the dependent threads inside the Thread Dependency Register. There are up to 8 dependent threads in the TDR register. The sendc instruction executes only when all the dependent threads in the TDR register are retired.
Wait for dependencies in the TDR Register to clear, then send a message stored in registers starting at src to a shared function identified by exdesc along with control from desc with a general register writeback location at dst.
Format:
[(pred)] sendc (exec_size) dst src0 exdesc desc
Shift Left
Perform component-wise logical left shift of the bits in src0 by the shift count indicated in src1, storing the results in dst, inserting zero bits in the number of LSBs indicated by the shift count.
Hardware detects overflow properly and uses it to perform any saturation operation on the result, as long as the shifted result is within 33 bits. Otherwise, the result is undefined.
Note: For word and DWord operands, the accumulators have 33 bits.
The shift count is taken from the low five bits of src1, regardless of the src1 type and treated as an unsigned integer in the range 0 to 31.
Format:
[(pred)] shl[.cmod] (exec_size) dst src0 src1
Shift Right
Perform component-wise logical right shift with zero insertion of the bits in src0 by the shift count indicated in src1, storing the results in dst. Insert zero bits in the number of MSBs indicated by the shift count.
src0 and dst can have different types and can be signed or unsigned.
Note: For word and DWord operands, the accumulators have 33 bits.
Note: For unsigned src0 types, shr and asr produce the same result.
The shift count is taken from the low five bits of src1, regardless of the src1 type and treated as an unsigned integer in the range 0 to 31.
Format:
[(pred)] shr[.cmod] (exec_size) dst src0 src1
subb
Integer Subtraction with Borrow
The subb instruction performs component-wise subtraction of src0 and src1 and stores the results in dst, it also stores the borrow into acc.
If the operation produces a borrow (src0 < src1), write 0x00000001 to acc, else write 0x00000000 to acc.
Format:
[(pred)] subb[.cmod] (exec_size) dst src0 src1
wait
Wait Notification
The wait instruction evaluates the value of the notification count register nreg. If nreg is zero, thread execution is suspended and the thread is put in 'wait_for_notification' state. If nreg is not zero (i.e., one or more notifications have been received), nreg is decremented by one and the thread continues executing on the next instruction. If a thread is in the 'wait_for_notification' state, when a notification arrives, the notification count register is incremented by one. As the notification count register becomes nonzero, the thread wakes up to continue execution and at the same time the notification register is decremented by one. If only one notification arrived, the notification register value becomes zero. However, during the above mentioned time period, it is possible that more notifications may arrive, making the notification register nonzero again.
When multiple notifications are received, software must use wait instructions to decrement notification count registers for each notification.
Notification register n0.0:ud is for thread to thread communication (via the Message Gateway shared function) and n0.1:ud for host to thread communication (through MMIO registers). See the Message Gateway chapter for thread-thread communication and the Debug chapter for host-to-thread communication.
Format:
wait (exec_size) nreg
while
While
The while instruction marks the end of a do-while block. The instruction first evaluates the loop termination condition for each channel based on the current channel enables and the predication flags specified in the instruction. If any channel has not terminated, a branch is taken to a destination address specified in the instruction, and the loop continues for those channels. Otherwise, execution continues to the next instruction.ld point to the first instruction with the do label of the do-while block of code. It should be a negative number for the backward referencing.
If SPF is ON, none of the PcIP are updated.
The following table describes the 16-bit jump target offset JIP. JIP is a signed 16-bit number, added to IP pre-increment, and should point to the first instruction with the do label of the do-while block of code. It should be a negative number for the backward referencing. In GEN binary, JIP is at location src1 and must be of type W (signed word integer).
Format:
[(pred)] while (exec_size) JIP
Logic Xor
The xor instruction performs component-wise logic XOR operation between src0 and src1 and stores the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
Register source operands can use source modifiers:
Any source modifier is numeric, optionally changing a source value s to -s, abs(s), or -abs(s) before the XOR operation.
Format:
[(pred)] xor[.cmod] (exec_size) dst src0 src1
The bfi1 instruction is the first instruction in a two-instruction macro for bfi (Bit Field Insert).
The bfi1 instruction component-wise generates mask with control from src0 and src1 and stores the results in dst. The mask is used in the bfi2 instruction to generate the final result of bfi.
Create a bit mask corresponding to the bit field width and offset in src0 and src1. Store the bit mask in dst. The mask has all bits in the bit field set to 1 and all other bits as 0.
The width and offset values are from the low five bits of src0 and src1 respectively, or src0 & 0x1f and src1 & 0x1f.
If width is zero, the result is zero.
The bfi macro has four source operands: src0 - bit field width in low five bits, src1 - bit field offset/starting bit position in low five bits, src2 - bit field value to insert, using only the number of least significant bits given by width in src0, and src3 - overall value into which the bit field is inserted, providing all bits other than the inserted bits for the result value.
bfi dst src0 src1 src2 src3
// Translates to these two instructions:
bfi1 dst src0 src1
bfi2 dst dst src2 src3
Format:
[(pred)] bfi1 (exec_size) dst src0 src1
No accumulator access, implicit or explicit.
The brc instruction redirects the execution forward or backward to the instruction pointed by (current IP + offset). The jump will occur if all channels are branched away.
UIP should reference the instruction where all channels are expected to come together. JIP should reference the end of the innermost conditional block.
In GEN binary, JIP and UIP use locations src1 and src0 respectively when immediate and location src0 when reg64, where reg64 is accessed as paired DWord (regioning being <2;2,1>). dst must be IP. When the offsets are immediate, src0 regfile must be immediate.
Format:
[(pred)] brc (exec_size) JIP UIP
The break instruction is used to early-out from the inner most loop, or early out from the inner most switch block.
When used in a loop, upon execution, the break instruction terminates the loop for all execution channels enabled. If all the enabled channels hit the break instruction, jump to the instruction referenced by JIP. JIP should be the offset to the end of the inner most conditional or loop block, UIP should be the offset to the while instruction of the loop block.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case
The following table describes the two 32-bit instruction pointer offsets. Both the JIP and UIP are signed 32-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at locations src0 and src1 and must be of type DW (signed DWord integer). When the offsets are immediate, src0 regfile must be immediate.
Format:
[(pred)] break (exec_size) JIP UIP
The cont instruction disables execution for the subset of channels for the remainder of the current loop iteration. Channels remain disabled until right before the while instuction or right before the condition check code block for the while instruction. If all enabled channels hit this instruction, jump to the instruction referenced by JIP where execution continues.
UIP should always reference the loop's associated while instruction. JIP should point to the last instruction of the inner most conditional block if the cont instruction is inside a conditional block. In case of the break instruction directly under the loop, the JIP and the UIP are the same.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the two 32-bit instruction pointer offsets. Both the JIP and UIP are signed 32-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at locations src0 and src1 and must be of type DW (signed DWord integer). When the offsets are immediate, src0 regfile must be immediate.
Format:
[(pred)] cont (exec_size) JIP UIP
csel
Conditional Select
The csel instruction selectively moves components in src0 or src1 to the dst based on the result of the compare of src2 with zero. If the channel condition is true, data in src0 is moved into dst. Otherwise, data in src1 is moved into dst. The csel instruction provides the function of a cmp followed by sel. The instruction must not be used if cmpn is required. The instruction does not update the flag register.
The comparison follows the same rule as cmp instruction for that data type.
Format:
csel (exec_size) dst src0 src1 src2
The else instruction is an optional statement within an if/else/endif block of code. It restricts execution within the else/endif portion to the opposite set of channels enabled under the if/else portion. Channels which were inactive prior to entering the if/endif block remain inactive throughout the entire block.
All enabled channels upon arriving the else instruction will be redirected to the matching endif. If all channels are redirected (by else or before else), a relative jump is performed to the location specified by  <JIP>. The jump target should be the matching endif instruction for that conditional block.
The following table describes the 32-bit <JIP>. In GEN binary, <JIP> is at location <src1> and must be of type D (signed dword integer). <JIP> must be an immediate operand, it is a signed 32-bit number and is intended to be forward referencing. This value is added to IP pre-increment.
If the <branch_ctrl> bit is set, then the <JIP> points to the first join instruction within the else block and <UIP> points to the endif instruction. If the <branch_ctrl> bit is not set,  <JIP> and <UIP>, both point to endif.
Format:
else (exec_size) JIP  UIP  branch_ctrl
An else instruction must not be followed by any instruction requiring register indirect access on source operands
If all channels are redirected (by else or before else), relative jump is performed to the location specified by <JIP> + 1.
The endif instruction terminates an if/else/endif block of code. It restores execution to the channels that were active prior to the if/else/endif block.
The endif instruction is also used to hop out of nested conditionals by jumping to the end of the next outer conditional block when all channels are disabled.
The following table describes the 32-bit JIP. In GEN binary, JIP is at location src1 and must be of type D (signed DWord integer). JIP must be an immediate operand, it is a signed 32-bit number. This value is added to IP pre-increment.
Format:
endif JIP
goto
Goto
The goto instruction directs the instruction pointer to the offset specified by the UIP offset or to the next IP based on the BranchCtrl bit in the instruction. The active channels that are predicated on this instruction will take the IP + UIP path when BranchCtrl is set else the channels take IP + 1. The active channels that are not predicated on this instruction will be made inactive and waiting to be joined at the join IP. The join IP is IP + UIP when BranchCtrl is clear else it is the next IP.
When there are no active channels the instruction pointer will move to IP + JIP.
The goto instruction is used in conjunction with a join instruction. A goto deactivates some channels that are reactivated at some program-specified join instruction. See the join instruction for the activation rules.
The goto and join instructions enable unstructured program control flow. These instructions must be used with additional care where dangling channels can result without proper compiler checks, meaning that it is expected that programs will navigate through these paths to reactivate the channels. Hardware does not provide native checks or reconvergence.
The following table describes the two 32-bit instruction pointer offsets. Both the JIP and UIP are signed 32-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at locations src0 and src1 and must be of type DW (signed DWord integer).
If SPF is ON, none of the PcIP are updated.
Format:
[(pred)] goto (exec_size) JIP UIP branch_ctrl
The halt instruction temporarily suspends execution for all enabled compute channels. Upon execution, the enabled channels are sent to the instruction at (IP + UIP), if all channels are enabled at HALT, jump to the instruction at (IP + JIP).
If the halt instruction is not inside any conditional code block, the values of JIP and UIP should be the same. If the halt instruction is inside a conditional code block, the UIP should be the end of the program and the JIP should be the end of the inner most conditional code block.
The UIP must point to a HALT Instruction.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the two 32-bit instruction pointer offsets. Both the JIP and UIP are signed 32-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at locations src0 and src1 and must be of type DW (signed DWord integer). When the offsets are immediate, src0 regfile must be immediate and dst must be null.
Format:
[(pred)] halt (exec_size) JIP UIP
An if instruction starts an if/endif or an if/else/endif block of code. It restricts execution within the conditional block to only those channels that were enabled via the predicate control.
Each if instruction must have a matching endif instruction and may have up to one matching else instruction before the matching endif.
If all channels are inactive (for the if/endif or if/else/endif block), a jump is performed to the instruction referenced by JIP. This jump must be to right after the matching else instruction when present, or otherwise to the matching endif instruction of the conditional block.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the 32-bit exit code <JIP> and <UIP>. If <branch_ctrl> is set, then the JIP points to the first join instruction within the if block. If <branch_ctrl> is not set, <JIP> should point to the instruction right after the matching else instruction if it exsits, otherwise <JIP> should point to the endif instruction. <UIP> should always point to the endif instruction. When a jump occurs, this value is added to IP pre-increment. In GEN instruction binary, <JIP> and <UIP> are at location <src0> & <src1> and must be of type D (signed dword integer).
Format:
[(pred)] if (exec_size JIP UIP <branch_ctrl>
join
Join
The join instruction makes the inactive channels active at the join IP if those channels are predicated. Any deactivated channels due to a goto instruction match the join IP are activated (qualified with predicates at join). If no IP is matched at this join, the program goes to the next IP with the active channels which followed the program path up to the join instruction. If no active channels are present after executing the join instruction, the program jumps to the offset specified by JIP instead of next IP.
The join instruction is used in conjunction with a goto instruction. The join activates channels that are deactivated by the goto instruction. See the goto instruction for the deactivation rules.
The goto and join instructions enable unstructured program control flow. These instructions must be used with additional care where dangling channels can result without proper compiler checks, meaning that it is expected that programs will navigate through these paths to reactivate the channels. Hardware does not provide native checks or reconvergence.
The following table describes the 32-bit JIP. In GEN binary, JIP is at location src1 and must be of type D (signed DWord integer). JIP must be an immediate operand and is a signed 32-bit number. This value is added to IP pre-increment.
If SPF is ON, none of the PcIP are updated.
Format:
[(pred)] join (exec_size) JIP
An index of 0 is an infinite loop.
The mach instruction performs DWord integer multiply-accumulate operation and outputs the high DWord (bits 63:32). For each enabled channel, this instruction multiplies the DWord in src0 with the high word of the DWord in src1, left shifts the result by 16 bits, adds it with the corresponding accumulator values, and keeps the whole 64-bit result in the accumulator. It then stores the high DWord (bits 63:32) of the results in dst. This instruction is intended to be used to emulate 32-bit DWord integer multiplication by using the large number of bits available in the accumulator. For example, the following instructions perform vector multiplication of two 32-bit signed integer sources from r2 and r3 and store the resulting vectors with the high 32 bits in r5 and the low 32 bits in r6.
mul (8) acc0:d r2.0<8;8,1>:d r3.0<16;8,2>:uw
mach (8) r5.0<1>:d r2.0<8;8,1>:d r3.0<8;8,1>:d
mov (8) r6.0<1>:d acc0:d // Low 32 bits.
Here is a different example including negation. An added preliminary mov is required for source modification on src1.
mov (8) r3.0<1>:d -r3<8;8,1>:d
mul (8) acc0:d r2.0<8;8,1>:d r3.0<16;8,2>:uw
mach (8) r5.0<1>:d r2.0<8;8,1>:d r3.0<8;8,1>:d // High 32 bits
mov (8) r6.0<1>:d acc0:d // Low 32 bits.
The mach should have channel enable from the destHI of IMUL, the mov should have the channel enable from the destLO of IMUL. As mach is used to generate part of the 64-bit DWord integer results, saturation modifier should not be used. In fact, saturation modifier should not be used for any of these four instructions. Source and destination operands must be DWord integers. Source and destination must be of the same type, signed integer or unsigned integer. If dst is UD, src0 and src1 may be UD and/or D. However, if any of src0 and src1 is D, source modifier (abs) must be present to convert it to match with dst. If dst is D, src0 and src1 must also be D. They cannot be UD as it may cause unexpected overflow because the computed results are limited to 64 bits.
Format:
[(pred)] mach[.cmod] (exec_size) dst src0 src1
madm
Multiply Add for Macro
The madm instruction takes component-wise multiplication of src1 and src2, adds the results with the corresponding src0 values, and then stores the final results in dst.
The source and destination operands have a higher precision carried in the exponent for this operation. The madm instruction is used for macro operations, where precision is accumulated over several instructions. This accumulation requires the exponent to increase by 2 extra bits across multiple madm operations.
Refer to Macros Defined in 'Math' Section for usage and restrictions of this operation.
Format:
[(pred)] madm[.cmod] (exec_size) dst src0 src1 src2
invm
math.invm
INVM
Reciprocal Macro for IEEE754-compliant fdiv
rsqtm
math.rsqtm
RSQTM
Reciprocal Square Root Macro for IEEE754-compliant rsqt
The mov instruction moves the components in src0 into the channels of dst. If src0 and dst are of different types, format conversion is performed. If src0 is a scalar immediate, the immediate value is loaded into enabled channels of dst.
A mov with the same source and destination type, no source modifier, and no saturation is a raw move. A packed byte destination region (B or UB type with HorzStride == 1 and ExecSize > 1) can only be written using raw move.
When denorm mode is flush to zero, a raw mov instruction with saturation modifier will not flush the denorm input or output to zero (Denorm is preserved).
Format: [(pred)] mov[.cmod] (exec_size) dst src0
A mov instruction with a source modifier always copies a denorm source value to a denorm destination value
(in the manner of a raw move).
There is no direct conversion from B/UB to DF or DF to B/UB. Use two instructions and a word or DWord intermediate type.
There is no direct conversion from B/UB to Q/UQ or Q/UQ to B/UB. Use two instructions and a word or DWord intermediate integer type.
There is no direct conversion from HF to DF or DF to HF. Use two instructions and F (Float) as an intermediate type.
There is no direct conversion from HF to Q/UQ or Q/UQ to HF. Use two instructions and F (Float) or a word integer type or a DWord integer type as an intermediate type.
The mul instruction performs component-wise multiplication of src0 and src1 and stores the results in dst. When multiplying integer datatypes, if src0 is DW and src1 is W, irrespective of the destination datatype, the accumulator maintains full 48-bit precision. This is required to handle the macro for 32x32 multiplication. The macro described in the mach instruction should be used to obtain the full precision 64-bit multiplication results.
Note: A 32x32 multiply operation is handled natively, without a macro. When operating in this mode, the resulting 64-bit data is packed, unlike the macro, where the lower and upper 32 bits of the result are written to different general registers by two separate instructions. Refer to the macro description for details.
When multiplying integer data types, if one of the sources is a DW, the resulting full precision data is stored in the accumulator. However, if the destination data type is either W or DW, the low bits of the result are written to the destination register and the remaining high bits are discarded. This results in undefined Overflow and Sign flags. Therefore, conditional modifiers and saturation (.sat) cannot be used in this case.
Format:
[(pred)] mul[.cmod] (exec_size) dst src0 src1
The not instruction performs logical NOT operation (or one's complement) of src0 and storing the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
A register source operand can use a source modifier:
Any source modifier is logical, optionally changing a source value s to ~s (inverting all source bits). Such a source modifier is not particularly useful with the not instruction, as it changes the effect of not to just copying bits.
Format:
[(pred)] not[.cmod] (exec_size) dst src0
The or instruction performs component-wise logic OR operation between src0 and src1 and stores the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
Register source operands can use source modifiers:
Any source modifier is logical, optionally changing a source value s to ~s (inverting all source bits). This capability allows expressions like a OR (NOT b) to be calculated with one instruction.
Format:
[(pred)] or[.cmod] (exec_size) dst src0 src1
The sel instruction selectively moves the components in src0 or src1 into the channels of dst based on the predication. On a channel by channel basis, if the channel condition is true, data in src0 is moved into dst. Otherwise, data in src1 is moved into dst.
As the predication is used to select the two sources, it is not included in the evaluation of WrEn. The predicate clause is mandatory if cmod is omitted/0000b. If both predication and the conditional modifier are omitted, the results are undefined.
If the conditional modifier is specified (not 0000b, a compare is performed and the resulting condition flag is used for the sel instruction. Conditional modifiers .ge and .l follow the cmpn rules, and all other conditional modifiers follow the cmp rules. Predication is not allowed in this mode.
A sel instruction with cmod .l is used to emulate a MIN instruction.
A sel instruction with cmod .ge is used to emulate a MAX instruction.
For a sel instruction with a .l or .ge conditional modifier, if one source is NaN and the other not NaN, the non-NaN source is the result. If both sources are NaNs, the result is NaN. For all other conditional modifiers, if either source is NaN then src1 is selected.
A sel instruction without a conditional modifier always copies a denorm source value to a denorm destination value (in the manner of a raw move). This applies even if the source modifies are set on the sel instruction sources.
The sel instruction uses any conditional modifier internally and does not update the flag register if a conditional modifier is used.
A sel instruction with cmod or source modifier will flush denorm to zero, depending on the denorm mode bit; a sel instruction without cmod and source modifier will retain denorm.
Format:
(pred) sel[.cmod] (exec_size) dst src0 src1
Send a message stored in GRF starting at <src> to a shared function identified by <ex_desc> along with control from <desc> with a GRF writeback location at <dest>.
The send instruction performs data communication between a thread and external function units, including shared functions (Sampler, Data Port Read, Data Port Write, URB, and Message Gateway) and some fixed functions (e.g. Thread Spawner, who also have an unique Shared Function ID). The send instruction adds an entry to the EU's message request queue. The request message is stored in a block of contiguous GRF registers. The response message, if present, will be returned to a block of contiguous GRF registers. The return GRF writes may be in any order depending on the external function units. <src> is the lead GRF register for request. <dest> is the lead GRF register for response. The message descriptor field <desc> contains the Message Length (the number of consecutive GRF registers) and the Response Length (the number of consecutive GRF registers). It also contains the header present bit, and the function control signals. The extend mesage descriptor field <ex_desc> contains the target function ID. WrEn is forwarded to the target function in the message sideband.
The send instruction is the only way to terminate a thread. When the EOT (End of Thread) bit of <ex_desc> is set, it indicates the end of thread to the EU, the Thread Dispatcher and, in most cases, the parent fixed function.
Message descriptor field <desc> can be a 32-bit immediate, imm32, or a 32-bit scalar register, <reg32a>. GEN restricts that the 32-bit scalar register <reg32a> must be the leading dword of the address register. It should be in the form of a0.0<0;1,0>:ud. When <desc> is a register operand, only the lower 29 bits of <reg32a> are used.
<ex_desc> is a 6-bit immediate, imm6. The lower 4bits of the <ex_desc> specifies the SFID for the message. The MSb of the message descriptor, the EOT field, always comes from bit 127 of the instruction word, which is the MSb of imm6. A thread must terminate with a send instruction with EOT turned on.
<src> is a 256-bit aligned GRF register. It serves as the leading GRF register of the request.
<dest> serves for two purposes: to provide the leading GRF register location for the response message if present, and to provide parameters to form the channel enable sideband signals. <dest> signals whether there is a response to the message request. It can be either a null register, a direct-addressed GRF register or a register-indirect GRF register. Otherwise, hardware behavior is undefined. If <dest> is null, there is no response to the request. Meanwhile, the Response Length field in <desc> must be 0. Certain types of message requests, such as memory write (store) through the Data Port, do not want response data from the function unit. If so, the posted destination operand can be null. If <dest> is a GRF register, the register number is forwarded to the shared function. In this case, the target function unit must send one or more response message phases back to the requesting thread. The number of response message phases must match the Response Length field in <desc>, which of course cannot be zero. For some cases, it could be an empty return message. An empty return message is defined as a single phase message with all channel enables turned off. The subregister number, horizontal stride, destination mask and type fields of <dest> are always valid and are used in part to generate on the WrEn. This is true even if <dest> is a null register (this is an exception for null as for most cases these fields are ignored by hardware). The 16-bit channel enables of the message sideband are formed based on the WrEn. Interpretation of the channel enable sideband signals is subject to the target external function. In general for a 'send' instruction with return messages, they are used as the destination dword write mask for the GRF registers starting at <dest>. For a message that has multiple return phases, the same set of channel enable signals applies to all the return phases. The destination dependency control, {NoDDClr}, can be used in this instruction. This allows software to control the destination dependencies for multiple 'read'-type messages similar to that for multiple instructions using EU execution pipeline. As send does not check register dependencies for the post destination, {NoDDChk} should not be used for this instruction.
Thread managed memory coherency: A special usage of using non-null <dest> is to support write-commit signaling for memory write service by the Data Port Write unit. If <post_dest> is not null for a memory write request, the Data Port along with the Data Cache or Render Cache will wait until all the posted writes for the request have reached the coherent domain before sending back to the requesting thread an empty message to <dest> register. A memory write reaching the coherent domain, also referred to as reaching the global observable state, means that subsequent read to the same memory location, no matter which thread issues the read, must return the data of the write.
Perform component-wise logical left shift of the bits in src0 by the shift count indicated in src1, storing the results in dst, inserting zero bits in the number of LSBs indicated by the shift count.
Hardware detects overflow properly and uses it to perform any saturation operation on the result, as long as the shifted result is within 33 bits. Otherwise, the result is undefined.
Note: For word and DWord operands, the accumulators have 33 bits.
In QWord mode, the shift count is taken from the low six bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 63. Otherwise the shift count is taken from the low five bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 31. The operation uses QWord mode if src0 or dst has the Q or UQ type but not if src1 is the only operand with the Q or UQ type.
Format:
[(pred)] shl[.cmod] (exec_size) dst src0 src1
Perform component-wise logical right shift with zero insertion of the bits in src0 by the shift count indicated in src1, storing the results in dst. Insert zero bits in the number of MSBs indicated by the shift count.
src0 and dst can have different types and can be signed or unsigned.
Note: For word and DWord operands, the accumulators have 33 bits.
Note: For unsigned src0 types, shr and asr produce the same result.
In QWord mode, the shift count is taken from the low six bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 63. Otherwise the shift count is taken from the low five bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 31. The operation uses QWord mode if src0 or dst has the Q or UQ type but not if src1 is the only operand with the Q or UQ type.
Format:
[(pred)] shr[.cmod] (exec_size) dst src0 src1
smov
Scattered Move
The smov instruction moves the components in src0 into dst.
For each enabled channel, copy src0 to dst. The immediate is used to selectively enable channels without using flags.
When predication is enabled, the predicate mask is not generated from the flags. Instead, the immediate is used to mask the execution mask. If any channel is enabled as a result of this masking, the instruction is executed.
When predication is not enabled, the immediate masks the execution mask. This provides flexibility to mask out any channel with an immediate.
Format:
[(pred)] smov[.cmod] (exec_size) dst src0 src1
When predication is disabled, the immediate provides the flexibility to perform a select operation without the use of flags.
When predication is enabled, the usage model provides flexibility to select any bit in the flag registers for predication for execution size of 1.
The while instruction marks the end of a do-while block. The instruction first evaluates the loop termination condition for each channel based on the current channel enables and the predication flags specified in the instruction. If any channel has not terminated, a branch is taken to a destination address specified in the instruction, and the loop continues for those channels. Otherwise, execution continues to the next instruction.ld point to the first instruction with the do label of the do-while block of code. It should be a negative number for the backward referencing.
If SPF is ON, none of the PcIP are updated.
The following table describes the 32-bit jump target offset JIP. JIP is a signed 32-bit number, added to IP pre-increment, and should point to the first instruction with the do label of the do-while block of code. It should be a negative number for the backward referencing. In GEN binary, JIP is at location src1 and must be of type D (signed dword integer).
Format:
[(pred)] while (exec_size) JIP
The xor instruction performs component-wise logic XOR operation between src0 and src1 and stores the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
Register source operands can use source modifiers:
Any source modifier is logical, optionally changing a source value s to ~s (inverting all source bits). This capability allows expressions like a XOR (NOT b) to be calculated with one instruction.
Format:
[(pred)] xor[.cmod] (exec_size) dst src0 src1
The call instruction jumps to a subroutine. It can be predicated or non-predicated. If non-predicated, all enabled channels jump to the subroutine. If predicated, only the channels enabled by PMask jump to the subroutine; the rest of the channels move to the next instruction after the call instruction. If none of the channels jump into the subroutine, the call instruction is treated as a nop.
In case of a jump, the call instruction stores the return IP onto the first DWord of the destination register and stores the CallMask in the second DWord of the destination register.
When SPF is on, the predication control must be scalar.
The following section describes JIP, the jump offset, for DevSKL+.
JIP can be an immediate or register value. When a jump occurs, this value is added to IP pre-increment. In GEN binary, JIP is at location src1 and src0 must be null. The GRF register must be put (for example, by the assembler) at dst location.
Format: [(pred)] call (exec_size) dst JIP
Format: [(pred)] call (exec_size) dst JIP
The mac instruction takes component-wise multiplication of src0 and src1, adds the results with the corresponding accumulator values, and then stores the final results in dst.
Format:
[(pred)] mac[.cmod] (exec_size) dst src0 src1
When source and destination datatypes are different, the implied datatype for the accumulator operand is always the destination datatype.
Send a message stored in GRF starting at <src> to a shared function identified by <ex_desc> along with control from <desc> with a GRF writeback location at <dest>.
The send instruction performs data communication between a thread and external function units, including shared functions (Sampler, Data Port Read, Data Port Write, URB, and Message Gateway) and some fixed functions (e.g. Thread Spawner, who also have an unique Shared Function ID). The send instruction adds an entry to the EU's message request queue. The request message is stored in a block of contiguous GRF registers. The response message, if present, will be returned to a block of contiguous GRF registers. The return GRF writes may be in any order depending on the external function units. <src> is the lead GRF register for request. <dest> is the lead GRF register for response. The message descriptor field <desc> contains the Message Length (the number of consecutive GRF registers) and the Response Length (the number of consecutive GRF registers). It also contains the header present bit, and the function control signals. The extend mesage descriptor field <ex_desc> contains the target function ID. WrEn is forwarded to the target function in the message sideband.
The extended message descriptor field <ex_desc> also contains the extended function control field to be sent to the Target Shared Function over message sideband.
The send instruction is the only way to terminate a thread. When the EOT (End of Thread) bit of <ex_desc> is set, it indicates the end of thread to the EU, the Thread Dispatcher and, in most cases, the parent fixed function.
Message descriptor field <desc> can be a 32-bit immediate, imm32, or a 32-bit scalar register, <reg32a>. GEN restricts that the 32-bit scalar register <reg32a> must be the leading dword of the address register. It should be in the form of a0.0<0;1,0>:ud. When <desc> is a register operand, only the lower 29 bits of <reg32a> are used.
<ex_desc> is a 32-bit immediate, imm32. The lower 4bits of the <ex_desc> specifies the SFID for the message. The bit5 of the extended message descriptor, the EOT field, always comes from bit 127 of the instruction word. A thread must terminate with a send instruction with EOT turned on. The higher 16bits, bit31:16 specify the 16bit extended function control field. Interpretation of the extended function control signals is subject to the target external function.
<src> is a 256-bit aligned GRF register. It serves as the leading GRF register of the request.
The source dependency control, {NoSrcDepSet} is used to control the setting of source dependency for the source.
<dest> serves for two purposes: to provide the leading GRF register location for the response message if present, and to provide parameters to form the channel enable sideband signals. <dest> signals whether there is a response to the message request. It can be either a null register, a direct-addressed GRF register or a register-indirect GRF register. Otherwise, hardware behavior is undefined. If <dest> is null, there is no response to the request. Meanwhile, the Response Length field in <desc> must be 0. Certain types of message requests, such as memory write (store) through the Data Port, do not want response data from the function unit. If so, the posted destination operand can be null. If <dest> is a GRF register, the register number is forwarded to the shared function. In this case, the target function unit must send one or more response message phases back to the requesting thread. The number of response message phases must match the Response Length field in <desc>, which of course cannot be zero. For some cases, it could be an empty return message. An empty return message is defined as a single phase message with all channel enables turned off. The subregister number, horizontal stride, destination mask and type fields of <dest> are always valid and are used in part to generate on the WrEn. This is true even if <dest> is a null register (this is an exception for null as for most cases these fields are ignored by hardware). The 16-bit channel enables of the message sideband are formed based on the WrEn. Interpretation of the channel enable sideband signals is subject to the target external function. In general for a 'send' instruction with return messages, they are used as the destination dword write mask for the GRF registers starting at <dest>. For a message that has multiple return phases, the same set of channel enable signals applies to all the return phases. The destination dependency control, {NoDDClr}, can be used in this instruction. This allows software to control the destination dependencies for multiple 'read'-type messages similar to that for multiple instructions using EU execution pipeline. As send does not check register dependencies for the post destination, {NoDDChk} should not be used for this instruction.
sends
Split Send Message
The sends instruction performs data communication between a thread and external function units, including shared functions (Sampler, Data Port Read, Data Port Write, URB, and Message Gateway) and some fixed functions (e.g. Thread Spawner, who also have an unique Shared Function ID). The sends instruction adds an entry to the EU's message request queue. The request message is stored in a block of contiguous GRF registers. The response message, if present, will be returned to a block of contiguous GRF registers. The return GRF writes may be in any order depending on the external function units. <src0> and <src1> are the lead GRF registers for the first and second block of the request respectively. <dest> is the lead GRF register for response. The message descriptor field <desc> contains the Message Length (the number of consecutive GRF registers corresponding to src0) and the Response Length (the number of consecutive GRF registers). It also contains the header present bit, and the function control signals. The extend message descriptor field <ex_desc> contains the target function ID, the Extended Message Length (the number of consecutive GRF registers corresponding to src1) and the extended function control signals. WrEn is forwarded to the target function in the message sideband.
The sends instruction is the only way to terminate a thread. When the EOT (End of Thread) bit of <ex_desc> is set, it indicates the end of thread to the EU, the Thread Dispatcher and, in most cases, the parent fixed function.
Message descriptor field <desc> can be a 32-bit immediate, imm32, or a 32-bit scalar register, <reg32a>. GEN restricts that the 32-bit scalar register <reg32a> must be the leading dword of the address register. It should be in the form of a0.0<0;1,0>:ud. When <desc> is a register operand, only the lower 31 bits of <reg32a> are used.
Extended Message descriptor field <ex_desc> can be a 32-bit immediate, imm32 only. The bits3:0 of the <ex_desc> specifies the SFID for the message.The EOT field always comes from bit127 of the instruction word, which is the bit5 of <ex_desc>. A thread must terminate with a sends instruction with EOT turned on. The bits9:6 of <ex_desc> specify the extended message length and bits31:16 specify the 16bit extended function control. Interpretation of the extended function control signals is subject to the target external function.</ex_desc></ex_desc></ex_desc></ex_desc>
Extended Message descriptor field <ex_desc> can be a 32-bit immediate, imm32 or a 32bit scalar register, <reg32a>. The bits3:0 of the <ex_desc> specifies the SFID for the message.The EOT field always comes from bit127 of the instruction word, which is the bit5 of <ex_desc>. A thread must terminate with a sends instruction with EOT turned on. The bits9:6 of <ex_desc> specify the extended message length and bits31:12 specify the 20bit extended function control. Interpretation of the extended function control signals is subject to the target external function. The scalar register <reg32a> is selected when SelReg32ExDesc is set, ExDesc.RegNum[3:0] provides the addressing for reg32a for extended message descriptor. This selects one of the index sub registers. Subregisters selected are always aligned to dword. This implies, the even index subregisters must be used.</reg32a></ex_desc></ex_desc></ex_desc></reg32a></ex_desc>
Function control is now extended to 20 bits as specified in the below definition.
<src0> is a 256-bit aligned GRF register. It serves as the leading GRF register of the request.
<src1> is a 256-bit aligned GRF register or a null register. It serves as the leading GRF register for the second block of the request when it is not a null register. It is required that the second block of GRFs does not overlap with the first block. If it is a null register the Extended Message Length must be 0. The sum of Message Length and Extended Message Length must not be greater than 15 on SKL.
The source dependency control, {NoSrcDepSet} is used to control the setting of source dependency for both the sources.
<dest> serves for two purposes: to provide the leading GRF register location for the response message if present, and to provide parameters to form the channel enable sideband signals.
<dest> signals whether there is a response to the message request. It can be either a null register, a direct-addressed GRF register or a register-indirect GRF register. Otherwise, hardware behavior is undefined.
If <dest> is null, there is no response to the request. Meanwhile, the Response Length field in <desc> must be 0. Certain types of message requests, such as memory write (store) through the Data Port, do not want response data from the function unit. If so, the posted destination operand can be null.
If <dest> is a GRF register, the register number is forwarded to the shared function. In this case, the target function unit must send one or more response message phases back to the requesting thread. The number of response message phases must match the Response Length field in <desc>, which of course cannot be zero. For some cases, it could be an empty return message. An empty return message is defined as a single phase message with all channel enables turned off.
The destination type field is always valid and is used to generate the WrEn. This is true even if <dest> is a null register (this is an exception for null as for most cases these fields are ignored by hardware).
The address immediates for indirect sources and destination must be oword aligned.
The 16-bit channel enables of the message sideband are formed based on the WrEn. Interpretation of the channel enable sideband signals is subject to the target external function. In general for a 'sends' instruction with return messages, they are used as the destination dword write mask for the GRF registers starting at <dest>. For a message that has multiple return phases, the same set of channel enable signals applies to all the return phases.
NoDDClr and NoDDChk must not be used for send instruction.
Send a message stored in GRF locations starting at <src0> followed by <src1> to a shared function identified by <ex_desc> along with control from <desc> and <ex_desc> with a GRF writeback location at <dest>.
Format:
[(pred)] sends (exec_size) <dest> <src0> <src1> <ex_desc> <desc>
sendsc
Conditional Split Send Message
The sendsc instruction has the same behavior as the sends instruction except the following.
sendsc first checks the dependent threads inside the Thread Dependency Register. There are up to 8 dependent threads in the TDR register. The sendsc instruction executes only when all the dependent threads in the TDR register are retired.
Wait for dependencies in the TDR Register to clear, then send a message stored in GRF locations starting at <src0> followed by <src1> to a shared function identified by <ex_desc> along with control from <desc> and <ex_desc> with a GRF writeback location at <dest>.
Format:
[(pred)] sendsc (exec_size) <dest> <src0> <src1> <ex_desc> <desc>
The while instruction marks the end of a do-while block. The instruction first evaluates the loop termination condition for each channel based on the current channel enables and the predication flags specified in the instruction. If any channel has not terminated, a branch is taken to a destination address specified in the instruction, and the loop continues for those channels. Otherwise, execution continues to the next instruction.ld point to the first instruction with the do label of the do-while block of code. It should be a negative number for the backward referencing.
If SPF is ON, none of the PcIP are updated.
Format:
[(pred)] while (exec_size) JIP
The csel instruction selectively moves components in src0 or src1 to the dst based on the result of the compare of src2 with zero. If the channel condition is true, data in src0 is moved into dst. Otherwise, data in src1 is moved into dst. The csel instruction provides the function of a cmp followed by sel. The instruction must not be used if cmpn is required. The instruction does not update the flag register.
The comparison follows the same rule as cmp instruction for that data type.
When Access Mode is Align1, accumulator may be used as source or destination.
Format:
csel (exec_size) dst src0 src1 src2
The sends instruction performs data communication between a thread and external function units, including shared functions (Sampler, Data Port Read, Data Port Write, URB, and Message Gateway) and some fixed functions (e.g. Thread Spawner, who also have an unique Shared Function ID). The sends instruction adds an entry to the EU's message request queue. The request message is stored in a block of contiguous GRF registers. The response message, if present, will be returned to a block of contiguous GRF registers. The return GRF writes may be in any order depending on the external function units. <src0> and <src1> are the lead GRF registers for the first and second block of the request respectively. <dest> is the lead GRF register for response. The message descriptor field <desc> contains the Message Length (the number of consecutive GRF registers corresponding to src0) and the Response Length (the number of consecutive GRF registers). It also contains the header present bit, and the function control signals. The extend message descriptor field <ex_desc> contains the target function ID, the Extended Message Length (the number of consecutive GRF registers corresponding to src1) and the extended function control signals. WrEn is forwarded to the target function in the message sideband.
The sends instruction is the only way to terminate a thread. When the EOT (End of Thread) bit of <ex_desc> is set, it indicates the end of thread to the EU, the Thread Dispatcher and, in most cases, the parent fixed function.
Message descriptor field <desc> can be a 32-bit immediate, imm32, or a 32-bit scalar register, <reg32a>. GEN restricts that the 32-bit scalar register <reg32a> must be the leading dword of the address register. It should be in the form of a0.0<0;1,0>:ud. When <desc> is a register operand, only the lower 31 bits of <reg32a> are used.
Extended Message descriptor field <ex_desc> can be a 32-bit immediate, imm32 only. The bits3:0 of the <ex_desc> specifies the SFID for the message.The EOT field always comes from bit127 of the instruction word, which is the bit5 of <ex_desc>. A thread must terminate with a sends instruction with EOT turned on. The bits9:6 of <ex_desc> specify the extended message length and bits31:16 specify the 16bit extended function control. Interpretation of the extended function control signals is subject to the target external function.</ex_desc></ex_desc></ex_desc></ex_desc>
Extended Message descriptor field <ex_desc> can be a 32-bit immediate, imm32 or a 32bit scalar register, <reg32a>. The bits3:0 of the <ex_desc> specifies the SFID for the message.The EOT field always comes from bit127 of the instruction word, which is the bit5 of <ex_desc>. A thread must terminate with a sends instruction with EOT turned on. The bits9:6 of <ex_desc> specify the extended message length and bits31:12 specify the 20bit extended function control. Interpretation of the extended function control signals is subject to the target external function. The scalar register <reg32a> is selected when SelReg32ExDesc is set, ExDesc.RegNum[3:0] provides the addressing for reg32a for extended message descriptor. This selects one of the index sub registers. Subregisters selected are always aligned to dword. This implies, the even index subregisters must be used.</reg32a></ex_desc></ex_desc></ex_desc></reg32a></ex_desc>
Function control is now extended to 20 bits as specified in the below definition.
Function control is now extended to 20 bits as specified in the below definition.
The sum of Message Length and Extended Message Length must not be greater than 31.
<src0> is a 256-bit aligned GRF register. It serves as the leading GRF register of the request.
<src1> is a 256-bit aligned GRF register or a null register. It serves as the leading GRF register for the second block of the request when it is not a null register. It is required that the second block of GRFs does not overlap with the first block. If it is a null register the Extended Message Length must be 0. The sum of Message Length and Extended Message Length must not be greater than 15 on SKL.
The source dependency control, {NoSrcDepSet} is used to control the setting of source dependency for both the sources.
<dest> serves for two purposes: to provide the leading GRF register location for the response message if present, and to provide parameters to form the channel enable sideband signals.
<dest> signals whether there is a response to the message request. It can be either a null register, a direct-addressed GRF register or a register-indirect GRF register. Otherwise, hardware behavior is undefined.
If <dest> is null, there is no response to the request. Meanwhile, the Response Length field in <desc> must be 0. Certain types of message requests, such as memory write (store) through the Data Port, do not want response data from the function unit. If so, the posted destination operand can be null.
If <dest> is a GRF register, the register number is forwarded to the shared function. In this case, the target function unit must send one or more response message phases back to the requesting thread. The number of response message phases must match the Response Length field in <desc>, which of course cannot be zero. For some cases, it could be an empty return message. An empty return message is defined as a single phase message with all channel enables turned off.
The destination type field is always valid and is used to generate the WrEn. This is true even if <dest> is a null register (this is an exception for null as for most cases these fields are ignored by hardware).
The address immediates for indirect sources and destination must be oword aligned.
The 16-bit channel enables of the message sideband are formed based on the WrEn. Interpretation of the channel enable sideband signals is subject to the target external function. In general for a 'sends' instruction with return messages, they are used as the destination dword write mask for the GRF registers starting at <dest>. For a message that has multiple return phases, the same set of channel enable signals applies to all the return phases.
NoDDClr and NoDDChk must not be used for send instruction.
Send a message stored in GRF locations starting at <src0> followed by <src1> to a shared function identified by <ex_desc> along with control from <desc> and <ex_desc> with a GRF writeback location at <dest>.
Format:
[(pred)] sends (exec_size) <dest> <src0> <src1> <ex_desc> <desc>
dp4a
Dot Product 4 Accumulate
DP4A is a packed four-wide integer dot product and accumulate operation.
Each source's 32-bit channel value is treated as four element vector of 8-bit integer values.
The operation performs a 32-bit precision dot product of those four bytes and adds it with a 32-bit accumulator (typically a GRF, not necessarily an acc# reg).
Format: [(pred)] dp4a (exec_size) dst src0 src1 src2
EXAMPLE (SIMD1 for simplicity):
mov  (1) r1.0:d  0x0102037F:d // (char4)(0x1,0x2,0x3,0x7F)
mov  (1) r2.0:d  50:d
dp4a (1) r3.0:d  r2:d r1:d r1:d
// r3.0 = 50 + (0x1*0x1 + 0x2*0x2 + 0x3*0x3 + 0x7F*0x7F)
//      = 50 + (1 + 4 + 9 + 16129)
//      = 16193
The else instruction is an optional statement within an if/else/endif block of code. It restricts execution within the else/endif portion to the opposite set of channels enabled under the if/else portion. Channels which were inactive prior to entering the if/endif block remain inactive throughout the entire block.
All enabled channels upon arriving the else instruction will be redirected to the matching endif. If all channels are redirected (by else or before else), a relative jump is performed to the location specified by  <JIP>. The jump target should be the matching endif instruction for that conditional block.
The following table describes the 32-bit <JIP>. In GEN binary, <JIP> is at location <src1> and must be of type D (signed dword integer). <JIP> must be an immediate operand, it is a signed 32-bit number and is intended to be forward referencing. This value is added to IP pre-increment.
If the <branch_ctrl> bit is set, then the <JIP> points to the first join instruction within the else block and <UIP> points to the endif instruction. If the <branch_ctrl> bit is not set,  <JIP> and <UIP>, both point to endif.
Format:
else (exec_size) JIP  UIP  branch_ctrl
An else instruction must not be followed by any instruction requiring register indirect access on source operands
The mad instruction takes component-wise multiplication of src1 and src2, adds the results with the corresponding src0 values, and then stores the final results in dst.
The conditional modifier and saturation (.sat) must not be used when src1 or src2 are dwords.
Plane and Linear Interpolation instructions are removed. The following macros must be used to emulate Plane and Linear Interpolation operations.
Plane Instruction Emulation
The below plane instruction
pln (16) r20.0<1>:f r10.4<0;1,0>:f r4.0<8;8,1>:f
is emulated as below
mad (8) acc0<1>:nf r10.7<0;1,0>:f r4.0<8;8,1>:f r10.4<0;1,0>:f
mad (8) r20.0<1>:f acc0<8;8,1>:nf r5.0<8;8,1>:f r10.5<0;1,0>:f
mad (8) acc0<1>:nf r10.7<0;1,0>:f r6.0<8;8,1>:f r10.4<0;1,0>:f
mad (8) r21.0<1>:f acc0<8;8,1>:nf r7.0<8;8,1>:f r10.5<0;1,0>:f
In case of SIMD8 pln instruction only the first pair of mad instructions are used.
Linear Interpolation Instruction Emulation
The below lrp instruction
lrp (16) r40.0<1>:f r10.0<8;8,1>:f r20.0<8;8,1>:f r30.0<8;8,1>:f
is emulated as below
mad (8) acc0<1>:nf r30.0<8;8,1>:f r10.0<8;8,1>:f r20.0<8;8,1>:f
mad (8) r40.0<1>:f acc0<8;8,1>:nf -r10.0<8;8,1>:f r30.0<8;8,1>:f
mad (8) acc0<1>:nf r31.0<8;8,1>:f r11.0<8;8,1>:f r21.0<8;8,1>:f
mad (8) r41.0<1>:f acc0<8;8,1>:nf -r11.0<8;8,1>:f r31.0<8;8,1>:f
In case of SIMD8 lrp instruction only the first pair of mad instructions are used.
Format:
[(pred)] mad[.cmod] (exec_size) dst src0 src1 src2
The math instruction performs extended math function on the components in src0, or src0 and src1, and write the output to the channels of dst. The type of extended math function are based on the FC[3:0] encoding in the table below.
Format:
[(pred)] math.<FC> (exec_size) dst src0 src1
Rotate Left
Perform component-wise logical rotate left operation of the bits in src0 by the rotate count indicated in src1, storing the result in dst. src0 and src1 are treated as unsigned numbers with only the bits within the specified datatype used during this operation. This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers are supported. Extra precision bits available in accumulator are ignored during this operation and only the bits within the specified datatype are used.
src0 and dst must be of same datatype precision.
Format: [(pred)] rol[.cmod] (exec_size) dst src0 src1
Rotate Right
Perform component-wise logical rotate right operation of the bits in src0 by the rotate count indicated in src1, storing the result in dst. src0 and src1 are treated as unsigned numbers with only the bits within the specified datatype used during this operation. This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers are supported. Extra precision bits available in accumulator are ignored during this operation and only the bits within the specified datatype are used.
src0 and dst must be of same datatype precision.
Format: [(pred)] ror[.cmod] (exec_size) dst src0 src1
Total
binary size is too small
SyncFC
SFID
unexpected padding at end of kernel
error decoding instruction (no compacted form)
unable to decompact
error decoding instruction
GED error decoding instruction
unsupported pseudo op (sub function of 
: unsupported opcode on this platform
at pc 
: invalid operation format
: invalid operation format
IGA INTERNAL ERROR: 
: unexpected format for basic instruction
dst: unsupported Align16 ChEn; only <1> (.xyzw) supported
converting unary/binary Align16 dst to equivalent Align1
unsupported Align16 Dst.ChEn (only .xyzw supported)
invalid addressing mode on dst
dst has wrong region for binary normal form
invalid reg file on dst
unexpected Align1Ternary in current platform
unsupported Align16 ternary destination for SIMD2 (must be .xywz or .{xy,zw} for :df)
unsupported Align16 ternary destination for SIMD4 (must be .xywz or .{x,y,z,w})
unsupported Align16 ternary destination for SIMD{8,16} (must be .xywz)
unsupported Align16 ternary destination (unsupported SIMD)
error decoding instruction: SEND dst ARF
Align16 branches not supported
dst: invalid math macro register (from ChEn)
invalid dst implicit accumulator reference (in ChEn)
%s: 0x%02X: invalid arf register
%s: %s%d: invalid register number 
%s: invalid register file
swizzle X could not be retrieved
swizzle Y could not be retrieved
swizzle Z could not be retrieved
swizzle W could not be retrieved
GED reports invalid value for 
GED reports invalid field for 
(line 
GED reports error (
) accessing GED_
 (line 
src%d: inconvertible align16 operand
src%d: invalid addressing mode
invalid register file in src%d
src%d.Rgn should have %s for binary normal form
src%d: macro instructions must be Align16 for this platform.
invalid addressing mode in src%d
Region::INVALID
src%d: converting Align16 to Align1 (bits will re-assemble to Align1)
unconvertible ternary align16 operand
Align1 not available on this platform
src1: immediate supported here on ternary instruction.
expected SIMD width
expected ChOff
invalid ChOff
expected )
expected '(' (start of execution size info)
invalid SIMD width
expected a send operand type
unexpected operand type for send
old-style access to mme via acc (use mme%d for acc%d)
register number out of bounds
 must be a constant integer expression
expected constant integer expression
argument to operator must be integral
right operand to operator must be floating point (append a .0 to force floating point)
left operand to operator must be floating point (append a .0 to force floating point)
left operand to operator must be integral
right operand to operator must be integral
(integral) division by zero
nan is deprecated, us snan(...) or qnan(...)
qnan
snan
NaN payload overflows
NaN payload must be nonzero for snan
bare qnan and snan tokens deprecated (pass in a valid payload)
branching operands may not perform arithmetic on labels
non-branching operations may not reference symbols
syntax error in constant expression
NoDDChk not supported on given platform
NoDDClr not supported on given platform
NoPreempt not supported on given platform
NoSrcDep not supported on given platform
ignoring unsupported instruction option {Switch}
duplicate instruction options
Atomic mot supported on given platform
Atomic mutually exclusive with Switch
Atomic mutually exclusive with NoPreempt
Compacted mutually exclusive with Uncompacted/NoCompact
EOT is only allowed on send instructions
Uncompacted
Uncomapcted/NoCompact mutually exclusive with Compacted
NoMask goes precedes predication as (W) for WrEn: e.g. (W) op (..) ...   or    (W&f0.0) op (..) ..
H1 is obsolete; use M0 in execution offset: e.g. op (16|M0) ...
H2 is obsolete; use M16 in execution offset: e.g. op (16|M16) ...
Q1 is obsolete; use M0 in execution offset: e.g. op (8|M0) ...
Q2 is obsolete; use M8 in execution offset: e.g. op (8|M8) ...
Q3 is obsolete; use M16 in execution offset: e.g. op (8|M16) ...
Q4 is obsolete; use M24 in execution offset: e.g. op (8|M24) ...
N1 is obsolete; use M0 in execution offset: e.g. op (4|M0) ...
N2 is obsolete; use M4 in execution offset: e.g. op (4|M4) ...
N3 is obsolete; use M8 in execution offset: e.g. op (4|M8) ...
N4 is obsolete; use M12 in execution offset: e.g. op (4|M12) ...
N5 is obsolete; use M16 in execution offset: e.g. op (4|M16) ...
N6 is obsolete; use M20 in execution offset: e.g. op (4|M20) ...
N7 is obsolete; use M24 in execution offset: e.g. op (4|M24) ...
N8 is obsolete; use M28 in execution offset: e.g. op (4|M28) ...
expected instruction, block, or EOF
default_execution_size
expected SIMD width (integral value)
invalid default execution size; must be 1, 2, 4, 8, 16, 32
default_register_type
expected default register type
unexpected directive name
integer literal too large
label redefinition 
 (defined 
on line 
invalid mnemonic
expected predication control
invalid predication control
expected flag register
Unexpected flag register number
expected flag subregister
jmpi must have (W) specified (automatically adding)
expected 'b' (branch control)
saturation flag goes on destination operand: e.g. op (..) (sat)dst ...
conditional modifier follows execution mask info: e.g. op (16|M0)  (le)f0.0 ...
unexpected . (expected execution size)
expected operation subfunction
subfunction is out of bounds
invalid subfunction
unexpected subfunction for op
src0 must be a register
src0 must be a notification register
expected '\n', ';', or EOF
expected flag modifier function
expected ]
deprecated flag modifier syntax (omit the brackets)
deprecated flag modifier syntax: 
use 
 for this function
flag register must be same for predication and flag modifier
invalid destination register
invalid destination register number (%s only has %d registers on this platform)
expected [
expected address subregister
expected indirect address offset
immediate offset is out of range; must be in [
expected a0
expected .
expected address register subregister
destination region argument
invalid destination region
expected >
implicit type on dst should be omitted
expected destination type
expected subregister
send operand subregisters have no effect and are deprecated syntax
send operand region has no effect and is deprecated syntax
subregister out of bounds for data type
access granularity too small for data type
expected math macro register (e.g. .mme0, ..., .mme7, or .nomme)
old-style math macro register (use mme)
acc2
acc3
acc4
acc5
acc6
acc7
acc8
acc9
noacc
expected |
this doesn't support regioning
unexpected |
unbound identifier
expected source operand
source modifier unsupported on this op
%s.Src%d region should be implicit
syntax error in source region
invalid region width
expected ;
invalid region vertical stride
expected ,
syntax error in region (horizontal stride)
invalid region horizontal stride
syntax error in region (width)
implicit type on src should be omitted
expected source type
subregister out of bounds
register access granularity too small type
syntax error in region (vertical stride)
literal must be integral for type 
immediate integer floating point literals must be in hex or binary (e.g. 0x7F800000:f)
hex literal too big for type
NaN payload value overflows
literal is out of bounds for type %s
invalid send destination register
this form of indirect (r3[a0.0,16]) is invalid for send dst operand; use regular form: r[a0.0,16]
expected extended send descriptor
immediate descriptor expression must be integral
extended message descriptor is typeless
Message Descriptor is typeless
 must be an immediate label
expected }
invalid instruction option
expected 
INTERNAL ERROR: parsing float literal
fatal flex scanner internal error--no action found
out of dynamic memory in yy_create_buffer()
out of dynamic memory in yy_scan_buffer()
out of dynamic memory in yy_scan_bytes()
bad buffer in yy_scan_bytes()
yyset_lineno called with no buffer
yyset_column called with no buffer
fatal flex scanner internal error--end of buffer missed
fatal error - scanner input buffer overflow
input in flex scanner failed
out of dynamic memory in yy_get_next_buffer()
out of dynamic memory in yyensure_buffer_stack()
malformed load/store mnemonic suffix
platform does not support packed (unary) send
ld/st operation name
unhandled ld/st operation kind
invalid address model for this message
invalid message
register range
invalid register range
malformed register range
malformed register range (high register must be >= low)
unary send prohibits src1 argument
surface offset
expected offset
address offset out of bounds for message type (>
address model
surface index
expected surface index
surface index is out of bounds
scratch index is out of bounds
invalid address model
unary store (stp) not supported yet
missing %s argument
invalid %s
address range includes header (extra reg), but format does not allow for it
expected %d address registers
expected %d data registers
instruction option
succeeded
unknown error
invalid argument
out of memory
decode error
encode error
parse error
version mismatch
invalid object
invalid state
unsupported platform
invalid error code
0.15.17
iga_assemble call uses deprecated options  (error_on_compact_fail or autoset_deps); see newest iga.h header file for updated fields
iga_disassemble* call uses deprecated options  (hex_floats or print_pc); see newest iga.h header file for updated fields
iga api: unsupported platform
failed to allocate
decoding error: %s
ERROR: 
WARNING: 
7.0.0
44444
St20bad_array_new_length
St9bad_alloc
St12out_of_range
St12length_error
St11logic_error
St9exception
L ( 
L ( 
L * 
A` 
L ( 
L ( 
L * 
A` 
8 .@
8@.`
e'7d@
vX6E@
1FE#@
TgTgA
2d2dA
WWWWA
q8q8A
cTcTA
8T8TA
2424A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%
Xx!C
!B##
!4!4
V#V#
&T&T
#1#1
!#!#
    
 " "
0000
0303
@@@@
@D@D
PPPP
PUPU
PUPU
pppp
8 .@
8@.`
e'7d@
vX6E@
1FE#@
TgTgA
2d2dA
WWWWA
q8q8A
cTcTA
8T8TA
2424A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%
Xx!C
!B##
!4!4
V#V#
&T&T
#1#1
!#!#
    
 " "
0000
0303
@@@@
@D@D
PPPP
PUPU
PUPU
pppp
L ( 
L ( 
L * 
A` 
L ( 
L ( 
L * 
A` 
L ( 
L ( 
L * 
A` 
e'7d@
vX6E@
1FE#@
TgTgA
2d2dA
WWWWA
q8q8A
cTcTA
8T8TA
2424A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%
Xx!C
!B##
!4!4
V#V#
&T&T
#1#1
!#!#
    
 " "
0000
0303
@@@@
@D@D
PPPP
PUPU
PUPU
````
,I .@
,I@.`
,I`.
,I .
,I@.
,I`.
e'7d@
vX6E@
1FE#@
TgTgA
2d2dA
WWWWA
q8q8A
cTcTA
8T8TA
2424A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%
Xx!C
!B##
!4!4
V#V#
&T&T
#1#1
!#!#
    
 " "
0000
0303
@@@@
@D@D
PPPP
PUPU
PUPU
````
$K %
$K@$
$K`$
e'7d@
vX6E@
1FE#@
TgTgA
2d2dA
WWWWA
q8q8A
cTcTA
8T8TA
2424A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%
Xx!C
!B##
!4!4
V#V#
&T&T
#1#1
!#!#
    
 " "
0000
0303
@@@@
@D@D
PPPP
PUPU
PUPU
````
oIo<P
CTNI&
^^^^ ^^^^^^^^^
^O;LLP
UL[!
#<(-278
K8@,v
~.jz
nZv2
 (08@HPX`hpx
 (08
4M^x
5.5555_
5.5555_
5.5555_
Sjp:s=
````
4Jqw}$
````
gggg
eeee
mmmm
 (    E
####M
2..::
:4::::6
&&&&
&&&&&&&
'''''
'''''''
''''''''''}--
3)-#9=1A'?!%;
||j 
NSt3__117bad_function_callE
gggg
`[````]
ffff
XSXXXXU
+Dg:
FFFFFFFF
FFFF7
p|||
||||||||||||||||||||t
||||||||||||||
|||y|||
air.kernel
air.vertex
air.version
air.language_version
air.compile_options
air.location_index
air.read
air.write
air.read_write
air.sample
air.buffer_size
air.arg_type_name
air.arg_type_size
air.arg_type_align_size
air.arg_name
air.emulation_argument
#####################################
KKKKKKKKKKKKKKKKKK6KKKKKKKKKKKKKEK2:0
4..99
9299996D
C:CCCC<
njey
okkvv
vqvvvvs
)=-#
')''''+SI
MOMMMMQ
KCCPP
PIPPPPM&
2##cc
c-cccc7
N))PP
PRPPPPT

9Tam
F+((
!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!
:===
8 8#8(8+8.8184
...........................
..........
!$'*-06<
Zldh
/c///e///////g///////////////i
Y[YYY]YYYYYYY_YYYYYYYYYYYYYYYaX_
Y[YYY]YYYYYYY_YYYYYYYYYYYYYYYaX_
,+K7
\fpz
6@NF
:nnn
nnnnnnnnnnnnnnnnnnnnj
nnnnnnnnnnnnnn
nnnRnnn
933>>
>7>>>>;
@@@@@
Ljs}
gggg
n--uu
uluuuup*
l llll(
-------+--
TTTTTTTTTTT5TTTTTTTT
-Fdk{
9ESK
6@NF
3322(
9AIQ
+6RAAAAAC
yo
qmmxx
xsxxxxu(
OU[a
J''LL
LNLLLLPA@
hhhhhhhhhhhhhhhh
.GZm
@@@@
5P/k
wwwwwwwwwwwwwwww88aw88awwww
cwcwww
wwwwwwwww''w
wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww''HN
1//33
3533337
/%..
>>>>
<88>>
>@>>>>B
9--22
252222hK
??????????
??????????????????????2
7277774
!,7"
!!!!
oiitt
tmttttq
BBBB
..17
++.4
=1WF
 (    A
,O%@
mmmmmmmmmmmmmmmmmmmmmmmmmmmmm
!777
4444
SE_G
II_IKIIIIM
@KU_hq
#####################################
Z2_d
]))EEr
b0$IY
2$IB
(CUUd
P$v`
clang version 4.0.1 #
cs)s
c+s1
       
ELzA
E`XB
C8QM_A
A45n0
PV~5
dPB0
1KpTd]
,A1PA
nx:0
L&SHT
t,>b&
T>b8
>b3
T>b/
WdPB0
1KpTd]A
$;KPT
7<{
[M"0OM
T>q!
B?5 
N"QA
#>bV
@A4S
J"8Me
K"8Mu
DdK
#>rR
#>bQ
#5nO
#>b1
#uoC
WdPB0
1KpTd]a
$;KPT
7<{
,A5P
3PAT
$;K0
"8Mu
#7of
LfsHT
#>bN
#8n9
#>bk
T>q!
B?5 
@A4S
J"8Me
K"8Mu
#wo_
#vo3
"8Mu
#9o7
#>bR
#yo+
T>q!Sn
#zmK
B?5 
DdL
#zoS
#>b1
#&sHG
#>bO
WdPB0
1KpTd]
A0PAT
\@Jp
,AtC
WdPB0
`aA
$c0s
XT#0OM
#vo:
#7oa
"0OM
 )>
#>bb
#>bI
=1@3
B?5 
#xnG
#8Me
#8Me
U#QA
a@#Q
B?5 
B?5 
2Y^#8M
#>bi
#0OM
WdPB0
1KpTd]
,A1PA
+2(!
@+ v
BX(e
24J0K
D7dpE
2LRPB
+2(!
A+ v
2lX0K
WdPB0
H7PATa`"]
&Tb
B+ v
Pm0PA n
Tc!5
ba5
lC+ v
Gm2
B?5 
@ITP
#8Me
#8M
#>r0h
T>q!
Dd4
z@$8M
 )>
#8Mu
 )>
S#8M
T>q!
T>q!
Q#QA
B?5 
#ynS
#>bj
Xi@#
r@$QA
 )>
$8Mu
#>bW
#8Me
 )>
Y9@3
d@$QA
m9NT
B?5 
Y#8M
#F%IG
 )>
B?5 
#{nl
#w~.
#8Mu
B?5 
c!@ H
WdPB0
1KpTd]
%DQm`\
,AtC
WdPB0
$c0s
|7dpE
%DQ7a\
`. b
7<y
1hA\
`. b
1hAy2
Td]
%DQ#b\
`. b
7<e
pC`&d0
,A+Td
%DQwb\
`. b
,A.T
0PA 
FF+ v
~!(!
0PA 
fAmhf
F+ v
3:`0
@$0OM
$8Me
#>rD
T>q!
#>r0j
T>q!
B?5 
Dt5
#V/@
#>rB
$8Mu
V$8Mu
$8Mu
%8Me
v@$8M
#&;P
@A4S
#>r[b
T>q!
#7@Y
Dtid
T>q!
`@$QA
 )>
Xp@$8M
B?5 
#f;`
$0OM
 )>
Dd}
#v;`
B?5 
 )>
XZ$QA
#|~.
#F/P
#>b|
#>rNd`
%0OM
%0OM
#6-0
 )>
/P9Q
%8Me
#8~f
B?5 
u~aj
B?5 
#v9@
;@IG
&8Mu
$8Me
LV=p
 )>
809Q
T>q!
;@IT
B?5 
f@$Q
 )>
j@$8Mu
#G0!
B?5 
#>r'
}ce`
B?5 
PV~5
dPBP
1KPTd
D4`A
L7LTPC
nX20
T>q!
 )>b+
t,>b&
tD>r
A4>b.
#vRD
WdPBP
1KPTd
+2(!
V0*0
2PAh
#VsHT
#>b7
#umE
#5n.
#>b8
#>b+GD0>
 )>
O"8M
WdPBP
1KPTd
+2(!
V0*0
2PAh
,AsC
WdPBP
TdU
#wmI
M[W"
Dd4
#>b5
#wo7
L6c8
>q!
J"8Me
#9mAID0>
#ym.
#>b8
#>bK
#:mF
K"8M
>q!
#yo6
"8Me
 )>
#wnWID0>
#voa
WdPBP
1KPTd
Bcg
L>bB
 )>
#>b,
#>b3
#>bA
 )>
#8nt
X#0OM
}[[#8M
#0OM
[^#Q
Q#8M
#5}
#>be
Ddz
WdPBP
1KPTd
2$H0K
a$sVP
20K0K
2PAD
2LR0K@
ZdLsV
,A6P
+2(!
0%/@0
h0PAhe`
F]2
L#8Me
 )>
#>b5
#>ba
@A4S
#8M
 )>
R#8M
#9mg
>r"h
>q!
#>bi
#|nu
>q!
LwAY
#>bK
Xk@$0OM
#8Me
#>bh
#>bU
#>bz
c!@ H
WdPBP
1KPTd
+2(!
2PAh
,AsC
WdPBP
TdUC
+2(!
5PAh
\7dpE
@EV]
tCI@A
%@b
nB+ v
7,a
WdPBP
sVP
WdPBP
=pcA=r
C+ v
A0KP
7dpE
Bs0PADu
"PPC
ldDJ
 Cp&32
&:RB
7dpE
K}0PAD
'PPC
r+`0
WdPBP
V0.Z
]pe
E+ v
7,#
 C 2
@$0OM
#9oi
0ITP
>rKd
>q!
>q!S
@%8M
f@$8M
Gp^B
>q!
$8Me
V.0E
&0OM
#>b_
 )>
#wnY
 )>
>q!
6809
 )>
#f+@
-@ITP
#5m[q
@%QA
>q!
#F,@
qA@3
>rGe`
 )>
U$8M
#7@Y
#}}%
$8Me
f)`9
#>bb
 )>
PD0>
Dd@
>rAb
>q!
y@%QA
]$0OM
>r@k
>q!
 )>
#9nL
,0IT
#&-0
$0OM
0ITP
#>bx
@%8Me
    
$;KPT
LVRHT
#um@
T>q!
!8Mu
 )>r
A4>b5
tD>b0
#64HT`1
    
A0PAT
f`rP
vTHT
#xmZ
#>b<
#6oi
#5m6
#>bh
T>q!
"8Me
#>bT
#uoE
D>b2
 )>
#>b]
#voe
#>bQ
    
A0PAT
f`rP
,AtC
wdPB0
#>b<
#>b,
#xmt
y)@3
#<mc
@A4S
L"8Mu
"8Mu
&sH
#>bO
#xnz
L=oHJDL
"8Me
#>b[
 )>
#>bD
#|n;
#>blLDL
"0OM
"8Mu
#>b0
#=ms
"8Me
    
A0PAT
0PA 
D 7
`. b
X-!
30\(B0
D7dpG
XA9h
2LRP
;2(!
RB+ v
2lX0K
bp![}
 )>
#>bA
#>b;
#>bI
#>b2
#wn>
#vt\N
L>bl
#zmnNDL
#yn|
nJLDL
X#0OM
#{nD
>b`
 )>
    
B0PAT
$;KPT
f`{P
,AtC
wdPB0
$c0sf
hP>1
Td]
J7PAda@.
a0PA
B<D
bA5
;2(!
Pm0PA n
D+ v
'CL7
O#8Mu
#8~(
#V&IG
#|oA
!1NT
i@$8Me
#:muPDL
#>bj
#gS!
T>q!
 )>
>q!S
#>r#
#8oG
>q!S
 )>
T>q!
#<ni
#>bf
#>bg
~@$0OM
n[d@
#>b`
j@$8Mu
|@$8Mu
@$0OM
    
PV~5P
n >301(B0
7dpG
,A1PA
;2(!
fA+ v
BX(e
24J0K
C:7
,A5P
3PAT
$;K0
Tb!%
aa%
f`.Q
7<h
X\!
|7dpG
XAhh
`. b
wdPB0
o0PA
xdaGXd
#f``R
;2(!
0*s2
P*t2
30T)B0
P{0PA |
E+ v
F!(a
c2`0
u2CL7
7dpG
0PAd
0PAT
T*T
D 7
:Y`7W
X0gt@0
,A.T
0PA 
 2pp
B0K 
!301*B0
0PAd
Di!
1Jf`
;2(!
+@ITP
#>b`
;`IG
@$0OM
$8Me
DdF
#>rf
#unp
#>rg
#5m_
}[S#
T>q!
>A&QA
 )>
$8Me
%8Mu
f:@E
]$0OM
$8Mu
#>b~
[_s9
l@4 
LF-`ITP
T>q!
>rNe`
@A4S
N`IT
 )>
HN[v@$8Mu
#v?0
 )>
#>rSf
#uN_
@%8M
~Uc`
 )>
#>r[b
T>q!
#>r=
J@IG
@%8M
0ITP
%8Mu
y}Mb
T>q!
_[p@
I0IT
#f>@
#>r>h
T>q!
#f;0
X?Au9
#WR!
#V-P
;0IT
#&/@IG
#u}[(
%8Me
%8Me
L&-@
#wQ!
#7!!
m\PDL
#wr!
#&; 
JPIT
&I0MN
#>r(
z@s9
$0OM
OpIG
X:A&8Me
>r"h
T>q!
#>rEg
#F>`I
$8Mu
-A59
w}9``
#>rhn
T>q!
z@$QA
^$QA
g@$QA
$8Me
&K`ITP
#6__
    
,A1P
L7hRPC
VRHT
#&SH
#FSHG
3`>b=
!0OM
    
,A1P
f`mP
2$H0K
&THT
,>ba
#6o-
#>bC
XL"8Me
#>b3
#>bR
 )>
#vmW
Dd+
>q!
    
,A1P
f`mP
2$H0K
Bcg
#>b;
#>bk
#>bt
#8mpID0>
#wnZ
#yoj
>q!S
#>bI
#;ox
>q!
#zm=
 )>
#xmC
O"QA
#>b1
#>by
L"8M
"8M
#>b?
m2GD0>
#>b8
    
,A1P
@+ v
,AsC
wdPBP
TdU#
XA.h
A+ v
7,#
hP#!
#zm;
>q!
#8Me
#8o{
#vnq
#5nT
#xoA
#:mb
i1@3
L>bi
>q!
#vmE
#>bB
#8m?
#>bU
`@"Q
_#QA
>by
Ddd
    
,A1P
;2(!
2PAh
Z(B0
47dpG
@EV5p
tC9HA
;2(!
5PAh
wdPBP
]|RU
B+ v
s_P
7dpG
#uot
Yv@$8M
[l@#8
@$QA
|@$8
#8Me
#>b\
y@$QA
 )>
MD0>
#0OM
[x@$0OM
) IT
#:mi
Hm[}
>q!
 )>
#>b[
#7mq
#7o?
    
PV~5P
,A1P
2$H0K
1|A,
Bcg
0E%@0
2LR0K@
f`=1
2XU0Kp
J5PAD
D 7
TdU
7PADa
 400
cA?
;2(!
h0PAhe`
&#hP3"
 C0#
D 7
A0K 
U+BL7
30_)B0
 4:0
eA_
;2(!
|0PAhy`
&3hP3#
 C03
 4?0@a
fAo
7f`}S
;2(!
0PAh
&;hP
*TdU*
)T@>w
D 7
 "W@
v>@IG
@%8M
>q!
neOD0>
#>bR
>q!
Ho[i
*A&0OM
Xs@$0OM
)@IT
Xj@$
 )>
#fIPIT
#>bFMD0>
>q!
t3b`
OD0>
+PMN
 )>
#>bk
/ IT
v*@IG
#>rC
*`ITP
>r,h
>q!
$8Me
) IT
<@ITP
@A4S
#>bg
#V80
#F>`
 )>
#>bH
#V:@I
#w0!
#5^_
"A%Q
[(A&
#>rOd
%8Me
@$8M
u}Ab
>q!
<0IT
#v9 
59@3
$0OM
$8Me
#7mu
#<mq
9@IT
TD0>
 )>
$0OM
%8Me
#8Me
#680
#;n`
f< I
#5][
IpIT
#un_
QD0>
#vm_
< IG
@%8M
%8Me
; IT
$0OM
H`ITP
 )>
9 IT
v<pIG
#6][
#u^[
Dt8e`
%0OM
9 MN
f@$8
B?5 U
p+F=c
b0$IY
= UD0
@0D"
P$v`
wchar_sizeclang version 7.0.0 
 3C@
intomnipotent charSimple C/C++ TBAA
r6J
_ (511bp!
D2b`!
,5n%
"MND0Dd
!8MU
1He
H!QAM
H!QAm[J!QA
0&aLN
precompiled_u32divrem_spGenISA_uitof_rtzGenISA_fma_rtzGenISA_mul_rtzGenISA_add_rtz7.0.0x86_64-pc-windows-msvcprecompiled_u32divrem_sp.cl
b0$IY
= UD0
@0D"
P$v`
wchar_sizeclang version 7.0.0 
 3C@
intomnipotent charSimple C/C++ TBAA
C0b`!
F1HGd<HDL
Dvm 
@A4S
D7m3
G!8M
[H!8M
!8Me%
!8MU
0HK`
I!QA}[J!QA
M[L!Q
0vo
precompiled_s32divrem_spGenISA_uitof_rtzGenISA_fma_rtzGenISA_mul_rtzGenISA_add_rtz7.0.0x86_64-pc-windows-msvcprecompiled_s32divrem_sp.cl
b0$IY
`B L
P$v`
PIC Levelclang version 4.0.1 (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-clang 3621e01986d729d27ffa6d8cc3e2020357cc420b) (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-llvm 26ebe8b7270e331f307f8d763aa5dd076abb0335)
3C@
   B
g@QA
g0bp
B0K@T
t!.
hb&`
'a0P
b0$IY
P$v`
clang version 4.0.1 (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-clang 3621e01986d729d27ffa6d8cc3e2020357cc420b) (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-llvm 26ebe8b7270e331f307f8d763aa5dd076abb0335)#
cs)s
c+s1
5@4F
intomnipotent charSimple C/C++ TBAA
Q6F
)TUt
B2b`!
SA$5
1K T
"MND0Dd
D!8MU[D!8Me
D!8Mu
F!8M
j?C-
= UD0
b0$IY
P$v`
clang version 4.0.1 (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-clang 3621e01986d729d27ffa6d8cc3e2020357cc420b) (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-llvm 26ebe8b7270e331f307f8d763aa5dd076abb0335)#
cs)s
c+s1
5P>Dc
intomnipotent charSimple C/C++ TBAA
1bp!
fR\NT
1HGd'HDL
,v0H
VA\Nt
AHGT
D5m$
)@0A
j?C-
2D$H
`B L
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
lnJP
TDT,
V?EFU
HxA@
XxA@
L0!
(T(L
pa`0
a7@0K
2H]P
NB7@0
2L]0
2PY0
`207
D`PA
Z0#0
LM@P
Tp+\D
OnpA@!
NU4,p
AP73
|37a0
pCp7`0
T@;Zds7xA@
B@-4*
!@!0
!`!0
f+`P
0w}&
#(5nP
>n[
Ddi
#(5m
)R9S}
~"II
V?EFU
6408A
n(lA
.f
p A1-
&@0K
$.Pj
2TV0
@EPd8
@GnP
Vd&[
@\.P
/C3`0
5#2h0
hX /
3xA@
hX0:
*lxG
pC ?`0
,A+T
BPx#?Z
?aP{C?:
B@*4*
4p?[
V0=YP
#(5n
0@f
Lf0\Hc
>r1JI
>b`
v0`Hc
)R9S
#VK@
2D$H
`B L
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
*llvm.identS
v67%(
TDT,
P>5P
@xA@
PxA@
PxA@
2$MP
l,`P
np^Cf
2|^py
#`0P
@E@Kd`
\XF+
f.P%s3ZB
n(L'J
:`PA
;`PA
|gT`>;
!`la
)BPB
 zAx
C0KP
`PB
%AB\
Dth
#(v~(
@D&>
fHpH
@D:m
^[(A"
D?q=N
4Cn[
08m
08o
v0`Hc
)R9S
SA5P
PqT50
HxA@
XxA@
hxA@
lxA@
^A+0
RDAM
$pA@
\d0p
BpAD
"@!H
5!F@P
BPEp
599K
`*E0
@"^@0Kp
[h`.Xi
:kf
r5-W
DaD
37h0
@@;T0
BpAD
r0K 
*LHK
?TFh0
FPur?|
BP!!FZ
)T0
dK`0
!8-0
Z1b 
+BPB
!`Tb
ZAg 
0;+BPB
&6j`0
pC0k`0
!p70
mT0r;
E@"7*`
pCpr`P
!x90
vnTPv;
pX r
!.T#
!x;0
vw`0
P"gwZ
s\!Wr<
a4T#
s}@s~
M[e@
6+p
0@f
>~[
r[qA
~^[p
@DuM
@Du]
0:n
0:o
@Dum
0;m
d4>m
0;n
FX`P
SMtK
,VipH
flpH
~MKI
7`"B
YLa(
%=|)r
(=|)r
&"$_
{S&x"B
&=|)r
&]|)r
uC&p
s{-p
q34H&
Y|d""_
'"$_
#E*g
&DP0
#E*g
s+%8R
%]|)r
%]|)r
X\py
(=|)r
K'8R
2D$H
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
lnJP
TDT,
v+Lv
l+P[`
6,_+Hx
*BQm
*^Td
*r^a
*BhA
*Ism
f%~*
w*JNY
$m*W
?f*~LM
'l_*
\*lBt
6O*^Q
L*]kt
&t?*
<*Pe{
4*bC
BD^'*ylc
*DHP
(@hn
(@hn
(@`H
(@hq
(@`b
(@@I
(@@b
(@Pl
(@hi
(@X[
(@@b
(@h@
(@pV
(@@b
(@@t
Sh%Q
R4eS8
R"ER&
S<%TDeTH
TP%UTeUX
VbEVf
WrEWv
tJg0"8
o LG&
tFb0"8
o0Pg$
#uFb0"8
o@Tg$
duFb0"8
oPXg$
uFb0"8
ujb0"8
'vLb0"8
hvLb0"8
vLb0"8
vLb0"8
+wLb0"8
lw~b0"8
wPb0"8
b0"8
b0"8
b0"8
 }Zb0"8
}Zb0"8
 ~Zb0"8
~\b0"8
Bc0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
2QK'2
bQNn2
rQO/2
QR12
QS12
QV12
QW12
"RZ"3
b3xA
J-0-
J-P-
"8)@M
`H+0
.0QH
GaG7d
V r;K
0Pa 
2@K0
('r`0
HA-.
HJ+ 
,A5P
.PHYi
DLo/0a
h1lC
Tp~Z
`/0QD
i0Pa
.0aA}
v`c0
/0aA
xv0"
v0b
obMK
@0K
vj`H
I('auD
@DW&
~0KI
0'auD
0@f
@D;}n
v0\Hsa
f~p
)R9S
2D$H
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
A#66
%QZP
2(IP
2HMP
 5Bd
2D$H
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
A#66
(~@X@
;K`T
2LU0
9('auD
B17
5`8K0T
,A1P
@pb0
F}B7
xIYpp
o3ODH
BPFpu
%0J
2$H0
PH-p
,ASH
6/ |
1('auD
5P8K0T
FqB7
2 I`
2I~m
2D$H
`@R
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
ksi{#
c+s1c
XA/h
20KPB)\
B0K 
^ PC
D0KP
r0K 
KX81
%('auD
@-S~
#(5}
`]LDH
)R9So
)R9S}
@akk!
V0\Hc
7Dd
t$r
f0@f 
_>m/
`HV$
2D$H
 0BXe`!P
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
lnJP
KP4Y
/HAL
_a*&
?c_a'G
5^!B
fa6]Q
\QJ'
g*e[
ls1[
lo0Z1
Ya[j
Yq/R
m5-Y
9gtXA
|d8X1.
W1_f
WAZ#z
 $ x@
 <nx@
 twy@
 l5z@
 dcz@
 $d{@
 xw{@
 (#|@
 |*|@
 hf|@
 ds|@
 h$}@
 h-}@
g+dVA
TA_sG
n1tS
p(8S
p*SA
*&-R17v"
QQFZ
/jkQQ
;aQQ
`?7Q
s-Q!F
)tzP
(;iPa
+w8P
i80P
%&(P
  '{@
 l4{@
 8a{@
 |#|@
 |>|@
 4o|@
 4w|@
 d-}@
 08}@
 l=}@
 |b}@
 xg}@
 hl}@
 (q}@
 <z}@
T    D
(@@@@
)@@@@
Xb0"
Bb0"
Bb0"
Bb0"
Db0"
db0"
Fb0"
Fb0"
Fb0"
Fb0"
Fb0"
Fb0"
Hb0"
Nb0"
Nb0"
Nb0"
Pb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
`D0V
(ag"2
`D0V
`D0V
`D0V
4!j$2
`D0V
8aj$2
`D0V
`D0V
`D0V
d!kd2
`D0V
hak(2
`D0V
`D0V
`D0V
t!n)2
`D0V
xan)2
`D0V
`D0V
`D0V
!o+2
`D0V
ao+2
`D0V
`D0V
`D0V
!r+2
`D0V
ar+2
`D0V
`D0V
`D0V
!s+2
`D0V
as+2
`D0V
`D0V
`D0V
!v+2
`D0V
av+2
`D0V
`D0V
`D0V
$"w 3
Ff0" 
Ff0" 
hf0" 
Jf0" 
Jf0" 
Jf0" 
Lf0" 
f0" 
Lj/e
Rf0" 
AMr/e
Rf0" 
Mz/e
Rf0" 
Tf0" 
Tf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
0Xf0" 
0Xf0" 
1Xf0" +
1Xf0" 
2Xf0" 
2Xf0" 
3Xf0" +
3Xf0" 
4Xf0" 
4Xf0" 
5Xf0" +
5Xf0" 
6Xf0" 
6Xf0" 
7Xf0" +
7Xf0" 
8Xf0" 
8Xf0" 
9Xf0" +
9Bh0" 
A;bP
@PA
n8@3
&.1bB 
TpZX
1aB 
-(``A
EMX7P
.0q
J- B`A
@(tZ
fK+ 
2HQP
x7-!
2PYp
2h]0
.?LX
ws3bP
wu5bP
3YqBB\
B3 E
+~m
 LNd
05o
0@f
$&(*,.02468:<>@BDFHJLNPRTVXZ\
<<<<H<<<<Y
EEEEEELEEEEEEESEEEEEEEEEEEEEEEE
oljn
....)GDBF
{{B{j{{{{v
----------------------
-----------
uuuu#
DDDDD
jjjj
jjhhhhhhhhhhhhhhhhjj
@,26
*4(8
:B<>DF.0
22QG
I((KK
KMKKKKO
U}}.++
../++
449?
%,%%%%F
,.6 
&2//
yuu{{
{}{{{{
K==MM
MOMMMMQ
`ZZbb
bdbbbbf
PKPPPPM$
####
6U6U6UUUUUUUUUU666UUUUUUU
UUUUUUUUUUUUUU[U@
$+$$$$I
(0((((
NUNNNNf

(*((((,
_[[aa
acaaaae
NAAPP
PRPPPPT
@@@@@
4N4)&
(2((((4
Y#Y#Y#Y#
.((bb
b,bbbb04*
3,33330
.VV2**
=')
ZZZZ
GJGGGGL3//
<<6<H<<<<JLI
KVKKKKXOL3
NN3NVNNNN[
bbbb#
1111
wwwwwwwww
\\\\"UU
RRRRRRRRR]a
xlZ
nnZnpnnnnt
8~__
+8IL\r~
 "    $(
"$""""&
DDD@DDDV
pwGDl
pwGDpww
//////
zODD
DD@DD
%%%%%%%!%%%%%%%%%%%%%%%#
%%%%%%%!%%%%%%%%%%%%%%%#
)!)))#)))))))')))))))))))))))%
OOOOO1OO11
'*******%****)
VVVVV
VV``
%%%%%%%!%%%%%%%%%%%%%%%#
)#)))!)))))))%)))))))))))))))'
`cf9il
<?oBrEux{~
%%%%%%%
%%%%%%%%%%%%%%%
V"V"V"V"V"V"V"V"S
V"V"V"V"V"V"V"V"V"V"V"V"V"V"V"V"V"V"V"V"V"V"V"V"V"V"V"V"V"V"V"
B"B"B"B"B"B"B"B"B"B"B"B"B"B"B"B"B"B"B"B"B"B"B"B"B"B"
B"B"B"B"B"B"B"B"B"B"B"B"B"B"B"B"B"B"B"B"B"B"
"&*.5GKT
/377;?GKOS
$$$$$$$$
&$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$
 (08@
"%5*-0
HN6T
$`<
iiiiiii
iiiii
iiiiiiiiiiiiiiiiiiiiiiiiiiiii
xz|~
^^^^^^^^^^
6<*B
-86$G
13/7<95;
FuFFF
@DoooooooooooooHL
%\D\\\H
%
2?4)y
F{Q\gk
*******
#;E?EEEAEEEEEEECEEEEEEEEEEEEEEE=
/-919993999999959999999999999997
&CI4L)P/
3333333357
DGJY
_behk
8;>A
/a<aaa>aaaaaaa@aaaaaaaaaaaaaaa1
0^?^^^A^^^^^^^C^^^^^^^^^^^^^^^2#
0AZFZZZKZZZZZZZPZZZZZZZZZZZZZZZU
7,.024
#*1111111111111C111111J1111Q1111111111111111111111111111111111111111111111111111X
P8:P=@
<@DHLPTX\`dhlptx
\\\\\\\\\\\\\\\\\\\\\\\\\\
\\\\\\\\\\\\\\
\\\\
/)))))))))))))))))))))8
4;iiiiiiiiiiiiii
iiiii@
#0YY
Xccccccccccccc
ccccc
cccccccccccccccccccccccccccccccccccccc
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||9=|A|EIMQ
%xx1
e,CeeW
!(gg`
8TTL
 *tti
)Bhh\
yyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
y-9yy
ytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyE
 "$&(*,.02468:<>@BDFHJLNPRTV
+-/13579;!
1111
11111111151O
<OOS
0 $(,
v"fz
jRn2
FU^{
5BO\g
$-6?HQZclu~

666666
6666666A666666666666666I
&2JN>W
,&,,,.,,,,,,,0#
8>888@8888888B888888888888888D/
DVDDDXDDDDDDDZDDDDDDDDDDDDDDDRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDT;
PhPPPjPPPPPPPlPPPPPPPPPPPPPPPnPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPpG
\~\\\
\\\\\\\
\\\\\\\\\\\\\\\
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
hhhhhhh
hhhhhhhhhhhhhhh
hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
IN+V
MM#)
::::::
::::::::::::::::"
TTTTTTTTTTTTTTTTTTTT
T!2;TTTTTTTTTTTTTTDTTTYTTTb
'GGGGGGGGGGGGGGGGGGGGGG9
OOOO!%
OOOO!
1NNcM
FU_{
syylr
9JJ;@
27<AFKP
UZ_di
+LLLLLLLLLLLLLLLLLLLL3LLLLLLLLLLLL
uuuuuuuuuuuuuu
uuuuu@u@
FJNRVZ
,$39$?C
$$(P
;72F
    
  {{{{{{{{{{{{{{{{  
%+!:
.9!]OU
l]]Yk
_YYU^
>>>>>>>>>>>>>>(>>>>>>>4>>>>>4{
<<<<<<<<<<<<<<<<<<<<S<<<<<<<<<<<<<<<<<<<<<<%
1--33
3533337
#((((((((((((((
RRRRRRRRRRRRRRRRRRRRRRR
RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR
RR RR
RRRR
RRRRRRRRRRR&,R2R8RRRRRRRRRRRRRRRRRRR>RRRRRRRRRRRRRRDI
RRRR
RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRNRRRRRRwRRRR}RRRRRRRRRRRRRRRRRRRRRRRRRRRR
RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR
RRRRRRRRRRRRR
RRRRRRRRRR
VffSQ
#9>+
&.S]8.#
%!!''
')''''+
@@@@@@@@@@@@
Q
ie`t
Tccccccccc^cTcccccccccccc
ccccccccccccccccccccccccccccccccccccccXX
55gcc
jff
i8b  
    
7,,
77.**
686666:
ii[XX
(1:<GPZcx
11R--
660--
)QQ  
    
  zzzzzzzzzzzzzzzz  
<FEEFEE
FEEFEE
FEE`EEFEE`EE
 #&)
,/258;>ADGJMPSVY
liveOnEntry
Optimization Remark Emitter
G&,5ER
.,,,
0JHHH
$   
E'''
u(((
!!!1'
iYYY
<SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSC
IIIIII
RII\
FFDDd
B111
    
  JJJJJJJJJJJJJJJJ  
x$$$
KKhh
],].
dddddd
eeeeeeT
TTTTTTq
+###
aiii

ff7N
N!!!
!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!+
!!!!!!!!!!!!!!!!!!!!!!!
!!!!
!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!
[[[aaagggmsssmmyyy






>D&&(
"$""""&

dddddddd
!(*.0,2
0aC{L(eeeee
eee-eeeeeee/eee1e36
-058;@E**JOT
:L\v
YYYYYYY
YYYY
36WY
Y!$9
'*<25J
JJJJJJJ
JJJJ
8;>HJ
!*U7UG
CCCC
CCCCCCC-$
&@Z 
 PV]dsy
'2CS
/5A_
!0?HQ`o~
'2>HS
<<<<<<<<<<<<<
))XXXX9
44XXXX
IXXXXXXXXXXXXX0&
---!
$+4;BKR[d
 '.;BI`g
#*1:CMX
#0YY
++++++MQ+++++++++++++++++++++++++++++++++++++U


!-oo
++++#
kkkk
;;;;
+XXXX
JOV\cisy
!.7HYfs:EP**
+29@G
J#JJJJ*
:44??
?8????<
7B:BBB4E;
?99DD
D=DDDDA
4969992MC
GAALL
LELLLLI
%I(III"RH
LFFQQ
QJQQQQN
%I(III"08(C
:66<<
<><<<<@
e=^^^
^^!!^^r^^^
$0<HT`lx
////
yyyy#
HHHH
yyyy#
HHHH
yyyy#
HHHH
EEEE#
++++#
II}III
;;;;;;;;;
;;;;;
;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-?:\,[]{}#&*!|>'"%@`
")HKUekx{
)+))))-1'
)##++
+-++++/:4=@CFlILO
////////.
JJJJJJJ
JJJJJJJJJJJ
JJJJ@
?,,?
??,?
////:
////////w
JJJJJJJ
JJJJJJJJJJJ
JJJJC
??????
???????
++++
++++
..D...E
..T...D
..D...D
..D...D
..D.
MMLL[
MMLL[
MMLL[
LLLLMMMMMM
MMLL[
MMLL[
MMLL[
MMLL[
LLLLMMMMLLL
LLLLMMMMLLL
LLLLMMMMLL
MMLL[
LLLLMMMMLLLLMMMMML
MMLL[
MMLL[
MMMD
LLLLMMMMLLL
LLLLMMMMLL
MMMD
LLLLMMMMLL
MMMD
...D...D...D...D...D...D..D
,,,,YYYY;;;;JJJJ,,,
,,,,YYYY;;;;JJJJ,,,
,,,,,,,
,,,,,,,
,,,,,,,
YYJJ;;,,JJ;;YYJJ;;,,JJ;;U99
YYJJ;;,,JJ;;YYJJ;;,,JJ;;U99
zzzz
zzzz
;;;;JJJJ;;;;JJJJUD
,,,,YYYY;;;;JJJJU99
;;;;JJJJ;;;;JJJJUD
,,,,YYYY;;;;JJJJU
,,,,YYYY;;;;JJJJ@
PD33PD33PD33PDDDPDDDPDDDPD33PD33PD33P4
PD33PD33PD33PDDDPDDDPDDDPD33PD33PD33PD4
PD33PDDDPD33P4
PD33PDDDPD33PD4
,,,,,,,
zzzzzzz
;;;;;;;;zzz
;;;;J,,JJ;;JJ;;JJ,,JJ;;JJ;;J;,,
zzzzJJJ,;JJ
YYYYYYY
JJJJJJJ
JJJJJJJ
,,,,JJJ
,,,,,,,
;,,;YJJY,YY,J;;J;,,
;,,;YJJYJ;;J,,,,JJJJ;;;;;,,;YJJYJ;;J,,,,JJJJ;;;;;,,;YJJYJ;;J;,,;YJJYJ;;J;,,
,,,,;JJ
,,,,,,,,,,,
{{{{
----KKK
B|||C
 K.D0L.D [.D [.D0
GB,,,
|L|CJ
[BJzJ
L|LC
BYzY
[{[BJzJ
L|LCYzY
[{[B
BzYz
{[{B
[BL|LCYzY
[{[BJzJ
L|LCYzY
[{[B|L|C
BzYz
{[{B0
Bzzz
|||C0
|<|C;z
B|||C0
B|||C0
 K.D0L.D [.D [.D3
JJJJKKKKLLLLJJJJKKKKLLLLJJJJKKKKLLLLJJJJKKKKLLLLJJJJKKKKLLLL;;;;<<<<====
zzJz{{K{||L|YYYYZZZZ[[[[,,,,----
YYYYZZZZ[[[[YYYYZZZZ[[[[JJJ
JJJJ.
zzzz
,,,,;;
YYY"
JJJJYJJYYJJYJJJJYJJYYJJYJ;;J;;;;J;;J;;;;J;;JJ;;J,,,,,,,
))))
!!#!#
""""""""""""""
%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%
""""""""""""""""""
"""""
##########
''''''
((((
((((((((((((((((
((((((((
))))))))
))))))))
))))))))
*****
**********
******
,---
0000
0000000000000000000100


BEHK-NQTW0
ilZ]`3'
or6cu
${<~?f)*1111101
==)-
&$&&&&(
B@BBBBD
+-1/111
!!!!
,.,,,,0
/))11
1311115-&
,/,,,,2M
,&,,,,(
'4AN[hu
'4AN[hu
EEEE#
EEEE#
EEEE#
EEEE#
EEEE#
BGBBBBu
fl6r<x
ccccccccc
W\_2+
8K_T
8K_T 


"%(+.
:=C@
   ...
CKEW
4444O
3A333T
49<7
!(:H
&=HVdoz
                                                                                
=CO\`
=CO\`
[0;30m
[0;31m
[0;32m
[0;33m
[0;34m
[0;35m
[0;36m
[0;37m
[0;1;30m
[0;1;31m
[0;1;32m
[0;1;33m
[0;1;34m
[0;1;35m
[0;1;36m
[0;1;37m
[0;40m
[0;41m
[0;42m
[0;43m
[0;44m
[0;45m
[0;46m
[0;47m
[0;1;40m
[0;1;41m
[0;1;42m
[0;1;43m
[0;1;44m
[0;1;45m
[0;1;46m
[0;1;47m
#'+/37;?
!%)-159=AEIMQUY]aeimquy}
hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
#&*.2hhhhhhhhh6:>BFIMQUY]ahhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhe
6"68
 (9J[l
N3iga10FatalErrorE
St13runtime_error
+1%>5
'$-0*.(
"%(H)
258;>
 #&h
ILORU
Z]`cf
!$'*-
%(+.1oI
"%(+.
&),/2!f
X[^ad
ux{~
147:=4+
 #&)
,++((
VY\_b1(
 #&4
69<?B
DGJMP1(
 #&xo
adgjmI@
258;>vm
_behkvm
_behk
UX[^a1(
 #&4
69<?B
DGJMPJA
369<?xo
adgjmI@
258;>
]`cfi#
,/258
,/258
>ADGJ
 #&)
69<?B
 #&YP
BEHKN
147:=
147:=
69<?B
 #&YP
BEHKN
"%(E&
 #&)
&-4>ELr@
#*18?FMT[bip
2:BJRZbjr
!(/6>IP\f
JRZbjrz
$)05<AJRZa
EIOSY]ci
 #&),/2;DGJMVY
&*.2
)$7$$$
$$$$$$$
$$$$$$$$$$$$$$$
..2:CKS
&.6>
#*18?FMT[bipN3iga11SyntaxErrorE
!"#$
)*+,
__Buffer_Typed_DIM_Resource
__1D_DIM_Resource
__1D_ARRAY_DIM_Resource
__2D_DIM_Resource
__2D_ARRAY_DIM_Resource
__3D_DIM_Resource
__Cube_DIM_Resource
__Cube_ARRAY_DIM_Resource
Warning: File name not specified with the -dump-opt-llvm option.
Old LLVM IR (possibly from legacy binary) :  not supported!
<origin>
Parsing llvm module failed!
-cmc
-instcombine-code-sinking=0
gpu_64-applecl-macosx
runtime.cligc64.bc
Error loading the Generic builtin resource
Error lazily loading bitcode for generic builtins,is bitcode the right version and correctly formed?
Error loading the Generic builtin module from buffer
ci-15.36-xxxxx
vector
-cl-replace-global-offsets-by-zero
-cl-kernel-debug-enable
-cl-include-sip-csr
-cl-include-sip-kernel-debug
-cl-include-sip-kernel-local-debug
-cl-intel-use-32bit-ptr-arith
-cl-intel-greater-than-4GB-buffer-required
-cl-intel-has-buffer-offset-arg
-cl-intel-gtpin-rera
-cl-intel-no-prera-scheduling
-cl-intel-use-bindless-buffers
-cl-intel-use-bindless-images
-cl-fp32-correctly-rounded-divide-sqrt
-cl-no-subgroup-ifp
-cl-uniform-work-group-size
compilation error
 -filetype=spv
 -platform=
-dumpvisa
 -dumpvisa
basic_string
SmallVector capacity overflow during allocation
Allocation failed
Total
Invalid Pass 
error: 
error: backend compiler failed build.
simd
FastStage1
BestStage1
RestStage2
SinglePatch
DualPatch
EightPatch
entry
IGC::PositionOnlyVertexShader
UserFunction
type
BorderColorR
BorderColorG
BorderColorB
BorderColorA
localSize
CorrectlyRoundedDivSqrt
offset
size
IGCMetadata
vector
air64-apple-macosx
metadata
moduleHash
air.vertex
visaStackCall
 undefined reference to `jmp()' 
Invalid user defined function being processed: 
Add implicit args to all functions in the module and adjusts call to these functions
igc-add-implicit-args
coarse_phase
pixel_phase
sample_phase
legacy
vector
igc.functions
Analyzes CallGraphSCC
igc-callgraphscc-analysis
AddImplictArgs
BuiltinCallGraphAnalysis
deviceEnqueueDefaultDeviceQueue
deviceEnqueueMaxWorkgroupSize
deviceEnqueueParentEvent
deviceEnqueuePreferedWorkgroupMultiple
deviceEnqueueGetObjectId
deviceEnqueueGetBlockSimdSize
localMemStatelessWindowStartAddr
localMemStatelessWindowSize
PrivateMemStatelessSize
map::at:  key not found
Set Functions' linkage and attributes
igc-process-func-attributes
ProcessFuncAttributes
referenced-indirectly
KMPLOCK
less-precise-fpmad
true
unsafe-fp-math
no-infs-fp-math
no-nans-fp-math
__builtin_IB_AllocLocalMemPool
IndirectlyCalled
Set builtin MetaData
igc-process-builtin-metaData
ProcessBuiltinMetaData
Types Legalization pass
types-legalization-pass
Types Legalization Pass
Legalize calls to functions/subroutines and their signatures
igc-legalize-function-signatures
LegalizeFunctionSignatures
llvm.
_igc_bif_%s_%s
_igc_bif_%s_%s_size
/System/Library/Frameworks/OpenCL.framework/Resources/
vector
reqd_work_group_size
vec_type_hint
work_group_size_hint
GTPIN_IGC_OCL Error: Fail to find a free BTI for GT-Pin surface %d
GTPIN_IGC_OCL Error: Failed to call GTPIN_IGC_OCL_UpdateKernelInfo
Malformed block
Invalid record
Invalid bitcode signature
Invalid bitcode wrapper header
Unexpected end of file
Invalid value
Incompatible epoch: Bitcode '
' vs current: '
Could not find function in stream
Trying to materialize functions before seeing function blocks
Expect SubBlock
Expect function block
 (Producer: '
' Reader: 'LLVM 
7.0.0')
Insufficient function protos
Invalid function metadata: incoming forward references
Invalid ID
Invalid cast
Explicit gep type does not match pointee type of pointer operand
EXTRACTVAL: Invalid instruction with 0 indices
EXTRACTVAL: Invalid type
EXTRACTVAL: Invalid struct index
EXTRACTVAL: Invalid array index
INSERTVAL: Invalid instruction with 0 indices
INSERTVAL: Invalid type
INSERTVAL: Invalid struct index
INSERTVAL: Invalid array index
Inserted value type doesn't match aggregate type
Invalid type for value
Explicit invoke type is not a function type
Callee is not a pointer
Callee is not of pointer to function type
Explicit invoke type does not match pointee type of callee operand
Insufficient operands to call
Personality function mismatch
Old-style alloca with a non-pointer type
Fast math flags indicator set for call with no FMF
Explicit call type is not a function type
Callee is not a pointer type
Explicit call type does not match pointee type of callee operand
Fast-math-flags specified for call without floating-point scalar or vector return type
Invalid instruction with no BB
Operand bundles found with no consumer
Never resolved value found in function
Invalid function metadata: outgoing forward refs
Invalid constant reference
Invalid constant type
Explicit gep operator type does not match pointee type of pointer operand
Invalid gep with no operands
Invalid value name
Invalid alignment value
Load/Store operand is not a pointer type
Explicit load/store type does not match pointee type of pointer operand
Cannot load/store from pointer
Never resolved function from blockaddress
Malformed global initializer set
Invalid multiple blocks
Unknown attribute kind (
Bitwidth for integer type out of range
Invalid type
Invalid function argument type
Invalid TYPE table
Invalid vector length
Invalid TYPE table: Only named structs can be forward referenced
Expected a constant
Alias and aliasee types don't match
Invalid multiple synchronization scope names blocks
Invalid empty synchronization scope names block
Invalid global variable comdat ID
Invalid calling convention ID
Invalid function comdat ID
Linker Options
llvm.linker.options
Expected a single module
opencl.kernels
llvm.global.annotations
Unify
e-p:32:32:32
e-p:64:64:64
-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v24:32:32-v32:32:32-v48:64:64-v64:64:64-v96:128:128-v128:128:128-v192:256:256-v256:256:256-v512:512:512-v1024:1024:1024-n8:16:32
opencl.compiler.options
opencl.compiler.ext.options
opencl.enable.FP_CONTRACT
opencl.used.optional.core.features
opencl.used.extensions
opencl.spir.version
opencl.ocl.version
libigcmc.so
cmc_load_and_compile
cmc_free_compile_info
cannot load symbol cmc_load_and_compile
cannot load symbol cmc_free_compile_info
ICLLP
Move static allocas to entry basic block of the function
igc-move-static-allocas
MoveStaticAllocasPass
vararg
tracepoint
llvm.dbg.cu
air.fragment
air.kernel
align
texture_buffer
bindless_image1d_buffer_t
texture1d_array
bindless_image1d_array_t
texture1d
bindless_image1d_t
texture2d_array
bindless_image2d_array_t
texture2d_ms
bindless_image2d_msaa_t
texture2d_ms_array
bindless_image2d_array_msaa_t
texture2d
bindless_image2d_t
texture3d
bindless_image3d_t
texturecube_array
bindless_image_cube_array_t
texturecube
bindless_image_cube_t
depth2d_array
depth2d_ms_array
bindless_image2d_array_msaa_depth_t
depth2d_ms
bindless_image2d_msaa_depth_t
depth2d
bindless_image2d_depth_t
depthcube_array
bindless_image_cube_depth_t
depthcube
bindless_image_cube_array_depth_t
sampler
bindless_sampler_t
air.
product
base_vertex
base_instance
base_patch
tess_factor_scale
tess_instance_stride
patch_index_buffer_offset
msaa_sample_pattern_offset
virtual_binding_table_vs
virtual_binding_table_ps
virtual_binding_table_hs
virtual_binding_table_ds
work_dim
local_size_x
local_size_y
local_size_z
global_size_x
global_size_y
global_size_z
global_offset_x
global_offset_y
global_offset_z
num_work_groups_x
num_work_groups_y
num_work_groups_z
enqueued_local_size_x
enqueued_local_size_y
enqueued_local_size_z
stage_in_grid_origin_x
stage_in_grid_origin_y
stage_in_grid_origin_z
stage_in_grid_size_x
stage_in_grid_size_y
stage_in_grid_size_z
virtual_binding_table_cs
__builtin_IB_get_local_size
__builtin_IB_get_global_size
__builtin_IB_get_enqueued_local_size
__builtin_IB_get_num_groups
__builtin_IB_get_stage_in_grid_origin
__builtin_IB_get_stage_in_grid_size
__builtin_IB_get_simd_id
__builtin_IB_get_local_id_x
__builtin_IB_get_local_id_y
__builtin_IB_get_local_id_z
__builtin_IB_get_group_id
Legalize Global Value Usages
igc-legalize-global-value-usages
UserSubroutine
AirArgumentPropagation
_tmp
UserDefined
air.hull
This is a generic pass for builtins custom-lowering.
air-builtin-handler
AirMsaaSamplePattern
AirInlineBuiltins
air.visible
air.emulation
mainFunc
air.read
ConstSampler
TessInputControlPointCount
MaxNumOfOutputSignatureEntries
MaxNumOfInputSignatureEntries
MaxNumOfPatchConstantSignatureEntries
__TessNumControlPoints
max-work-group-size
AIR conversion to IGC
igc-air-conversion
isGlobalSizeGT0
threads_per_grid_end
globalSizeUnavaliable
thread_index_in_threadgroup_end
cond_dim3_true
cond_dim2_true
air.read_write
air.write
igc.read_only_array
AIR Conversion
air.struct_type_info
llvm.memcpy.p
.emulation.
wrapper
air.indirect_buffer
air.buffer
air.emulation_argument
Emulate Argument Buffers
igc-emulate-argument-buffers
air.intersection
air.vertex_id
air.instance_id
air.base_vertex
air.base_instance
air.thread_position_in_grid
air.threads_per_grid
air.thread_position_in_threadgroup
air.thread_index_in_threadgroup
air.threads_per_threadgroup
air.threadgroups_per_grid
air.threadgroup_position_in_grid
air.thread_execution_width
air.patch_id
air.position_in_patch
air.stage_in_grid_origin
air.stage_in_grid_size
air.thread_index_in_quadgroup
air.thread_index_in_simdgroup
air.threads_per_quadgroup
air.threads_per_simdgroup
air.amplification_id
air.amplification_count
air.location_index
air.arg_type_name
air.arg_name
air.sample
air.arg_type_size
air.arg_type_align_size
air.raster_order_group
const
global
local
constant
__global
__constant
float
float2
float3
float4
packed_float
packed_float2
packed_float3
packed_float4
half
half2
half3
half4
packed_half
packed_half2
packed_half3
packed_half4
int2
int3
int4
packed_int
packed_int2
packed_int3
packed_int4
uint
uint2
uint3
uint4
packed_uint
packed_uint2
packed_uint3
packed_uint4
short
short2
short3
short4
packed_short
packed_short2
packed_short3
packed_short4
ushort
ushort2
ushort3
ushort4
packed_ushort
packed_ushort2
packed_ushort3
packed_ushort4
char
char2
char3
char4
packed_char
packed_char2
packed_char3
packed_char4
uchar
uchar2
uchar3
uchar4
packed_uchar
packed_uchar2
packed_uchar3
packed_uchar4
long
long2
long3
long4
packed_long
packed_long2
packed_long3
packed_long4
ulong
ulong2
ulong3
ulong4
packed_ulong
packed_ulong2
packed_ulong3
packed_ulong4
double
double2
double3
double4
packed_double
packed_double2
packed_double3
packed_double4
bool
bool2
bool3
bool4
packed_bool
packed_bool2
packed_bool3
packed_bool4
float2x2
float2x3
float2x4
float3x2
float3x3
float3x4
float4x2
float4x3
float4x4
half2x2
half2x3
half2x4
half3x2
half3x3
half3x4
half4x2
half4x3
half4x4
void
indirect_command_buffer
visible_function_table
intersection_function_table
primitive_acceleration_structure
instance_acceleration_structure
r8unorm
r8snorm
r16unorm
r16snorm
rg8unorm
rg8snorm
rg16unorm
rg16snorm
rgba8unorm
srgba8unorm
rgba8snorm
rgba16unorm
rgba16snorm
rgb10a2
rg11b10f
rgb9e5
AirEmulateArgumentBuffers
__flag_begin_marker
__flag_end_marker
Insert markers around builtin calls marked with fast flag
air-fast-flag-propagation-mark-pass
Resolve fast flag markers to operand attributes
air-fast-flag-propagation-resolve-pass
AirFastFlagPropagationMark
AirFastFlagPropagationResolve
igc.internal_symbol
AIR Function Attribute Update
igc-air-function-attribute-update
Air Function Attribute Update
unordered_map::at: key not found
__air_sampler_state_static
air.sampler_states
air.sampler_state
cubeMapCoordArray
struct._sampler_t
CmpXchgFail
rg11b10
rsqrt_chan
__builtin_IB_get_snap_wa_reqd
__builtin_IB_is_normalized_coords
__builtin_IB_get_group_id
__builtin_IB_get_local_id_x
__builtin_IB_get_local_id_y
__builtin_IB_get_local_id_z
Pass legalizes texture and sampler addrspaces from GLOBAL/CONSTANT to indirect
igc-air-function-builder
denorm_or_zero
sat_exp
denorm_exp
denorm_exp_loop
denorm_exp_loop_end
denorm_or_zero_end
AirFunctionBuilder
AirPropagateAssumptions
air-propagate-assumptions
for arguments marked with raster_order_group, emit sendc
air-raster-order-groups
AirRasterOrderGroups
AirResolveInlineSamplerWA
Colects read-write textures indexes and removes texture fences
air-rw-texture-analysis
AirRWModification
Pass walks through sampler uses and detects sampler to texture mappings, and converts Sample to SampleL instructions.
igc-air-samplers
AIR Samplers
Pass walks through kernel and checks if there remains any unresolved air builtin function, in which case it is flagged as an error.
igc-check-unresolved-builtin-functions
Check unresolved builtin functions
Workaround for FP16div optimization causing a overflow
igc-workaround-FP16Div
FP16DivWorkaround
Trivial greedy live range reduction to reduce register pressure for special cases.
greedy-live-range-reduction
HSOutputControlPointCount
TessInputControlPointCount
MaxNumOfInputSignatureEntries
MaxNumOfOutputSignatureEntries
MaxNumOfPatchConstantSignatureEntries
HSEntry
HullShaderForcedDispatchMask
HullShaderDispatchMode
TessellationShaderDomain
igc-air-legalize-resource-addrspace
LegalizeResourcePointer
LegalizeStructLoadStores
Loop Exit Canonicalization Pass
loop-exit-canonicalization
air.global_bindings
air.external_initializations
voidProgram
output
input
air.fragment
air.vertex
air.kernel
air.hull
air.location
air.render_target
air.arg_unused
air.perspective
air.flat
air.no_perspective
air.center
air.centroid
air.interpolation_function
AIR to IGC metadata parser
igc-air-metadata-parse
AIR Metadata Parse
Air Metadata Schema Wrapper
igc-metadata-schema-wrapper
PreprocessMetadata
air.visible_function_references
ResolveExternalVisibleFunctionName
Translate AI
igc-translate-air
Translate AIR
Translate AIR Builtins
igc-translate-air-builtins
error: 
error: backend compiler failed build.
IGC::PositionOnlyVertexShader
CodeGenContext Wrapper
igc-code-gen-context-wrapper
CodeGen Context Wrapper
reducedIndex
Custom Pass Optimization
igc-custom-safe-opt
TrivialLocalMemoryOpsElimination
LastPatternMatch Pass
igc-gen-specific-pattern
Custom Const-prop Pass
igc-const-prop
Indirect ICB Propagaion
IGCIndirectICBPropagaion
NAN handling
NanHandling
Gen strength reduction
GenStrengthReduction
Flatten Small Switch
FCmpPaternMatch
flattenSmallSwitch
logicalAndToBranch
LogicalAndToBranch
if.then
if.else
if.end
GenSpecificPattern
const-prop with shader-const replacement
Unsafe Optimizations Pass
igc-custom-unsafe-opt-pass
Hoist FMul in Loop Pass
igc-hoist-fmul-in-loop-pass
Custom Unsafe Optimization Pass
EarlyOutPatterns
HoistFMulInLoopPass
.seg1
.seg2
.seg3
IGC Custom Loop Opt
igc-custom-loop-opt
IGC Loop canonicalization
igc-loop-canonicalization
.backedge
llvm.loop
Custom Loop Versioning
IGC loop canonicalization
BlendToDiscard
Pass promotes indirect addrspace resource access to direct addrspace
igc-promote-resources-to-direct-addrspace
PromoteResourceToDirectAS
Pass promotes stateless accesses to bindless accesses
igc-promote-stateless-to-bindless
PromoteStatelessToBindless
copysign
copysignf
copysignl
fabs
fabsf
fabsl
fmin
fminf
fminl
fmax
fmaxf
fmaxl
sinf
sinl
cosf
cosl
sqrt
sqrtf
sqrtl
powf
powl
exp2
exp2l
exp2f
floor
floorf
ceil
round
ffsl
labs
llabs
Dummy Pass for GenTTIImpl
gen-tti-dummy-pass
target-cpu
target-features
Fix the usage of GetBufferPtr, no combination of GetBufferPtr and GetResourcePtr
igc-fix-resource-ptr
FixResourcePtrPass
splitDouble
Convert load/store on doubles into store/loads on i32 or float types
igc-dp-to-fp-load-store
HandleLoadStoreInstructionsPass
preserve-nan
Preserve NAN (default false)
UnifiedReturnBlock
UnifiedRetVal
VISA Legalizer
igc-legalization
GenOptLegalizer
Legalization Pass
Low Precision Opt
igc-low-precision-opt
LowPrecisionOpt Pass
Metadata Utils Wrapper
igc-metadata-utils-wrapper
MetaData Utils Wrapper
SampleCmpToDiscard
Unsupported required sub group size
SPIR to IGC metadata translator
igc-spir-metadata-translation
printf
Translate ACL printf
igc-translate-acl-printf
Translate ACL Printf
enable-fmax-fmin-plus-zero
Enable fmax/fmin + 0.0f flag
Workaround pass used to fix functionality of special cases
igc-workaround
Workaround fmax/fmin
igc-wa-fminmax
WorkaroundAnalysis Pass
WAFMinFMax
iterBarriers
iterX
iterY
new_entry
newKernel
Perform analysis and apply optimization to combine number of software threads
igc-threadcombining
ThreadCombining
GenUpdateCB
Find interesting constants
igc-find-interesting-constants
Find Interesting Constants
dynamic texture folding
igc-dynamic-texture-folding
Dynamic Texture Folding
sample multiversioning
igc-sample-multiversioning
Sample Multiversioning
handling and lowering for data available across functions and dylibs
global-data-resolution-pass
GlobalDataResolutionPass
Cleans up symbols and relocation that are not longer needed due to various optimizations
symbol-relocation-cleanup
SymbolRelocationCleanup
Symbol Relocation Analysis provides info needed to generate symbol and relocation entries
igc-symbols-relocation-analysis
SymbolRelocation Analysis
kernel_arg_addr_space
apple.cl.arg_metadata
sampler_t
image
image1d_t
image2d_t
image3d_t
image1d_array_t
image2d_array_t
image1d_buffer_t
image2d_buffer_t
image2d_msaa_t
image2d_array_msaa_t
image2d_array_msaa_depth_t
image2d_msaa_depth_t
image2d_depth_t
image2d_array_depth_t
kernel_arg_access_qual
read
read_only
write
write_only
none
kernel_arg_type
kernel_arg_type_qual
kernel_arg_base_type
kernel_arg_name
-cl-std=CL1.2
-cl-kernel-arg-info
Resource indirection pass
igc-resource-indirection-pass
Resource Indirection Pass
Advanced Code Motion
globalSize
enqueuedLocalSize
Advanced MemOpt
Advanced Memory Optimization
igc-advmemopt
Mark empty blocks after deSSA
BlockCoalescing
Check individual type of instructions
CheckInstrTypes
InstrStatitic
KMPLOCK
label%d
-debug
-fasterRA
-noLocalSplit
igc.device.enqueue
kernel
kernel.asm
OutputAsmPath
main
ArgSize
RetValSize
Extern
Output
inline.visaasm
vector
CC Tuple
CC Tuple list: 
CC Tuple list end. 
coalesce moves coming payloads, insert and extract element
CoalescingEngine
.hoist
code sinking
CodeHoisting
Code Hoisting
Collect GS Properties
collectgeometryshaderproperties
CollectGeometryShaderProperties
twoScalar
chunkPtr
Constant Coalescing
igc-constant-coalescing
CE: 
Output
DebugInfoPass
---- AliasMap ----
  Aliasee: 
     
---- InsEltMap ----
  Root Value : 
       
---- Multi-value Alias (value in both AliasMap & InsEltMap) ----
  Root Value: 
 [aliasee]
       
 [aliasee]  
---- Phi-Var Isolations ----
Var isolated : 
Leader : 
    
coalesce moves coming from phi nodes
DeSSA
Collect information related to domain shader
igc-collect-domain-shader-properties
Lower inputs outputs for domain shader
igc-domain-shader-lowering
/// Inlined ASM
/// End Inlined ASM
INTEL_PATCH_PRIVATE_MEMORY_SIZE
EmitPass
V = 
I = 
.shl.outer.merge.lo
.shl.outer.merge.hi
.shl.outer.true.branch
.shl.merge.inner.lo
.shl.merge.inner.hi
.shl.inner.true.branch
.shl.inner.false.branch
.lshr.outer.merge.lo
.lshr.outer.merge.hi
.lshr.outer.true.branch
.lshr.merge.inner.lo
.lshr.merge.inner.hi
.lshr.inner.true.branch
.lshr.inner.false.branch
.ashr.outer.merge.lo
.ashr.outer.merge.hi
.ashr.outer.true.branch
.ashr.merge.inner.lo
.ashr.merge.inner.hi
.ashr.inner.true.branch
.ashr.inner.false.branch
.u2f.outer.merge
.u2f.outer.true.branch
.u2f.inner.merge.hi
.u2f.inner.merge.lo
.u2f.inner.true.branch
.u2f.rounding.merge.hi
.u2f.roudning.branch
IGC 64-bit ops emulation
igc-emu64ops
EstimateFunctionSize
Estimate Function Sizes
.fix1.addrspacecast
.fix1.bitcast
.fix2.addrspacecast
Fix invalid addrspacecast-relevant patterns
igc-addrspacecast-fix
Fixup extractvalue pairs
igc-extractvalue-pair-fixup
visaStackCall
GenXCodeGenModule
GenXFunctionGroupAnalysis
SubroutineInliner
FunctionGroup analysis
GenX CodeGen module
GenIR Lowering
Lowers GEP into primitive ones
igc-gen-ir-lowering
Gen Simplification
igc-shuffle-simplification
GeometryShaderLowering
resID
resTy
accessTy
needBufferOffset
llvm.used
llvm.metadata
llvm.genx.
Collect information related to hull shader
igc-collect-hull-shader-properties
Lower inputs outputs for hull shader
igc-hull-shader-lowering
Clear tessellation factors
igc-cleartessfactors
ClearTessFactors
Layout blocks
igc-layout
Layout
IGC Load Shrink
igc-ldshrink
LiveVarsAnalysis
Calculate liveness based on LiveVars
igc-livenessanalysis
LivenessAnalysis
Advanced DCE on loop
igc-loop-dce
Remove dead recurisive PHINode
igc-phielimination
uniform
Lower GEP of Private Memory to Register Pass
igc-priv-mem-to-reg
LowerGEPForPrivMem
memopt-merge-load
Controls count of merged loads
memopt-merge-store
Controls count of merged stores
IGC Memory Optimization
igc-memopt
IGC Memory Optimization, the 2nd
igc-memopt2
MergeURBWrites
NONE
__local
__private
nounwind
work_group_size_hint(
reqd_work_group_size(
intel_reqd_sub_group_size(
intel_reqd_workgroup_walk_order(
vec_type_hint(
printf.strings
Does pattern matching
CodeGenPatternMatch
CodeGenPatternMatchPass
PrimIdLocation
KillPixel
DiscardRet
postDiscard
Pixel shader lowering pass
igc-pixel-shader-addmask
This is the pixel shader lowering pass 
igc-pixel-shader-lowering
Lower discard intrinsics
igc-lower-discard
PixelShaderLowering
Lower Discard
bitset set argument out of range
PositionDepAnalysis
SetMathPrecisionForPositionOutput
PreRA rematerialize flag
igc-pre-ra-remat-flag
Use LivenessAnalysis to calculate register pressure
igc-registerestimator
RegisterEstimator
SimplifyConstant
PromoteConstant
PruneUnusedArguments
This is an analysis pass for pulling constants for short shaders 
Analyse shader to determine push const threshold
dynamicBufferOffset.bufferId
ConstantBufferIndexedWithInstanceId
promotes the values to be arguments
igc-push-analysis
PushAnalysis
Scalarizer in codegen
igc-scalarizer-in-codegen
Scalarizer in Codegen
GenX Register Pressure Analysis
igc-RegisterPressureEstimate
RegisterPressureEstimate
IGC PreRA Scheduler
igc-PreRAScheduler
__builtin_IB_memcpy_generic_to_private
__builtin_IB_memcpy_private_to_generic
__builtin_IB_memcpy_private_to_private
__builtin_IB_memcpy_global_to_private
__builtin_IB_memcpy_private_to_global
__builtin_IB_memcpy_constant_to_private
__builtin_IB_memcpy_private_to_constant
__builtin_IB_memcpy_local_to_private
__builtin_IB_memcpy_private_to_local
__builtin_IB_to_local
__builtin_IB_to_private
Resolve generic address space
igc-gas-resolve
Resolve compiler predefeind constants
igc-predefined-constant-resolve
OPTPre
UpdateOptPre
OPTPost
Check SIMD32 Profitability for OpenCL
simd32-profit
Simd32Profitability
TimeStatsCounter Start/Stop
time-stats-counter
.demoted.zext
Demote type safely
igc-type-demote
Detect non-uniform usage of textures and samplers and check if they may be assumed uniform.
UniformAssumptions
VariableReuseAnalysis
Compute-once pass that provides a translation table for mapping attributes for LLVM values
TranslationTable
Split loads/stores of big (or 3-element) vectors into smaller ones.
igc-vectorpreprocess
VectorPreProcess
split
scalarize
elt0
elt1
elt2
Elt0
Elt1
Elt2
Process vector loads/stores for explicit vISA variable layout
igc-vectorprocess
VectorProcess
IntToPtr2
vptrcast
vCastload
Collect information related to vertex shader
igc-collect-vertex-shader-properties
Lower inputs outputs for vertex shader
igc-vertex-shader-lowering
array::at
ComputeShaderLowering
print-wia-check
Debug wia-check analysis
WIAnalysis: 
Args: 
  unknown 
       ; preds =
 BB:
WIAnalysis
WIAnalysis provides work item dependency info
igc-wi-analysis
consecu
p_conse
strided
random 
Special const prop for SLM
igc-slmconstprop
Custom Pass for Position-Only Shader
igc-remove-nonposition-output
remove non-position output in vertex shader
debug_loc
vectorized
simd8
simd16
.debug_abbrev_begin
vector
info_string
func_begin
func_end
<stdin>
module_begin
module_end
line_table_start
section_line
igc.input.ir
Intel OpenCL 
debug_end
section_info
section_abbrev
dwarf_frame
debug_range
section_debug_loc
text_begin
.debug_info_begin
.debug_info_end
.debug_abbrev_begin
.debug_abbrev_end
Dwarf Version
$dup
.ptrcast
.off
.zext
.concat
.trunc
.legal
.promote
.soften
.sclr
.elt
.lsext
.rsext
.shl
.lshr
IGC Type Legalizer
igc-type-legalizer
Binary Instruction seen with illegal int type. Legalization support missing. Inst opcode:%d
IGC Int Type Legalizer
igc-int-type-legalizer
explicit_arg_num
struct_arg_offset
img_access_float_coords
img_access_int_coords
function_type
arg_desc
implicit_arg_desc
thread_group_size
thread_group_size_hint
sub_group_size
opencl_vec_type_hint
intel_reqd_sub_group_size
intel_reqd_workgroup_walk_order
PurgeMetaDataUtilsImport
igc-purgeMetaDataUtils-import
PurgeMetaDataUtilsPass
11ocl_image1d
14ocl_image1d
16ocl_image1darray
20ocl_image1d_array
17ocl_image1dbuffer
21ocl_image1d_buffer
11ocl_image2d
14ocl_image2d
16ocl_image2darray
20ocl_image2d_array
11ocl_image3d
14ocl_image3d
15ocl_image2dmsaa
19ocl_image2d_msaa
20ocl_image2darraymsaa
25ocl_image2d_array_msaa
20ocl_image2dmsaadepth
25ocl_image2d_msaa_depth
25ocl_image2darraymsaadepth
31ocl_image2d_array_msaa_depth
16ocl_image2ddepth
20ocl_image2d_depth
21ocl_image2darraydepth
26ocl_image2d_array_depth
24IGIL_EnqueueKernelShared9ocl_queuejPvjS_S_jS_jiPi9ndrange_tii12ocl_clkevent
24IGIL_EnqueueKernelShared9ocl_queuejPvjS0_S0_jS0_jiPi9ndrange_tii12ocl_clkevent
18IGIL_EnqueueKernel9ocl_queuejPvjS_S_jS_j9ndrange_ti12ocl_clkevent
18IGIL_EnqueueKernel9ocl_queuejPvjS0_S0_jS0_j9ndrange_ti12ocl_clkevent
33IGIL_EnqueueKernelWithLocalParams9ocl_queueiPijPvjS0_S0_jS0_j9ndrange_ti12ocl_clkevent
33IGIL_EnqueueKernelWithLocalParams9ocl_queueiPijPvjS1_S1_jS1_j9ndrange_ti12ocl_clkevent
28IGIL_EnqueueKernelWithEvents9ocl_queuejPvjS_S_jS_jiPi9ndrange_tiiPKU3AS412ocl_clkeventPU3AS412ocl_clkevent12ocl_clkevent
28IGIL_EnqueueKernelWithEvents9ocl_queuejPvjS0_S0_jS0_jiPi9ndrange_tiiPU3AS4K12ocl_clkeventPU3AS4S3_S3_
14enqueue_marker9ocl_queuejPKU3AS412ocl_clkeventPU3AS412ocl_clkevent
14enqueue_marker9ocl_queuejPU3AS4K12ocl_clkeventPU3AS4S0_
11read_imagef14ocl_image2d_ro11ocl_samplerDv2_fS_S_
11read_imagef14ocl_image2d_ro11ocl_samplerDv2_fS1_S1
11read_imagei14ocl_image2d_ro11ocl_samplerDv2_fS_S_
11read_imagei14ocl_image2d_ro11ocl_samplerDv2_fS1_S1_
12read_imageui14ocl_image2d_ro11ocl_samplerDv2_fS_S_
12read_imageui14ocl_image2d_ro11ocl_samplerDv2_fS1_S1_
11read_imagef20ocl_image2d_depth_ro11ocl_samplerDv2_fS_S_
11read_imagef20ocl_image2d_depth_ro11ocl_samplerDv2_fS1_S1_
11read_imagef20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS0_
11read_imagef20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS2_
11read_imagei20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS0_
11read_imagei20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS2_
12read_imageui20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS0_
12read_imageui20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS2_
11read_imagef26ocl_image2d_array_depth_ro11ocl_samplerDv4_fDv2_fS0_
11read_imagef26ocl_image2d_array_depth_ro11ocl_samplerDv4_fDv2_fS2_
11read_imagef14ocl_image3d_ro11ocl_samplerDv4_fS_S_
11read_imagef14ocl_image3d_ro11ocl_samplerDv4_fS1_S1_
11read_imagei14ocl_image3d_ro11ocl_samplerDv4_fS_S_
11read_imagei14ocl_image3d_ro11ocl_samplerDv4_fS1_S1_
12read_imageui14ocl_image3d_ro11ocl_samplerDv4_fS_S_
12read_imageui14ocl_image3d_ro11ocl_samplerDv4_fS1_S1_
12write_imagei14ocl_image3d_woDv4_iS_
12write_imagei14ocl_image3d_woDv4_iS0_
12write_imagei14ocl_image3d_rwDv4_iS_
12write_imagei14ocl_image3d_rwDv4_iS0_
12write_imagei16ocl_image2darrayDv4_iS_
12write_imagei20ocl_image2d_array_woDv4_iS0_
12write_imagei16ocl_image2d_array_woDv4_iS_
12write_imagei16ocl_image2d_array_rwDv4_iS_
12write_imagei20ocl_image2d_array_rwDv4_iS0_
12write_imagei16ocl_image2d_array_woDv4_iiS_
12write_imagei20ocl_image2d_array_woDv4_iiS0_
12write_imagei14ocl_image3d_woDv4_iiS_
12write_imagei14ocl_image3d_woDv4_iiS0_
29intel_work_group_vme_mb_queryPU3AS3jDv2_iS1_14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
29intel_work_group_vme_mb_queryPU3AS3jDv2_iS1_14ocl_image2d_roS2_11ocl_sampler
12DoMultiQueryPU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_ro14ocl_image2d_ro11ocl_samplerj
12DoMultiQueryPU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_roS3_11ocl_samplerj
37intel_work_group_vme_mb_multi_query_8PU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
37intel_work_group_vme_mb_multi_query_8PU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_roS3_11ocl_sampler
37intel_work_group_vme_mb_multi_query_4PU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
37intel_work_group_vme_mb_multi_query_4PU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_roS3_11ocl_sampler
41intel_work_group_vme_mb_multi_check_16x16PU3AS3jjjjDv2_ii14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
41intel_work_group_vme_mb_multi_check_16x16PU3AS3jjjjDv2_ii14ocl_image2d_roS2_S2_11ocl_sampler
39intel_work_group_vme_mb_multi_check_8x8PU3AS3jjjjDv2_iDv4_i14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
39intel_work_group_vme_mb_multi_check_8x8PU3AS3jjjjDv2_iDv4_i14ocl_image2d_roS3_S3_11ocl_sampler
47intel_work_group_vme_mb_multi_bidir_check_16x16PU3AS3jjjjDv2_ihhi14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
47intel_work_group_vme_mb_multi_bidir_check_16x16PU3AS3jjjjDv2_ihhi14ocl_image2d_roS2_S2_S2_11ocl_sampler
45intel_work_group_vme_mb_multi_bidir_check_8x8PU3AS3jjjjDv2_ihhS1_14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
45intel_work_group_vme_mb_multi_bidir_check_8x8PU3AS3jjjjDv2_ihhS1_14ocl_image2d_roS2_S2_S2_11ocl_sampler
52intel_sub_group_avc_ime_evaluate_with_dual_reference14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t
52intel_sub_group_avc_ime_evaluate_with_dual_reference14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_ime_payload_t
54intel_sub_group_avc_ime_evaluate_with_single_reference14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t
54intel_sub_group_avc_ime_evaluate_with_single_reference14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_ime_payload_t
64intel_sub_group_avc_ime_evaluate_with_single_reference_streamout14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t
64intel_sub_group_avc_ime_evaluate_with_single_reference_streamout14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_ime_payload_t
62intel_sub_group_avc_ime_evaluate_with_dual_reference_streamout14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t
62intel_sub_group_avc_ime_evaluate_with_dual_reference_streamout14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_ime_payload_t
63intel_sub_group_avc_ime_evaluate_with_single_reference_streamin14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t51intel_sub_group_avc_ime_single_reference_streamin_t
63intel_sub_group_avc_ime_evaluate_with_single_reference_streamin14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_ime_payload_t51intel_sub_group_avc_ime_single_reference_streamin_t
61intel_sub_group_avc_ime_evaluate_with_dual_reference_streamin14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t49intel_sub_group_avc_ime_dual_reference_streamin_t
61intel_sub_group_avc_ime_evaluate_with_dual_reference_streamin14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_ime_payload_t49intel_sub_group_avc_ime_dual_reference_streamin_t
66intel_sub_group_avc_ime_evaluate_with_single_reference_streaminout14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t51intel_sub_group_avc_ime_single_reference_streamin_t
66intel_sub_group_avc_ime_evaluate_with_single_reference_streaminout14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_ime_payload_t51intel_sub_group_avc_ime_single_reference_streamin_t
64intel_sub_group_avc_ime_evaluate_with_dual_reference_streaminout14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t49intel_sub_group_avc_ime_dual_reference_streamin_t
64intel_sub_group_avc_ime_evaluate_with_dual_reference_streaminout14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_ime_payload_t49intel_sub_group_avc_ime_dual_reference_streamin_t
52intel_sub_group_avc_ref_evaluate_with_dual_reference14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ref_payload_t
52intel_sub_group_avc_ref_evaluate_with_dual_reference14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_ref_payload_t
54intel_sub_group_avc_ref_evaluate_with_single_reference14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ref_payload_t
54intel_sub_group_avc_ref_evaluate_with_single_reference14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_ref_payload_t
54intel_sub_group_avc_sic_evaluate_with_single_reference14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_sic_payload_t
54intel_sub_group_avc_sic_evaluate_with_single_reference14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_sic_payload_t
52intel_sub_group_avc_sic_evaluate_with_dual_reference14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_sic_payload_t
52intel_sub_group_avc_sic_evaluate_with_dual_reference14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_sic_payload_t
_Z17get_global_offsetj
_Z12get_local_idj
_Z12get_group_idj
__builtin_spirv_BuiltInSubgroupId
get_sub_group_id
Built-in function pass
igc-builtin-import
PreBIImportAnalysis
BIImport
__enqueue_kernel_basic
__enqueue_kernel_vaargs
__enqueue_kernel_events_vaargs
_Z14enqueue_kernel
enqueue_IB_kernel
===> Materialize Failure: 
MCSOptimization
Loop Gating Optimization
loop-gating
GatingSimilarSamples
Convert builtin functions from OpenCL to common GenISA
igc-conv-ocl-to-common
BuiltinsConverterFunction
CoordZ
CoordX
CoordY
floatColor
ColorX
ColorY
ColorZ
ColorW
Inconsistent use of image!
__builtin_IB_OCL_1d_ldui
__builtin_IB_OCL_1darr_ldui
__builtin_IB_OCL_2d_ldui
__builtin_IB_OCL_2darr_ldui
__builtin_IB_OCL_3d_ldui
__builtin_IB_OCL_1d_ld
__builtin_IB_OCL_1darr_ld
__builtin_IB_OCL_2d_ld
__builtin_IB_OCL_2darr_ld
__builtin_IB_OCL_3d_ld
__builtin_IB_OCL_2d_ldmcs
__builtin_IB_OCL_2darr_ldmcs
__builtin_IB_OCL_2d_ld2dms
__builtin_IB_OCL_2darr_ld2dms
__builtin_IB_OCL_2d_ld2dmsui
__builtin_IB_OCL_2darr_ld2dmsui
__builtin_IB_OCL_1d_sample_l
__builtin_IB_OCL_1darr_sample_l
__builtin_IB_OCL_2d_sample_l
__builtin_IB_OCL_2darr_sample_l
__builtin_IB_OCL_3d_sample_l
__builtin_IB_OCL_1d_sample_d
__builtin_IB_OCL_1darr_sample_d
__builtin_IB_OCL_2d_sample_d
__builtin_IB_OCL_2darr_sample_d
__builtin_IB_OCL_3d_sample_d
__builtin_IB_OCL_1d_sample_lui
__builtin_IB_OCL_1darr_sample_lui
__builtin_IB_OCL_2d_sample_lui
__builtin_IB_OCL_2darr_sample_lui
__builtin_IB_OCL_3d_sample_lui
__builtin_IB_OCL_1d_sample_dui
__builtin_IB_OCL_1darr_sample_dui
__builtin_IB_OCL_2d_sample_dui
__builtin_IB_OCL_2darr_sample_dui
__builtin_IB_OCL_3d_sample_dui
__builtin_IB_write_1d_ui
__builtin_IB_write_1darr_ui
__builtin_IB_write_2d_ui
__builtin_IB_write_2darr_ui
__builtin_IB_write_3d_ui
__builtin_IB_write_2d_f
__builtin_IB_write_2darr_f
__builtin_IB_frnd_ne
__builtin_IB_ftoh_rtn
__builtin_IB_ftoh_rtp
__builtin_IB_ftoh_rtz
__builtin_IB_dtoh_rtn
__builtin_IB_dtoh_rtp
__builtin_IB_dtoh_rtz
__builtin_IB_dtof_rtn
__builtin_IB_dtof_rtp
__builtin_IB_dtof_rtz
__builtin_IB_dtoi8_rtn
__builtin_IB_dtoi8_rtp
__builtin_IB_dtoi8_rte
__builtin_IB_dtoi16_rtn
__builtin_IB_dtoi16_rtp
__builtin_IB_dtoi16_rte
__builtin_IB_dtoi32_rtn
__builtin_IB_dtoi32_rtp
__builtin_IB_dtoi32_rte
__builtin_IB_dtoi64_rtn
__builtin_IB_dtoi64_rtp
__builtin_IB_dtoi64_rte
__builtin_IB_dtoui8_rtn
__builtin_IB_dtoui8_rtp
__builtin_IB_dtoui8_rte
__builtin_IB_dtoui16_rtn
__builtin_IB_dtoui16_rtp
__builtin_IB_dtoui16_rte
__builtin_IB_dtoui32_rtn
__builtin_IB_dtoui32_rtp
__builtin_IB_dtoui32_rte
__builtin_IB_dtoui64_rtn
__builtin_IB_dtoui64_rtp
__builtin_IB_dtoui64_rte
__builtin_IB_itof_rtn
__builtin_IB_itof_rtp
__builtin_IB_itof_rtz
__builtin_IB_uitof_rtn
__builtin_IB_uitof_rtp
__builtin_IB_uitof_rtz
__builtin_IB_itofp64_rtn
__builtin_IB_itofp64_rtp
__builtin_IB_itofp64_rtz
__builtin_IB_uitofp64_rtn
__builtin_IB_uitofp64_rtp
__builtin_IB_uitofp64_rtz
__builtin_IB_frnd_pi
__builtin_IB_frnd_ni
__builtin_IB_frnd_zi
__builtin_IB_native_cosf
__builtin_IB_native_cosh
__builtin_IB_native_sinf
__builtin_IB_native_sinh
__builtin_IB_native_exp2f
__builtin_IB_native_exp2h
__builtin_IB_native_log2f
__builtin_IB_native_log2h
__builtin_IB_native_sqrtf
__builtin_IB_native_sqrth
__builtin_IB_native_sqrtd
__builtin_IB_popcount_1u32
__builtin_IB_popcount_1u16
__builtin_IB_popcount_1u8
__builtin_IB_native_powrf
__builtin_IB_fma
__builtin_IB_fmah
__builtin_IB_bfi
__builtin_IB_ibfe
__builtin_IB_ubfe
__builtin_IB_bfrev
__builtin_IB_fmax
__builtin_IB_fmin
__builtin_IB_HMAX
__builtin_IB_HMIN
__builtin_IB_dmin
__builtin_IB_dmax
__builtin_IB_mul_rtz_f64
__builtin_IB_mul_rtz_f32
__builtin_IB_fma_rtz_f64
__builtin_IB_fma_rtz_f32
__builtin_IB_add_rtz_f64
__builtin_IB_add_rtz_f32
__builtin_IB_thread_group_barrier
__builtin_IB_thread_group_barrier_signal
__builtin_IB_thread_group_barrier_wait
__builtin_IB_memfence
__builtin_IB_flush_sampler_cache
__builtin_IB_typedmemfence
__builtin_IB_simd_lane_id
__builtin_IB_vme_send_ime
__builtin_IB_vme_send_fbr
__builtin_IB_vme_send_sic
__builtin_IB_vme_send_fbr_new
__builtin_IB_vme_send_sic_new
__builtin_IB_vme_send_ime_new_uint4_uint8
__builtin_IB_vme_send_ime_new_uint8_uint8
__builtin_IB_vme_send_ime_new_uint4_uint4
__builtin_IB_vme_send_ime_new_uint8_uint4
__builtin_IB_set_message_phase_legacy_dw
__builtin_IB_set_message_phase_legacy_uw
__builtin_IB_set_message_phase_legacy_ub
__builtin_IB_set_message_phase_legacy
__builtin_IB_create_message_phases
__builtin_IB_create_message_phases_uint2
__builtin_IB_create_message_phases_uint4
__builtin_IB_create_message_phases_uint8
__builtin_IB_create_message_phases_no_init
__builtin_IB_create_message_phases_no_init_uint2
__builtin_IB_create_message_phases_no_init_uint4
__builtin_IB_create_message_phases_no_init_uint8
__builtin_IB_get_message_phase_dw
__builtin_IB_get_message_phase_dw_uint2
__builtin_IB_get_message_phase_dw_uint4
__builtin_IB_get_message_phase_dw_uint8
__builtin_IB_get_message_phase_uq
__builtin_IB_get_message_phase_uq_uint2
__builtin_IB_get_message_phase_uq_uint4
__builtin_IB_get_message_phase_uq_uint8
__builtin_IB_set_message_phase_dw
__builtin_IB_set_message_phase_dw_uint2
__builtin_IB_set_message_phase_dw_uint4
__builtin_IB_set_message_phase_dw_uint8
__builtin_IB_get_message_phase_uw
__builtin_IB_get_message_phase_uw_uint2
__builtin_IB_get_message_phase_uw_uint4
__builtin_IB_get_message_phase_uw_uint8
__builtin_IB_set_message_phase_uw
__builtin_IB_set_message_phase_uw_uint2
__builtin_IB_set_message_phase_uw_uint4
__builtin_IB_set_message_phase_uw_uint8
__builtin_IB_get_message_phase_ub
__builtin_IB_get_message_phase_ub_uint2
__builtin_IB_get_message_phase_ub_uint4
__builtin_IB_get_message_phase_ub_uint8
__builtin_IB_set_message_phase_ub
__builtin_IB_set_message_phase_ub_uint2
__builtin_IB_set_message_phase_ub_uint4
__builtin_IB_set_message_phase_ub_uint8
__builtin_IB_get_message_phase
__builtin_IB_get_message_phase_uint2
__builtin_IB_get_message_phase_uint4
__builtin_IB_get_message_phase_uint8
__builtin_IB_set_message_phase
__builtin_IB_set_message_phase_uint2
__builtin_IB_set_message_phase_uint4
__builtin_IB_set_message_phase_uint8
__builtin_IB_broadcast_message_phase_ub
__builtin_IB_broadcast_message_phase_ub_uint2
__builtin_IB_broadcast_message_phase_ub_uint4
__builtin_IB_broadcast_message_phase_ub_uint8
__builtin_IB_broadcast_message_phase_uw
__builtin_IB_broadcast_message_phase_uw_uint2
__builtin_IB_broadcast_message_phase_uw_uint4
__builtin_IB_broadcast_message_phase_uw_uint8
__builtin_IB_broadcast_message_phase_dw
__builtin_IB_broadcast_message_phase_dw_uint2
__builtin_IB_broadcast_message_phase_dw_uint4
__builtin_IB_broadcast_message_phase_dw_uint8
__builtin_IB_broadcast_message_phase_uq
__builtin_IB_broadcast_message_phase_uq_uint2
__builtin_IB_broadcast_message_phase_uq_uint4
__builtin_IB_broadcast_message_phase_uq_uint8
__builtin_IB_simd_set_message_phase_ub
__builtin_IB_simd_set_message_phase_ub_uint2
__builtin_IB_simd_set_message_phase_ub_uint4
__builtin_IB_simd_set_message_phase_ub_uint8
__builtin_IB_simd_set_message_phase_uw
__builtin_IB_simd_set_message_phase_uw_uint2
__builtin_IB_simd_set_message_phase_uw_uint4
__builtin_IB_simd_set_message_phase_uw_uint8
__builtin_IB_simd_set_message_phase_dw
__builtin_IB_simd_set_message_phase_dw_uint2
__builtin_IB_simd_set_message_phase_dw_uint4
__builtin_IB_simd_set_message_phase_dw_uint8
__builtin_IB_simd_set_message_phase_uq
__builtin_IB_simd_set_message_phase_uq_uint2
__builtin_IB_simd_set_message_phase_uq_uint4
__builtin_IB_simd_set_message_phase_uq_uint8
__builtin_IB_simd_get_message_phase_uw
__builtin_IB_simd_get_message_phase_uw_uint2
__builtin_IB_simd_get_message_phase_uw_uint4
__builtin_IB_simd_get_message_phase_uw_uint8
__builtin_IB_simd_get_message_phase_uq
__builtin_IB_simd_get_message_phase_uq_uint2
__builtin_IB_simd_get_message_phase_uq_uint4
__builtin_IB_simd_get_message_phase_uq_uint8
__builtin_IB_extract_mv_and_sad
__builtin_IB_cmp_sads
__builtin_IB_simdMediaRegionCopy
__builtin_IB_ieee_sqrt
__builtin_IB_ieee_divide
__builtin_IB_ieee_divide_f64
__builtin_IB_va_erode_64x4
__builtin_IB_va_dilate_64x4
__builtin_IB_va_minmaxfilter_16x4_SLM
__builtin_IB_va_convolve_16x4_SLM
__builtin_IB_va_convolve_16x1
__builtin_IB_va_convolve_16x4
__builtin_IB_va_minmax
__builtin_IB_va_centroid
__builtin_IB_va_boolcentroid
__builtin_IB_va_boolsum
__builtin_IB_WaveBallot
__builtin_IB_samplepos
__builtin_IB_dp4a_ss
__builtin_IB_dp4a_uu
__builtin_IB_dp4a_su
__builtin_IB_dp4a_us
mcsl
mcsh
imcsl
imcsh
gradXZ
gradYZ
gradXY
gradYY
gradXX
gradYX
__precompiled_udiv
__precompiled_udiv2
__precompiled_udiv3
__precompiled_udiv4
__precompiled_udiv8
__precompiled_udiv16
__precompiled_umod
__precompiled_umod2
__precompiled_umod3
__precompiled_umod4
__precompiled_umod8
__precompiled_umod16
__precompiled_sdiv
__precompiled_sdiv2
__precompiled_sdiv3
__precompiled_sdiv4
__precompiled_sdiv8
__precompiled_sdiv16
__precompiled_smod
__precompiled_smod2
__precompiled_smod3
__precompiled_smod4
__precompiled_smod8
__precompiled_smod16
precompiled_u32divrem
precompiled_s32divrem
precompiled_u32divrem_sp
precompiled_s32divrem_sp
__igcbuiltin_dp_add
__igcbuiltin_dp_sub
__igcbuiltin_dp_fma
__igcbuiltin_dp_mul
__igcbuiltin_dp_div
__igcbuiltin_dp_cmp
__igcbuiltin_dp_to_int32
__igcbuiltin_dp_to_uint32
__igcbuiltin_int32_to_dp
__igcbuiltin_uint32_to_dp
__igcbuiltin_dp_to_sp
__igcbuiltin_sp_to_dp
__igcbuiltin_dp_sqrt
__igcbuiltin_sp_div
Remainder
__precompiled_convert_f64_to_f16
DPEmuFlag
DPEmufp16tofp32
DPEmusext
DPEmuzext
DPEmuTrunc
DPEmuCmp
DPEmuFabs
PreCompiledFuncImport
igc-precompiled-import
ptrVec2ptrScl
GEP_lane
scalar
assembled.vect
Scalarize functions
igc-scalarize
ScalarizeFunction
Fix FMF for APIs that are using legacy IR
fix-fast-math-flags
Fix Fast Math Flags
_Z13get_global_idj
__builtin_spirv_BuiltInGlobalInvocationID
__builtin_spirv_BuiltInLocalInvocationId
__builtin_spirv_BuiltInWorkgroupId
sgid
assumeCond
Mark readonly load
mark-readonly-load
MarkReadOnlyLoadPass
RectListOptimization
callees
endIndirectCallBB
funcThen
funcElse
Changes indirect calls to direct calls if possible
indirect-call-optimization
IndirectCallOptimization
Simplify return types and bodies of dead visible functions
igc-fix-dead-visible-functions
FixDeadVisibleFunctions
read_write
image1d
image1d_buffer
image2d
image2d_depth
image2d_msaa
image2d_msaa_depth
image3d
image1d_array
image2d_array
image2d_array_depth
image2d_array_msaa
image2d_array_msaa_depth
sampler_t
Breakdown intrinsics into simpler operations to enable better optimization
breakdown-intrinsics
BreakdownIntrinsicPass
double type is not supported on this platform
Check for input errors
igc-error-check
Error Check
Address space alias analysis
igc-address-space-alias-analysis
_alloca
Analyze aggregate arguments
igc-agg-arg-analysis
Resolve aggregate arguments
igc-agg-arg
AggregateArgumentsAnalysis
ResolveAggregateArguments
Fix the alignment of loads and stores according to OpenCL rules
igc-fix-alignment
AlignmentAnalysisPass
__builtin_IB_get_local_lock
__builtin_IB_atomic_add_global_i32
__builtin_IB_atomic_add_local_i32
__builtin_IB_atomic_sub_global_i32
__builtin_IB_atomic_sub_local_i32
__builtin_IB_atomic_xchg_global_i32
__builtin_IB_atomic_xchg_local_i32
__builtin_IB_atomic_min_global_i32
__builtin_IB_atomic_min_global_u32
__builtin_IB_atomic_min_global_f32
__builtin_IB_atomic_min_local_i32
__builtin_IB_atomic_min_local_u32
__builtin_IB_atomic_min_local_f32
__builtin_IB_atomic_max_global_i32
__builtin_IB_atomic_max_global_u32
__builtin_IB_atomic_max_global_f32
__builtin_IB_atomic_max_local_i32
__builtin_IB_atomic_max_local_u32
__builtin_IB_atomic_max_local_f32
__builtin_IB_atomic_and_global_i32
__builtin_IB_atomic_and_local_i32
__builtin_IB_atomic_or_global_i32
__builtin_IB_atomic_or_local_i32
__builtin_IB_atomic_xor_global_i32
__builtin_IB_atomic_xor_local_i32
__builtin_IB_atomic_inc_global_i32
__builtin_IB_atomic_inc_local_i32
__builtin_IB_atomic_dec_global_i32
__builtin_IB_atomic_dec_local_i32
__builtin_IB_atomic_cmpxchg_global_i32
__builtin_IB_atomic_cmpxchg_global_f32
__builtin_IB_atomic_cmpxchg_local_i32
__builtin_IB_atomic_cmpxchg_local_f32
__builtin_IB_atomic_add_global_i64
__builtin_IB_atomic_sub_global_i64
__builtin_IB_atomic_xchg_global_i64
__builtin_IB_atomic_min_global_i64
__builtin_IB_atomic_min_global_u64
__builtin_IB_atomic_min_global_f64
__builtin_IB_atomic_max_global_i64
__builtin_IB_atomic_max_global_u64
__builtin_IB_atomic_max_global_f64
__builtin_IB_atomic_and_global_i64
__builtin_IB_atomic_or_global_i64
__builtin_IB_atomic_xor_global_i64
__builtin_IB_atomic_inc_global_i64
__builtin_IB_atomic_dec_global_i64
__builtin_IB_atomic_cmpxchg_global_i64
__builtin_IB_atomic_cmpxchg_global_f64
__builtin_IB_atomic_add_global_i16
__builtin_IB_atomic_add_local_i16
__builtin_IB_atomic_sub_global_i16
__builtin_IB_atomic_sub_local_i16
__builtin_IB_atomic_xchg_global_i16
__builtin_IB_atomic_xchg_local_i16
__builtin_IB_atomic_min_global_i16
__builtin_IB_atomic_min_global_u16
__builtin_IB_atomic_min_global_f16
__builtin_IB_atomic_min_local_i16
__builtin_IB_atomic_min_local_u16
__builtin_IB_atomic_min_local_f16
__builtin_IB_atomic_max_global_i16
__builtin_IB_atomic_max_global_u16
__builtin_IB_atomic_max_global_f16
__builtin_IB_atomic_max_local_i16
__builtin_IB_atomic_max_local_u16
__builtin_IB_atomic_max_local_f16
__builtin_IB_atomic_and_global_i16
__builtin_IB_atomic_and_local_i16
__builtin_IB_atomic_or_global_i16
__builtin_IB_atomic_or_local_i16
__builtin_IB_atomic_xor_global_i16
__builtin_IB_atomic_xor_local_i16
__builtin_IB_atomic_inc_global_i16
__builtin_IB_atomic_inc_local_i16
__builtin_IB_atomic_dec_global_i16
__builtin_IB_atomic_dec_local_i16
__builtin_IB_atomic_cmpxchg_global_i16
__builtin_IB_atomic_cmpxchg_global_f16
__builtin_IB_atomic_cmpxchg_local_i16
__builtin_IB_atomic_cmpxchg_local_f16
PtrDstToInt
spinlock
init_spinlock_var.end
init_spinlock_var.start
Resolve atomic built-ins
igc-resolve-atomics
ResolveOCLAtomics
Break constant expressions into instruction sequences
igc-break-const-expr
BreakConstantExprPass
Ensures single precision divide and sqrt are correctly rounded
igc-correctly-rounded-div-sqrt
grid
__ocl_dbg_gid
__ocl_dbg_lid
__ocl_dbg_grid
long long
__builtin_spirv_BuiltInGlobalInvocationId
Implicit Global Id Pass - Add parameters for debugging
igc-add-implicit-gid
ImplicitGlobalId
__builtin_IB_get_default_device_queue
__builtin_IB_get_event_pool
__builtin_IB_get_max_workgroup_size
__builtin_IB_get_parent_event
__builtin_IB_get_prefered_workgroup_multiple
__builtin_IB_get_object_id
__builtin_IB_get_block_simd_size
Analyzes device enqueue functions
igc-device-enqueue-func-analysis
Resolve device enqueue functions
igc-device-enqueue-func-resolution
DeviceEnqueueFuncsAnalysis
DeviceEnqueueFuncsResolution
TransformBlocksOutput
Output the .llvm generated from TransformBlocks pass
__get_kernel_work_group_size_impl
_Z45get_kernel_preferred_work_group_size_multiple
__get_kernel_preferred_work_group_multiple_impl
_Z41get_kernel_max_sub_group_size_for_ndrange
_Z38get_kernel_sub_group_count_for_ndrange
__builtin_spirv_OpEnqueueKernel
__builtin_spirv_OpGetKernelNDrangeSubGroupCount
__builtin_spirv_OpGetKernelNDrangeMaxSubGroupSize
__builtin_spirv_OpGetKernelPreferredWorkGroupSizeMultiple
__builtin_spirv_OpGetKernelLocalSizeForSubgroupCount
__builtin_spirv_OpGetKernelMaxNumSubgroups
igc-block-transform
TransformBlocks Pass
indirect calls are not supported
Enqueue param is not set
Enqueue param is not a struct
Device enqueue invoke param is not a function
block_simd_size
IGIL_calc_sub_group_count_for_ndrange
NDRange type mismatch
converted_ndrange
__builtin_IB_copyNDRangeTondrange
struct.ndrange_t
enqueue_kernel signature does not match
_local
captured value is null
scalar_buf
pointer_buf
pointer_arg_map_buf
object_map_buf
unknown argument number for an object
obj_id
local_size_buf
scalarParamBuf
globalArgBuf
globalPtrArgMappingBuf
getobjectidMappingBuf
casted_ptr
__intel_calc_kernel_local_size_for_sub_group_count
__intel_calc_kernel_max_num_subgroups
OpEnqueueKernel signature does not match
invoke function should not be null
Fail parent kernel lookup: possible closed self-enqueue
_dispatch_
capture
local_ptr
.block_struct
.block_descriptor
parent calls for invoke are not set
Fail parent call lookup: possible closed self-enqueue
unknown_type
llvm.loop.unroll.enable
llvm.loop.unroll.full
Disable loop unroll on retry
igc-disable-loop-unroll
DisableLoopUnrollOnRetry
block_motion_estimate_intel
block_advanced_motion_estimate_check_intel
block_advanced_motion_estimate_bidirectional_check_intel
erode_2d_intel
dilate_2d_intel
min_filter_2d_intel
max_filter_2d_intel
convolve_2d_intel
minmax_2d_intel
centroid_2d_intel
bool_centroid_2d_intel
bool_sum_2d_intel
convolve_1d_intel
convolve_pixel_intel
lbp_image_intel
lbp_correlation_intel
floodfill_intel
correlation_search_intel
__builtin_IB_media_block_rectangle_read
Analyzes extenstion functions arguments
igc-extension-arg-analysis
SIMD16 is expected
ExtensionArgAnalysis
Resolves extension function
igc-extension-funcs-resolution
ExtensionFuncsResolution
__builtin_IB_vme_mb_block_type
__builtin_IB_vme_subpixel_mode
__builtin_IB_vme_sad_adjust_mode
__builtin_IB_vme_search_path_type
__builtin_IB_vme_helper_get_handle
__builtin_IB_vme_helper_get_as
Analyzes extension functions
igc-extension-funcs-analysis
ExtensionFuncsAnalysis
GenericAddressAnalysis
GenericAddressDynamicResolution
LocalLoadBlock
GlobalPrivateLoadBlock
localLoad
globalOrPrivateLoad
CmpWindowLowerBound
CmpWindowUpperBound
isPtrInWindow
localWindowEnd
Resolves image height, width, depth functions
igc-image-func-resolution
ImageFuncResolution
__builtin_IB_get_image_height
__builtin_IB_get_image_width
__builtin_IB_get_image_depth
__builtin_IB_get_image_num_mip_levels
__builtin_IB_get_image_channel_data_type
__builtin_IB_get_image_channel_order
__builtin_IB_get_image_srgb_channel_order
__builtin_IB_get_image_array_size
__builtin_IB_get_image_num_samples
__builtin_IB_get_address_mode
Analyzes image height, width, depth functions
igc-image-func-analysis
ImageFuncsAnalysis
-ExtSLM
localToChar
movedLocal
charToLocal
GenSLM.LocalMemPoolOnGetMemPoolPtr
mempoolcast
localSLM
Resolve inline local variables/buffers
igc-resolve-inline-locals
InlineLocalsResolutionPass
Analyzes OpenCL printf calls
igc-opencl-printf-analysis
OpenCLPrintfAnalysis
write_offset
end_offset
buffer_ptr
bblockJoin
write_offset_true
write_offset_false
write_offset_ptr
write_error_string
bblockFalseJoin
printf_ret_val
to_float
ptrBC
Resolves OpenCL printf calls
igc-opencl-printf-resolution
OpenCLPrintfResolution
OCL IGC-Internal-ERRORERROR!!!: Non-OCL is not supposed to reach here!
Resolves private memory allocation
igc-private-mem-resolution
PrivateMemoryResolution
Analyzes the presence of private memory allocation
igc-private-mem-usage-analysis
PrivateMemoryUsageAnalysis
Creates annotations for OpenCL program-scope structures
igc-programscope-constant-analysis
ProgramScopeConstantAnalysisPass
cast
Resolves references to inline constants
igc-programscope-constant-resolve
ProgramScopeConstantResolutionPass
Replace calls to instrinsics which are not supported by the codegen
igc-replace-unsupported-intrinsics
memcpy_vsrc
memcpy_vdst
memcpy
memcpy_src
memcpy_dst
memcpy_rem
.post
.body
memset_vdst
memset
memset_dst
memset_rem
memmove.post
memmove.true
memmove.false
memmmove
memmove
ReplaceUnsupportedIntrinsics
Allocates UAV and SRV numbers to kernel arguments
igc-resource-allocator
ResourceAllocatorPass
Set llvm fast math flags according to compiler options
igc-set-fast-math-flags
SetFastMathFlags
__builtin_IB_sub_group_barrier
__builtin_IB_get_simd_size
__builtin_IB_get_simd_id
__builtin_IB_simd_shuffle
__builtin_IB_simd_shuffle_us
__builtin_IB_simd_shuffle_f
__builtin_IB_simd_shuffle_h
__builtin_IB_simd_shuffle_b
__builtin_IB_simd_shuffle_df
__builtin_IB_simd_shuffle_down
__builtin_IB_simd_shuffle_down_us
__builtin_IB_simd_shuffle_down_uc
__builtin_IB_simd_block_read_1_global
__builtin_IB_simd_block_read_2_global
__builtin_IB_simd_block_read_4_global
__builtin_IB_simd_block_read_8_global
__builtin_IB_simd_block_read_1_global_h
__builtin_IB_simd_block_read_2_global_h
__builtin_IB_simd_block_read_4_global_h
__builtin_IB_simd_block_read_8_global_h
__builtin_IB_simd_block_read_16_global_h
__builtin_IB_simd_block_read_1_global_b
__builtin_IB_simd_block_read_2_global_b
__builtin_IB_simd_block_read_4_global_b
__builtin_IB_simd_block_read_8_global_b
__builtin_IB_simd_block_read_16_global_b
__builtin_IB_simd_block_read_1_global_l
__builtin_IB_simd_block_read_2_global_l
__builtin_IB_simd_block_read_4_global_l
__builtin_IB_simd_block_read_8_global_l
__builtin_IB_simd_block_write_1_global
__builtin_IB_simd_block_write_2_global
__builtin_IB_simd_block_write_4_global
__builtin_IB_simd_block_write_8_global
__builtin_IB_simd_block_write_1_global_h
__builtin_IB_simd_block_write_2_global_h
__builtin_IB_simd_block_write_4_global_h
__builtin_IB_simd_block_write_8_global_h
__builtin_IB_simd_block_write_16_global_h
__builtin_IB_simd_block_write_1_global_b
__builtin_IB_simd_block_write_2_global_b
__builtin_IB_simd_block_write_4_global_b
__builtin_IB_simd_block_write_8_global_b
__builtin_IB_simd_block_write_16_global_b
__builtin_IB_simd_block_write_1_global_l
__builtin_IB_simd_block_write_2_global_l
__builtin_IB_simd_block_write_4_global_l
__builtin_IB_simd_block_write_8_global_l
__builtin_IB_simd_media_block_read_1
__builtin_IB_simd_media_block_read_2
__builtin_IB_simd_media_block_read_4
__builtin_IB_simd_media_block_read_8
__builtin_IB_simd_media_block_read_1_h
__builtin_IB_simd_media_block_read_2_h
__builtin_IB_simd_media_block_read_4_h
__builtin_IB_simd_media_block_read_8_h
__builtin_IB_simd_media_block_read_16_h
__builtin_IB_simd_media_block_read_1_b
__builtin_IB_simd_media_block_read_2_b
__builtin_IB_simd_media_block_read_4_b
__builtin_IB_simd_media_block_read_8_b
__builtin_IB_simd_media_block_read_16_b
__builtin_IB_simd_media_block_read_1_l
__builtin_IB_simd_media_block_read_2_l
__builtin_IB_simd_media_block_read_4_l
__builtin_IB_simd_media_block_read_8_l
__builtin_IB_simd_media_block_write_1
__builtin_IB_simd_media_block_write_2
__builtin_IB_simd_media_block_write_4
__builtin_IB_simd_media_block_write_8
__builtin_IB_simd_media_block_write_1_h
__builtin_IB_simd_media_block_write_2_h
__builtin_IB_simd_media_block_write_4_h
__builtin_IB_simd_media_block_write_8_h
__builtin_IB_simd_media_block_write_16_h
__builtin_IB_simd_media_block_write_1_l
__builtin_IB_simd_media_block_write_2_l
__builtin_IB_simd_media_block_write_4_l
__builtin_IB_simd_media_block_write_8_l
__builtin_IB_simd_media_block_write_1_b
__builtin_IB_simd_media_block_write_2_b
__builtin_IB_simd_media_block_write_4_b
__builtin_IB_simd_media_block_write_8_b
__builtin_IB_simd_media_block_write_16_b
__builtin_IB_media_block_read
__builtin_IB_media_block_write
__builtin_IB_get_image_bti
__builtin_IB_sub_group_reduce_OpGroupIAdd
__builtin_IB_sub_group_reduce_OpGroupSMax
__builtin_IB_sub_group_reduce_OpGroupUMax
__builtin_IB_sub_group_reduce_OpGroupSMin
__builtin_IB_sub_group_reduce_OpGroupUMin
__builtin_IB_sub_group_reduce_OpGroupFAdd
__builtin_IB_sub_group_reduce_OpGroupFMax
__builtin_IB_sub_group_reduce_OpGroupFMin
__builtin_IB_sub_group_scan_OpGroupIAdd
__builtin_IB_sub_group_scan_OpGroupSMax
__builtin_IB_sub_group_scan_OpGroupUMax
__builtin_IB_sub_group_scan_OpGroupSMin
__builtin_IB_sub_group_scan_OpGroupUMin
__builtin_IB_sub_group_scan_OpGroupFAdd
__builtin_IB_sub_group_scan_OpGroupFMax
__builtin_IB_sub_group_scan_OpGroupFMin
BlockReadLocal not supported!
BlockWriteLocal not supported!
xOffset
yOffset
simdSize
simdLaneId16
simdLaneId
Shuffle not supported in SIMD32
simdShuffle
Shuffle Down not supported in SIMD32
simdShuffleDown
Block reads not supported in SIMD32
Block writes not supported in SIMD32
SIMD Media Block Read not supported in SIMD32
SIMD Media Block Write not supported in SIMD32
width argument supplied to intel_media_block_read*() must be constant.
height argument supplied to intel_media_block_read*() must be constant.
width argument supplied to intel_media_block_write*() must be constant.
height argument supplied to intel_media_block_write*() must be constant.
intel_media_block_read
intel_media_block_write
width for 
*() must be <= 
height for 
 bytes wide 
*() attempt of 
 bytes.  Must be <= 
 bytes.
_uc*() widths must be quad pixel aligned.
_us*() widths must be dual pixel aligned.
Resolves sub group functions
igc-sub-group-func-resolution
SubGroupFuncsResolution
invariant.load
p%d:32:32:32
p%d:
-p%d:32:32:32
Tries to convert stateless to statefull accesses
igc-stateless-to-statefull-resolution
StatelessToStatefull
Emit linker warnings to user
undefined-references
undefined reference to `
UndefinedReferencesPass
Resolve WG built-in
igc-wg-resolution
WGFuncResolution
cmpDim
tmpOffsetR0
offsetR0
groupId
globalOffset
numGroups
grid_origin
grid_size
Resolves work item functions
igc-wi-func-resolution
WIFuncResolution
__builtin_IB_get_global_offset
__builtin_IB_get_work_dim
__builtin_IB_get_sync_buffer
Analyzes work item functions
igc-wi-func-analysis
WIFuncsAnalysis
Sets a limit on unrolling metadata to control compile time
igc-clamp-loop-unroll
ClampLoopUnroll
Converts 3d images access to 2d array image accesses where possible
igc-3d-to-2darray
Image3dToImage2darray
converts get_local_size() to get_enqueued_local_size()
igc-rewrite-local-size
RewriteLocalSize
srem
urem
sext
addconv
diff.neg
.not
notmask
.masked
and.shrunk
bitfield
notlhs
notrhs
.demorgan
igc-instcombine-guard-widening-window
How wide an instruction window to bypass looking for another guard
blendv
exec
thunk
nest
nvptx-f32ftz
unmaskedload
.splatinsert
.splat
castvec
tmpcast
.lobit
.mask
.unshifted
.idx
.sext
.add
to.ptr
.ptr
.conv
sadd
sadd.result
sadd.overflow
umul
umul.value
.cast
.val
storemerge
.sub
.unpack
.repack
suba
subc
mulconv
igc-instcombine-max-num-phis
Maximum number phis to handle in intptr/ptrint folding
.shrunk
extract
extract.t
narrow
not.
.inv
.Elt
.lhs
.rhs
.extract
instcombine-visit
Controls which instructions are visited
igc-expensive-combines
Enable expensive instruction combines
igc-instcombine-maxarray-size
Maximum array size considered when doing a combine
igc-instcombine-lower-dbg-declare
phitmp
trunc
SmallVector capacity overflow during allocation
Allocation failed
igcinstcombine
.offs
not_intrinsic
llvm.genx.GenISA.CatchAllDebugLine
llvm.genx.GenISA.DCL.DSCntrlPtInputVec
llvm.genx.GenISA.DCL.DSInputTessFactor
llvm.genx.GenISA.DCL.DSPatchConstInputVec
llvm.genx.GenISA.DCL.GSinputVec
llvm.genx.GenISA.DCL.GSsystemValue
llvm.genx.GenISA.DCL.HSControlPointID
llvm.genx.GenISA.DCL.HSOutputCntrlPtInputVec
llvm.genx.GenISA.DCL.HSPatchConstInputVec
llvm.genx.GenISA.DCL.HSinputVec
llvm.genx.GenISA.DCL.ShaderInputVec
llvm.genx.GenISA.DCL.SystemValue
llvm.genx.GenISA.DCL.input
llvm.genx.GenISA.DCL.inputVec
llvm.genx.GenISA.EndPrimitive
llvm.genx.GenISA.EnqueuedLocalSizeLocation
llvm.genx.GenISA.GetBufferPtr
llvm.genx.GenISA.GetPixelMask
llvm.genx.GenISA.GlobalDataAccess
llvm.genx.GenISA.GlobalSizeLocation
llvm.genx.GenISA.GradientX
llvm.genx.GenISA.GradientXfine
llvm.genx.GenISA.GradientY
llvm.genx.GenISA.GradientYfine
llvm.genx.GenISA.GridOriginLocation
llvm.genx.GenISA.GridSizeLocation
llvm.genx.GenISA.GroupIdLocation
llvm.genx.GenISA.GsCutControlHeader
llvm.genx.GenISA.GsStreamHeader
llvm.genx.GenISA.HSURBPatchHeaderRead
llvm.genx.GenISA.IEEE.Divide
llvm.genx.GenISA.IEEE.Sqrt
llvm.genx.GenISA.InitDiscardMask
llvm.genx.GenISA.InnerScalarTessFactors
llvm.genx.GenISA.Interpolant
llvm.genx.GenISA.Interpolate
llvm.genx.GenISA.Interpolate2
llvm.genx.GenISA.IsHelperInvocation
llvm.genx.GenISA.LocalIdLocation
llvm.genx.GenISA.LocalSizeLocation
llvm.genx.GenISA.MediaBlockRead
llvm.genx.GenISA.MediaBlockRectangleRead
llvm.genx.GenISA.MediaBlockWrite
llvm.genx.GenISA.OUTPUT
llvm.genx.GenISA.OUTPUTGS
llvm.genx.GenISA.OUTPUTGS2
llvm.genx.GenISA.OWordPtr
llvm.genx.GenISA.OuterScalarTessFactors
llvm.genx.GenISA.OutputTessControlPoint
llvm.genx.GenISA.OutputTessFactors
llvm.genx.GenISA.PHASE.INPUT
llvm.genx.GenISA.PHASE.OUTPUT
llvm.genx.GenISA.PatchConstantOutput
llvm.genx.GenISA.PixelPositionX
llvm.genx.GenISA.PixelPositionY
llvm.genx.GenISA.PullCentroidBarys
llvm.genx.GenISA.PullSampleIndexBarys
llvm.genx.GenISA.PullSnappedBarys
llvm.genx.GenISA.QuadPrefix
llvm.genx.GenISA.ROUNDNE
llvm.genx.GenISA.RTDualBlendSource
llvm.genx.GenISA.RTWrite
llvm.genx.GenISA.RenderTargetRead
llvm.genx.GenISA.RenderTargetReadSampleFreq
llvm.genx.GenISA.RuntimeValue
llvm.genx.GenISA.SampleOffsetX
llvm.genx.GenISA.SampleOffsetY
llvm.genx.GenISA.SetDebugReg
llvm.genx.GenISA.SetStream
llvm.genx.GenISA.StackAlloca
llvm.genx.GenISA.URBRead
llvm.genx.GenISA.URBReadOutput
llvm.genx.GenISA.URBWrite
llvm.genx.GenISA.UpdateDiscardMask
llvm.genx.GenISA.VirtualBindingTableBaseLocation
llvm.genx.GenISA.WaveAll
llvm.genx.GenISA.WaveBallot
llvm.genx.GenISA.WaveClustered
llvm.genx.GenISA.WaveInverseBallot
llvm.genx.GenISA.WavePrefix
llvm.genx.GenISA.WaveShuffleIndex
llvm.genx.GenISA.WorkGroupAny
llvm.genx.GenISA.add.pair
llvm.genx.GenISA.add.rtz
llvm.genx.GenISA.atomiccounterinc
llvm.genx.GenISA.atomiccounterpredec
llvm.genx.GenISA.bfi
llvm.genx.GenISA.bfrev
llvm.genx.GenISA.broadcastMessagePhase
llvm.genx.GenISA.broadcastMessagePhaseV
llvm.genx.GenISA.cmpSADs
llvm.genx.GenISA.cmpxchgatomicstructured
llvm.genx.GenISA.createMessagePhases
llvm.genx.GenISA.createMessagePhasesNoInit
llvm.genx.GenISA.createMessagePhasesNoInitV
llvm.genx.GenISA.createMessagePhasesV
llvm.genx.GenISA.cycleCounter
llvm.genx.GenISA.discard
llvm.genx.GenISA.dp4a.ss
llvm.genx.GenISA.dp4a.su
llvm.genx.GenISA.dp4a.us
llvm.genx.GenISA.dp4a.uu
llvm.genx.GenISA.dwordatomicstructured
llvm.genx.GenISA.eu.id
llvm.genx.GenISA.eu.thread.id
llvm.genx.GenISA.eu.thread.pause
llvm.genx.GenISA.evaluateSampler
llvm.genx.GenISA.extractMVAndSAD
llvm.genx.GenISA.f32tof16.rtz
llvm.genx.GenISA.fcmpxchgatomicraw
llvm.genx.GenISA.fcmpxchgatomicrawA64
llvm.genx.GenISA.fcmpxchgatomicstructured
llvm.genx.GenISA.firstbitHi
llvm.genx.GenISA.firstbitLo
llvm.genx.GenISA.firstbitShi
llvm.genx.GenISA.floatatomicraw
llvm.genx.GenISA.floatatomicrawA64
llvm.genx.GenISA.floatatomicstructured
llvm.genx.GenISA.flushsampler
llvm.genx.GenISA.fma.rtz
llvm.genx.GenISA.fsat
llvm.genx.GenISA.ftof.rtn
llvm.genx.GenISA.ftof.rtp
llvm.genx.GenISA.ftof.rtz
llvm.genx.GenISA.ftoi.rte
llvm.genx.GenISA.ftoi.rtn
llvm.genx.GenISA.ftoi.rtp
llvm.genx.GenISA.ftoui.rte
llvm.genx.GenISA.ftoui.rtn
llvm.genx.GenISA.ftoui.rtp
llvm.genx.GenISA.gather4Cptr
llvm.genx.GenISA.gather4POCptr
llvm.genx.GenISA.gather4POptr
llvm.genx.GenISA.gather4ptr
llvm.genx.GenISA.getEnqueuedLocalSize
llvm.genx.GenISA.getGlobalSize
llvm.genx.GenISA.getGridOrigin
llvm.genx.GenISA.getGridSize
llvm.genx.GenISA.getGroupId
llvm.genx.GenISA.getLocalId
llvm.genx.GenISA.getLocalSize
llvm.genx.GenISA.getMessagePhase
llvm.genx.GenISA.getMessagePhaseV
llvm.genx.GenISA.getMessagePhaseX
llvm.genx.GenISA.getMessagePhaseXV
llvm.genx.GenISA.getSR0
llvm.genx.GenISA.getSimdGroupSize
llvm.genx.GenISA.globalSync
llvm.genx.GenISA.hw.thread.id
llvm.genx.GenISA.ibfe
llvm.genx.GenISA.icmpxchgatomicraw
llvm.genx.GenISA.icmpxchgatomicrawA64
llvm.genx.GenISA.icmpxchgatomictyped
llvm.genx.GenISA.imulH
llvm.genx.GenISA.intatomicraw
llvm.genx.GenISA.intatomicrawA64
llvm.genx.GenISA.intatomictyped
llvm.genx.GenISA.is.uniform
llvm.genx.GenISA.itof.rtn
llvm.genx.GenISA.itof.rtp
llvm.genx.GenISA.itof.rtz
llvm.genx.GenISA.ldmcsptr
llvm.genx.GenISA.ldmsptr
llvm.genx.GenISA.ldmsptr16bit
llvm.genx.GenISA.ldptr
llvm.genx.GenISA.ldraw.indexed
llvm.genx.GenISA.ldrawvector.indexed
llvm.genx.GenISA.ldstructured
llvm.genx.GenISA.lodptr
llvm.genx.GenISA.memoryfence
llvm.genx.GenISA.mov.identity
llvm.genx.GenISA.movcr
llvm.genx.GenISA.movflag
llvm.genx.GenISA.mul.pair
llvm.genx.GenISA.mul.rtz
llvm.genx.GenISA.pair.to.ptr
llvm.genx.GenISA.patchInstanceId
llvm.genx.GenISA.ptr.to.pair
llvm.genx.GenISA.readsurfaceinfoptr
llvm.genx.GenISA.resinfoptr
llvm.genx.GenISA.rsq
llvm.genx.GenISA.sampleBCptr
llvm.genx.GenISA.sampleBptr
llvm.genx.GenISA.sampleCptr
llvm.genx.GenISA.sampleDCptr
llvm.genx.GenISA.sampleDptr
llvm.genx.GenISA.sampleKillPix
llvm.genx.GenISA.sampleLCptr
llvm.genx.GenISA.sampleLptr
llvm.genx.GenISA.sampleinfoptr
llvm.genx.GenISA.sampleptr
llvm.genx.GenISA.setMessagePhase
llvm.genx.GenISA.setMessagePhaseV
llvm.genx.GenISA.setMessagePhaseX
llvm.genx.GenISA.setMessagePhaseXV
llvm.genx.GenISA.setMessagePhaseX.legacy
llvm.genx.GenISA.setMessagePhase.legacy
llvm.genx.GenISA.simdBlockRead
llvm.genx.GenISA.simdBlockReadBindless
llvm.genx.GenISA.simdBlockWrite
llvm.genx.GenISA.simdBlockWriteBindless
llvm.genx.GenISA.simdGetMessagePhase
llvm.genx.GenISA.simdGetMessagePhaseV
llvm.genx.GenISA.simdLaneId
llvm.genx.GenISA.simdMediaBlockRead
llvm.genx.GenISA.simdMediaBlockWrite
llvm.genx.GenISA.simdMediaRegionCopy
llvm.genx.GenISA.simdSetMessagePhase
llvm.genx.GenISA.simdSetMessagePhaseV
llvm.genx.GenISA.simdShuffleDown
llvm.genx.GenISA.simdSize
llvm.genx.GenISA.slice.id
llvm.genx.GenISA.source.value
llvm.genx.GenISA.storeraw.indexed
llvm.genx.GenISA.storerawvector.indexed
llvm.genx.GenISA.storestructured1
llvm.genx.GenISA.storestructured2
llvm.genx.GenISA.storestructured3
llvm.genx.GenISA.storestructured4
llvm.genx.GenISA.sub.pair
llvm.genx.GenISA.subslice.id
llvm.genx.GenISA.threadgroupbarrier
llvm.genx.GenISA.threadgroupbarrier.signal
llvm.genx.GenISA.threadgroupbarrier.wait
llvm.genx.GenISA.typedmemoryfence
llvm.genx.GenISA.typedread
llvm.genx.GenISA.typedwrite
llvm.genx.GenISA.uaddc
llvm.genx.GenISA.uavSerializeAll
llvm.genx.GenISA.uavSerializeOnResID
llvm.genx.GenISA.ubfe
llvm.genx.GenISA.uitof.rtn
llvm.genx.GenISA.uitof.rtp
llvm.genx.GenISA.uitof.rtz
llvm.genx.GenISA.umulH
llvm.genx.GenISA.usubb
llvm.genx.GenISA.vaBoolCentroid
llvm.genx.GenISA.vaBoolSum
llvm.genx.GenISA.vaCentroid
llvm.genx.GenISA.vaConvolve
llvm.genx.GenISA.vaConvolveGRF.16x1
llvm.genx.GenISA.vaConvolveGRF.16x4
llvm.genx.GenISA.vaDilate
llvm.genx.GenISA.vaErode
llvm.genx.GenISA.vaMinMax
llvm.genx.GenISA.vaMinMaxFilter
llvm.genx.GenISA.vmeSendFBR
llvm.genx.GenISA.vmeSendFBR2
llvm.genx.GenISA.vmeSendIME
llvm.genx.GenISA.vmeSendIME2
llvm.genx.GenISA.vmeSendSIC
llvm.genx.GenISA.vmeSendSIC2
llvm.genx.GenISA.wavebarrier
CatchAllDebugLine@
DCL_DSCntrlPtInputVec@
DCL_DSInputTessFactor@
DCL_DSPatchConstInputVec@
DCL_GSinputVec@
DCL_GSsystemValue@
DCL_HSControlPointID@
DCL_HSOutputCntrlPtInputVec@
DCL_HSPatchConstInputVec@
DCL_HSinputVec@
DCL_ShaderInputVec@
DCL_SystemValue@
DCL_input@
DCL_inputVec@
EndPrimitive@
EnqueuedLocalSizeLocation@
GetBufferPtr@
GetPixelMask@
GlobalDataAccess@
GlobalSizeLocation@
GradientX@
GradientXfine@
GradientY@
GradientYfine@
GridOriginLocation@
GridSizeLocation@
GroupIdLocation@
GsCutControlHeader@
GsStreamHeader@
HSURBPatchHeaderRead@
IEEE_Divide@
IEEE_Sqrt@
InitDiscardMask@
InnerScalarTessFactors@
Interpolant@
Interpolate@
Interpolate2@
IsHelperInvocation@
LocalIdLocation@
LocalSizeLocation@
MediaBlockRead@
MediaBlockRectangleRead@
MediaBlockWrite@
OUTPUT@
OUTPUTGS@
OUTPUTGS2@
OWordPtr@
OuterScalarTessFactors@
OutputTessControlPoint@
OutputTessFactors@
PHASE_INPUT@
PHASE_OUTPUT@
PatchConstantOutput@
PixelPositionX@
PixelPositionY@
PullCentroidBarys@
PullSampleIndexBarys@
PullSnappedBarys@
QuadPrefix@
ROUNDNE@
RTDualBlendSource@
RTWrite@
RenderTargetRead@
RenderTargetReadSampleFreq@
RuntimeValue@
SampleOffsetX@
SampleOffsetY@
SetDebugReg@
SetStream@
StackAlloca@
URBRead@
URBReadOutput@
URBWrite@
UpdateDiscardMask@
VirtualBindingTableBaseLocation@
WaveAll@
WaveBallot@
WaveClustered@
WaveInverseBallot@
WavePrefix@
WaveShuffleIndex@
WorkGroupAny@
add_pair@
add_rtz@
atomiccounterinc@
atomiccounterpredec@
bfi@
bfrev@
broadcastMessagePhase@
broadcastMessagePhaseV@
cmpSADs@
cmpxchgatomicstructured@
createMessagePhases@
createMessagePhasesNoInit@
createMessagePhasesNoInitV@
createMessagePhasesV@
cycleCounter@
discard@
dp4a_ss@
dp4a_su@
dp4a_us@
dp4a_uu@
dwordatomicstructured@
eu_id@
eu_thread_id@
eu_thread_pause@
evaluateSampler@
extractMVAndSAD@
f32tof16_rtz@
fcmpxchgatomicraw@
fcmpxchgatomicrawA64@
fcmpxchgatomicstructured@
firstbitHi@
firstbitLo@
firstbitShi@
floatatomicraw@
floatatomicrawA64@
floatatomicstructured@
flushsampler@
fma_rtz@
fsat@
ftof_rtn@
ftof_rtp@
ftof_rtz@
ftoi_rte@
ftoi_rtn@
ftoi_rtp@
ftoui_rte@
ftoui_rtn@
ftoui_rtp@
gather4Cptr@
gather4POCptr@
gather4POptr@
gather4ptr@
getEnqueuedLocalSize@
getGlobalSize@
getGridOrigin@
getGridSize@
getGroupId@
getLocalId@
getLocalSize@
getMessagePhase@
getMessagePhaseV@
getMessagePhaseX@
getMessagePhaseXV@
getSR0@
getSimdGroupSize@
globalSync@
hw_thread_id@
ibfe@
icmpxchgatomicraw@
icmpxchgatomicrawA64@
icmpxchgatomictyped@
imulH@
intatomicraw@
intatomicrawA64@
intatomictyped@
is_uniform@
itof_rtn@
itof_rtp@
itof_rtz@
ldmcsptr@
ldmsptr@
ldmsptr16bit@
ldptr@
ldraw_indexed@
ldrawvector_indexed@
ldstructured@
lodptr@
memoryfence@
mov_identity@
movcr@
movflag@
mul_pair@
mul_rtz@
pair_to_ptr@
patchInstanceId@
ptr_to_pair@
readsurfaceinfoptr@
resinfoptr@
rsq@
sampleBCptr@
sampleBptr@
sampleCptr@
sampleDCptr@
sampleDptr@
sampleKillPix@
sampleLCptr@
sampleLptr@
sampleinfoptr@
sampleptr@
setMessagePhase@
setMessagePhaseV@
setMessagePhaseX@
setMessagePhaseXV@
setMessagePhaseX_legacy@
setMessagePhase_legacy@
simdBlockRead@
simdBlockReadBindless@
simdBlockWrite@
simdBlockWriteBindless@
simdGetMessagePhase@
simdGetMessagePhaseV@
simdLaneId@
simdMediaBlockRead@
simdMediaBlockWrite@
simdMediaRegionCopy@
simdSetMessagePhase@
simdSetMessagePhaseV@
simdShuffleDown@
simdSize@
slice_id@
source_value@
storeraw_indexed@
storerawvector_indexed@
storestructured1@
storestructured2@
storestructured3@
storestructured4@
sub_pair@
subslice_id@
threadgroupbarrier@
threadgroupbarrier_signal@
threadgroupbarrier_wait@
typedmemoryfence@
typedread@
typedwrite@
uaddc@
uavSerializeAll@
uavSerializeOnResID@
ubfe@
uitof_rtn@
uitof_rtp@
uitof_rtz@
umulH@
usubb@
vaBoolCentroid@
vaBoolSum@
vaCentroid@
vaConvolve@
vaConvolveGRF_16x1@
vaConvolveGRF_16x4@
vaDilate@
vaErode@
vaMinMax@
vaMinMaxFilter@
vmeSendFBR@
vmeSendFBR2@
vmeSendIME@
vmeSendIME2@
vmeSendSIC@
vmeSendSIC2@
wavebarrier@
wait
mem_fence
pseudo_kill
spill
fill
Can't open 
             === Binary Compaction ===
 out of 
 instructions are compacted.
 instructions of 3 src (mad/pln) are compacted.
% instructions of this kernel are compacted.
xyzw
wait
mem_fence
pseudo_kill
spill
fill
INVALID opcode 
UNDEFINED_
test
.implicit_
bool
none
Illegal or unimplemented ISA opcode 
 at byte position 
SurfaceUsage
Target
SLMSize
Scope
FESPSize
be_fp
_AUTO_LABEL_
_AUTO_GENERATED_IF_LABEL_
__AUTO_GENERATED_ELSE_LABEL__
L_AUTO_k
L_AUTO_f
beforeRemoveRedundantLabels
afterRemoveRedundantLabels
beforeRemoveUnreachableBlocks
afterRemoveUnreachableBlocks
before_doCFGStructurizer
after_doCFGStructurizer
beforeProcessGoto
afterProcessGoto
__EXIT_BB
LABEL__
LABEL__EMPTYBB__
LABEL__EMPTYBB
__AUTO_GENERATED_DUMMY_LAST_BB
__MERGED_FRET_EXIT_BLOCK_f
VCE_SAVE
%s.%03d.%s.dump
UnknownKernel
Preds: 
Succs: 
%s.%03d.%s.dot
digraph UnknownKernel
digraph 
// Setup
size = "80.0, 
page= "80.5, 110";
pagedir="TL";
 [shape=plaintext, label=<
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
<TR><TD ALIGN="CENTER">
</TD></TR>
<TR><TD>
    <TABLE BORDER="0" CELLBORDER="0" CELLSPACING="0">
black
<TR><TD ALIGN="LEFT"><FONT color="
</FONT></TD></TR>
    </TABLE>
</TD></TR>
    </TABLE>>];
 -> 
//.kernel 
//.platform 
//.stepping 
//.CISA version 
//.options 
//.instCount 
//.RA type
//.GRF count 
//.spill size 
//.spill GRF ref count 
//.spill flag store 
//.spill flag load 
//.kernel_reordering_info_start
//id
byte_offset
byte_size
kind
implicit_kind
//.arg_
//.kernel_reordering_info_end
.code
Failed to decode binary for asm output. Please report the issue and try disabling IGA disassembler for now.
// Text representation might not be correct
.end_code
.end_kernel
// Bank Conflict Statistics: 
// -- GOOD: 
// --  BAD: 
// --   OK: 
// File: 
// Line 
EL, 
OL, 
EH, 
OH, 
BAD,
GOOD,
GOOD
be_sp
vector
TRIVIAL_BC_RA
TRIVIAL_RA
LOCAL_ROUND_ROBIN_BC_RA
LOCAL_ROUND_ROBIN_RA
LOCAL_FIRST_FIT_BC_RA
LOCAL_FIRST_FIT_RA
HYBRID_BC_RA
HYBRID_RA
GRAPH_COLORING_RR_BC_RA
GRAPH_COLORING_FF_BC_RA
GRAPH_COLORING_RR_RA
GRAPH_COLORING_FF_RA
GRAPH_COLORING_SPILL_RR_BC_RA
GRAPH_COLORING_SPILL_FF_BC_RA
GRAPH_COLORING_SPILL_RR_RA
GRAPH_COLORING_SPILL_FF_RA
UNKNOWN_RA
%s_%s
Can't find src file
Invalid line no
label_cf_
Align16
Switch
Atomic
NoDDChk
NoDDClr
NoMask
BreakPoint
AccWrEn
Compacted
NoCompact
NoSrcDepSet
NoPreempt
Serialize
illegal
movi
smov
csel
bfrev
bfi1
bfi2
cbit
math
rndu
rndd
rnde
rndz
mach
addc
subb
dp4a
madm
mulh
cmpn
jmpi
else
endif
while
break
cont
halt
call
return
goto
join
pseudo_fcall
pseudo_fret
pseudo_exit
pseudo_fc_call
pseudo_fc_ret
sad2
sada2
line
pseudo_mad
pseudo_sada2
wait
send
sendc
sends
sendsc
pseudo_store_be_fp
pseudo_restore_be_fp
pseudo_caller_save
pseudo_caller_restore
pseudo_callee_save
pseudo_callee_restore
lifetime
intrinsic
DebugInfoPlaceholder
pseudo_and
pseudo_or
pseudo_xor
pseudo_not
gateway
scaled untyped surface read
scaled A64 scatter read
scaled A64 untyped surface read
scaled byte scattered read
scaled untyped surface write
scaled A64 untyped surface write
scaled A64 scattered write
scaled byte scattede write
unrecognized DC2 message
render target write
render target read
unrecognized RT message
thread spawner
oword block read
unaligned oword block read
oword dual block read
dword scattered read
unrecognized DCC message
hword block read
hword aligned block read
byte scattered read
memory fence
hword block write
oword block write
hword aligned block write
oword dual block write
dword scattered write
byte scattered write
unrecognized DC0 message
scratch read
scratch write
dp_pi
transpose read
untyped surface read
untyped atomic operation
untyped atomic operation simd4x2
media block read
typed surface read
typed atomic operation
typed atomic operation simd4x2
untyped atomic float add
untyped surface write
media block write (non-iecp)
atomic counter operation
atomic counter operation simd4x2
typed surface write
a64 gathering read
a64 untyped surface read
a64 untyped atomic operation
a64 untyped atomic operation simd4x2
a64 block read
a64 block write
a64 untyped atomic float add
a64 untyped surface write
a64 scattered write
unrecognized DC1 message
.sat
 // 
, resLen=
, msgLen=
, extMsgLen=
, barrier
Align1, 
Align1}
null
acc0
acc1
dbg0
tdr0
unknown architecture reg
.noacc
.acc
//.declare 
Base=
r (spilled)
a (spilled)
f (spilled)
.declare 
Base=r
Base=a
 ElementSize=
 rf=
 size=
 type=
 alias=
 align=
 words
 (a0.
 (spilled -> 
 (spilled)
 Type=
 Input_Output
 Input
 Output
wany4h
all4h
any2h
any4h
any8h
any16h
any32h
all2h
all8h
all16h
all32h
anyv
allv
f0.0
bool
none
mem_fence
pseudo_kill
spill
fill
(abs)
-(abs)
be_fp
be_sp
StackCall
Spill candidate 
 intf:
(Liverange is local starting at line #
 and ending at line #
 --- spilled
--max RP: 
--avg # neighbors: 
--max # neighbors: 
round-robin
first-fit
 BCR
 graph coloring
--# variables: 
Caller save size: 
 bytes for fcall at cisa id 
Callee save size: 
 bytes
Total frame size: 
predicate
src0
src1
src2
Def not found for use 
) at CISA offset 
, src line 
=== Uses with reaching def - Flags ===
=== Uses with reaching def - Address ===
=== Uses with reaching def - GRF ===
(Use -nolocalra switch for accurate results of uses without reaching defs)
=== Variables used but never defined ===
 (General)
 (Address)
 (Flag)
--address RA iteration 
Address_RA
--flag RA iteration 
Flag_RA
--hybrid RA--
--skip hybrid RA due to high pressure: 
=== Register Allocation ===
Function: 
Kernel: 
--GRF RA iteration 
--split local send--
--enable failSafe RA
--rematerialize
--global send split
--# variables spilled: 
--current spill size: 
Spill_GRF
Local RA used 
 GRFs
: (Pred: 
 Succ: 
max pressure: 
 inst(s)
Dcl %s is Default32Bit but assignment is not Even aligned
's LRA assignment 
 doesnt interfere with 
Start verification for kernel: 
) is split
) and 
) are overlapping with incompatible emask but not masked as interfering
) use overlapping physical assignments but not marked as interfering
End verification for kenel: 
Default16Bit
Default32Bit
Default64Bit
NonDefault
Undetermined
-----
DefaultPredicateMask
(size = 
, spill cost = 
, degree = 
wait
mem_fence
pseudo_kill
spill
fill
--trivial RA
Allocated 100% GRF ranges without graph coloring.
--local RA--
--round-robin 
BCR 
--first-fit 
Total GRF ranges: 
GRF ranges allocated by local RA: 
% allocated by local RA
Undoing local RA assignments
bool
none
bool
none
===== LVN =====
Number of instructions removed: 
insertCallReturnVar
callReturn
===== Bank conflicts =====
Found 
 conflicts (
 locals, 
 globals) in kernel: 
 // $
before.
after.
cleanMessageHeader
renameRegister
newLocalDefHoisting
newLocalCopyPropagation
sendFusion
cselPeepHoleOpt
optimizeLogicOperation
HWConformityChk
preRA_Schedule
regAlloc
removeLifetimeOps
countBankConflicts
removeRedundMov
removeEmptyBlocks
insertFallThroughJump
reassignBlockIDs
evalAddrExp
FoldAddrImmediate
chkRegBoundary
localSchedule
NoDD
HWWorkaround
insertInstLabels
insertHashMovs
insertDummyCompactInst
mergeScalarInst
lowerMadSequence
ifCvt
dumpPayload
normalizeRegion
checkBarrierUsage
createR0Copy
initializePayload
cleanupBindless
countGRFUsage
splitVariables
changeMoveType
reRAPostSchedule
accSubPostSchedule
reassociateConst
split4GRFVars
addFFIDProlog
loadThreadPayload
insertFenceBeforeEOT
insertScratchReadBeforeEOT
mapOrphans
_UIP
             === Local Definition Hoisting Optimization ===
Number of defs hoisted: 
             === Message Header Optimization ===
 is reduced from 
 to 
 instructions. 
% instructions of this kernel are removed.
%s_optreport.txt
ffid_prolog_end
             === Merge Scalar Optimization ===
Number of optimized bundles:
Number of instructions saved:
wait
mem_fence
pseudo_kill
spill
fill
C:\Intel\nodd.txt
bool
none
bool
none
Fix Inst Size for:
split into: 
's live in: 
's live in size: 
's live out: 
's live out size: 
PreRegAlloc
SP_GRF
TM_GRF
SP_MSG
FL_MSG
FL_GRF
FL_Send
tmp_shl_dst_bti
tmp_shl_y_offset
tmp_shl
bool
none
%s.asm
Fail to open 
SpillMemOffset
AsmName
ArgSize
RetValSize
perThreadInputSize
Extern
Callable
Caller
Composable
Entry
Input
Input_Output
NoWidening
Wrong input variable is used
ONLY ADDC AND SUBB are supported by this API
Destination for Arithmetic Instruction is NULL
BuiltinR0
BuiltinA0
BuiltinA0Dot2
hw_tid
samplerHeader
Number of parameters does not match
LINE: 
FUNCTION: 
CHECK_NUM_OPNDS
NEGABS
thread_x
thread_y
local_id_x
local_id_y
group_id_x
group_id_y
group_id_z
group_count_x
group_count_y
retval
hw_id
color
global_data_base
bitset test argument out of range
before.remat
after.remat
Skip block with instructions 
Skip block with rp 
Before scheduling, 
After scheduling for presssure, 
After scheduling for latency, 
[---] 
the max pressure is 
Max pressure instructions are: 
schedule reverted due to mischeduling.
schedule not committed due to no change.
schedule committed for latency.
the pressure is increased to 
schedule committed with reduced pressure.
the reduced pressure is 
schedule reverted, 
%s.bb%d.schedule
 ... 
+++++++++++ 
 empty cycles 
 +++++++++++
nodes
 Prio:
 Earl:
 Occu:
%s.bb%d.dag.dot
digraph DAG {
#CCCCCC
#FFEE99
#FFFFFF
[label="
, style="filled", fillcolor="
%d->%d
orange
grey
,color="
%s.bb%d.nodes
,type="
%s.%s.dot
size = "80, 100";
// Nodes
[shape=record, label="{ID : 
 PRIORITY : 
 ETIME : 
Label: 
} "];
// Edges
Number of operands mismatch between CISA instruction description and value passed in.
ONE OF THE OPERANDS IS NULL!
temp.isa
Could not open %s
Cannot open file %s
isaasmListFile.txt
.visaasm
.errors.txt
 errors in vISA files.
Please see error report written to the file 
Found a total of 
T252
T255
word
dword
qword
oword
2GRF
byte
(abs)
(-abs)
reserved0
line
mulh
rndd
rndu
rnde
rndz
sad2
rsqrt
reserved1C
reserved1D
reserved1E
cbit
addr_add
setp
movs
func
label
call
oword_ld
oword_st
media_ld
media_st
gather
scatter
reserved3b
oword_ld_unaligned
reserved3d
reserved3e
reserved3f
sample
sample_unorm
load
fminmax
bfrev
addc
subb
gather4_typed
scatter4_typed
va_skl_plus
ifcall
faddr
file
reserved53
vme_ime
vme_sic
vme_fbr
vme_idm
reserved58
barrier
sampler_cache_flush
fence
raw_send
reserved5E
yield
reserved60
reserved61
reserved62
reserved63
reserved64
reserved65
reserved66
fcall
fret
switchjmp
sad2add
plane
goto
sample_3d
load_3d
gather4_3d
info_3d
rt_write_3d
urb_write_3d
typed_atomic
gather4_scaled
scatter4_scaled
reserved76
reserved77
gather_scaled
scatter_scaled
raw_sends
lifetime
sbarrier
dword_atomic
sqrtm
divm
dp4a
RESERVED_0
reserved_1c
reserved_1d
reserved_1e
reserved_3B
reserved_3D
reserved_3E
reserved_3F
reserved_53
reserved_58
samplr_cache_flush
reserved_5e
reserved_60
reserved_61
reserved_62
reserved_63
reserved_64
reserved_65
reserved_66
3d_sample
3d_load
3d_gather4
3d_info
3d_rt_write
3d_urb_write
reserved_76
reserved_77
va_convolve_2d
va_minmax
va_minmaxfilter
va_erode
va_dilate
va_boolcentroid
va_centroid
va_convolve_1d_v
va_convolve_1d_h
va_convolve_1pixel
va_floodfill
va_lbpcreation
va_lbpcorrelation
va_correlationsearch
va_hdc_convolve_2d
va_hdc_minmaxfilter
va_hdc_erode
va_hdc_dilate
va_hdc_lbpcorrelation
va_hdc_lbpcreation
va_hdc_convolve_1d_h
va_hdc_convolve_1d_v
va_hdc_convolve_1pixel
svm_block_ld
svm_block_st
svm_gather
svm_scatter
svm_atomic
svm_gather4scaled
svm_scatter4scaled
kernel_
attr 
"cm"
"3d"
"cs"
.decl P
v_type=P 
num_elts=
.decl A
v_type=A 
.decl S
 v_type=S
 num_elts=
 v_name=
.decl T
 v_type=T
.parameter 
.input 
 offset=
.decl 
 v_type=G
 alias=<
.version 
.global_function 
.kernel 
.funcdecl 
/// VISA Predefined Variables
// .decl V
// .decl T
.kernel_attr Target=
Illegal or unimplemented CISA instruction (opcode, type): (
 /// $
_global
.signal
.wait
.any
.all
svm_
block_
.unaligned
atomic
gather4scaled
scatter4scaled
.function 
FILE 
LOC 
raw_sendc 
raw_send 
raw_sendsc.
raw_sends.
eot.
start 
end 
pixel_null_mask.
cps.
divS.
illegal
31x31
15x15
 4x16
 1x16
 1x1
8_connect
4_connect
 31x31
 15x15
.mod
<RTI>
<ST>
<LRTW>
<CPS>
<PS>
Kernel Header / Declare Errors: 
Instruction / Operand / Region Errors: 
label%d's name index(%d) is not valid
S%d's name index(%d) is not valid
S%d's number of elements(%d) is not vaild
T%d's name index(%d) is not valid
T%d's number of elements(%d) is not valid
Input V%d is out of bound [%d, %d)
Input V%d = [%d, %d) intersects with V%d = [%d, %d)
Explicit input %d must not follow an implicit input %d
Input %d points to an invalid variable(%d)
Input %d's size(%d) does not agree with its variable (V%d)'s
Input%d points to an invalid sampler index(%d)
Input%d points to an invalid/predefined surface index(%d)
Input%d's size(%d) does not agree with its surface's
Input%d has invalid operand class(%d)
Invalid opcode, value: 
vISA instruction not supported on this platform
CISA instruction uses an illegal execution size.
CISA instruction uses an illegal predicate value.
 Error in CISA variable decl: 
V%d's name index(%d) is not valid: %s
V%d's type(%s) is not legal: %s
V%d's number of elements(%d) is out of range: %s
V%d's alias offset must be zero when it is not aliased: %s
Circular alias detected, alias index: %d
Aliased variable aliases to an invalid alias index. Variable count: %d. invalid index: %d. %s
Variable decl's alias offset exceeds the bounds of the aliased variable decl allocation size: %s
V%d's variable alignment is not a valid alignment value: %s
V%d's alias index must point to a valid CISA variable index between 0 and %d. Currently points to invalid index V%d: %s
 Error in address variable decl: 
A%d's name index(%d) is not valid: %s
Max possible address registers are 16 on BDW+: %s
 Error in predicate variable decl: 
P%d's name index(%d) is not valid: %s
P%d's number of elements(%d) is not valid: %s
/-------------------------------------------!!!KERNEL HEADER ERRORS FOUND!!!-------------------------------------------\
/--------------------------------------------!!!INSTRUCTION ERROR FOUND!!!---------------------------------------------\
Error in CISA routine with name: 
Error Message: 
Diagnostics: 
 Instruction variables' decls: 
 Violating Instruction: 
\----------------------------------------------------------------------------------------------------------------------/
ADDRESSOF Operand decl... are those even allowed>
Immediate operand: 
Operand type: 
 unable to print.
unknown operand?
                               
More than 1 kernel attribute defined SLMSize
Operand modifier for non-general and non-indirect operands must be MODIFIER_NONE.
Only arithmetic modifiers should be used with arithmetic instruction general or indirect operands.
Only logical modifiers should be used with logical instruction general or indirect operands.
Boolean types for immediate (constant literals) operands are disallowed.
Variable V%d is not declaired in CISA symtab.
Constant Immediate operands are not allowed to be used as destination operands.
Not allowed to write to a read only variable
CISA region has width of 0
Invalid execution size
Horizontal Stride should not be 0 for a destination operand.
There's no reason, to set the vertical stride or width of a destination operand. They are ignored.
Horizontal Stride should not be REGION_NULL
Legal CISA region horizontal stride parameter values: {0, 1, 2, 4}.
Legal CISA region width parameter values: {1, 2, 4, 8, 16}.
Execution size must be greater than width.
Legal CISA region vertical stride parameter values: {0, 1, 2, 4, 8, 16, 32}.
CISA operand region access out of 2 GRF boundary (within %d bytes): %d
CISA operand accesses more than 2 GRF due to mis-alignment: start byte offset = %d, end byte offset = %d
WARNING: CISA region and offset cause an out of bounds byte access: 
An access should not exceed the declared allocation size: 
  The access fails the following check to determine correct bounds (see CISA manual section 5.1 Region-based Addressing):
  (row_offset * GRF_SIZE + col_offset) + (((i * v_stride) + (j * h_stride)) * type_size) <= type_size * num_elements:
) + (((
) + (
)) * 
) <= 
Violating Instruction: 
For 3 source operand instructions, the destination operand's horizontal stride must be 1.
LRP instruction only supports sources and destination of type F.
For 3 source operand instructions, region must be either scalar or contiguous
Aliased variable aliases to an invalid alias index. Variable count: %d. invalid index: %d
Raw operand should be GRF-aligned: Raw offset is %d
A CISA raw operand's offset field must be within the allocated operand size. Raw offset is %d, allocated number of elements is %d
Execution size for a flag copy mov instruction should be 1, as it is a scalar copy.
dst operand type for a flag copy mov instruction should be UD/UW/UB.
dst operand type for a flag copy mov instruction should be greater than or equal to the size of the src0 operand's type size.
saturation is not allowed for dst operands of a flag copy mov instruction
predication is not allowed for dst operands of a flag copy mov instruction
Destination operand of CISA MOVS instruction only supports general and indirect operands.
Source0 operand of CISA MOVS instruction only supports general, indirect, and immediate operands.
Destination operand of CISA SETP instruction only supports predicate operands.
Source0 operand of CISA SETP instruction only supports general, indirect, and immediate operands.
FMINMAX opext must be either 0x0 or 0x1 (min or max).
Destination operand of CISA SEL instruction only supports general and indirect operands.
Source0 operand of CISA SEL instruction only supports general, indirect, and immediate operands.
Source1 operand of CISA SEL instruction only supports general, indirect, and immediate operands.
Illegal Move Instruction Opcode: %d, %s.
Illegal Synchronization Instruction Opcode: %d, %s.
Illegal Scalar Control Flow Instruction Opcode: %d, %s.
CISA ISA_VME_IME instruction uses illegal stream mode.
CISA ISA_VME_IME instruction uses illegal search ctrl.
CISA ISA_VME_IME uses undeclared surface.
CISA ISA_VME_SIC uses undeclared surface.
CISA ISA_VME_FBR uses undeclared surface.
FBRMbMode operand of CISA VME_FBR instrution should be either a general, indirect, or immediate operand.
FBRSubMbShape operand of CISA VME_FBR instrution should be either a general, indirect, or immediate operand.
FBRSubPredMode operand of CISA VME_FBR instrution should be either a general, indirect, or immediate operand.
Number of message source GRFs must be between 1 and 15
Number of message destination GRFs must be between 0 and 16
desc operand of CISA RAW_SEND instrution should be either a general, indirect, or immediate operand.
Number of source0 GRFs must be between 1 and 32
Number of source1 GRFs must be between 1 and 32
Number of message destination GRFs must be between 0 and 32
Valid range for num_out parameter of URB write is [1,8]
Valid range for global_offset parameter of URB write is [0,2047]
Only execution size of 8 is supported for URB write
Invalid encoding for register file
Illegal Miscellaneous Flow Instruction Opcode: %d, %s.
Destination of CISA arithmetic instruction should be general or indirect operand.
Illegal destination modifier for CISA arithmetic instruction.
%s does not support saturation
%s does not support saturation on integer types.
Only mul/add/mad/div/inv/sqrtm/sqrt/divm are allowed to use double precision floating point operands.
%s only supports single and half float type
%s only supports single float type
%s only supports integer and single precision float types
%s only supports integer type
lzd only supports UD type
%s only support D/UD dst type
sad2/sad2add only supports W/UW dst type.
%s only supports single UD type
%s has illegal dst type
unsupported source modifier for arithmetic instruction
source in arithmetic instruction must be general, indirect, or immediate
Arithmetic instructions that use single or double precision or half float types must use the same type for all of their operannds: dst(%s) and src%d(%s).
immediate src%d has %d type, and it must have integer type
sad2/sad2add only supports B/UB types for src0 and src1; W/UW for src2 (sad2add). src%d has invalid type.
mul/div does not support Q/UQ types for src%d
ieee div does not support types for src%d, other than F/DF
ieee sqrt does not support types for src%d, other than F/DF
%s src0 and src1 only supports single UD type
lrp only supports general/immediate operands
Common ISA Logic instrutions are not allowed to have address operands.
Operand type of logic operantion for predicate operands should all be BOOL (ie if one operand is BOOL they all have to be BOOL).
ror/rol does not support i8/i64 types
fbl/fbh/cbit does not support Q/UQ type.
Predicate can not be used in logic operantion for predicate operands.
All operands of logic instructions must be of integral type! opnd %d has float type %d
All operands of logic instructions must be of integral type! opnd %d has unknow type %d
CISA compare instruction destination only supports a predicate operand.
CISA compare instruction sources do not support address or predicate operands.
CISA address instruction destination only supports an address operand.
CISA ADDR_ADD instruction sources do not support predicate operands.
Can not take the address of a pre-defined variable
Can not take the address of a pre-defined surface
Data type of the second source of ADDR_ADD should be WORD or BYTE.
CISA SAMPLER ISA_SAMPLE_UNORM instruction only accepts non-zero channel masks.
CISA SAMPLER ISA_SAMPLE_UNORM instruction uses undeclared sampler.
Surface T0 (the SLM surface) is not allowed for the SAMPLER instruction ISA_SAMPLE_UNORM.
CISA SAMPLER instruction ISA_SAMPLE_UNORM uses undefined surface.
u_offset operand of CISA SAMPLER ISA_SAMPLE_UNORM instrution should be either a general, indirect, or immediate operand.
v_offset operand of CISA SAMPLER ISA_SAMPLE_UNORM instrution should be either a general, indirect, or immediate operand.
u_delta operand of CISA SAMPLER ISA_SAMPLE_UNORM instrution should be either a general, indirect, or immediate operand.
v_delta operand of CISA SAMPLER ISA_SAMPLE_UNORM instrution should be either a general, indirect, or immediate operand.
CISA SAMPLER SAMPLE/LOAD instruction uses undeclared sampler.
Surface T0 (the SLM surface) is not allowed for the SAMPLER instruction ISA_SAMPLE/ISA_LOAD.
CISA SAMPLER instruction ISA_SAMPLE/ISA_LOAD uses undefined surface.
CISA SAMPLER ISA_SAMPLE/ISA_LOAD instruction only accepts non-zero channel masks.
Illegal SIMD mode used in ISA_SAMPLE/ISA_LOAD inst.
Pixel Null Mask Enable only valid for SKL+
CPS LOD Compensation Enable must be disabled unless SIMD mode is simd8* or simd16*
CPS LOD Compensation Enable is only supported for sample, sample_b, sample_b_c, sample_c and LOD
CISA SAMPLER AVS instruction only accepts non-zero channel masks.
CISA VA MINMAXFILTER instruction uses undeclared sampler.
Surface T0 (the SLM surface) is not allowed for the SAMPLER AVS instruction.
CISA VA instruction MINMAX uses undefined surface.
u_offset operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
v_offset operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
u_delta operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
v_delta operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
u2d operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
groupid operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
verticalBlockNumber operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
cntrl for CISA SAMPLER AVS intruction should be a value 0-3 (8/16bit full/chrominance down sample).
v2d operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
execMode for CISA SAMPLER AVS intruction should be a value 0-3 (16x4, 8x4, 16x8, or 4x4).
iefbypass operand of CISA SAMPLER AVS instruction should be either a general, indirect, or immediate operand.
Surface T0 (the SLM surface) is not allowed for VA instructions.
u_offset operand of CISA MINMAX instrution should be either a general, indirect, or immediate operand.
v_offset operand of CISA MINMAX instrution should be either a general, indirect, or immediate operand.
CISA VA instruction MINMAXFILTER uses undefined surface.
u_offset operand of CISA MINMAXFILTER instrution should be either a general, indirect, or immediate operand.
v_offset operand of CISA MINMAXFILTER instrution should be either a general, indirect, or immediate operand.
CISA VA VA CENTROID/BOOLCENTROID instruction MINMAX uses undefined surface.
u_offset operand of CISA VA CENTROID/BOOLCENTROID instrution should be either a general, indirect, or immediate operand.
v_offset operand of CISA VA CENTROID/BOOLCENTROID instrution should be either a general, indirect, or immediate operand.
v_size operand of CISA VA CENTROID/BOOLCENTROID instrution should be either a general, indirect, or immediate operand.
h_size operand of CISA VA CENTROID/BOOLCENTROID instrution should be either a general, indirect, or immediate operand.
CISA VA CONVOLVE/ERODE/DILATE instruction uses undeclared sampler.
CISA VA CONVOLVE/ERODE/DILATE instruction MINMAX uses undefined surface.
u_offset operand of CISA CONVOLVE/ERODE/DILATE instrution should be either a general, indirect, or immediate operand.
v_offset operand of CISA CONVOLVE/ERODE/DILATE instrution should be either a general, indirect, or immediate operand.
Invalid VA sub-opcode: %d.
Surface T0 (the SLM surface) is not allowed for VA++ instructions.
CISA VA++ instruction LBP Correlation uses undefined surface.
u_offset operand of CISA LBP Correlation instrution should be either a general, indirect, or immediate operand.
v_offset operand of CISA LBP Correlation instrution should be either a general, indirect, or immediate operand.
Disparity operand of CISA LBP Correlation instrution should be either a general, indirect, or immediate operand.
CISA VA++ instruction uses undeclared sampler.
CISA VA++ instruction uses undefined surface.
u_offset operand of CISA VA++ instrution should be either a general, indirect, or immediate operand.
v_offset operand of CISA VA++ instrution should be either a general, indirect, or immediate operand.
Invalid mode field for CISA VA++ instruction. Only 4x16, 1x16, and 1x1 (in the case of 1 pixel convolve) are supported.
CISA LBP Creation VA++ instruction uses undefined surface.
u_offset operand of CISA LBP Creation VA++ instrution should be either a general, indirect, or immediate operand.
v_offset operand of CISA LBP Creation VA++ instrution should be either a general, indirect, or immediate operand.
Invalid mode field for CISA LBP Creation VA++ instruction. Only 5x5, 3x3, or both modes are supported.
Pixel direction v-mask left of CISA VA++ FloodFill instruction only supports general, indirect, and immediate operands.
Pixel direction v-mask right of CISA VA++ FloodFill instruction only supports general, indirect, and immediate operands.
loop_count of Common ISA sample instrution is invalid type.
u_offset of Common ISA Meida LD/ST instrution should not be address or predicate operand.
v_offset of Common ISA Meida LD/ST instrution should not be address or predicate operand.
CISA VA++ instruction Correlation search operand verticalOrigin can only be of operand class general, indirect, or immediate.
CISA VA++ instruction Correlation search operand horizontalOrigin can only be of operand class general, indirect, or immediate.
CISA VA++ instruction Correlation search operand xDirectionSize can only be of operand class general, indirect, or immediate.
CISA VA++ instruction Correlation search operand yDirectionSize can only be of operand class general, indirect, or immediate.
CISA VA++ instruction Correlation search operand xDirectionSearchSize can only be of operand class general, indirect, or immediate.
CISA VA++ instruction Correlation search operand yDirectionSearchSize can only be of operand class general, indirect, or immediate.
u_offset of Common ISA HDC INSTRUCTION should not be address or predicate operand.
v_offset of Common ISA HDC instruction should not be address or predicate operand.
CISA VA++ instruction uses invalid output pixel size.
CISA VA++ instruction uses invalid mode.
disparity of Common ISA HDC LBPCORRELATION should not be address or predicate operand.
CISA VA++ instruction uses undefined destination surface.
x_offset of Common ISA HDC instruction should not be address or predicate operand.
y_offset of Common ISA HDC instruction should not be address or predicate operand.
Invalid VA++ sub-opcode: %d.
Illegal Sampler Instruction Opcode: %d, %s.
Illegal SIMD CF Instruction Opcode: %d, %s.
MEDIA_LD modifier must be 0-5 not %d
MEDIA_ST modifier must be 0-3 not %d
Surface T0 (the SLM surface) is not allowed for MEDIA_LD/MEDIA_ST
CISA dataport instruction uses an undeclared surface.
MEDIA_LD/MEDIA_ST plane must be in the range [0, 3]: %d
MEDIA_LD/MEDIA_ST block width must be in the range [1, 32]: %d
MEDIA_LD/MEDIA_ST block height must be in the range [1, 64]: %d
MEDIA_LD only supports objects that fit into a single dataport transaction where block width <= 64 bytes and size <= 256 bytes. Block width: %d. Block height: %d
MEDIA_ST only supports objects that fit into a single dataport transaction where block width <= 64 bytes and size <= 256 bytes. Block width: %d. Block height: %d
x_offset of Common ISA Meida LD/ST instrution should not be address or predicate operand.
y_offset of Common ISA Meida LD/ST instrution should not be address or predicate operand.
OWORD_LD*/OWORD_ST size must be in the range [0, 3] (ie, OWord block size must be 1/2/4/8. OWord block size: %d
Surface T0 (the SLM surface) is not allowed for OWORD_LD*/OWORD_ST
Offset of Common ISA OWORD LD/ST instrutions should not be address or predicate operands.
Incorrect element size for Gather/Scatter CISA inst.
global_offset of Common ISA gather/scatter instrution should not be address or predicate operand.
At least one channel must be enabled for TYPED GATEHR4/SCATTER4
Surface T0/T5 (the SLM surface) is not allowed for TYPED SCATTTER4/GATHER4
CISA dataport TYPED SCATTTER4/GATHER4 instruction uses an undeclared surface.
Invalid DWORD ATOMIC sub op.
src0 in ISA_DWORD_ATOMIC inst must be V0 for INC/DEC/PREDEC.
src1 in ISA_DWORD_ATOMIC inst must be V0 for non CMPXCHG operations.
Illegal dataport Instruction Opcode: %d, %s.
Raw Operand %s has incorrect type %s
EXPLICIT
LOCAL_SIZE
GROUP_COUNT
LOCAL_ID
PSEUDO_INPUT
nomod
modified
bottom
top_mod
bottom_mod
reserved
RGBA
0000
16-full
16-downsampled
8-full
8-downsampled
M1_NM
M2_NM
M3_NM
M4_NM
M5_NM
M6_NM
M7_NM
M8_NM
sample_b
sample_l
sample_c
sample_d
sample_b_c
sample_l_c
sample4
resinfo
sampleinfo
sample+killpix
sample4_c
sample4_po
sample4_po_c
sample_d_c
sample_lz
sample_c_lz
load_lz
load_2dms_w
load_mcs
convolve
minmax
minmaxfilter
erode
dilate
boolcentroid
centroid
CONV_1D_HORIZONTAL
CONV_1D_VERTICAL
CONV_1PIXEL
FLOOD_FILL
LBP_CREATION
LBP_CORRELATION
CORRELATION_SEARCH
HDC_CONVOLVE_2D
HDC_MIN_MAX_FILTER
HDC_ERODE
HDC_DILATE
HDC_LBP_CORRELATION
HDC_LBP_CREATION
HDC_CONVOLVE_1D_H
HDC_CONVOLVE_1D_V
HDC_CONVOLVE_1P
UNDEFINED
CM_Y16_FORMAT
CM_Y8_FORMAT
CM_5x5_mode
CM_3x3_mode
CM_BOTH_mode
CM_16_FULL
CM_16_DOWN_SAMPLE
CM_8_FULL
CM_8_DOWN_SAMPLE
CM_AVS_16x4
CM_AVS_INVALID
CM_AVS_16x8
CM_MMF_16x4
CM_MMF_INVALID
CM_MMF_16x1
CM_MMF_1x1
CM_MINMAX_ENABLE
CM_MAX_ENABLE
CM_MIN_ENABLE
CM_ED_64x4
CM_ED_32x4
CM_ED_64x1
CM_ED_32x1
CM_CONV_16x4
CM_CONV_INVALID
CM_CONV_16x1
CM_CONV_1x1
xchg
cmpxchg
minsint
maxsint
fcmpwr
ICLLP
gen11
gen11lp
none
USAGE: Unrecognized option "
unrecognized platform string: 
USAGE: GenX_IR <InputFilename.isa> {Option List}
Converts a CISA file into Gen binary or assembly
Options :
    -output
- Emit target assembly code to a file.
    -noschedule
- Turn off code scheduling.
    -nocompaction
- Turn off binary compaction.
    -dumpcommonisa
- Emit CISA assembly.
USAGE: GenX_IR <InputFilename.visaasm> {Option List}
Converting a CISA assembly file into CISA binary file
    -outputCisaBinaryName <CISABinaryName>
- name for the CISA binary file.
vISA_DumpPasses
vISA_DumpPassesLocation
vISA_DumpDot
vISA_DumpDotAll
VISA_FullIRVerify
vISA_dumpVISAOptions
vISA_dumpVISAOptionsAll
vISA_Debug
vISA_DebugConsoleDump
vISA_Gtpin
vISA_EmitLocation
vISA_dumpRPE
vISA_dumpLiveness
vISA_EnableAlways
vISA_EnableSendFusion
vISA_EnableWriteFusion
vISA_EnableAtomicFusion
vISA_LocalCopyProp
vISA_LocalFlagOpt
vISA_LocalMACopt
vISA_LocalCleanMessageHeader
vISA_LocalRenameRegister
vISA_LocalDefHoist
vISA_FoldAddrImmed
vISA_enableCSEL
vISA_OptReport
vISA_MergeScalar
vISA_EnableMACOpt
vISA_EnableDCE
vISA_DisableleHFOpt
vISA_enableUnsafeCP_DF
vISA_EnableStructurizer
vISA_StructurizeCF
vISA_EnableScalarJmp
vISA_enableCleanupBindless
vISA_EnableSplitVariables
vISA_ChangeMoveType
vISA_accSubstitution
vISA_doAccSubAfterSchedule
vISA_ifCvt
vISA_LVN
vISA_numGeneralAcc
vISA_reassociate
vISA_unsafeMath
vISA_split4GRFVar
vISA_noSrc1Byte
vISA_expandPlane
vISA_FImmToHFImm
vISA_cacheSamplerHeader
vISA_forceSamplerHeader
vISA_noncoherentStateless
vISA_enablePreemption
VISA_EnableBarrierInstCounterBits
vISA_forceFPMAD
vISA_DisableMixMode
vISA_DisableHFMath
vISA_ForceMixMode
vISA_UseSends
vISA_doAlign1Ternary
vISA_loadThreadPayload
vISA_foldEOTtoPrevSend
vISA_hasRNEandDenorm
vISA_forceNoFP64bRegioning
vISA_alignBindlessSampler
vISA_RoundRobin
vISA_PrintRegUsage
vISA_IPA
vISA_LocalRA
vISA_LocalRARoundRobin
vISA_ForceSpills
vISA_NoIndirectForceSpills
vISA_AbortOnSpill
vISA_VerifyRA
vISA_LocalBankConflictReduction
vISA_FailSafeRA
vISA_FlagSpillCodeCleanup
vISA_GRFSpillCodeCleanup
vISA_SpillSpaceCompression
vISA_ConsiderLoopInfoInRA
vISA_ReserveR0
vISA_SpiltLLR
vISA_EnableGlobalScopeAnalysis
vISA_LocalDeclareSplitInGlobalRA
vISA_DisableSpillCoalescing
vISA_GlobalSendVarSplit
vISA_NoRemat
vISA_ForceRemat
vISA_SpillMemOffset
vISA_ReservedGRFNum
vISA_TotalGRFNum
vISA_GRFNumToUse
vISA_RATrace
vISA_FastSpill
vISA_AbortOnSpillThreshold
vISA_enableBCR
vISA_hierarchicaIPA
vISA_VerifyAugmentation
vISA_LocalScheduling
vISA_preRA_Schedule
vISA_preRA_ScheduleForce
vISA_preRA_ScheduleCtrl
vISA_preRA_ScheduleRPThreshold
vISA_DumpSchedule
vISA_DumpDagDot
vISA_EnableNoDD
vISA_DebugNoDD
vISA_NoDDLookBack
vISA_EnableNoSrcDep
vISA_EnableNoSrcDepScen1
vISA_EnableNoSrcDepScen2
vISA_DumpNoSrcDep
vISA_stopNoSrcDepSetAt
vISA_FuseTypedWrites
vISA_ReorderDPSendToDifferentBti
vISA_WAWSubregHazardAvoidance
vISA_useMultiThreadedLatencies
vISA_SchedulerWindowSize
vISA_UnifiedSendCycle
vISA_HWThreadNumberPerEU
vISA_NoAtomicSend
vISA_ReadSuppressionDepth
vISA_Compaction
vISA_BXMLEncoder
vISA_IGAEncoder
vISA_outputToFile
vISA_SymbolReg
vISA_PrintASMCount
vISA_GenerateBinary
vISA_GeneratevISABInary
vISA_IsaAssembly
vISA_GenerateISAASM
vISA_DumpIsaVarNames
vISA_GenIsaAsmList
vISA_UniqueLabels
vISA_IsaasmNamesFileUsed
vISA_DumpvISA
vISA_StripComments
vISA_dumpNewSyntax
vISA_NumGenBinariesWillBePatched
vISA_ISAASMNamesFile
vISA_GetvISABinaryName
vISA_OutputvISABinaryName
vISA_LabelStr
VISA_AsmFileName
vISA_DecodeDbg
vISA_encoderFile
vISA_CISAbinary
vISA_PlatformIsSet
vISA_NoVerifyvISA
vISA_InitPayload
vISA_isParseMode
vISA_ReRAPostSchedule
vISA_GetFreeGRFInfo
vISA_clearScratchWritesBeforeEOT
vISA_clearHDCWritesBeforeEOT
vISA_setA0toTdrForSendc
vISA_addFFIDProlog
vISA_setFFID
vISA_clearAccBeforeEOT
vISA_replaceIndirectCallWithJmpi
vISA_GenerateDebugInfo
vISA_setStartBreakPoint
vISA_InsertHashMovs
vISA_InsertDummyCompactInst
VISA_AsmFileNameUser
vISA_HashVal
vISA_HashVal1
vISA_easyIsaasm
vISA_AddKernelID
vISA_dumpPayload
vISA_dumpToCurrentDir
vISA_dumpTimer
vISA_DumpCompilerStats
vISA_3DOption
vISA_Stepping
vISA_Platform
-dumpPassesAll
-dumpPassesLocation
-dot
-dotAll
-fullIRVerify
-dumpVisaOptions
-dumpVisaOptionsAll
-dumpDebugConsoleOutput
-gtpin
-emitLocation
-dumpRPE
-dumpLiveness
-enableSendFusion
-enableWriteFusion
-enableAtomicFusion
-nocopyprop
-noflagopt
-nomacopt
-nomsgheaderopt
-noregrenaming
-nodefhoist
-nofoldaddrimmed
-disablecsel
-optreport
-nomergescalar
-nomac
-dce
-disableHFOpt
-enableUnsafeCP_DF
-disableStructurizer
-noStructurize
-noScalarJmp
-noSplitVariables
-ALTMode
-noAccSub
-accSubPostSchedule
-noifcvt
-nolvn
-numGeneralAcc
-noreassoc
-unsafeMath
-no4GRFSplit
-nosrc1byte
-expandPlane
-noSamplerHeaderCache
-forceSamplerHeader
-ncstateless
-enablePreemption
-enableBarrierInstCounterBits
-disableMixMode
-disableHFMath
-forceMixMode
-nosends
-noalign1ternary
-noLoadPayload
-foldEOT
-hasRNEandDenorm
-noFP64bRegion
-alignBS
-noroundrobin
-printregusage
-noipa
-nolocalra
-nolocalraroundrobin
-forcespills
-noindirectforcespills
-abortonspill
-verifyra
-nolocalBCR
-nofailsafera
-disableFlagSpillClean
-noloopra
-reserveR0
-nosplitllr
-enableGlobalScopeAnalysis
-nospillcleanup
-globalSendVarSplit
-noremat
-forceremat
-spilloffset
-reservedGRFNum
-TotalGRFNum
-GRFNumToUse
-ratrace
-abortonspillthreshold
-enableBCR
-oldIPA
-verifyaugmentation
-noschedule
-nopresched
-presched
-presched-ctrl
-presched-rp
-dumpSchedule
-dumpDagDot
-enable-noDD
-debug-noDD
-noDD-lookback
-enable-noSrcDep
-disable-noSrcDep-scen1
-disable-noSrcDep-scen2
-dump-noSrcDep
-stop-noSrcDep-at
-nofuse-typedWrites
-nodpsendreorder
-noWAWSubregHazardAvoidance
-dontUseMultiThreadedLatencies
-schedulerwindow
-unifiedSendCycle
-HWThreadNumberPerEU
-noAtomicSend
-readSuppressionDepth
-nocompaction
-nobxmlencoder
-IGAEncoder
-output
-symbolreg
-printasmcount
-binary
-dumpcommonisa
-dumpisavarnames
-genIsaasmList
-stripcomments
-disableIGASyntax
-numGenBinariesWillBePatched
-isaasmNamesOutputFile
-outputCisaBinaryName
-uniqueLabels
-asmNameUser
-decodedbg
-encoderStatisticsFile
-CISAbinary
-noverifyCISA
-initializePayload
-rerapostschedule
-getfreegrfinfo
-setA0toTdrForSendc
-noFFIDProlog
-setFFID
-clearAccBeforeEOT
-replaceIndirectCallWithJmpi
-generateDebugInfo
-setstartbp
-insertDummyCompactInst
-hashmovs
-hashmovs1
-easyisaasm
-addKernelID
-dumpPayload
-dumpToCurrentDir
-timestats
-compilerStats
-stepping
-platform
USAGE: Directory to dump VISA passes into
USAGE: -numGeneralAcc <accNum>
USAGE: -spilloffset <offset>
USAGE: -reservedGRFNum <regNum>
USAGE: -TotalGRFNum <regNum>
USAGE: -GRFNumToUse <regNum>
USAGE: -abortonspillthreshold <threshold>
USAGE: -presched-ctrl <ctrl>
USAGE: -presched-rp <threshold>
USAGE: -noDD-lookback <NUM>
Usage: -stop-noSrcDep-at <NUMBER>
USAGE: -schedulerwindow <window-size>
USAGE: -unifiedSendCycle <cycle>
USAGE: -HWThreadNumberPerEU <num>
USAGE: missing number of gen binaries that will be patched.
USAGE: File Name with isaasm paths.
Label String is not provided for the -uniqueLabels option.
USAGE: -asmNameUser <FILE>
USAGE: -decodedbg <dbg filename>
USAGE: -encoderStatisticsFile <reloc file>
encoderStatistics.csv
USAGE: File Name with isaasm paths. 
USAGE: -setFFID <ffid>
USAGE: -hashmovs hi32 lo32
USAGE: -hashmovs1 hi32 lo32
USAGE: missing stepping string. 
USAGE: missing platform string. 
UNDEFINED 
false
unordered_map::at: key not found
NULL
jit_time.txt
timers.
IR_Build
Optimizer
HW_Conformity
Misc_opts
Total_RA
Addr_Flag_RA
GRF_Local_RA
GRF_Hybrid_RA
GRF_Global_RA
  Interference
  Graph Coloring
preRA_Scheduling
Scheduling
Encode+Emit
Compaction
IGA_Encoding
VB_Append_Instruction
VB_Create_Var
VB_Create_Operand
VB_IR_Construction
liveness
Reg Pressure Estimate
Inliner for always_inline functions
always-inline
A No-Op Barrier Pass
enable-nonnull-arg-prop
Try to propagate nonnull argument attributes from callsites to caller functions.
disable-nounwind-inference
Stop inferring nounwind attribute during function-attrs pass
functionattrs
Deduce function attributes
..., 
Dead Global Elimination
globaldce
StringRef llvm::getTypeName() [DesiredTypeName = llvm::InnerAnalysisManagerProxy<FunctionAnalysisManager, Module>]
enable-coldcc-stress-test
Enable stress test of coldcc by adding calling conv to all internal functions.
coldcc-rel-freq
Maximum block frequency, expressed as a percentage of caller's entry frequency, for a call site to be considered cold for enablingcoldcc
globalopt
newgv
.init
notinit
isneg
isnull
malloc_cont
malloc_ret_null
free_it
next
Global Variable Optimizer
Interprocedural constant propagation
ipconstprop
Function Integration/Inlining
inline
disable-inlined-alloca-merging
inliner-function-import-stats
basic
basic statistics
verbose
printing of statistics for each inlined function
Enable inliner stats for imported functions
Cannot find option named '
NoDefinition
Callee
 will not be inlined into 
 because its definition is unavailable
NotInlined
AlwaysInline
Inlined
 inlined into 
 with cost=always
 with cost=
 (threshold=
Threshold
NeverInline
 not inlined into 
 because it should never be inlined (cost=never)
TooCostly
 because too costly to inline (cost=
, threshold=
IncreaseCostInOtherContexts
Not inlining. Cost of inlining 
 increases the cost of inlining 
 in other contexts
parse
Parse IR
irparse
LLVM IR Parsing
bitcode-mdindex-threshold
Number of metadatas above which we emit an index to enable lazy-loading
write-relbf-to-summary
Write relative block frequency to function summary 
Invalid encoding
LLVM7.0.0
ThinLTO
Unexpected anonymous function when writing summary
Write Bitcode
write-bitcode
Bitcode Writer
Default
MetaData
Map Name: 
Size: 
Value: 
Value: [null]
 Uses(
 [null]
Metadata: slot = 
Metadata: function = 
constant bigger than 64 bits detected!
constant bigger than 128 bits detected!
end of file in COMDAT variable name
Null bytes are not allowed in names
end of file in string constant
invalid value number (too large)!
end of file in global variable name
bitwidth for integer type out of range!
declare
available_externally
linkonce_odr
appending
unnamed_addr
local_unnamed_addr
extern_weak
zeroinitializer
undef
unwind
unordered
monotonic
acquire
release
acq_rel
seq_cst
alias
alignstack
fastcc
coldcc
x86_stdcallcc
x86_fastcallcc
x86_thiscallcc
x86_vectorcallcc
arm_apcscc
arm_aapcscc
arm_aapcs_vfpcc
msp430_intrcc
ptx_kernel
ptx_device
spir_kernel
spir_func
intel_ocl_bicc
x86_64_sysvcc
win64cc
x86_regcallcc
webkit_jscc
swiftcc
anyregcc
preserve_mostcc
preserve_allcc
ghccc
x86_intrcc
hhvmcc
hhvm_ccc
cxx_fast_tlscc
amdgpu_vs
amdgpu_ls
amdgpu_hs
amdgpu_es
amdgpu_gs
amdgpu_ps
amdgpu_cs
amdgpu_kernel
attributes
alwaysinline
argmemonly
builtin
byval
inalloca
cold
convergent
dereferenceable
dereferenceable_or_null
inaccessiblememonly
inaccessiblemem_or_argmemonly
inlinehint
inreg
jumptable
minsize
naked
noalias
nobuiltin
nocapture
noduplicate
noimplicitfloat
noinline
norecurse
nonlazybind
nonnull
noredzone
noreturn
nocf_check
optforfuzzing
optnone
optsize
readnone
readonly
returned
returns_twice
signext
speculatable
sret
sspreq
sspstrong
strictfp
safestack
shadowcallstack
sanitize_address
sanitize_hwaddress
sanitize_thread
sanitize_memory
swifterror
swiftself
uwtable
writeonly
zeroext
opaque
exactmatch
largest
noduplicates
samesize
umax
uselistorder
name
flags
function
unknown
critical
variable
typeTestAssumeVCalls
typeCheckedLoadVCalls
typeTestAssumeConstVCalls
typeCheckedLoadConstVCalls
unsat
byteArray
single
allOnes
indir
singleImpl
branchFunnel
uniformRetVal
uniqueRetVal
virtualConstProp
x86_fp80
fp128
ppc_fp128
x86_mmx
token
zext
switch
store
extractelement
Can't read textual IR with a Context that discards named Values
expected function name in blockaddress
use of undefined type '%
use of undefined type named '
use of undefined comdat '$
use of undefined value '@
use of undefined metadata '!
use of undefined summary '^
use of undefined type id summary '^
expected top-level entity
expected 'module asm'
unknown target property
expected '=' after target triple
expected '=' after target datalayout
expected '=' after source_filename
expected '=' after deplibs
expected ']' at end of list
expected '=' after name
expected 'type' after '='
non-struct types may not be recursive
expected 'type' after name
expected 'global' or 'constant'
variable expected to be numbered '%
expected '=' in global variable
expected '=' here
expected comdat keyword
expected comdat type
unknown selection kind
redefinition of comdat '$
Expected '!' here
Expected '{' here
expected end of metadata node
unexpected type in metadata definition
Metadata id is already used
Expected 'gv', 'module', or 'typeid' at the start of summary entry
expected ':' at start of summary entry
expected '(' at start of summary entry
found end of file while parsing summary entry
unexpected summary kind
invalid linkage type for alias
symbol with local linkage must have default visibility
expected comma after alias or ifunc's type
invalid aliasee
An alias or ifunc must have pointer type
explicit pointee type doesn't match operand's pointee type
explicit pointee type should be a function type
redefinition of global '@
forward reference and definition of alias have different types
invalid type for global variable
forward reference and definition of global have different types
expected global section string
unknown global variable property!
expected attribute group id
expected '{' here
expected end of attribute group
attribute group has no attributes
unterminated attribute group
cannot have an attribute group reference in an attribute group
invalid use of attribute on a function
invalid use of parameter-only attribute on a function
global variable reference must have pointer type
' defined with type '
expected string constant
expected integer
expected 32-bit integer (too large)
expected localdynamic, initialexec or localexec
expected ')' after thread local model
expected '(' in address space
expected ')' in address space
invalid use of function-only attribute
invalid use of parameter-only attribute
invalid use of attribute on return type
dso_location and DLL-StorageClass mismatch
expected metadata after comma
alignment is not a power of two
huge alignments are not supported yet
expected '('
expected ')'
dereferenceable bytes must be non-zero
expected metadata or 'align'
expected metadata or 'addrspace'
'allocsize' indices can't refer to the same parameter
Expected '(' in syncscope
Expected synchronization scope name
Expected ')' in syncscope
Expected ordering on atomic instruction
stack alignment is not a power of two
expected ',' as start of index list
expected index
expected '>' at end of packed struct
void type only allowed for function results
basic block pointers are invalid
pointers to void are invalid - use i8* instead
pointer to this type is invalid
pointers to void are invalid; use i8* instead
expected '*' in address space
expected '(' in call
expected ',' in argument list
unexpected ellipsis in argument list for 
non-musttail call
musttail call in non-varargs function
expected ')' at end of argument list
expected '...' at end of argument list for musttail call in varargs function
expected ',' in input list
expected '(' in operand bundle
operand bundle set must not be empty
argument can not have void type
invalid type for function argument
invalid function return type
argument name invalid in function type
argument attributes invalid in function type
redefinition of type
forward references to non-struct type
expected '>' in packed struct
invalid element type for struct
expected '}' at end of struct
expected number in address space
expected 'x' after element count
expected end of sequential type
zero element vector is illegal
size too large for vector
invalid vector element type
invalid array element type
use of undefined value '%
' is not a basic block
invalid use of a non-first-class type
instructions returning void cannot have a name
instruction expected to be numbered '%
instruction forward referenced with type '
multiple definition of local value named '
expected value token
expected end of struct constant
expected end of packed struct
expected end of constant
constant vector must not be empty
vector elements must have integer, pointer or floating point type
vector element #
 is not of type '
expected end of array constant
invalid array element type: 
array element #
expected string
expected comma in inline asm expression
expected constraint string
expected '(' in block address expression
expected comma in block address expression
expected ')' in block address expression
expected basic block name in blockaddress
cannot take blockaddress inside a declaration
referenced value is not a basic block
cannot take address of numeric label after the function is defined
expected '(' after constantexpr cast
expected 'to' in constantexpr cast
expected ')' at end of constantexpr cast
invalid cast opcode for cast from '
' to '
expected '(' in extractvalue constantexpr
expected ')' in extractvalue constantexpr
extractvalue operand must be aggregate type
invalid indices for extractvalue
expected '(' in insertvalue constantexpr
expected comma in insertvalue constantexpr
expected ')' in insertvalue constantexpr
insertvalue operand must be aggregate type
invalid indices for insertvalue
insertvalue operand and field disagree in type: '
' instead of '
expected '(' in compare constantexpr
expected comma in compare constantexpr
expected ')' in compare constantexpr
compare operands must have the same type
fcmp requires floating point operands
icmp requires pointer or integer operands
expected '(' in binary constantexpr
expected comma in binary constantexpr
expected ')' in binary constantexpr
operands of constexpr must have same type
nuw only applies to integer operations
nsw only applies to integer operations
constexpr requires integer operands
constexpr requires fp operands
expected '(' in logical constantexpr
expected comma in logical constantexpr
expected ')' in logical constantexpr
constexpr requires integer or integer vector operands
expected '(' in constantexpr
expected comma after getelementptr's type
expected ')' in constantexpr
base of getelementptr must be a pointer
getelementptr index must be an integer
getelementptr vector index has a wrong number of elements
base element of getelementptr must be sized
invalid getelementptr indices
inrange keyword may not appear on pointer operand
expected three operands to select
expected three operands to shufflevector
invalid operands to shufflevector
expected two operands to extractelement
invalid extractelement operands
expected three operands to insertelement
invalid insertelement operands
global values must be constants
expected comdat variable
expected ')' after comdat var
comdat cannot be unnamed
expected '!' here
expected metadata type
missing required field 'scope'
missing required field 'tag'
missing required field 'count'
missing required field 'name'
missing required field 'value'
unsigned enumerator with negative value
missing required field 'baseType'
missing required field 'types'
missing required field 'filename'
missing required field 'directory'
'checksumkind' and 'checksum' must be provided together
missing 'distinct', required for !DICompileUnit
missing required field 'language'
missing required field 'file'
missing 'distinct', required for !DISubprogram when 'isDefinition'
missing required field 'discriminator'
missing required field 'type'
missing required field 'line'
expected '(' here
invalid DWARF op '
expected unsigned integer
element too large, limit is 
expected ')' here
missing required field 'var'
missing required field 'expr'
invalid metadata-value-metadata roundtrip
expected metadata operand
functions are not values, refer to them as pointers
invalid use of function-local name
invalid type for inline asm constraint string
integer constant must have integer type
floating point constant invalid for type
floating point constant does not have type '
null must be a pointer type
invalid type for undef constant
invalid empty array initializer
invalid type for null constant
invalid type for none constant
constant expression type mismatch
initializer with struct type has wrong # elements
packed'ness of initializer and type don't match
element 
 of struct initializer doesn't match struct element type
expected a basic block
invalid linkage for function definition
invalid linkage for function declaration
invalid function linkage type
function expected to be numbered '%
expected function name
expected '(' in function argument list
'builtin' attribute not valid on function
functions with 'sret' argument must return void
invalid forward reference to function as global value!
invalid forward reference to function '
' with wrong type!
invalid redefinition of function '
redefinition of function '@
type of definition and forward reference of '@
' disagree
redefinition of argument '%
expected '{' in function body
function body requires at least one basic block
unable to create block named '
expected '=' after instruction id
expected '=' after instruction name
found end of file when expecting more instructions
expected instruction opcode
expected fcmp predicate (e.g. 'oeq')
expected icmp predicate (e.g. 'eq')
value doesn't match function result type '
branch condition must have 'i1' type
expected ',' after branch condition
expected ',' after true destination
expected ',' after switch condition
expected '[' with switch table
switch condition must have integer type
expected ',' after case value
duplicate case value in switch
case value is not a constant integer
expected ',' after indirectbr address
expected '[' with indirectbr
indirectbr address must have pointer type
expected ']' at end of block list
expected 'to' in invoke
expected 'unwind' in invoke
Invalid result type for LLVM function
too many arguments specified
argument is not of expected type '
not enough parameters specified for call
invoke instructions may not have an alignment
expected '[' in catchpad/cleanuppad
expected 'from' after cleanupret
expected 'unwind' in cleanupret
expected 'caller' in cleanupret
expected 'from' after catchret
expected 'to' in catchret
expected 'within' after catchswitch
expected scope value for catchswitch
expected '[' with catchswitch labels
expected ']' after catchswitch labels
expected 'unwind' after catchswitch scope
expected 'caller' in catchswitch
expected 'within' after catchpad
expected scope value for catchpad
expected 'within' after cleanuppad
expected scope value for cleanuppad
expected ',' in arithmetic operation
invalid operand type for instruction
expected ',' in logical operation
instruction requires integer or integer vector operands
expected ',' after compare value
icmp requires integer operands
expected 'to' after cast value
expected ',' after select condition
expected ',' after select value
expected ',' after vaarg operand
va_arg requires operand with first class type
expected ',' after extract value
expected ',' after insertelement value
expected ',' after shuffle mask
expected ',' after shuffle value
invalid shufflevector operands
expected '[' in phi value list
expected ']' in phi value list
phi node must have first class type
'catch' clause has an invalid type
'filter' clause has an invalid type
clause argument must be a constant
expected 'tail call', 'musttail call', or 'notail call'
fast-math-flags specified for call without floating-point scalar or vector return type
call instructions may not have an alignment
invalid type for alloca
element count must have integer type
expected comma after load's type
load operand must be a pointer to a first class type
atomic load must have explicit non-zero alignment
atomic load cannot use Release ordering
expected ',' after store operand
store operand must be a pointer
store operand must be a first class value
stored value and pointer type do not match
atomic store must have explicit non-zero alignment
atomic store cannot use Acquire ordering
expected ',' after cmpxchg address
expected ',' after cmpxchg cmp operand
cmpxchg cannot be unordered
cmpxchg failure argument shall be no stronger than the success argument
cmpxchg failure ordering cannot include release semantics
cmpxchg operand must be a pointer
compare value and pointer type do not match
new value and pointer type do not match
cmpxchg operand must be a first class value
expected binary operation in atomicrmw
expected ',' after atomicrmw address
atomicrmw cannot be unordered
atomicrmw operand must be a pointer
atomicrmw value and pointer type do not match
atomicrmw operand must be an integer
atomicrmw operand must be power-of-two byte-sized integer
fence cannot be unordered
fence cannot be monotonic
expected comma after insertvalue operand
value has no uses
value only has one use
wrong number of indexes, expected 
expected non-empty list of uselistorder indexes
expected '}' here
expected >= 2 uselistorder indexes
expected distinct uselistorder indexes in range [0, size)
expected uselistorder indexes to change the order
expected uselistorder directive
expected comma in uselistorder directive
expected comma in uselistorder_bb directive
expected function name in uselistorder_bb
invalid function forward reference in uselistorder_bb
invalid declaration in uselistorder_bb
invalid numeric label in uselistorder_bb
expected basic block name in uselistorder_bb
invalid basic block in uselistorder_bb
expected basic block in uselistorder_bb
expected ':' here
expected 'path' here
expected ',' here
expected 'hash' here
expected 'name' here
expected 'summary' here
expected 'typeTestRes' here
expected 'kind' here
unexpected TypeTestResolution kind
expected 'sizeM1BitWidth' here
expected ':'
expected optional TypeTestResolution field
expected 'wpdResolutions' here
expected 'offset' here
expected 'wpdRes' here
unexpected WholeProgramDevirtResolution kind
expected optional WholeProgramDevirtResolution field
expected 'byArg here
unexpected WholeProgramDevirtResolution::ByArg kind
expected optional whole program devirt field
expected 'args' here
expected name or guid tag
expected 'summaries' here
expected summary type
expected 'insts' here
expected optional function summary field
expected 'aliasee' here
expected ':' in funcFlags
expected '(' in funcFlags
expected function flag type
expected ')' in funcFlags
expected ':' in calls
expected '(' in calls
expected 'callee' in call
expected relbf
expected ')' in call
expected ')' in calls
invalid call edge hotness
expected ':' in refs
expected '(' in refs
expected ')' in refs
expected '(' in typeIdInfo
invalid typeIdInfo list type
expected ')' in typeIdInfo
expected 'guid' here
expected 'linkage' here
expected 'notEligibleToImport' here
expected 'live' here
expected 'dsoLocal' here
expected 'module' here
expected module ID
expected GV ID
expected type
expected field label here
column
scope
inlinedAt
invalid field '
field '
' cannot be specified more than once
value for '
' too large, limit is 
' cannot be null
header
operands
expected DWARF tag
invalid DWARF tag
' cannot be empty
count
lowerBound
expected signed integer
' too small, limit is 
value
isUnsigned
expected 'true' or 'false'
encoding
expected DWARF type attribute encoding
invalid DWARF type attribute encoding
baseType
extraData
dwarfAddressSpace
expected debug info flag
invalid debug info flag flag '
elements
runtimeLang
vtableHolder
templateParams
identifier
discriminator
expected DWARF language
invalid DWARF language
types
expected DWARF calling convention
invalid DWARF calling convention
filename
directory
checksumkind
checksum
source
invalid checksum kind
language
producer
isOptimized
runtimeVersion
splitDebugFilename
emissionKind
enums
retainedTypes
globals
imports
macros
dwoId
splitDebugInlining
debugInfoForProfiling
gnuPubnames
expected emission kind
invalid emission kind
linkageName
isLocal
isDefinition
scopeLine
containingType
virtuality
virtualIndex
thisAdjustment
unit
declaration
retainedNodes
thrownTypes
expected DWARF virtuality code
invalid DWARF virtuality code
exportSymbols
expected DWARF macinfo type
invalid DWARF macinfo type
configMacros
includePath
isysroot
expr
setter
getter
entity
print-summary-global-ids
Print the global id for each value when reading the module summary
Expected a single module
llvm.bitcode
Corrupted bitcode
Abbreviation starts with an Array or a Blob
Array element type can't be an Array or a Blob
Array op not second to last
Array element type has to be an encoding of a type
Fixed or VBR abbrev record with size > MaxChunkData
Abbrev record with no operands
Invalid abbrev number
abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._
import-full-type-definitions
Import full type definitions for ThinLTO.
disable-ondemand-mds-loading
Force disable the lazy-loading on-demand of metadata when loading bitcode for importing.
Corrupted Metadata block
Invalid metadata: fwd refs into function blocks
Invalid record: metadata strings layout
Invalid record: metadata strings with no strings
Invalid record: metadata strings corrupt offset
Invalid record: metadata strings bad length
Invalid record: metadata strings truncated chars
Invalid metadata attachment
Conflicting METADATA_KIND records
METADATA_NAME not followed by METADATA_NAMED_NODE
Invalid record: Unsupported version of DISubrange
Alignment value is too large
Can't lazyload MD
Type mismatch in constant table!
llvm.global_ctors
llvm.global_dtors
Linking globals named '
': can only link appending global with another appending global!
Appending variables with different element types!
Appending variables linked with different const'ness!
Appending variables with different alignment need to be linked!
Appending variables with different visibility need to be linked!
Appending variables with different unnamed_addr need to be linked!
Appending variables with different section name need to be linked!
Linking two modules of different data layouts: '
' is '
' whereas '
Linking two modules of different target triples: 
.text
.balign 2
.thumb
.text
.balign 4
.arm
linking module flags '
': IDs have conflicting override values
': IDs have conflicting behaviors
': IDs have conflicting values
': does not have the required value
Linking COMDATs named '
': invalid selection kinds!
': noduplicates has been violated!
': ExactMatch violated!
': SameSize violated!
': COMDAT key involves incomputable alias size.
': GlobalVariable required for data dependent selection!
': symbol multiply defined!
Allocation failed
DFSIn: 
 DFSOut: 
Abstract Scope
Children ...
live-debug-variables
Enable the live debug variables pass
Allocation failed
********** DEBUG VARIABLES **********
 ind
 Loc
 @[ 
use-segment-set-for-physregs
Use segment set for the computation of the live ranges of physregs.
********** MACHINEINSTRS **********
EMPTY
-phi
 weight:
Clean updater: 
Null updater.
 updater with gap = 
, last start = 
  Area 1:
  Spills:
  Area 2:
%08X
  Alive in blocks: 
  Killed by:
 No instructions.
    #
regalloc=... not currently supported with -O0
Live Variable Analysis
livevars
Can't print out MachineBasicBlock because parent MachineFunction
 is null
<ir-block badref>
%ir-block.
address-taken
landing-pad
align 
; predecessors: 
successors: 
0x%08x
%.2f%%
liveins: 
; Irreducible loop header weight: 
%bb.
%08X
view-machine-block-freq-propagation-dags
Pop up a window to show a dag displaying how machine block frequencies propagate through the CFG.
do not display graphs.
fraction
display a graph using the fractional block frequency representation.
integer
display a graph using the raw integer fractional block frequency representation.
display a graph using the real profile count if available.
view-block-layout-with-bfi
Pop up a window to show a dag displaying MBP layout and associated block frequencies of the CFG.
print-machine-bfi
Print the machine block frequency info.
static-likely-prob
branch probability threshold in percentageto be considered very likely
profile-likely-prob
branch probability threshold in percentage to be considered very likely when profile is available
verify-machine-dom-info
Verify machine dominator info (time consuming)
=============================--------------------------------
Inorder Dominator Tree: 
DFSNumbers invalid: 
 slow queries.
cl::location(x) specified more than once!
 <<exit node>>
Frame Objects:
  fi#
dead
variable sized
size=
, align=
, fixed
, at location [SP
align-all-functions
Force the alignment of all functions.
no-realign-stack
# Machine code for function 
Function Live Ins: 
 in 
# End machine code for function 
Jump Tables:
Constant Pool:
  cp#
FailedISel
IsSSA
Legalized
NoPHIs
NoVRegs
RegBankSelected
Selected
TracksLiveness
Allocation failed
%jump-table.
MachineFunction Printer
frame-setup 
frame-destroy 
nnan 
ninf 
nsz 
arcp 
contract 
afn 
reassoc 
UNKNOWN
 [sideeffect]
 [mayload]
 [maystore]
 [isconvergent]
 [alignstack]
 [attdialect]
 [inteldialect]
:[reguse
:[regdef
:[regdef-ec
:[clobber
:[imm
:[mem
:[??
 tiedto:$
 debug-location 
 :: 
 line no:
 indirect
Loop at depth 
 containing: 
<header>
<latch>
<exiting>
print-regmask-num-regs
Number of registers to limit to when printing regmask operands in IR dumps. unlimited = -1
%subreg.
target-flags(
<unknown>) 
<unknown target flag>
<unknown bitmask target flag>
<mcsymbol 
%fixed-stack.
%stack.
<badref>
implicit-def 
implicit 
def 
internal 
dead 
killed 
undef 
early-clobber 
debug-use 
renamable 
.subreg
(tied-def 
%const.
target-index(
<unknown>
blockaddress(
<regmask
 and 
 more...
 ...
liveout(
<cfi directive>
intrinsic(@
intrinsic(
pred(
volatile 
non-temporal 
dereferenceable 
invariant 
load 
store 
 on 
 from 
 into 
stack
jump-table
constant-pool
call-entry 
call-entry &
custom 
, align 
, !tbaa 
, !alias.scope 
, !noalias 
, !range 
, addrspace 
same_value 
remember_state 
restore_state 
offset 
def_cfa_register 
def_cfa_offset 
def_cfa 
rel_offset 
adjust_cfa_offset 
restore 
escape 
0x%02x
undefined 
register 
window_save 
<unserializable cfi directive>
%dwarfreg.
<badreg>
syncscope("
not_atomic
consume
%ir.
enable-subreg-liveness
Enable subregister liveness tracking.
TargetCustom
FixedStack
Stack
JumpTable
ConstantPool
GlobalValueCallEntry
ExternalSymbolCallEntry
stress-regalloc
Limit all regclasses to N registers
join-liveintervals
Coalesce copies (default=true)
terminal-rule
Apply the terminal rule
join-splitedges
Coalesce copies on split edges (default=subtarget)
join-globalcopies
Coalesce copies that span blocks (default=subtarget)
verify-coalescing
Verify machine instrs before and after register coalescing
Data
Anti
Out 
Ord 
 Latency=
 Reg=
 Barrier
 Memory
 Artificial
 Weak
 Cluster
EntrySU
ExitSU
  # preds left       : 
  # succs left       : 
  # weak preds left  : 
  # weak succs left  : 
  # rdefs left       : 
  Latency            : 
  Depth              : 
  Height             : 
  Predecessors:
  Successors:
Scoreboard:
%bb.
Berd
invalid
stackmap-version
Specify the stackmap encoding version (default = 3)
disable-sched-hazard
Disable hazard detection during preRA scheduling
$noreg
physreg
:sub(
schedmodel
Use TargetSchedModel for latency lookup
scheditins
Use InstrItineraryData for latency lookup
Remove unreachable machine basic blocks
unreachable-mbb-elimination
i128
f128
ppcf128
isVoid
glue
x86mmx
v1i1
v2i1
v4i1
v8i1
v16i1
v32i1
v64i1
v128i1
v512i1
v1024i1
v1i8
v2i8
v4i8
v8i8
v16i8
v32i8
v64i8
v128i8
v256i8
v1i16
v2i16
v4i16
v8i16
v16i16
v32i16
v64i16
v128i16
v1i32
v2i32
v4i32
v8i32
v16i32
v32i32
v64i32
v1i64
v2i64
v4i64
v8i64
v16i64
v32i64
v1i128
v1f32
v2f32
v2f16
v4f16
v8f16
v4f32
v8f32
v16f32
v1f64
v2f64
v4f64
v8f64
Metadata
Untyped
ExceptRef
disable-demotion
Clone multicolor basic blocks but do not demote cross scopes
disable-cleanups
Do not remove implausible terminators or other similar cleanups
demote-catchswitch-only
Demote catchswitch BBs only (for wasm EH)
adce-remove-control-flow
adce-remove-loops
adce
Aggressive Dead Code Elimination
callsite-splitting-duplication-threshold
Only allow instructions before a call, if their cost is below DuplicationThreshold
consthoist-with-block-frequency
Enable the use of the block frequency analysis to reduce the chance to execute const materialization more frequently than without hoisting.
Simple constant propagation
constprop
cvp-dont-process-adds
Value Propagation
correlated-propagation
.lhs.trunc
.rhs.trunc
Dead Code Elimination
enable-dse-partial-overwrite-tracking
Enable partial-overwrite tracking in DSE
enable-dse-partial-store-merging
Enable partial store merging in DSE
Dead Store Elimination
early-cse
Controls which instructions are removed
Early CSE
Early CSE w/ MemorySSA
early-cse-memssa
float2int-max-integer-bw
Max integer bitwidth to consider in float2int(default=64)
Base: 
 Offset: 
 Length: 
enable-pre
enable-load-pre
max-recurse-depth
Max recurse depth (default = 1000)
.pre
.pre-phi
LoadClobbered
load of type 
 not eliminated
 in favor of 
OtherAccess
 because it is clobbered by 
ClobberedBy
LoadElim
 eliminated
InfavorOfValue
Global Value Numbering
LoadPRE
load eliminated by PRE
gvn-max-hoisted
Max number of instructions to hoist (default unlimited = -1)
gvn-hoist-max-bbs
Max number of basic blocks on the path between hoisting locations (default = 4, unlimited = -1)
gvn-hoist-max-depth
Hoist instructions from the beginning of the BB up to the maximum specified depth (default = 100, unlimited = -1)
gvn-hoist-max-chain-length
Maximum length of dependent chains to hoist (default = 10, unlimited = -1)
.sink
irce-loop-size-cutoff
irce-print-changed-loops
irce-print-range-checks
irce-max-exit-prob-reciprocal
irce-skip-profitability-checks
irce-allow-unsigned-latch
InductiveRangeCheck:
  Kind: 
  Begin: 
  Step: 
  End: 
  CheckUse: 
 Operand: 
RANGE_CHECK_UNKNOWN
RANGE_CHECK_UPPER
RANGE_CHECK_LOWER
RANGE_CHECK_BOTH
llvm.loop.unroll.disable
verify-indvars
Verify the ScalarEvolution result after running indvars
replexitval
Choose the strategy to replace exit value in IndVarSimplify
never
never replace exit value
cheap
only replace exit value when the cost is cheap
always
always replace exit value whenever possible
indvars-post-increment-ranges
Use post increment control-dependent ranges in IndVarSimplify
disable-lftr
Disable Linear Function Test Replace optimization
.int
Remove redundant instructions
instsimplify
jump-threading-threshold
Max block size to duplicate for jump threading
jump-threading-implication-search-threshold
The number of predecessors to search for a stronger condition to use to thread over a weaker condition
print-lvi-after-jump-threading
Print the LazyValueInfo cache after JumpThreading
thread-pre-split
.thr_comm
.thread
.split-lp
select.unfold
Jump Threading
jump-threading
LVI for function '
disable-licm-promotion
Disable memory promotion in LICM pass
licm-max-num-uses-traversed
Max num uses visited for identifying load invariance in loop using invariant start (default = 8)
.promoted
Loop Invariant Code Motion
licm
InstSunk
Inst
.split.loop.exit
funclet
.lcssa
Hoisted
hoisting 
LoadWithLoopInvariantAddressCondExecuted
failed to hoist load with loop-invariant address because load is conditionally executed
LoadWithLoopInvariantAddressInvalidated
failed to move load with loop-invariant address because the loop may invalidate its value
PromoteLoopAccessesToScalar
Moving accesses to memory location out of the loop
sink-freq-percent-threshold
Do not sink instructions that require cloning unless they execute less than this percent of the time.
max-uses-for-sinking
Do not sink instructions that have too many uses.
Delete dead loops
loop-deletion
loop-prefetch-writes
Prefetch write addresses
prefetch-distance
Number of instructions to prefetch ahead
min-prefetch-stride
Min stride to add prefetches
max-prefetch-iters-ahead
Max number of iterations to prefetch ahead
loop-distribute-verify
Turn on DominatorTree and LoopInfo verification after Loop Distribution
loop-distribute-non-if-convertible
Whether to distribute into a loop that may not be if-convertible by the loop vectorizer
loop-distribute-scev-check-threshold
The maximum number of SCEV checks allowed for Loop Distribution
loop-distribute-scev-check-threshold-with-pragma
The maximum number of SCEV checks allowed for Loop Distribution for loop marked with #pragma loop distribute(enable)
enable-loop-distribute
Enable the new, experimental LoopDistribution Pass
use-lir-code-size-heurs
Use loop idiom recognition code size heuristics when compilingwith -Os/-Oz
memset_pattern16
loop-interchange-threshold
Interchange if you gain more than this number
runtime-check-per-loop-load-elim
Max number of memchecks allowed per eliminated load on average
loop-load-elimination-scev-check-threshold
The maximum number of SCEV checks allowed for Loop Load Elimination
loop-predication-enable-iv-truncation
loop-predication-enable-count-down-loop
loop-predication-skip-profitability-checks
loop-predication-latch-probability-scale
scale factor for the latch probability. Value should be greater than 1. Lower values are ignored
reroll-num-tolerated-failed-matches
The maximum number of failures to tolerate during fuzzy matching. (default: 400)
rotation-max-header-size
The default maximum header size for automatic loop rotation
Rotate Loops
loop-rotate
enable-lsr-phielim
Enable LSR phi elimination
lsr-insns-cost
Add instruction count to a LSR cost model
lsr-exp-narrow
Narrow LSR complex solution using expectation of registers number
lsr-filter-same-scaled-reg
Narrow LSR search space by filtering non-optimal formulae with the same ScaledReg and Scale
[NumUses=
reg(
**error: HasBaseReg**
**error: !HasBaseReg**
*reg(
imm(
 instruction
 reg
, with addrec cost 
, plus 
 IV mul
 base add
 scale cost
 imm cost
 setup cost
UserInst=
, OperandValToReplace=
, PostIncLoop=
, Offset=
LSR Use: Kind=
Basic
Special
ICmpZero
Address of 
pointer
 in addrspace(
, Offsets={
, all-fixups-outside-loop
, widest fixup type: 
in formulae referencing 
 in use 
 , add offset 
LSR has identified the following interesting factors and types: 
LSR is examining the following fixup sites:
LSR is examining the following uses:
unroll-threshold
The cost threshold for loop unrolling
unroll-partial-threshold
The cost threshold for partial loop unrolling
unroll-max-percent-threshold-boost
The maximum 'boost' (represented as a percentage >= 100) applied to the threshold when aggressively unrolling a loop due to the dynamic cost savings. If completely unrolling a loop will reduce the total runtime from X to Y, we boost the loop unroll threshold to DefaultThreshold*std::min(MaxPercentThresholdBoost, X/Y). This limit avoids excessive code bloat.
unroll-max-iteration-count-to-analyze
Don't allow loop unrolling to simulate more than this number ofiterations when checking full unroll profitability
unroll-count
Use this unroll count for all loops including those with unroll_count pragma values, for testing purposes
unroll-max-count
Set the max unroll count for partial and runtime unrolling, fortesting purposes
unroll-full-max-count
Set the max unroll count for full unrolling, for testing purposes
unroll-peel-count
Set the unroll peeling count, for testing purposes
unroll-allow-partial
Allows loops to be partially unrolled until -unroll-threshold loop size is reached.
unroll-allow-remainder
Allow generation of a loop remainder (extra iterations) when unrolling a loop.
unroll-runtime
Unroll loops with run-time trip counts
unroll-max-upperbound
The max of trip count upper bound that is considered in unrolling
pragma-unroll-threshold
Unrolled size limit for loops with an unroll(full) or unroll_count pragma.
flat-loop-tripcount-threshold
If the runtime tripcount for the loop is lower than the threshold, the loop is considered as flat and will be less aggressively unrolled.
unroll-allow-peeling
Allows loops to be peeled when the dynamic trip count is known to be low.
unroll-remainder
Allow the loop remainder to be unrolled.
unroll-revisit-child-loops
Enqueue and re-visit child loops in the loop PM after unrolling. This shouldn't typically be needed as child loops (or their clones) were already visited.
llvm.loop.unroll.count
llvm.loop.unroll.runtime.disable
Unroll loops
loop-unroll
UnrollAsDirectedTooLarge
Unable to unroll loop as directed by unroll(enable) pragma because unrolled size is too large.
FullUnrollAsDirectedTooLarge
Unable to fully unroll loop as directed by unroll pragma because unrolled size is too large.
CantFullUnrollAsDirectedRuntimeTripCount
Unable to fully unroll loop as directed by unroll(full) pragma because loop has a runtime trip count.
DifferentUnrollCountFromDirected
Unable to unroll loop the number of times directed by unroll_count pragma because remainder loop is restricted (that could architecture specific or because the loop contains a convergent instruction) and so must have an unroll count that divides the loop trip multiple of 
TripMultiple
.  Unrolling instead 
UnrollCount
 time(s).
allow-unroll-and-jam
Allows loops to be unroll-and-jammed.
unroll-and-jam-count
Use this unroll count for all loops including those with unroll_and_jam_count pragma values, for testing purposes
unroll-and-jam-threshold
Threshold to use for inner loop when doing unroll and jam.
pragma-unroll-and-jam-threshold
Unrolled size limit for loops with an unroll_and_jam(full) or unroll_count pragma.
loop-unswitch-threshold
Max loop size to unswitch
licm-versioning-invariant-threshold
LoopVersioningLICM's minimum allowed percentageof possible invariant instructions per loop
licm-versioning-max-depth-threshold
LoopVersioningLICM's threshold for maximum allowed loop nest/depth
llvm.mem.parallel_loop_access
likely-branch-weight
Weight of the branch likely to be taken (default = 2000)
unlikely-branch-weight
Weight of the branch unlikely to be taken (default = 1)
guards-predicate-pass-branch-weight
The probability of a guard failing is assumed to be the reciprocal of this value (default = 1 << 20)
MemCpy Optimization
memcpyopt
newgvn-vn
Controls which instructions are value numbered
newgvn-phi
Controls which instructions we create phi of ops for
enable-store-refinement
enable-phi-of-ops
spp-all-backedges
spp-counted-loop-trip-width
spp-split-backedge
spp-no-entry
spp-no-call
spp-no-backedge
spp-print-liveset
spp-print-liveset-size
spp-print-base-pointers
spp-rematerialization-threshold
rs4gc-clobber-non-live
rs4gc-allow-statepoint-with-no-deopt-info
nullptr
__llvm_deoptimize
Sparse Conditional Constant Propagation
sccp
sroa-random-shuffle-slices
sroa-strict-inbounds
Can't analyze slices for alloca: 
  A pointer to this alloca escaped by:
Slices of alloca: 
.sroa.
 slice #
 (splittable)
  used by: 
sroa_raw_cast
sroa_raw_idx
sroa_cast
sroa_idx
sroa
load.ext
endian_shift
insert
.shift
.ext
.insert
load.trunc
.expand
blend
oldload
copyload
isplat
vsplat
.fca
.gep
.load
.sroa.speculated
.sroa.speculate.load.
.sroa.speculate.load.true
.sroa.speculate.load.false
SROA
Scalar Replacement Of Aggregates
disable-separate-const-offset-from-gep
Do not separate the constant offset from a GEP instruction
reassociate-geps-verify-no-dead-code
Verify this pass produces no dead code
uglygep
enable-nontrivial-unswitch
Forcibly enables non-trivial loop unswitching rather than following the configuration passed into the pass.
unswitch-threshold
The cost threshold for unswitching a loop.
.split
bonus-inst-threshold
Control the number of bonus instructions (default = 1)
keep-loops
Preserve canonical loop structure (default = true)
switch-to-lookup
Convert switches to lookup tables (default = false)
forward-switch-cond
Forward switch condition to phi ops (default = false)
sink-common-insts
Sink common instructions (default = false)
merge
simplifycfg
Simplify the CFG
spec-exec-max-speculation-cost
Speculative execution is not applied to basic blocks where the cost of the instructions to speculatively execute exceeds this limit.
spec-exec-max-not-hoisted
Speculative execution is not applied to basic blocks where the number of instructions that would not be speculatively executed exceeds this limit.
spec-exec-only-if-divergent-target
Speculative execution is applied only to targets with divergent branches, even if the pass was configured to apply only to all targets.
structurizecfg-skip-uniform-regions
Force whether the StructurizeCFG pass skips uniform regions
lpad
lpad.phi
_crit_edge
Break critical edges in CFG
break-crit-edges
cstr
strlen
strchr
strncmp
strncpy
__memcpy_chk
memchr
memcmp
putchar
chari
puts
fputc
fputc_unlocked
fputs
fputs_unlocked
malloc
calloc
fgetc_unlocked
fgets_unlocked
enable-noalias-to-md-conversion
Convert noalias attributes to metadata during inlining.
preserve-alignment-assumptions-during-inlining
Convert align attributes to assumptions during inlining.
deopt
savedstack
.exit
ptrint
maskedptr
maskcond
: argument 
.lpad-body
eh.lpad-body
thinlto_src_module
------- Dumping inliner stats for [
] -------
-- List of inlined functions:
Inlined 
imported 
not imported 
function [
: #inlines = 
, #inlines_to_importing_module = 
-- Summary:
All functions: 
, imported functions: 
inlined functions
all functions
imported functions inlined anywhere
imported functions
imported functions inlined into importing module
, remaining
non-imported functions inlined anywhere
non-imported functions
non-imported functions inlined into importing module
% of 
verify-loop-lcssa
Verify loop lcssa form (time consuming)
lcssa
Loop-Closed SSA Form Pass
cond
.noexc
.lr.ph
.preheader
.outer
loop-simplify
Canonicalize natural loops
unroll-runtime-epilog
Allow runtime unrolled loops to be unrolled with epilog instead of prolog.
unroll-verify-domtree
Verify domtree after unrolling
FullyUnrolled
completely unrolled loop with 
 iterations
Peeled
 peeled loop by 
PeelCount
 with a breakout at trip 
BreakoutTrip
PartialUnrolled
unrolled loop by a factor of 
 trips per branch
 with run-time trip count
unroll-peel-max-count
Max average trip count which will cause loop peeling.
unroll-force-peel-count
Force a peel count regardless of profiling information.
.peel.begin
.peel.next
.peel.newph
.peel
unroll-runtime-multi-exit
Allow runtime unrolling for loops with multiple exits, when epilog is generated
.new
.unr-lcssa
.epil.preheader
.prol.preheader
.prol.loopexit
xtraiter
lcmp.mod
unroll_iter
niter
.nsub
.ncmp
epil
prol
.iter
.cmp
.unr
.epilog-lcssa
.loopexit
loop-version-annotate-no-alias
Add no-alias annotation for instructions that are disambiguated by memchecks
Lower SwitchInst's to branches
lowerswitch
NewDefault
NodeBlock
Pivot
LeafBlock
SwitchLeaf
mem2reg
Promote Memory to Register
verify-predicateinfo
Verify PredicateInfo in legacy printer pass.
predicateinfo-rename
Controls which variables are renamed with predicateinfo
phi-node-folding-threshold
Control the amount of phi node folding to perform (default = 2)
simplifycfg-dup-ret
Duplicate return instructions into unconditional branches
simplifycfg-sink-common
Sink common instructions down to the end block
simplifycfg-hoist-cond-stores
Hoist conditional stores if an unconditional store precedes
simplifycfg-merge-cond-stores
Hoist conditional stores even if an unconditional store does not precede - hoist multiple conditional stores into a single predicated store
simplifycfg-merge-cond-stores-aggressively
When merging conditional stores, do so even if the resultant basic blocks are unlikely to be if-converted as a result
speculate-one-expensive-inst
Allow exactly one expensive instruction to be speculatively executed
max-speculation-depth
Limit maximum recursion depth when calculating costs of speculatively executed instructions
.old
or.cond
not.cond
and.cond
.sink.split
switch.edge
.fold.split
magicptr
infloop
switch.early.test
spec.store.select
spec.select
.critedge
brmerge
.mux
condstore.split
simplifycfg.merge
switch.selectcmp
switch.select
no-jump-tables
switch.lookup
switch.tableidx
switch.hole_check
switch.maskindex
switch.shifted
switch.lobit
switch.table.
switch.idx.cast
switch.idx.mult
switch.offset
switch.cast
switch.shiftamt
switch.downshift
switch.masked
switch.tableidx.zext
switch.gep
switch.load
inverted.cmp
indvars
iv.rem
.urem
.udiv
enable-double-float-shrink
Enable unsafe double to float shrinking for math lib calls
endptr
strchr
strrchr
strcmpload
strlenfirst
strpbrk
strstr
memchr.bounds
memchr.bits
memchr
lhsc
lhsv
rhsc
rhsv
chardiff
memcmp
real
imag
cabs
reciprocal
square
isinf
log2
log10
logmul
tanf
tanl
cttz
ctlz
isdigittmp
isdigit
isascii
iprintf
leninc
siprintf
fiprintf
__sincospif_stret
__sincospi_stret
sincospi
sinpi
cospi
instcombine
simplify-libcalls
folded strlen(select) to select of constants
disable-basicaa
NoAlias
MustAlias
MayAlias
PartialAlias
External Alias Analysis
external-aa
Function Alias Analysis Results
alias-set-saturation-threshold
The maximum number of pointers may-alias sets may contain before degradation
  AliasSet[
must
 alias, 
No access 
Ref       
Mod       
Mod/Ref   
[volatile] 
 forwarding to 
Pointers: 
    
 Unknown instructions: 
Alias Set Tracker: 
 alias sets for 
 pointer values.
verify-assumption-cache
Enable verification of assumption cache
Assumption in scanned function not in cache
Assumption Cache Tracker
assumption-cache-tracker
basicaa-recphi
basicaa
Basic Alias Analysis (stateless AA impl)
view-block-freq-propagation-dags
Pop up a window to show a dag displaying how block frequencies propagation through the CFG.
view-bfi-func-name
The option to specify the name of the function whose CFG will be displayed.
view-hot-freq-percent
An integer in percent used to specify the hot blocks/edges to be displayed in red: a block or edge whose frequency is no less than the max frequency of the function multiplied by this percent.
pgo-view-counts
A boolean option to show CFG dag or text with block profile counts and branch probabilities right after PGO profile annotation step. The profile counts are computed using branch probabilities from the runtime profile data and block frequency propagation algorithm. To view the raw counts from the profile, use option -pgo-view-raw-counts instead. To limit graph display to only one function, use filtering option -view-bfi-func-name.
do not show.
graph
show a graph.
text
show in text.
print-bfi
Print the block frequency info.
print-bfi-func-name
The option to specify the name of the function whose block frequency info is printed.
BlockFrequencyDAGs
block-frequency-info: 
: float = 
, int = 
, count = 
, irr_loop_header_weight = 
Block Frequency Analysis
block-freq
error opening file '
' for writing!
 done. 
digraph "
digraph unnamed {
label="
Node
 [shape=record,
label="{
}"];
color="red"
Unknown
 -> Node
label="%.1f%%"
,color="red"
print-bpi
Print the branch probability info.
print-bpi-func-name
The option to specify the name of the function whose branch probability info is printed.
---- Branch Probabilities ----
edge 
 probability is 
 [HOT edge]
Branch Probability Analysis
branch-prob
Inclusion-Based CFL Alias Analysis
cfl-anders-aa
Unification-Based CFL Alias Analysis
cfl-steens-aa
Invalidating all non-preserved analyses for: 
Invalidating analysis: 
Call graph node for function: '
Call graph node <<null function>>
>>  #uses=
  CS<
> calls 
function '
external node
No call graph has been built!
CallGraph Construction
basiccg
max-cg-scc-iterations
CallGraph Pass Manager
Call Graph SCC Pass Manager
size-info
Print CallGraph IR
Printing <null> Function
acos
asin
atan
atan2
acosf
asinf
atanf
atan2f
cosh
ceilf
coshf
expf
fmod
fmodf
logf
log10f
roundf
sinh
sinhf
tanh
tanhf
__acos_finite
__acosf_finite
__asin_finite
__asinf_finite
__atan2_finite
__atan2f_finite
__cosh_finite
__coshf_finite
__exp_finite
__expf_finite
__exp2_finite
__exp2f_finite
__log_finite
__logf_finite
__log10_finite
__log10f_finite
__pow_finite
__powf_finite
__sinh_finite
__sinhf_finite
da-delinearize
Try to delinearize array references.
 Empty
 Any
 Point is <
 Distance is 
*X + 
*Y = 
 Line is 
enable-unsafe-globalsmodref-alias-results
Globals Alias Analysis
globals-aa
IV Users for loop 
 with backedge-taken count 
 (post-inc with loop 
 in  
Printing <null> User
icp-remaining-percent-threshold
The percentage threshold against remaining unpromoted indirect call count for the promotion
icp-total-percent-threshold
The percentage threshold against total count for the promotion
icp-max-prom
Max number of promotions for a single indirect call callsite
inline-threshold
Control the amount of inlining to perform (default = 225)
inlinehint-threshold
Threshold for inlining functions with inline hint
inline-cold-callsite-threshold
Threshold for inlining cold callsites
inlinecold-threshold
Threshold for inlining functions with cold attribute
hot-callsite-threshold
Threshold for hot callsites 
locally-hot-callsite-threshold
Threshold for locally hot callsites 
cold-callsite-rel-freq
Maxmimum block frequency, expressed as a percentage of caller's entry frequency, for a callsite to be cold in the absence of profile information.
hot-callsite-rel-freq
Minimum block frequency, expressed as a multiple of caller's entry frequency, for a callsite to be hot in the absence of profile information.
inline-cost-full
Compute the full inline cost of a call site even when the cost exceeds the threshold.
      NumConstantArgs: 
      NumConstantOffsetPtrArgs: 
      NumAllocaArgs: 
      NumConstantPtrCmps: 
      NumConstantPtrDiffs: 
      NumInstructionsSimplified: 
      NumInstructions: 
      SROACostSavings: 
      SROACostSavingsLost: 
      LoadEliminationCost: 
      ContainsNoDuplicateCall: 
      Cost: 
      Threshold: 
inline-cost
 has uninlinable pattern and cost is not fully computed
 is recursive and allocates too much stack space. Cost is not fully computed
Lazy Branch Probability Analysis
lazy-branch-prob
Lazy Block Frequency Analysis
lazy-block-freq
Lazy Value Information Analysis
lazy-value-info
; LatticeVal for: '
' is: 
' in BB: '
available-load-scan-limit
Use this to specify the default maximum number of instructions to scan backward from a given instruction, when searching for available loaded value
force-vector-width
Sets the SIMD width. Zero is autoselect.
force-vector-interleave
Sets the vectorization interleave count. Zero is autoselect.
runtime-memory-check-threshold
When performing memory disambiguation checks at runtime do not generate more than this number of comparisons (default = 8).
memory-check-merge-threshold
Maximum number of comparisons done when trying to merge runtime memory checks. (default = 100)
max-dependences
Maximum number of dependences collected by loop-access analysis (default = 100)
enable-mem-access-versioning
Enable symbolic stride memory access versioning
store-to-load-forwarding-conflict-detection
Enable conflict detection in loop-access analysis
enable-mssa-loop-dependency
Enable MemorySSA dependency for loop pass manager
<unnamed loop>
verify-loop-info
Verify loop info (time consuming)
 (loop: 
; Preheader:
; Loop:
Printing <null> block
; Exit blocks
Natural Loop Information
loops
<deleted loop>
<deleted>
Loop Pass Manager
Print Loop IR
LCSSA Verifier
lcssa-verification
Loop Pass Manager
memdep-block-scan-limit
The number of instructions to scan in a block in memory dependency analysis (default = 100)
memdep-block-number-limit
The number of blocks to scan during memory dependency analysis (default = 1000)
memdep
Memory Dependence Analysis
memssa-check-limit
The maximum number of stores/phis MemorySSAwill consider trying to walk past (default = 100)
verify-memoryssa
Verify MemorySSA in legacy printer pass.
 = MemoryDef(
 = MemoryPhi(
MemoryUse(
Memory SSA
memoryssa
force-summary-edges-cold
Force all edges in the function summary to cold
None.
all-non-critical
All non-critical edges.
All edges.
llvm.compiler.used
Module Summary Analysis
module-summary-analysis
ObjC-ARC-Based Alias Analysis
objc-arc-aa
enable-objc-arc-opts
enable/disable all ARC Optimizations
opt-remark-emitter
PHITransAddr: null
PHITransAddr: 
  Input #
 is 
.phi.trans.insert
Phi Values Analysis
phi-values
Post-Dominator Tree Construction
postdomtree
profile-summary-cutoff-hot
A count is hot if it exceeds the minimum count to reach this percentile of total counts.
profile-summary-cutoff-cold
A count is cold if it is below the minimum count to reach this percentile of total counts.
profile-sample-accurate
If the sample profile is accurate, we will mark all un-sampled callsite as cold. Otherwise, treat un-sampled callsites as if we have no profile.
profile-summary-huge-working-set-size-threshold
The code working set size is considered huge if the number of blocks required to reach the -profile-summary-cutoff-hot percentile exceeds this count.
Desired percentile exceeds the maximum cutoff
Profile summary info
profile-summary-info
<Function Return>
Region tree:
End region tree
verify-region-info
Verify region info (time consuming)
print-region-style
style of printing regions
print no details
print regions in detail with block_iterator
print regions in detail with element_iterator
scalar-evolution-max-iterations
Maximum number of iterations SCEV will symbolically execute a constant derived loop
verify-scev
Verify ScalarEvolution's backedge taken counts (slow)
verify-scev-maps
Verify no dangling value in ScalarEvolution's ExprValueMap (slow)
scev-mulops-inline-threshold
Threshold for inlining multiplication operands into a SCEV
scev-addops-inline-threshold
Threshold for inlining addition operands into a SCEV
scalar-evolution-max-scev-compare-depth
Maximum depth of recursive SCEV complexity comparisons
scalar-evolution-max-scev-operations-implication-depth
Maximum depth of recursive SCEV operations implication analysis
scalar-evolution-max-value-compare-depth
Maximum depth of recursive value complexity comparisons
scalar-evolution-max-arith-depth
Maximum depth of recursive arithmetics
scalar-evolution-max-constant-evolving-depth
Maximum depth of recursive constant evolving
scalar-evolution-max-cast-depth
Maximum depth of recursive SExt/ZExt/Trunc
scalar-evolution-max-add-rec-size
Max coefficients in AddRec during evolving
(trunc 
(zext 
(sext 
nuw><
nsw><
nw><
 umax 
 smax 
<nuw>
<nsw>
 /u 
sizeof(
alignof(
offsetof(
***COULDNOTCOMPUTE***
Classifying expressions for: 
  -->  
 U: 
 S: 
Exits: 
<<Unknown>>
LoopDispositions: { 
Determining loop execution counts for: 
Trip Count Changed!
Old: 
New: 
Delta: 
Equal predicate: 
 == 
 Added Flags: 
<nusw>
<nssw>
scalar-evolution
Variant
Invariant
Computable
Loop 
<multiple exits> 
backedge-taken count is 
Unpredictable backedge-taken count. 
Loop 
max backedge-taken count is 
, actual taken count either this or zero.
Unpredictable max backedge-taken count. 
Predicated backedge-taken count is 
 Predicates:
Unpredictable predicated backedge-taken count. 
Trip multiple is 
Scalar Evolution Analysis
ScalarEvolution-based Alias Analysis
scev-aa
scevgep
.iv.next
indvar
indvar.next
smax
vector-library
Vector functions library
No vector functions library
Accelerate
Accelerate framework
SVML
Intel SVML library
??2@YAPAXI@Z
??2@YAPAXIABUnothrow_t@std@@@Z
??2@YAPEAX_K@Z
??2@YAPEAX_KAEBUnothrow_t@std@@@Z
??3@YAXPAX@Z
??3@YAXPAXABUnothrow_t@std@@@Z
??3@YAXPAXI@Z
??3@YAXPEAX@Z
??3@YAXPEAXAEBUnothrow_t@std@@@Z
??3@YAXPEAX_K@Z
??_U@YAPAXI@Z
??_U@YAPAXIABUnothrow_t@std@@@Z
??_U@YAPEAX_K@Z
??_U@YAPEAX_KAEBUnothrow_t@std@@@Z
??_V@YAXPAX@Z
??_V@YAXPAXABUnothrow_t@std@@@Z
??_V@YAXPAXI@Z
??_V@YAXPEAX@Z
??_V@YAXPEAXAEBUnothrow_t@std@@@Z
??_V@YAXPEAX_K@Z
_IO_getc
_IO_putc
_ZdaPv
_ZdaPvRKSt9nothrow_t
_ZdaPvSt11align_val_t
_ZdaPvSt11align_val_tRKSt9nothrow_t
_ZdaPvj
_ZdaPvm
_ZdlPv
_ZdlPvRKSt9nothrow_t
_ZdlPvSt11align_val_t
_ZdlPvSt11align_val_tRKSt9nothrow_t
_ZdlPvj
_ZdlPvm
_Znaj
_ZnajRKSt9nothrow_t
_ZnajSt11align_val_t
_ZnajSt11align_val_tRKSt9nothrow_t
_Znam
_ZnamRKSt9nothrow_t
_ZnamSt11align_val_t
_ZnamSt11align_val_tRKSt9nothrow_t
_Znwj
_ZnwjRKSt9nothrow_t
_ZnwjSt11align_val_t
_ZnwjSt11align_val_tRKSt9nothrow_t
_Znwm
_ZnwmRKSt9nothrow_t
_ZnwmSt11align_val_t
_ZnwmSt11align_val_tRKSt9nothrow_t
__acosh_finite
__acoshf_finite
__acoshl_finite
__acosl_finite
__asinl_finite
__atan2l_finite
__atanh_finite
__atanhf_finite
__atanhl_finite
__coshl_finite
__cospi
__cospif
__cxa_atexit
__cxa_guard_abort
__cxa_guard_acquire
__cxa_guard_release
__exp10_finite
__exp10f_finite
__exp10l_finite
__exp2l_finite
__expl_finite
__isoc99_scanf
__isoc99_sscanf
__log10l_finite
__log2_finite
__log2f_finite
__log2l_finite
__logl_finite
__memmove_chk
__memset_chk
__nvvm_reflect
__powl_finite
__sinhl_finite
__sinpi
__sinpif
__sqrt_finite
__sqrtf_finite
__sqrtl_finite
__stpcpy_chk
__stpncpy_chk
__strcpy_chk
__strdup
__strncpy_chk
__strndup
__strtok_r
access
acosh
acoshf
acoshl
acosl
asinh
asinhf
asinhl
asinl
atan2l
atanh
atanhf
atanhl
atanl
atof
atoi
atol
atoll
bcmp
bcopy
bzero
cabsf
cabsl
calloc
cbrt
cbrtf
cbrtl
ceill
chmod
chown
clearerr
closedir
coshl
ctermid
exp10
exp10f
exp10l
expl
expm1
expm1f
expm1l
fclose
fdopen
feof
ferror
fflush
ffsll
fgetc
fgetc_unlocked
fgetpos
fgets
fgets_unlocked
fileno
flockfile
floorl
flsl
flsll
fmodl
fopen
fopen64
fprintf
fread
fread_unlocked
free
frexp
frexpf
frexpl
fscanf
fseek
fseeko
fseeko64
fsetpos
fstat
fstat64
fstatvfs
fstatvfs64
ftell
ftello
ftello64
ftrylockfile
funlockfile
fwrite
fwrite_unlocked
getc
getc_unlocked
getchar
getchar_unlocked
getenv
getitimer
getlogin_r
getpwnam
gets
gettimeofday
htonl
htons
lchown
ldexp
ldexpf
ldexpl
log10l
log1p
log1pf
log1pl
log2f
log2l
logb
logbf
logbl
logl
lstat
lstat64
malloc
memalign
memccpy
mempcpy
memrchr
mkdir
mktime
modf
modff
modfl
nearbyint
nearbyintf
nearbyintl
ntohl
ntohs
open
open64
opendir
pclose
perror
popen
posix_memalign
pread
putc
putc_unlocked
putchar_unlocked
puts
pwrite
qsort
readlink
realloc
reallocf
realpath
remove
rename
rewind
rint
rintf
rintl
rmdir
roundl
scanf
setbuf
setitimer
setvbuf
sinhl
snprintf
sprintf
sscanf
stat
stat64
statvfs
statvfs64
stpcpy
stpncpy
strcasecmp
strcat
strcmp
strcoll
strcpy
strcspn
strdup
strlen
strncasecmp
strncat
strncmp
strncpy
strndup
strnlen
strspn
strtod
strtof
strtok
strtok_r
strtol
strtold
strtoll
strtoul
strtoull
strxfrm
system
tanhl
times
tmpfile
tmpfile64
toascii
truncf
truncl
uname
ungetc
unlink
unsetenv
utime
utimes
valloc
vfprintf
vfscanf
vprintf
vscanf
vsnprintf
vsprintf
vsscanf
wcslen
vceilf
vfabsf
llvm.fabs.f32
vfloorf
vsqrtf
llvm.sqrt.f32
vexpf
llvm.exp.f32
vexpm1f
vlogf
llvm.log.f32
vlog1pf
vlog10f
llvm.log10.f32
vlogbf
vsinf
llvm.sin.f32
vcosf
llvm.cos.f32
vtanf
vasinf
vacosf
vatanf
vsinhf
vcoshf
vtanhf
vasinhf
vacoshf
vatanhf
__svml_sin2
__svml_sin4
__svml_sin8
__svml_sinf4
__svml_sinf8
__svml_sinf16
llvm.sin.f64
__svml_cos2
__svml_cos4
__svml_cos8
__svml_cosf4
__svml_cosf8
__svml_cosf16
llvm.cos.f64
__svml_pow2
__svml_pow4
__svml_pow8
__svml_powf4
__svml_powf8
__svml_powf16
llvm.pow.f64
llvm.pow.f32
__svml_exp2
__svml_exp4
__svml_exp8
__svml_expf4
__svml_expf8
__svml_expf16
llvm.exp.f64
__svml_log2
__svml_log4
__svml_log8
__svml_logf4
__svml_logf8
__svml_logf16
llvm.log.f64
wchar_size
fwrite$UNIX2003
fputs$UNIX2003
_copysign
__exp10
__exp10f
Target Library Information
targetlibinfo
costmodel-reduxcost
Recognize reduction patterns.
Target Transform Information
enable-tbaa
Cycle found in TBAA metadata.
Type-Based Alias Analysis
tbaa
enable-scoped-noalias
Scoped NoAlias Alias Analysis
scoped-noalias
undefined
overdefined
notconstant<
constantrange<
constant<
dom-conditions-max-uses
value-tracking
BadAssumption
Detected conflicting code assumptions. Program may have undefined behavior, or compiler may have internal error.
LLVM_OVERRIDE_PRODUCER
input module has no datalayout
Unable to determine comdat of alias!
Invalid weak external
__ashlhi3
__ashlsi3
__ashldi3
__ashlti3
__lshrhi3
__lshrsi3
__lshrdi3
__lshrti3
__ashrhi3
__ashrsi3
__ashrdi3
__ashrti3
__mulqi3
__mulhi3
__mulsi3
__muldi3
__multi3
__mulosi4
__mulodi4
__muloti4
__divqi3
__divhi3
__divsi3
__divdi3
__divti3
__udivqi3
__udivhi3
__udivsi3
__udivdi3
__udivti3
__modqi3
__modhi3
__modsi3
__moddi3
__modti3
__umodqi3
__umodhi3
__umodsi3
__umoddi3
__umodti3
__negsi2
__negdi2
__addsf3
__adddf3
__addxf3
__addtf3
__gcc_qadd
__subsf3
__subdf3
__subxf3
__subtf3
__gcc_qsub
__mulsf3
__muldf3
__mulxf3
__multf3
__gcc_qmul
__divsf3
__divdf3
__divxf3
__divtf3
__gcc_qdiv
fmaf
fmal
__powisf2
__powidf2
__powixf2
__powitf2
__gcc_stoq
__gcc_dtoq
__extendxftf2
__extenddftf2
__extendsftf2
__extendsfdf2
__gnu_h2f_ieee
__gnu_f2h_ieee
__truncdfhf2
__truncxfhf2
__trunctfhf2
__truncdfsf2
__truncxfsf2
__trunctfsf2
__gcc_qtos
__truncxfdf2
__trunctfdf2
__gcc_qtod
__trunctfxf2
__fixsfsi
__fixsfdi
__fixsfti
__fixdfsi
__fixdfdi
__fixdfti
__fixxfsi
__fixxfdi
__fixxfti
__fixtfsi
__fixtfdi
__fixtfti
__gcc_qtou
__fixunssfsi
__fixunssfdi
__fixunssfti
__fixunsdfsi
__fixunsdfdi
__fixunsdfti
__fixunsxfsi
__fixunsxfdi
__fixunsxfti
__fixunstfsi
__fixunstfdi
__fixunstfti
__floatsisf
__floatsidf
__floatsixf
__floatsitf
__gcc_itoq
__floatdisf
__floatdidf
__floatdixf
__floatditf
__floattisf
__floattidf
__floattixf
__floattitf
__floatunsisf
__floatunsidf
__floatunsixf
__floatunsitf
__gcc_utoq
__floatundisf
__floatundidf
__floatundixf
__floatunditf
__floatuntisf
__floatuntidf
__floatuntixf
__floatuntitf
__eqsf2
__eqdf2
__eqtf2
__gcc_qeq
__nesf2
__nedf2
__netf2
__gcc_qne
__gesf2
__gedf2
__getf2
__gcc_qge
__ltsf2
__ltdf2
__lttf2
__gcc_qlt
__lesf2
__ledf2
__letf2
__gcc_qle
__gtsf2
__gtdf2
__gttf2
__gcc_qgt
__unordsf2
__unorddf2
__unordtf2
__gcc_qunord
__llvm_memcpy_element_unordered_atomic_1
__llvm_memcpy_element_unordered_atomic_2
__llvm_memcpy_element_unordered_atomic_4
__llvm_memcpy_element_unordered_atomic_8
__llvm_memcpy_element_unordered_atomic_16
__llvm_memmove_element_unordered_atomic_1
__llvm_memmove_element_unordered_atomic_2
__llvm_memmove_element_unordered_atomic_4
__llvm_memmove_element_unordered_atomic_8
__llvm_memmove_element_unordered_atomic_16
__llvm_memset_element_unordered_atomic_1
__llvm_memset_element_unordered_atomic_2
__llvm_memset_element_unordered_atomic_4
__llvm_memset_element_unordered_atomic_8
__llvm_memset_element_unordered_atomic_16
_Unwind_Resume
__sync_val_compare_and_swap_1
__sync_val_compare_and_swap_2
__sync_val_compare_and_swap_4
__sync_val_compare_and_swap_8
__sync_val_compare_and_swap_16
__sync_lock_test_and_set_1
__sync_lock_test_and_set_2
__sync_lock_test_and_set_4
__sync_lock_test_and_set_8
__sync_lock_test_and_set_16
__sync_fetch_and_add_1
__sync_fetch_and_add_2
__sync_fetch_and_add_4
__sync_fetch_and_add_8
__sync_fetch_and_add_16
__sync_fetch_and_sub_1
__sync_fetch_and_sub_2
__sync_fetch_and_sub_4
__sync_fetch_and_sub_8
__sync_fetch_and_sub_16
__sync_fetch_and_and_1
__sync_fetch_and_and_2
__sync_fetch_and_and_4
__sync_fetch_and_and_8
__sync_fetch_and_and_16
__sync_fetch_and_or_1
__sync_fetch_and_or_2
__sync_fetch_and_or_4
__sync_fetch_and_or_8
__sync_fetch_and_or_16
__sync_fetch_and_xor_1
__sync_fetch_and_xor_2
__sync_fetch_and_xor_4
__sync_fetch_and_xor_8
__sync_fetch_and_xor_16
__sync_fetch_and_nand_1
__sync_fetch_and_nand_2
__sync_fetch_and_nand_4
__sync_fetch_and_nand_8
__sync_fetch_and_nand_16
__sync_fetch_and_max_1
__sync_fetch_and_max_2
__sync_fetch_and_max_4
__sync_fetch_and_max_8
__sync_fetch_and_max_16
__sync_fetch_and_umax_1
__sync_fetch_and_umax_2
__sync_fetch_and_umax_4
__sync_fetch_and_umax_8
__sync_fetch_and_umax_16
__sync_fetch_and_min_1
__sync_fetch_and_min_2
__sync_fetch_and_min_4
__sync_fetch_and_min_8
__sync_fetch_and_min_16
__sync_fetch_and_umin_1
__sync_fetch_and_umin_2
__sync_fetch_and_umin_4
__sync_fetch_and_umin_8
__sync_fetch_and_umin_16
__atomic_load
__atomic_load_1
__atomic_load_2
__atomic_load_4
__atomic_load_8
__atomic_load_16
__atomic_store
__atomic_store_1
__atomic_store_2
__atomic_store_4
__atomic_store_8
__atomic_store_16
__atomic_exchange
__atomic_exchange_1
__atomic_exchange_2
__atomic_exchange_4
__atomic_exchange_8
__atomic_exchange_16
__atomic_compare_exchange
__atomic_compare_exchange_1
__atomic_compare_exchange_2
__atomic_compare_exchange_4
__atomic_compare_exchange_8
__atomic_compare_exchange_16
__atomic_fetch_add_1
__atomic_fetch_add_2
__atomic_fetch_add_4
__atomic_fetch_add_8
__atomic_fetch_add_16
__atomic_fetch_sub_1
__atomic_fetch_sub_2
__atomic_fetch_sub_4
__atomic_fetch_sub_8
__atomic_fetch_sub_16
__atomic_fetch_and_1
__atomic_fetch_and_2
__atomic_fetch_and_4
__atomic_fetch_and_8
__atomic_fetch_and_16
__atomic_fetch_or_1
__atomic_fetch_or_2
__atomic_fetch_or_4
__atomic_fetch_or_8
__atomic_fetch_or_16
__atomic_fetch_xor_1
__atomic_fetch_xor_2
__atomic_fetch_xor_4
__atomic_fetch_xor_8
__atomic_fetch_xor_16
__atomic_fetch_nand_1
__atomic_fetch_nand_2
__atomic_fetch_nand_4
__atomic_fetch_nand_8
__atomic_fetch_nand_16
__stack_chk_fail
Could not find leader
__imp_
invalid hexadecimal floating-point constant: expected at least one significand digit
invalid hexadecimal floating-point constant: expected exponent part 'p'
invalid hexadecimal floating-point constant: expected at least one exponent digit
unterminated comment
invalid binary number
invalid hexdecimal number
invalid decimal number
invalid hexadecimal number
invalid octal number
unterminated single quote
single quote way too long
unterminated string constant
invalid character in input
higher
highest
tlsgd
asm-macro-max-nesting-depth
The maximum nesting depth allowed for assembly macros.
missing expression
unexpected token
Recursive use of '
redefinition of '
invalid assignment to '
invalid reassignment of non-absolute variable '
.set
.equ
.equiv
.ascii
.asciz
.string
.byte
.short
.value
.2byte
.long
.4byte
.quad
.8byte
.octa
.single
.float
.double
.align
.align32
.balign
.balignw
.balignl
.p2align
.p2alignw
.p2alignl
.org
.fill
.zero
.extern
.globl
.global
.lazy_reference
.no_dead_strip
.symbol_resolver
.private_extern
.reference
.weak_definition
.weak_reference
.weak_def_can_be_hidden
.comm
.common
.lcomm
.abort
.include
.incbin
.code16
.code16gcc
.rept
.rep
.irp
.irpc
.endr
.bundle_align_mode
.bundle_lock
.bundle_unlock
.ifeq
.ifge
.ifgt
.ifle
.iflt
.ifne
.ifb
.ifnb
.ifc
.ifeqs
.ifnc
.ifnes
.ifdef
.ifndef
.ifnotdef
.elseif
.else
.end
.endif
.skip
.space
.file
.line
.loc
.stabs
.cv_file
.cv_func_id
.cv_loc
.cv_linetable
.cv_inline_linetable
.cv_inline_site_id
.cv_def_range
.cv_stringtable
.cv_filechecksums
.cv_filechecksumoffset
.cv_fpo_data
.sleb128
.uleb128
.cfi_sections
.cfi_startproc
.cfi_endproc
.cfi_def_cfa
.cfi_def_cfa_offset
.cfi_adjust_cfa_offset
.cfi_def_cfa_register
.cfi_offset
.cfi_rel_offset
.cfi_personality
.cfi_lsda
.cfi_remember_state
.cfi_restore_state
.cfi_same_value
.cfi_restore
.cfi_escape
.cfi_return_column
.cfi_signal_frame
.cfi_undefined
.cfi_register
.cfi_window_save
.macros_on
.macros_off
.macro
.exitm
.endm
.endmacro
.purgem
.err
.error
.warning
.altmacro
.noaltmacro
.reloc
.dc.a
.dc.b
.dc.d
.dc.l
.dc.s
.dc.w
.dc.x
.dcb
.dcb.b
.dcb.d
.dcb.l
.dcb.s
.dcb.w
.dcb.x
.ds.b
.ds.d
.ds.l
.ds.p
.ds.s
.ds.w
.ds.x
.print
.addrsig
.addrsig_sym
unmatched .ifs or .elses
unassigned file number: 
 for .file directives
assembler local symbol '
' not defined
directional label undefined
unexpected token at start of statement
invalid use of pseudo-symbol '.' as a label
 not currently supported for this target
unknown directive
parsed instruction: [
unexpected token in '.if' directive
unexpected token in '.ifb' directive
unexpected token in '.ifc' directive
expected string parameter for '.ifeqs' directive
expected string parameter for '.ifnes' directive
expected comma after first string for '.ifeqs' directive
expected comma after first string for '.ifnes' directive
expected identifier after '.ifdef'
unexpected token in '.ifdef'
Encountered a .elseif that doesn't follow an .if or  an .elseif
unexpected token in '.elseif' directive
unexpected token in '.else' directive
Encountered a .else that doesn't follow  an .if or an .elseif
unexpected token in '.endif' directive
Encountered a .endif that doesn't follow an .if or .else
macros cannot be nested more than 
 levels deep.
 Use -asm-macro-max-nesting-depth to increase this limit.
.endmacro
<instantiation>
invalid argument identifier for formal argument
expected '=' after formal parameter identifier
cannot mix positional and keyword arguments
expected absolute expression
parameter named '
' does not exist for macro '
missing value for required parameter '
' in macro '
too many positional arguments
unexpected token in macro instantiation
unbalanced parentheses in macro argument
Wrong number of arguments
expected identifier
 in '
' directive
out of range literal value
unknown token in expression
unexpected token in directive
invalid floating point literal
 in directive
p2align directive with no operand(s) is ignored
invalid alignment value
alignment must be a power of 2
alignment directive can never be satisfied in this many bytes, ignoring maximum bytes expression
maximum bytes expression exceeds alignment and has no effect
 in '.org' directive
unexpected token in '.fill' directive
'.fill' directive with negative size has no effect
'.fill' directive with size greater than 8 has been truncated to 8
'.fill' directive pattern has been truncated to 32-bits
unexpected token in '.zero' directive
non-local symbol required
unable to emit symbol attribute
expected identifier in directive
alignment not supported on this target
unexpected token in '.comm' or '.lcomm' directive
invalid '.comm' or '.lcomm' directive size, can't be less than zero
invalid '.comm' or '.lcomm' directive alignment, can't be less than zero
invalid symbol redefinition
unexpected token in '.abort' directive
.abort detected. Assembly stopping.
.abort '
' detected. Assembly stopping.
expected string in '.include' directive
unexpected token in '.include' directive
Could not find include file '
expected string in '.incbin' directive
unexpected token in '.incbin' directive
skip is negative
Could not find incbin file '
negative count has no effect
unexpected token in '
Count is negative
no matching '.endr' in definition
unexpected token in '.endr' directive
.endr
expected identifier in '.irp' directive
expected comma in '.irp' directive
expected End of Statement
expected identifier in '.irpc' directive
expected comma in '.irpc' directive
unexpected token in '.irpc' directive
expected end of statement
unmatched '.endr' directive
unexpected token after expression in '.bundle_align_mode' directive
invalid bundle alignment size (expected between 0 and 30)
invalid option for '.bundle_lock' directive
unexpected token after '.bundle_lock' directive option
unexpected token in '.bundle_unlock' directive
in '
negative file number
unexpected token in '.file' directive
explicit path specified, but no file number
MD5 checksum specified, but no file number
source specified, but no file number
file 0 not supported prior to DWARF-5
inconsistent use of MD5 checksums
unexpected token in '.line' directive
unexpected token in '.loc' directive
file number less than one in '.loc' directive
unassigned file number in '.loc' directive
line number less than zero in '.loc' directive
column position less than zero in '.loc' directive
is_stmt value not 0 or 1
is_stmt value not the constant value of 0 or 1
isa number less than zero
isa number not a constant value
unknown sub-directive in '.loc' directive
unsupported directive '.stabs'
expected file number in '.cv_file' directive
file number less than one
unexpected token in '.cv_file' directive
expected checksum kind in '.cv_file' directive
file number already allocated
unexpected token in '.cv_func_id' directive
function id already allocated
expected function id in '
expected function id within range [0, UINT_MAX)
expected 'within' identifier in '.cv_inline_site_id' directive
expected 'inlined_at' identifier in '.cv_inline_site_id' directive
expected line number after 'inlined_at'
unexpected token in '.cv_inline_site_id' directive
expected integer in '
file number less than one in '
unassigned file number in '
line number less than zero in '.cv_loc' directive
column position less than zero in '.cv_loc' directive
unexpected token in '.cv_loc' directive
unknown sub-directive in '.cv_loc' directive
unexpected token in '.cv_linetable' directive
expected SourceField in '.cv_inline_linetable' directive
File id less than zero in '.cv_inline_linetable' directive
expected SourceLineNum in '.cv_inline_linetable' directive
Line number less than zero in '.cv_inline_linetable' directive
Expected End of Statement
expected symbol name
unexpected tokens
 in '.cv_fpo_data' directive
Expected an identifier
.eh_frame
.debug_frame
 in '.cfi_startproc' directive
unsupported encoding.
unexpected token in '.cfi_signal_frame'
expected identifier in '.macro' directive
Vararg parameter '
' should be last one in the list of parameters.
macro '
' has multiple parameters named '
missing parameter qualifier for '
 is not a valid parameter qualifier for '
pointless default value for required parameter '
no matching '.endmacro' in definition
' is already defined
macro defined with named parameters which are not used in macro body, possible positional parameter found in body which will have no effect
unexpected '
' in file, no current macro definition
expected identifier in '.purgem' directive
unexpected token in '.purgem' directive
' is not defined
unexpected token in '.end' directive
.err encountered
.error directive invoked in source file
.error argument must be a string
.warning directive invoked in source file
.warning argument must be a string
expected end of statement in '.warning' directive
expression is not a constant value
expression is negative
expected comma
expected relocation name
expression must be relocatable
unexpected token in .reloc directive
unknown relocation name
' directive with negative repeat count has no effect
literal value out of range for directive
expected double quoted string after .print
expected identifier in '.addrsig_sym' directive
unexpected expression in _emit
unexpected expression in align
literal value not a power of two greater then zero
 * $$
 + $$
byte ptr 
word ptr 
dword ptr 
qword ptr 
xword ptr 
xmmword ptr 
ymmword ptr 
.even
while in macro instantiation
unexpected backslash at end of string
invalid octal escape sequence (out of range)
invalid escape sequence (unrecognized character)
unexpected symbol modifier following '@'
invalid variant '
invalid modifier '
' (no symbols present)
invalid variant on expression '
' (already modified)
invalid token in expression
expected symbol variant after '@'
unexpected token in variant, expected ')'
unexpected modifier on variable reference
brackets expression not supported on this target
expected '(' after operator
expected ')' in parentheses expression
expected ']' in brackets expression
expected section directive before assembly directive
.text
.data
.bss
.section
.def
.scl
.type
.endef
.secrel32
.symidx
.safeseh
.secidx
.linkonce
.rva
.seh_proc
.seh_endproc
.seh_startchained
.seh_endchained
.seh_handler
.seh_handlerdata
.seh_pushreg
.seh_setframe
.seh_stackalloc
.seh_savereg
.seh_savexmm
.seh_pushframe
.seh_endprologue
.weak
unexpected token in section switching directive
expected string in directive
expected comdat type such as 'discard' or 'largest' after protection bits
expected comma in directive
conflicting section flags 'b' and 'd'.
unknown flag
one_only
discard
same_size
same_contents
associative
newest
unrecognized COMDAT type '
invalid '.secrel32' directive offset, can't be less than zero or greater than std::numeric_limits<uint32_t>::max()
cannot make section associative with .linkonce
section '
' is already linkonce
invalid '.rva' directive offset, can't be less than -2147483648 or greater than 2147483647
you must specify one or both of @unwind or @except
a handler attribute must begin with '@'
expected @unwind or @except
register can't be represented in SEH unwind info
register number is too high
you must specify a stack pointer offset
you must specify an offset on the stack
expected @code
.alt_entry
.desc
.indirect_symbol
.lsym
.subsections_via_symbols
.dump
.pushsection
.popsection
.previous
.secure_log_unique
.secure_log_reset
.tbss
.zerofill
.data_region
.end_data_region
.const
.const_data
.constructor
.cstring
.destructor
.dyld
.fvmlib_init0
.fvmlib_init1
.lazy_symbol_pointer
.linker_option
.literal16
.literal4
.literal8
.mod_init_func
.mod_term_func
.non_lazy_symbol_pointer
.thread_local_variable_pointer
.objc_cat_cls_meth
.objc_cat_inst_meth
.objc_category
.objc_class
.objc_class_names
.objc_class_vars
.objc_cls_meth
.objc_cls_refs
.objc_inst_meth
.objc_instance_vars
.objc_message_refs
.objc_meta_class
.objc_meth_var_names
.objc_meth_var_types
.objc_module_info
.objc_protocol
.objc_selector_strs
.objc_string_object
.objc_symbols
.picsymbol_stub
.static_const
.static_data
.symbol_stub
.tdata
.thread_init_func
.tlv
.ident
.watchos_version_min
.tvos_version_min
.ios_version_min
.macosx_version_min
.build_version
.alt_entry must preceed symbol definition
unexpected token in '.desc' directive
indirect symbol not in a symbol pointer or stub section
expected identifier in .indirect_symbol directive
non-local symbol required in directive
unable to emit indirect symbol attribute for: 
unexpected token in '.indirect_symbol' directive
unexpected token in '.lsym' directive
directive '.lsym' is unsupported
unexpected token in '.subsections_via_symbols' directive
expected string in '.dump' or '.load' directive
unexpected token in '.dump' or '.load' directive
ignoring directive .dump for now
ignoring directive .load for now
expected identifier after '.section' directive
unexpected token in '.section' directive
__textcoal_nt
__text
__const_coal
__const
__datacoal_nt
__data
section "
" is deprecated
change section name to "
__TEXT
.popsection without corresponding .pushsection
.previous without corresponding .section
unexpected token in '.secure_log_unique' directive
.secure_log_unique specified multiple times
.secure_log_unique used but AS_SECURE_LOG_FILE environment variable unset.
can't open secure log file: 
unexpected token in '.secure_log_reset' directive
unexpected token in '.tbss' directive
invalid '.tbss' directive size, can't be less thanzero
invalid '.tbss' alignment, can't be lessthan zero
__DATA
__thread_bss
expected segment name after '.zerofill' directive
expected section name after comma in '.zerofill' directive
unexpected token in '.zerofill' directive
invalid '.zerofill' directive size, can't be less than zero
invalid '.zerofill' directive alignment, can't be less than zero
expected region type after '.data_region' directive
unknown region type in '.data_region' directive
unexpected token in '.end_data_region' directive
__bss
__constructor
__cstring
__destructor
__dyld
__fvmlib_init0
__fvmlib_init1
__la_symbol_ptr
expected string in '
__literal16
__literal4
__literal8
__mod_init_func
__mod_term_func
__nl_symbol_ptr
__thread_ptr
__OBJC
__cat_cls_meth
__cat_inst_meth
__category
__class
__class_vars
__cls_meth
__cls_refs
__inst_meth
__instance_vars
__message_refs
__meta_class
__module_info
__protocol
__selector_strs
__string_object
__symbols
__picsymbol_stub
__static_const
__static_data
__symbol_stub
__thread_data
__thread_init
__thread_vars
invalid OS major version number, integer expected
invalid OS major version number
OS minor version number required, comma expected
invalid OS minor version number, integer expected
invalid OS minor version number
invalid OS update specifier, comma expected
invalid OS update version number, integer expected
invalid OS update version number
 used while targeting 
overriding previous version directive
previous definition is here
platform name expected
tvos
watchos
unknown platform name
version number required, comma expected
 in '.build_version' directive
.rodata
.data.rel
.data.rel.ro
.size
.symver
.version
.weakref
.local
.protected
.internal
.hidden
.subsection
.cg_profile
.data.
.fini_array.
.preinit_array.
.tdata.
.tbss.
Section cannot specifiy a group name while also acting as a member of the last group
Mergeable section must specify the type
Group section must specify the type
.note
init_array
fini_array
preinit_array
nobits
progbits
note
llvm_odrtab
llvm_linker_options
llvm_call_graph_profile
unknown section type
DWARF2 only supports one section per compilation unit
expected '@<type>', '%<type>' or "<type>"
expected '%<type>' or "<type>"
expected the entry size
entry size must be positive
expected group name
invalid group name
invalid linkage
Linkage must be 'comdat'
expected metadata symbol
invalid metadata symbol
symbol is not in a section: 
expected 'unique'
expected commma
unique id must be positive
unique id is too large
expected STT_<TYPE_IN_UPPER_CASE>, '#<type>', '%<type>' or "<type>"
expected STT_<TYPE_IN_UPPER_CASE>, '#<type>', '@<type>', '%<type>' or "<type>"
expected symbol type in directive
unsupported attribute in '.type' directive
unexpected token in '.type' directive
unexpected token in '.ident' directive
expected a comma
expected a '@' in the name
unexpected token in '.version' directive
expected integer count in '.cg_profile' directive
unexpected token
A @@ version cannot be undefined
Multiple symbol versions defined for 
No relocation available to represent this relative expression
symbol '
' can not be undefined in a subtraction expression
Cannot represent a difference across sections
.strtab
.llvm.call-graph-profile
.llvm_addrsig
.rela
.rel
.symtab
Undefined temporary symbol
.symtab_shndxr
Size expression must be absolute.
FK_Data_1
FK_Data_2
FK_Data_4
FK_Data_8
FK_PCRel_1
FK_PCRel_2
FK_PCRel_4
FK_PCRel_8
FK_GPRel_1
FK_GPRel_2
FK_GPRel_4
FK_GPRel_8
FK_DTPRel_4
FK_DTPRel_8
FK_TPRel_4
FK_TPRel_8
FK_SecRel_1
FK_SecRel_2
FK_SecRel_4
FK_SecRel_8
FK_Data_Add_1
FK_Data_Add_2
FK_Data_Add_4
FK_Data_Add_8
FK_Data_Sub_1
FK_Data_Sub_2
FK_Data_Sub_4
FK_Data_Sub_8
dwarf-extended-loc
Disable emission of the extended flags in .loc directives.
Default for platform
Enable
Enabled
Disable
Disabled
NO_APP
.code32
.code64
.zero
.ascii
.asciz
.byte
.short
.long
.quad
.globl
.weak
.note.GNU-stack
.weak
expected relocatable expression
unsupported subtraction of qualified symbol
expected assembly-time absolute expression
invalid number of bytes
invalid .org offset '
' (at offset '
Fragment can't be larger than a bundle size
Padding cannot exceed 255 bytes
unable to write NOP sequence of 
 bytes
cannot have fixups in virtual section!
non-zero initializer found in section '
non-zero initializer found in virtual section
sleb128 and uleb128 expressions must be absolute
<MCAssembler
  Sections:[
    
    
  Symbols:[
           
, Index:
undefined .align directive, value size '
' is not a divisor of padding size '
unable to write nop sequence of 
<stdin>
checksum_offset
strtab_begin
strtab_end
filechecksums_begin
filechecksums_end
linetable_begin
linetable_end
Segment for file '
' begins
Allocation failed
as-secure-log-file-name
As secure log file name (initialized from AS_SECURE_LOG_FILE env variable)
AS_SECURE_LOG_FILE
.group
Allocation failed
inconsistent use of embedded source
llvm-mc (based on LLVM 7.0.0)
Unterminated .bundle_lock when changing a section
Symbol: 
 redeclared as different type
Emitting values inside a locked bundle is forbidden
.comment
Reference to undefined temporary symbol 
.bundle_align_mode cannot be changed once set
.bundle_lock forbidden when bundling is disabled
.bundle_unlock forbidden when bundling is disabled
.bundle_unlock without matching lock
Empty bundle-locked group is forbidden
A Bundle can only have one Subtarget.
<<invalid>>
<<none>>
DTPOFF
DTPREL
GOTOFF
GOTREL
GOTPCREL
GOTTPOFF
INDNTPOFF
NTPOFF
GOTNTPOFF
TLSGD
TLSLD
TLSLDM
TPOFF
TPREL
tlscall
tlsdesc
TLVP
TLVPPAGE
TLVPPAGEOFF
PAGE
PAGEOFF
GOTPAGE
GOTPAGEOFF
SECREL32
SIZE
WEAKREF
ABS8
GOT_PREL
target1
target2
prel31
sbrel
tlsldo
tlsdescseq
hlo8
diff8
diff16
diff32
high
higha
highera
highesta
got@l
got@h
got@ha
tocbase
toc@l
toc@h
toc@ha
dtpmod
tprel@l
tprel@h
tprel@ha
tprel@high
tprel@higha
tprel@higher
tprel@highera
tprel@highest
tprel@highesta
dtprel@l
dtprel@h
dtprel@ha
dtprel@high
dtprel@higha
dtprel@higher
dtprel@highera
dtprel@highest
dtprel@highesta
got@tprel
got@tprel@l
got@tprel@h
got@tprel@ha
got@dtprel
got@dtprel@l
got@dtprel@h
got@dtprel@ha
got@tlsgd
got@tlsgd@l
got@tlsgd@h
got@tlsgd@ha
got@tlsld
got@tlsld@l
got@tlsld@h
got@tlsld@ha
tlsld
IMGREL
PCREL
LO16
HI16
GPREL
GDGOT
LDGOT
GDPLT
LDPLT
IEGOT
FUNCTION
TYPEINDEX
gotpcrel32@lo
gotpcrel32@hi
rel32@lo
rel32@hi
rel64
Allocation failed
expression could not be evaluated
' could not be evaluated in a subtraction expression
Common symbol '
' cannot be used in assignment expr
<MCFixup
 Offset:
 Value:
 Kind:
MCAlignFragment
MCDataFragment
MCCompactEncodedInstFragment
MCFillFragment
MCRelaxableFragment
MCOrgFragment
MCDwarfFragment
MCDwarfCallFrameFragment
MCLEBFragment
MCPaddingFragment
MCSymbolIdFragment
MCCVInlineLineTableFragment
MCCVDefRangeTableFragment
MCDummyFragment
<MCFragment 
 LayoutOrder:
 HasInstructions:
 BundlePadding:
 (emit nops)
 Alignment:
 ValueSize:
 MaxBytesToEmit:
 Contents:[
 bytes)
       
 Fixups:[
                
 NumValues:
 Inst:
 AddrDelta:
 LineDelta:
 Signed:
 PaddingPoliciesMask:
 IsInsertionPoint:
 Size:
 InstSize:
 Sym:
 RangeStart:
 RangeEnd:
unable to evaluate offset for variable '
unable to evaluate offset to undefined symbol '
<MCOperand 
INVALID
Reg:
Imm:
FPImm:
Expr:(
Inst:(
<MCInst 
<MCInst #
__eh_frame
__ustring
__common
__gcc_except_tab
__LD
__compact_unwind
__DWARF
__debug_names
debug_names_begin
__apple_names
names_begin
__apple_objc
objc_begin
__apple_namespac
namespac_begin
__apple_types
types_begin
__swift_ast
__debug_abbrev
__debug_info
__debug_line
__debug_line_str
section_line_str
__debug_frame
__debug_pubnames
__debug_pubtypes
__debug_gnu_pubn
__debug_gnu_pubt
__debug_str
__debug_str_offs
section_str_off
__debug_loc
__debug_aranges
__debug_ranges
__debug_rnglists
__debug_macinfo
debug_macinfo
__debug_inlined
__debug_cu_index
__debug_tu_index
__LLVM_STACKMAPS
__llvm_stackmaps
__LLVM_FAULTMAPS
__llvm_faultmaps
.rodata.cst4
.rodata.cst8
.rodata.cst16
.rodata.cst32
.gcc_except_table
.debug_abbrev
.debug_info
.debug_line
.debug_line_str
.debug_pubnames
.debug_pubtypes
.debug_gnu_pubnames
.debug_gnu_pubtypes
.debug_str
.debug_loc
.debug_aranges
.debug_ranges
.debug_macinfo
.debug_names
.apple_names
.apple_objc
.apple_namespaces
.apple_types
.debug_str_offsets
.debug_addr
.debug_rnglists
.debug_info.dwo
.debug_types.dwo
.debug_abbrev.dwo
.debug_str.dwo
.debug_line.dwo
.debug_loc.dwo
.debug_str_offsets.dwo
.debug_rnglists.dwo
.debug_cu_index
.debug_tu_index
.llvm_stackmaps
.llvm_faultmaps
.stack_sizes
.rdata
.debug$S
.debug$T
.debug$H
section_info_dwo
section_types_dwo
section_abbrev_dwo
skel_string
skel_loc
section_str_off_dwo
addr_sec
.drectve
.pdata
.xdata
.sxdata
.gfids$y
.tls$
Cannot initialize MC for non-Windows COFF object files.
Cannot initialize MC for unknown object file format.
value evaluated as 
 is out of range.
This file format doesn't support weak aliases.
Cannot evaluate subsection number
Subsection number out of range
'.fill' directive with negative repeat count has no effect
sec_end
Mismatched bundle_lock/unlock directives
<MCSection
 Fragments:[
      
      
.section
.linkonce
,#alloc
,#execinstr
,#write
,#exclude
,#tls
0x7000001e
unsupported type 0x
 for section 
,comdat
,unique,
.subsection
0123456789_.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
,none,
mach-o section specifier requires a segment whose length is between 1 and 16 characters
mach-o section specifier requires a segment and section separated by a comma
mach-o section specifier requires a section whose length is between 1 and 16 characters
mach-o section specifier uses an unknown section type
mach-o section specifier of type 'symbol_stubs' requires a size specifier
mach-o section specifier has invalid attribute
mach-o section specifier cannot have a stub size specified because it does not have type 'symbol_stubs'
mach-o section specifier has a malformed stub size
regular
S_REGULAR
S_ZEROFILL
cstring_literals
S_CSTRING_LITERALS
4byte_literals
S_4BYTE_LITERALS
8byte_literals
S_8BYTE_LITERALS
literal_pointers
S_LITERAL_POINTERS
non_lazy_symbol_pointers
S_NON_LAZY_SYMBOL_POINTERS
lazy_symbol_pointers
S_LAZY_SYMBOL_POINTERS
symbol_stubs
S_SYMBOL_STUBS
mod_init_funcs
S_MOD_INIT_FUNC_POINTERS
mod_term_funcs
S_MOD_TERM_FUNC_POINTERS
coalesced
S_COALESCED
S_GB_ZEROFILL
interposing
S_INTERPOSING
16byte_literals
S_16BYTE_LITERALS
S_DTRACE_DOF
S_LAZY_DYLIB_SYMBOL_POINTERS
thread_local_regular
S_THREAD_LOCAL_REGULAR
thread_local_zerofill
S_THREAD_LOCAL_ZEROFILL
thread_local_variables
S_THREAD_LOCAL_VARIABLES
thread_local_variable_pointers
S_THREAD_LOCAL_VARIABLE_POINTERS
thread_local_init_function_pointers
S_THREAD_LOCAL_INIT_FUNCTION_POINTERS
pure_instructions
S_ATTR_PURE_INSTRUCTIONS
no_toc
S_ATTR_NO_TOC
strip_static_syms
S_ATTR_STRIP_STATIC_SYMS
no_dead_strip
S_ATTR_NO_DEAD_STRIP
live_support
S_ATTR_LIVE_SUPPORT
self_modifying_code
S_ATTR_SELF_MODIFYING_CODE
debug
S_ATTR_DEBUG
S_ATTR_SOME_INSTRUCTIONS
S_ATTR_EXT_RELOC
S_ATTR_LOC_RELOC
unsupported directive in streamer
this directive must appear between .cfi_startproc and .cfi_endproc directives
parent function id not introduced by .cv_func_id or .cv_inline_site_id
function id not introduced by .cv_func_id or .cv_inline_site_id
all .cv_loc directives for a function must be in the same section
invalid symbol redefinition
starting new .cfi frame before finishing the previous one
.seh_* directives are not supported on this target
.seh_ directive must appear within an active frame
Starting a function before ending the previous one!
Not all chained regions terminated!
End of a chained region outside a chained region!
Chained unwind areas can't have handlers!
Don't know what kind of handler this is!
frame register and offset can be set at most once
offset is not a multiple of 16
frame offset must be less than or equal to 240
stack allocation size must be non-zero
stack allocation size is not a multiple of 8
register save offset is not 8 byte aligned
If present, PushMachFrame must be the first UOP
EmitRawText called on an MCStreamer that doesn't support it,  something must not be fully mc'ized
Unfinished frame!
Symbol name with unsupported characters
help
 Off=
, Sym=
, Addend=
, FixupSection=
 = comdat 
 = type 
; Materializable
; Function Attrs: 
define 
 section "
 align 
 gc "
 prefix 
 prologue 
 personality 
!<unknown kind #
<empty name> 
!DIExpression(
dso_local 
hidden 
protected 
dllimport 
dllexport 
avr_intrcc 
avr_signalcc 
asm 
sideeffect 
alignstack 
inteldialect 
", "
 comdat
<null operand!>
; uselistorder directives
_bb 
, { 
; ModuleID = '
source_filename = "
target datalayout = "
target triple = "
module asm "
attributes #
 = { 
distinct 
<temporary!> 
!DILocation(
!DIGlobalVariableExpression(
!GenericDINode(
operands: {
tag: 
!DISubrange(
!DIEnumerator(
!DIBasicType(
!DIDerivedType(
!DICompositeType(
!DISubroutineType(
!DIFile(
checksumkind: 
!DICompileUnit(
!DISubprogram(
!DILexicalBlock(
!DILexicalBlockFile(
!DINamespace(
!DIModule(
!DITemplateTypeParameter(
!DITemplateValueParameter(
!DIGlobalVariable(
!DILocalVariable(
!DILabel(
!DIObjCProperty(
!DIImportedEntity(
!DIMacro(
type: 
!DIMacroFile(
 = !{
%"type 
 addrspace(
<badref> = 
musttail 
tail 
notail 
 atomic
 weak
 volatile
          cleanup
          catch 
          filter 
 within 
] unwind 
to caller
 void
 unwind 
, ...
          to 
inalloca 
swifterror 
, addrspace(
 fast
 reassoc
 nnan
 ninf
 nsz
 arcp
 contract
 afn
 nuw
 nsw
 exact
 inbounds
 <unknown operation 
 xchg
 add
 sub
 and
 nand
 xor
 max
 min
 umax
 umin
 syncscope("
 ; (
; <label>:
; Error: Block without parent!
 No predecessors!
 preds = 
external 
addrspace(
externally_initialized 
constant 
global 
, section "
thread_local 
thread_local(localdynamic) 
thread_local(initialexec) 
thread_local(localexec) 
alias 
ifunc 
 <<NULL ALIASEE>>
inrange 
<placeholder or erroneous Constant>
 = module: (
path: "
", hash: (
 = typeid: (name: "
) ; guid = 
 = gv: (
name: "
guid: 
, summaries: (
 ; guid = 
(module: ^
, flags: (
linkage: 
, notEligibleToImport: 
, live: 
, dsoLocal: 
, refs: (
, aliasee: 
, insts: 
, funcFlags: (
readNone: 
, readOnly: 
, noRecurse: 
, returnDoesNotAlias: 
, calls: (
(callee: ^
, hotness: 
, relbf: 
, typeIdInfo: (
typeTests: (
vFuncId: (
, offset: 
args: (
, summary: (
, wpdResolutions: (
(offset: 
typeTestRes: (kind: 
, sizeM1BitWidth: 
, alignLog2: 
, sizeM1: 
, bitMask: 
, inlineBits: 
wpdRes: (kind: 
, singleImplName: "
, resByArg: (
, byArg: (kind: 
, info: 
, byte: 
, bit: 
allocsize(
AS =
  { 
PAL[
 => 
profile-sample-accurate
probe-stack
stack-probe-size
min-legal-vector-width
null-pointer-is-valid
nontemporal
cvtu
cvtps2pd
pmovsx
abs.cond
max.cond
min.cond
ctlz.trunc
ctpop
ctpop.trunc
Broken module found, compilation aborted!
clang.arc.retainAutoreleasedReturnValueMarker
Objective-C Class Properties
llvm.ctlz.
^arm\.neon\.vld([1234]|[234]lane)\.v[a-z0-9]*$
.p0i8
^arm\.neon\.vst([1234]|[234]lane)\.v[a-z0-9]*$
lane
palignr
vpmovm2
llvm.loop.interleave.count
llvm.loop.vectorize.
loop_header_weight
full-set
empty-set
Allocation failed
use-dbg-addr
Use llvm.dbg.addr for all local variables
Address space 0 can never be non-integral
Invalid address space, must be a 24bit integer
Missing size specification for pointer in datalayout string
Invalid pointer size of 0 bytes
Missing alignment specification for pointer in datalayout string
Pointer ABI alignment must be a power of 2
Pointer preferred alignment must be a power of 2
Invalid index size of 0 bytes
Sized aggregate specification in datalayout string
Missing alignment specification in datalayout string
ABI alignment specification must be >0 for non-aggregate types
Zero width native integer type in datalayout string
Unexpected trailing characters after mangling specifier in datalayout string
Expected mangling specifier in datalayout string
Unknown mangling specifier in datalayout string
Unknown mangling in datalayout string
Unknown specifier in datalayout string
Invalid bit width, must be a 24bit integer
Invalid ABI alignment, must be a 16bit integer
Invalid preferred alignment, must be a 16bit integer
Invalid ABI alignment, must be a power of 2
Invalid preferred alignment, must be a power of 2
Preferred alignment cannot be less than the ABI alignment
Trailing separator in datalayout string
Expected token before separator in datalayout string
not a number, or does not fit in an unsigned int
number of bits must be a byte width multiple
Invalid address space, must be a 24-bit integer
Allocation failed
Debug Info Version
DIFlagZero
DIFlagPrivate
DIFlagProtected
DIFlagPublic
DIFlagFwdDecl
DIFlagAppleBlock
DIFlagBlockByrefStruct
DIFlagVirtual
DIFlagArtificial
DIFlagExplicit
DIFlagPrototyped
DIFlagObjcClassComplete
DIFlagObjectPointer
DIFlagVector
DIFlagStaticMember
DIFlagLValueReference
DIFlagRValueReference
DIFlagReserved
DIFlagSingleInheritance
DIFlagMultipleInheritance
DIFlagVirtualInheritance
DIFlagIntroducedVirtual
DIFlagBitField
DIFlagNoReturn
DIFlagMainSubprogram
DIFlagTypePassByValue
DIFlagTypePassByReference
DIFlagFixedEnum
DIFlagThunk
DIFlagTrivial
DIFlagIndirectVirtualBase
CSK_MD5
CSK_SHA1
NoDebug
FullDebug
LineTablesOnly
pass-remarks
pattern
Enable optimization remarks from passes whose name match the given regular expression
pass-remarks-missed
Enable missed optimization remarks from passes whose name match the given regular expression
pass-remarks-analysis
Enable optimization analysis remarks from passes whose name match the given regular expression
Invalid regular expression '
' in -pass-remarks: 
 at line 
) in 
ignoring debug info with an invalid version (
ignoring invalid debug info in 
 (hotness: 
!Passed
!Missed
!Analysis
!AnalysisFPCommute
!AnalysisAliasing
!Failure
Pass
Name
DebugLoc
Function
Hotness
Args
String
^(\.[0-9]+|[0-9]+(\.[0-9]*)?)([eE][-+]?[0-9]+)?$
File
Line
Column
verify-dom-info
Verify dominator info (time consuming)
Inorder PostDominator Tree: 
Roots: 
PendUpdates:
Insert, 
Delete, 
(no name)
(badref), 
(no_name)
(badref)
DeletedBBs:
(no_name)(
Dominator Tree Construction
domtree
llvm.
aarch64
amdgcn
hexagon
mips
nvvm
r600
s390
xcore
null-pointer-is-valid
true
wasm
not_intrinsic
llvm.addressofreturnaddress
llvm.adjust.trampoline
llvm.annotation
llvm.assume
llvm.bitreverse
llvm.bswap
llvm.canonicalize
llvm.ceil
llvm.clear_cache
llvm.codeview.annotation
llvm.convert.from.fp16
llvm.convert.to.fp16
llvm.copysign
llvm.coro.alloc
llvm.coro.begin
llvm.coro.destroy
llvm.coro.done
llvm.coro.end
llvm.coro.frame
llvm.coro.free
llvm.coro.id
llvm.coro.noop
llvm.coro.param
llvm.coro.promise
llvm.coro.resume
llvm.coro.save
llvm.coro.size
llvm.coro.subfn.addr
llvm.coro.suspend
llvm.cos
llvm.ctlz
llvm.ctpop
llvm.cttz
llvm.dbg.addr
llvm.dbg.declare
llvm.dbg.label
llvm.dbg.value
llvm.debugtrap
llvm.donothing
llvm.eh.dwarf.cfa
llvm.eh.exceptioncode
llvm.eh.exceptionpointer
llvm.eh.return.i32
llvm.eh.return.i64
llvm.eh.sjlj.callsite
llvm.eh.sjlj.functioncontext
llvm.eh.sjlj.longjmp
llvm.eh.sjlj.lsda
llvm.eh.sjlj.setjmp
llvm.eh.sjlj.setup.dispatch
llvm.eh.typeid.for
llvm.eh.unwind.init
llvm.exp
llvm.exp2
llvm.expect
llvm.experimental.constrained.cos
llvm.experimental.constrained.exp
llvm.experimental.constrained.exp2
llvm.experimental.constrained.fadd
llvm.experimental.constrained.fdiv
llvm.experimental.constrained.fma
llvm.experimental.constrained.fmul
llvm.experimental.constrained.frem
llvm.experimental.constrained.fsub
llvm.experimental.constrained.log
llvm.experimental.constrained.log10
llvm.experimental.constrained.log2
llvm.experimental.constrained.nearbyint
llvm.experimental.constrained.pow
llvm.experimental.constrained.powi
llvm.experimental.constrained.rint
llvm.experimental.constrained.sin
llvm.experimental.constrained.sqrt
llvm.experimental.deoptimize
llvm.experimental.gc.relocate
llvm.experimental.gc.result
llvm.experimental.gc.statepoint
llvm.experimental.guard
llvm.experimental.patchpoint.i64
llvm.experimental.patchpoint.void
llvm.experimental.stackmap
llvm.experimental.vector.reduce.add
llvm.experimental.vector.reduce.and
llvm.experimental.vector.reduce.fadd
llvm.experimental.vector.reduce.fmax
llvm.experimental.vector.reduce.fmin
llvm.experimental.vector.reduce.fmul
llvm.experimental.vector.reduce.mul
llvm.experimental.vector.reduce.or
llvm.experimental.vector.reduce.smax
llvm.experimental.vector.reduce.smin
llvm.experimental.vector.reduce.umax
llvm.experimental.vector.reduce.umin
llvm.experimental.vector.reduce.xor
llvm.fabs
llvm.floor
llvm.flt.rounds
llvm.fma
llvm.fmuladd
llvm.frameaddress
llvm.fshl
llvm.fshr
llvm.gcread
llvm.gcroot
llvm.gcwrite
llvm.get.dynamic.area.offset
llvm.icall.branch.funnel
llvm.init.trampoline
llvm.instrprof.increment
llvm.instrprof.increment.step
llvm.instrprof.value.profile
llvm.invariant.end
llvm.invariant.start
llvm.launder.invariant.group
llvm.lifetime.end
llvm.lifetime.start
llvm.load.relative
llvm.localaddress
llvm.localescape
llvm.localrecover
llvm.log
llvm.log10
llvm.log2
llvm.longjmp
llvm.masked.compressstore
llvm.masked.expandload
llvm.masked.gather
llvm.masked.load
llvm.masked.scatter
llvm.masked.store
llvm.maxnum
llvm.memcpy
llvm.memcpy.element.unordered.atomic
llvm.memmove
llvm.memmove.element.unordered.atomic
llvm.memset
llvm.memset.element.unordered.atomic
llvm.minnum
llvm.nearbyint
llvm.objectsize
llvm.pcmarker
llvm.pow
llvm.powi
llvm.prefetch
llvm.ptr.annotation
llvm.read_register
llvm.readcyclecounter
llvm.returnaddress
llvm.rint
llvm.round
llvm.sadd.with.overflow
llvm.setjmp
llvm.sideeffect
llvm.siglongjmp
llvm.sigsetjmp
llvm.sin
llvm.smul.with.overflow
llvm.sqrt
llvm.ssa.copy
llvm.ssub.with.overflow
llvm.stackguard
llvm.stackprotector
llvm.stackrestore
llvm.stacksave
llvm.strip.invariant.group
llvm.thread.pointer
llvm.trap
llvm.trunc
llvm.type.checked.load
llvm.type.test
llvm.uadd.with.overflow
llvm.umul.with.overflow
llvm.usub.with.overflow
llvm.va_copy
llvm.va_end
llvm.va_start
llvm.var.annotation
llvm.write_register
llvm.xray.customevent
llvm.xray.typedevent
llvm.aarch64.clrex
llvm.aarch64.crc32b
llvm.aarch64.crc32cb
llvm.aarch64.crc32ch
llvm.aarch64.crc32cw
llvm.aarch64.crc32cx
llvm.aarch64.crc32h
llvm.aarch64.crc32w
llvm.aarch64.crc32x
llvm.aarch64.crypto.aesd
llvm.aarch64.crypto.aese
llvm.aarch64.crypto.aesimc
llvm.aarch64.crypto.aesmc
llvm.aarch64.crypto.sha1c
llvm.aarch64.crypto.sha1h
llvm.aarch64.crypto.sha1m
llvm.aarch64.crypto.sha1p
llvm.aarch64.crypto.sha1su0
llvm.aarch64.crypto.sha1su1
llvm.aarch64.crypto.sha256h
llvm.aarch64.crypto.sha256h2
llvm.aarch64.crypto.sha256su0
llvm.aarch64.crypto.sha256su1
llvm.aarch64.dmb
llvm.aarch64.dsb
llvm.aarch64.get.fpcr
llvm.aarch64.hint
llvm.aarch64.isb
llvm.aarch64.ldaxp
llvm.aarch64.ldaxr
llvm.aarch64.ldxp
llvm.aarch64.ldxr
llvm.aarch64.neon.abs
llvm.aarch64.neon.addhn
llvm.aarch64.neon.addp
llvm.aarch64.neon.cls
llvm.aarch64.neon.fabd
llvm.aarch64.neon.facge
llvm.aarch64.neon.facgt
llvm.aarch64.neon.faddv
llvm.aarch64.neon.fcvtas
llvm.aarch64.neon.fcvtau
llvm.aarch64.neon.fcvtms
llvm.aarch64.neon.fcvtmu
llvm.aarch64.neon.fcvtns
llvm.aarch64.neon.fcvtnu
llvm.aarch64.neon.fcvtps
llvm.aarch64.neon.fcvtpu
llvm.aarch64.neon.fcvtxn
llvm.aarch64.neon.fcvtzs
llvm.aarch64.neon.fcvtzu
llvm.aarch64.neon.fmax
llvm.aarch64.neon.fmaxnm
llvm.aarch64.neon.fmaxnmp
llvm.aarch64.neon.fmaxnmv
llvm.aarch64.neon.fmaxp
llvm.aarch64.neon.fmaxv
llvm.aarch64.neon.fmin
llvm.aarch64.neon.fminnm
llvm.aarch64.neon.fminnmp
llvm.aarch64.neon.fminnmv
llvm.aarch64.neon.fminp
llvm.aarch64.neon.fminv
llvm.aarch64.neon.fmulx
llvm.aarch64.neon.frecpe
llvm.aarch64.neon.frecps
llvm.aarch64.neon.frecpx
llvm.aarch64.neon.frintn
llvm.aarch64.neon.frsqrte
llvm.aarch64.neon.frsqrts
llvm.aarch64.neon.ld1x2
llvm.aarch64.neon.ld1x3
llvm.aarch64.neon.ld1x4
llvm.aarch64.neon.ld2
llvm.aarch64.neon.ld2lane
llvm.aarch64.neon.ld2r
llvm.aarch64.neon.ld3
llvm.aarch64.neon.ld3lane
llvm.aarch64.neon.ld3r
llvm.aarch64.neon.ld4
llvm.aarch64.neon.ld4lane
llvm.aarch64.neon.ld4r
llvm.aarch64.neon.pmul
llvm.aarch64.neon.pmull
llvm.aarch64.neon.pmull64
llvm.aarch64.neon.raddhn
llvm.aarch64.neon.rbit
llvm.aarch64.neon.rshrn
llvm.aarch64.neon.rsubhn
llvm.aarch64.neon.sabd
llvm.aarch64.neon.saddlp
llvm.aarch64.neon.saddlv
llvm.aarch64.neon.saddv
llvm.aarch64.neon.scalar.sqxtn
llvm.aarch64.neon.scalar.sqxtun
llvm.aarch64.neon.scalar.uqxtn
llvm.aarch64.neon.sdot
llvm.aarch64.neon.shadd
llvm.aarch64.neon.shll
llvm.aarch64.neon.shsub
llvm.aarch64.neon.smax
llvm.aarch64.neon.smaxp
llvm.aarch64.neon.smaxv
llvm.aarch64.neon.smin
llvm.aarch64.neon.sminp
llvm.aarch64.neon.sminv
llvm.aarch64.neon.smull
llvm.aarch64.neon.sqabs
llvm.aarch64.neon.sqadd
llvm.aarch64.neon.sqdmulh
llvm.aarch64.neon.sqdmull
llvm.aarch64.neon.sqdmulls.scalar
llvm.aarch64.neon.sqneg
llvm.aarch64.neon.sqrdmulh
llvm.aarch64.neon.sqrshl
llvm.aarch64.neon.sqrshrn
llvm.aarch64.neon.sqrshrun
llvm.aarch64.neon.sqshl
llvm.aarch64.neon.sqshlu
llvm.aarch64.neon.sqshrn
llvm.aarch64.neon.sqshrun
llvm.aarch64.neon.sqsub
llvm.aarch64.neon.sqxtn
llvm.aarch64.neon.sqxtun
llvm.aarch64.neon.srhadd
llvm.aarch64.neon.srshl
llvm.aarch64.neon.sshl
llvm.aarch64.neon.sshll
llvm.aarch64.neon.st1x2
llvm.aarch64.neon.st1x3
llvm.aarch64.neon.st1x4
llvm.aarch64.neon.st2
llvm.aarch64.neon.st2lane
llvm.aarch64.neon.st3
llvm.aarch64.neon.st3lane
llvm.aarch64.neon.st4
llvm.aarch64.neon.st4lane
llvm.aarch64.neon.subhn
llvm.aarch64.neon.suqadd
llvm.aarch64.neon.tbl1
llvm.aarch64.neon.tbl2
llvm.aarch64.neon.tbl3
llvm.aarch64.neon.tbl4
llvm.aarch64.neon.tbx1
llvm.aarch64.neon.tbx2
llvm.aarch64.neon.tbx3
llvm.aarch64.neon.tbx4
llvm.aarch64.neon.uabd
llvm.aarch64.neon.uaddlp
llvm.aarch64.neon.uaddlv
llvm.aarch64.neon.uaddv
llvm.aarch64.neon.udot
llvm.aarch64.neon.uhadd
llvm.aarch64.neon.uhsub
llvm.aarch64.neon.umax
llvm.aarch64.neon.umaxp
llvm.aarch64.neon.umaxv
llvm.aarch64.neon.umin
llvm.aarch64.neon.uminp
llvm.aarch64.neon.uminv
llvm.aarch64.neon.umull
llvm.aarch64.neon.uqadd
llvm.aarch64.neon.uqrshl
llvm.aarch64.neon.uqrshrn
llvm.aarch64.neon.uqshl
llvm.aarch64.neon.uqshrn
llvm.aarch64.neon.uqsub
llvm.aarch64.neon.uqxtn
llvm.aarch64.neon.urecpe
llvm.aarch64.neon.urhadd
llvm.aarch64.neon.urshl
llvm.aarch64.neon.ursqrte
llvm.aarch64.neon.ushl
llvm.aarch64.neon.ushll
llvm.aarch64.neon.usqadd
llvm.aarch64.neon.vcopy.lane
llvm.aarch64.neon.vcvtfp2fxs
llvm.aarch64.neon.vcvtfp2fxu
llvm.aarch64.neon.vcvtfp2hf
llvm.aarch64.neon.vcvtfxs2fp
llvm.aarch64.neon.vcvtfxu2fp
llvm.aarch64.neon.vcvthf2fp
llvm.aarch64.neon.vsli
llvm.aarch64.neon.vsri
llvm.aarch64.sdiv
llvm.aarch64.sisd.fabd
llvm.aarch64.sisd.fcvtxn
llvm.aarch64.stlxp
llvm.aarch64.stlxr
llvm.aarch64.stxp
llvm.aarch64.stxr
llvm.aarch64.udiv
llvm.amdgcn.alignbit
llvm.amdgcn.alignbyte
llvm.amdgcn.atomic.dec
llvm.amdgcn.atomic.inc
llvm.amdgcn.break
llvm.amdgcn.buffer.atomic.add
llvm.amdgcn.buffer.atomic.and
llvm.amdgcn.buffer.atomic.cmpswap
llvm.amdgcn.buffer.atomic.or
llvm.amdgcn.buffer.atomic.smax
llvm.amdgcn.buffer.atomic.smin
llvm.amdgcn.buffer.atomic.sub
llvm.amdgcn.buffer.atomic.swap
llvm.amdgcn.buffer.atomic.umax
llvm.amdgcn.buffer.atomic.umin
llvm.amdgcn.buffer.atomic.xor
llvm.amdgcn.buffer.load
llvm.amdgcn.buffer.load.format
llvm.amdgcn.buffer.store
llvm.amdgcn.buffer.store.format
llvm.amdgcn.buffer.wbinvl1
llvm.amdgcn.buffer.wbinvl1.sc
llvm.amdgcn.buffer.wbinvl1.vol
llvm.amdgcn.class
llvm.amdgcn.cos
llvm.amdgcn.cubeid
llvm.amdgcn.cubema
llvm.amdgcn.cubesc
llvm.amdgcn.cubetc
llvm.amdgcn.cvt.pk.i16
llvm.amdgcn.cvt.pk.u16
llvm.amdgcn.cvt.pk.u8.f32
llvm.amdgcn.cvt.pknorm.i16
llvm.amdgcn.cvt.pknorm.u16
llvm.amdgcn.cvt.pkrtz
llvm.amdgcn.dispatch.id
llvm.amdgcn.dispatch.ptr
llvm.amdgcn.div.fixup
llvm.amdgcn.div.fmas
llvm.amdgcn.div.scale
llvm.amdgcn.ds.bpermute
llvm.amdgcn.ds.fadd
llvm.amdgcn.ds.fmax
llvm.amdgcn.ds.fmin
llvm.amdgcn.ds.permute
llvm.amdgcn.ds.swizzle
llvm.amdgcn.else
llvm.amdgcn.else.break
llvm.amdgcn.end.cf
llvm.amdgcn.exp
llvm.amdgcn.exp.compr
llvm.amdgcn.fcmp
llvm.amdgcn.fdiv.fast
llvm.amdgcn.fdot2
llvm.amdgcn.fmad.ftz
llvm.amdgcn.fmed3
llvm.amdgcn.fmul.legacy
llvm.amdgcn.fract
llvm.amdgcn.frexp.exp
llvm.amdgcn.frexp.mant
llvm.amdgcn.groupstaticsize
llvm.amdgcn.icmp
llvm.amdgcn.if
llvm.amdgcn.if.break
llvm.amdgcn.image.atomic.add.1d
llvm.amdgcn.image.atomic.add.1darray
llvm.amdgcn.image.atomic.add.2d
llvm.amdgcn.image.atomic.add.2darray
llvm.amdgcn.image.atomic.add.2darraymsaa
llvm.amdgcn.image.atomic.add.2dmsaa
llvm.amdgcn.image.atomic.add.3d
llvm.amdgcn.image.atomic.add.cube
llvm.amdgcn.image.atomic.and.1d
llvm.amdgcn.image.atomic.and.1darray
llvm.amdgcn.image.atomic.and.2d
llvm.amdgcn.image.atomic.and.2darray
llvm.amdgcn.image.atomic.and.2darraymsaa
llvm.amdgcn.image.atomic.and.2dmsaa
llvm.amdgcn.image.atomic.and.3d
llvm.amdgcn.image.atomic.and.cube
llvm.amdgcn.image.atomic.cmpswap.1d
llvm.amdgcn.image.atomic.cmpswap.1darray
llvm.amdgcn.image.atomic.cmpswap.2d
llvm.amdgcn.image.atomic.cmpswap.2darray
llvm.amdgcn.image.atomic.cmpswap.2darraymsaa
llvm.amdgcn.image.atomic.cmpswap.2dmsaa
llvm.amdgcn.image.atomic.cmpswap.3d
llvm.amdgcn.image.atomic.cmpswap.cube
llvm.amdgcn.image.atomic.dec.1d
llvm.amdgcn.image.atomic.dec.1darray
llvm.amdgcn.image.atomic.dec.2d
llvm.amdgcn.image.atomic.dec.2darray
llvm.amdgcn.image.atomic.dec.2darraymsaa
llvm.amdgcn.image.atomic.dec.2dmsaa
llvm.amdgcn.image.atomic.dec.3d
llvm.amdgcn.image.atomic.dec.cube
llvm.amdgcn.image.atomic.inc.1d
llvm.amdgcn.image.atomic.inc.1darray
llvm.amdgcn.image.atomic.inc.2d
llvm.amdgcn.image.atomic.inc.2darray
llvm.amdgcn.image.atomic.inc.2darraymsaa
llvm.amdgcn.image.atomic.inc.2dmsaa
llvm.amdgcn.image.atomic.inc.3d
llvm.amdgcn.image.atomic.inc.cube
llvm.amdgcn.image.atomic.or.1d
llvm.amdgcn.image.atomic.or.1darray
llvm.amdgcn.image.atomic.or.2d
llvm.amdgcn.image.atomic.or.2darray
llvm.amdgcn.image.atomic.or.2darraymsaa
llvm.amdgcn.image.atomic.or.2dmsaa
llvm.amdgcn.image.atomic.or.3d
llvm.amdgcn.image.atomic.or.cube
llvm.amdgcn.image.atomic.smax.1d
llvm.amdgcn.image.atomic.smax.1darray
llvm.amdgcn.image.atomic.smax.2d
llvm.amdgcn.image.atomic.smax.2darray
llvm.amdgcn.image.atomic.smax.2darraymsaa
llvm.amdgcn.image.atomic.smax.2dmsaa
llvm.amdgcn.image.atomic.smax.3d
llvm.amdgcn.image.atomic.smax.cube
llvm.amdgcn.image.atomic.smin.1d
llvm.amdgcn.image.atomic.smin.1darray
llvm.amdgcn.image.atomic.smin.2d
llvm.amdgcn.image.atomic.smin.2darray
llvm.amdgcn.image.atomic.smin.2darraymsaa
llvm.amdgcn.image.atomic.smin.2dmsaa
llvm.amdgcn.image.atomic.smin.3d
llvm.amdgcn.image.atomic.smin.cube
llvm.amdgcn.image.atomic.sub.1d
llvm.amdgcn.image.atomic.sub.1darray
llvm.amdgcn.image.atomic.sub.2d
llvm.amdgcn.image.atomic.sub.2darray
llvm.amdgcn.image.atomic.sub.2darraymsaa
llvm.amdgcn.image.atomic.sub.2dmsaa
llvm.amdgcn.image.atomic.sub.3d
llvm.amdgcn.image.atomic.sub.cube
llvm.amdgcn.image.atomic.swap.1d
llvm.amdgcn.image.atomic.swap.1darray
llvm.amdgcn.image.atomic.swap.2d
llvm.amdgcn.image.atomic.swap.2darray
llvm.amdgcn.image.atomic.swap.2darraymsaa
llvm.amdgcn.image.atomic.swap.2dmsaa
llvm.amdgcn.image.atomic.swap.3d
llvm.amdgcn.image.atomic.swap.cube
llvm.amdgcn.image.atomic.umax.1d
llvm.amdgcn.image.atomic.umax.1darray
llvm.amdgcn.image.atomic.umax.2d
llvm.amdgcn.image.atomic.umax.2darray
llvm.amdgcn.image.atomic.umax.2darraymsaa
llvm.amdgcn.image.atomic.umax.2dmsaa
llvm.amdgcn.image.atomic.umax.3d
llvm.amdgcn.image.atomic.umax.cube
llvm.amdgcn.image.atomic.umin.1d
llvm.amdgcn.image.atomic.umin.1darray
llvm.amdgcn.image.atomic.umin.2d
llvm.amdgcn.image.atomic.umin.2darray
llvm.amdgcn.image.atomic.umin.2darraymsaa
llvm.amdgcn.image.atomic.umin.2dmsaa
llvm.amdgcn.image.atomic.umin.3d
llvm.amdgcn.image.atomic.umin.cube
llvm.amdgcn.image.atomic.xor.1d
llvm.amdgcn.image.atomic.xor.1darray
llvm.amdgcn.image.atomic.xor.2d
llvm.amdgcn.image.atomic.xor.2darray
llvm.amdgcn.image.atomic.xor.2darraymsaa
llvm.amdgcn.image.atomic.xor.2dmsaa
llvm.amdgcn.image.atomic.xor.3d
llvm.amdgcn.image.atomic.xor.cube
llvm.amdgcn.image.gather4.2d
llvm.amdgcn.image.gather4.2darray
llvm.amdgcn.image.gather4.b.2d
llvm.amdgcn.image.gather4.b.2darray
llvm.amdgcn.image.gather4.b.cl.2d
llvm.amdgcn.image.gather4.b.cl.2darray
llvm.amdgcn.image.gather4.b.cl.cube
llvm.amdgcn.image.gather4.b.cl.o.2d
llvm.amdgcn.image.gather4.b.cl.o.2darray
llvm.amdgcn.image.gather4.b.cl.o.cube
llvm.amdgcn.image.gather4.b.cube
llvm.amdgcn.image.gather4.b.o.2d
llvm.amdgcn.image.gather4.b.o.2darray
llvm.amdgcn.image.gather4.b.o.cube
llvm.amdgcn.image.gather4.c.2d
llvm.amdgcn.image.gather4.c.2darray
llvm.amdgcn.image.gather4.c.b.2d
llvm.amdgcn.image.gather4.c.b.2darray
llvm.amdgcn.image.gather4.c.b.cl.2d
llvm.amdgcn.image.gather4.c.b.cl.2darray
llvm.amdgcn.image.gather4.c.b.cl.cube
llvm.amdgcn.image.gather4.c.b.cl.o.2d
llvm.amdgcn.image.gather4.c.b.cl.o.2darray
llvm.amdgcn.image.gather4.c.b.cl.o.cube
llvm.amdgcn.image.gather4.c.b.cube
llvm.amdgcn.image.gather4.c.b.o.2d
llvm.amdgcn.image.gather4.c.b.o.2darray
llvm.amdgcn.image.gather4.c.b.o.cube
llvm.amdgcn.image.gather4.c.cl.2d
llvm.amdgcn.image.gather4.c.cl.2darray
llvm.amdgcn.image.gather4.c.cl.cube
llvm.amdgcn.image.gather4.c.cl.o.2d
llvm.amdgcn.image.gather4.c.cl.o.2darray
llvm.amdgcn.image.gather4.c.cl.o.cube
llvm.amdgcn.image.gather4.c.cube
llvm.amdgcn.image.gather4.c.l.2d
llvm.amdgcn.image.gather4.c.l.2darray
llvm.amdgcn.image.gather4.c.l.cube
llvm.amdgcn.image.gather4.c.l.o.2d
llvm.amdgcn.image.gather4.c.l.o.2darray
llvm.amdgcn.image.gather4.c.l.o.cube
llvm.amdgcn.image.gather4.c.lz.2d
llvm.amdgcn.image.gather4.c.lz.2darray
llvm.amdgcn.image.gather4.c.lz.cube
llvm.amdgcn.image.gather4.c.lz.o.2d
llvm.amdgcn.image.gather4.c.lz.o.2darray
llvm.amdgcn.image.gather4.c.lz.o.cube
llvm.amdgcn.image.gather4.c.o.2d
llvm.amdgcn.image.gather4.c.o.2darray
llvm.amdgcn.image.gather4.c.o.cube
llvm.amdgcn.image.gather4.cl.2d
llvm.amdgcn.image.gather4.cl.2darray
llvm.amdgcn.image.gather4.cl.cube
llvm.amdgcn.image.gather4.cl.o.2d
llvm.amdgcn.image.gather4.cl.o.2darray
llvm.amdgcn.image.gather4.cl.o.cube
llvm.amdgcn.image.gather4.cube
llvm.amdgcn.image.gather4.l.2d
llvm.amdgcn.image.gather4.l.2darray
llvm.amdgcn.image.gather4.l.cube
llvm.amdgcn.image.gather4.l.o.2d
llvm.amdgcn.image.gather4.l.o.2darray
llvm.amdgcn.image.gather4.l.o.cube
llvm.amdgcn.image.gather4.lz.2d
llvm.amdgcn.image.gather4.lz.2darray
llvm.amdgcn.image.gather4.lz.cube
llvm.amdgcn.image.gather4.lz.o.2d
llvm.amdgcn.image.gather4.lz.o.2darray
llvm.amdgcn.image.gather4.lz.o.cube
llvm.amdgcn.image.gather4.o.2d
llvm.amdgcn.image.gather4.o.2darray
llvm.amdgcn.image.gather4.o.cube
llvm.amdgcn.image.getlod.1d
llvm.amdgcn.image.getlod.1darray
llvm.amdgcn.image.getlod.2d
llvm.amdgcn.image.getlod.2darray
llvm.amdgcn.image.getlod.3d
llvm.amdgcn.image.getlod.cube
llvm.amdgcn.image.getresinfo.1d
llvm.amdgcn.image.getresinfo.1darray
llvm.amdgcn.image.getresinfo.2d
llvm.amdgcn.image.getresinfo.2darray
llvm.amdgcn.image.getresinfo.2darraymsaa
llvm.amdgcn.image.getresinfo.2dmsaa
llvm.amdgcn.image.getresinfo.3d
llvm.amdgcn.image.getresinfo.cube
llvm.amdgcn.image.load.1d
llvm.amdgcn.image.load.1darray
llvm.amdgcn.image.load.2d
llvm.amdgcn.image.load.2darray
llvm.amdgcn.image.load.2darraymsaa
llvm.amdgcn.image.load.2dmsaa
llvm.amdgcn.image.load.3d
llvm.amdgcn.image.load.cube
llvm.amdgcn.image.load.mip.1d
llvm.amdgcn.image.load.mip.1darray
llvm.amdgcn.image.load.mip.2d
llvm.amdgcn.image.load.mip.2darray
llvm.amdgcn.image.load.mip.3d
llvm.amdgcn.image.load.mip.cube
llvm.amdgcn.image.sample.1d
llvm.amdgcn.image.sample.1darray
llvm.amdgcn.image.sample.2d
llvm.amdgcn.image.sample.2darray
llvm.amdgcn.image.sample.3d
llvm.amdgcn.image.sample.b.1d
llvm.amdgcn.image.sample.b.1darray
llvm.amdgcn.image.sample.b.2d
llvm.amdgcn.image.sample.b.2darray
llvm.amdgcn.image.sample.b.3d
llvm.amdgcn.image.sample.b.cl.1d
llvm.amdgcn.image.sample.b.cl.1darray
llvm.amdgcn.image.sample.b.cl.2d
llvm.amdgcn.image.sample.b.cl.2darray
llvm.amdgcn.image.sample.b.cl.3d
llvm.amdgcn.image.sample.b.cl.cube
llvm.amdgcn.image.sample.b.cl.o.1d
llvm.amdgcn.image.sample.b.cl.o.1darray
llvm.amdgcn.image.sample.b.cl.o.2d
llvm.amdgcn.image.sample.b.cl.o.2darray
llvm.amdgcn.image.sample.b.cl.o.3d
llvm.amdgcn.image.sample.b.cl.o.cube
llvm.amdgcn.image.sample.b.cube
llvm.amdgcn.image.sample.b.o.1d
llvm.amdgcn.image.sample.b.o.1darray
llvm.amdgcn.image.sample.b.o.2d
llvm.amdgcn.image.sample.b.o.2darray
llvm.amdgcn.image.sample.b.o.3d
llvm.amdgcn.image.sample.b.o.cube
llvm.amdgcn.image.sample.c.1d
llvm.amdgcn.image.sample.c.1darray
llvm.amdgcn.image.sample.c.2d
llvm.amdgcn.image.sample.c.2darray
llvm.amdgcn.image.sample.c.3d
llvm.amdgcn.image.sample.c.b.1d
llvm.amdgcn.image.sample.c.b.1darray
llvm.amdgcn.image.sample.c.b.2d
llvm.amdgcn.image.sample.c.b.2darray
llvm.amdgcn.image.sample.c.b.3d
llvm.amdgcn.image.sample.c.b.cl.1d
llvm.amdgcn.image.sample.c.b.cl.1darray
llvm.amdgcn.image.sample.c.b.cl.2d
llvm.amdgcn.image.sample.c.b.cl.2darray
llvm.amdgcn.image.sample.c.b.cl.3d
llvm.amdgcn.image.sample.c.b.cl.cube
llvm.amdgcn.image.sample.c.b.cl.o.1d
llvm.amdgcn.image.sample.c.b.cl.o.1darray
llvm.amdgcn.image.sample.c.b.cl.o.2d
llvm.amdgcn.image.sample.c.b.cl.o.2darray
llvm.amdgcn.image.sample.c.b.cl.o.3d
llvm.amdgcn.image.sample.c.b.cl.o.cube
llvm.amdgcn.image.sample.c.b.cube
llvm.amdgcn.image.sample.c.b.o.1d
llvm.amdgcn.image.sample.c.b.o.1darray
llvm.amdgcn.image.sample.c.b.o.2d
llvm.amdgcn.image.sample.c.b.o.2darray
llvm.amdgcn.image.sample.c.b.o.3d
llvm.amdgcn.image.sample.c.b.o.cube
llvm.amdgcn.image.sample.c.cd.1d
llvm.amdgcn.image.sample.c.cd.1darray
llvm.amdgcn.image.sample.c.cd.2d
llvm.amdgcn.image.sample.c.cd.2darray
llvm.amdgcn.image.sample.c.cd.3d
llvm.amdgcn.image.sample.c.cd.cl.1d
llvm.amdgcn.image.sample.c.cd.cl.1darray
llvm.amdgcn.image.sample.c.cd.cl.2d
llvm.amdgcn.image.sample.c.cd.cl.2darray
llvm.amdgcn.image.sample.c.cd.cl.3d
llvm.amdgcn.image.sample.c.cd.cl.cube
llvm.amdgcn.image.sample.c.cd.cl.o.1d
llvm.amdgcn.image.sample.c.cd.cl.o.1darray
llvm.amdgcn.image.sample.c.cd.cl.o.2d
llvm.amdgcn.image.sample.c.cd.cl.o.2darray
llvm.amdgcn.image.sample.c.cd.cl.o.3d
llvm.amdgcn.image.sample.c.cd.cl.o.cube
llvm.amdgcn.image.sample.c.cd.cube
llvm.amdgcn.image.sample.c.cd.o.1d
llvm.amdgcn.image.sample.c.cd.o.1darray
llvm.amdgcn.image.sample.c.cd.o.2d
llvm.amdgcn.image.sample.c.cd.o.2darray
llvm.amdgcn.image.sample.c.cd.o.3d
llvm.amdgcn.image.sample.c.cd.o.cube
llvm.amdgcn.image.sample.c.cl.1d
llvm.amdgcn.image.sample.c.cl.1darray
llvm.amdgcn.image.sample.c.cl.2d
llvm.amdgcn.image.sample.c.cl.2darray
llvm.amdgcn.image.sample.c.cl.3d
llvm.amdgcn.image.sample.c.cl.cube
llvm.amdgcn.image.sample.c.cl.o.1d
llvm.amdgcn.image.sample.c.cl.o.1darray
llvm.amdgcn.image.sample.c.cl.o.2d
llvm.amdgcn.image.sample.c.cl.o.2darray
llvm.amdgcn.image.sample.c.cl.o.3d
llvm.amdgcn.image.sample.c.cl.o.cube
llvm.amdgcn.image.sample.c.cube
llvm.amdgcn.image.sample.c.d.1d
llvm.amdgcn.image.sample.c.d.1darray
llvm.amdgcn.image.sample.c.d.2d
llvm.amdgcn.image.sample.c.d.2darray
llvm.amdgcn.image.sample.c.d.3d
llvm.amdgcn.image.sample.c.d.cl.1d
llvm.amdgcn.image.sample.c.d.cl.1darray
llvm.amdgcn.image.sample.c.d.cl.2d
llvm.amdgcn.image.sample.c.d.cl.2darray
llvm.amdgcn.image.sample.c.d.cl.3d
llvm.amdgcn.image.sample.c.d.cl.cube
llvm.amdgcn.image.sample.c.d.cl.o.1d
llvm.amdgcn.image.sample.c.d.cl.o.1darray
llvm.amdgcn.image.sample.c.d.cl.o.2d
llvm.amdgcn.image.sample.c.d.cl.o.2darray
llvm.amdgcn.image.sample.c.d.cl.o.3d
llvm.amdgcn.image.sample.c.d.cl.o.cube
llvm.amdgcn.image.sample.c.d.cube
llvm.amdgcn.image.sample.c.d.o.1d
llvm.amdgcn.image.sample.c.d.o.1darray
llvm.amdgcn.image.sample.c.d.o.2d
llvm.amdgcn.image.sample.c.d.o.2darray
llvm.amdgcn.image.sample.c.d.o.3d
llvm.amdgcn.image.sample.c.d.o.cube
llvm.amdgcn.image.sample.c.l.1d
llvm.amdgcn.image.sample.c.l.1darray
llvm.amdgcn.image.sample.c.l.2d
llvm.amdgcn.image.sample.c.l.2darray
llvm.amdgcn.image.sample.c.l.3d
llvm.amdgcn.image.sample.c.l.cube
llvm.amdgcn.image.sample.c.l.o.1d
llvm.amdgcn.image.sample.c.l.o.1darray
llvm.amdgcn.image.sample.c.l.o.2d
llvm.amdgcn.image.sample.c.l.o.2darray
llvm.amdgcn.image.sample.c.l.o.3d
llvm.amdgcn.image.sample.c.l.o.cube
llvm.amdgcn.image.sample.c.lz.1d
llvm.amdgcn.image.sample.c.lz.1darray
llvm.amdgcn.image.sample.c.lz.2d
llvm.amdgcn.image.sample.c.lz.2darray
llvm.amdgcn.image.sample.c.lz.3d
llvm.amdgcn.image.sample.c.lz.cube
llvm.amdgcn.image.sample.c.lz.o.1d
llvm.amdgcn.image.sample.c.lz.o.1darray
llvm.amdgcn.image.sample.c.lz.o.2d
llvm.amdgcn.image.sample.c.lz.o.2darray
llvm.amdgcn.image.sample.c.lz.o.3d
llvm.amdgcn.image.sample.c.lz.o.cube
llvm.amdgcn.image.sample.c.o.1d
llvm.amdgcn.image.sample.c.o.1darray
llvm.amdgcn.image.sample.c.o.2d
llvm.amdgcn.image.sample.c.o.2darray
llvm.amdgcn.image.sample.c.o.3d
llvm.amdgcn.image.sample.c.o.cube
llvm.amdgcn.image.sample.cd.1d
llvm.amdgcn.image.sample.cd.1darray
llvm.amdgcn.image.sample.cd.2d
llvm.amdgcn.image.sample.cd.2darray
llvm.amdgcn.image.sample.cd.3d
llvm.amdgcn.image.sample.cd.cl.1d
llvm.amdgcn.image.sample.cd.cl.1darray
llvm.amdgcn.image.sample.cd.cl.2d
llvm.amdgcn.image.sample.cd.cl.2darray
llvm.amdgcn.image.sample.cd.cl.3d
llvm.amdgcn.image.sample.cd.cl.cube
llvm.amdgcn.image.sample.cd.cl.o.1d
llvm.amdgcn.image.sample.cd.cl.o.1darray
llvm.amdgcn.image.sample.cd.cl.o.2d
llvm.amdgcn.image.sample.cd.cl.o.2darray
llvm.amdgcn.image.sample.cd.cl.o.3d
llvm.amdgcn.image.sample.cd.cl.o.cube
llvm.amdgcn.image.sample.cd.cube
llvm.amdgcn.image.sample.cd.o.1d
llvm.amdgcn.image.sample.cd.o.1darray
llvm.amdgcn.image.sample.cd.o.2d
llvm.amdgcn.image.sample.cd.o.2darray
llvm.amdgcn.image.sample.cd.o.3d
llvm.amdgcn.image.sample.cd.o.cube
llvm.amdgcn.image.sample.cl.1d
llvm.amdgcn.image.sample.cl.1darray
llvm.amdgcn.image.sample.cl.2d
llvm.amdgcn.image.sample.cl.2darray
llvm.amdgcn.image.sample.cl.3d
llvm.amdgcn.image.sample.cl.cube
llvm.amdgcn.image.sample.cl.o.1d
llvm.amdgcn.image.sample.cl.o.1darray
llvm.amdgcn.image.sample.cl.o.2d
llvm.amdgcn.image.sample.cl.o.2darray
llvm.amdgcn.image.sample.cl.o.3d
llvm.amdgcn.image.sample.cl.o.cube
llvm.amdgcn.image.sample.cube
llvm.amdgcn.image.sample.d.1d
llvm.amdgcn.image.sample.d.1darray
llvm.amdgcn.image.sample.d.2d
llvm.amdgcn.image.sample.d.2darray
llvm.amdgcn.image.sample.d.3d
llvm.amdgcn.image.sample.d.cl.1d
llvm.amdgcn.image.sample.d.cl.1darray
llvm.amdgcn.image.sample.d.cl.2d
llvm.amdgcn.image.sample.d.cl.2darray
llvm.amdgcn.image.sample.d.cl.3d
llvm.amdgcn.image.sample.d.cl.cube
llvm.amdgcn.image.sample.d.cl.o.1d
llvm.amdgcn.image.sample.d.cl.o.1darray
llvm.amdgcn.image.sample.d.cl.o.2d
llvm.amdgcn.image.sample.d.cl.o.2darray
llvm.amdgcn.image.sample.d.cl.o.3d
llvm.amdgcn.image.sample.d.cl.o.cube
llvm.amdgcn.image.sample.d.cube
llvm.amdgcn.image.sample.d.o.1d
llvm.amdgcn.image.sample.d.o.1darray
llvm.amdgcn.image.sample.d.o.2d
llvm.amdgcn.image.sample.d.o.2darray
llvm.amdgcn.image.sample.d.o.3d
llvm.amdgcn.image.sample.d.o.cube
llvm.amdgcn.image.sample.l.1d
llvm.amdgcn.image.sample.l.1darray
llvm.amdgcn.image.sample.l.2d
llvm.amdgcn.image.sample.l.2darray
llvm.amdgcn.image.sample.l.3d
llvm.amdgcn.image.sample.l.cube
llvm.amdgcn.image.sample.l.o.1d
llvm.amdgcn.image.sample.l.o.1darray
llvm.amdgcn.image.sample.l.o.2d
llvm.amdgcn.image.sample.l.o.2darray
llvm.amdgcn.image.sample.l.o.3d
llvm.amdgcn.image.sample.l.o.cube
llvm.amdgcn.image.sample.lz.1d
llvm.amdgcn.image.sample.lz.1darray
llvm.amdgcn.image.sample.lz.2d
llvm.amdgcn.image.sample.lz.2darray
llvm.amdgcn.image.sample.lz.3d
llvm.amdgcn.image.sample.lz.cube
llvm.amdgcn.image.sample.lz.o.1d
llvm.amdgcn.image.sample.lz.o.1darray
llvm.amdgcn.image.sample.lz.o.2d
llvm.amdgcn.image.sample.lz.o.2darray
llvm.amdgcn.image.sample.lz.o.3d
llvm.amdgcn.image.sample.lz.o.cube
llvm.amdgcn.image.sample.o.1d
llvm.amdgcn.image.sample.o.1darray
llvm.amdgcn.image.sample.o.2d
llvm.amdgcn.image.sample.o.2darray
llvm.amdgcn.image.sample.o.3d
llvm.amdgcn.image.sample.o.cube
llvm.amdgcn.image.store.1d
llvm.amdgcn.image.store.1darray
llvm.amdgcn.image.store.2d
llvm.amdgcn.image.store.2darray
llvm.amdgcn.image.store.2darraymsaa
llvm.amdgcn.image.store.2dmsaa
llvm.amdgcn.image.store.3d
llvm.amdgcn.image.store.cube
llvm.amdgcn.image.store.mip.1d
llvm.amdgcn.image.store.mip.1darray
llvm.amdgcn.image.store.mip.2d
llvm.amdgcn.image.store.mip.2darray
llvm.amdgcn.image.store.mip.3d
llvm.amdgcn.image.store.mip.cube
llvm.amdgcn.implicit.buffer.ptr
llvm.amdgcn.implicitarg.ptr
llvm.amdgcn.init.exec
llvm.amdgcn.init.exec.from.input
llvm.amdgcn.interp.mov
llvm.amdgcn.interp.p1
llvm.amdgcn.interp.p2
llvm.amdgcn.kernarg.segment.ptr
llvm.amdgcn.kill
llvm.amdgcn.ldexp
llvm.amdgcn.lerp
llvm.amdgcn.log.clamp
llvm.amdgcn.loop
llvm.amdgcn.mbcnt.hi
llvm.amdgcn.mbcnt.lo
llvm.amdgcn.mov.dpp
llvm.amdgcn.mqsad.pk.u16.u8
llvm.amdgcn.mqsad.u32.u8
llvm.amdgcn.msad.u8
llvm.amdgcn.ps.live
llvm.amdgcn.qsad.pk.u16.u8
llvm.amdgcn.queue.ptr
llvm.amdgcn.rcp
llvm.amdgcn.rcp.legacy
llvm.amdgcn.readfirstlane
llvm.amdgcn.readlane
llvm.amdgcn.rsq
llvm.amdgcn.rsq.clamp
llvm.amdgcn.rsq.legacy
llvm.amdgcn.s.barrier
llvm.amdgcn.s.dcache.inv
llvm.amdgcn.s.dcache.inv.vol
llvm.amdgcn.s.dcache.wb
llvm.amdgcn.s.dcache.wb.vol
llvm.amdgcn.s.decperflevel
llvm.amdgcn.s.getpc
llvm.amdgcn.s.getreg
llvm.amdgcn.s.incperflevel
llvm.amdgcn.s.memrealtime
llvm.amdgcn.s.memtime
llvm.amdgcn.s.sendmsg
llvm.amdgcn.s.sendmsghalt
llvm.amdgcn.s.sleep
llvm.amdgcn.s.waitcnt
llvm.amdgcn.sad.hi.u8
llvm.amdgcn.sad.u16
llvm.amdgcn.sad.u8
llvm.amdgcn.sbfe
llvm.amdgcn.sdot2
llvm.amdgcn.sdot4
llvm.amdgcn.sdot8
llvm.amdgcn.set.inactive
llvm.amdgcn.sffbh
llvm.amdgcn.sin
llvm.amdgcn.tbuffer.load
llvm.amdgcn.tbuffer.store
llvm.amdgcn.trig.preop
llvm.amdgcn.ubfe
llvm.amdgcn.udot2
llvm.amdgcn.udot4
llvm.amdgcn.udot8
llvm.amdgcn.unreachable
llvm.amdgcn.update.dpp
llvm.amdgcn.wave.barrier
llvm.amdgcn.workgroup.id.x
llvm.amdgcn.workgroup.id.y
llvm.amdgcn.workgroup.id.z
llvm.amdgcn.workitem.id.x
llvm.amdgcn.workitem.id.y
llvm.amdgcn.workitem.id.z
llvm.amdgcn.wqm
llvm.amdgcn.wqm.vote
llvm.amdgcn.writelane
llvm.amdgcn.wwm
llvm.arm.cdp
llvm.arm.cdp2
llvm.arm.clrex
llvm.arm.crc32b
llvm.arm.crc32cb
llvm.arm.crc32ch
llvm.arm.crc32cw
llvm.arm.crc32h
llvm.arm.crc32w
llvm.arm.dbg
llvm.arm.dmb
llvm.arm.dsb
llvm.arm.get.fpscr
llvm.arm.hint
llvm.arm.isb
llvm.arm.ldaex
llvm.arm.ldaexd
llvm.arm.ldc
llvm.arm.ldc2
llvm.arm.ldc2l
llvm.arm.ldcl
llvm.arm.ldrex
llvm.arm.ldrexd
llvm.arm.mcr
llvm.arm.mcr2
llvm.arm.mcrr
llvm.arm.mcrr2
llvm.arm.mrc
llvm.arm.mrc2
llvm.arm.mrrc
llvm.arm.mrrc2
llvm.arm.neon.aesd
llvm.arm.neon.aese
llvm.arm.neon.aesimc
llvm.arm.neon.aesmc
llvm.arm.neon.sdot
llvm.arm.neon.sha1c
llvm.arm.neon.sha1h
llvm.arm.neon.sha1m
llvm.arm.neon.sha1p
llvm.arm.neon.sha1su0
llvm.arm.neon.sha1su1
llvm.arm.neon.sha256h
llvm.arm.neon.sha256h2
llvm.arm.neon.sha256su0
llvm.arm.neon.sha256su1
llvm.arm.neon.udot
llvm.arm.neon.vabds
llvm.arm.neon.vabdu
llvm.arm.neon.vabs
llvm.arm.neon.vacge
llvm.arm.neon.vacgt
llvm.arm.neon.vbsl
llvm.arm.neon.vcls
llvm.arm.neon.vcvtas
llvm.arm.neon.vcvtau
llvm.arm.neon.vcvtfp2fxs
llvm.arm.neon.vcvtfp2fxu
llvm.arm.neon.vcvtfp2hf
llvm.arm.neon.vcvtfxs2fp
llvm.arm.neon.vcvtfxu2fp
llvm.arm.neon.vcvthf2fp
llvm.arm.neon.vcvtms
llvm.arm.neon.vcvtmu
llvm.arm.neon.vcvtns
llvm.arm.neon.vcvtnu
llvm.arm.neon.vcvtps
llvm.arm.neon.vcvtpu
llvm.arm.neon.vhadds
llvm.arm.neon.vhaddu
llvm.arm.neon.vhsubs
llvm.arm.neon.vhsubu
llvm.arm.neon.vld1
llvm.arm.neon.vld1x2
llvm.arm.neon.vld1x3
llvm.arm.neon.vld1x4
llvm.arm.neon.vld2
llvm.arm.neon.vld2dup
llvm.arm.neon.vld2lane
llvm.arm.neon.vld3
llvm.arm.neon.vld3dup
llvm.arm.neon.vld3lane
llvm.arm.neon.vld4
llvm.arm.neon.vld4dup
llvm.arm.neon.vld4lane
llvm.arm.neon.vmaxnm
llvm.arm.neon.vmaxs
llvm.arm.neon.vmaxu
llvm.arm.neon.vminnm
llvm.arm.neon.vmins
llvm.arm.neon.vminu
llvm.arm.neon.vmullp
llvm.arm.neon.vmulls
llvm.arm.neon.vmullu
llvm.arm.neon.vmulp
llvm.arm.neon.vpadals
llvm.arm.neon.vpadalu
llvm.arm.neon.vpadd
llvm.arm.neon.vpaddls
llvm.arm.neon.vpaddlu
llvm.arm.neon.vpmaxs
llvm.arm.neon.vpmaxu
llvm.arm.neon.vpmins
llvm.arm.neon.vpminu
llvm.arm.neon.vqabs
llvm.arm.neon.vqadds
llvm.arm.neon.vqaddu
llvm.arm.neon.vqdmulh
llvm.arm.neon.vqdmull
llvm.arm.neon.vqmovns
llvm.arm.neon.vqmovnsu
llvm.arm.neon.vqmovnu
llvm.arm.neon.vqneg
llvm.arm.neon.vqrdmulh
llvm.arm.neon.vqrshiftns
llvm.arm.neon.vqrshiftnsu
llvm.arm.neon.vqrshiftnu
llvm.arm.neon.vqrshifts
llvm.arm.neon.vqrshiftu
llvm.arm.neon.vqshiftns
llvm.arm.neon.vqshiftnsu
llvm.arm.neon.vqshiftnu
llvm.arm.neon.vqshifts
llvm.arm.neon.vqshiftsu
llvm.arm.neon.vqshiftu
llvm.arm.neon.vqsubs
llvm.arm.neon.vqsubu
llvm.arm.neon.vraddhn
llvm.arm.neon.vrecpe
llvm.arm.neon.vrecps
llvm.arm.neon.vrhadds
llvm.arm.neon.vrhaddu
llvm.arm.neon.vrinta
llvm.arm.neon.vrintm
llvm.arm.neon.vrintn
llvm.arm.neon.vrintp
llvm.arm.neon.vrintx
llvm.arm.neon.vrintz
llvm.arm.neon.vrshiftn
llvm.arm.neon.vrshifts
llvm.arm.neon.vrshiftu
llvm.arm.neon.vrsqrte
llvm.arm.neon.vrsqrts
llvm.arm.neon.vrsubhn
llvm.arm.neon.vshiftins
llvm.arm.neon.vshifts
llvm.arm.neon.vshiftu
llvm.arm.neon.vst1
llvm.arm.neon.vst1x2
llvm.arm.neon.vst1x3
llvm.arm.neon.vst1x4
llvm.arm.neon.vst2
llvm.arm.neon.vst2lane
llvm.arm.neon.vst3
llvm.arm.neon.vst3lane
llvm.arm.neon.vst4
llvm.arm.neon.vst4lane
llvm.arm.neon.vtbl1
llvm.arm.neon.vtbl2
llvm.arm.neon.vtbl3
llvm.arm.neon.vtbl4
llvm.arm.neon.vtbx1
llvm.arm.neon.vtbx2
llvm.arm.neon.vtbx3
llvm.arm.neon.vtbx4
llvm.arm.qadd
llvm.arm.qadd16
llvm.arm.qadd8
llvm.arm.qasx
llvm.arm.qsax
llvm.arm.qsub
llvm.arm.qsub16
llvm.arm.qsub8
llvm.arm.sadd16
llvm.arm.sadd8
llvm.arm.sasx
llvm.arm.sel
llvm.arm.set.fpscr
llvm.arm.shadd16
llvm.arm.shadd8
llvm.arm.shasx
llvm.arm.shsax
llvm.arm.shsub16
llvm.arm.shsub8
llvm.arm.smlabb
llvm.arm.smlabt
llvm.arm.smlad
llvm.arm.smladx
llvm.arm.smlald
llvm.arm.smlaldx
llvm.arm.smlatb
llvm.arm.smlatt
llvm.arm.smlawb
llvm.arm.smlawt
llvm.arm.smlsd
llvm.arm.smlsdx
llvm.arm.smlsld
llvm.arm.smlsldx
llvm.arm.smuad
llvm.arm.smuadx
llvm.arm.smulbb
llvm.arm.smulbt
llvm.arm.smultb
llvm.arm.smultt
llvm.arm.smulwb
llvm.arm.smulwt
llvm.arm.smusd
llvm.arm.smusdx
llvm.arm.space
llvm.arm.ssat
llvm.arm.ssat16
llvm.arm.ssax
llvm.arm.ssub16
llvm.arm.ssub8
llvm.arm.stc
llvm.arm.stc2
llvm.arm.stc2l
llvm.arm.stcl
llvm.arm.stlex
llvm.arm.stlexd
llvm.arm.strex
llvm.arm.strexd
llvm.arm.sxtab16
llvm.arm.sxtb16
llvm.arm.uadd16
llvm.arm.uadd8
llvm.arm.uasx
llvm.arm.uhadd16
llvm.arm.uhadd8
llvm.arm.uhasx
llvm.arm.uhsax
llvm.arm.uhsub16
llvm.arm.uhsub8
llvm.arm.undefined
llvm.arm.uqadd16
llvm.arm.uqadd8
llvm.arm.uqasx
llvm.arm.uqsax
llvm.arm.uqsub16
llvm.arm.uqsub8
llvm.arm.usad8
llvm.arm.usada8
llvm.arm.usat
llvm.arm.usat16
llvm.arm.usax
llvm.arm.usub16
llvm.arm.usub8
llvm.arm.uxtab16
llvm.arm.uxtb16
llvm.arm.vcvtr
llvm.arm.vcvtru
llvm.bpf.load.byte
llvm.bpf.load.half
llvm.bpf.load.word
llvm.bpf.pseudo
llvm.hexagon.A2.abs
llvm.hexagon.A2.absp
llvm.hexagon.A2.abssat
llvm.hexagon.A2.add
llvm.hexagon.A2.addh.h16.hh
llvm.hexagon.A2.addh.h16.hl
llvm.hexagon.A2.addh.h16.lh
llvm.hexagon.A2.addh.h16.ll
llvm.hexagon.A2.addh.h16.sat.hh
llvm.hexagon.A2.addh.h16.sat.hl
llvm.hexagon.A2.addh.h16.sat.lh
llvm.hexagon.A2.addh.h16.sat.ll
llvm.hexagon.A2.addh.l16.hl
llvm.hexagon.A2.addh.l16.ll
llvm.hexagon.A2.addh.l16.sat.hl
llvm.hexagon.A2.addh.l16.sat.ll
llvm.hexagon.A2.addi
llvm.hexagon.A2.addp
llvm.hexagon.A2.addpsat
llvm.hexagon.A2.addsat
llvm.hexagon.A2.addsp
llvm.hexagon.A2.and
llvm.hexagon.A2.andir
llvm.hexagon.A2.andp
llvm.hexagon.A2.aslh
llvm.hexagon.A2.asrh
llvm.hexagon.A2.combine.hh
llvm.hexagon.A2.combine.hl
llvm.hexagon.A2.combine.lh
llvm.hexagon.A2.combine.ll
llvm.hexagon.A2.combineii
llvm.hexagon.A2.combinew
llvm.hexagon.A2.max
llvm.hexagon.A2.maxp
llvm.hexagon.A2.maxu
llvm.hexagon.A2.maxup
llvm.hexagon.A2.min
llvm.hexagon.A2.minp
llvm.hexagon.A2.minu
llvm.hexagon.A2.minup
llvm.hexagon.A2.neg
llvm.hexagon.A2.negp
llvm.hexagon.A2.negsat
llvm.hexagon.A2.not
llvm.hexagon.A2.notp
llvm.hexagon.A2.or
llvm.hexagon.A2.orir
llvm.hexagon.A2.orp
llvm.hexagon.A2.roundsat
llvm.hexagon.A2.sat
llvm.hexagon.A2.satb
llvm.hexagon.A2.sath
llvm.hexagon.A2.satub
llvm.hexagon.A2.satuh
llvm.hexagon.A2.sub
llvm.hexagon.A2.subh.h16.hh
llvm.hexagon.A2.subh.h16.hl
llvm.hexagon.A2.subh.h16.lh
llvm.hexagon.A2.subh.h16.ll
llvm.hexagon.A2.subh.h16.sat.hh
llvm.hexagon.A2.subh.h16.sat.hl
llvm.hexagon.A2.subh.h16.sat.lh
llvm.hexagon.A2.subh.h16.sat.ll
llvm.hexagon.A2.subh.l16.hl
llvm.hexagon.A2.subh.l16.ll
llvm.hexagon.A2.subh.l16.sat.hl
llvm.hexagon.A2.subh.l16.sat.ll
llvm.hexagon.A2.subp
llvm.hexagon.A2.subri
llvm.hexagon.A2.subsat
llvm.hexagon.A2.svaddh
llvm.hexagon.A2.svaddhs
llvm.hexagon.A2.svadduhs
llvm.hexagon.A2.svavgh
llvm.hexagon.A2.svavghs
llvm.hexagon.A2.svnavgh
llvm.hexagon.A2.svsubh
llvm.hexagon.A2.svsubhs
llvm.hexagon.A2.svsubuhs
llvm.hexagon.A2.swiz
llvm.hexagon.A2.sxtb
llvm.hexagon.A2.sxth
llvm.hexagon.A2.sxtw
llvm.hexagon.A2.tfr
llvm.hexagon.A2.tfrih
llvm.hexagon.A2.tfril
llvm.hexagon.A2.tfrp
llvm.hexagon.A2.tfrpi
llvm.hexagon.A2.tfrsi
llvm.hexagon.A2.vabsh
llvm.hexagon.A2.vabshsat
llvm.hexagon.A2.vabsw
llvm.hexagon.A2.vabswsat
llvm.hexagon.A2.vaddb.map
llvm.hexagon.A2.vaddh
llvm.hexagon.A2.vaddhs
llvm.hexagon.A2.vaddub
llvm.hexagon.A2.vaddubs
llvm.hexagon.A2.vadduhs
llvm.hexagon.A2.vaddw
llvm.hexagon.A2.vaddws
llvm.hexagon.A2.vavgh
llvm.hexagon.A2.vavghcr
llvm.hexagon.A2.vavghr
llvm.hexagon.A2.vavgub
llvm.hexagon.A2.vavgubr
llvm.hexagon.A2.vavguh
llvm.hexagon.A2.vavguhr
llvm.hexagon.A2.vavguw
llvm.hexagon.A2.vavguwr
llvm.hexagon.A2.vavgw
llvm.hexagon.A2.vavgwcr
llvm.hexagon.A2.vavgwr
llvm.hexagon.A2.vcmpbeq
llvm.hexagon.A2.vcmpbgtu
llvm.hexagon.A2.vcmpheq
llvm.hexagon.A2.vcmphgt
llvm.hexagon.A2.vcmphgtu
llvm.hexagon.A2.vcmpweq
llvm.hexagon.A2.vcmpwgt
llvm.hexagon.A2.vcmpwgtu
llvm.hexagon.A2.vconj
llvm.hexagon.A2.vmaxb
llvm.hexagon.A2.vmaxh
llvm.hexagon.A2.vmaxub
llvm.hexagon.A2.vmaxuh
llvm.hexagon.A2.vmaxuw
llvm.hexagon.A2.vmaxw
llvm.hexagon.A2.vminb
llvm.hexagon.A2.vminh
llvm.hexagon.A2.vminub
llvm.hexagon.A2.vminuh
llvm.hexagon.A2.vminuw
llvm.hexagon.A2.vminw
llvm.hexagon.A2.vnavgh
llvm.hexagon.A2.vnavghcr
llvm.hexagon.A2.vnavghr
llvm.hexagon.A2.vnavgw
llvm.hexagon.A2.vnavgwcr
llvm.hexagon.A2.vnavgwr
llvm.hexagon.A2.vraddub
llvm.hexagon.A2.vraddub.acc
llvm.hexagon.A2.vrsadub
llvm.hexagon.A2.vrsadub.acc
llvm.hexagon.A2.vsubb.map
llvm.hexagon.A2.vsubh
llvm.hexagon.A2.vsubhs
llvm.hexagon.A2.vsubub
llvm.hexagon.A2.vsububs
llvm.hexagon.A2.vsubuhs
llvm.hexagon.A2.vsubw
llvm.hexagon.A2.vsubws
llvm.hexagon.A2.xor
llvm.hexagon.A2.xorp
llvm.hexagon.A2.zxtb
llvm.hexagon.A2.zxth
llvm.hexagon.A4.andn
llvm.hexagon.A4.andnp
llvm.hexagon.A4.bitsplit
llvm.hexagon.A4.bitspliti
llvm.hexagon.A4.boundscheck
llvm.hexagon.A4.cmpbeq
llvm.hexagon.A4.cmpbeqi
llvm.hexagon.A4.cmpbgt
llvm.hexagon.A4.cmpbgti
llvm.hexagon.A4.cmpbgtu
llvm.hexagon.A4.cmpbgtui
llvm.hexagon.A4.cmpheq
llvm.hexagon.A4.cmpheqi
llvm.hexagon.A4.cmphgt
llvm.hexagon.A4.cmphgti
llvm.hexagon.A4.cmphgtu
llvm.hexagon.A4.cmphgtui
llvm.hexagon.A4.combineir
llvm.hexagon.A4.combineri
llvm.hexagon.A4.cround.ri
llvm.hexagon.A4.cround.rr
llvm.hexagon.A4.modwrapu
llvm.hexagon.A4.orn
llvm.hexagon.A4.ornp
llvm.hexagon.A4.rcmpeq
llvm.hexagon.A4.rcmpeqi
llvm.hexagon.A4.rcmpneq
llvm.hexagon.A4.rcmpneqi
llvm.hexagon.A4.round.ri
llvm.hexagon.A4.round.ri.sat
llvm.hexagon.A4.round.rr
llvm.hexagon.A4.round.rr.sat
llvm.hexagon.A4.tlbmatch
llvm.hexagon.A4.vcmpbeq.any
llvm.hexagon.A4.vcmpbeqi
llvm.hexagon.A4.vcmpbgt
llvm.hexagon.A4.vcmpbgti
llvm.hexagon.A4.vcmpbgtui
llvm.hexagon.A4.vcmpheqi
llvm.hexagon.A4.vcmphgti
llvm.hexagon.A4.vcmphgtui
llvm.hexagon.A4.vcmpweqi
llvm.hexagon.A4.vcmpwgti
llvm.hexagon.A4.vcmpwgtui
llvm.hexagon.A4.vrmaxh
llvm.hexagon.A4.vrmaxuh
llvm.hexagon.A4.vrmaxuw
llvm.hexagon.A4.vrmaxw
llvm.hexagon.A4.vrminh
llvm.hexagon.A4.vrminuh
llvm.hexagon.A4.vrminuw
llvm.hexagon.A4.vrminw
llvm.hexagon.A5.vaddhubs
llvm.hexagon.A6.vcmpbeq.notany
llvm.hexagon.A6.vcmpbeq.notany.128B
llvm.hexagon.C2.all8
llvm.hexagon.C2.and
llvm.hexagon.C2.andn
llvm.hexagon.C2.any8
llvm.hexagon.C2.bitsclr
llvm.hexagon.C2.bitsclri
llvm.hexagon.C2.bitsset
llvm.hexagon.C2.cmpeq
llvm.hexagon.C2.cmpeqi
llvm.hexagon.C2.cmpeqp
llvm.hexagon.C2.cmpgei
llvm.hexagon.C2.cmpgeui
llvm.hexagon.C2.cmpgt
llvm.hexagon.C2.cmpgti
llvm.hexagon.C2.cmpgtp
llvm.hexagon.C2.cmpgtu
llvm.hexagon.C2.cmpgtui
llvm.hexagon.C2.cmpgtup
llvm.hexagon.C2.cmplt
llvm.hexagon.C2.cmpltu
llvm.hexagon.C2.mask
llvm.hexagon.C2.mux
llvm.hexagon.C2.muxii
llvm.hexagon.C2.muxir
llvm.hexagon.C2.muxri
llvm.hexagon.C2.not
llvm.hexagon.C2.or
llvm.hexagon.C2.orn
llvm.hexagon.C2.pxfer.map
llvm.hexagon.C2.tfrpr
llvm.hexagon.C2.tfrrp
llvm.hexagon.C2.vitpack
llvm.hexagon.C2.vmux
llvm.hexagon.C2.xor
llvm.hexagon.C4.and.and
llvm.hexagon.C4.and.andn
llvm.hexagon.C4.and.or
llvm.hexagon.C4.and.orn
llvm.hexagon.C4.cmplte
llvm.hexagon.C4.cmpltei
llvm.hexagon.C4.cmplteu
llvm.hexagon.C4.cmplteui
llvm.hexagon.C4.cmpneq
llvm.hexagon.C4.cmpneqi
llvm.hexagon.C4.fastcorner9
llvm.hexagon.C4.fastcorner9.not
llvm.hexagon.C4.nbitsclr
llvm.hexagon.C4.nbitsclri
llvm.hexagon.C4.nbitsset
llvm.hexagon.C4.or.and
llvm.hexagon.C4.or.andn
llvm.hexagon.C4.or.or
llvm.hexagon.C4.or.orn
llvm.hexagon.F2.conv.d2df
llvm.hexagon.F2.conv.d2sf
llvm.hexagon.F2.conv.df2d
llvm.hexagon.F2.conv.df2d.chop
llvm.hexagon.F2.conv.df2sf
llvm.hexagon.F2.conv.df2ud
llvm.hexagon.F2.conv.df2ud.chop
llvm.hexagon.F2.conv.df2uw
llvm.hexagon.F2.conv.df2uw.chop
llvm.hexagon.F2.conv.df2w
llvm.hexagon.F2.conv.df2w.chop
llvm.hexagon.F2.conv.sf2d
llvm.hexagon.F2.conv.sf2d.chop
llvm.hexagon.F2.conv.sf2df
llvm.hexagon.F2.conv.sf2ud
llvm.hexagon.F2.conv.sf2ud.chop
llvm.hexagon.F2.conv.sf2uw
llvm.hexagon.F2.conv.sf2uw.chop
llvm.hexagon.F2.conv.sf2w
llvm.hexagon.F2.conv.sf2w.chop
llvm.hexagon.F2.conv.ud2df
llvm.hexagon.F2.conv.ud2sf
llvm.hexagon.F2.conv.uw2df
llvm.hexagon.F2.conv.uw2sf
llvm.hexagon.F2.conv.w2df
llvm.hexagon.F2.conv.w2sf
llvm.hexagon.F2.dfclass
llvm.hexagon.F2.dfcmpeq
llvm.hexagon.F2.dfcmpge
llvm.hexagon.F2.dfcmpgt
llvm.hexagon.F2.dfcmpuo
llvm.hexagon.F2.dfimm.n
llvm.hexagon.F2.dfimm.p
llvm.hexagon.F2.sfadd
llvm.hexagon.F2.sfclass
llvm.hexagon.F2.sfcmpeq
llvm.hexagon.F2.sfcmpge
llvm.hexagon.F2.sfcmpgt
llvm.hexagon.F2.sfcmpuo
llvm.hexagon.F2.sffixupd
llvm.hexagon.F2.sffixupn
llvm.hexagon.F2.sffixupr
llvm.hexagon.F2.sffma
llvm.hexagon.F2.sffma.lib
llvm.hexagon.F2.sffma.sc
llvm.hexagon.F2.sffms
llvm.hexagon.F2.sffms.lib
llvm.hexagon.F2.sfimm.n
llvm.hexagon.F2.sfimm.p
llvm.hexagon.F2.sfmax
llvm.hexagon.F2.sfmin
llvm.hexagon.F2.sfmpy
llvm.hexagon.F2.sfsub
llvm.hexagon.L2.loadrb.pbr
llvm.hexagon.L2.loadrb.pci
llvm.hexagon.L2.loadrb.pcr
llvm.hexagon.L2.loadrd.pbr
llvm.hexagon.L2.loadrd.pci
llvm.hexagon.L2.loadrd.pcr
llvm.hexagon.L2.loadrh.pbr
llvm.hexagon.L2.loadrh.pci
llvm.hexagon.L2.loadrh.pcr
llvm.hexagon.L2.loadri.pbr
llvm.hexagon.L2.loadri.pci
llvm.hexagon.L2.loadri.pcr
llvm.hexagon.L2.loadrub.pbr
llvm.hexagon.L2.loadrub.pci
llvm.hexagon.L2.loadrub.pcr
llvm.hexagon.L2.loadruh.pbr
llvm.hexagon.L2.loadruh.pci
llvm.hexagon.L2.loadruh.pcr
llvm.hexagon.L2.loadw.locked
llvm.hexagon.L4.loadd.locked
llvm.hexagon.M2.acci
llvm.hexagon.M2.accii
llvm.hexagon.M2.cmaci.s0
llvm.hexagon.M2.cmacr.s0
llvm.hexagon.M2.cmacs.s0
llvm.hexagon.M2.cmacs.s1
llvm.hexagon.M2.cmacsc.s0
llvm.hexagon.M2.cmacsc.s1
llvm.hexagon.M2.cmpyi.s0
llvm.hexagon.M2.cmpyr.s0
llvm.hexagon.M2.cmpyrs.s0
llvm.hexagon.M2.cmpyrs.s1
llvm.hexagon.M2.cmpyrsc.s0
llvm.hexagon.M2.cmpyrsc.s1
llvm.hexagon.M2.cmpys.s0
llvm.hexagon.M2.cmpys.s1
llvm.hexagon.M2.cmpysc.s0
llvm.hexagon.M2.cmpysc.s1
llvm.hexagon.M2.cnacs.s0
llvm.hexagon.M2.cnacs.s1
llvm.hexagon.M2.cnacsc.s0
llvm.hexagon.M2.cnacsc.s1
llvm.hexagon.M2.dpmpyss.acc.s0
llvm.hexagon.M2.dpmpyss.nac.s0
llvm.hexagon.M2.dpmpyss.rnd.s0
llvm.hexagon.M2.dpmpyss.s0
llvm.hexagon.M2.dpmpyuu.acc.s0
llvm.hexagon.M2.dpmpyuu.nac.s0
llvm.hexagon.M2.dpmpyuu.s0
llvm.hexagon.M2.hmmpyh.rs1
llvm.hexagon.M2.hmmpyh.s1
llvm.hexagon.M2.hmmpyl.rs1
llvm.hexagon.M2.hmmpyl.s1
llvm.hexagon.M2.maci
llvm.hexagon.M2.macsin
llvm.hexagon.M2.macsip
llvm.hexagon.M2.mmachs.rs0
llvm.hexagon.M2.mmachs.rs1
llvm.hexagon.M2.mmachs.s0
llvm.hexagon.M2.mmachs.s1
llvm.hexagon.M2.mmacls.rs0
llvm.hexagon.M2.mmacls.rs1
llvm.hexagon.M2.mmacls.s0
llvm.hexagon.M2.mmacls.s1
llvm.hexagon.M2.mmacuhs.rs0
llvm.hexagon.M2.mmacuhs.rs1
llvm.hexagon.M2.mmacuhs.s0
llvm.hexagon.M2.mmacuhs.s1
llvm.hexagon.M2.mmaculs.rs0
llvm.hexagon.M2.mmaculs.rs1
llvm.hexagon.M2.mmaculs.s0
llvm.hexagon.M2.mmaculs.s1
llvm.hexagon.M2.mmpyh.rs0
llvm.hexagon.M2.mmpyh.rs1
llvm.hexagon.M2.mmpyh.s0
llvm.hexagon.M2.mmpyh.s1
llvm.hexagon.M2.mmpyl.rs0
llvm.hexagon.M2.mmpyl.rs1
llvm.hexagon.M2.mmpyl.s0
llvm.hexagon.M2.mmpyl.s1
llvm.hexagon.M2.mmpyuh.rs0
llvm.hexagon.M2.mmpyuh.rs1
llvm.hexagon.M2.mmpyuh.s0
llvm.hexagon.M2.mmpyuh.s1
llvm.hexagon.M2.mmpyul.rs0
llvm.hexagon.M2.mmpyul.rs1
llvm.hexagon.M2.mmpyul.s0
llvm.hexagon.M2.mmpyul.s1
llvm.hexagon.M2.mpy.acc.hh.s0
llvm.hexagon.M2.mpy.acc.hh.s1
llvm.hexagon.M2.mpy.acc.hl.s0
llvm.hexagon.M2.mpy.acc.hl.s1
llvm.hexagon.M2.mpy.acc.lh.s0
llvm.hexagon.M2.mpy.acc.lh.s1
llvm.hexagon.M2.mpy.acc.ll.s0
llvm.hexagon.M2.mpy.acc.ll.s1
llvm.hexagon.M2.mpy.acc.sat.hh.s0
llvm.hexagon.M2.mpy.acc.sat.hh.s1
llvm.hexagon.M2.mpy.acc.sat.hl.s0
llvm.hexagon.M2.mpy.acc.sat.hl.s1
llvm.hexagon.M2.mpy.acc.sat.lh.s0
llvm.hexagon.M2.mpy.acc.sat.lh.s1
llvm.hexagon.M2.mpy.acc.sat.ll.s0
llvm.hexagon.M2.mpy.acc.sat.ll.s1
llvm.hexagon.M2.mpy.hh.s0
llvm.hexagon.M2.mpy.hh.s1
llvm.hexagon.M2.mpy.hl.s0
llvm.hexagon.M2.mpy.hl.s1
llvm.hexagon.M2.mpy.lh.s0
llvm.hexagon.M2.mpy.lh.s1
llvm.hexagon.M2.mpy.ll.s0
llvm.hexagon.M2.mpy.ll.s1
llvm.hexagon.M2.mpy.nac.hh.s0
llvm.hexagon.M2.mpy.nac.hh.s1
llvm.hexagon.M2.mpy.nac.hl.s0
llvm.hexagon.M2.mpy.nac.hl.s1
llvm.hexagon.M2.mpy.nac.lh.s0
llvm.hexagon.M2.mpy.nac.lh.s1
llvm.hexagon.M2.mpy.nac.ll.s0
llvm.hexagon.M2.mpy.nac.ll.s1
llvm.hexagon.M2.mpy.nac.sat.hh.s0
llvm.hexagon.M2.mpy.nac.sat.hh.s1
llvm.hexagon.M2.mpy.nac.sat.hl.s0
llvm.hexagon.M2.mpy.nac.sat.hl.s1
llvm.hexagon.M2.mpy.nac.sat.lh.s0
llvm.hexagon.M2.mpy.nac.sat.lh.s1
llvm.hexagon.M2.mpy.nac.sat.ll.s0
llvm.hexagon.M2.mpy.nac.sat.ll.s1
llvm.hexagon.M2.mpy.rnd.hh.s0
llvm.hexagon.M2.mpy.rnd.hh.s1
llvm.hexagon.M2.mpy.rnd.hl.s0
llvm.hexagon.M2.mpy.rnd.hl.s1
llvm.hexagon.M2.mpy.rnd.lh.s0
llvm.hexagon.M2.mpy.rnd.lh.s1
llvm.hexagon.M2.mpy.rnd.ll.s0
llvm.hexagon.M2.mpy.rnd.ll.s1
llvm.hexagon.M2.mpy.sat.hh.s0
llvm.hexagon.M2.mpy.sat.hh.s1
llvm.hexagon.M2.mpy.sat.hl.s0
llvm.hexagon.M2.mpy.sat.hl.s1
llvm.hexagon.M2.mpy.sat.lh.s0
llvm.hexagon.M2.mpy.sat.lh.s1
llvm.hexagon.M2.mpy.sat.ll.s0
llvm.hexagon.M2.mpy.sat.ll.s1
llvm.hexagon.M2.mpy.sat.rnd.hh.s0
llvm.hexagon.M2.mpy.sat.rnd.hh.s1
llvm.hexagon.M2.mpy.sat.rnd.hl.s0
llvm.hexagon.M2.mpy.sat.rnd.hl.s1
llvm.hexagon.M2.mpy.sat.rnd.lh.s0
llvm.hexagon.M2.mpy.sat.rnd.lh.s1
llvm.hexagon.M2.mpy.sat.rnd.ll.s0
llvm.hexagon.M2.mpy.sat.rnd.ll.s1
llvm.hexagon.M2.mpy.up
llvm.hexagon.M2.mpy.up.s1
llvm.hexagon.M2.mpy.up.s1.sat
llvm.hexagon.M2.mpyd.acc.hh.s0
llvm.hexagon.M2.mpyd.acc.hh.s1
llvm.hexagon.M2.mpyd.acc.hl.s0
llvm.hexagon.M2.mpyd.acc.hl.s1
llvm.hexagon.M2.mpyd.acc.lh.s0
llvm.hexagon.M2.mpyd.acc.lh.s1
llvm.hexagon.M2.mpyd.acc.ll.s0
llvm.hexagon.M2.mpyd.acc.ll.s1
llvm.hexagon.M2.mpyd.hh.s0
llvm.hexagon.M2.mpyd.hh.s1
llvm.hexagon.M2.mpyd.hl.s0
llvm.hexagon.M2.mpyd.hl.s1
llvm.hexagon.M2.mpyd.lh.s0
llvm.hexagon.M2.mpyd.lh.s1
llvm.hexagon.M2.mpyd.ll.s0
llvm.hexagon.M2.mpyd.ll.s1
llvm.hexagon.M2.mpyd.nac.hh.s0
llvm.hexagon.M2.mpyd.nac.hh.s1
llvm.hexagon.M2.mpyd.nac.hl.s0
llvm.hexagon.M2.mpyd.nac.hl.s1
llvm.hexagon.M2.mpyd.nac.lh.s0
llvm.hexagon.M2.mpyd.nac.lh.s1
llvm.hexagon.M2.mpyd.nac.ll.s0
llvm.hexagon.M2.mpyd.nac.ll.s1
llvm.hexagon.M2.mpyd.rnd.hh.s0
llvm.hexagon.M2.mpyd.rnd.hh.s1
llvm.hexagon.M2.mpyd.rnd.hl.s0
llvm.hexagon.M2.mpyd.rnd.hl.s1
llvm.hexagon.M2.mpyd.rnd.lh.s0
llvm.hexagon.M2.mpyd.rnd.lh.s1
llvm.hexagon.M2.mpyd.rnd.ll.s0
llvm.hexagon.M2.mpyd.rnd.ll.s1
llvm.hexagon.M2.mpyi
llvm.hexagon.M2.mpysmi
llvm.hexagon.M2.mpysu.up
llvm.hexagon.M2.mpyu.acc.hh.s0
llvm.hexagon.M2.mpyu.acc.hh.s1
llvm.hexagon.M2.mpyu.acc.hl.s0
llvm.hexagon.M2.mpyu.acc.hl.s1
llvm.hexagon.M2.mpyu.acc.lh.s0
llvm.hexagon.M2.mpyu.acc.lh.s1
llvm.hexagon.M2.mpyu.acc.ll.s0
llvm.hexagon.M2.mpyu.acc.ll.s1
llvm.hexagon.M2.mpyu.hh.s0
llvm.hexagon.M2.mpyu.hh.s1
llvm.hexagon.M2.mpyu.hl.s0
llvm.hexagon.M2.mpyu.hl.s1
llvm.hexagon.M2.mpyu.lh.s0
llvm.hexagon.M2.mpyu.lh.s1
llvm.hexagon.M2.mpyu.ll.s0
llvm.hexagon.M2.mpyu.ll.s1
llvm.hexagon.M2.mpyu.nac.hh.s0
llvm.hexagon.M2.mpyu.nac.hh.s1
llvm.hexagon.M2.mpyu.nac.hl.s0
llvm.hexagon.M2.mpyu.nac.hl.s1
llvm.hexagon.M2.mpyu.nac.lh.s0
llvm.hexagon.M2.mpyu.nac.lh.s1
llvm.hexagon.M2.mpyu.nac.ll.s0
llvm.hexagon.M2.mpyu.nac.ll.s1
llvm.hexagon.M2.mpyu.up
llvm.hexagon.M2.mpyud.acc.hh.s0
llvm.hexagon.M2.mpyud.acc.hh.s1
llvm.hexagon.M2.mpyud.acc.hl.s0
llvm.hexagon.M2.mpyud.acc.hl.s1
llvm.hexagon.M2.mpyud.acc.lh.s0
llvm.hexagon.M2.mpyud.acc.lh.s1
llvm.hexagon.M2.mpyud.acc.ll.s0
llvm.hexagon.M2.mpyud.acc.ll.s1
llvm.hexagon.M2.mpyud.hh.s0
llvm.hexagon.M2.mpyud.hh.s1
llvm.hexagon.M2.mpyud.hl.s0
llvm.hexagon.M2.mpyud.hl.s1
llvm.hexagon.M2.mpyud.lh.s0
llvm.hexagon.M2.mpyud.lh.s1
llvm.hexagon.M2.mpyud.ll.s0
llvm.hexagon.M2.mpyud.ll.s1
llvm.hexagon.M2.mpyud.nac.hh.s0
llvm.hexagon.M2.mpyud.nac.hh.s1
llvm.hexagon.M2.mpyud.nac.hl.s0
llvm.hexagon.M2.mpyud.nac.hl.s1
llvm.hexagon.M2.mpyud.nac.lh.s0
llvm.hexagon.M2.mpyud.nac.lh.s1
llvm.hexagon.M2.mpyud.nac.ll.s0
llvm.hexagon.M2.mpyud.nac.ll.s1
llvm.hexagon.M2.mpyui
llvm.hexagon.M2.nacci
llvm.hexagon.M2.naccii
llvm.hexagon.M2.subacc
llvm.hexagon.M2.vabsdiffh
llvm.hexagon.M2.vabsdiffw
llvm.hexagon.M2.vcmac.s0.sat.i
llvm.hexagon.M2.vcmac.s0.sat.r
llvm.hexagon.M2.vcmpy.s0.sat.i
llvm.hexagon.M2.vcmpy.s0.sat.r
llvm.hexagon.M2.vcmpy.s1.sat.i
llvm.hexagon.M2.vcmpy.s1.sat.r
llvm.hexagon.M2.vdmacs.s0
llvm.hexagon.M2.vdmacs.s1
llvm.hexagon.M2.vdmpyrs.s0
llvm.hexagon.M2.vdmpyrs.s1
llvm.hexagon.M2.vdmpys.s0
llvm.hexagon.M2.vdmpys.s1
llvm.hexagon.M2.vmac2
llvm.hexagon.M2.vmac2es
llvm.hexagon.M2.vmac2es.s0
llvm.hexagon.M2.vmac2es.s1
llvm.hexagon.M2.vmac2s.s0
llvm.hexagon.M2.vmac2s.s1
llvm.hexagon.M2.vmac2su.s0
llvm.hexagon.M2.vmac2su.s1
llvm.hexagon.M2.vmpy2es.s0
llvm.hexagon.M2.vmpy2es.s1
llvm.hexagon.M2.vmpy2s.s0
llvm.hexagon.M2.vmpy2s.s0pack
llvm.hexagon.M2.vmpy2s.s1
llvm.hexagon.M2.vmpy2s.s1pack
llvm.hexagon.M2.vmpy2su.s0
llvm.hexagon.M2.vmpy2su.s1
llvm.hexagon.M2.vraddh
llvm.hexagon.M2.vradduh
llvm.hexagon.M2.vrcmaci.s0
llvm.hexagon.M2.vrcmaci.s0c
llvm.hexagon.M2.vrcmacr.s0
llvm.hexagon.M2.vrcmacr.s0c
llvm.hexagon.M2.vrcmpyi.s0
llvm.hexagon.M2.vrcmpyi.s0c
llvm.hexagon.M2.vrcmpyr.s0
llvm.hexagon.M2.vrcmpyr.s0c
llvm.hexagon.M2.vrcmpys.acc.s1
llvm.hexagon.M2.vrcmpys.s1
llvm.hexagon.M2.vrcmpys.s1rp
llvm.hexagon.M2.vrmac.s0
llvm.hexagon.M2.vrmpy.s0
llvm.hexagon.M2.xor.xacc
llvm.hexagon.M4.and.and
llvm.hexagon.M4.and.andn
llvm.hexagon.M4.and.or
llvm.hexagon.M4.and.xor
llvm.hexagon.M4.cmpyi.wh
llvm.hexagon.M4.cmpyi.whc
llvm.hexagon.M4.cmpyr.wh
llvm.hexagon.M4.cmpyr.whc
llvm.hexagon.M4.mac.up.s1.sat
llvm.hexagon.M4.mpyri.addi
llvm.hexagon.M4.mpyri.addr
llvm.hexagon.M4.mpyri.addr.u2
llvm.hexagon.M4.mpyrr.addi
llvm.hexagon.M4.mpyrr.addr
llvm.hexagon.M4.nac.up.s1.sat
llvm.hexagon.M4.or.and
llvm.hexagon.M4.or.andn
llvm.hexagon.M4.or.or
llvm.hexagon.M4.or.xor
llvm.hexagon.M4.pmpyw
llvm.hexagon.M4.pmpyw.acc
llvm.hexagon.M4.vpmpyh
llvm.hexagon.M4.vpmpyh.acc
llvm.hexagon.M4.vrmpyeh.acc.s0
llvm.hexagon.M4.vrmpyeh.acc.s1
llvm.hexagon.M4.vrmpyeh.s0
llvm.hexagon.M4.vrmpyeh.s1
llvm.hexagon.M4.vrmpyoh.acc.s0
llvm.hexagon.M4.vrmpyoh.acc.s1
llvm.hexagon.M4.vrmpyoh.s0
llvm.hexagon.M4.vrmpyoh.s1
llvm.hexagon.M4.xor.and
llvm.hexagon.M4.xor.andn
llvm.hexagon.M4.xor.or
llvm.hexagon.M4.xor.xacc
llvm.hexagon.M5.vdmacbsu
llvm.hexagon.M5.vdmpybsu
llvm.hexagon.M5.vmacbsu
llvm.hexagon.M5.vmacbuu
llvm.hexagon.M5.vmpybsu
llvm.hexagon.M5.vmpybuu
llvm.hexagon.M5.vrmacbsu
llvm.hexagon.M5.vrmacbuu
llvm.hexagon.M5.vrmpybsu
llvm.hexagon.M5.vrmpybuu
llvm.hexagon.M6.vabsdiffb
llvm.hexagon.M6.vabsdiffub
llvm.hexagon.S2.addasl.rrri
llvm.hexagon.S2.asl.i.p
llvm.hexagon.S2.asl.i.p.acc
llvm.hexagon.S2.asl.i.p.and
llvm.hexagon.S2.asl.i.p.nac
llvm.hexagon.S2.asl.i.p.or
llvm.hexagon.S2.asl.i.p.xacc
llvm.hexagon.S2.asl.i.r
llvm.hexagon.S2.asl.i.r.acc
llvm.hexagon.S2.asl.i.r.and
llvm.hexagon.S2.asl.i.r.nac
llvm.hexagon.S2.asl.i.r.or
llvm.hexagon.S2.asl.i.r.sat
llvm.hexagon.S2.asl.i.r.xacc
llvm.hexagon.S2.asl.i.vh
llvm.hexagon.S2.asl.i.vw
llvm.hexagon.S2.asl.r.p
llvm.hexagon.S2.asl.r.p.acc
llvm.hexagon.S2.asl.r.p.and
llvm.hexagon.S2.asl.r.p.nac
llvm.hexagon.S2.asl.r.p.or
llvm.hexagon.S2.asl.r.p.xor
llvm.hexagon.S2.asl.r.r
llvm.hexagon.S2.asl.r.r.acc
llvm.hexagon.S2.asl.r.r.and
llvm.hexagon.S2.asl.r.r.nac
llvm.hexagon.S2.asl.r.r.or
llvm.hexagon.S2.asl.r.r.sat
llvm.hexagon.S2.asl.r.vh
llvm.hexagon.S2.asl.r.vw
llvm.hexagon.S2.asr.i.p
llvm.hexagon.S2.asr.i.p.acc
llvm.hexagon.S2.asr.i.p.and
llvm.hexagon.S2.asr.i.p.nac
llvm.hexagon.S2.asr.i.p.or
llvm.hexagon.S2.asr.i.p.rnd
llvm.hexagon.S2.asr.i.p.rnd.goodsyntax
llvm.hexagon.S2.asr.i.r
llvm.hexagon.S2.asr.i.r.acc
llvm.hexagon.S2.asr.i.r.and
llvm.hexagon.S2.asr.i.r.nac
llvm.hexagon.S2.asr.i.r.or
llvm.hexagon.S2.asr.i.r.rnd
llvm.hexagon.S2.asr.i.r.rnd.goodsyntax
llvm.hexagon.S2.asr.i.svw.trun
llvm.hexagon.S2.asr.i.vh
llvm.hexagon.S2.asr.i.vw
llvm.hexagon.S2.asr.r.p
llvm.hexagon.S2.asr.r.p.acc
llvm.hexagon.S2.asr.r.p.and
llvm.hexagon.S2.asr.r.p.nac
llvm.hexagon.S2.asr.r.p.or
llvm.hexagon.S2.asr.r.p.xor
llvm.hexagon.S2.asr.r.r
llvm.hexagon.S2.asr.r.r.acc
llvm.hexagon.S2.asr.r.r.and
llvm.hexagon.S2.asr.r.r.nac
llvm.hexagon.S2.asr.r.r.or
llvm.hexagon.S2.asr.r.r.sat
llvm.hexagon.S2.asr.r.svw.trun
llvm.hexagon.S2.asr.r.vh
llvm.hexagon.S2.asr.r.vw
llvm.hexagon.S2.brev
llvm.hexagon.S2.brevp
llvm.hexagon.S2.cabacencbin
llvm.hexagon.S2.cl0
llvm.hexagon.S2.cl0p
llvm.hexagon.S2.cl1
llvm.hexagon.S2.cl1p
llvm.hexagon.S2.clb
llvm.hexagon.S2.clbnorm
llvm.hexagon.S2.clbp
llvm.hexagon.S2.clrbit.i
llvm.hexagon.S2.clrbit.r
llvm.hexagon.S2.ct0
llvm.hexagon.S2.ct0p
llvm.hexagon.S2.ct1
llvm.hexagon.S2.ct1p
llvm.hexagon.S2.deinterleave
llvm.hexagon.S2.extractu
llvm.hexagon.S2.extractu.rp
llvm.hexagon.S2.extractup
llvm.hexagon.S2.extractup.rp
llvm.hexagon.S2.insert
llvm.hexagon.S2.insert.rp
llvm.hexagon.S2.insertp
llvm.hexagon.S2.insertp.rp
llvm.hexagon.S2.interleave
llvm.hexagon.S2.lfsp
llvm.hexagon.S2.lsl.r.p
llvm.hexagon.S2.lsl.r.p.acc
llvm.hexagon.S2.lsl.r.p.and
llvm.hexagon.S2.lsl.r.p.nac
llvm.hexagon.S2.lsl.r.p.or
llvm.hexagon.S2.lsl.r.p.xor
llvm.hexagon.S2.lsl.r.r
llvm.hexagon.S2.lsl.r.r.acc
llvm.hexagon.S2.lsl.r.r.and
llvm.hexagon.S2.lsl.r.r.nac
llvm.hexagon.S2.lsl.r.r.or
llvm.hexagon.S2.lsl.r.vh
llvm.hexagon.S2.lsl.r.vw
llvm.hexagon.S2.lsr.i.p
llvm.hexagon.S2.lsr.i.p.acc
llvm.hexagon.S2.lsr.i.p.and
llvm.hexagon.S2.lsr.i.p.nac
llvm.hexagon.S2.lsr.i.p.or
llvm.hexagon.S2.lsr.i.p.xacc
llvm.hexagon.S2.lsr.i.r
llvm.hexagon.S2.lsr.i.r.acc
llvm.hexagon.S2.lsr.i.r.and
llvm.hexagon.S2.lsr.i.r.nac
llvm.hexagon.S2.lsr.i.r.or
llvm.hexagon.S2.lsr.i.r.xacc
llvm.hexagon.S2.lsr.i.vh
llvm.hexagon.S2.lsr.i.vw
llvm.hexagon.S2.lsr.r.p
llvm.hexagon.S2.lsr.r.p.acc
llvm.hexagon.S2.lsr.r.p.and
llvm.hexagon.S2.lsr.r.p.nac
llvm.hexagon.S2.lsr.r.p.or
llvm.hexagon.S2.lsr.r.p.xor
llvm.hexagon.S2.lsr.r.r
llvm.hexagon.S2.lsr.r.r.acc
llvm.hexagon.S2.lsr.r.r.and
llvm.hexagon.S2.lsr.r.r.nac
llvm.hexagon.S2.lsr.r.r.or
llvm.hexagon.S2.lsr.r.vh
llvm.hexagon.S2.lsr.r.vw
llvm.hexagon.S2.packhl
llvm.hexagon.S2.parityp
llvm.hexagon.S2.setbit.i
llvm.hexagon.S2.setbit.r
llvm.hexagon.S2.shuffeb
llvm.hexagon.S2.shuffeh
llvm.hexagon.S2.shuffob
llvm.hexagon.S2.shuffoh
llvm.hexagon.S2.storerb.pbr
llvm.hexagon.S2.storerb.pci
llvm.hexagon.S2.storerb.pcr
llvm.hexagon.S2.storerd.pbr
llvm.hexagon.S2.storerd.pci
llvm.hexagon.S2.storerd.pcr
llvm.hexagon.S2.storerf.pbr
llvm.hexagon.S2.storerf.pci
llvm.hexagon.S2.storerf.pcr
llvm.hexagon.S2.storerh.pbr
llvm.hexagon.S2.storerh.pci
llvm.hexagon.S2.storerh.pcr
llvm.hexagon.S2.storeri.pbr
llvm.hexagon.S2.storeri.pci
llvm.hexagon.S2.storeri.pcr
llvm.hexagon.S2.storew.locked
llvm.hexagon.S2.svsathb
llvm.hexagon.S2.svsathub
llvm.hexagon.S2.tableidxb.goodsyntax
llvm.hexagon.S2.tableidxd.goodsyntax
llvm.hexagon.S2.tableidxh.goodsyntax
llvm.hexagon.S2.tableidxw.goodsyntax
llvm.hexagon.S2.togglebit.i
llvm.hexagon.S2.togglebit.r
llvm.hexagon.S2.tstbit.i
llvm.hexagon.S2.tstbit.r
llvm.hexagon.S2.valignib
llvm.hexagon.S2.valignrb
llvm.hexagon.S2.vcnegh
llvm.hexagon.S2.vcrotate
llvm.hexagon.S2.vrcnegh
llvm.hexagon.S2.vrndpackwh
llvm.hexagon.S2.vrndpackwhs
llvm.hexagon.S2.vsathb
llvm.hexagon.S2.vsathb.nopack
llvm.hexagon.S2.vsathub
llvm.hexagon.S2.vsathub.nopack
llvm.hexagon.S2.vsatwh
llvm.hexagon.S2.vsatwh.nopack
llvm.hexagon.S2.vsatwuh
llvm.hexagon.S2.vsatwuh.nopack
llvm.hexagon.S2.vsplatrb
llvm.hexagon.S2.vsplatrh
llvm.hexagon.S2.vspliceib
llvm.hexagon.S2.vsplicerb
llvm.hexagon.S2.vsxtbh
llvm.hexagon.S2.vsxthw
llvm.hexagon.S2.vtrunehb
llvm.hexagon.S2.vtrunewh
llvm.hexagon.S2.vtrunohb
llvm.hexagon.S2.vtrunowh
llvm.hexagon.S2.vzxtbh
llvm.hexagon.S2.vzxthw
llvm.hexagon.S4.addaddi
llvm.hexagon.S4.addi.asl.ri
llvm.hexagon.S4.addi.lsr.ri
llvm.hexagon.S4.andi.asl.ri
llvm.hexagon.S4.andi.lsr.ri
llvm.hexagon.S4.clbaddi
llvm.hexagon.S4.clbpaddi
llvm.hexagon.S4.clbpnorm
llvm.hexagon.S4.extract
llvm.hexagon.S4.extract.rp
llvm.hexagon.S4.extractp
llvm.hexagon.S4.extractp.rp
llvm.hexagon.S4.lsli
llvm.hexagon.S4.ntstbit.i
llvm.hexagon.S4.ntstbit.r
llvm.hexagon.S4.or.andi
llvm.hexagon.S4.or.andix
llvm.hexagon.S4.or.ori
llvm.hexagon.S4.ori.asl.ri
llvm.hexagon.S4.ori.lsr.ri
llvm.hexagon.S4.parity
llvm.hexagon.S4.stored.locked
llvm.hexagon.S4.subaddi
llvm.hexagon.S4.subi.asl.ri
llvm.hexagon.S4.subi.lsr.ri
llvm.hexagon.S4.vrcrotate
llvm.hexagon.S4.vrcrotate.acc
llvm.hexagon.S4.vxaddsubh
llvm.hexagon.S4.vxaddsubhr
llvm.hexagon.S4.vxaddsubw
llvm.hexagon.S4.vxsubaddh
llvm.hexagon.S4.vxsubaddhr
llvm.hexagon.S4.vxsubaddw
llvm.hexagon.S5.asrhub.rnd.sat.goodsyntax
llvm.hexagon.S5.asrhub.sat
llvm.hexagon.S5.popcountp
llvm.hexagon.S5.vasrhrnd.goodsyntax
llvm.hexagon.S6.rol.i.p
llvm.hexagon.S6.rol.i.p.acc
llvm.hexagon.S6.rol.i.p.and
llvm.hexagon.S6.rol.i.p.nac
llvm.hexagon.S6.rol.i.p.or
llvm.hexagon.S6.rol.i.p.xacc
llvm.hexagon.S6.rol.i.r
llvm.hexagon.S6.rol.i.r.acc
llvm.hexagon.S6.rol.i.r.and
llvm.hexagon.S6.rol.i.r.nac
llvm.hexagon.S6.rol.i.r.or
llvm.hexagon.S6.rol.i.r.xacc
llvm.hexagon.S6.vsplatrbp
llvm.hexagon.S6.vtrunehb.ppp
llvm.hexagon.S6.vtrunohb.ppp
llvm.hexagon.V6.extractw
llvm.hexagon.V6.extractw.128B
llvm.hexagon.V6.hi
llvm.hexagon.V6.hi.128B
llvm.hexagon.V6.lo
llvm.hexagon.V6.lo.128B
llvm.hexagon.V6.lvsplatb
llvm.hexagon.V6.lvsplatb.128B
llvm.hexagon.V6.lvsplath
llvm.hexagon.V6.lvsplath.128B
llvm.hexagon.V6.lvsplatw
llvm.hexagon.V6.lvsplatw.128B
llvm.hexagon.V6.pred.and
llvm.hexagon.V6.pred.and.128B
llvm.hexagon.V6.pred.and.n
llvm.hexagon.V6.pred.and.n.128B
llvm.hexagon.V6.pred.not
llvm.hexagon.V6.pred.not.128B
llvm.hexagon.V6.pred.or
llvm.hexagon.V6.pred.or.128B
llvm.hexagon.V6.pred.or.n
llvm.hexagon.V6.pred.or.n.128B
llvm.hexagon.V6.pred.scalar2
llvm.hexagon.V6.pred.scalar2.128B
llvm.hexagon.V6.pred.scalar2v2
llvm.hexagon.V6.pred.scalar2v2.128B
llvm.hexagon.V6.pred.xor
llvm.hexagon.V6.pred.xor.128B
llvm.hexagon.V6.shuffeqh
llvm.hexagon.V6.shuffeqh.128B
llvm.hexagon.V6.shuffeqw
llvm.hexagon.V6.shuffeqw.128B
llvm.hexagon.V6.vS32b.nqpred.ai
llvm.hexagon.V6.vS32b.nqpred.ai.128B
llvm.hexagon.V6.vS32b.nt.nqpred.ai
llvm.hexagon.V6.vS32b.nt.nqpred.ai.128B
llvm.hexagon.V6.vS32b.nt.qpred.ai
llvm.hexagon.V6.vS32b.nt.qpred.ai.128B
llvm.hexagon.V6.vS32b.qpred.ai
llvm.hexagon.V6.vS32b.qpred.ai.128B
llvm.hexagon.V6.vabsb
llvm.hexagon.V6.vabsb.128B
llvm.hexagon.V6.vabsb.sat
llvm.hexagon.V6.vabsb.sat.128B
llvm.hexagon.V6.vabsdiffh
llvm.hexagon.V6.vabsdiffh.128B
llvm.hexagon.V6.vabsdiffub
llvm.hexagon.V6.vabsdiffub.128B
llvm.hexagon.V6.vabsdiffuh
llvm.hexagon.V6.vabsdiffuh.128B
llvm.hexagon.V6.vabsdiffw
llvm.hexagon.V6.vabsdiffw.128B
llvm.hexagon.V6.vabsh
llvm.hexagon.V6.vabsh.128B
llvm.hexagon.V6.vabsh.sat
llvm.hexagon.V6.vabsh.sat.128B
llvm.hexagon.V6.vabsw
llvm.hexagon.V6.vabsw.128B
llvm.hexagon.V6.vabsw.sat
llvm.hexagon.V6.vabsw.sat.128B
llvm.hexagon.V6.vaddb
llvm.hexagon.V6.vaddb.128B
llvm.hexagon.V6.vaddb.dv
llvm.hexagon.V6.vaddb.dv.128B
llvm.hexagon.V6.vaddbnq
llvm.hexagon.V6.vaddbnq.128B
llvm.hexagon.V6.vaddbq
llvm.hexagon.V6.vaddbq.128B
llvm.hexagon.V6.vaddbsat
llvm.hexagon.V6.vaddbsat.128B
llvm.hexagon.V6.vaddbsat.dv
llvm.hexagon.V6.vaddbsat.dv.128B
llvm.hexagon.V6.vaddcarry
llvm.hexagon.V6.vaddcarry.128B
llvm.hexagon.V6.vaddclbh
llvm.hexagon.V6.vaddclbh.128B
llvm.hexagon.V6.vaddclbw
llvm.hexagon.V6.vaddclbw.128B
llvm.hexagon.V6.vaddh
llvm.hexagon.V6.vaddh.128B
llvm.hexagon.V6.vaddh.dv
llvm.hexagon.V6.vaddh.dv.128B
llvm.hexagon.V6.vaddhnq
llvm.hexagon.V6.vaddhnq.128B
llvm.hexagon.V6.vaddhq
llvm.hexagon.V6.vaddhq.128B
llvm.hexagon.V6.vaddhsat
llvm.hexagon.V6.vaddhsat.128B
llvm.hexagon.V6.vaddhsat.dv
llvm.hexagon.V6.vaddhsat.dv.128B
llvm.hexagon.V6.vaddhw
llvm.hexagon.V6.vaddhw.128B
llvm.hexagon.V6.vaddhw.acc
llvm.hexagon.V6.vaddhw.acc.128B
llvm.hexagon.V6.vaddubh
llvm.hexagon.V6.vaddubh.128B
llvm.hexagon.V6.vaddubh.acc
llvm.hexagon.V6.vaddubh.acc.128B
llvm.hexagon.V6.vaddubsat
llvm.hexagon.V6.vaddubsat.128B
llvm.hexagon.V6.vaddubsat.dv
llvm.hexagon.V6.vaddubsat.dv.128B
llvm.hexagon.V6.vaddububb.sat
llvm.hexagon.V6.vaddububb.sat.128B
llvm.hexagon.V6.vadduhsat
llvm.hexagon.V6.vadduhsat.128B
llvm.hexagon.V6.vadduhsat.dv
llvm.hexagon.V6.vadduhsat.dv.128B
llvm.hexagon.V6.vadduhw
llvm.hexagon.V6.vadduhw.128B
llvm.hexagon.V6.vadduhw.acc
llvm.hexagon.V6.vadduhw.acc.128B
llvm.hexagon.V6.vadduwsat
llvm.hexagon.V6.vadduwsat.128B
llvm.hexagon.V6.vadduwsat.dv
llvm.hexagon.V6.vadduwsat.dv.128B
llvm.hexagon.V6.vaddw
llvm.hexagon.V6.vaddw.128B
llvm.hexagon.V6.vaddw.dv
llvm.hexagon.V6.vaddw.dv.128B
llvm.hexagon.V6.vaddwnq
llvm.hexagon.V6.vaddwnq.128B
llvm.hexagon.V6.vaddwq
llvm.hexagon.V6.vaddwq.128B
llvm.hexagon.V6.vaddwsat
llvm.hexagon.V6.vaddwsat.128B
llvm.hexagon.V6.vaddwsat.dv
llvm.hexagon.V6.vaddwsat.dv.128B
llvm.hexagon.V6.valignb
llvm.hexagon.V6.valignb.128B
llvm.hexagon.V6.valignbi
llvm.hexagon.V6.valignbi.128B
llvm.hexagon.V6.vand
llvm.hexagon.V6.vand.128B
llvm.hexagon.V6.vandnqrt
llvm.hexagon.V6.vandnqrt.128B
llvm.hexagon.V6.vandnqrt.acc
llvm.hexagon.V6.vandnqrt.acc.128B
llvm.hexagon.V6.vandqrt
llvm.hexagon.V6.vandqrt.128B
llvm.hexagon.V6.vandqrt.acc
llvm.hexagon.V6.vandqrt.acc.128B
llvm.hexagon.V6.vandvnqv
llvm.hexagon.V6.vandvnqv.128B
llvm.hexagon.V6.vandvqv
llvm.hexagon.V6.vandvqv.128B
llvm.hexagon.V6.vandvrt
llvm.hexagon.V6.vandvrt.128B
llvm.hexagon.V6.vandvrt.acc
llvm.hexagon.V6.vandvrt.acc.128B
llvm.hexagon.V6.vaslh
llvm.hexagon.V6.vaslh.128B
llvm.hexagon.V6.vaslh.acc
llvm.hexagon.V6.vaslh.acc.128B
llvm.hexagon.V6.vaslhv
llvm.hexagon.V6.vaslhv.128B
llvm.hexagon.V6.vaslw
llvm.hexagon.V6.vaslw.128B
llvm.hexagon.V6.vaslw.acc
llvm.hexagon.V6.vaslw.acc.128B
llvm.hexagon.V6.vaslwv
llvm.hexagon.V6.vaslwv.128B
llvm.hexagon.V6.vasrh
llvm.hexagon.V6.vasrh.128B
llvm.hexagon.V6.vasrh.acc
llvm.hexagon.V6.vasrh.acc.128B
llvm.hexagon.V6.vasrhbrndsat
llvm.hexagon.V6.vasrhbrndsat.128B
llvm.hexagon.V6.vasrhbsat
llvm.hexagon.V6.vasrhbsat.128B
llvm.hexagon.V6.vasrhubrndsat
llvm.hexagon.V6.vasrhubrndsat.128B
llvm.hexagon.V6.vasrhubsat
llvm.hexagon.V6.vasrhubsat.128B
llvm.hexagon.V6.vasrhv
llvm.hexagon.V6.vasrhv.128B
llvm.hexagon.V6.vasruhubrndsat
llvm.hexagon.V6.vasruhubrndsat.128B
llvm.hexagon.V6.vasruhubsat
llvm.hexagon.V6.vasruhubsat.128B
llvm.hexagon.V6.vasruwuhrndsat
llvm.hexagon.V6.vasruwuhrndsat.128B
llvm.hexagon.V6.vasruwuhsat
llvm.hexagon.V6.vasruwuhsat.128B
llvm.hexagon.V6.vasrw
llvm.hexagon.V6.vasrw.128B
llvm.hexagon.V6.vasrw.acc
llvm.hexagon.V6.vasrw.acc.128B
llvm.hexagon.V6.vasrwh
llvm.hexagon.V6.vasrwh.128B
llvm.hexagon.V6.vasrwhrndsat
llvm.hexagon.V6.vasrwhrndsat.128B
llvm.hexagon.V6.vasrwhsat
llvm.hexagon.V6.vasrwhsat.128B
llvm.hexagon.V6.vasrwuhrndsat
llvm.hexagon.V6.vasrwuhrndsat.128B
llvm.hexagon.V6.vasrwuhsat
llvm.hexagon.V6.vasrwuhsat.128B
llvm.hexagon.V6.vasrwv
llvm.hexagon.V6.vasrwv.128B
llvm.hexagon.V6.vassign
llvm.hexagon.V6.vassign.128B
llvm.hexagon.V6.vassignp
llvm.hexagon.V6.vassignp.128B
llvm.hexagon.V6.vavgb
llvm.hexagon.V6.vavgb.128B
llvm.hexagon.V6.vavgbrnd
llvm.hexagon.V6.vavgbrnd.128B
llvm.hexagon.V6.vavgh
llvm.hexagon.V6.vavgh.128B
llvm.hexagon.V6.vavghrnd
llvm.hexagon.V6.vavghrnd.128B
llvm.hexagon.V6.vavgub
llvm.hexagon.V6.vavgub.128B
llvm.hexagon.V6.vavgubrnd
llvm.hexagon.V6.vavgubrnd.128B
llvm.hexagon.V6.vavguh
llvm.hexagon.V6.vavguh.128B
llvm.hexagon.V6.vavguhrnd
llvm.hexagon.V6.vavguhrnd.128B
llvm.hexagon.V6.vavguw
llvm.hexagon.V6.vavguw.128B
llvm.hexagon.V6.vavguwrnd
llvm.hexagon.V6.vavguwrnd.128B
llvm.hexagon.V6.vavgw
llvm.hexagon.V6.vavgw.128B
llvm.hexagon.V6.vavgwrnd
llvm.hexagon.V6.vavgwrnd.128B
llvm.hexagon.V6.vcl0h
llvm.hexagon.V6.vcl0h.128B
llvm.hexagon.V6.vcl0w
llvm.hexagon.V6.vcl0w.128B
llvm.hexagon.V6.vcombine
llvm.hexagon.V6.vcombine.128B
llvm.hexagon.V6.vd0
llvm.hexagon.V6.vd0.128B
llvm.hexagon.V6.vdd0
llvm.hexagon.V6.vdd0.128B
llvm.hexagon.V6.vdealb
llvm.hexagon.V6.vdealb.128B
llvm.hexagon.V6.vdealb4w
llvm.hexagon.V6.vdealb4w.128B
llvm.hexagon.V6.vdealh
llvm.hexagon.V6.vdealh.128B
llvm.hexagon.V6.vdealvdd
llvm.hexagon.V6.vdealvdd.128B
llvm.hexagon.V6.vdelta
llvm.hexagon.V6.vdelta.128B
llvm.hexagon.V6.vdmpybus
llvm.hexagon.V6.vdmpybus.128B
llvm.hexagon.V6.vdmpybus.acc
llvm.hexagon.V6.vdmpybus.acc.128B
llvm.hexagon.V6.vdmpybus.dv
llvm.hexagon.V6.vdmpybus.dv.128B
llvm.hexagon.V6.vdmpybus.dv.acc
llvm.hexagon.V6.vdmpybus.dv.acc.128B
llvm.hexagon.V6.vdmpyhb
llvm.hexagon.V6.vdmpyhb.128B
llvm.hexagon.V6.vdmpyhb.acc
llvm.hexagon.V6.vdmpyhb.acc.128B
llvm.hexagon.V6.vdmpyhb.dv
llvm.hexagon.V6.vdmpyhb.dv.128B
llvm.hexagon.V6.vdmpyhb.dv.acc
llvm.hexagon.V6.vdmpyhb.dv.acc.128B
llvm.hexagon.V6.vdmpyhisat
llvm.hexagon.V6.vdmpyhisat.128B
llvm.hexagon.V6.vdmpyhisat.acc
llvm.hexagon.V6.vdmpyhisat.acc.128B
llvm.hexagon.V6.vdmpyhsat
llvm.hexagon.V6.vdmpyhsat.128B
llvm.hexagon.V6.vdmpyhsat.acc
llvm.hexagon.V6.vdmpyhsat.acc.128B
llvm.hexagon.V6.vdmpyhsuisat
llvm.hexagon.V6.vdmpyhsuisat.128B
llvm.hexagon.V6.vdmpyhsuisat.acc
llvm.hexagon.V6.vdmpyhsuisat.acc.128B
llvm.hexagon.V6.vdmpyhsusat
llvm.hexagon.V6.vdmpyhsusat.128B
llvm.hexagon.V6.vdmpyhsusat.acc
llvm.hexagon.V6.vdmpyhsusat.acc.128B
llvm.hexagon.V6.vdmpyhvsat
llvm.hexagon.V6.vdmpyhvsat.128B
llvm.hexagon.V6.vdmpyhvsat.acc
llvm.hexagon.V6.vdmpyhvsat.acc.128B
llvm.hexagon.V6.vdsaduh
llvm.hexagon.V6.vdsaduh.128B
llvm.hexagon.V6.vdsaduh.acc
llvm.hexagon.V6.vdsaduh.acc.128B
llvm.hexagon.V6.veqb
llvm.hexagon.V6.veqb.128B
llvm.hexagon.V6.veqb.and
llvm.hexagon.V6.veqb.and.128B
llvm.hexagon.V6.veqb.or
llvm.hexagon.V6.veqb.or.128B
llvm.hexagon.V6.veqb.xor
llvm.hexagon.V6.veqb.xor.128B
llvm.hexagon.V6.veqh
llvm.hexagon.V6.veqh.128B
llvm.hexagon.V6.veqh.and
llvm.hexagon.V6.veqh.and.128B
llvm.hexagon.V6.veqh.or
llvm.hexagon.V6.veqh.or.128B
llvm.hexagon.V6.veqh.xor
llvm.hexagon.V6.veqh.xor.128B
llvm.hexagon.V6.veqw
llvm.hexagon.V6.veqw.128B
llvm.hexagon.V6.veqw.and
llvm.hexagon.V6.veqw.and.128B
llvm.hexagon.V6.veqw.or
llvm.hexagon.V6.veqw.or.128B
llvm.hexagon.V6.veqw.xor
llvm.hexagon.V6.veqw.xor.128B
llvm.hexagon.V6.vgathermh
llvm.hexagon.V6.vgathermh.128B
llvm.hexagon.V6.vgathermhq
llvm.hexagon.V6.vgathermhq.128B
llvm.hexagon.V6.vgathermhw
llvm.hexagon.V6.vgathermhw.128B
llvm.hexagon.V6.vgathermhwq
llvm.hexagon.V6.vgathermhwq.128B
llvm.hexagon.V6.vgathermw
llvm.hexagon.V6.vgathermw.128B
llvm.hexagon.V6.vgathermwq
llvm.hexagon.V6.vgathermwq.128B
llvm.hexagon.V6.vgtb
llvm.hexagon.V6.vgtb.128B
llvm.hexagon.V6.vgtb.and
llvm.hexagon.V6.vgtb.and.128B
llvm.hexagon.V6.vgtb.or
llvm.hexagon.V6.vgtb.or.128B
llvm.hexagon.V6.vgtb.xor
llvm.hexagon.V6.vgtb.xor.128B
llvm.hexagon.V6.vgth
llvm.hexagon.V6.vgth.128B
llvm.hexagon.V6.vgth.and
llvm.hexagon.V6.vgth.and.128B
llvm.hexagon.V6.vgth.or
llvm.hexagon.V6.vgth.or.128B
llvm.hexagon.V6.vgth.xor
llvm.hexagon.V6.vgth.xor.128B
llvm.hexagon.V6.vgtub
llvm.hexagon.V6.vgtub.128B
llvm.hexagon.V6.vgtub.and
llvm.hexagon.V6.vgtub.and.128B
llvm.hexagon.V6.vgtub.or
llvm.hexagon.V6.vgtub.or.128B
llvm.hexagon.V6.vgtub.xor
llvm.hexagon.V6.vgtub.xor.128B
llvm.hexagon.V6.vgtuh
llvm.hexagon.V6.vgtuh.128B
llvm.hexagon.V6.vgtuh.and
llvm.hexagon.V6.vgtuh.and.128B
llvm.hexagon.V6.vgtuh.or
llvm.hexagon.V6.vgtuh.or.128B
llvm.hexagon.V6.vgtuh.xor
llvm.hexagon.V6.vgtuh.xor.128B
llvm.hexagon.V6.vgtuw
llvm.hexagon.V6.vgtuw.128B
llvm.hexagon.V6.vgtuw.and
llvm.hexagon.V6.vgtuw.and.128B
llvm.hexagon.V6.vgtuw.or
llvm.hexagon.V6.vgtuw.or.128B
llvm.hexagon.V6.vgtuw.xor
llvm.hexagon.V6.vgtuw.xor.128B
llvm.hexagon.V6.vgtw
llvm.hexagon.V6.vgtw.128B
llvm.hexagon.V6.vgtw.and
llvm.hexagon.V6.vgtw.and.128B
llvm.hexagon.V6.vgtw.or
llvm.hexagon.V6.vgtw.or.128B
llvm.hexagon.V6.vgtw.xor
llvm.hexagon.V6.vgtw.xor.128B
llvm.hexagon.V6.vinsertwr
llvm.hexagon.V6.vinsertwr.128B
llvm.hexagon.V6.vlalignb
llvm.hexagon.V6.vlalignb.128B
llvm.hexagon.V6.vlalignbi
llvm.hexagon.V6.vlalignbi.128B
llvm.hexagon.V6.vlsrb
llvm.hexagon.V6.vlsrb.128B
llvm.hexagon.V6.vlsrh
llvm.hexagon.V6.vlsrh.128B
llvm.hexagon.V6.vlsrhv
llvm.hexagon.V6.vlsrhv.128B
llvm.hexagon.V6.vlsrw
llvm.hexagon.V6.vlsrw.128B
llvm.hexagon.V6.vlsrwv
llvm.hexagon.V6.vlsrwv.128B
llvm.hexagon.V6.vlut4
llvm.hexagon.V6.vlut4.128B
llvm.hexagon.V6.vlutvvb
llvm.hexagon.V6.vlutvvb.128B
llvm.hexagon.V6.vlutvvb.nm
llvm.hexagon.V6.vlutvvb.nm.128B
llvm.hexagon.V6.vlutvvb.oracc
llvm.hexagon.V6.vlutvvb.oracc.128B
llvm.hexagon.V6.vlutvvb.oracci
llvm.hexagon.V6.vlutvvb.oracci.128B
llvm.hexagon.V6.vlutvvbi
llvm.hexagon.V6.vlutvvbi.128B
llvm.hexagon.V6.vlutvwh
llvm.hexagon.V6.vlutvwh.128B
llvm.hexagon.V6.vlutvwh.nm
llvm.hexagon.V6.vlutvwh.nm.128B
llvm.hexagon.V6.vlutvwh.oracc
llvm.hexagon.V6.vlutvwh.oracc.128B
llvm.hexagon.V6.vlutvwh.oracci
llvm.hexagon.V6.vlutvwh.oracci.128B
llvm.hexagon.V6.vlutvwhi
llvm.hexagon.V6.vlutvwhi.128B
llvm.hexagon.V6.vmaskedstorenq
llvm.hexagon.V6.vmaskedstorenq.128B
llvm.hexagon.V6.vmaskedstorentnq
llvm.hexagon.V6.vmaskedstorentnq.128B
llvm.hexagon.V6.vmaskedstorentq
llvm.hexagon.V6.vmaskedstorentq.128B
llvm.hexagon.V6.vmaskedstoreq
llvm.hexagon.V6.vmaskedstoreq.128B
llvm.hexagon.V6.vmaxb
llvm.hexagon.V6.vmaxb.128B
llvm.hexagon.V6.vmaxh
llvm.hexagon.V6.vmaxh.128B
llvm.hexagon.V6.vmaxub
llvm.hexagon.V6.vmaxub.128B
llvm.hexagon.V6.vmaxuh
llvm.hexagon.V6.vmaxuh.128B
llvm.hexagon.V6.vmaxw
llvm.hexagon.V6.vmaxw.128B
llvm.hexagon.V6.vminb
llvm.hexagon.V6.vminb.128B
llvm.hexagon.V6.vminh
llvm.hexagon.V6.vminh.128B
llvm.hexagon.V6.vminub
llvm.hexagon.V6.vminub.128B
llvm.hexagon.V6.vminuh
llvm.hexagon.V6.vminuh.128B
llvm.hexagon.V6.vminw
llvm.hexagon.V6.vminw.128B
llvm.hexagon.V6.vmpabus
llvm.hexagon.V6.vmpabus.128B
llvm.hexagon.V6.vmpabus.acc
llvm.hexagon.V6.vmpabus.acc.128B
llvm.hexagon.V6.vmpabusv
llvm.hexagon.V6.vmpabusv.128B
llvm.hexagon.V6.vmpabuu
llvm.hexagon.V6.vmpabuu.128B
llvm.hexagon.V6.vmpabuu.acc
llvm.hexagon.V6.vmpabuu.acc.128B
llvm.hexagon.V6.vmpabuuv
llvm.hexagon.V6.vmpabuuv.128B
llvm.hexagon.V6.vmpahb
llvm.hexagon.V6.vmpahb.128B
llvm.hexagon.V6.vmpahb.acc
llvm.hexagon.V6.vmpahb.acc.128B
llvm.hexagon.V6.vmpahhsat
llvm.hexagon.V6.vmpahhsat.128B
llvm.hexagon.V6.vmpauhb
llvm.hexagon.V6.vmpauhb.128B
llvm.hexagon.V6.vmpauhb.acc
llvm.hexagon.V6.vmpauhb.acc.128B
llvm.hexagon.V6.vmpauhuhsat
llvm.hexagon.V6.vmpauhuhsat.128B
llvm.hexagon.V6.vmpsuhuhsat
llvm.hexagon.V6.vmpsuhuhsat.128B
llvm.hexagon.V6.vmpybus
llvm.hexagon.V6.vmpybus.128B
llvm.hexagon.V6.vmpybus.acc
llvm.hexagon.V6.vmpybus.acc.128B
llvm.hexagon.V6.vmpybusv
llvm.hexagon.V6.vmpybusv.128B
llvm.hexagon.V6.vmpybusv.acc
llvm.hexagon.V6.vmpybusv.acc.128B
llvm.hexagon.V6.vmpybv
llvm.hexagon.V6.vmpybv.128B
llvm.hexagon.V6.vmpybv.acc
llvm.hexagon.V6.vmpybv.acc.128B
llvm.hexagon.V6.vmpyewuh
llvm.hexagon.V6.vmpyewuh.128B
llvm.hexagon.V6.vmpyewuh.64
llvm.hexagon.V6.vmpyewuh.64.128B
llvm.hexagon.V6.vmpyh
llvm.hexagon.V6.vmpyh.128B
llvm.hexagon.V6.vmpyh.acc
llvm.hexagon.V6.vmpyh.acc.128B
llvm.hexagon.V6.vmpyhsat.acc
llvm.hexagon.V6.vmpyhsat.acc.128B
llvm.hexagon.V6.vmpyhsrs
llvm.hexagon.V6.vmpyhsrs.128B
llvm.hexagon.V6.vmpyhss
llvm.hexagon.V6.vmpyhss.128B
llvm.hexagon.V6.vmpyhus
llvm.hexagon.V6.vmpyhus.128B
llvm.hexagon.V6.vmpyhus.acc
llvm.hexagon.V6.vmpyhus.acc.128B
llvm.hexagon.V6.vmpyhv
llvm.hexagon.V6.vmpyhv.128B
llvm.hexagon.V6.vmpyhv.acc
llvm.hexagon.V6.vmpyhv.acc.128B
llvm.hexagon.V6.vmpyhvsrs
llvm.hexagon.V6.vmpyhvsrs.128B
llvm.hexagon.V6.vmpyieoh
llvm.hexagon.V6.vmpyieoh.128B
llvm.hexagon.V6.vmpyiewh.acc
llvm.hexagon.V6.vmpyiewh.acc.128B
llvm.hexagon.V6.vmpyiewuh
llvm.hexagon.V6.vmpyiewuh.128B
llvm.hexagon.V6.vmpyiewuh.acc
llvm.hexagon.V6.vmpyiewuh.acc.128B
llvm.hexagon.V6.vmpyih
llvm.hexagon.V6.vmpyih.128B
llvm.hexagon.V6.vmpyih.acc
llvm.hexagon.V6.vmpyih.acc.128B
llvm.hexagon.V6.vmpyihb
llvm.hexagon.V6.vmpyihb.128B
llvm.hexagon.V6.vmpyihb.acc
llvm.hexagon.V6.vmpyihb.acc.128B
llvm.hexagon.V6.vmpyiowh
llvm.hexagon.V6.vmpyiowh.128B
llvm.hexagon.V6.vmpyiwb
llvm.hexagon.V6.vmpyiwb.128B
llvm.hexagon.V6.vmpyiwb.acc
llvm.hexagon.V6.vmpyiwb.acc.128B
llvm.hexagon.V6.vmpyiwh
llvm.hexagon.V6.vmpyiwh.128B
llvm.hexagon.V6.vmpyiwh.acc
llvm.hexagon.V6.vmpyiwh.acc.128B
llvm.hexagon.V6.vmpyiwub
llvm.hexagon.V6.vmpyiwub.128B
llvm.hexagon.V6.vmpyiwub.acc
llvm.hexagon.V6.vmpyiwub.acc.128B
llvm.hexagon.V6.vmpyowh
llvm.hexagon.V6.vmpyowh.128B
llvm.hexagon.V6.vmpyowh.64.acc
llvm.hexagon.V6.vmpyowh.64.acc.128B
llvm.hexagon.V6.vmpyowh.rnd
llvm.hexagon.V6.vmpyowh.rnd.128B
llvm.hexagon.V6.vmpyowh.rnd.sacc
llvm.hexagon.V6.vmpyowh.rnd.sacc.128B
llvm.hexagon.V6.vmpyowh.sacc
llvm.hexagon.V6.vmpyowh.sacc.128B
llvm.hexagon.V6.vmpyub
llvm.hexagon.V6.vmpyub.128B
llvm.hexagon.V6.vmpyub.acc
llvm.hexagon.V6.vmpyub.acc.128B
llvm.hexagon.V6.vmpyubv
llvm.hexagon.V6.vmpyubv.128B
llvm.hexagon.V6.vmpyubv.acc
llvm.hexagon.V6.vmpyubv.acc.128B
llvm.hexagon.V6.vmpyuh
llvm.hexagon.V6.vmpyuh.128B
llvm.hexagon.V6.vmpyuh.acc
llvm.hexagon.V6.vmpyuh.acc.128B
llvm.hexagon.V6.vmpyuhe
llvm.hexagon.V6.vmpyuhe.128B
llvm.hexagon.V6.vmpyuhe.acc
llvm.hexagon.V6.vmpyuhe.acc.128B
llvm.hexagon.V6.vmpyuhv
llvm.hexagon.V6.vmpyuhv.128B
llvm.hexagon.V6.vmpyuhv.acc
llvm.hexagon.V6.vmpyuhv.acc.128B
llvm.hexagon.V6.vmux
llvm.hexagon.V6.vmux.128B
llvm.hexagon.V6.vnavgb
llvm.hexagon.V6.vnavgb.128B
llvm.hexagon.V6.vnavgh
llvm.hexagon.V6.vnavgh.128B
llvm.hexagon.V6.vnavgub
llvm.hexagon.V6.vnavgub.128B
llvm.hexagon.V6.vnavgw
llvm.hexagon.V6.vnavgw.128B
llvm.hexagon.V6.vnormamth
llvm.hexagon.V6.vnormamth.128B
llvm.hexagon.V6.vnormamtw
llvm.hexagon.V6.vnormamtw.128B
llvm.hexagon.V6.vnot
llvm.hexagon.V6.vnot.128B
llvm.hexagon.V6.vor
llvm.hexagon.V6.vor.128B
llvm.hexagon.V6.vpackeb
llvm.hexagon.V6.vpackeb.128B
llvm.hexagon.V6.vpackeh
llvm.hexagon.V6.vpackeh.128B
llvm.hexagon.V6.vpackhb.sat
llvm.hexagon.V6.vpackhb.sat.128B
llvm.hexagon.V6.vpackhub.sat
llvm.hexagon.V6.vpackhub.sat.128B
llvm.hexagon.V6.vpackob
llvm.hexagon.V6.vpackob.128B
llvm.hexagon.V6.vpackoh
llvm.hexagon.V6.vpackoh.128B
llvm.hexagon.V6.vpackwh.sat
llvm.hexagon.V6.vpackwh.sat.128B
llvm.hexagon.V6.vpackwuh.sat
llvm.hexagon.V6.vpackwuh.sat.128B
llvm.hexagon.V6.vpopcounth
llvm.hexagon.V6.vpopcounth.128B
llvm.hexagon.V6.vprefixqb
llvm.hexagon.V6.vprefixqb.128B
llvm.hexagon.V6.vprefixqh
llvm.hexagon.V6.vprefixqh.128B
llvm.hexagon.V6.vprefixqw
llvm.hexagon.V6.vprefixqw.128B
llvm.hexagon.V6.vrdelta
llvm.hexagon.V6.vrdelta.128B
llvm.hexagon.V6.vrmpybub.rtt
llvm.hexagon.V6.vrmpybub.rtt.128B
llvm.hexagon.V6.vrmpybub.rtt.acc
llvm.hexagon.V6.vrmpybub.rtt.acc.128B
llvm.hexagon.V6.vrmpybus
llvm.hexagon.V6.vrmpybus.128B
llvm.hexagon.V6.vrmpybus.acc
llvm.hexagon.V6.vrmpybus.acc.128B
llvm.hexagon.V6.vrmpybusi
llvm.hexagon.V6.vrmpybusi.128B
llvm.hexagon.V6.vrmpybusi.acc
llvm.hexagon.V6.vrmpybusi.acc.128B
llvm.hexagon.V6.vrmpybusv
llvm.hexagon.V6.vrmpybusv.128B
llvm.hexagon.V6.vrmpybusv.acc
llvm.hexagon.V6.vrmpybusv.acc.128B
llvm.hexagon.V6.vrmpybv
llvm.hexagon.V6.vrmpybv.128B
llvm.hexagon.V6.vrmpybv.acc
llvm.hexagon.V6.vrmpybv.acc.128B
llvm.hexagon.V6.vrmpyub
llvm.hexagon.V6.vrmpyub.128B
llvm.hexagon.V6.vrmpyub.acc
llvm.hexagon.V6.vrmpyub.acc.128B
llvm.hexagon.V6.vrmpyub.rtt
llvm.hexagon.V6.vrmpyub.rtt.128B
llvm.hexagon.V6.vrmpyub.rtt.acc
llvm.hexagon.V6.vrmpyub.rtt.acc.128B
llvm.hexagon.V6.vrmpyubi
llvm.hexagon.V6.vrmpyubi.128B
llvm.hexagon.V6.vrmpyubi.acc
llvm.hexagon.V6.vrmpyubi.acc.128B
llvm.hexagon.V6.vrmpyubv
llvm.hexagon.V6.vrmpyubv.128B
llvm.hexagon.V6.vrmpyubv.acc
llvm.hexagon.V6.vrmpyubv.acc.128B
llvm.hexagon.V6.vror
llvm.hexagon.V6.vror.128B
llvm.hexagon.V6.vroundhb
llvm.hexagon.V6.vroundhb.128B
llvm.hexagon.V6.vroundhub
llvm.hexagon.V6.vroundhub.128B
llvm.hexagon.V6.vrounduhub
llvm.hexagon.V6.vrounduhub.128B
llvm.hexagon.V6.vrounduwuh
llvm.hexagon.V6.vrounduwuh.128B
llvm.hexagon.V6.vroundwh
llvm.hexagon.V6.vroundwh.128B
llvm.hexagon.V6.vroundwuh
llvm.hexagon.V6.vroundwuh.128B
llvm.hexagon.V6.vrsadubi
llvm.hexagon.V6.vrsadubi.128B
llvm.hexagon.V6.vrsadubi.acc
llvm.hexagon.V6.vrsadubi.acc.128B
llvm.hexagon.V6.vsathub
llvm.hexagon.V6.vsathub.128B
llvm.hexagon.V6.vsatuwuh
llvm.hexagon.V6.vsatuwuh.128B
llvm.hexagon.V6.vsatwh
llvm.hexagon.V6.vsatwh.128B
llvm.hexagon.V6.vsb
llvm.hexagon.V6.vsb.128B
llvm.hexagon.V6.vscattermh
llvm.hexagon.V6.vscattermh.128B
llvm.hexagon.V6.vscattermh.add
llvm.hexagon.V6.vscattermh.add.128B
llvm.hexagon.V6.vscattermhq
llvm.hexagon.V6.vscattermhq.128B
llvm.hexagon.V6.vscattermhw
llvm.hexagon.V6.vscattermhw.128B
llvm.hexagon.V6.vscattermhw.add
llvm.hexagon.V6.vscattermhw.add.128B
llvm.hexagon.V6.vscattermhwq
llvm.hexagon.V6.vscattermhwq.128B
llvm.hexagon.V6.vscattermw
llvm.hexagon.V6.vscattermw.128B
llvm.hexagon.V6.vscattermw.add
llvm.hexagon.V6.vscattermw.add.128B
llvm.hexagon.V6.vscattermwq
llvm.hexagon.V6.vscattermwq.128B
llvm.hexagon.V6.vsh
llvm.hexagon.V6.vsh.128B
llvm.hexagon.V6.vshufeh
llvm.hexagon.V6.vshufeh.128B
llvm.hexagon.V6.vshuffb
llvm.hexagon.V6.vshuffb.128B
llvm.hexagon.V6.vshuffeb
llvm.hexagon.V6.vshuffeb.128B
llvm.hexagon.V6.vshuffh
llvm.hexagon.V6.vshuffh.128B
llvm.hexagon.V6.vshuffob
llvm.hexagon.V6.vshuffob.128B
llvm.hexagon.V6.vshuffvdd
llvm.hexagon.V6.vshuffvdd.128B
llvm.hexagon.V6.vshufoeb
llvm.hexagon.V6.vshufoeb.128B
llvm.hexagon.V6.vshufoeh
llvm.hexagon.V6.vshufoeh.128B
llvm.hexagon.V6.vshufoh
llvm.hexagon.V6.vshufoh.128B
llvm.hexagon.V6.vsubb
llvm.hexagon.V6.vsubb.128B
llvm.hexagon.V6.vsubb.dv
llvm.hexagon.V6.vsubb.dv.128B
llvm.hexagon.V6.vsubbnq
llvm.hexagon.V6.vsubbnq.128B
llvm.hexagon.V6.vsubbq
llvm.hexagon.V6.vsubbq.128B
llvm.hexagon.V6.vsubbsat
llvm.hexagon.V6.vsubbsat.128B
llvm.hexagon.V6.vsubbsat.dv
llvm.hexagon.V6.vsubbsat.dv.128B
llvm.hexagon.V6.vsubcarry
llvm.hexagon.V6.vsubcarry.128B
llvm.hexagon.V6.vsubh
llvm.hexagon.V6.vsubh.128B
llvm.hexagon.V6.vsubh.dv
llvm.hexagon.V6.vsubh.dv.128B
llvm.hexagon.V6.vsubhnq
llvm.hexagon.V6.vsubhnq.128B
llvm.hexagon.V6.vsubhq
llvm.hexagon.V6.vsubhq.128B
llvm.hexagon.V6.vsubhsat
llvm.hexagon.V6.vsubhsat.128B
llvm.hexagon.V6.vsubhsat.dv
llvm.hexagon.V6.vsubhsat.dv.128B
llvm.hexagon.V6.vsubhw
llvm.hexagon.V6.vsubhw.128B
llvm.hexagon.V6.vsububh
llvm.hexagon.V6.vsububh.128B
llvm.hexagon.V6.vsububsat
llvm.hexagon.V6.vsububsat.128B
llvm.hexagon.V6.vsububsat.dv
llvm.hexagon.V6.vsububsat.dv.128B
llvm.hexagon.V6.vsubububb.sat
llvm.hexagon.V6.vsubububb.sat.128B
llvm.hexagon.V6.vsubuhsat
llvm.hexagon.V6.vsubuhsat.128B
llvm.hexagon.V6.vsubuhsat.dv
llvm.hexagon.V6.vsubuhsat.dv.128B
llvm.hexagon.V6.vsubuhw
llvm.hexagon.V6.vsubuhw.128B
llvm.hexagon.V6.vsubuwsat
llvm.hexagon.V6.vsubuwsat.128B
llvm.hexagon.V6.vsubuwsat.dv
llvm.hexagon.V6.vsubuwsat.dv.128B
llvm.hexagon.V6.vsubw
llvm.hexagon.V6.vsubw.128B
llvm.hexagon.V6.vsubw.dv
llvm.hexagon.V6.vsubw.dv.128B
llvm.hexagon.V6.vsubwnq
llvm.hexagon.V6.vsubwnq.128B
llvm.hexagon.V6.vsubwq
llvm.hexagon.V6.vsubwq.128B
llvm.hexagon.V6.vsubwsat
llvm.hexagon.V6.vsubwsat.128B
llvm.hexagon.V6.vsubwsat.dv
llvm.hexagon.V6.vsubwsat.dv.128B
llvm.hexagon.V6.vswap
llvm.hexagon.V6.vswap.128B
llvm.hexagon.V6.vtmpyb
llvm.hexagon.V6.vtmpyb.128B
llvm.hexagon.V6.vtmpyb.acc
llvm.hexagon.V6.vtmpyb.acc.128B
llvm.hexagon.V6.vtmpybus
llvm.hexagon.V6.vtmpybus.128B
llvm.hexagon.V6.vtmpybus.acc
llvm.hexagon.V6.vtmpybus.acc.128B
llvm.hexagon.V6.vtmpyhb
llvm.hexagon.V6.vtmpyhb.128B
llvm.hexagon.V6.vtmpyhb.acc
llvm.hexagon.V6.vtmpyhb.acc.128B
llvm.hexagon.V6.vunpackb
llvm.hexagon.V6.vunpackb.128B
llvm.hexagon.V6.vunpackh
llvm.hexagon.V6.vunpackh.128B
llvm.hexagon.V6.vunpackob
llvm.hexagon.V6.vunpackob.128B
llvm.hexagon.V6.vunpackoh
llvm.hexagon.V6.vunpackoh.128B
llvm.hexagon.V6.vunpackub
llvm.hexagon.V6.vunpackub.128B
llvm.hexagon.V6.vunpackuh
llvm.hexagon.V6.vunpackuh.128B
llvm.hexagon.V6.vxor
llvm.hexagon.V6.vxor.128B
llvm.hexagon.V6.vzb
llvm.hexagon.V6.vzb.128B
llvm.hexagon.V6.vzh
llvm.hexagon.V6.vzh.128B
llvm.hexagon.Y2.dccleana
llvm.hexagon.Y2.dccleaninva
llvm.hexagon.Y2.dcinva
llvm.hexagon.Y2.dczeroa
llvm.hexagon.Y4.l2fetch
llvm.hexagon.Y5.l2fetch
llvm.hexagon.circ.ldb
llvm.hexagon.circ.ldd
llvm.hexagon.circ.ldh
llvm.hexagon.circ.ldub
llvm.hexagon.circ.lduh
llvm.hexagon.circ.ldw
llvm.hexagon.circ.stb
llvm.hexagon.circ.std
llvm.hexagon.circ.sth
llvm.hexagon.circ.sthhi
llvm.hexagon.circ.stw
llvm.hexagon.mm256i.vaddw
llvm.hexagon.prefetch
llvm.mips.absq.s.ph
llvm.mips.absq.s.qb
llvm.mips.absq.s.w
llvm.mips.add.a.b
llvm.mips.add.a.d
llvm.mips.add.a.h
llvm.mips.add.a.w
llvm.mips.addq.ph
llvm.mips.addq.s.ph
llvm.mips.addq.s.w
llvm.mips.addqh.ph
llvm.mips.addqh.r.ph
llvm.mips.addqh.r.w
llvm.mips.addqh.w
llvm.mips.adds.a.b
llvm.mips.adds.a.d
llvm.mips.adds.a.h
llvm.mips.adds.a.w
llvm.mips.adds.s.b
llvm.mips.adds.s.d
llvm.mips.adds.s.h
llvm.mips.adds.s.w
llvm.mips.adds.u.b
llvm.mips.adds.u.d
llvm.mips.adds.u.h
llvm.mips.adds.u.w
llvm.mips.addsc
llvm.mips.addu.ph
llvm.mips.addu.qb
llvm.mips.addu.s.ph
llvm.mips.addu.s.qb
llvm.mips.adduh.qb
llvm.mips.adduh.r.qb
llvm.mips.addv.b
llvm.mips.addv.d
llvm.mips.addv.h
llvm.mips.addv.w
llvm.mips.addvi.b
llvm.mips.addvi.d
llvm.mips.addvi.h
llvm.mips.addvi.w
llvm.mips.addwc
llvm.mips.and.v
llvm.mips.andi.b
llvm.mips.append
llvm.mips.asub.s.b
llvm.mips.asub.s.d
llvm.mips.asub.s.h
llvm.mips.asub.s.w
llvm.mips.asub.u.b
llvm.mips.asub.u.d
llvm.mips.asub.u.h
llvm.mips.asub.u.w
llvm.mips.ave.s.b
llvm.mips.ave.s.d
llvm.mips.ave.s.h
llvm.mips.ave.s.w
llvm.mips.ave.u.b
llvm.mips.ave.u.d
llvm.mips.ave.u.h
llvm.mips.ave.u.w
llvm.mips.aver.s.b
llvm.mips.aver.s.d
llvm.mips.aver.s.h
llvm.mips.aver.s.w
llvm.mips.aver.u.b
llvm.mips.aver.u.d
llvm.mips.aver.u.h
llvm.mips.aver.u.w
llvm.mips.balign
llvm.mips.bclr.b
llvm.mips.bclr.d
llvm.mips.bclr.h
llvm.mips.bclr.w
llvm.mips.bclri.b
llvm.mips.bclri.d
llvm.mips.bclri.h
llvm.mips.bclri.w
llvm.mips.binsl.b
llvm.mips.binsl.d
llvm.mips.binsl.h
llvm.mips.binsl.w
llvm.mips.binsli.b
llvm.mips.binsli.d
llvm.mips.binsli.h
llvm.mips.binsli.w
llvm.mips.binsr.b
llvm.mips.binsr.d
llvm.mips.binsr.h
llvm.mips.binsr.w
llvm.mips.binsri.b
llvm.mips.binsri.d
llvm.mips.binsri.h
llvm.mips.binsri.w
llvm.mips.bitrev
llvm.mips.bmnz.v
llvm.mips.bmnzi.b
llvm.mips.bmz.v
llvm.mips.bmzi.b
llvm.mips.bneg.b
llvm.mips.bneg.d
llvm.mips.bneg.h
llvm.mips.bneg.w
llvm.mips.bnegi.b
llvm.mips.bnegi.d
llvm.mips.bnegi.h
llvm.mips.bnegi.w
llvm.mips.bnz.b
llvm.mips.bnz.d
llvm.mips.bnz.h
llvm.mips.bnz.v
llvm.mips.bnz.w
llvm.mips.bposge32
llvm.mips.bsel.v
llvm.mips.bseli.b
llvm.mips.bset.b
llvm.mips.bset.d
llvm.mips.bset.h
llvm.mips.bset.w
llvm.mips.bseti.b
llvm.mips.bseti.d
llvm.mips.bseti.h
llvm.mips.bseti.w
llvm.mips.bz.b
llvm.mips.bz.d
llvm.mips.bz.h
llvm.mips.bz.v
llvm.mips.bz.w
llvm.mips.ceq.b
llvm.mips.ceq.d
llvm.mips.ceq.h
llvm.mips.ceq.w
llvm.mips.ceqi.b
llvm.mips.ceqi.d
llvm.mips.ceqi.h
llvm.mips.ceqi.w
llvm.mips.cfcmsa
llvm.mips.cle.s.b
llvm.mips.cle.s.d
llvm.mips.cle.s.h
llvm.mips.cle.s.w
llvm.mips.cle.u.b
llvm.mips.cle.u.d
llvm.mips.cle.u.h
llvm.mips.cle.u.w
llvm.mips.clei.s.b
llvm.mips.clei.s.d
llvm.mips.clei.s.h
llvm.mips.clei.s.w
llvm.mips.clei.u.b
llvm.mips.clei.u.d
llvm.mips.clei.u.h
llvm.mips.clei.u.w
llvm.mips.clt.s.b
llvm.mips.clt.s.d
llvm.mips.clt.s.h
llvm.mips.clt.s.w
llvm.mips.clt.u.b
llvm.mips.clt.u.d
llvm.mips.clt.u.h
llvm.mips.clt.u.w
llvm.mips.clti.s.b
llvm.mips.clti.s.d
llvm.mips.clti.s.h
llvm.mips.clti.s.w
llvm.mips.clti.u.b
llvm.mips.clti.u.d
llvm.mips.clti.u.h
llvm.mips.clti.u.w
llvm.mips.cmp.eq.ph
llvm.mips.cmp.le.ph
llvm.mips.cmp.lt.ph
llvm.mips.cmpgdu.eq.qb
llvm.mips.cmpgdu.le.qb
llvm.mips.cmpgdu.lt.qb
llvm.mips.cmpgu.eq.qb
llvm.mips.cmpgu.le.qb
llvm.mips.cmpgu.lt.qb
llvm.mips.cmpu.eq.qb
llvm.mips.cmpu.le.qb
llvm.mips.cmpu.lt.qb
llvm.mips.copy.s.b
llvm.mips.copy.s.d
llvm.mips.copy.s.h
llvm.mips.copy.s.w
llvm.mips.copy.u.b
llvm.mips.copy.u.d
llvm.mips.copy.u.h
llvm.mips.copy.u.w
llvm.mips.ctcmsa
llvm.mips.div.s.b
llvm.mips.div.s.d
llvm.mips.div.s.h
llvm.mips.div.s.w
llvm.mips.div.u.b
llvm.mips.div.u.d
llvm.mips.div.u.h
llvm.mips.div.u.w
llvm.mips.dlsa
llvm.mips.dotp.s.d
llvm.mips.dotp.s.h
llvm.mips.dotp.s.w
llvm.mips.dotp.u.d
llvm.mips.dotp.u.h
llvm.mips.dotp.u.w
llvm.mips.dpa.w.ph
llvm.mips.dpadd.s.d
llvm.mips.dpadd.s.h
llvm.mips.dpadd.s.w
llvm.mips.dpadd.u.d
llvm.mips.dpadd.u.h
llvm.mips.dpadd.u.w
llvm.mips.dpaq.s.w.ph
llvm.mips.dpaq.sa.l.w
llvm.mips.dpaqx.s.w.ph
llvm.mips.dpaqx.sa.w.ph
llvm.mips.dpau.h.qbl
llvm.mips.dpau.h.qbr
llvm.mips.dpax.w.ph
llvm.mips.dps.w.ph
llvm.mips.dpsq.s.w.ph
llvm.mips.dpsq.sa.l.w
llvm.mips.dpsqx.s.w.ph
llvm.mips.dpsqx.sa.w.ph
llvm.mips.dpsu.h.qbl
llvm.mips.dpsu.h.qbr
llvm.mips.dpsub.s.d
llvm.mips.dpsub.s.h
llvm.mips.dpsub.s.w
llvm.mips.dpsub.u.d
llvm.mips.dpsub.u.h
llvm.mips.dpsub.u.w
llvm.mips.dpsx.w.ph
llvm.mips.extp
llvm.mips.extpdp
llvm.mips.extr.r.w
llvm.mips.extr.rs.w
llvm.mips.extr.s.h
llvm.mips.extr.w
llvm.mips.fadd.d
llvm.mips.fadd.w
llvm.mips.fcaf.d
llvm.mips.fcaf.w
llvm.mips.fceq.d
llvm.mips.fceq.w
llvm.mips.fclass.d
llvm.mips.fclass.w
llvm.mips.fcle.d
llvm.mips.fcle.w
llvm.mips.fclt.d
llvm.mips.fclt.w
llvm.mips.fcne.d
llvm.mips.fcne.w
llvm.mips.fcor.d
llvm.mips.fcor.w
llvm.mips.fcueq.d
llvm.mips.fcueq.w
llvm.mips.fcule.d
llvm.mips.fcule.w
llvm.mips.fcult.d
llvm.mips.fcult.w
llvm.mips.fcun.d
llvm.mips.fcun.w
llvm.mips.fcune.d
llvm.mips.fcune.w
llvm.mips.fdiv.d
llvm.mips.fdiv.w
llvm.mips.fexdo.h
llvm.mips.fexdo.w
llvm.mips.fexp2.d
llvm.mips.fexp2.w
llvm.mips.fexupl.d
llvm.mips.fexupl.w
llvm.mips.fexupr.d
llvm.mips.fexupr.w
llvm.mips.ffint.s.d
llvm.mips.ffint.s.w
llvm.mips.ffint.u.d
llvm.mips.ffint.u.w
llvm.mips.ffql.d
llvm.mips.ffql.w
llvm.mips.ffqr.d
llvm.mips.ffqr.w
llvm.mips.fill.b
llvm.mips.fill.d
llvm.mips.fill.h
llvm.mips.fill.w
llvm.mips.flog2.d
llvm.mips.flog2.w
llvm.mips.fmadd.d
llvm.mips.fmadd.w
llvm.mips.fmax.a.d
llvm.mips.fmax.a.w
llvm.mips.fmax.d
llvm.mips.fmax.w
llvm.mips.fmin.a.d
llvm.mips.fmin.a.w
llvm.mips.fmin.d
llvm.mips.fmin.w
llvm.mips.fmsub.d
llvm.mips.fmsub.w
llvm.mips.fmul.d
llvm.mips.fmul.w
llvm.mips.frcp.d
llvm.mips.frcp.w
llvm.mips.frint.d
llvm.mips.frint.w
llvm.mips.frsqrt.d
llvm.mips.frsqrt.w
llvm.mips.fsaf.d
llvm.mips.fsaf.w
llvm.mips.fseq.d
llvm.mips.fseq.w
llvm.mips.fsle.d
llvm.mips.fsle.w
llvm.mips.fslt.d
llvm.mips.fslt.w
llvm.mips.fsne.d
llvm.mips.fsne.w
llvm.mips.fsor.d
llvm.mips.fsor.w
llvm.mips.fsqrt.d
llvm.mips.fsqrt.w
llvm.mips.fsub.d
llvm.mips.fsub.w
llvm.mips.fsueq.d
llvm.mips.fsueq.w
llvm.mips.fsule.d
llvm.mips.fsule.w
llvm.mips.fsult.d
llvm.mips.fsult.w
llvm.mips.fsun.d
llvm.mips.fsun.w
llvm.mips.fsune.d
llvm.mips.fsune.w
llvm.mips.ftint.s.d
llvm.mips.ftint.s.w
llvm.mips.ftint.u.d
llvm.mips.ftint.u.w
llvm.mips.ftq.h
llvm.mips.ftq.w
llvm.mips.ftrunc.s.d
llvm.mips.ftrunc.s.w
llvm.mips.ftrunc.u.d
llvm.mips.ftrunc.u.w
llvm.mips.hadd.s.d
llvm.mips.hadd.s.h
llvm.mips.hadd.s.w
llvm.mips.hadd.u.d
llvm.mips.hadd.u.h
llvm.mips.hadd.u.w
llvm.mips.hsub.s.d
llvm.mips.hsub.s.h
llvm.mips.hsub.s.w
llvm.mips.hsub.u.d
llvm.mips.hsub.u.h
llvm.mips.hsub.u.w
llvm.mips.ilvev.b
llvm.mips.ilvev.d
llvm.mips.ilvev.h
llvm.mips.ilvev.w
llvm.mips.ilvl.b
llvm.mips.ilvl.d
llvm.mips.ilvl.h
llvm.mips.ilvl.w
llvm.mips.ilvod.b
llvm.mips.ilvod.d
llvm.mips.ilvod.h
llvm.mips.ilvod.w
llvm.mips.ilvr.b
llvm.mips.ilvr.d
llvm.mips.ilvr.h
llvm.mips.ilvr.w
llvm.mips.insert.b
llvm.mips.insert.d
llvm.mips.insert.h
llvm.mips.insert.w
llvm.mips.insv
llvm.mips.insve.b
llvm.mips.insve.d
llvm.mips.insve.h
llvm.mips.insve.w
llvm.mips.lbux
llvm.mips.ld.b
llvm.mips.ld.d
llvm.mips.ld.h
llvm.mips.ld.w
llvm.mips.ldi.b
llvm.mips.ldi.d
llvm.mips.ldi.h
llvm.mips.ldi.w
llvm.mips.lhx
llvm.mips.lsa
llvm.mips.lwx
llvm.mips.madd
llvm.mips.madd.q.h
llvm.mips.madd.q.w
llvm.mips.maddr.q.h
llvm.mips.maddr.q.w
llvm.mips.maddu
llvm.mips.maddv.b
llvm.mips.maddv.d
llvm.mips.maddv.h
llvm.mips.maddv.w
llvm.mips.maq.s.w.phl
llvm.mips.maq.s.w.phr
llvm.mips.maq.sa.w.phl
llvm.mips.maq.sa.w.phr
llvm.mips.max.a.b
llvm.mips.max.a.d
llvm.mips.max.a.h
llvm.mips.max.a.w
llvm.mips.max.s.b
llvm.mips.max.s.d
llvm.mips.max.s.h
llvm.mips.max.s.w
llvm.mips.max.u.b
llvm.mips.max.u.d
llvm.mips.max.u.h
llvm.mips.max.u.w
llvm.mips.maxi.s.b
llvm.mips.maxi.s.d
llvm.mips.maxi.s.h
llvm.mips.maxi.s.w
llvm.mips.maxi.u.b
llvm.mips.maxi.u.d
llvm.mips.maxi.u.h
llvm.mips.maxi.u.w
llvm.mips.min.a.b
llvm.mips.min.a.d
llvm.mips.min.a.h
llvm.mips.min.a.w
llvm.mips.min.s.b
llvm.mips.min.s.d
llvm.mips.min.s.h
llvm.mips.min.s.w
llvm.mips.min.u.b
llvm.mips.min.u.d
llvm.mips.min.u.h
llvm.mips.min.u.w
llvm.mips.mini.s.b
llvm.mips.mini.s.d
llvm.mips.mini.s.h
llvm.mips.mini.s.w
llvm.mips.mini.u.b
llvm.mips.mini.u.d
llvm.mips.mini.u.h
llvm.mips.mini.u.w
llvm.mips.mod.s.b
llvm.mips.mod.s.d
llvm.mips.mod.s.h
llvm.mips.mod.s.w
llvm.mips.mod.u.b
llvm.mips.mod.u.d
llvm.mips.mod.u.h
llvm.mips.mod.u.w
llvm.mips.modsub
llvm.mips.move.v
llvm.mips.msub
llvm.mips.msub.q.h
llvm.mips.msub.q.w
llvm.mips.msubr.q.h
llvm.mips.msubr.q.w
llvm.mips.msubu
llvm.mips.msubv.b
llvm.mips.msubv.d
llvm.mips.msubv.h
llvm.mips.msubv.w
llvm.mips.mthlip
llvm.mips.mul.ph
llvm.mips.mul.q.h
llvm.mips.mul.q.w
llvm.mips.mul.s.ph
llvm.mips.muleq.s.w.phl
llvm.mips.muleq.s.w.phr
llvm.mips.muleu.s.ph.qbl
llvm.mips.muleu.s.ph.qbr
llvm.mips.mulq.rs.ph
llvm.mips.mulq.rs.w
llvm.mips.mulq.s.ph
llvm.mips.mulq.s.w
llvm.mips.mulr.q.h
llvm.mips.mulr.q.w
llvm.mips.mulsa.w.ph
llvm.mips.mulsaq.s.w.ph
llvm.mips.mult
llvm.mips.multu
llvm.mips.mulv.b
llvm.mips.mulv.d
llvm.mips.mulv.h
llvm.mips.mulv.w
llvm.mips.nloc.b
llvm.mips.nloc.d
llvm.mips.nloc.h
llvm.mips.nloc.w
llvm.mips.nlzc.b
llvm.mips.nlzc.d
llvm.mips.nlzc.h
llvm.mips.nlzc.w
llvm.mips.nor.v
llvm.mips.nori.b
llvm.mips.or.v
llvm.mips.ori.b
llvm.mips.packrl.ph
llvm.mips.pckev.b
llvm.mips.pckev.d
llvm.mips.pckev.h
llvm.mips.pckev.w
llvm.mips.pckod.b
llvm.mips.pckod.d
llvm.mips.pckod.h
llvm.mips.pckod.w
llvm.mips.pcnt.b
llvm.mips.pcnt.d
llvm.mips.pcnt.h
llvm.mips.pcnt.w
llvm.mips.pick.ph
llvm.mips.pick.qb
llvm.mips.preceq.w.phl
llvm.mips.preceq.w.phr
llvm.mips.precequ.ph.qbl
llvm.mips.precequ.ph.qbla
llvm.mips.precequ.ph.qbr
llvm.mips.precequ.ph.qbra
llvm.mips.preceu.ph.qbl
llvm.mips.preceu.ph.qbla
llvm.mips.preceu.ph.qbr
llvm.mips.preceu.ph.qbra
llvm.mips.precr.qb.ph
llvm.mips.precr.sra.ph.w
llvm.mips.precr.sra.r.ph.w
llvm.mips.precrq.ph.w
llvm.mips.precrq.qb.ph
llvm.mips.precrq.rs.ph.w
llvm.mips.precrqu.s.qb.ph
llvm.mips.prepend
llvm.mips.raddu.w.qb
llvm.mips.rddsp
llvm.mips.repl.ph
llvm.mips.repl.qb
llvm.mips.sat.s.b
llvm.mips.sat.s.d
llvm.mips.sat.s.h
llvm.mips.sat.s.w
llvm.mips.sat.u.b
llvm.mips.sat.u.d
llvm.mips.sat.u.h
llvm.mips.sat.u.w
llvm.mips.shf.b
llvm.mips.shf.h
llvm.mips.shf.w
llvm.mips.shilo
llvm.mips.shll.ph
llvm.mips.shll.qb
llvm.mips.shll.s.ph
llvm.mips.shll.s.w
llvm.mips.shra.ph
llvm.mips.shra.qb
llvm.mips.shra.r.ph
llvm.mips.shra.r.qb
llvm.mips.shra.r.w
llvm.mips.shrl.ph
llvm.mips.shrl.qb
llvm.mips.sld.b
llvm.mips.sld.d
llvm.mips.sld.h
llvm.mips.sld.w
llvm.mips.sldi.b
llvm.mips.sldi.d
llvm.mips.sldi.h
llvm.mips.sldi.w
llvm.mips.sll.b
llvm.mips.sll.d
llvm.mips.sll.h
llvm.mips.sll.w
llvm.mips.slli.b
llvm.mips.slli.d
llvm.mips.slli.h
llvm.mips.slli.w
llvm.mips.splat.b
llvm.mips.splat.d
llvm.mips.splat.h
llvm.mips.splat.w
llvm.mips.splati.b
llvm.mips.splati.d
llvm.mips.splati.h
llvm.mips.splati.w
llvm.mips.sra.b
llvm.mips.sra.d
llvm.mips.sra.h
llvm.mips.sra.w
llvm.mips.srai.b
llvm.mips.srai.d
llvm.mips.srai.h
llvm.mips.srai.w
llvm.mips.srar.b
llvm.mips.srar.d
llvm.mips.srar.h
llvm.mips.srar.w
llvm.mips.srari.b
llvm.mips.srari.d
llvm.mips.srari.h
llvm.mips.srari.w
llvm.mips.srl.b
llvm.mips.srl.d
llvm.mips.srl.h
llvm.mips.srl.w
llvm.mips.srli.b
llvm.mips.srli.d
llvm.mips.srli.h
llvm.mips.srli.w
llvm.mips.srlr.b
llvm.mips.srlr.d
llvm.mips.srlr.h
llvm.mips.srlr.w
llvm.mips.srlri.b
llvm.mips.srlri.d
llvm.mips.srlri.h
llvm.mips.srlri.w
llvm.mips.st.b
llvm.mips.st.d
llvm.mips.st.h
llvm.mips.st.w
llvm.mips.subq.ph
llvm.mips.subq.s.ph
llvm.mips.subq.s.w
llvm.mips.subqh.ph
llvm.mips.subqh.r.ph
llvm.mips.subqh.r.w
llvm.mips.subqh.w
llvm.mips.subs.s.b
llvm.mips.subs.s.d
llvm.mips.subs.s.h
llvm.mips.subs.s.w
llvm.mips.subs.u.b
llvm.mips.subs.u.d
llvm.mips.subs.u.h
llvm.mips.subs.u.w
llvm.mips.subsus.u.b
llvm.mips.subsus.u.d
llvm.mips.subsus.u.h
llvm.mips.subsus.u.w
llvm.mips.subsuu.s.b
llvm.mips.subsuu.s.d
llvm.mips.subsuu.s.h
llvm.mips.subsuu.s.w
llvm.mips.subu.ph
llvm.mips.subu.qb
llvm.mips.subu.s.ph
llvm.mips.subu.s.qb
llvm.mips.subuh.qb
llvm.mips.subuh.r.qb
llvm.mips.subv.b
llvm.mips.subv.d
llvm.mips.subv.h
llvm.mips.subv.w
llvm.mips.subvi.b
llvm.mips.subvi.d
llvm.mips.subvi.h
llvm.mips.subvi.w
llvm.mips.vshf.b
llvm.mips.vshf.d
llvm.mips.vshf.h
llvm.mips.vshf.w
llvm.mips.wrdsp
llvm.mips.xor.v
llvm.mips.xori.b
llvm.nvvm.add.rm.d
llvm.nvvm.add.rm.f
llvm.nvvm.add.rm.ftz.f
llvm.nvvm.add.rn.d
llvm.nvvm.add.rn.f
llvm.nvvm.add.rn.ftz.f
llvm.nvvm.add.rp.d
llvm.nvvm.add.rp.f
llvm.nvvm.add.rp.ftz.f
llvm.nvvm.add.rz.d
llvm.nvvm.add.rz.f
llvm.nvvm.add.rz.ftz.f
llvm.nvvm.atomic.add.gen.f.cta
llvm.nvvm.atomic.add.gen.f.sys
llvm.nvvm.atomic.add.gen.i.cta
llvm.nvvm.atomic.add.gen.i.sys
llvm.nvvm.atomic.and.gen.i.cta
llvm.nvvm.atomic.and.gen.i.sys
llvm.nvvm.atomic.cas.gen.i.cta
llvm.nvvm.atomic.cas.gen.i.sys
llvm.nvvm.atomic.dec.gen.i.cta
llvm.nvvm.atomic.dec.gen.i.sys
llvm.nvvm.atomic.exch.gen.i.cta
llvm.nvvm.atomic.exch.gen.i.sys
llvm.nvvm.atomic.inc.gen.i.cta
llvm.nvvm.atomic.inc.gen.i.sys
llvm.nvvm.atomic.load.add.f32
llvm.nvvm.atomic.load.add.f64
llvm.nvvm.atomic.load.dec.32
llvm.nvvm.atomic.load.inc.32
llvm.nvvm.atomic.max.gen.i.cta
llvm.nvvm.atomic.max.gen.i.sys
llvm.nvvm.atomic.min.gen.i.cta
llvm.nvvm.atomic.min.gen.i.sys
llvm.nvvm.atomic.or.gen.i.cta
llvm.nvvm.atomic.or.gen.i.sys
llvm.nvvm.atomic.xor.gen.i.cta
llvm.nvvm.atomic.xor.gen.i.sys
llvm.nvvm.bar.sync
llvm.nvvm.bar.warp.sync
llvm.nvvm.barrier
llvm.nvvm.barrier.n
llvm.nvvm.barrier.sync
llvm.nvvm.barrier.sync.cnt
llvm.nvvm.barrier0
llvm.nvvm.barrier0.and
llvm.nvvm.barrier0.or
llvm.nvvm.barrier0.popc
llvm.nvvm.bitcast.d2ll
llvm.nvvm.bitcast.f2i
llvm.nvvm.bitcast.i2f
llvm.nvvm.bitcast.ll2d
llvm.nvvm.ceil.d
llvm.nvvm.ceil.f
llvm.nvvm.ceil.ftz.f
llvm.nvvm.compiler.error
llvm.nvvm.compiler.warn
llvm.nvvm.cos.approx.f
llvm.nvvm.cos.approx.ftz.f
llvm.nvvm.d2f.rm
llvm.nvvm.d2f.rm.ftz
llvm.nvvm.d2f.rn
llvm.nvvm.d2f.rn.ftz
llvm.nvvm.d2f.rp
llvm.nvvm.d2f.rp.ftz
llvm.nvvm.d2f.rz
llvm.nvvm.d2f.rz.ftz
llvm.nvvm.d2i.hi
llvm.nvvm.d2i.lo
llvm.nvvm.d2i.rm
llvm.nvvm.d2i.rn
llvm.nvvm.d2i.rp
llvm.nvvm.d2i.rz
llvm.nvvm.d2ll.rm
llvm.nvvm.d2ll.rn
llvm.nvvm.d2ll.rp
llvm.nvvm.d2ll.rz
llvm.nvvm.d2ui.rm
llvm.nvvm.d2ui.rn
llvm.nvvm.d2ui.rp
llvm.nvvm.d2ui.rz
llvm.nvvm.d2ull.rm
llvm.nvvm.d2ull.rn
llvm.nvvm.d2ull.rp
llvm.nvvm.d2ull.rz
llvm.nvvm.div.approx.f
llvm.nvvm.div.approx.ftz.f
llvm.nvvm.div.rm.d
llvm.nvvm.div.rm.f
llvm.nvvm.div.rm.ftz.f
llvm.nvvm.div.rn.d
llvm.nvvm.div.rn.f
llvm.nvvm.div.rn.ftz.f
llvm.nvvm.div.rp.d
llvm.nvvm.div.rp.f
llvm.nvvm.div.rp.ftz.f
llvm.nvvm.div.rz.d
llvm.nvvm.div.rz.f
llvm.nvvm.div.rz.ftz.f
llvm.nvvm.ex2.approx.d
llvm.nvvm.ex2.approx.f
llvm.nvvm.ex2.approx.ftz.f
llvm.nvvm.f2h.rn
llvm.nvvm.f2h.rn.ftz
llvm.nvvm.f2i.rm
llvm.nvvm.f2i.rm.ftz
llvm.nvvm.f2i.rn
llvm.nvvm.f2i.rn.ftz
llvm.nvvm.f2i.rp
llvm.nvvm.f2i.rp.ftz
llvm.nvvm.f2i.rz
llvm.nvvm.f2i.rz.ftz
llvm.nvvm.f2ll.rm
llvm.nvvm.f2ll.rm.ftz
llvm.nvvm.f2ll.rn
llvm.nvvm.f2ll.rn.ftz
llvm.nvvm.f2ll.rp
llvm.nvvm.f2ll.rp.ftz
llvm.nvvm.f2ll.rz
llvm.nvvm.f2ll.rz.ftz
llvm.nvvm.f2ui.rm
llvm.nvvm.f2ui.rm.ftz
llvm.nvvm.f2ui.rn
llvm.nvvm.f2ui.rn.ftz
llvm.nvvm.f2ui.rp
llvm.nvvm.f2ui.rp.ftz
llvm.nvvm.f2ui.rz
llvm.nvvm.f2ui.rz.ftz
llvm.nvvm.f2ull.rm
llvm.nvvm.f2ull.rm.ftz
llvm.nvvm.f2ull.rn
llvm.nvvm.f2ull.rn.ftz
llvm.nvvm.f2ull.rp
llvm.nvvm.f2ull.rp.ftz
llvm.nvvm.f2ull.rz
llvm.nvvm.f2ull.rz.ftz
llvm.nvvm.fabs.d
llvm.nvvm.fabs.f
llvm.nvvm.fabs.ftz.f
llvm.nvvm.floor.d
llvm.nvvm.floor.f
llvm.nvvm.floor.ftz.f
llvm.nvvm.fma.rm.d
llvm.nvvm.fma.rm.f
llvm.nvvm.fma.rm.ftz.f
llvm.nvvm.fma.rn.d
llvm.nvvm.fma.rn.f
llvm.nvvm.fma.rn.ftz.f
llvm.nvvm.fma.rp.d
llvm.nvvm.fma.rp.f
llvm.nvvm.fma.rp.ftz.f
llvm.nvvm.fma.rz.d
llvm.nvvm.fma.rz.f
llvm.nvvm.fma.rz.ftz.f
llvm.nvvm.fmax.d
llvm.nvvm.fmax.f
llvm.nvvm.fmax.ftz.f
llvm.nvvm.fmin.d
llvm.nvvm.fmin.f
llvm.nvvm.fmin.ftz.f
llvm.nvvm.fns
llvm.nvvm.i2d.rm
llvm.nvvm.i2d.rn
llvm.nvvm.i2d.rp
llvm.nvvm.i2d.rz
llvm.nvvm.i2f.rm
llvm.nvvm.i2f.rn
llvm.nvvm.i2f.rp
llvm.nvvm.i2f.rz
llvm.nvvm.isspacep.const
llvm.nvvm.isspacep.global
llvm.nvvm.isspacep.local
llvm.nvvm.isspacep.shared
llvm.nvvm.istypep.sampler
llvm.nvvm.istypep.surface
llvm.nvvm.istypep.texture
llvm.nvvm.ldg.global.f
llvm.nvvm.ldg.global.i
llvm.nvvm.ldg.global.p
llvm.nvvm.ldu.global.f
llvm.nvvm.ldu.global.i
llvm.nvvm.ldu.global.p
llvm.nvvm.lg2.approx.d
llvm.nvvm.lg2.approx.f
llvm.nvvm.lg2.approx.ftz.f
llvm.nvvm.ll2d.rm
llvm.nvvm.ll2d.rn
llvm.nvvm.ll2d.rp
llvm.nvvm.ll2d.rz
llvm.nvvm.ll2f.rm
llvm.nvvm.ll2f.rn
llvm.nvvm.ll2f.rp
llvm.nvvm.ll2f.rz
llvm.nvvm.lohi.i2d
llvm.nvvm.match.all.sync.i32p
llvm.nvvm.match.all.sync.i64p
llvm.nvvm.match.any.sync.i32
llvm.nvvm.match.any.sync.i64
llvm.nvvm.membar.cta
llvm.nvvm.membar.gl
llvm.nvvm.membar.sys
llvm.nvvm.move.double
llvm.nvvm.move.float
llvm.nvvm.move.i16
llvm.nvvm.move.i32
llvm.nvvm.move.i64
llvm.nvvm.move.ptr
llvm.nvvm.mul.rm.d
llvm.nvvm.mul.rm.f
llvm.nvvm.mul.rm.ftz.f
llvm.nvvm.mul.rn.d
llvm.nvvm.mul.rn.f
llvm.nvvm.mul.rn.ftz.f
llvm.nvvm.mul.rp.d
llvm.nvvm.mul.rp.f
llvm.nvvm.mul.rp.ftz.f
llvm.nvvm.mul.rz.d
llvm.nvvm.mul.rz.f
llvm.nvvm.mul.rz.ftz.f
llvm.nvvm.mul24.i
llvm.nvvm.mul24.ui
llvm.nvvm.mulhi.i
llvm.nvvm.mulhi.ll
llvm.nvvm.mulhi.ui
llvm.nvvm.mulhi.ull
llvm.nvvm.prmt
llvm.nvvm.ptr.constant.to.gen
llvm.nvvm.ptr.gen.to.constant
llvm.nvvm.ptr.gen.to.global
llvm.nvvm.ptr.gen.to.local
llvm.nvvm.ptr.gen.to.param
llvm.nvvm.ptr.gen.to.shared
llvm.nvvm.ptr.global.to.gen
llvm.nvvm.ptr.local.to.gen
llvm.nvvm.ptr.shared.to.gen
llvm.nvvm.rcp.approx.ftz.d
llvm.nvvm.rcp.rm.d
llvm.nvvm.rcp.rm.f
llvm.nvvm.rcp.rm.ftz.f
llvm.nvvm.rcp.rn.d
llvm.nvvm.rcp.rn.f
llvm.nvvm.rcp.rn.ftz.f
llvm.nvvm.rcp.rp.d
llvm.nvvm.rcp.rp.f
llvm.nvvm.rcp.rp.ftz.f
llvm.nvvm.rcp.rz.d
llvm.nvvm.rcp.rz.f
llvm.nvvm.rcp.rz.ftz.f
llvm.nvvm.read.ptx.sreg.clock
llvm.nvvm.read.ptx.sreg.clock64
llvm.nvvm.read.ptx.sreg.ctaid.w
llvm.nvvm.read.ptx.sreg.ctaid.x
llvm.nvvm.read.ptx.sreg.ctaid.y
llvm.nvvm.read.ptx.sreg.ctaid.z
llvm.nvvm.read.ptx.sreg.envreg0
llvm.nvvm.read.ptx.sreg.envreg1
llvm.nvvm.read.ptx.sreg.envreg10
llvm.nvvm.read.ptx.sreg.envreg11
llvm.nvvm.read.ptx.sreg.envreg12
llvm.nvvm.read.ptx.sreg.envreg13
llvm.nvvm.read.ptx.sreg.envreg14
llvm.nvvm.read.ptx.sreg.envreg15
llvm.nvvm.read.ptx.sreg.envreg16
llvm.nvvm.read.ptx.sreg.envreg17
llvm.nvvm.read.ptx.sreg.envreg18
llvm.nvvm.read.ptx.sreg.envreg19
llvm.nvvm.read.ptx.sreg.envreg2
llvm.nvvm.read.ptx.sreg.envreg20
llvm.nvvm.read.ptx.sreg.envreg21
llvm.nvvm.read.ptx.sreg.envreg22
llvm.nvvm.read.ptx.sreg.envreg23
llvm.nvvm.read.ptx.sreg.envreg24
llvm.nvvm.read.ptx.sreg.envreg25
llvm.nvvm.read.ptx.sreg.envreg26
llvm.nvvm.read.ptx.sreg.envreg27
llvm.nvvm.read.ptx.sreg.envreg28
llvm.nvvm.read.ptx.sreg.envreg29
llvm.nvvm.read.ptx.sreg.envreg3
llvm.nvvm.read.ptx.sreg.envreg30
llvm.nvvm.read.ptx.sreg.envreg31
llvm.nvvm.read.ptx.sreg.envreg4
llvm.nvvm.read.ptx.sreg.envreg5
llvm.nvvm.read.ptx.sreg.envreg6
llvm.nvvm.read.ptx.sreg.envreg7
llvm.nvvm.read.ptx.sreg.envreg8
llvm.nvvm.read.ptx.sreg.envreg9
llvm.nvvm.read.ptx.sreg.gridid
llvm.nvvm.read.ptx.sreg.laneid
llvm.nvvm.read.ptx.sreg.lanemask.eq
llvm.nvvm.read.ptx.sreg.lanemask.ge
llvm.nvvm.read.ptx.sreg.lanemask.gt
llvm.nvvm.read.ptx.sreg.lanemask.le
llvm.nvvm.read.ptx.sreg.lanemask.lt
llvm.nvvm.read.ptx.sreg.nctaid.w
llvm.nvvm.read.ptx.sreg.nctaid.x
llvm.nvvm.read.ptx.sreg.nctaid.y
llvm.nvvm.read.ptx.sreg.nctaid.z
llvm.nvvm.read.ptx.sreg.nsmid
llvm.nvvm.read.ptx.sreg.ntid.w
llvm.nvvm.read.ptx.sreg.ntid.x
llvm.nvvm.read.ptx.sreg.ntid.y
llvm.nvvm.read.ptx.sreg.ntid.z
llvm.nvvm.read.ptx.sreg.nwarpid
llvm.nvvm.read.ptx.sreg.pm0
llvm.nvvm.read.ptx.sreg.pm1
llvm.nvvm.read.ptx.sreg.pm2
llvm.nvvm.read.ptx.sreg.pm3
llvm.nvvm.read.ptx.sreg.smid
llvm.nvvm.read.ptx.sreg.tid.w
llvm.nvvm.read.ptx.sreg.tid.x
llvm.nvvm.read.ptx.sreg.tid.y
llvm.nvvm.read.ptx.sreg.tid.z
llvm.nvvm.read.ptx.sreg.warpid
llvm.nvvm.read.ptx.sreg.warpsize
llvm.nvvm.reflect
llvm.nvvm.rotate.b32
llvm.nvvm.rotate.b64
llvm.nvvm.rotate.right.b64
llvm.nvvm.round.d
llvm.nvvm.round.f
llvm.nvvm.round.ftz.f
llvm.nvvm.rsqrt.approx.d
llvm.nvvm.rsqrt.approx.f
llvm.nvvm.rsqrt.approx.ftz.f
llvm.nvvm.sad.i
llvm.nvvm.sad.ui
llvm.nvvm.saturate.d
llvm.nvvm.saturate.f
llvm.nvvm.saturate.ftz.f
llvm.nvvm.shfl.bfly.f32
llvm.nvvm.shfl.bfly.i32
llvm.nvvm.shfl.down.f32
llvm.nvvm.shfl.down.i32
llvm.nvvm.shfl.idx.f32
llvm.nvvm.shfl.idx.i32
llvm.nvvm.shfl.sync.bfly.f32
llvm.nvvm.shfl.sync.bfly.i32
llvm.nvvm.shfl.sync.down.f32
llvm.nvvm.shfl.sync.down.i32
llvm.nvvm.shfl.sync.idx.f32
llvm.nvvm.shfl.sync.idx.i32
llvm.nvvm.shfl.sync.up.f32
llvm.nvvm.shfl.sync.up.i32
llvm.nvvm.shfl.up.f32
llvm.nvvm.shfl.up.i32
llvm.nvvm.sin.approx.f
llvm.nvvm.sin.approx.ftz.f
llvm.nvvm.sqrt.approx.f
llvm.nvvm.sqrt.approx.ftz.f
llvm.nvvm.sqrt.f
llvm.nvvm.sqrt.rm.d
llvm.nvvm.sqrt.rm.f
llvm.nvvm.sqrt.rm.ftz.f
llvm.nvvm.sqrt.rn.d
llvm.nvvm.sqrt.rn.f
llvm.nvvm.sqrt.rn.ftz.f
llvm.nvvm.sqrt.rp.d
llvm.nvvm.sqrt.rp.f
llvm.nvvm.sqrt.rp.ftz.f
llvm.nvvm.sqrt.rz.d
llvm.nvvm.sqrt.rz.f
llvm.nvvm.sqrt.rz.ftz.f
llvm.nvvm.suld.1d.array.i16.clamp
llvm.nvvm.suld.1d.array.i16.trap
llvm.nvvm.suld.1d.array.i16.zero
llvm.nvvm.suld.1d.array.i32.clamp
llvm.nvvm.suld.1d.array.i32.trap
llvm.nvvm.suld.1d.array.i32.zero
llvm.nvvm.suld.1d.array.i64.clamp
llvm.nvvm.suld.1d.array.i64.trap
llvm.nvvm.suld.1d.array.i64.zero
llvm.nvvm.suld.1d.array.i8.clamp
llvm.nvvm.suld.1d.array.i8.trap
llvm.nvvm.suld.1d.array.i8.zero
llvm.nvvm.suld.1d.array.v2i16.clamp
llvm.nvvm.suld.1d.array.v2i16.trap
llvm.nvvm.suld.1d.array.v2i16.zero
llvm.nvvm.suld.1d.array.v2i32.clamp
llvm.nvvm.suld.1d.array.v2i32.trap
llvm.nvvm.suld.1d.array.v2i32.zero
llvm.nvvm.suld.1d.array.v2i64.clamp
llvm.nvvm.suld.1d.array.v2i64.trap
llvm.nvvm.suld.1d.array.v2i64.zero
llvm.nvvm.suld.1d.array.v2i8.clamp
llvm.nvvm.suld.1d.array.v2i8.trap
llvm.nvvm.suld.1d.array.v2i8.zero
llvm.nvvm.suld.1d.array.v4i16.clamp
llvm.nvvm.suld.1d.array.v4i16.trap
llvm.nvvm.suld.1d.array.v4i16.zero
llvm.nvvm.suld.1d.array.v4i32.clamp
llvm.nvvm.suld.1d.array.v4i32.trap
llvm.nvvm.suld.1d.array.v4i32.zero
llvm.nvvm.suld.1d.array.v4i8.clamp
llvm.nvvm.suld.1d.array.v4i8.trap
llvm.nvvm.suld.1d.array.v4i8.zero
llvm.nvvm.suld.1d.i16.clamp
llvm.nvvm.suld.1d.i16.trap
llvm.nvvm.suld.1d.i16.zero
llvm.nvvm.suld.1d.i32.clamp
llvm.nvvm.suld.1d.i32.trap
llvm.nvvm.suld.1d.i32.zero
llvm.nvvm.suld.1d.i64.clamp
llvm.nvvm.suld.1d.i64.trap
llvm.nvvm.suld.1d.i64.zero
llvm.nvvm.suld.1d.i8.clamp
llvm.nvvm.suld.1d.i8.trap
llvm.nvvm.suld.1d.i8.zero
llvm.nvvm.suld.1d.v2i16.clamp
llvm.nvvm.suld.1d.v2i16.trap
llvm.nvvm.suld.1d.v2i16.zero
llvm.nvvm.suld.1d.v2i32.clamp
llvm.nvvm.suld.1d.v2i32.trap
llvm.nvvm.suld.1d.v2i32.zero
llvm.nvvm.suld.1d.v2i64.clamp
llvm.nvvm.suld.1d.v2i64.trap
llvm.nvvm.suld.1d.v2i64.zero
llvm.nvvm.suld.1d.v2i8.clamp
llvm.nvvm.suld.1d.v2i8.trap
llvm.nvvm.suld.1d.v2i8.zero
llvm.nvvm.suld.1d.v4i16.clamp
llvm.nvvm.suld.1d.v4i16.trap
llvm.nvvm.suld.1d.v4i16.zero
llvm.nvvm.suld.1d.v4i32.clamp
llvm.nvvm.suld.1d.v4i32.trap
llvm.nvvm.suld.1d.v4i32.zero
llvm.nvvm.suld.1d.v4i8.clamp
llvm.nvvm.suld.1d.v4i8.trap
llvm.nvvm.suld.1d.v4i8.zero
llvm.nvvm.suld.2d.array.i16.clamp
llvm.nvvm.suld.2d.array.i16.trap
llvm.nvvm.suld.2d.array.i16.zero
llvm.nvvm.suld.2d.array.i32.clamp
llvm.nvvm.suld.2d.array.i32.trap
llvm.nvvm.suld.2d.array.i32.zero
llvm.nvvm.suld.2d.array.i64.clamp
llvm.nvvm.suld.2d.array.i64.trap
llvm.nvvm.suld.2d.array.i64.zero
llvm.nvvm.suld.2d.array.i8.clamp
llvm.nvvm.suld.2d.array.i8.trap
llvm.nvvm.suld.2d.array.i8.zero
llvm.nvvm.suld.2d.array.v2i16.clamp
llvm.nvvm.suld.2d.array.v2i16.trap
llvm.nvvm.suld.2d.array.v2i16.zero
llvm.nvvm.suld.2d.array.v2i32.clamp
llvm.nvvm.suld.2d.array.v2i32.trap
llvm.nvvm.suld.2d.array.v2i32.zero
llvm.nvvm.suld.2d.array.v2i64.clamp
llvm.nvvm.suld.2d.array.v2i64.trap
llvm.nvvm.suld.2d.array.v2i64.zero
llvm.nvvm.suld.2d.array.v2i8.clamp
llvm.nvvm.suld.2d.array.v2i8.trap
llvm.nvvm.suld.2d.array.v2i8.zero
llvm.nvvm.suld.2d.array.v4i16.clamp
llvm.nvvm.suld.2d.array.v4i16.trap
llvm.nvvm.suld.2d.array.v4i16.zero
llvm.nvvm.suld.2d.array.v4i32.clamp
llvm.nvvm.suld.2d.array.v4i32.trap
llvm.nvvm.suld.2d.array.v4i32.zero
llvm.nvvm.suld.2d.array.v4i8.clamp
llvm.nvvm.suld.2d.array.v4i8.trap
llvm.nvvm.suld.2d.array.v4i8.zero
llvm.nvvm.suld.2d.i16.clamp
llvm.nvvm.suld.2d.i16.trap
llvm.nvvm.suld.2d.i16.zero
llvm.nvvm.suld.2d.i32.clamp
llvm.nvvm.suld.2d.i32.trap
llvm.nvvm.suld.2d.i32.zero
llvm.nvvm.suld.2d.i64.clamp
llvm.nvvm.suld.2d.i64.trap
llvm.nvvm.suld.2d.i64.zero
llvm.nvvm.suld.2d.i8.clamp
llvm.nvvm.suld.2d.i8.trap
llvm.nvvm.suld.2d.i8.zero
llvm.nvvm.suld.2d.v2i16.clamp
llvm.nvvm.suld.2d.v2i16.trap
llvm.nvvm.suld.2d.v2i16.zero
llvm.nvvm.suld.2d.v2i32.clamp
llvm.nvvm.suld.2d.v2i32.trap
llvm.nvvm.suld.2d.v2i32.zero
llvm.nvvm.suld.2d.v2i64.clamp
llvm.nvvm.suld.2d.v2i64.trap
llvm.nvvm.suld.2d.v2i64.zero
llvm.nvvm.suld.2d.v2i8.clamp
llvm.nvvm.suld.2d.v2i8.trap
llvm.nvvm.suld.2d.v2i8.zero
llvm.nvvm.suld.2d.v4i16.clamp
llvm.nvvm.suld.2d.v4i16.trap
llvm.nvvm.suld.2d.v4i16.zero
llvm.nvvm.suld.2d.v4i32.clamp
llvm.nvvm.suld.2d.v4i32.trap
llvm.nvvm.suld.2d.v4i32.zero
llvm.nvvm.suld.2d.v4i8.clamp
llvm.nvvm.suld.2d.v4i8.trap
llvm.nvvm.suld.2d.v4i8.zero
llvm.nvvm.suld.3d.i16.clamp
llvm.nvvm.suld.3d.i16.trap
llvm.nvvm.suld.3d.i16.zero
llvm.nvvm.suld.3d.i32.clamp
llvm.nvvm.suld.3d.i32.trap
llvm.nvvm.suld.3d.i32.zero
llvm.nvvm.suld.3d.i64.clamp
llvm.nvvm.suld.3d.i64.trap
llvm.nvvm.suld.3d.i64.zero
llvm.nvvm.suld.3d.i8.clamp
llvm.nvvm.suld.3d.i8.trap
llvm.nvvm.suld.3d.i8.zero
llvm.nvvm.suld.3d.v2i16.clamp
llvm.nvvm.suld.3d.v2i16.trap
llvm.nvvm.suld.3d.v2i16.zero
llvm.nvvm.suld.3d.v2i32.clamp
llvm.nvvm.suld.3d.v2i32.trap
llvm.nvvm.suld.3d.v2i32.zero
llvm.nvvm.suld.3d.v2i64.clamp
llvm.nvvm.suld.3d.v2i64.trap
llvm.nvvm.suld.3d.v2i64.zero
llvm.nvvm.suld.3d.v2i8.clamp
llvm.nvvm.suld.3d.v2i8.trap
llvm.nvvm.suld.3d.v2i8.zero
llvm.nvvm.suld.3d.v4i16.clamp
llvm.nvvm.suld.3d.v4i16.trap
llvm.nvvm.suld.3d.v4i16.zero
llvm.nvvm.suld.3d.v4i32.clamp
llvm.nvvm.suld.3d.v4i32.trap
llvm.nvvm.suld.3d.v4i32.zero
llvm.nvvm.suld.3d.v4i8.clamp
llvm.nvvm.suld.3d.v4i8.trap
llvm.nvvm.suld.3d.v4i8.zero
llvm.nvvm.suq.array.size
llvm.nvvm.suq.channel.data.type
llvm.nvvm.suq.channel.order
llvm.nvvm.suq.depth
llvm.nvvm.suq.height
llvm.nvvm.suq.width
llvm.nvvm.sust.b.1d.array.i16.clamp
llvm.nvvm.sust.b.1d.array.i16.trap
llvm.nvvm.sust.b.1d.array.i16.zero
llvm.nvvm.sust.b.1d.array.i32.clamp
llvm.nvvm.sust.b.1d.array.i32.trap
llvm.nvvm.sust.b.1d.array.i32.zero
llvm.nvvm.sust.b.1d.array.i64.clamp
llvm.nvvm.sust.b.1d.array.i64.trap
llvm.nvvm.sust.b.1d.array.i64.zero
llvm.nvvm.sust.b.1d.array.i8.clamp
llvm.nvvm.sust.b.1d.array.i8.trap
llvm.nvvm.sust.b.1d.array.i8.zero
llvm.nvvm.sust.b.1d.array.v2i16.clamp
llvm.nvvm.sust.b.1d.array.v2i16.trap
llvm.nvvm.sust.b.1d.array.v2i16.zero
llvm.nvvm.sust.b.1d.array.v2i32.clamp
llvm.nvvm.sust.b.1d.array.v2i32.trap
llvm.nvvm.sust.b.1d.array.v2i32.zero
llvm.nvvm.sust.b.1d.array.v2i64.clamp
llvm.nvvm.sust.b.1d.array.v2i64.trap
llvm.nvvm.sust.b.1d.array.v2i64.zero
llvm.nvvm.sust.b.1d.array.v2i8.clamp
llvm.nvvm.sust.b.1d.array.v2i8.trap
llvm.nvvm.sust.b.1d.array.v2i8.zero
llvm.nvvm.sust.b.1d.array.v4i16.clamp
llvm.nvvm.sust.b.1d.array.v4i16.trap
llvm.nvvm.sust.b.1d.array.v4i16.zero
llvm.nvvm.sust.b.1d.array.v4i32.clamp
llvm.nvvm.sust.b.1d.array.v4i32.trap
llvm.nvvm.sust.b.1d.array.v4i32.zero
llvm.nvvm.sust.b.1d.array.v4i8.clamp
llvm.nvvm.sust.b.1d.array.v4i8.trap
llvm.nvvm.sust.b.1d.array.v4i8.zero
llvm.nvvm.sust.b.1d.i16.clamp
llvm.nvvm.sust.b.1d.i16.trap
llvm.nvvm.sust.b.1d.i16.zero
llvm.nvvm.sust.b.1d.i32.clamp
llvm.nvvm.sust.b.1d.i32.trap
llvm.nvvm.sust.b.1d.i32.zero
llvm.nvvm.sust.b.1d.i64.clamp
llvm.nvvm.sust.b.1d.i64.trap
llvm.nvvm.sust.b.1d.i64.zero
llvm.nvvm.sust.b.1d.i8.clamp
llvm.nvvm.sust.b.1d.i8.trap
llvm.nvvm.sust.b.1d.i8.zero
llvm.nvvm.sust.b.1d.v2i16.clamp
llvm.nvvm.sust.b.1d.v2i16.trap
llvm.nvvm.sust.b.1d.v2i16.zero
llvm.nvvm.sust.b.1d.v2i32.clamp
llvm.nvvm.sust.b.1d.v2i32.trap
llvm.nvvm.sust.b.1d.v2i32.zero
llvm.nvvm.sust.b.1d.v2i64.clamp
llvm.nvvm.sust.b.1d.v2i64.trap
llvm.nvvm.sust.b.1d.v2i64.zero
llvm.nvvm.sust.b.1d.v2i8.clamp
llvm.nvvm.sust.b.1d.v2i8.trap
llvm.nvvm.sust.b.1d.v2i8.zero
llvm.nvvm.sust.b.1d.v4i16.clamp
llvm.nvvm.sust.b.1d.v4i16.trap
llvm.nvvm.sust.b.1d.v4i16.zero
llvm.nvvm.sust.b.1d.v4i32.clamp
llvm.nvvm.sust.b.1d.v4i32.trap
llvm.nvvm.sust.b.1d.v4i32.zero
llvm.nvvm.sust.b.1d.v4i8.clamp
llvm.nvvm.sust.b.1d.v4i8.trap
llvm.nvvm.sust.b.1d.v4i8.zero
llvm.nvvm.sust.b.2d.array.i16.clamp
llvm.nvvm.sust.b.2d.array.i16.trap
llvm.nvvm.sust.b.2d.array.i16.zero
llvm.nvvm.sust.b.2d.array.i32.clamp
llvm.nvvm.sust.b.2d.array.i32.trap
llvm.nvvm.sust.b.2d.array.i32.zero
llvm.nvvm.sust.b.2d.array.i64.clamp
llvm.nvvm.sust.b.2d.array.i64.trap
llvm.nvvm.sust.b.2d.array.i64.zero
llvm.nvvm.sust.b.2d.array.i8.clamp
llvm.nvvm.sust.b.2d.array.i8.trap
llvm.nvvm.sust.b.2d.array.i8.zero
llvm.nvvm.sust.b.2d.array.v2i16.clamp
llvm.nvvm.sust.b.2d.array.v2i16.trap
llvm.nvvm.sust.b.2d.array.v2i16.zero
llvm.nvvm.sust.b.2d.array.v2i32.clamp
llvm.nvvm.sust.b.2d.array.v2i32.trap
llvm.nvvm.sust.b.2d.array.v2i32.zero
llvm.nvvm.sust.b.2d.array.v2i64.clamp
llvm.nvvm.sust.b.2d.array.v2i64.trap
llvm.nvvm.sust.b.2d.array.v2i64.zero
llvm.nvvm.sust.b.2d.array.v2i8.clamp
llvm.nvvm.sust.b.2d.array.v2i8.trap
llvm.nvvm.sust.b.2d.array.v2i8.zero
llvm.nvvm.sust.b.2d.array.v4i16.clamp
llvm.nvvm.sust.b.2d.array.v4i16.trap
llvm.nvvm.sust.b.2d.array.v4i16.zero
llvm.nvvm.sust.b.2d.array.v4i32.clamp
llvm.nvvm.sust.b.2d.array.v4i32.trap
llvm.nvvm.sust.b.2d.array.v4i32.zero
llvm.nvvm.sust.b.2d.array.v4i8.clamp
llvm.nvvm.sust.b.2d.array.v4i8.trap
llvm.nvvm.sust.b.2d.array.v4i8.zero
llvm.nvvm.sust.b.2d.i16.clamp
llvm.nvvm.sust.b.2d.i16.trap
llvm.nvvm.sust.b.2d.i16.zero
llvm.nvvm.sust.b.2d.i32.clamp
llvm.nvvm.sust.b.2d.i32.trap
llvm.nvvm.sust.b.2d.i32.zero
llvm.nvvm.sust.b.2d.i64.clamp
llvm.nvvm.sust.b.2d.i64.trap
llvm.nvvm.sust.b.2d.i64.zero
llvm.nvvm.sust.b.2d.i8.clamp
llvm.nvvm.sust.b.2d.i8.trap
llvm.nvvm.sust.b.2d.i8.zero
llvm.nvvm.sust.b.2d.v2i16.clamp
llvm.nvvm.sust.b.2d.v2i16.trap
llvm.nvvm.sust.b.2d.v2i16.zero
llvm.nvvm.sust.b.2d.v2i32.clamp
llvm.nvvm.sust.b.2d.v2i32.trap
llvm.nvvm.sust.b.2d.v2i32.zero
llvm.nvvm.sust.b.2d.v2i64.clamp
llvm.nvvm.sust.b.2d.v2i64.trap
llvm.nvvm.sust.b.2d.v2i64.zero
llvm.nvvm.sust.b.2d.v2i8.clamp
llvm.nvvm.sust.b.2d.v2i8.trap
llvm.nvvm.sust.b.2d.v2i8.zero
llvm.nvvm.sust.b.2d.v4i16.clamp
llvm.nvvm.sust.b.2d.v4i16.trap
llvm.nvvm.sust.b.2d.v4i16.zero
llvm.nvvm.sust.b.2d.v4i32.clamp
llvm.nvvm.sust.b.2d.v4i32.trap
llvm.nvvm.sust.b.2d.v4i32.zero
llvm.nvvm.sust.b.2d.v4i8.clamp
llvm.nvvm.sust.b.2d.v4i8.trap
llvm.nvvm.sust.b.2d.v4i8.zero
llvm.nvvm.sust.b.3d.i16.clamp
llvm.nvvm.sust.b.3d.i16.trap
llvm.nvvm.sust.b.3d.i16.zero
llvm.nvvm.sust.b.3d.i32.clamp
llvm.nvvm.sust.b.3d.i32.trap
llvm.nvvm.sust.b.3d.i32.zero
llvm.nvvm.sust.b.3d.i64.clamp
llvm.nvvm.sust.b.3d.i64.trap
llvm.nvvm.sust.b.3d.i64.zero
llvm.nvvm.sust.b.3d.i8.clamp
llvm.nvvm.sust.b.3d.i8.trap
llvm.nvvm.sust.b.3d.i8.zero
llvm.nvvm.sust.b.3d.v2i16.clamp
llvm.nvvm.sust.b.3d.v2i16.trap
llvm.nvvm.sust.b.3d.v2i16.zero
llvm.nvvm.sust.b.3d.v2i32.clamp
llvm.nvvm.sust.b.3d.v2i32.trap
llvm.nvvm.sust.b.3d.v2i32.zero
llvm.nvvm.sust.b.3d.v2i64.clamp
llvm.nvvm.sust.b.3d.v2i64.trap
llvm.nvvm.sust.b.3d.v2i64.zero
llvm.nvvm.sust.b.3d.v2i8.clamp
llvm.nvvm.sust.b.3d.v2i8.trap
llvm.nvvm.sust.b.3d.v2i8.zero
llvm.nvvm.sust.b.3d.v4i16.clamp
llvm.nvvm.sust.b.3d.v4i16.trap
llvm.nvvm.sust.b.3d.v4i16.zero
llvm.nvvm.sust.b.3d.v4i32.clamp
llvm.nvvm.sust.b.3d.v4i32.trap
llvm.nvvm.sust.b.3d.v4i32.zero
llvm.nvvm.sust.b.3d.v4i8.clamp
llvm.nvvm.sust.b.3d.v4i8.trap
llvm.nvvm.sust.b.3d.v4i8.zero
llvm.nvvm.sust.p.1d.array.i16.trap
llvm.nvvm.sust.p.1d.array.i32.trap
llvm.nvvm.sust.p.1d.array.i8.trap
llvm.nvvm.sust.p.1d.array.v2i16.trap
llvm.nvvm.sust.p.1d.array.v2i32.trap
llvm.nvvm.sust.p.1d.array.v2i8.trap
llvm.nvvm.sust.p.1d.array.v4i16.trap
llvm.nvvm.sust.p.1d.array.v4i32.trap
llvm.nvvm.sust.p.1d.array.v4i8.trap
llvm.nvvm.sust.p.1d.i16.trap
llvm.nvvm.sust.p.1d.i32.trap
llvm.nvvm.sust.p.1d.i8.trap
llvm.nvvm.sust.p.1d.v2i16.trap
llvm.nvvm.sust.p.1d.v2i32.trap
llvm.nvvm.sust.p.1d.v2i8.trap
llvm.nvvm.sust.p.1d.v4i16.trap
llvm.nvvm.sust.p.1d.v4i32.trap
llvm.nvvm.sust.p.1d.v4i8.trap
llvm.nvvm.sust.p.2d.array.i16.trap
llvm.nvvm.sust.p.2d.array.i32.trap
llvm.nvvm.sust.p.2d.array.i8.trap
llvm.nvvm.sust.p.2d.array.v2i16.trap
llvm.nvvm.sust.p.2d.array.v2i32.trap
llvm.nvvm.sust.p.2d.array.v2i8.trap
llvm.nvvm.sust.p.2d.array.v4i16.trap
llvm.nvvm.sust.p.2d.array.v4i32.trap
llvm.nvvm.sust.p.2d.array.v4i8.trap
llvm.nvvm.sust.p.2d.i16.trap
llvm.nvvm.sust.p.2d.i32.trap
llvm.nvvm.sust.p.2d.i8.trap
llvm.nvvm.sust.p.2d.v2i16.trap
llvm.nvvm.sust.p.2d.v2i32.trap
llvm.nvvm.sust.p.2d.v2i8.trap
llvm.nvvm.sust.p.2d.v4i16.trap
llvm.nvvm.sust.p.2d.v4i32.trap
llvm.nvvm.sust.p.2d.v4i8.trap
llvm.nvvm.sust.p.3d.i16.trap
llvm.nvvm.sust.p.3d.i32.trap
llvm.nvvm.sust.p.3d.i8.trap
llvm.nvvm.sust.p.3d.v2i16.trap
llvm.nvvm.sust.p.3d.v2i32.trap
llvm.nvvm.sust.p.3d.v2i8.trap
llvm.nvvm.sust.p.3d.v4i16.trap
llvm.nvvm.sust.p.3d.v4i32.trap
llvm.nvvm.sust.p.3d.v4i8.trap
llvm.nvvm.swap.lo.hi.b64
llvm.nvvm.tex.1d.array.grad.v4f32.f32
llvm.nvvm.tex.1d.array.grad.v4s32.f32
llvm.nvvm.tex.1d.array.grad.v4u32.f32
llvm.nvvm.tex.1d.array.level.v4f32.f32
llvm.nvvm.tex.1d.array.level.v4s32.f32
llvm.nvvm.tex.1d.array.level.v4u32.f32
llvm.nvvm.tex.1d.array.v4f32.f32
llvm.nvvm.tex.1d.array.v4f32.s32
llvm.nvvm.tex.1d.array.v4s32.f32
llvm.nvvm.tex.1d.array.v4s32.s32
llvm.nvvm.tex.1d.array.v4u32.f32
llvm.nvvm.tex.1d.array.v4u32.s32
llvm.nvvm.tex.1d.grad.v4f32.f32
llvm.nvvm.tex.1d.grad.v4s32.f32
llvm.nvvm.tex.1d.grad.v4u32.f32
llvm.nvvm.tex.1d.level.v4f32.f32
llvm.nvvm.tex.1d.level.v4s32.f32
llvm.nvvm.tex.1d.level.v4u32.f32
llvm.nvvm.tex.1d.v4f32.f32
llvm.nvvm.tex.1d.v4f32.s32
llvm.nvvm.tex.1d.v4s32.f32
llvm.nvvm.tex.1d.v4s32.s32
llvm.nvvm.tex.1d.v4u32.f32
llvm.nvvm.tex.1d.v4u32.s32
llvm.nvvm.tex.2d.array.grad.v4f32.f32
llvm.nvvm.tex.2d.array.grad.v4s32.f32
llvm.nvvm.tex.2d.array.grad.v4u32.f32
llvm.nvvm.tex.2d.array.level.v4f32.f32
llvm.nvvm.tex.2d.array.level.v4s32.f32
llvm.nvvm.tex.2d.array.level.v4u32.f32
llvm.nvvm.tex.2d.array.v4f32.f32
llvm.nvvm.tex.2d.array.v4f32.s32
llvm.nvvm.tex.2d.array.v4s32.f32
llvm.nvvm.tex.2d.array.v4s32.s32
llvm.nvvm.tex.2d.array.v4u32.f32
llvm.nvvm.tex.2d.array.v4u32.s32
llvm.nvvm.tex.2d.grad.v4f32.f32
llvm.nvvm.tex.2d.grad.v4s32.f32
llvm.nvvm.tex.2d.grad.v4u32.f32
llvm.nvvm.tex.2d.level.v4f32.f32
llvm.nvvm.tex.2d.level.v4s32.f32
llvm.nvvm.tex.2d.level.v4u32.f32
llvm.nvvm.tex.2d.v4f32.f32
llvm.nvvm.tex.2d.v4f32.s32
llvm.nvvm.tex.2d.v4s32.f32
llvm.nvvm.tex.2d.v4s32.s32
llvm.nvvm.tex.2d.v4u32.f32
llvm.nvvm.tex.2d.v4u32.s32
llvm.nvvm.tex.3d.grad.v4f32.f32
llvm.nvvm.tex.3d.grad.v4s32.f32
llvm.nvvm.tex.3d.grad.v4u32.f32
llvm.nvvm.tex.3d.level.v4f32.f32
llvm.nvvm.tex.3d.level.v4s32.f32
llvm.nvvm.tex.3d.level.v4u32.f32
llvm.nvvm.tex.3d.v4f32.f32
llvm.nvvm.tex.3d.v4f32.s32
llvm.nvvm.tex.3d.v4s32.f32
llvm.nvvm.tex.3d.v4s32.s32
llvm.nvvm.tex.3d.v4u32.f32
llvm.nvvm.tex.3d.v4u32.s32
llvm.nvvm.tex.cube.array.level.v4f32.f32
llvm.nvvm.tex.cube.array.level.v4s32.f32
llvm.nvvm.tex.cube.array.level.v4u32.f32
llvm.nvvm.tex.cube.array.v4f32.f32
llvm.nvvm.tex.cube.array.v4s32.f32
llvm.nvvm.tex.cube.array.v4u32.f32
llvm.nvvm.tex.cube.level.v4f32.f32
llvm.nvvm.tex.cube.level.v4s32.f32
llvm.nvvm.tex.cube.level.v4u32.f32
llvm.nvvm.tex.cube.v4f32.f32
llvm.nvvm.tex.cube.v4s32.f32
llvm.nvvm.tex.cube.v4u32.f32
llvm.nvvm.tex.unified.1d.array.grad.v4f32.f32
llvm.nvvm.tex.unified.1d.array.grad.v4s32.f32
llvm.nvvm.tex.unified.1d.array.grad.v4u32.f32
llvm.nvvm.tex.unified.1d.array.level.v4f32.f32
llvm.nvvm.tex.unified.1d.array.level.v4s32.f32
llvm.nvvm.tex.unified.1d.array.level.v4u32.f32
llvm.nvvm.tex.unified.1d.array.v4f32.f32
llvm.nvvm.tex.unified.1d.array.v4f32.s32
llvm.nvvm.tex.unified.1d.array.v4s32.f32
llvm.nvvm.tex.unified.1d.array.v4s32.s32
llvm.nvvm.tex.unified.1d.array.v4u32.f32
llvm.nvvm.tex.unified.1d.array.v4u32.s32
llvm.nvvm.tex.unified.1d.grad.v4f32.f32
llvm.nvvm.tex.unified.1d.grad.v4s32.f32
llvm.nvvm.tex.unified.1d.grad.v4u32.f32
llvm.nvvm.tex.unified.1d.level.v4f32.f32
llvm.nvvm.tex.unified.1d.level.v4s32.f32
llvm.nvvm.tex.unified.1d.level.v4u32.f32
llvm.nvvm.tex.unified.1d.v4f32.f32
llvm.nvvm.tex.unified.1d.v4f32.s32
llvm.nvvm.tex.unified.1d.v4s32.f32
llvm.nvvm.tex.unified.1d.v4s32.s32
llvm.nvvm.tex.unified.1d.v4u32.f32
llvm.nvvm.tex.unified.1d.v4u32.s32
llvm.nvvm.tex.unified.2d.array.grad.v4f32.f32
llvm.nvvm.tex.unified.2d.array.grad.v4s32.f32
llvm.nvvm.tex.unified.2d.array.grad.v4u32.f32
llvm.nvvm.tex.unified.2d.array.level.v4f32.f32
llvm.nvvm.tex.unified.2d.array.level.v4s32.f32
llvm.nvvm.tex.unified.2d.array.level.v4u32.f32
llvm.nvvm.tex.unified.2d.array.v4f32.f32
llvm.nvvm.tex.unified.2d.array.v4f32.s32
llvm.nvvm.tex.unified.2d.array.v4s32.f32
llvm.nvvm.tex.unified.2d.array.v4s32.s32
llvm.nvvm.tex.unified.2d.array.v4u32.f32
llvm.nvvm.tex.unified.2d.array.v4u32.s32
llvm.nvvm.tex.unified.2d.grad.v4f32.f32
llvm.nvvm.tex.unified.2d.grad.v4s32.f32
llvm.nvvm.tex.unified.2d.grad.v4u32.f32
llvm.nvvm.tex.unified.2d.level.v4f32.f32
llvm.nvvm.tex.unified.2d.level.v4s32.f32
llvm.nvvm.tex.unified.2d.level.v4u32.f32
llvm.nvvm.tex.unified.2d.v4f32.f32
llvm.nvvm.tex.unified.2d.v4f32.s32
llvm.nvvm.tex.unified.2d.v4s32.f32
llvm.nvvm.tex.unified.2d.v4s32.s32
llvm.nvvm.tex.unified.2d.v4u32.f32
llvm.nvvm.tex.unified.2d.v4u32.s32
llvm.nvvm.tex.unified.3d.grad.v4f32.f32
llvm.nvvm.tex.unified.3d.grad.v4s32.f32
llvm.nvvm.tex.unified.3d.grad.v4u32.f32
llvm.nvvm.tex.unified.3d.level.v4f32.f32
llvm.nvvm.tex.unified.3d.level.v4s32.f32
llvm.nvvm.tex.unified.3d.level.v4u32.f32
llvm.nvvm.tex.unified.3d.v4f32.f32
llvm.nvvm.tex.unified.3d.v4f32.s32
llvm.nvvm.tex.unified.3d.v4s32.f32
llvm.nvvm.tex.unified.3d.v4s32.s32
llvm.nvvm.tex.unified.3d.v4u32.f32
llvm.nvvm.tex.unified.3d.v4u32.s32
llvm.nvvm.tex.unified.cube.array.level.v4f32.f32
llvm.nvvm.tex.unified.cube.array.level.v4s32.f32
llvm.nvvm.tex.unified.cube.array.level.v4u32.f32
llvm.nvvm.tex.unified.cube.array.v4f32.f32
llvm.nvvm.tex.unified.cube.array.v4s32.f32
llvm.nvvm.tex.unified.cube.array.v4u32.f32
llvm.nvvm.tex.unified.cube.level.v4f32.f32
llvm.nvvm.tex.unified.cube.level.v4s32.f32
llvm.nvvm.tex.unified.cube.level.v4u32.f32
llvm.nvvm.tex.unified.cube.v4f32.f32
llvm.nvvm.tex.unified.cube.v4s32.f32
llvm.nvvm.tex.unified.cube.v4u32.f32
llvm.nvvm.texsurf.handle
llvm.nvvm.texsurf.handle.internal
llvm.nvvm.tld4.a.2d.v4f32.f32
llvm.nvvm.tld4.a.2d.v4s32.f32
llvm.nvvm.tld4.a.2d.v4u32.f32
llvm.nvvm.tld4.b.2d.v4f32.f32
llvm.nvvm.tld4.b.2d.v4s32.f32
llvm.nvvm.tld4.b.2d.v4u32.f32
llvm.nvvm.tld4.g.2d.v4f32.f32
llvm.nvvm.tld4.g.2d.v4s32.f32
llvm.nvvm.tld4.g.2d.v4u32.f32
llvm.nvvm.tld4.r.2d.v4f32.f32
llvm.nvvm.tld4.r.2d.v4s32.f32
llvm.nvvm.tld4.r.2d.v4u32.f32
llvm.nvvm.tld4.unified.a.2d.v4f32.f32
llvm.nvvm.tld4.unified.a.2d.v4s32.f32
llvm.nvvm.tld4.unified.a.2d.v4u32.f32
llvm.nvvm.tld4.unified.b.2d.v4f32.f32
llvm.nvvm.tld4.unified.b.2d.v4s32.f32
llvm.nvvm.tld4.unified.b.2d.v4u32.f32
llvm.nvvm.tld4.unified.g.2d.v4f32.f32
llvm.nvvm.tld4.unified.g.2d.v4s32.f32
llvm.nvvm.tld4.unified.g.2d.v4u32.f32
llvm.nvvm.tld4.unified.r.2d.v4f32.f32
llvm.nvvm.tld4.unified.r.2d.v4s32.f32
llvm.nvvm.tld4.unified.r.2d.v4u32.f32
llvm.nvvm.trunc.d
llvm.nvvm.trunc.f
llvm.nvvm.trunc.ftz.f
llvm.nvvm.txq.array.size
llvm.nvvm.txq.channel.data.type
llvm.nvvm.txq.channel.order
llvm.nvvm.txq.depth
llvm.nvvm.txq.height
llvm.nvvm.txq.num.mipmap.levels
llvm.nvvm.txq.num.samples
llvm.nvvm.txq.width
llvm.nvvm.ui2d.rm
llvm.nvvm.ui2d.rn
llvm.nvvm.ui2d.rp
llvm.nvvm.ui2d.rz
llvm.nvvm.ui2f.rm
llvm.nvvm.ui2f.rn
llvm.nvvm.ui2f.rp
llvm.nvvm.ui2f.rz
llvm.nvvm.ull2d.rm
llvm.nvvm.ull2d.rn
llvm.nvvm.ull2d.rp
llvm.nvvm.ull2d.rz
llvm.nvvm.ull2f.rm
llvm.nvvm.ull2f.rn
llvm.nvvm.ull2f.rp
llvm.nvvm.ull2f.rz
llvm.nvvm.vote.all
llvm.nvvm.vote.all.sync
llvm.nvvm.vote.any
llvm.nvvm.vote.any.sync
llvm.nvvm.vote.ballot
llvm.nvvm.vote.ballot.sync
llvm.nvvm.vote.uni
llvm.nvvm.vote.uni.sync
llvm.nvvm.wmma.m16n16k16.load.a.col.f16
llvm.nvvm.wmma.m16n16k16.load.a.col.stride.f16
llvm.nvvm.wmma.m16n16k16.load.a.row.f16
llvm.nvvm.wmma.m16n16k16.load.a.row.stride.f16
llvm.nvvm.wmma.m16n16k16.load.b.col.f16
llvm.nvvm.wmma.m16n16k16.load.b.col.stride.f16
llvm.nvvm.wmma.m16n16k16.load.b.row.f16
llvm.nvvm.wmma.m16n16k16.load.b.row.stride.f16
llvm.nvvm.wmma.m16n16k16.load.c.col.f16
llvm.nvvm.wmma.m16n16k16.load.c.col.f32
llvm.nvvm.wmma.m16n16k16.load.c.col.stride.f16
llvm.nvvm.wmma.m16n16k16.load.c.col.stride.f32
llvm.nvvm.wmma.m16n16k16.load.c.row.f16
llvm.nvvm.wmma.m16n16k16.load.c.row.f32
llvm.nvvm.wmma.m16n16k16.load.c.row.stride.f16
llvm.nvvm.wmma.m16n16k16.load.c.row.stride.f32
llvm.nvvm.wmma.m16n16k16.mma.col.col.f16.f16
llvm.nvvm.wmma.m16n16k16.mma.col.col.f16.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.col.f16.f32
llvm.nvvm.wmma.m16n16k16.mma.col.col.f16.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.col.f32.f16
llvm.nvvm.wmma.m16n16k16.mma.col.col.f32.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.col.f32.f32
llvm.nvvm.wmma.m16n16k16.mma.col.col.f32.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.row.f16.f16
llvm.nvvm.wmma.m16n16k16.mma.col.row.f16.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.row.f16.f32
llvm.nvvm.wmma.m16n16k16.mma.col.row.f16.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.row.f32.f16
llvm.nvvm.wmma.m16n16k16.mma.col.row.f32.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.row.f32.f32
llvm.nvvm.wmma.m16n16k16.mma.col.row.f32.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.col.f16.f16
llvm.nvvm.wmma.m16n16k16.mma.row.col.f16.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.col.f16.f32
llvm.nvvm.wmma.m16n16k16.mma.row.col.f16.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.col.f32.f16
llvm.nvvm.wmma.m16n16k16.mma.row.col.f32.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.col.f32.f32
llvm.nvvm.wmma.m16n16k16.mma.row.col.f32.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.row.f16.f16
llvm.nvvm.wmma.m16n16k16.mma.row.row.f16.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.row.f16.f32
llvm.nvvm.wmma.m16n16k16.mma.row.row.f16.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.row.f32.f16
llvm.nvvm.wmma.m16n16k16.mma.row.row.f32.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.row.f32.f32
llvm.nvvm.wmma.m16n16k16.mma.row.row.f32.f32.satfinite
llvm.nvvm.wmma.m16n16k16.store.d.col.f16
llvm.nvvm.wmma.m16n16k16.store.d.col.f32
llvm.nvvm.wmma.m16n16k16.store.d.col.stride.f16
llvm.nvvm.wmma.m16n16k16.store.d.col.stride.f32
llvm.nvvm.wmma.m16n16k16.store.d.row.f16
llvm.nvvm.wmma.m16n16k16.store.d.row.f32
llvm.nvvm.wmma.m16n16k16.store.d.row.stride.f16
llvm.nvvm.wmma.m16n16k16.store.d.row.stride.f32
llvm.nvvm.wmma.m32n8k16.load.a.col.f16
llvm.nvvm.wmma.m32n8k16.load.a.col.stride.f16
llvm.nvvm.wmma.m32n8k16.load.a.row.f16
llvm.nvvm.wmma.m32n8k16.load.a.row.stride.f16
llvm.nvvm.wmma.m32n8k16.load.b.col.f16
llvm.nvvm.wmma.m32n8k16.load.b.col.stride.f16
llvm.nvvm.wmma.m32n8k16.load.b.row.f16
llvm.nvvm.wmma.m32n8k16.load.b.row.stride.f16
llvm.nvvm.wmma.m32n8k16.load.c.col.f16
llvm.nvvm.wmma.m32n8k16.load.c.col.f32
llvm.nvvm.wmma.m32n8k16.load.c.col.stride.f16
llvm.nvvm.wmma.m32n8k16.load.c.col.stride.f32
llvm.nvvm.wmma.m32n8k16.load.c.row.f16
llvm.nvvm.wmma.m32n8k16.load.c.row.f32
llvm.nvvm.wmma.m32n8k16.load.c.row.stride.f16
llvm.nvvm.wmma.m32n8k16.load.c.row.stride.f32
llvm.nvvm.wmma.m32n8k16.mma.col.col.f16.f16
llvm.nvvm.wmma.m32n8k16.mma.col.col.f16.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.col.f16.f32
llvm.nvvm.wmma.m32n8k16.mma.col.col.f16.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.col.f32.f16
llvm.nvvm.wmma.m32n8k16.mma.col.col.f32.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.col.f32.f32
llvm.nvvm.wmma.m32n8k16.mma.col.col.f32.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.row.f16.f16
llvm.nvvm.wmma.m32n8k16.mma.col.row.f16.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.row.f16.f32
llvm.nvvm.wmma.m32n8k16.mma.col.row.f16.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.row.f32.f16
llvm.nvvm.wmma.m32n8k16.mma.col.row.f32.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.row.f32.f32
llvm.nvvm.wmma.m32n8k16.mma.col.row.f32.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.col.f16.f16
llvm.nvvm.wmma.m32n8k16.mma.row.col.f16.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.col.f16.f32
llvm.nvvm.wmma.m32n8k16.mma.row.col.f16.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.col.f32.f16
llvm.nvvm.wmma.m32n8k16.mma.row.col.f32.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.col.f32.f32
llvm.nvvm.wmma.m32n8k16.mma.row.col.f32.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.row.f16.f16
llvm.nvvm.wmma.m32n8k16.mma.row.row.f16.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.row.f16.f32
llvm.nvvm.wmma.m32n8k16.mma.row.row.f16.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.row.f32.f16
llvm.nvvm.wmma.m32n8k16.mma.row.row.f32.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.row.f32.f32
llvm.nvvm.wmma.m32n8k16.mma.row.row.f32.f32.satfinite
llvm.nvvm.wmma.m32n8k16.store.d.col.f16
llvm.nvvm.wmma.m32n8k16.store.d.col.f32
llvm.nvvm.wmma.m32n8k16.store.d.col.stride.f16
llvm.nvvm.wmma.m32n8k16.store.d.col.stride.f32
llvm.nvvm.wmma.m32n8k16.store.d.row.f16
llvm.nvvm.wmma.m32n8k16.store.d.row.f32
llvm.nvvm.wmma.m32n8k16.store.d.row.stride.f16
llvm.nvvm.wmma.m32n8k16.store.d.row.stride.f32
llvm.nvvm.wmma.m8n32k16.load.a.col.f16
llvm.nvvm.wmma.m8n32k16.load.a.col.stride.f16
llvm.nvvm.wmma.m8n32k16.load.a.row.f16
llvm.nvvm.wmma.m8n32k16.load.a.row.stride.f16
llvm.nvvm.wmma.m8n32k16.load.b.col.f16
llvm.nvvm.wmma.m8n32k16.load.b.col.stride.f16
llvm.nvvm.wmma.m8n32k16.load.b.row.f16
llvm.nvvm.wmma.m8n32k16.load.b.row.stride.f16
llvm.nvvm.wmma.m8n32k16.load.c.col.f16
llvm.nvvm.wmma.m8n32k16.load.c.col.f32
llvm.nvvm.wmma.m8n32k16.load.c.col.stride.f16
llvm.nvvm.wmma.m8n32k16.load.c.col.stride.f32
llvm.nvvm.wmma.m8n32k16.load.c.row.f16
llvm.nvvm.wmma.m8n32k16.load.c.row.f32
llvm.nvvm.wmma.m8n32k16.load.c.row.stride.f16
llvm.nvvm.wmma.m8n32k16.load.c.row.stride.f32
llvm.nvvm.wmma.m8n32k16.mma.col.col.f16.f16
llvm.nvvm.wmma.m8n32k16.mma.col.col.f16.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.col.f16.f32
llvm.nvvm.wmma.m8n32k16.mma.col.col.f16.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.col.f32.f16
llvm.nvvm.wmma.m8n32k16.mma.col.col.f32.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.col.f32.f32
llvm.nvvm.wmma.m8n32k16.mma.col.col.f32.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.row.f16.f16
llvm.nvvm.wmma.m8n32k16.mma.col.row.f16.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.row.f16.f32
llvm.nvvm.wmma.m8n32k16.mma.col.row.f16.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.row.f32.f16
llvm.nvvm.wmma.m8n32k16.mma.col.row.f32.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.row.f32.f32
llvm.nvvm.wmma.m8n32k16.mma.col.row.f32.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.col.f16.f16
llvm.nvvm.wmma.m8n32k16.mma.row.col.f16.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.col.f16.f32
llvm.nvvm.wmma.m8n32k16.mma.row.col.f16.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.col.f32.f16
llvm.nvvm.wmma.m8n32k16.mma.row.col.f32.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.col.f32.f32
llvm.nvvm.wmma.m8n32k16.mma.row.col.f32.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.row.f16.f16
llvm.nvvm.wmma.m8n32k16.mma.row.row.f16.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.row.f16.f32
llvm.nvvm.wmma.m8n32k16.mma.row.row.f16.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.row.f32.f16
llvm.nvvm.wmma.m8n32k16.mma.row.row.f32.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.row.f32.f32
llvm.nvvm.wmma.m8n32k16.mma.row.row.f32.f32.satfinite
llvm.nvvm.wmma.m8n32k16.store.d.col.f16
llvm.nvvm.wmma.m8n32k16.store.d.col.f32
llvm.nvvm.wmma.m8n32k16.store.d.col.stride.f16
llvm.nvvm.wmma.m8n32k16.store.d.col.stride.f32
llvm.nvvm.wmma.m8n32k16.store.d.row.f16
llvm.nvvm.wmma.m8n32k16.store.d.row.f32
llvm.nvvm.wmma.m8n32k16.store.d.row.stride.f16
llvm.nvvm.wmma.m8n32k16.store.d.row.stride.f32
llvm.ppc.addf128.round.to.odd
llvm.ppc.altivec.crypto.vcipher
llvm.ppc.altivec.crypto.vcipherlast
llvm.ppc.altivec.crypto.vncipher
llvm.ppc.altivec.crypto.vncipherlast
llvm.ppc.altivec.crypto.vpermxor
llvm.ppc.altivec.crypto.vpmsumb
llvm.ppc.altivec.crypto.vpmsumd
llvm.ppc.altivec.crypto.vpmsumh
llvm.ppc.altivec.crypto.vpmsumw
llvm.ppc.altivec.crypto.vsbox
llvm.ppc.altivec.crypto.vshasigmad
llvm.ppc.altivec.crypto.vshasigmaw
llvm.ppc.altivec.dss
llvm.ppc.altivec.dssall
llvm.ppc.altivec.dst
llvm.ppc.altivec.dstst
llvm.ppc.altivec.dststt
llvm.ppc.altivec.dstt
llvm.ppc.altivec.lvebx
llvm.ppc.altivec.lvehx
llvm.ppc.altivec.lvewx
llvm.ppc.altivec.lvsl
llvm.ppc.altivec.lvsr
llvm.ppc.altivec.lvx
llvm.ppc.altivec.lvxl
llvm.ppc.altivec.mfvscr
llvm.ppc.altivec.mtvscr
llvm.ppc.altivec.stvebx
llvm.ppc.altivec.stvehx
llvm.ppc.altivec.stvewx
llvm.ppc.altivec.stvx
llvm.ppc.altivec.stvxl
llvm.ppc.altivec.vabsdub
llvm.ppc.altivec.vabsduh
llvm.ppc.altivec.vabsduw
llvm.ppc.altivec.vaddcuq
llvm.ppc.altivec.vaddcuw
llvm.ppc.altivec.vaddecuq
llvm.ppc.altivec.vaddeuqm
llvm.ppc.altivec.vaddsbs
llvm.ppc.altivec.vaddshs
llvm.ppc.altivec.vaddsws
llvm.ppc.altivec.vaddubs
llvm.ppc.altivec.vadduhs
llvm.ppc.altivec.vadduws
llvm.ppc.altivec.vavgsb
llvm.ppc.altivec.vavgsh
llvm.ppc.altivec.vavgsw
llvm.ppc.altivec.vavgub
llvm.ppc.altivec.vavguh
llvm.ppc.altivec.vavguw
llvm.ppc.altivec.vbpermq
llvm.ppc.altivec.vcfsx
llvm.ppc.altivec.vcfux
llvm.ppc.altivec.vclzlsbb
llvm.ppc.altivec.vcmpbfp
llvm.ppc.altivec.vcmpbfp.p
llvm.ppc.altivec.vcmpeqfp
llvm.ppc.altivec.vcmpeqfp.p
llvm.ppc.altivec.vcmpequb
llvm.ppc.altivec.vcmpequb.p
llvm.ppc.altivec.vcmpequd
llvm.ppc.altivec.vcmpequd.p
llvm.ppc.altivec.vcmpequh
llvm.ppc.altivec.vcmpequh.p
llvm.ppc.altivec.vcmpequw
llvm.ppc.altivec.vcmpequw.p
llvm.ppc.altivec.vcmpgefp
llvm.ppc.altivec.vcmpgefp.p
llvm.ppc.altivec.vcmpgtfp
llvm.ppc.altivec.vcmpgtfp.p
llvm.ppc.altivec.vcmpgtsb
llvm.ppc.altivec.vcmpgtsb.p
llvm.ppc.altivec.vcmpgtsd
llvm.ppc.altivec.vcmpgtsd.p
llvm.ppc.altivec.vcmpgtsh
llvm.ppc.altivec.vcmpgtsh.p
llvm.ppc.altivec.vcmpgtsw
llvm.ppc.altivec.vcmpgtsw.p
llvm.ppc.altivec.vcmpgtub
llvm.ppc.altivec.vcmpgtub.p
llvm.ppc.altivec.vcmpgtud
llvm.ppc.altivec.vcmpgtud.p
llvm.ppc.altivec.vcmpgtuh
llvm.ppc.altivec.vcmpgtuh.p
llvm.ppc.altivec.vcmpgtuw
llvm.ppc.altivec.vcmpgtuw.p
llvm.ppc.altivec.vcmpneb
llvm.ppc.altivec.vcmpneb.p
llvm.ppc.altivec.vcmpneh
llvm.ppc.altivec.vcmpneh.p
llvm.ppc.altivec.vcmpnew
llvm.ppc.altivec.vcmpnew.p
llvm.ppc.altivec.vcmpnezb
llvm.ppc.altivec.vcmpnezb.p
llvm.ppc.altivec.vcmpnezh
llvm.ppc.altivec.vcmpnezh.p
llvm.ppc.altivec.vcmpnezw
llvm.ppc.altivec.vcmpnezw.p
llvm.ppc.altivec.vctsxs
llvm.ppc.altivec.vctuxs
llvm.ppc.altivec.vctzlsbb
llvm.ppc.altivec.vexptefp
llvm.ppc.altivec.vgbbd
llvm.ppc.altivec.vlogefp
llvm.ppc.altivec.vmaddfp
llvm.ppc.altivec.vmaxfp
llvm.ppc.altivec.vmaxsb
llvm.ppc.altivec.vmaxsd
llvm.ppc.altivec.vmaxsh
llvm.ppc.altivec.vmaxsw
llvm.ppc.altivec.vmaxub
llvm.ppc.altivec.vmaxud
llvm.ppc.altivec.vmaxuh
llvm.ppc.altivec.vmaxuw
llvm.ppc.altivec.vmhaddshs
llvm.ppc.altivec.vmhraddshs
llvm.ppc.altivec.vminfp
llvm.ppc.altivec.vminsb
llvm.ppc.altivec.vminsd
llvm.ppc.altivec.vminsh
llvm.ppc.altivec.vminsw
llvm.ppc.altivec.vminub
llvm.ppc.altivec.vminud
llvm.ppc.altivec.vminuh
llvm.ppc.altivec.vminuw
llvm.ppc.altivec.vmladduhm
llvm.ppc.altivec.vmsummbm
llvm.ppc.altivec.vmsumshm
llvm.ppc.altivec.vmsumshs
llvm.ppc.altivec.vmsumubm
llvm.ppc.altivec.vmsumuhm
llvm.ppc.altivec.vmsumuhs
llvm.ppc.altivec.vmulesb
llvm.ppc.altivec.vmulesh
llvm.ppc.altivec.vmulesw
llvm.ppc.altivec.vmuleub
llvm.ppc.altivec.vmuleuh
llvm.ppc.altivec.vmuleuw
llvm.ppc.altivec.vmulosb
llvm.ppc.altivec.vmulosh
llvm.ppc.altivec.vmulosw
llvm.ppc.altivec.vmuloub
llvm.ppc.altivec.vmulouh
llvm.ppc.altivec.vmulouw
llvm.ppc.altivec.vnmsubfp
llvm.ppc.altivec.vperm
llvm.ppc.altivec.vpkpx
llvm.ppc.altivec.vpksdss
llvm.ppc.altivec.vpksdus
llvm.ppc.altivec.vpkshss
llvm.ppc.altivec.vpkshus
llvm.ppc.altivec.vpkswss
llvm.ppc.altivec.vpkswus
llvm.ppc.altivec.vpkudus
llvm.ppc.altivec.vpkuhus
llvm.ppc.altivec.vpkuwus
llvm.ppc.altivec.vprtybd
llvm.ppc.altivec.vprtybq
llvm.ppc.altivec.vprtybw
llvm.ppc.altivec.vrefp
llvm.ppc.altivec.vrfim
llvm.ppc.altivec.vrfin
llvm.ppc.altivec.vrfip
llvm.ppc.altivec.vrfiz
llvm.ppc.altivec.vrlb
llvm.ppc.altivec.vrld
llvm.ppc.altivec.vrldmi
llvm.ppc.altivec.vrldnm
llvm.ppc.altivec.vrlh
llvm.ppc.altivec.vrlw
llvm.ppc.altivec.vrlwmi
llvm.ppc.altivec.vrlwnm
llvm.ppc.altivec.vrsqrtefp
llvm.ppc.altivec.vsel
llvm.ppc.altivec.vsl
llvm.ppc.altivec.vslb
llvm.ppc.altivec.vslh
llvm.ppc.altivec.vslo
llvm.ppc.altivec.vslv
llvm.ppc.altivec.vslw
llvm.ppc.altivec.vsr
llvm.ppc.altivec.vsrab
llvm.ppc.altivec.vsrah
llvm.ppc.altivec.vsraw
llvm.ppc.altivec.vsrb
llvm.ppc.altivec.vsrh
llvm.ppc.altivec.vsro
llvm.ppc.altivec.vsrv
llvm.ppc.altivec.vsrw
llvm.ppc.altivec.vsubcuq
llvm.ppc.altivec.vsubcuw
llvm.ppc.altivec.vsubecuq
llvm.ppc.altivec.vsubeuqm
llvm.ppc.altivec.vsubsbs
llvm.ppc.altivec.vsubshs
llvm.ppc.altivec.vsubsws
llvm.ppc.altivec.vsububs
llvm.ppc.altivec.vsubuhs
llvm.ppc.altivec.vsubuws
llvm.ppc.altivec.vsum2sws
llvm.ppc.altivec.vsum4sbs
llvm.ppc.altivec.vsum4shs
llvm.ppc.altivec.vsum4ubs
llvm.ppc.altivec.vsumsws
llvm.ppc.altivec.vupkhpx
llvm.ppc.altivec.vupkhsb
llvm.ppc.altivec.vupkhsh
llvm.ppc.altivec.vupkhsw
llvm.ppc.altivec.vupklpx
llvm.ppc.altivec.vupklsb
llvm.ppc.altivec.vupklsh
llvm.ppc.altivec.vupklsw
llvm.ppc.bpermd
llvm.ppc.cfence
llvm.ppc.dcba
llvm.ppc.dcbf
llvm.ppc.dcbi
llvm.ppc.dcbst
llvm.ppc.dcbt
llvm.ppc.dcbtst
llvm.ppc.dcbz
llvm.ppc.dcbzl
llvm.ppc.divde
llvm.ppc.divdeu
llvm.ppc.divf128.round.to.odd
llvm.ppc.divwe
llvm.ppc.divweu
llvm.ppc.fmaf128.round.to.odd
llvm.ppc.get.texasr
llvm.ppc.get.texasru
llvm.ppc.get.tfhar
llvm.ppc.get.tfiar
llvm.ppc.is.decremented.ctr.nonzero
llvm.ppc.lwsync
llvm.ppc.mtctr
llvm.ppc.mulf128.round.to.odd
llvm.ppc.qpx.qvfabs
llvm.ppc.qpx.qvfadd
llvm.ppc.qpx.qvfadds
llvm.ppc.qpx.qvfcfid
llvm.ppc.qpx.qvfcfids
llvm.ppc.qpx.qvfcfidu
llvm.ppc.qpx.qvfcfidus
llvm.ppc.qpx.qvfcmpeq
llvm.ppc.qpx.qvfcmpgt
llvm.ppc.qpx.qvfcmplt
llvm.ppc.qpx.qvfcpsgn
llvm.ppc.qpx.qvfctid
llvm.ppc.qpx.qvfctidu
llvm.ppc.qpx.qvfctiduz
llvm.ppc.qpx.qvfctidz
llvm.ppc.qpx.qvfctiw
llvm.ppc.qpx.qvfctiwu
llvm.ppc.qpx.qvfctiwuz
llvm.ppc.qpx.qvfctiwz
llvm.ppc.qpx.qvflogical
llvm.ppc.qpx.qvfmadd
llvm.ppc.qpx.qvfmadds
llvm.ppc.qpx.qvfmsub
llvm.ppc.qpx.qvfmsubs
llvm.ppc.qpx.qvfmul
llvm.ppc.qpx.qvfmuls
llvm.ppc.qpx.qvfnabs
llvm.ppc.qpx.qvfneg
llvm.ppc.qpx.qvfnmadd
llvm.ppc.qpx.qvfnmadds
llvm.ppc.qpx.qvfnmsub
llvm.ppc.qpx.qvfnmsubs
llvm.ppc.qpx.qvfperm
llvm.ppc.qpx.qvfre
llvm.ppc.qpx.qvfres
llvm.ppc.qpx.qvfrim
llvm.ppc.qpx.qvfrin
llvm.ppc.qpx.qvfrip
llvm.ppc.qpx.qvfriz
llvm.ppc.qpx.qvfrsp
llvm.ppc.qpx.qvfrsqrte
llvm.ppc.qpx.qvfrsqrtes
llvm.ppc.qpx.qvfsel
llvm.ppc.qpx.qvfsub
llvm.ppc.qpx.qvfsubs
llvm.ppc.qpx.qvftstnan
llvm.ppc.qpx.qvfxmadd
llvm.ppc.qpx.qvfxmadds
llvm.ppc.qpx.qvfxmul
llvm.ppc.qpx.qvfxmuls
llvm.ppc.qpx.qvfxxcpnmadd
llvm.ppc.qpx.qvfxxcpnmadds
llvm.ppc.qpx.qvfxxmadd
llvm.ppc.qpx.qvfxxmadds
llvm.ppc.qpx.qvfxxnpmadd
llvm.ppc.qpx.qvfxxnpmadds
llvm.ppc.qpx.qvgpci
llvm.ppc.qpx.qvlfcd
llvm.ppc.qpx.qvlfcda
llvm.ppc.qpx.qvlfcs
llvm.ppc.qpx.qvlfcsa
llvm.ppc.qpx.qvlfd
llvm.ppc.qpx.qvlfda
llvm.ppc.qpx.qvlfiwa
llvm.ppc.qpx.qvlfiwaa
llvm.ppc.qpx.qvlfiwz
llvm.ppc.qpx.qvlfiwza
llvm.ppc.qpx.qvlfs
llvm.ppc.qpx.qvlfsa
llvm.ppc.qpx.qvlpcld
llvm.ppc.qpx.qvlpcls
llvm.ppc.qpx.qvlpcrd
llvm.ppc.qpx.qvlpcrs
llvm.ppc.qpx.qvstfcd
llvm.ppc.qpx.qvstfcda
llvm.ppc.qpx.qvstfcs
llvm.ppc.qpx.qvstfcsa
llvm.ppc.qpx.qvstfd
llvm.ppc.qpx.qvstfda
llvm.ppc.qpx.qvstfiw
llvm.ppc.qpx.qvstfiwa
llvm.ppc.qpx.qvstfs
llvm.ppc.qpx.qvstfsa
llvm.ppc.set.texasr
llvm.ppc.set.texasru
llvm.ppc.set.tfhar
llvm.ppc.set.tfiar
llvm.ppc.sqrtf128.round.to.odd
llvm.ppc.subf128.round.to.odd
llvm.ppc.sync
llvm.ppc.tabort
llvm.ppc.tabortdc
llvm.ppc.tabortdci
llvm.ppc.tabortwc
llvm.ppc.tabortwci
llvm.ppc.tbegin
llvm.ppc.tcheck
llvm.ppc.tend
llvm.ppc.tendall
llvm.ppc.trechkpt
llvm.ppc.treclaim
llvm.ppc.tresume
llvm.ppc.truncf128.round.to.odd
llvm.ppc.tsr
llvm.ppc.tsuspend
llvm.ppc.ttest
llvm.ppc.vsx.lxvd2x
llvm.ppc.vsx.lxvd2x.be
llvm.ppc.vsx.lxvl
llvm.ppc.vsx.lxvll
llvm.ppc.vsx.lxvw4x
llvm.ppc.vsx.lxvw4x.be
llvm.ppc.vsx.stxvd2x
llvm.ppc.vsx.stxvd2x.be
llvm.ppc.vsx.stxvl
llvm.ppc.vsx.stxvll
llvm.ppc.vsx.stxvw4x
llvm.ppc.vsx.stxvw4x.be
llvm.ppc.vsx.xsmaxdp
llvm.ppc.vsx.xsmindp
llvm.ppc.vsx.xvcmpeqdp
llvm.ppc.vsx.xvcmpeqdp.p
llvm.ppc.vsx.xvcmpeqsp
llvm.ppc.vsx.xvcmpeqsp.p
llvm.ppc.vsx.xvcmpgedp
llvm.ppc.vsx.xvcmpgedp.p
llvm.ppc.vsx.xvcmpgesp
llvm.ppc.vsx.xvcmpgesp.p
llvm.ppc.vsx.xvcmpgtdp
llvm.ppc.vsx.xvcmpgtdp.p
llvm.ppc.vsx.xvcmpgtsp
llvm.ppc.vsx.xvcmpgtsp.p
llvm.ppc.vsx.xvcvdpsp
llvm.ppc.vsx.xvcvdpsxws
llvm.ppc.vsx.xvcvdpuxws
llvm.ppc.vsx.xvcvhpsp
llvm.ppc.vsx.xvcvspdp
llvm.ppc.vsx.xvcvsphp
llvm.ppc.vsx.xvcvsxdsp
llvm.ppc.vsx.xvcvsxwdp
llvm.ppc.vsx.xvcvuxdsp
llvm.ppc.vsx.xvcvuxwdp
llvm.ppc.vsx.xvdivdp
llvm.ppc.vsx.xvdivsp
llvm.ppc.vsx.xviexpdp
llvm.ppc.vsx.xviexpsp
llvm.ppc.vsx.xvmaxdp
llvm.ppc.vsx.xvmaxsp
llvm.ppc.vsx.xvmindp
llvm.ppc.vsx.xvminsp
llvm.ppc.vsx.xvrdpip
llvm.ppc.vsx.xvredp
llvm.ppc.vsx.xvresp
llvm.ppc.vsx.xvrspip
llvm.ppc.vsx.xvrsqrtedp
llvm.ppc.vsx.xvrsqrtesp
llvm.ppc.vsx.xvtstdcdp
llvm.ppc.vsx.xvtstdcsp
llvm.ppc.vsx.xvxexpdp
llvm.ppc.vsx.xvxexpsp
llvm.ppc.vsx.xvxsigdp
llvm.ppc.vsx.xvxsigsp
llvm.ppc.vsx.xxextractuw
llvm.ppc.vsx.xxinsertw
llvm.ppc.vsx.xxleqv
llvm.r600.cube
llvm.r600.ddx
llvm.r600.ddy
llvm.r600.dot4
llvm.r600.group.barrier
llvm.r600.implicitarg.ptr
llvm.r600.kill
llvm.r600.rat.store.typed
llvm.r600.read.global.size.x
llvm.r600.read.global.size.y
llvm.r600.read.global.size.z
llvm.r600.read.local.size.x
llvm.r600.read.local.size.y
llvm.r600.read.local.size.z
llvm.r600.read.ngroups.x
llvm.r600.read.ngroups.y
llvm.r600.read.ngroups.z
llvm.r600.read.tgid.x
llvm.r600.read.tgid.y
llvm.r600.read.tgid.z
llvm.r600.read.tidig.x
llvm.r600.read.tidig.y
llvm.r600.read.tidig.z
llvm.r600.recipsqrt.clamped
llvm.r600.recipsqrt.ieee
llvm.r600.store.stream.output
llvm.r600.store.swizzle
llvm.r600.tex
llvm.r600.texc
llvm.r600.txb
llvm.r600.txbc
llvm.r600.txf
llvm.r600.txl
llvm.r600.txlc
llvm.r600.txq
llvm.s390.efpc
llvm.s390.etnd
llvm.s390.lcbb
llvm.s390.ntstg
llvm.s390.ppa.txassist
llvm.s390.sfpc
llvm.s390.tabort
llvm.s390.tbegin
llvm.s390.tbegin.nofloat
llvm.s390.tbeginc
llvm.s390.tdc
llvm.s390.tend
llvm.s390.vaccb
llvm.s390.vacccq
llvm.s390.vaccf
llvm.s390.vaccg
llvm.s390.vacch
llvm.s390.vaccq
llvm.s390.vacq
llvm.s390.vaq
llvm.s390.vavgb
llvm.s390.vavgf
llvm.s390.vavgg
llvm.s390.vavgh
llvm.s390.vavglb
llvm.s390.vavglf
llvm.s390.vavglg
llvm.s390.vavglh
llvm.s390.vbperm
llvm.s390.vceqbs
llvm.s390.vceqfs
llvm.s390.vceqgs
llvm.s390.vceqhs
llvm.s390.vchbs
llvm.s390.vchfs
llvm.s390.vchgs
llvm.s390.vchhs
llvm.s390.vchlbs
llvm.s390.vchlfs
llvm.s390.vchlgs
llvm.s390.vchlhs
llvm.s390.vcksm
llvm.s390.verimb
llvm.s390.verimf
llvm.s390.verimg
llvm.s390.verimh
llvm.s390.verllb
llvm.s390.verllf
llvm.s390.verllg
llvm.s390.verllh
llvm.s390.verllvb
llvm.s390.verllvf
llvm.s390.verllvg
llvm.s390.verllvh
llvm.s390.vfaeb
llvm.s390.vfaebs
llvm.s390.vfaef
llvm.s390.vfaefs
llvm.s390.vfaeh
llvm.s390.vfaehs
llvm.s390.vfaezb
llvm.s390.vfaezbs
llvm.s390.vfaezf
llvm.s390.vfaezfs
llvm.s390.vfaezh
llvm.s390.vfaezhs
llvm.s390.vfcedbs
llvm.s390.vfcesbs
llvm.s390.vfchdbs
llvm.s390.vfchedbs
llvm.s390.vfchesbs
llvm.s390.vfchsbs
llvm.s390.vfeeb
llvm.s390.vfeebs
llvm.s390.vfeef
llvm.s390.vfeefs
llvm.s390.vfeeh
llvm.s390.vfeehs
llvm.s390.vfeezb
llvm.s390.vfeezbs
llvm.s390.vfeezf
llvm.s390.vfeezfs
llvm.s390.vfeezh
llvm.s390.vfeezhs
llvm.s390.vfeneb
llvm.s390.vfenebs
llvm.s390.vfenef
llvm.s390.vfenefs
llvm.s390.vfeneh
llvm.s390.vfenehs
llvm.s390.vfenezb
llvm.s390.vfenezbs
llvm.s390.vfenezf
llvm.s390.vfenezfs
llvm.s390.vfenezh
llvm.s390.vfenezhs
llvm.s390.vfidb
llvm.s390.vfisb
llvm.s390.vfmaxdb
llvm.s390.vfmaxsb
llvm.s390.vfmindb
llvm.s390.vfminsb
llvm.s390.vftcidb
llvm.s390.vftcisb
llvm.s390.vgfmab
llvm.s390.vgfmaf
llvm.s390.vgfmag
llvm.s390.vgfmah
llvm.s390.vgfmb
llvm.s390.vgfmf
llvm.s390.vgfmg
llvm.s390.vgfmh
llvm.s390.vistrb
llvm.s390.vistrbs
llvm.s390.vistrf
llvm.s390.vistrfs
llvm.s390.vistrh
llvm.s390.vistrhs
llvm.s390.vlbb
llvm.s390.vll
llvm.s390.vlrl
llvm.s390.vmaeb
llvm.s390.vmaef
llvm.s390.vmaeh
llvm.s390.vmahb
llvm.s390.vmahf
llvm.s390.vmahh
llvm.s390.vmaleb
llvm.s390.vmalef
llvm.s390.vmaleh
llvm.s390.vmalhb
llvm.s390.vmalhf
llvm.s390.vmalhh
llvm.s390.vmalob
llvm.s390.vmalof
llvm.s390.vmaloh
llvm.s390.vmaob
llvm.s390.vmaof
llvm.s390.vmaoh
llvm.s390.vmeb
llvm.s390.vmef
llvm.s390.vmeh
llvm.s390.vmhb
llvm.s390.vmhf
llvm.s390.vmhh
llvm.s390.vmleb
llvm.s390.vmlef
llvm.s390.vmleh
llvm.s390.vmlhb
llvm.s390.vmlhf
llvm.s390.vmlhh
llvm.s390.vmlob
llvm.s390.vmlof
llvm.s390.vmloh
llvm.s390.vmob
llvm.s390.vmof
llvm.s390.vmoh
llvm.s390.vmslg
llvm.s390.vpdi
llvm.s390.vperm
llvm.s390.vpklsf
llvm.s390.vpklsfs
llvm.s390.vpklsg
llvm.s390.vpklsgs
llvm.s390.vpklsh
llvm.s390.vpklshs
llvm.s390.vpksf
llvm.s390.vpksfs
llvm.s390.vpksg
llvm.s390.vpksgs
llvm.s390.vpksh
llvm.s390.vpkshs
llvm.s390.vsbcbiq
llvm.s390.vsbiq
llvm.s390.vscbib
llvm.s390.vscbif
llvm.s390.vscbig
llvm.s390.vscbih
llvm.s390.vscbiq
llvm.s390.vsl
llvm.s390.vslb
llvm.s390.vsldb
llvm.s390.vsq
llvm.s390.vsra
llvm.s390.vsrab
llvm.s390.vsrl
llvm.s390.vsrlb
llvm.s390.vstl
llvm.s390.vstrcb
llvm.s390.vstrcbs
llvm.s390.vstrcf
llvm.s390.vstrcfs
llvm.s390.vstrch
llvm.s390.vstrchs
llvm.s390.vstrczb
llvm.s390.vstrczbs
llvm.s390.vstrczf
llvm.s390.vstrczfs
llvm.s390.vstrczh
llvm.s390.vstrczhs
llvm.s390.vstrl
llvm.s390.vsumb
llvm.s390.vsumgf
llvm.s390.vsumgh
llvm.s390.vsumh
llvm.s390.vsumqf
llvm.s390.vsumqg
llvm.s390.vtm
llvm.s390.vuphb
llvm.s390.vuphf
llvm.s390.vuphh
llvm.s390.vuplb
llvm.s390.vuplf
llvm.s390.vuplhb
llvm.s390.vuplhf
llvm.s390.vuplhh
llvm.s390.vuplhw
llvm.s390.vupllb
llvm.s390.vupllf
llvm.s390.vupllh
llvm.wasm.catch
llvm.wasm.current.memory
llvm.wasm.get.ehselector
llvm.wasm.get.exception
llvm.wasm.grow.memory
llvm.wasm.landingpad.index
llvm.wasm.lsda
llvm.wasm.mem.grow
llvm.wasm.mem.size
llvm.wasm.memory.grow
llvm.wasm.memory.size
llvm.wasm.rethrow
llvm.wasm.throw
llvm.x86.3dnow.pavgusb
llvm.x86.3dnow.pf2id
llvm.x86.3dnow.pfacc
llvm.x86.3dnow.pfadd
llvm.x86.3dnow.pfcmpeq
llvm.x86.3dnow.pfcmpge
llvm.x86.3dnow.pfcmpgt
llvm.x86.3dnow.pfmax
llvm.x86.3dnow.pfmin
llvm.x86.3dnow.pfmul
llvm.x86.3dnow.pfrcp
llvm.x86.3dnow.pfrcpit1
llvm.x86.3dnow.pfrcpit2
llvm.x86.3dnow.pfrsqit1
llvm.x86.3dnow.pfrsqrt
llvm.x86.3dnow.pfsub
llvm.x86.3dnow.pfsubr
llvm.x86.3dnow.pi2fd
llvm.x86.3dnow.pmulhrw
llvm.x86.3dnowa.pf2iw
llvm.x86.3dnowa.pfnacc
llvm.x86.3dnowa.pfpnacc
llvm.x86.3dnowa.pi2fw
llvm.x86.3dnowa.pswapd
llvm.x86.addcarry.u32
llvm.x86.addcarry.u64
llvm.x86.addcarryx.u32
llvm.x86.addcarryx.u64
llvm.x86.aesni.aesdec
llvm.x86.aesni.aesdec.256
llvm.x86.aesni.aesdec.512
llvm.x86.aesni.aesdeclast
llvm.x86.aesni.aesdeclast.256
llvm.x86.aesni.aesdeclast.512
llvm.x86.aesni.aesenc
llvm.x86.aesni.aesenc.256
llvm.x86.aesni.aesenc.512
llvm.x86.aesni.aesenclast
llvm.x86.aesni.aesenclast.256
llvm.x86.aesni.aesenclast.512
llvm.x86.aesni.aesimc
llvm.x86.aesni.aeskeygenassist
llvm.x86.avx.addsub.pd.256
llvm.x86.avx.addsub.ps.256
llvm.x86.avx.blendv.pd.256
llvm.x86.avx.blendv.ps.256
llvm.x86.avx.cmp.pd.256
llvm.x86.avx.cmp.ps.256
llvm.x86.avx.cvt.pd2.ps.256
llvm.x86.avx.cvt.pd2dq.256
llvm.x86.avx.cvt.ps2dq.256
llvm.x86.avx.cvtt.pd2dq.256
llvm.x86.avx.cvtt.ps2dq.256
llvm.x86.avx.dp.ps.256
llvm.x86.avx.hadd.pd.256
llvm.x86.avx.hadd.ps.256
llvm.x86.avx.hsub.pd.256
llvm.x86.avx.hsub.ps.256
llvm.x86.avx.ldu.dq.256
llvm.x86.avx.maskload.pd
llvm.x86.avx.maskload.pd.256
llvm.x86.avx.maskload.ps
llvm.x86.avx.maskload.ps.256
llvm.x86.avx.maskstore.pd
llvm.x86.avx.maskstore.pd.256
llvm.x86.avx.maskstore.ps
llvm.x86.avx.maskstore.ps.256
llvm.x86.avx.max.pd.256
llvm.x86.avx.max.ps.256
llvm.x86.avx.min.pd.256
llvm.x86.avx.min.ps.256
llvm.x86.avx.movmsk.pd.256
llvm.x86.avx.movmsk.ps.256
llvm.x86.avx.ptestc.256
llvm.x86.avx.ptestnzc.256
llvm.x86.avx.ptestz.256
llvm.x86.avx.rcp.ps.256
llvm.x86.avx.round.pd.256
llvm.x86.avx.round.ps.256
llvm.x86.avx.rsqrt.ps.256
llvm.x86.avx.vpermilvar.pd
llvm.x86.avx.vpermilvar.pd.256
llvm.x86.avx.vpermilvar.ps
llvm.x86.avx.vpermilvar.ps.256
llvm.x86.avx.vtestc.pd
llvm.x86.avx.vtestc.pd.256
llvm.x86.avx.vtestc.ps
llvm.x86.avx.vtestc.ps.256
llvm.x86.avx.vtestnzc.pd
llvm.x86.avx.vtestnzc.pd.256
llvm.x86.avx.vtestnzc.ps
llvm.x86.avx.vtestnzc.ps.256
llvm.x86.avx.vtestz.pd
llvm.x86.avx.vtestz.pd.256
llvm.x86.avx.vtestz.ps
llvm.x86.avx.vtestz.ps.256
llvm.x86.avx.vzeroall
llvm.x86.avx.vzeroupper
llvm.x86.avx2.gather.d.d
llvm.x86.avx2.gather.d.d.256
llvm.x86.avx2.gather.d.pd
llvm.x86.avx2.gather.d.pd.256
llvm.x86.avx2.gather.d.ps
llvm.x86.avx2.gather.d.ps.256
llvm.x86.avx2.gather.d.q
llvm.x86.avx2.gather.d.q.256
llvm.x86.avx2.gather.q.d
llvm.x86.avx2.gather.q.d.256
llvm.x86.avx2.gather.q.pd
llvm.x86.avx2.gather.q.pd.256
llvm.x86.avx2.gather.q.ps
llvm.x86.avx2.gather.q.ps.256
llvm.x86.avx2.gather.q.q
llvm.x86.avx2.gather.q.q.256
llvm.x86.avx2.maskload.d
llvm.x86.avx2.maskload.d.256
llvm.x86.avx2.maskload.q
llvm.x86.avx2.maskload.q.256
llvm.x86.avx2.maskstore.d
llvm.x86.avx2.maskstore.d.256
llvm.x86.avx2.maskstore.q
llvm.x86.avx2.maskstore.q.256
llvm.x86.avx2.mpsadbw
llvm.x86.avx2.packssdw
llvm.x86.avx2.packsswb
llvm.x86.avx2.packusdw
llvm.x86.avx2.packuswb
llvm.x86.avx2.padds.b
llvm.x86.avx2.padds.w
llvm.x86.avx2.paddus.b
llvm.x86.avx2.paddus.w
llvm.x86.avx2.pblendvb
llvm.x86.avx2.permd
llvm.x86.avx2.permps
llvm.x86.avx2.phadd.d
llvm.x86.avx2.phadd.sw
llvm.x86.avx2.phadd.w
llvm.x86.avx2.phsub.d
llvm.x86.avx2.phsub.sw
llvm.x86.avx2.phsub.w
llvm.x86.avx2.pmadd.ub.sw
llvm.x86.avx2.pmadd.wd
llvm.x86.avx2.pmovmskb
llvm.x86.avx2.pmul.hr.sw
llvm.x86.avx2.pmulh.w
llvm.x86.avx2.pmulhu.w
llvm.x86.avx2.psad.bw
llvm.x86.avx2.pshuf.b
llvm.x86.avx2.psign.b
llvm.x86.avx2.psign.d
llvm.x86.avx2.psign.w
llvm.x86.avx2.psll.d
llvm.x86.avx2.psll.q
llvm.x86.avx2.psll.w
llvm.x86.avx2.pslli.d
llvm.x86.avx2.pslli.q
llvm.x86.avx2.pslli.w
llvm.x86.avx2.psllv.d
llvm.x86.avx2.psllv.d.256
llvm.x86.avx2.psllv.q
llvm.x86.avx2.psllv.q.256
llvm.x86.avx2.psra.d
llvm.x86.avx2.psra.w
llvm.x86.avx2.psrai.d
llvm.x86.avx2.psrai.w
llvm.x86.avx2.psrav.d
llvm.x86.avx2.psrav.d.256
llvm.x86.avx2.psrl.d
llvm.x86.avx2.psrl.q
llvm.x86.avx2.psrl.w
llvm.x86.avx2.psrli.d
llvm.x86.avx2.psrli.q
llvm.x86.avx2.psrli.w
llvm.x86.avx2.psrlv.d
llvm.x86.avx2.psrlv.d.256
llvm.x86.avx2.psrlv.q
llvm.x86.avx2.psrlv.q.256
llvm.x86.avx2.psubs.b
llvm.x86.avx2.psubs.w
llvm.x86.avx2.psubus.b
llvm.x86.avx2.psubus.w
llvm.x86.avx512.add.pd.512
llvm.x86.avx512.add.ps.512
llvm.x86.avx512.broadcastmb.128
llvm.x86.avx512.broadcastmb.256
llvm.x86.avx512.broadcastmb.512
llvm.x86.avx512.broadcastmw.128
llvm.x86.avx512.broadcastmw.256
llvm.x86.avx512.broadcastmw.512
llvm.x86.avx512.cmp.pd.128
llvm.x86.avx512.cmp.pd.256
llvm.x86.avx512.cmp.pd.512
llvm.x86.avx512.cmp.ps.128
llvm.x86.avx512.cmp.ps.256
llvm.x86.avx512.cmp.ps.512
llvm.x86.avx512.cvtsi2sd64
llvm.x86.avx512.cvtsi2ss32
llvm.x86.avx512.cvtsi2ss64
llvm.x86.avx512.cvttsd2si
llvm.x86.avx512.cvttsd2si64
llvm.x86.avx512.cvttsd2usi
llvm.x86.avx512.cvttsd2usi64
llvm.x86.avx512.cvttss2si
llvm.x86.avx512.cvttss2si64
llvm.x86.avx512.cvttss2usi
llvm.x86.avx512.cvttss2usi64
llvm.x86.avx512.cvtusi2ss
llvm.x86.avx512.cvtusi642sd
llvm.x86.avx512.cvtusi642ss
llvm.x86.avx512.dbpsadbw.128
llvm.x86.avx512.dbpsadbw.256
llvm.x86.avx512.dbpsadbw.512
llvm.x86.avx512.div.pd.512
llvm.x86.avx512.div.ps.512
llvm.x86.avx512.exp2.pd
llvm.x86.avx512.exp2.ps
llvm.x86.avx512.fpclass.pd.128
llvm.x86.avx512.fpclass.pd.256
llvm.x86.avx512.fpclass.pd.512
llvm.x86.avx512.fpclass.ps.128
llvm.x86.avx512.fpclass.ps.256
llvm.x86.avx512.fpclass.ps.512
llvm.x86.avx512.gather.dpd.512
llvm.x86.avx512.gather.dpi.512
llvm.x86.avx512.gather.dpq.512
llvm.x86.avx512.gather.dps.512
llvm.x86.avx512.gather.qpd.512
llvm.x86.avx512.gather.qpi.512
llvm.x86.avx512.gather.qpq.512
llvm.x86.avx512.gather.qps.512
llvm.x86.avx512.gather3div2.df
llvm.x86.avx512.gather3div2.di
llvm.x86.avx512.gather3div4.df
llvm.x86.avx512.gather3div4.di
llvm.x86.avx512.gather3div4.sf
llvm.x86.avx512.gather3div4.si
llvm.x86.avx512.gather3div8.sf
llvm.x86.avx512.gather3div8.si
llvm.x86.avx512.gather3siv2.df
llvm.x86.avx512.gather3siv2.di
llvm.x86.avx512.gather3siv4.df
llvm.x86.avx512.gather3siv4.di
llvm.x86.avx512.gather3siv4.sf
llvm.x86.avx512.gather3siv4.si
llvm.x86.avx512.gather3siv8.sf
llvm.x86.avx512.gather3siv8.si
llvm.x86.avx512.gatherpf.dpd.512
llvm.x86.avx512.gatherpf.dps.512
llvm.x86.avx512.gatherpf.qpd.512
llvm.x86.avx512.gatherpf.qps.512
llvm.x86.avx512.mask.add.sd.round
llvm.x86.avx512.mask.add.ss.round
llvm.x86.avx512.mask.cmp.sd
llvm.x86.avx512.mask.cmp.ss
llvm.x86.avx512.mask.compress.b.128
llvm.x86.avx512.mask.compress.b.256
llvm.x86.avx512.mask.compress.b.512
llvm.x86.avx512.mask.compress.d.128
llvm.x86.avx512.mask.compress.d.256
llvm.x86.avx512.mask.compress.d.512
llvm.x86.avx512.mask.compress.pd.128
llvm.x86.avx512.mask.compress.pd.256
llvm.x86.avx512.mask.compress.pd.512
llvm.x86.avx512.mask.compress.ps.128
llvm.x86.avx512.mask.compress.ps.256
llvm.x86.avx512.mask.compress.ps.512
llvm.x86.avx512.mask.compress.q.128
llvm.x86.avx512.mask.compress.q.256
llvm.x86.avx512.mask.compress.q.512
llvm.x86.avx512.mask.compress.w.128
llvm.x86.avx512.mask.compress.w.256
llvm.x86.avx512.mask.compress.w.512
llvm.x86.avx512.mask.conflict.d.128
llvm.x86.avx512.mask.conflict.d.256
llvm.x86.avx512.mask.conflict.d.512
llvm.x86.avx512.mask.conflict.q.128
llvm.x86.avx512.mask.conflict.q.256
llvm.x86.avx512.mask.conflict.q.512
llvm.x86.avx512.mask.cvtdq2ps.512
llvm.x86.avx512.mask.cvtpd2dq.128
llvm.x86.avx512.mask.cvtpd2dq.512
llvm.x86.avx512.mask.cvtpd2ps
llvm.x86.avx512.mask.cvtpd2ps.512
llvm.x86.avx512.mask.cvtpd2qq.128
llvm.x86.avx512.mask.cvtpd2qq.256
llvm.x86.avx512.mask.cvtpd2qq.512
llvm.x86.avx512.mask.cvtpd2udq.128
llvm.x86.avx512.mask.cvtpd2udq.256
llvm.x86.avx512.mask.cvtpd2udq.512
llvm.x86.avx512.mask.cvtpd2uqq.128
llvm.x86.avx512.mask.cvtpd2uqq.256
llvm.x86.avx512.mask.cvtpd2uqq.512
llvm.x86.avx512.mask.cvtps2dq.128
llvm.x86.avx512.mask.cvtps2dq.256
llvm.x86.avx512.mask.cvtps2dq.512
llvm.x86.avx512.mask.cvtps2pd.512
llvm.x86.avx512.mask.cvtps2qq.128
llvm.x86.avx512.mask.cvtps2qq.256
llvm.x86.avx512.mask.cvtps2qq.512
llvm.x86.avx512.mask.cvtps2udq.128
llvm.x86.avx512.mask.cvtps2udq.256
llvm.x86.avx512.mask.cvtps2udq.512
llvm.x86.avx512.mask.cvtps2uqq.128
llvm.x86.avx512.mask.cvtps2uqq.256
llvm.x86.avx512.mask.cvtps2uqq.512
llvm.x86.avx512.mask.cvtqq2pd.512
llvm.x86.avx512.mask.cvtqq2ps.128
llvm.x86.avx512.mask.cvtqq2ps.256
llvm.x86.avx512.mask.cvtqq2ps.512
llvm.x86.avx512.mask.cvtsd2ss.round
llvm.x86.avx512.mask.cvtss2sd.round
llvm.x86.avx512.mask.cvttpd2dq.128
llvm.x86.avx512.mask.cvttpd2dq.512
llvm.x86.avx512.mask.cvttpd2qq.128
llvm.x86.avx512.mask.cvttpd2qq.256
llvm.x86.avx512.mask.cvttpd2qq.512
llvm.x86.avx512.mask.cvttpd2udq.128
llvm.x86.avx512.mask.cvttpd2udq.256
llvm.x86.avx512.mask.cvttpd2udq.512
llvm.x86.avx512.mask.cvttpd2uqq.128
llvm.x86.avx512.mask.cvttpd2uqq.256
llvm.x86.avx512.mask.cvttpd2uqq.512
llvm.x86.avx512.mask.cvttps2dq.512
llvm.x86.avx512.mask.cvttps2qq.128
llvm.x86.avx512.mask.cvttps2qq.256
llvm.x86.avx512.mask.cvttps2qq.512
llvm.x86.avx512.mask.cvttps2udq.128
llvm.x86.avx512.mask.cvttps2udq.256
llvm.x86.avx512.mask.cvttps2udq.512
llvm.x86.avx512.mask.cvttps2uqq.128
llvm.x86.avx512.mask.cvttps2uqq.256
llvm.x86.avx512.mask.cvttps2uqq.512
llvm.x86.avx512.mask.cvtudq2ps.512
llvm.x86.avx512.mask.cvtuqq2pd.512
llvm.x86.avx512.mask.cvtuqq2ps.128
llvm.x86.avx512.mask.cvtuqq2ps.256
llvm.x86.avx512.mask.cvtuqq2ps.512
llvm.x86.avx512.mask.div.sd.round
llvm.x86.avx512.mask.div.ss.round
llvm.x86.avx512.mask.expand.b.128
llvm.x86.avx512.mask.expand.b.256
llvm.x86.avx512.mask.expand.b.512
llvm.x86.avx512.mask.expand.d.128
llvm.x86.avx512.mask.expand.d.256
llvm.x86.avx512.mask.expand.d.512
llvm.x86.avx512.mask.expand.pd.128
llvm.x86.avx512.mask.expand.pd.256
llvm.x86.avx512.mask.expand.pd.512
llvm.x86.avx512.mask.expand.ps.128
llvm.x86.avx512.mask.expand.ps.256
llvm.x86.avx512.mask.expand.ps.512
llvm.x86.avx512.mask.expand.q.128
llvm.x86.avx512.mask.expand.q.256
llvm.x86.avx512.mask.expand.q.512
llvm.x86.avx512.mask.expand.w.128
llvm.x86.avx512.mask.expand.w.256
llvm.x86.avx512.mask.expand.w.512
llvm.x86.avx512.mask.fixupimm.pd.128
llvm.x86.avx512.mask.fixupimm.pd.256
llvm.x86.avx512.mask.fixupimm.pd.512
llvm.x86.avx512.mask.fixupimm.ps.128
llvm.x86.avx512.mask.fixupimm.ps.256
llvm.x86.avx512.mask.fixupimm.ps.512
llvm.x86.avx512.mask.fixupimm.sd
llvm.x86.avx512.mask.fixupimm.ss
llvm.x86.avx512.mask.fpclass.sd
llvm.x86.avx512.mask.fpclass.ss
llvm.x86.avx512.mask.getexp.pd.128
llvm.x86.avx512.mask.getexp.pd.256
llvm.x86.avx512.mask.getexp.pd.512
llvm.x86.avx512.mask.getexp.ps.128
llvm.x86.avx512.mask.getexp.ps.256
llvm.x86.avx512.mask.getexp.ps.512
llvm.x86.avx512.mask.getexp.sd
llvm.x86.avx512.mask.getexp.ss
llvm.x86.avx512.mask.getmant.pd.128
llvm.x86.avx512.mask.getmant.pd.256
llvm.x86.avx512.mask.getmant.pd.512
llvm.x86.avx512.mask.getmant.ps.128
llvm.x86.avx512.mask.getmant.ps.256
llvm.x86.avx512.mask.getmant.ps.512
llvm.x86.avx512.mask.getmant.sd
llvm.x86.avx512.mask.getmant.ss
llvm.x86.avx512.mask.max.sd.round
llvm.x86.avx512.mask.max.ss.round
llvm.x86.avx512.mask.min.sd.round
llvm.x86.avx512.mask.min.ss.round
llvm.x86.avx512.mask.mul.sd.round
llvm.x86.avx512.mask.mul.ss.round
llvm.x86.avx512.mask.padds.b.128
llvm.x86.avx512.mask.padds.b.256
llvm.x86.avx512.mask.padds.b.512
llvm.x86.avx512.mask.padds.w.128
llvm.x86.avx512.mask.padds.w.256
llvm.x86.avx512.mask.padds.w.512
llvm.x86.avx512.mask.paddus.b.128
llvm.x86.avx512.mask.paddus.b.256
llvm.x86.avx512.mask.paddus.b.512
llvm.x86.avx512.mask.paddus.w.128
llvm.x86.avx512.mask.paddus.w.256
llvm.x86.avx512.mask.paddus.w.512
llvm.x86.avx512.mask.pmov.db.128
llvm.x86.avx512.mask.pmov.db.256
llvm.x86.avx512.mask.pmov.db.512
llvm.x86.avx512.mask.pmov.db.mem.128
llvm.x86.avx512.mask.pmov.db.mem.256
llvm.x86.avx512.mask.pmov.db.mem.512
llvm.x86.avx512.mask.pmov.dw.128
llvm.x86.avx512.mask.pmov.dw.256
llvm.x86.avx512.mask.pmov.dw.512
llvm.x86.avx512.mask.pmov.dw.mem.128
llvm.x86.avx512.mask.pmov.dw.mem.256
llvm.x86.avx512.mask.pmov.dw.mem.512
llvm.x86.avx512.mask.pmov.qb.128
llvm.x86.avx512.mask.pmov.qb.256
llvm.x86.avx512.mask.pmov.qb.512
llvm.x86.avx512.mask.pmov.qb.mem.128
llvm.x86.avx512.mask.pmov.qb.mem.256
llvm.x86.avx512.mask.pmov.qb.mem.512
llvm.x86.avx512.mask.pmov.qd.128
llvm.x86.avx512.mask.pmov.qd.256
llvm.x86.avx512.mask.pmov.qd.512
llvm.x86.avx512.mask.pmov.qd.mem.128
llvm.x86.avx512.mask.pmov.qd.mem.256
llvm.x86.avx512.mask.pmov.qd.mem.512
llvm.x86.avx512.mask.pmov.qw.128
llvm.x86.avx512.mask.pmov.qw.256
llvm.x86.avx512.mask.pmov.qw.512
llvm.x86.avx512.mask.pmov.qw.mem.128
llvm.x86.avx512.mask.pmov.qw.mem.256
llvm.x86.avx512.mask.pmov.qw.mem.512
llvm.x86.avx512.mask.pmov.wb.128
llvm.x86.avx512.mask.pmov.wb.256
llvm.x86.avx512.mask.pmov.wb.512
llvm.x86.avx512.mask.pmov.wb.mem.128
llvm.x86.avx512.mask.pmov.wb.mem.256
llvm.x86.avx512.mask.pmov.wb.mem.512
llvm.x86.avx512.mask.pmovs.db.128
llvm.x86.avx512.mask.pmovs.db.256
llvm.x86.avx512.mask.pmovs.db.512
llvm.x86.avx512.mask.pmovs.db.mem.128
llvm.x86.avx512.mask.pmovs.db.mem.256
llvm.x86.avx512.mask.pmovs.db.mem.512
llvm.x86.avx512.mask.pmovs.dw.128
llvm.x86.avx512.mask.pmovs.dw.256
llvm.x86.avx512.mask.pmovs.dw.512
llvm.x86.avx512.mask.pmovs.dw.mem.128
llvm.x86.avx512.mask.pmovs.dw.mem.256
llvm.x86.avx512.mask.pmovs.dw.mem.512
llvm.x86.avx512.mask.pmovs.qb.128
llvm.x86.avx512.mask.pmovs.qb.256
llvm.x86.avx512.mask.pmovs.qb.512
llvm.x86.avx512.mask.pmovs.qb.mem.128
llvm.x86.avx512.mask.pmovs.qb.mem.256
llvm.x86.avx512.mask.pmovs.qb.mem.512
llvm.x86.avx512.mask.pmovs.qd.128
llvm.x86.avx512.mask.pmovs.qd.256
llvm.x86.avx512.mask.pmovs.qd.512
llvm.x86.avx512.mask.pmovs.qd.mem.128
llvm.x86.avx512.mask.pmovs.qd.mem.256
llvm.x86.avx512.mask.pmovs.qd.mem.512
llvm.x86.avx512.mask.pmovs.qw.128
llvm.x86.avx512.mask.pmovs.qw.256
llvm.x86.avx512.mask.pmovs.qw.512
llvm.x86.avx512.mask.pmovs.qw.mem.128
llvm.x86.avx512.mask.pmovs.qw.mem.256
llvm.x86.avx512.mask.pmovs.qw.mem.512
llvm.x86.avx512.mask.pmovs.wb.128
llvm.x86.avx512.mask.pmovs.wb.256
llvm.x86.avx512.mask.pmovs.wb.512
llvm.x86.avx512.mask.pmovs.wb.mem.128
llvm.x86.avx512.mask.pmovs.wb.mem.256
llvm.x86.avx512.mask.pmovs.wb.mem.512
llvm.x86.avx512.mask.pmovus.db.128
llvm.x86.avx512.mask.pmovus.db.256
llvm.x86.avx512.mask.pmovus.db.512
llvm.x86.avx512.mask.pmovus.db.mem.128
llvm.x86.avx512.mask.pmovus.db.mem.256
llvm.x86.avx512.mask.pmovus.db.mem.512
llvm.x86.avx512.mask.pmovus.dw.128
llvm.x86.avx512.mask.pmovus.dw.256
llvm.x86.avx512.mask.pmovus.dw.512
llvm.x86.avx512.mask.pmovus.dw.mem.128
llvm.x86.avx512.mask.pmovus.dw.mem.256
llvm.x86.avx512.mask.pmovus.dw.mem.512
llvm.x86.avx512.mask.pmovus.qb.128
llvm.x86.avx512.mask.pmovus.qb.256
llvm.x86.avx512.mask.pmovus.qb.512
llvm.x86.avx512.mask.pmovus.qb.mem.128
llvm.x86.avx512.mask.pmovus.qb.mem.256
llvm.x86.avx512.mask.pmovus.qb.mem.512
llvm.x86.avx512.mask.pmovus.qd.128
llvm.x86.avx512.mask.pmovus.qd.256
llvm.x86.avx512.mask.pmovus.qd.512
llvm.x86.avx512.mask.pmovus.qd.mem.128
llvm.x86.avx512.mask.pmovus.qd.mem.256
llvm.x86.avx512.mask.pmovus.qd.mem.512
llvm.x86.avx512.mask.pmovus.qw.128
llvm.x86.avx512.mask.pmovus.qw.256
llvm.x86.avx512.mask.pmovus.qw.512
llvm.x86.avx512.mask.pmovus.qw.mem.128
llvm.x86.avx512.mask.pmovus.qw.mem.256
llvm.x86.avx512.mask.pmovus.qw.mem.512
llvm.x86.avx512.mask.pmovus.wb.128
llvm.x86.avx512.mask.pmovus.wb.256
llvm.x86.avx512.mask.pmovus.wb.512
llvm.x86.avx512.mask.pmovus.wb.mem.128
llvm.x86.avx512.mask.pmovus.wb.mem.256
llvm.x86.avx512.mask.pmovus.wb.mem.512
llvm.x86.avx512.mask.pmultishift.qb.128
llvm.x86.avx512.mask.pmultishift.qb.256
llvm.x86.avx512.mask.pmultishift.qb.512
llvm.x86.avx512.mask.psubs.b.128
llvm.x86.avx512.mask.psubs.b.256
llvm.x86.avx512.mask.psubs.b.512
llvm.x86.avx512.mask.psubs.w.128
llvm.x86.avx512.mask.psubs.w.256
llvm.x86.avx512.mask.psubs.w.512
llvm.x86.avx512.mask.psubus.b.128
llvm.x86.avx512.mask.psubus.b.256
llvm.x86.avx512.mask.psubus.b.512
llvm.x86.avx512.mask.psubus.w.128
llvm.x86.avx512.mask.psubus.w.256
llvm.x86.avx512.mask.psubus.w.512
llvm.x86.avx512.mask.range.pd.128
llvm.x86.avx512.mask.range.pd.256
llvm.x86.avx512.mask.range.pd.512
llvm.x86.avx512.mask.range.ps.128
llvm.x86.avx512.mask.range.ps.256
llvm.x86.avx512.mask.range.ps.512
llvm.x86.avx512.mask.range.sd
llvm.x86.avx512.mask.range.ss
llvm.x86.avx512.mask.reduce.pd.128
llvm.x86.avx512.mask.reduce.pd.256
llvm.x86.avx512.mask.reduce.pd.512
llvm.x86.avx512.mask.reduce.ps.128
llvm.x86.avx512.mask.reduce.ps.256
llvm.x86.avx512.mask.reduce.ps.512
llvm.x86.avx512.mask.reduce.sd
llvm.x86.avx512.mask.reduce.ss
llvm.x86.avx512.mask.rndscale.pd.128
llvm.x86.avx512.mask.rndscale.pd.256
llvm.x86.avx512.mask.rndscale.pd.512
llvm.x86.avx512.mask.rndscale.ps.128
llvm.x86.avx512.mask.rndscale.ps.256
llvm.x86.avx512.mask.rndscale.ps.512
llvm.x86.avx512.mask.rndscale.sd
llvm.x86.avx512.mask.rndscale.ss
llvm.x86.avx512.mask.scalef.pd.128
llvm.x86.avx512.mask.scalef.pd.256
llvm.x86.avx512.mask.scalef.pd.512
llvm.x86.avx512.mask.scalef.ps.128
llvm.x86.avx512.mask.scalef.ps.256
llvm.x86.avx512.mask.scalef.ps.512
llvm.x86.avx512.mask.scalef.sd
llvm.x86.avx512.mask.scalef.ss
llvm.x86.avx512.mask.sqrt.sd
llvm.x86.avx512.mask.sqrt.ss
llvm.x86.avx512.mask.sub.sd.round
llvm.x86.avx512.mask.sub.ss.round
llvm.x86.avx512.mask.vcvtph2ps.128
llvm.x86.avx512.mask.vcvtph2ps.256
llvm.x86.avx512.mask.vcvtph2ps.512
llvm.x86.avx512.mask.vcvtps2ph.128
llvm.x86.avx512.mask.vcvtps2ph.256
llvm.x86.avx512.mask.vcvtps2ph.512
llvm.x86.avx512.mask.vpshldv.d.128
llvm.x86.avx512.mask.vpshldv.d.256
llvm.x86.avx512.mask.vpshldv.d.512
llvm.x86.avx512.mask.vpshldv.q.128
llvm.x86.avx512.mask.vpshldv.q.256
llvm.x86.avx512.mask.vpshldv.q.512
llvm.x86.avx512.mask.vpshldv.w.128
llvm.x86.avx512.mask.vpshldv.w.256
llvm.x86.avx512.mask.vpshldv.w.512
llvm.x86.avx512.mask.vpshrdv.d.128
llvm.x86.avx512.mask.vpshrdv.d.256
llvm.x86.avx512.mask.vpshrdv.d.512
llvm.x86.avx512.mask.vpshrdv.q.128
llvm.x86.avx512.mask.vpshrdv.q.256
llvm.x86.avx512.mask.vpshrdv.q.512
llvm.x86.avx512.mask.vpshrdv.w.128
llvm.x86.avx512.mask.vpshrdv.w.256
llvm.x86.avx512.mask.vpshrdv.w.512
llvm.x86.avx512.mask.vpshufbitqmb.128
llvm.x86.avx512.mask.vpshufbitqmb.256
llvm.x86.avx512.mask.vpshufbitqmb.512
llvm.x86.avx512.maskz.fixupimm.pd.128
llvm.x86.avx512.maskz.fixupimm.pd.256
llvm.x86.avx512.maskz.fixupimm.pd.512
llvm.x86.avx512.maskz.fixupimm.ps.128
llvm.x86.avx512.maskz.fixupimm.ps.256
llvm.x86.avx512.maskz.fixupimm.ps.512
llvm.x86.avx512.maskz.fixupimm.sd
llvm.x86.avx512.maskz.fixupimm.ss
llvm.x86.avx512.maskz.vpshldv.d.128
llvm.x86.avx512.maskz.vpshldv.d.256
llvm.x86.avx512.maskz.vpshldv.d.512
llvm.x86.avx512.maskz.vpshldv.q.128
llvm.x86.avx512.maskz.vpshldv.q.256
llvm.x86.avx512.maskz.vpshldv.q.512
llvm.x86.avx512.maskz.vpshldv.w.128
llvm.x86.avx512.maskz.vpshldv.w.256
llvm.x86.avx512.maskz.vpshldv.w.512
llvm.x86.avx512.maskz.vpshrdv.d.128
llvm.x86.avx512.maskz.vpshrdv.d.256
llvm.x86.avx512.maskz.vpshrdv.d.512
llvm.x86.avx512.maskz.vpshrdv.q.128
llvm.x86.avx512.maskz.vpshrdv.q.256
llvm.x86.avx512.maskz.vpshrdv.q.512
llvm.x86.avx512.maskz.vpshrdv.w.128
llvm.x86.avx512.maskz.vpshrdv.w.256
llvm.x86.avx512.maskz.vpshrdv.w.512
llvm.x86.avx512.max.pd.512
llvm.x86.avx512.max.ps.512
llvm.x86.avx512.min.pd.512
llvm.x86.avx512.min.ps.512
llvm.x86.avx512.mul.pd.512
llvm.x86.avx512.mul.ps.512
llvm.x86.avx512.packssdw.512
llvm.x86.avx512.packsswb.512
llvm.x86.avx512.packusdw.512
llvm.x86.avx512.packuswb.512
llvm.x86.avx512.permvar.df.256
llvm.x86.avx512.permvar.df.512
llvm.x86.avx512.permvar.di.256
llvm.x86.avx512.permvar.di.512
llvm.x86.avx512.permvar.hi.128
llvm.x86.avx512.permvar.hi.256
llvm.x86.avx512.permvar.hi.512
llvm.x86.avx512.permvar.qi.128
llvm.x86.avx512.permvar.qi.256
llvm.x86.avx512.permvar.qi.512
llvm.x86.avx512.permvar.sf.512
llvm.x86.avx512.permvar.si.512
llvm.x86.avx512.pmaddubs.w.512
llvm.x86.avx512.pmaddw.d.512
llvm.x86.avx512.pmul.hr.sw.512
llvm.x86.avx512.pmulh.w.512
llvm.x86.avx512.pmulhu.w.512
llvm.x86.avx512.prol.d.128
llvm.x86.avx512.prol.d.256
llvm.x86.avx512.prol.d.512
llvm.x86.avx512.prol.q.128
llvm.x86.avx512.prol.q.256
llvm.x86.avx512.prol.q.512
llvm.x86.avx512.prolv.d.128
llvm.x86.avx512.prolv.d.256
llvm.x86.avx512.prolv.d.512
llvm.x86.avx512.prolv.q.128
llvm.x86.avx512.prolv.q.256
llvm.x86.avx512.prolv.q.512
llvm.x86.avx512.pror.d.128
llvm.x86.avx512.pror.d.256
llvm.x86.avx512.pror.d.512
llvm.x86.avx512.pror.q.128
llvm.x86.avx512.pror.q.256
llvm.x86.avx512.pror.q.512
llvm.x86.avx512.prorv.d.128
llvm.x86.avx512.prorv.d.256
llvm.x86.avx512.prorv.d.512
llvm.x86.avx512.prorv.q.128
llvm.x86.avx512.prorv.q.256
llvm.x86.avx512.prorv.q.512
llvm.x86.avx512.psad.bw.512
llvm.x86.avx512.pshuf.b.512
llvm.x86.avx512.psll.d.512
llvm.x86.avx512.psll.q.512
llvm.x86.avx512.psll.w.512
llvm.x86.avx512.pslli.d.512
llvm.x86.avx512.pslli.q.512
llvm.x86.avx512.pslli.w.512
llvm.x86.avx512.psllv.d.512
llvm.x86.avx512.psllv.q.512
llvm.x86.avx512.psllv.w.128
llvm.x86.avx512.psllv.w.256
llvm.x86.avx512.psllv.w.512
llvm.x86.avx512.psra.d.512
llvm.x86.avx512.psra.q.128
llvm.x86.avx512.psra.q.256
llvm.x86.avx512.psra.q.512
llvm.x86.avx512.psra.w.512
llvm.x86.avx512.psrai.d.512
llvm.x86.avx512.psrai.q.128
llvm.x86.avx512.psrai.q.256
llvm.x86.avx512.psrai.q.512
llvm.x86.avx512.psrai.w.512
llvm.x86.avx512.psrav.d.512
llvm.x86.avx512.psrav.q.128
llvm.x86.avx512.psrav.q.256
llvm.x86.avx512.psrav.q.512
llvm.x86.avx512.psrav.w.128
llvm.x86.avx512.psrav.w.256
llvm.x86.avx512.psrav.w.512
llvm.x86.avx512.psrl.d.512
llvm.x86.avx512.psrl.q.512
llvm.x86.avx512.psrl.w.512
llvm.x86.avx512.psrli.d.512
llvm.x86.avx512.psrli.q.512
llvm.x86.avx512.psrli.w.512
llvm.x86.avx512.psrlv.d.512
llvm.x86.avx512.psrlv.q.512
llvm.x86.avx512.psrlv.w.128
llvm.x86.avx512.psrlv.w.256
llvm.x86.avx512.psrlv.w.512
llvm.x86.avx512.pternlog.d.128
llvm.x86.avx512.pternlog.d.256
llvm.x86.avx512.pternlog.d.512
llvm.x86.avx512.pternlog.q.128
llvm.x86.avx512.pternlog.q.256
llvm.x86.avx512.pternlog.q.512
llvm.x86.avx512.rcp14.pd.128
llvm.x86.avx512.rcp14.pd.256
llvm.x86.avx512.rcp14.pd.512
llvm.x86.avx512.rcp14.ps.128
llvm.x86.avx512.rcp14.ps.256
llvm.x86.avx512.rcp14.ps.512
llvm.x86.avx512.rcp14.sd
llvm.x86.avx512.rcp14.ss
llvm.x86.avx512.rcp28.pd
llvm.x86.avx512.rcp28.ps
llvm.x86.avx512.rcp28.sd
llvm.x86.avx512.rcp28.ss
llvm.x86.avx512.rsqrt14.pd.128
llvm.x86.avx512.rsqrt14.pd.256
llvm.x86.avx512.rsqrt14.pd.512
llvm.x86.avx512.rsqrt14.ps.128
llvm.x86.avx512.rsqrt14.ps.256
llvm.x86.avx512.rsqrt14.ps.512
llvm.x86.avx512.rsqrt14.sd
llvm.x86.avx512.rsqrt14.ss
llvm.x86.avx512.rsqrt28.pd
llvm.x86.avx512.rsqrt28.ps
llvm.x86.avx512.rsqrt28.sd
llvm.x86.avx512.rsqrt28.ss
llvm.x86.avx512.scatter.dpd.512
llvm.x86.avx512.scatter.dpi.512
llvm.x86.avx512.scatter.dpq.512
llvm.x86.avx512.scatter.dps.512
llvm.x86.avx512.scatter.qpd.512
llvm.x86.avx512.scatter.qpi.512
llvm.x86.avx512.scatter.qpq.512
llvm.x86.avx512.scatter.qps.512
llvm.x86.avx512.scatterdiv2.df
llvm.x86.avx512.scatterdiv2.di
llvm.x86.avx512.scatterdiv4.df
llvm.x86.avx512.scatterdiv4.di
llvm.x86.avx512.scatterdiv4.sf
llvm.x86.avx512.scatterdiv4.si
llvm.x86.avx512.scatterdiv8.sf
llvm.x86.avx512.scatterdiv8.si
llvm.x86.avx512.scatterpf.dpd.512
llvm.x86.avx512.scatterpf.dps.512
llvm.x86.avx512.scatterpf.qpd.512
llvm.x86.avx512.scatterpf.qps.512
llvm.x86.avx512.scattersiv2.df
llvm.x86.avx512.scattersiv2.di
llvm.x86.avx512.scattersiv4.df
llvm.x86.avx512.scattersiv4.di
llvm.x86.avx512.scattersiv4.sf
llvm.x86.avx512.scattersiv4.si
llvm.x86.avx512.scattersiv8.sf
llvm.x86.avx512.scattersiv8.si
llvm.x86.avx512.sqrt.pd.512
llvm.x86.avx512.sqrt.ps.512
llvm.x86.avx512.sub.pd.512
llvm.x86.avx512.sub.ps.512
llvm.x86.avx512.vcomi.sd
llvm.x86.avx512.vcomi.ss
llvm.x86.avx512.vcvtsd2si32
llvm.x86.avx512.vcvtsd2si64
llvm.x86.avx512.vcvtsd2usi32
llvm.x86.avx512.vcvtsd2usi64
llvm.x86.avx512.vcvtss2si32
llvm.x86.avx512.vcvtss2si64
llvm.x86.avx512.vcvtss2usi32
llvm.x86.avx512.vcvtss2usi64
llvm.x86.avx512.vfmadd.f32
llvm.x86.avx512.vfmadd.f64
llvm.x86.avx512.vfmadd.pd.512
llvm.x86.avx512.vfmadd.ps.512
llvm.x86.avx512.vfmaddsub.pd.512
llvm.x86.avx512.vfmaddsub.ps.512
llvm.x86.avx512.vpdpbusd.128
llvm.x86.avx512.vpdpbusd.256
llvm.x86.avx512.vpdpbusd.512
llvm.x86.avx512.vpdpbusds.128
llvm.x86.avx512.vpdpbusds.256
llvm.x86.avx512.vpdpbusds.512
llvm.x86.avx512.vpdpwssd.128
llvm.x86.avx512.vpdpwssd.256
llvm.x86.avx512.vpdpwssd.512
llvm.x86.avx512.vpdpwssds.128
llvm.x86.avx512.vpdpwssds.256
llvm.x86.avx512.vpdpwssds.512
llvm.x86.avx512.vpermi2var.d.128
llvm.x86.avx512.vpermi2var.d.256
llvm.x86.avx512.vpermi2var.d.512
llvm.x86.avx512.vpermi2var.hi.128
llvm.x86.avx512.vpermi2var.hi.256
llvm.x86.avx512.vpermi2var.hi.512
llvm.x86.avx512.vpermi2var.pd.128
llvm.x86.avx512.vpermi2var.pd.256
llvm.x86.avx512.vpermi2var.pd.512
llvm.x86.avx512.vpermi2var.ps.128
llvm.x86.avx512.vpermi2var.ps.256
llvm.x86.avx512.vpermi2var.ps.512
llvm.x86.avx512.vpermi2var.q.128
llvm.x86.avx512.vpermi2var.q.256
llvm.x86.avx512.vpermi2var.q.512
llvm.x86.avx512.vpermi2var.qi.128
llvm.x86.avx512.vpermi2var.qi.256
llvm.x86.avx512.vpermi2var.qi.512
llvm.x86.avx512.vpermilvar.pd.512
llvm.x86.avx512.vpermilvar.ps.512
llvm.x86.avx512.vpmadd52h.uq.128
llvm.x86.avx512.vpmadd52h.uq.256
llvm.x86.avx512.vpmadd52h.uq.512
llvm.x86.avx512.vpmadd52l.uq.128
llvm.x86.avx512.vpmadd52l.uq.256
llvm.x86.avx512.vpmadd52l.uq.512
llvm.x86.avx512.vpshld.d.128
llvm.x86.avx512.vpshld.d.256
llvm.x86.avx512.vpshld.d.512
llvm.x86.avx512.vpshld.q.128
llvm.x86.avx512.vpshld.q.256
llvm.x86.avx512.vpshld.q.512
llvm.x86.avx512.vpshld.w.128
llvm.x86.avx512.vpshld.w.256
llvm.x86.avx512.vpshld.w.512
llvm.x86.avx512.vpshrd.d.128
llvm.x86.avx512.vpshrd.d.256
llvm.x86.avx512.vpshrd.d.512
llvm.x86.avx512.vpshrd.q.128
llvm.x86.avx512.vpshrd.q.256
llvm.x86.avx512.vpshrd.q.512
llvm.x86.avx512.vpshrd.w.128
llvm.x86.avx512.vpshrd.w.256
llvm.x86.avx512.vpshrd.w.512
llvm.x86.bmi.bextr.32
llvm.x86.bmi.bextr.64
llvm.x86.bmi.bzhi.32
llvm.x86.bmi.bzhi.64
llvm.x86.bmi.pdep.32
llvm.x86.bmi.pdep.64
llvm.x86.bmi.pext.32
llvm.x86.bmi.pext.64
llvm.x86.cldemote
llvm.x86.clflushopt
llvm.x86.clrssbsy
llvm.x86.clwb
llvm.x86.clzero
llvm.x86.directstore32
llvm.x86.directstore64
llvm.x86.flags.read.u32
llvm.x86.flags.read.u64
llvm.x86.flags.write.u32
llvm.x86.flags.write.u64
llvm.x86.fxrstor
llvm.x86.fxrstor64
llvm.x86.fxsave
llvm.x86.fxsave64
llvm.x86.incsspd
llvm.x86.incsspq
llvm.x86.int
llvm.x86.invpcid
llvm.x86.llwpcb
llvm.x86.lwpins32
llvm.x86.lwpins64
llvm.x86.lwpval32
llvm.x86.lwpval64
llvm.x86.mmx.emms
llvm.x86.mmx.femms
llvm.x86.mmx.maskmovq
llvm.x86.mmx.movnt.dq
llvm.x86.mmx.packssdw
llvm.x86.mmx.packsswb
llvm.x86.mmx.packuswb
llvm.x86.mmx.padd.b
llvm.x86.mmx.padd.d
llvm.x86.mmx.padd.q
llvm.x86.mmx.padd.w
llvm.x86.mmx.padds.b
llvm.x86.mmx.padds.w
llvm.x86.mmx.paddus.b
llvm.x86.mmx.paddus.w
llvm.x86.mmx.palignr.b
llvm.x86.mmx.pand
llvm.x86.mmx.pandn
llvm.x86.mmx.pavg.b
llvm.x86.mmx.pavg.w
llvm.x86.mmx.pcmpeq.b
llvm.x86.mmx.pcmpeq.d
llvm.x86.mmx.pcmpeq.w
llvm.x86.mmx.pcmpgt.b
llvm.x86.mmx.pcmpgt.d
llvm.x86.mmx.pcmpgt.w
llvm.x86.mmx.pextr.w
llvm.x86.mmx.pinsr.w
llvm.x86.mmx.pmadd.wd
llvm.x86.mmx.pmaxs.w
llvm.x86.mmx.pmaxu.b
llvm.x86.mmx.pmins.w
llvm.x86.mmx.pminu.b
llvm.x86.mmx.pmovmskb
llvm.x86.mmx.pmulh.w
llvm.x86.mmx.pmulhu.w
llvm.x86.mmx.pmull.w
llvm.x86.mmx.pmulu.dq
llvm.x86.mmx.por
llvm.x86.mmx.psad.bw
llvm.x86.mmx.psll.d
llvm.x86.mmx.psll.q
llvm.x86.mmx.psll.w
llvm.x86.mmx.pslli.d
llvm.x86.mmx.pslli.q
llvm.x86.mmx.pslli.w
llvm.x86.mmx.psra.d
llvm.x86.mmx.psra.w
llvm.x86.mmx.psrai.d
llvm.x86.mmx.psrai.w
llvm.x86.mmx.psrl.d
llvm.x86.mmx.psrl.q
llvm.x86.mmx.psrl.w
llvm.x86.mmx.psrli.d
llvm.x86.mmx.psrli.q
llvm.x86.mmx.psrli.w
llvm.x86.mmx.psub.b
llvm.x86.mmx.psub.d
llvm.x86.mmx.psub.q
llvm.x86.mmx.psub.w
llvm.x86.mmx.psubs.b
llvm.x86.mmx.psubs.w
llvm.x86.mmx.psubus.b
llvm.x86.mmx.psubus.w
llvm.x86.mmx.punpckhbw
llvm.x86.mmx.punpckhdq
llvm.x86.mmx.punpckhwd
llvm.x86.mmx.punpcklbw
llvm.x86.mmx.punpckldq
llvm.x86.mmx.punpcklwd
llvm.x86.mmx.pxor
llvm.x86.monitorx
llvm.x86.movdir64b
llvm.x86.mwaitx
llvm.x86.pclmulqdq
llvm.x86.pclmulqdq.256
llvm.x86.pclmulqdq.512
llvm.x86.ptwrite32
llvm.x86.ptwrite64
llvm.x86.rdfsbase.32
llvm.x86.rdfsbase.64
llvm.x86.rdgsbase.32
llvm.x86.rdgsbase.64
llvm.x86.rdpid
llvm.x86.rdpkru
llvm.x86.rdpmc
llvm.x86.rdrand.16
llvm.x86.rdrand.32
llvm.x86.rdrand.64
llvm.x86.rdseed.16
llvm.x86.rdseed.32
llvm.x86.rdseed.64
llvm.x86.rdsspd
llvm.x86.rdsspq
llvm.x86.rdtsc
llvm.x86.rdtscp
llvm.x86.rstorssp
llvm.x86.saveprevssp
llvm.x86.seh.ehguard
llvm.x86.seh.ehregnode
llvm.x86.seh.lsda
llvm.x86.seh.recoverfp
llvm.x86.setssbsy
llvm.x86.sha1msg1
llvm.x86.sha1msg2
llvm.x86.sha1nexte
llvm.x86.sha1rnds4
llvm.x86.sha256msg1
llvm.x86.sha256msg2
llvm.x86.sha256rnds2
llvm.x86.slwpcb
llvm.x86.sse.cmp.ps
llvm.x86.sse.cmp.ss
llvm.x86.sse.comieq.ss
llvm.x86.sse.comige.ss
llvm.x86.sse.comigt.ss
llvm.x86.sse.comile.ss
llvm.x86.sse.comilt.ss
llvm.x86.sse.comineq.ss
llvm.x86.sse.cvtpd2pi
llvm.x86.sse.cvtpi2pd
llvm.x86.sse.cvtpi2ps
llvm.x86.sse.cvtps2pi
llvm.x86.sse.cvtss2si
llvm.x86.sse.cvtss2si64
llvm.x86.sse.cvttpd2pi
llvm.x86.sse.cvttps2pi
llvm.x86.sse.cvttss2si
llvm.x86.sse.cvttss2si64
llvm.x86.sse.ldmxcsr
llvm.x86.sse.max.ps
llvm.x86.sse.max.ss
llvm.x86.sse.min.ps
llvm.x86.sse.min.ss
llvm.x86.sse.movmsk.ps
llvm.x86.sse.pshuf.w
llvm.x86.sse.rcp.ps
llvm.x86.sse.rcp.ss
llvm.x86.sse.rsqrt.ps
llvm.x86.sse.rsqrt.ss
llvm.x86.sse.sfence
llvm.x86.sse.stmxcsr
llvm.x86.sse.ucomieq.ss
llvm.x86.sse.ucomige.ss
llvm.x86.sse.ucomigt.ss
llvm.x86.sse.ucomile.ss
llvm.x86.sse.ucomilt.ss
llvm.x86.sse.ucomineq.ss
llvm.x86.sse2.clflush
llvm.x86.sse2.cmp.pd
llvm.x86.sse2.cmp.sd
llvm.x86.sse2.comieq.sd
llvm.x86.sse2.comige.sd
llvm.x86.sse2.comigt.sd
llvm.x86.sse2.comile.sd
llvm.x86.sse2.comilt.sd
llvm.x86.sse2.comineq.sd
llvm.x86.sse2.cvtpd2dq
llvm.x86.sse2.cvtpd2ps
llvm.x86.sse2.cvtps2dq
llvm.x86.sse2.cvtsd2si
llvm.x86.sse2.cvtsd2si64
llvm.x86.sse2.cvtsd2ss
llvm.x86.sse2.cvttpd2dq
llvm.x86.sse2.cvttps2dq
llvm.x86.sse2.cvttsd2si
llvm.x86.sse2.cvttsd2si64
llvm.x86.sse2.lfence
llvm.x86.sse2.maskmov.dqu
llvm.x86.sse2.max.pd
llvm.x86.sse2.max.sd
llvm.x86.sse2.mfence
llvm.x86.sse2.min.pd
llvm.x86.sse2.min.sd
llvm.x86.sse2.movmsk.pd
llvm.x86.sse2.packssdw.128
llvm.x86.sse2.packsswb.128
llvm.x86.sse2.packuswb.128
llvm.x86.sse2.padds.b
llvm.x86.sse2.padds.w
llvm.x86.sse2.paddus.b
llvm.x86.sse2.paddus.w
llvm.x86.sse2.pause
llvm.x86.sse2.pmadd.wd
llvm.x86.sse2.pmovmskb.128
llvm.x86.sse2.pmulh.w
llvm.x86.sse2.pmulhu.w
llvm.x86.sse2.psad.bw
llvm.x86.sse2.psll.d
llvm.x86.sse2.psll.q
llvm.x86.sse2.psll.w
llvm.x86.sse2.pslli.d
llvm.x86.sse2.pslli.q
llvm.x86.sse2.pslli.w
llvm.x86.sse2.psra.d
llvm.x86.sse2.psra.w
llvm.x86.sse2.psrai.d
llvm.x86.sse2.psrai.w
llvm.x86.sse2.psrl.d
llvm.x86.sse2.psrl.q
llvm.x86.sse2.psrl.w
llvm.x86.sse2.psrli.d
llvm.x86.sse2.psrli.q
llvm.x86.sse2.psrli.w
llvm.x86.sse2.psubs.b
llvm.x86.sse2.psubs.w
llvm.x86.sse2.psubus.b
llvm.x86.sse2.psubus.w
llvm.x86.sse2.ucomieq.sd
llvm.x86.sse2.ucomige.sd
llvm.x86.sse2.ucomigt.sd
llvm.x86.sse2.ucomile.sd
llvm.x86.sse2.ucomilt.sd
llvm.x86.sse2.ucomineq.sd
llvm.x86.sse3.addsub.pd
llvm.x86.sse3.addsub.ps
llvm.x86.sse3.hadd.pd
llvm.x86.sse3.hadd.ps
llvm.x86.sse3.hsub.pd
llvm.x86.sse3.hsub.ps
llvm.x86.sse3.ldu.dq
llvm.x86.sse3.monitor
llvm.x86.sse3.mwait
llvm.x86.sse41.blendvpd
llvm.x86.sse41.blendvps
llvm.x86.sse41.dppd
llvm.x86.sse41.dpps
llvm.x86.sse41.insertps
llvm.x86.sse41.mpsadbw
llvm.x86.sse41.packusdw
llvm.x86.sse41.pblendvb
llvm.x86.sse41.phminposuw
llvm.x86.sse41.ptestc
llvm.x86.sse41.ptestnzc
llvm.x86.sse41.ptestz
llvm.x86.sse41.round.pd
llvm.x86.sse41.round.ps
llvm.x86.sse41.round.sd
llvm.x86.sse41.round.ss
llvm.x86.sse42.crc32.32.16
llvm.x86.sse42.crc32.32.32
llvm.x86.sse42.crc32.32.8
llvm.x86.sse42.crc32.64.64
llvm.x86.sse42.pcmpestri128
llvm.x86.sse42.pcmpestria128
llvm.x86.sse42.pcmpestric128
llvm.x86.sse42.pcmpestrio128
llvm.x86.sse42.pcmpestris128
llvm.x86.sse42.pcmpestriz128
llvm.x86.sse42.pcmpestrm128
llvm.x86.sse42.pcmpistri128
llvm.x86.sse42.pcmpistria128
llvm.x86.sse42.pcmpistric128
llvm.x86.sse42.pcmpistrio128
llvm.x86.sse42.pcmpistris128
llvm.x86.sse42.pcmpistriz128
llvm.x86.sse42.pcmpistrm128
llvm.x86.sse4a.extrq
llvm.x86.sse4a.extrqi
llvm.x86.sse4a.insertq
llvm.x86.sse4a.insertqi
llvm.x86.ssse3.pabs.b
llvm.x86.ssse3.pabs.d
llvm.x86.ssse3.pabs.w
llvm.x86.ssse3.phadd.d
llvm.x86.ssse3.phadd.d.128
llvm.x86.ssse3.phadd.sw
llvm.x86.ssse3.phadd.sw.128
llvm.x86.ssse3.phadd.w
llvm.x86.ssse3.phadd.w.128
llvm.x86.ssse3.phsub.d
llvm.x86.ssse3.phsub.d.128
llvm.x86.ssse3.phsub.sw
llvm.x86.ssse3.phsub.sw.128
llvm.x86.ssse3.phsub.w
llvm.x86.ssse3.phsub.w.128
llvm.x86.ssse3.pmadd.ub.sw
llvm.x86.ssse3.pmadd.ub.sw.128
llvm.x86.ssse3.pmul.hr.sw
llvm.x86.ssse3.pmul.hr.sw.128
llvm.x86.ssse3.pshuf.b
llvm.x86.ssse3.pshuf.b.128
llvm.x86.ssse3.psign.b
llvm.x86.ssse3.psign.b.128
llvm.x86.ssse3.psign.d
llvm.x86.ssse3.psign.d.128
llvm.x86.ssse3.psign.w
llvm.x86.ssse3.psign.w.128
llvm.x86.subborrow.u32
llvm.x86.subborrow.u64
llvm.x86.tbm.bextri.u32
llvm.x86.tbm.bextri.u64
llvm.x86.tpause
llvm.x86.umonitor
llvm.x86.umwait
llvm.x86.vcvtph2ps.128
llvm.x86.vcvtph2ps.256
llvm.x86.vcvtps2ph.128
llvm.x86.vcvtps2ph.256
llvm.x86.vgf2p8affineinvqb.128
llvm.x86.vgf2p8affineinvqb.256
llvm.x86.vgf2p8affineinvqb.512
llvm.x86.vgf2p8affineqb.128
llvm.x86.vgf2p8affineqb.256
llvm.x86.vgf2p8affineqb.512
llvm.x86.vgf2p8mulb.128
llvm.x86.vgf2p8mulb.256
llvm.x86.vgf2p8mulb.512
llvm.x86.wbinvd
llvm.x86.wbnoinvd
llvm.x86.wrfsbase.32
llvm.x86.wrfsbase.64
llvm.x86.wrgsbase.32
llvm.x86.wrgsbase.64
llvm.x86.wrpkru
llvm.x86.wrssd
llvm.x86.wrssq
llvm.x86.wrussd
llvm.x86.wrussq
llvm.x86.xabort
llvm.x86.xbegin
llvm.x86.xend
llvm.x86.xgetbv
llvm.x86.xop.vfrcz.pd
llvm.x86.xop.vfrcz.pd.256
llvm.x86.xop.vfrcz.ps
llvm.x86.xop.vfrcz.ps.256
llvm.x86.xop.vfrcz.sd
llvm.x86.xop.vfrcz.ss
llvm.x86.xop.vpcomb
llvm.x86.xop.vpcomd
llvm.x86.xop.vpcomq
llvm.x86.xop.vpcomub
llvm.x86.xop.vpcomud
llvm.x86.xop.vpcomuq
llvm.x86.xop.vpcomuw
llvm.x86.xop.vpcomw
llvm.x86.xop.vpermil2pd
llvm.x86.xop.vpermil2pd.256
llvm.x86.xop.vpermil2ps
llvm.x86.xop.vpermil2ps.256
llvm.x86.xop.vphaddbd
llvm.x86.xop.vphaddbq
llvm.x86.xop.vphaddbw
llvm.x86.xop.vphadddq
llvm.x86.xop.vphaddubd
llvm.x86.xop.vphaddubq
llvm.x86.xop.vphaddubw
llvm.x86.xop.vphaddudq
llvm.x86.xop.vphadduwd
llvm.x86.xop.vphadduwq
llvm.x86.xop.vphaddwd
llvm.x86.xop.vphaddwq
llvm.x86.xop.vphsubbw
llvm.x86.xop.vphsubdq
llvm.x86.xop.vphsubwd
llvm.x86.xop.vpmacsdd
llvm.x86.xop.vpmacsdqh
llvm.x86.xop.vpmacsdql
llvm.x86.xop.vpmacssdd
llvm.x86.xop.vpmacssdqh
llvm.x86.xop.vpmacssdql
llvm.x86.xop.vpmacsswd
llvm.x86.xop.vpmacssww
llvm.x86.xop.vpmacswd
llvm.x86.xop.vpmacsww
llvm.x86.xop.vpmadcsswd
llvm.x86.xop.vpmadcswd
llvm.x86.xop.vpperm
llvm.x86.xop.vprotb
llvm.x86.xop.vprotbi
llvm.x86.xop.vprotd
llvm.x86.xop.vprotdi
llvm.x86.xop.vprotq
llvm.x86.xop.vprotqi
llvm.x86.xop.vprotw
llvm.x86.xop.vprotwi
llvm.x86.xop.vpshab
llvm.x86.xop.vpshad
llvm.x86.xop.vpshaq
llvm.x86.xop.vpshaw
llvm.x86.xop.vpshlb
llvm.x86.xop.vpshld
llvm.x86.xop.vpshlq
llvm.x86.xop.vpshlw
llvm.x86.xrstor
llvm.x86.xrstor64
llvm.x86.xrstors
llvm.x86.xrstors64
llvm.x86.xsave
llvm.x86.xsave64
llvm.x86.xsavec
llvm.x86.xsavec64
llvm.x86.xsaveopt
llvm.x86.xsaveopt64
llvm.x86.xsaves
llvm.x86.xsaves64
llvm.x86.xsetbv
llvm.x86.xtest
llvm.xcore.bitrev
llvm.xcore.checkevent
llvm.xcore.chkct
llvm.xcore.clre
llvm.xcore.clrpt
llvm.xcore.clrsr
llvm.xcore.crc32
llvm.xcore.crc8
llvm.xcore.edu
llvm.xcore.eeu
llvm.xcore.endin
llvm.xcore.freer
llvm.xcore.geted
llvm.xcore.getet
llvm.xcore.getid
llvm.xcore.getps
llvm.xcore.getr
llvm.xcore.getst
llvm.xcore.getts
llvm.xcore.in
llvm.xcore.inct
llvm.xcore.initcp
llvm.xcore.initdp
llvm.xcore.initlr
llvm.xcore.initpc
llvm.xcore.initsp
llvm.xcore.inshr
llvm.xcore.int
llvm.xcore.mjoin
llvm.xcore.msync
llvm.xcore.out
llvm.xcore.outct
llvm.xcore.outshr
llvm.xcore.outt
llvm.xcore.peek
llvm.xcore.setc
llvm.xcore.setclk
llvm.xcore.setd
llvm.xcore.setev
llvm.xcore.setps
llvm.xcore.setpsc
llvm.xcore.setpt
llvm.xcore.setrdy
llvm.xcore.setsr
llvm.xcore.settw
llvm.xcore.setv
llvm.xcore.sext
llvm.xcore.ssync
llvm.xcore.syncr
llvm.xcore.testct
llvm.xcore.testwct
llvm.xcore.waitevent
llvm.xcore.zext
<unknown>:
 (function: 
Print Module IR
Print Function IR
Print BasicBlock IR
switch
indirectbr
invoke
resume
unreachable
cleanupret
catchret
catchpad
catchswitch
fadd
fsub
fmul
udiv
sdiv
fdiv
urem
srem
frem
alloca
load
store
cmpxchg
atomicrmw
fence
getelementptr
trunc
zext
sext
fptrunc
fpext
fptoui
fptosi
uitofp
sitofp
inttoptr
ptrtoint
bitcast
addrspacecast
icmp
fcmp
select
call
lshr
ashr
va_arg
extractelement
insertelement
shufflevector
extractvalue
insertvalue
landingpad
cleanuppad
<Invalid operator> 
both values to select must have same type
select values cannot have token type
vector select condition element type must be i1
selected values for vector select must be vectors
vector select requires selected vectors to have the same vector length as select condition
select condition must be i1 or <n x i1>
unknown
false
true
mallocsize
malloccall
prof
fpmath
range
tbaa.struct
alias.scope
make.implicit
unpredictable
invariant.group
section_prefix
absolute_symbol
associated
irr_loop
gc-transition
singlethread
error
warning
remark
Allocation failed
debug-pass
Print PassManager debugging information
disable debug output
Arguments
print pass arguments to pass to 'opt'
Structure
print pass structure before run()
Executions
print pass name before it is executed
Details
print pass details when it is executed
print-before
Print IR before specified passes
print-after
Print IR after specified passes
print-before-all
Print IR before each pass
print-after-all
Print IR after each pass
print-module-scope
When printing IR for print-[before|after]{-all} always print a module IR
filter-print-funcs
function names
Only print IR for functions whose name match this for all print-[before|after][-all] options
size-info
IRSizeChange
: IR instruction count changed from 
IRInstrsBefore
IRInstrsAfter
; Delta: 
DeltaInstrCount
Releasing pass '
Running pass '
 on module '
basic block
Pass '
' is not initialized.
Verify if there is a pass dependency cycle.
Required Passes:
Error: Required pass not found! Possible causes:
- Pass misconfiguration (e.g.: missing macros)
- Corruption of the global PassRegistry
*** IR Dump Before 
 ***
*** IR Dump After 
Pass Arguments: 
 -- '
' is not preserving '
 -*- '
' is the last user of following pass instances.
 Free these instances
Executing Pass '
Made Modification '
 Freeing Pass '
' on BasicBlock '
'...
' on Function '
' on Module '
' on Region '
' on Loop '
' on Call Graph Nodes '
Required
Preserved
Used
 Analyses:
 Uninitialized Pass
FunctionPass Manager
time-passes
Time each pass, printing elapsed time for each on exit
Module Pass Manager
ModulePass Manager
pass
... Pass execution timing report ...
BasicBlock Pass Manager
BasicBlockPass Manager
Function Pass Manager
branch_weights
synthetic_function_entry_count
function_entry_count
__unnamed_
 /EXPORT:
 -export:
,DATA
,data
llvm.module.flags
ProfileSummary
RtLibUseGOT
Allocation failed
SCC (
 node
External
 (has loop)
opt-bisect-limit
Maximum optimization to perform
module (
function (
basic block (
) in function (
<<null function>>
NOT 
BISECT: 
running pass 
Unnamed pass: implement Pass::getPassName()
Pass::print not implemented for pass: '
Two passes with the same argument (-
) attempted to be registered!
safepoint-ir-verifier-print-only
NumCounts
NumFunctions
Allocation failed
non-global-value-max-name-size
Maximum size for the name of non-global values.
Allocation failed
Base nodes must have at least two operands
Access tag nodes must have the number of operands that is a multiple of 3!
Struct tag nodes must have an odd number of operands!
Type size nodes must be constants!
Struct tag nodes have a string as their first operand
Incorrect field entry in struct type node!
Offset entries must be constants!
Bitwidth between the offsets and struct type entries must match
Offsets must be increasing!
Member size entries must be constants!
Could not find TBAA parent in struct type node
This instruction shall not have a TBAA access tag!
Old-style TBAA is no longer allowed, use struct-path TBAA instead
Access tag metadata must have either 4 or 5 operands
Struct tag metadata must have either 3 or 4 operands
Access size field must be a constant
Immutability tag on struct tag metadata must be a constant
Immutability part of the struct tag metadata must be either 0 or 1
Malformed struct tag metadata: base and access-type should be non-null and point to Metadata nodes
Access type node must be a valid scalar type
Offset must be constant integer
Cycle detected in struct path
Offset not zero at the point of scalar access
Access bit-width not the same as description bit-width
Did not see access type in access path!
Basic Block in function '
' does not have terminator!
Function context does not match Module context!
Functions may not have common linkage
# formal arguments must match # of arguments for function type!
Functions cannot return aggregate values!
Invalid struct return type!
Attribute after last parameter!
Attribute 'builtin' can only be applied to a callsite.
Calling convention requires void return type
Calling convention does not allow sret
Calling convention does not support varargs or perfect forwarding!
Argument value does not match function argument type!
Function arguments must have first-class types!
Function takes metadata but isn't an intrinsic
Function takes token but isn't an intrinsic
Functions returns a token but isn't an intrinsic
Referencing personality function in another module!
unmaterialized function cannot have metadata
function declaration may not have a !dbg attachment
function declaration may not have a !prof attachment
Function declaration shouldn't have a personality routine
llvm intrinsics cannot be defined!
Entry block to function must not have predecessors!
blockaddress may not be used with the entry block!
function must have a single !dbg attachment
function !dbg attachment must be a subprogram
DISubprogram attached to more than one function
function must have a single !prof attachment
Invalid user of intrinsic instruction!
!dbg attachment points at wrong subprogram for function
Global is external, but doesn't have external or weak linkage!
huge alignment values are unsupported
Only global variables can have appending linkage!
Only global arrays can have appending linkage!
Declaration may not be in a Comdat!
GlobalValue with DLLImport Storage is dso_local!
Global is marked as dllimport, but not external
GlobalValue with private or internal linkage must be dso_local!
GlobalValue with non default visibility must be dso_local!
Global is referenced by parentless instruction!
Global is referenced in a different module!
Global is used by function in a different module
Attributes 'byval', 'inalloca', 'nest', 'sret', 'nocapture', 'returned', 'swiftself', and 'swifterror' do not apply to return values!
Attribute '
' does not apply to function returns
More than one parameter has attribute nest!
More than one parameter has attribute returned!
Incompatible argument and return types for 'returned' attribute
Cannot have multiple 'sret' parameters!
Attribute 'sret' is not on first or second parameter!
Cannot have multiple 'swiftself' parameters!
Cannot have multiple 'swifterror' parameters!
inalloca isn't on the last parameter!
Attributes 'readnone and readonly' are incompatible!
Attributes 'readnone and writeonly' are incompatible!
Attributes 'readonly and writeonly' are incompatible!
Attributes 'readnone and inaccessiblemem_or_argmemonly' are incompatible!
Attributes 'readnone and inaccessiblememonly' are incompatible!
Attributes 'noinline and alwaysinline' are incompatible!
Attribute 'optnone' requires 'noinline'!
Attributes 'optsize and optnone' are incompatible!
Attributes 'minsize and optnone' are incompatible!
Attribute 'jumptable' requires 'unnamed_addr'
element size
number of elements
Attributes 'byval', 'inalloca', 'inreg', 'nest', and 'sret' are incompatible!
Attributes 'inalloca and readonly' are incompatible!
Attributes 'sret and returned' are incompatible!
Attributes 'zeroext and signext' are incompatible!
Wrong types for attribute: 
Attributes 'byval' and 'inalloca' do not support unsized types!
Attribute 'swifterror' only applies to parameters with pointer to pointer type!
Attribute 'byval' only applies to parameters with pointer type!
Attribute 'swifterror' only applies to parameters with pointer type!
' only applies to functions!
' does not apply to functions!
'allocsize' 
 argument is out of bounds
 argument must refer to an integer parameter
swifterror value can only be loaded and stored from, or as a swifterror argument!
swifterror value should be the second operand when used by stores
swifterror value when used in a callsite should be marked with swifterror attribute
!prof annotations should have no less than 2 operands
first operand should not be null
expected string with name of the !prof annotation
first operand should be 'function_entry_count' or 'synthetic_function_entry_count'
second operand should not be null
expected integer argument to function_entry_count
Invalid operand for global metadata!
Expected no forward declarations!
All nodes should be resolved!
location requires a valid scope
inlined-at should be a location
scope points into the type hierarchy
invalid expression
missing variable
fragment is larger than or outside of variable
fragment covers entire variable
invalid tag
Count must either be a signed constant or a DIVariable
invalid subrange count
invalid pointer to member type
invalid scope
invalid base type
DWARF address space only applies to pointer or reference types
invalid file
invalid composite elements
invalid vtable holder
invalid reference flags
invalid vector, expected one element of type subrange
class/union requires a filename
discriminator can only appear on variant part
invalid template params
invalid template parameter
invalid subroutine type ref
invalid checksum length
invalid checksum
compile units must be distinct
invalid filename
invalid enum list
invalid enum type
invalid retained type list
invalid retained type
invalid global variable list
invalid global variable ref
invalid imported entity list
invalid imported entity ref
invalid macro list
invalid macro ref
line specified with no file
invalid subroutine type
invalid containing type
invalid subprogram declaration
invalid retained nodes list
invalid retained nodes, expected DILocalVariable or DILabel
subprogram definitions must be distinct
subprogram definitions must have a compile unit
invalid unit type
subprogram declarations must not have a compile unit
invalid thrown types list
invalid thrown type
cannot have column info without line info
invalid local scope
invalid scope ref
anonymous module
invalid type ref
missing global variable name
missing global variable type
invalid static data member declaration
local variable requires a valid scope
label requires a valid scope
invalid scope for imported entity
invalid imported entity
invalid macinfo type
anonymous macro
Expected valid value
Unexpected metadata round-trip through values
function-local metadata used outside a function
function-local metadata not in basic block
function-local metadata used in wrong function
Basic Block does not have terminator!
PHI nodes must have at least one entry.  If the block is dead, the PHI should be removed!
PHINode should have one entry for each predecessor of its parent basic block!
PHI node has multiple entries for the same basic block with different incoming values!
PHI node entries do not match predecessors!
Instruction has bogus parent pointer!
Operand is null
Found return instr that returns non-void in Function of void return type!
Function return type does not match operand type of return inst!
Terminator found in the middle of a basic block!
Instruction not embedded in basic block!
Only PHI nodes may reference their own value!
Instruction has a name, but provides a void value!
Instruction returns a non-scalar type!
Invalid use of metadata!
Instruction referencing instruction not embedded in a basic block!
Use of instruction is not an instruction!
Instruction has null operand!
Instruction operands must be first-class values!
Cannot take the address of an intrinsic!
Cannot invoke an intrinsic other than donothing, patchpoint, statepoint, coro_resume or coro_destroy
Referencing function in another module!
Referring to a basic block in another function!
Referring to an argument in another function!
Referencing global in another module!
Cannot take the address of an inline asm!
fpmath requires a floating point result!
fpmath takes one operand!
fpmath accuracy must have float type
fpmath accuracy not a positive number!
invalid fpmath accuracy!
Ranges are only for loads, calls and invokes!
nonnull applies only to pointer types
nonnull applies only to load instructions, use attributes for calls or invokes
align applies only to pointer types
align applies only to load instructions, use attributes for calls or invokes
align takes one operand!
align metadata value must be an i64!
align metadata value must be a power of 2!
alignment is larger that implementation defined limit
invalid !dbg metadata attachment
Instruction does not dominate all uses!
Invalid bitcast
inttoptr not supported for non-integral pointers
ptrtoint not supported for non-integral pointers
Unfinished range!
It should have at least one range!
The lower limit must be an integer!
The upper limit must be an integer!
Range types must match instruction type!
Range must not be empty!
Intervals are overlapping
Intervals are not in order
Intervals are contiguous
dereferenceable, dereferenceable_or_null apply only to pointer types
dereferenceable, dereferenceable_or_null apply only to load instructions, use attributes for calls or invokes
dereferenceable, dereferenceable_or_null take one operand!
dereferenceable, dereferenceable_or_null metadata value must be an i64!
Branch condition is not 'i1' type!
Switch constants must all be same type as switch value!
Duplicate integer as switch case
Indirectbr operand must have pointer type!
Indirectbr destinations must all have pointer type!
The unwind destination does not have an exception handling instruction!
Called function must be a pointer!
Called function is not pointer to function type!
Called function is not the same type as the call!
Called function requires more parameters than were provided!
Incorrect number of arguments passed to called function!
Call parameter type does not match function signature!
speculatable attribute may not apply to call sites
inalloca argument for call has mismatched alloca
swifterror argument for call has mismatched alloca
swifterror argument should come from an alloca or parameter
swifterror argument for call has mismatched parameter
Attribute 'sret' cannot be used for vararg call arguments!
inalloca isn't on the last argument!
Function has metadata parameter but isn't an intrinsic
Function has token parameter but isn't an intrinsic
Return type cannot be token for indirect call!
Multiple deopt operand bundles
Multiple gc-transition operand bundles
Multiple funclet operand bundles
Expected exactly one funclet bundle operand
Funclet bundle operands should correspond to a FuncletPadInst
inlinable function call in a function with debug info must have a !dbg location
Intrinsic functions should never be defined!
Intrinsic has incorrect return type!
Intrinsic has incorrect argument type!
Intrinsic was not defined with variable arguments!
Callsite was not defined with variable arguments!
Intrinsic name not mangled correctly for type arguments! Should be: 
info argument of llvm.coro.begin must refer to an initialized constant
info argument of llvm.coro.begin must refer to either a struct or an array
is_zero_undef argument of bit counting intrinsics must be a constant int
invalid llvm.dbg.declare intrinsic call 1
addr
alignment of arg 0 of memory intrinsic must be 0 or a power of 2
alignment of arg 1 of memory intrinsic must be 0 or a power of 2
isvolatile argument of memory intrinsics must be a constant int
element size of the element-wise unordered atomic memory intrinsic must be a constant int
element size of the element-wise atomic memory intrinsic must be a power of 2
constant length must be a multiple of the element size in the element-wise atomic memory intrinsic
incorrect alignment of the destination argument
incorrect alignment of the source argument
llvm.gcroot parameter #1 must be an alloca.
llvm.gcroot parameter #2 must be a constant.
llvm.gcroot parameter #1 must either be a pointer alloca, or argument #2 must be a non-null constant.
Enclosing function does not use GC.
llvm.init_trampoline parameter #2 must resolve to a function.
invalid arguments to llvm.prefetch
llvm.stackprotector parameter #2 must resolve to an alloca.
size argument of memory use markers must be a constant integer
llvm.invariant.end parameter #2 must be a constant integer
llvm.localescape used outside of entry block
multiple calls to llvm.localescape in one function
llvm.localescape only accepts static allocas
llvm.localrecover first argument must be function defined in this module
idx argument of llvm.localrecover must be a constant int
gc.statepoint support for inline assembly unimplemented
gc.result operand #1 must be from a statepoint
gc.result result type does not match wrapped callee
wrong number of arguments
gc.relocate must return a pointer or a vector of pointers
safepoints should have unique landingpads
safepoint block should be well formed
gc relocate should be linked to a statepoint
gc relocate is incorrectly tied to the statepoint
gc.relocate operand #2 must be integer offset
gc.relocate operand #3 must be integer offset
gc.relocate: statepoint base index out of bounds
gc.relocate: statepoint derived index out of bounds
gc.statepoint: insufficient arguments
gc.statement: number of call arguments must be constant integer
gc.statepoint: mismatch in number of call arguments
gc.statepoint: number of transition arguments must be a constant integer
gc.statepoint: number of deoptimization arguments must be a constant integer
gc.relocate: statepoint base index doesn't fall within the 'gc parameters' section of the statepoint call
gc.relocate: statepoint derived index doesn't fall within the 'gc parameters' section of the statepoint call
gc.relocate: relocated value must be a gc pointer
gc.relocate: vector relocates to vector and pointer to pointer
gc.relocate: relocating a pointer shouldn't change its address space
eh.exceptionpointer argument must be a catchpad
masked_load: must return a vector
masked_load: mask must be vector
masked_load: return must match pointer type
masked_load: pass through and data type must match
masked_load: vector mask must be same length as data
masked_store: mask must be vector
masked_store: storee must match pointer type
masked_store: vector mask must be same length as data
experimental_guard cannot be invoked
experimental_guard must have exactly one "deopt" operand bundle
experimental_deoptimize cannot be invoked
experimental_deoptimize must have exactly one "deopt" operand bundle
experimental_deoptimize return type must match caller return type
calls to experimental_deoptimize must be followed by a return
calls to experimental_deoptimize must be followed by a return of the value computed by experimental_deoptimize
invalid arguments for constrained FP intrinsic
invalid exception behavior argument
invalid rounding mode argument
invalid llvm.dbg.
 intrinsic address/value
 intrinsic variable
 intrinsic expression
llvm.dbg.
 intrinsic requires a !dbg attachment
mismatched subprogram between llvm.dbg.
 variable and !dbg attachment
dbg intrinsic without variable
conflicting debug info for argument
 label and !dbg attachment
gc.statepoint must read and write all memory to preserve reordering restrictions required by safepoint semantics
gc.statepoint ID must be a constant integer
gc.statepoint number of patchable bytes must be a constant integer
gc.statepoint number of patchable bytes must be positive
gc.statepoint callee must be of function pointer type
gc.statepoint number of arguments to underlying call must be constant integer
gc.statepoint number of arguments to underlying call must be positive
gc.statepoint mismatch in number of vararg call args
gc.statepoint doesn't support wrapping non-void vararg functions yet
gc.statepoint mismatch in number of call args
gc.statepoint flags must be constant integer
unknown flag used in gc.statepoint flags argument
gc.statepoint call argument does not match wrapped function type
gc.statepoint number of transition arguments must be constant integer
gc.statepoint number of transition arguments must be positive
gc.statepoint number of deoptimization arguments must be constant integer
gc.statepoint number of deoptimization arguments must be positive
gc.statepoint too few arguments according to length fields
illegal use of statepoint token
gc.result or gc.relocate are the only value uses of a gc.statepoint
gc.result connected to wrong gc.statepoint
gc.relocate connected to wrong gc.statepoint
ResumeInst needs to be in a function with a personality.
The resume instruction should have a consistent result type inside a function.
CleanupReturnInst needs to be provided a CleanupPad
CleanupReturnInst must unwind to an EH block which is not a landingpad.
CatchReturnInst needs to be provided a CatchPad
CatchSwitchInst needs to be in a function with a personality.
CatchSwitchInst not the first non-PHI instruction in the block.
CatchSwitchInst has an invalid parent.
CatchSwitchInst must unwind to an EH block which is not a landingpad.
CatchSwitchInst cannot have empty handler list
CatchSwitchInst handlers must be catchpads
EH pad cannot be in entry block.
Block containing LandingPadInst must be jumped to only by the unwind edge of an invoke.
Block containg CatchPadInst must be jumped to only by its catchswitch.
Catchswitch cannot unwind to one of its catchpads
EH pad must be jumped to via an unwind edge
A cleanupret must exit its cleanup
EH pad cannot handle exceptions raised within it
A single unwind edge may only enter one EH pad
EH pad jumps through a cycle of pads
Both operands to a binary operator are not of the same type!
Integer arithmetic operators only work with integral types!
Integer arithmetic operators must have same type for operands and result!
Floating-point arithmetic operators only work with floating-point types!
Floating-point arithmetic operators must have same type for operands and result!
Logical operators only work with integral types!
Logical operators must have same type for operands and result!
Shifts only work with integral types!
Shift return type must be same as operands!
Allocation instruction pointer not in the stack address space!
Cannot allocate unsized type
Alloca array size must have integer type
Load operand must be a pointer.
loading unsized types is not allowed
Load cannot have Release ordering
Atomic load must specify explicit alignment
atomic load operand must have integer, pointer, or floating point type!
Non-atomic load cannot have SynchronizationScope specified
atomic memory access' size must be byte-sized
atomic memory access' operand must have a power-of-two size
Store operand must be a pointer.
Stored value type does not match pointer operand type!
storing unsized types is not allowed
Store cannot have Acquire ordering
Atomic store must specify explicit alignment
atomic store operand must have integer, pointer, or floating point type!
Non-atomic store cannot have SynchronizationScope specified
GEP base pointer is not a vector or a vector of pointers
GEP into unsized type!
GEP indexes must be integers
Invalid indices for GEP pointer type!
GEP is not of right type for indices!
Vector GEP result width doesn't match operand's
Invalid GEP index vector width
All GEP indices should be of integer type
fence instructions may only have acquire, release, acq_rel, or seq_cst ordering.
cmpxchg instructions must be atomic.
cmpxchg instructions cannot be unordered.
cmpxchg instructions failure argument shall be no stronger than the success argument
First cmpxchg operand must be a pointer.
cmpxchg operand must have integer or pointer type
Expected value type does not match pointer operand type!
atomicrmw instructions must be atomic.
atomicrmw instructions cannot be unordered.
First atomicrmw operand must be a pointer.
atomicrmw operand must have integer type!
Argument value type does not match pointer operand type!
Invalid binary operation!
Trunc only operates on integer
Trunc only produces integer
trunc source and destination must both be a vector or neither
DestTy too big for Trunc
ZExt only operates on integer
ZExt only produces an integer
zext source and destination must both be a vector or neither
Type too small for ZExt
SExt only operates on integer
SExt only produces an integer
sext source and destination must both be a vector or neither
Type too small for SExt
FPToUI source and dest must both be vector or scalar
FPToUI source must be FP or FP vector
FPToUI result must be integer or integer vector
FPToUI source and dest vector length mismatch
FPToSI source and dest must both be vector or scalar
FPToSI source must be FP or FP vector
FPToSI result must be integer or integer vector
FPToSI source and dest vector length mismatch
UIToFP source and dest must both be vector or scalar
UIToFP source must be integer or integer vector
UIToFP result must be FP or FP vector
UIToFP source and dest vector length mismatch
SIToFP source and dest must both be vector or scalar
SIToFP source must be integer or integer vector
SIToFP result must be FP or FP vector
SIToFP source and dest vector length mismatch
FPTrunc only operates on FP
FPTrunc only produces an FP
fptrunc source and destination must both be a vector or neither
DestTy too big for FPTrunc
FPExt only operates on FP
FPExt only produces an FP
fpext source and destination must both be a vector or neither
DestTy too small for FPExt
PtrToInt source must be pointer
PtrToInt result must be integral
PtrToInt type mismatch
PtrToInt Vector width mismatch
IntToPtr source must be an integral
IntToPtr result must be a pointer
IntToPtr type mismatch
IntToPtr Vector width mismatch
AddrSpaceCast source must be a pointer
AddrSpaceCast result must be a pointer
AddrSpaceCast must be between different address spaces
AddrSpaceCast vector pointer number of elements mismatch
CleanupPadInst needs to be in a function with a personality.
CleanupPadInst not the first non-PHI instruction in the block.
CleanupPadInst has an invalid parent.
FuncletPadInst must not be nested within itself
Bogus funclet pad use
Unwind edges out of a funclet pad must have the same unwind dest
Unwind edges out of a catch must have the same unwind dest as the parent catchswitch
CatchPadInst needs to be in a function with a personality.
CatchPadInst needs to be directly nested in a CatchSwitchInst.
CatchPadInst not the first non-PHI instruction in the block.
Both operands to ICmp instruction are not of the same type!
Invalid operand types for ICmp instruction
Invalid predicate in ICmp instruction!
Both operands to FCmp instruction are not of the same type!
Invalid operand types for FCmp instruction
Invalid predicate in FCmp instruction!
PHI nodes not grouped at top of basic block!
PHI nodes cannot have token type!
PHI node operands are not the same type as the result!
cannot use musttail call with inline asm
cannot guarantee tail call due to mismatched parameter counts
cannot guarantee tail call due to mismatched parameter types
cannot guarantee tail call due to mismatched varargs
cannot guarantee tail call due to mismatched return types
cannot guarantee tail call due to mismatched calling conv
cannot guarantee tail call due to mismatched ABI impacting function attributes
bitcast following musttail call must use the call
musttail call must precede a ret with an optional bitcast
musttail call result must be returned
Invalid operands for select instruction!
Select values must have same type as select instruction!
User-defined operators should not live outside of a pass!
Invalid extractelement operands!
Invalid insertelement operands!
Invalid shufflevector operands!
Invalid ExtractValueInst operands!
Invalid InsertValueInst operands!
LandingPadInst needs at least one clause or to be a cleanup.
The landingpad instruction should have a consistent result type inside a function.
LandingPadInst needs to be in a function with a personality.
LandingPadInst not the first non-PHI instruction in the block.
Catch operand does not have pointer type!
Filter operand is not an array of constants!
EH pads can't handle each other's exceptions
all indices passed to llvm.localrecover must be less than the number of arguments passed ot llvm.localescape in the parent function
Global variable initializer type does not match global variable type!
'common' global must have a zero initializer!
'common' global may not be marked constant!
'common' global may not be in a Comdat!
invalid linkage for intrinsic global variable
wrong type for intrinsic global variable
wrong initalizer for intrinsic global variable
invalid llvm.used member
members of llvm.used must be named
!dbg attachment of global variable must be a DIGlobalVariableExpression
Alias should have private, internal, linkonce, weak, linkonce_odr, weak_odr, or external linkage!
Aliasee cannot be NULL!
Alias and aliasee types should match!
Aliasee should be either GlobalValue or ConstantExpr
Alias must point to a definition
Aliases cannot form a cycle
Alias cannot point to an interposable alias
unrecognized named metadata node in the llvm.dbg namespace
invalid compile unit
comdat global value has private linkage
invalid requirement on flag, flag is not present in module
invalid requirement on flag, flag does not have the required value
incorrect number of operands in module flag
invalid behavior operand in module flag (expected constant integer)
invalid behavior operand in module flag (unexpected constant)
invalid ID operand in module flag (expected metadata string)
invalid value for 'max' module flag (expected constant integer)
invalid value for 'require' module flag (expected metadata pair)
invalid value for 'require' module flag (first value operand should be a string)
invalid value for 'append'-type module flag (expected a metadata node)
module flag identifiers must be unique (or of 'require' type)
wchar_size metadata requires constant integer argument
'Linker Options' named metadata no longer supported
expected a MDNode triple
expected an integer constant
expected a Function or null
llvm.ident
incorrect number of operands in llvm.ident metadata
invalid value for llvm.ident metadata entry operand(the operand should be a string)
DICompileUnit not listed in llvm.dbg.cu
All llvm.experimental.deoptimize declarations must have the same calling convention
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ
APInt(
0x%08x / 0x%08x = %.2f%%
%Y-%m-%d %H:%M:%S
%.9lu
General options
: for the -
 option: 
may only occur zero or one times!
must occur exactly one time!
>...
' is invalid value for boolean argument! Try 0 or 1
' value invalid for integer argument!
' value invalid for uint argument!
    =
 -   
    -
 (default: 
= *unknown option value*
*no default*
= *cannot print option value*
Generic Options
help-list
Display list of available options (-help-list-hidden for more)
help-list-hidden
Display list of all available options
Display available options (-help-hidden for more)
help-hidden
Display all available options
print-options
Print non-default options after command line parsing
print-all-options
Print all option values after command line parsing
version
Display the version of this program
: CommandLine Error: Option '
' registered more than once!
inconsistency in registered CommandLine options
Cannot specify more than one option with cl::ConsumeAfter!
error - this positional option will never be matched, because it does not Require a value, and a cl::ConsumeAfter option is active!
error - option can never match, because another positional argument will match an unbounded number of values, and this option does not require a value!
' is all messed up!
: Unknown command line argument '
'.  Try: '
 -help'
: Did you mean '-
This argument does not take a value.
Instead, it consumes any positional arguments until the next recognized option.
: Not enough positional command line arguments specified!
Must specify at least 
 positional argument
: See: 
 -help
: Too many positional arguments specified!
Can specify at most 
 positional arguments: See: 
must be specified at least once!
requires a value!
multi-valued option specified with ValueDisallowed modifier!
does not allow a value! '
' specified.
not enough values!
' value invalid for floating point argument!
  This option category has no options.
OVERVIEW: 
USAGE: 
 [subcommand]
 [options]
SUBCOMMAND '
SUBCOMMANDS:
  Type "
 <subcommand> -help" to get more help on a specific subcommand
OPTIONS:
LLVM (http://llvm.org/):
LLVM
 version 
7.0.0
Optimized build
(unknown)
  Default target: 
  Host CPU: 
number
string
debug-counter
Comma separated list of debug counter skip and count
DebugCounter Error: 
 does not have an = in it
 is not a number
 is not a registered counter
 does not end with -skip or -count
Counters and values:
Multiple errors:
Error
Multiple errors
Inconvertible error value. An error has occurred that could not be converted to a known std::error_code. Please file a bug.
LLVM ERROR: 
LLVM ERROR: out of memory
Allocation failed
view-background
Execute graph viewer in the background. Creates tmp file litter.
Error: 
Writing '
'... 
Trying 'open' program... 
xdg-open
Trying 'xdg-open' program... 
Graphviz
Running 'Graphviz' program... 
xdot|xdot.py
Running 'xdot.py' program... 
dot|fdp|neato|twopi|circo
-Tps
-Nfontname=Courier
-Gsize=7.5,10
Running '
' program... 
--spartan
dotty
Running 'dotty' program... 
Error: Couldn't find a usable graph viewer program:
  Tried '
Remember to erase graph file: 
neato
twopi
circo
LLT_invalid
rng-seed
seed
Seed for the random number generator
Allocation failed
SmallVector capacity overflow during allocation
Allocation failed
Included from 
error: 
warning: 
note: 
remark: 
Allocation failed
iwmmxt
xscale
invalid
arm64
thumb
aarch64
armv2
armv2a
armv3
armv3m
armv4
armv4t
armv5t
armv5te
armv5tej
5TEJ
armv6
armv6k
armv6t2
v6t2
armv6kz
v6kz
armv6-m
armv7-a
armv7ve
v7ve
armv7-r
armv7-m
armv7e-m
7E-M
v7em
armv8-a
armv8.1-a
8.1-A
v8.1a
armv8.2-a
8.2-A
v8.2a
armv8.3-a
8.3-A
v8.3a
armv8.4-a
8.4-A
v8.4a
armv8-r
armv8-m.base
8-M.Baseline
v8m.base
armv8-m.main
8-M.Mainline
v8m.main
iwmmxt2
armv7s
armv7k
v5te
v6-m
v7-a
v7-r
v7-m
v7e-m
v8-a
v8.1-a
v8.2-a
v8.3-a
v8.4-a
v8-r
v8-m.base
v8-m.main
track-memory
Enable -time-passes memory tracking (this may be slow)
info-output-file
File to append -stats and -timer output to
Error opening info-output-file '
 for appending!
%9lld  
  Total Execution Time: %5.4f seconds (%5.4f wall clock)
   ---User Time---
   --System Time--
   --User+System--
   ---Wall Time---
  ---Mem---
  --- Name ---
Total
misc
Miscellaneous Ungrouped Timers
        -----     
  %7.4f (%5.1f%%)
unknown
aarch64
aarch64_be
mips64
mips64el
powerpc64
riscv64
sparcv9
x86_64
nvptx64
le64
amdil64
hsail64
spir64
wasm64
renderscript64
ananas
cloudabi
darwin
dragonfly
freebsd
fuchsia
kfreebsd
linux
macosx
netbsd
openbsd
solaris
windows
haiku
minix
rtems
nacl
cuda
nvcl
amdhsa
elfiamcu
mesa3d
contiki
amdpal
gnuabin32
gnuabi64
gnueabihf
gnueabi
gnux32
code16
eabi
eabihf
android
musl
musleabi
musleabihf
msvc
itanium
cygnus
coreclr
simulator
macho
empty
rope:
cstring:"
std::string:"
stringref:"
smallstring:"
formatv:"
char:"
decUI:"
decI:"
decUL:"
decL:"
decULL:"
decLL:"
uhex:"
(Twine 
invalid number
out of range number
IO failure on output stream: 
[:<:]]
[:>:]]
alnum
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
alpha
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
blank
cntrl
digit
0123456789
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
lower
abcdefghijklmnopqrstuvwxyz
print
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~ 
punct
!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
space
upper
ABCDEFGHIJKLMNOPQRSTUVWXYZ
xdigit
0123456789ABCDEFabcdef
alert
backspace
newline
vertical-tab
form-feed
carriage-return
exclamation-mark
quotation-mark
number-sign
dollar-sign
percent-sign
ampersand
apostrophe
left-parenthesis
right-parenthesis
asterisk
plus-sign
comma
hyphen
hyphen-minus
period
full-stop
slash
solidus
zero
three
four
five
seven
eight
nine
colon
semicolon
less-than-sign
equals-sign
greater-than-sign
question-mark
commercial-at
left-square-bracket
backslash
reverse-solidus
right-square-bracket
circumflex
circumflex-accent
underscore
low-line
grave-accent
left-brace
left-curly-bracket
vertical-line
right-brace
right-curly-bracket
tilde
REG_0x%x
REG_NOMATCH
llvm_regexec() failed to match
REG_BADPAT
invalid regular expression
REG_ECOLLATE
invalid collating element
REG_ECTYPE
invalid character class
REG_EESCAPE
trailing backslash (\)
REG_ESUBREG
invalid backreference number
REG_EBRACK
brackets ([ ]) not balanced
REG_EPAREN
parentheses not balanced
REG_EBRACE
braces not balanced
REG_BADBR
invalid repetition count(s)
REG_ERANGE
invalid character range
REG_ESPACE
out of memory
REG_BADRPT
repetition-operator operand invalid
REG_EMPTY
empty (sub)expression
REG_ASSERT
"can't happen" -- you found a bug
REG_INVARG
invalid argument to regex routine
*** unknown regexp error code ***
x86_64-apple-darwin22.1.0
generic
-darwin
Allocation failed
-%%%%%%
0123456789abcdef
-%%%%%%.
TMPDIR
TEMP
TEMPDIR
/var/tmp/
TERM
PATH
Child timed out but wouldn't die
Child timed out
Error waiting for child process
Program could not be executed
 (core dumped)
Executable "
" doesn't exist!
Can't redirect stderr to stdout
posix_spawn failed
Couldn't fork
/dev/null
Cannot dup2
Cannot open file '
' for 
Allocation failed
disable-symbolication
Disable symbolizing crash backtraces.
llvm-symbolizer
Unable to find target for this triple (no targets are registered)
DW_TAG_null
DW_TAG_array_type
DW_TAG_class_type
DW_TAG_entry_point
DW_TAG_enumeration_type
DW_TAG_formal_parameter
DW_TAG_imported_declaration
DW_TAG_label
DW_TAG_lexical_block
DW_TAG_member
DW_TAG_pointer_type
DW_TAG_reference_type
DW_TAG_compile_unit
DW_TAG_string_type
DW_TAG_structure_type
DW_TAG_subroutine_type
DW_TAG_typedef
DW_TAG_union_type
DW_TAG_unspecified_parameters
DW_TAG_variant
DW_TAG_common_block
DW_TAG_common_inclusion
DW_TAG_inheritance
DW_TAG_inlined_subroutine
DW_TAG_module
DW_TAG_ptr_to_member_type
DW_TAG_set_type
DW_TAG_subrange_type
DW_TAG_with_stmt
DW_TAG_access_declaration
DW_TAG_base_type
DW_TAG_catch_block
DW_TAG_const_type
DW_TAG_constant
DW_TAG_enumerator
DW_TAG_file_type
DW_TAG_friend
DW_TAG_namelist
DW_TAG_namelist_item
DW_TAG_packed_type
DW_TAG_subprogram
DW_TAG_template_type_parameter
DW_TAG_template_value_parameter
DW_TAG_thrown_type
DW_TAG_try_block
DW_TAG_variant_part
DW_TAG_variable
DW_TAG_volatile_type
DW_TAG_dwarf_procedure
DW_TAG_restrict_type
DW_TAG_interface_type
DW_TAG_namespace
DW_TAG_imported_module
DW_TAG_unspecified_type
DW_TAG_partial_unit
DW_TAG_imported_unit
DW_TAG_condition
DW_TAG_shared_type
DW_TAG_type_unit
DW_TAG_rvalue_reference_type
DW_TAG_template_alias
DW_TAG_coarray_type
DW_TAG_generic_subrange
DW_TAG_dynamic_type
DW_TAG_atomic_type
DW_TAG_call_site
DW_TAG_call_site_parameter
DW_TAG_skeleton_unit
DW_TAG_immutable_type
DW_TAG_MIPS_loop
DW_TAG_format_label
DW_TAG_function_template
DW_TAG_class_template
DW_TAG_GNU_template_template_param
DW_TAG_GNU_template_parameter_pack
DW_TAG_GNU_formal_parameter_pack
DW_TAG_GNU_call_site
DW_TAG_GNU_call_site_parameter
DW_TAG_APPLE_property
DW_TAG_BORLAND_property
DW_TAG_BORLAND_Delphi_string
DW_TAG_BORLAND_Delphi_dynamic_array
DW_TAG_BORLAND_Delphi_set
DW_TAG_BORLAND_Delphi_variant
DW_AT_sibling
DW_AT_location
DW_AT_name
DW_AT_ordering
DW_AT_byte_size
DW_AT_bit_offset
DW_AT_bit_size
DW_AT_stmt_list
DW_AT_low_pc
DW_AT_high_pc
DW_AT_language
DW_AT_discr
DW_AT_discr_value
DW_AT_visibility
DW_AT_import
DW_AT_string_length
DW_AT_common_reference
DW_AT_comp_dir
DW_AT_const_value
DW_AT_containing_type
DW_AT_default_value
DW_AT_inline
DW_AT_is_optional
DW_AT_lower_bound
DW_AT_producer
DW_AT_prototyped
DW_AT_return_addr
DW_AT_start_scope
DW_AT_bit_stride
DW_AT_upper_bound
DW_AT_abstract_origin
DW_AT_accessibility
DW_AT_address_class
DW_AT_artificial
DW_AT_base_types
DW_AT_calling_convention
DW_AT_count
DW_AT_data_member_location
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_declaration
DW_AT_discr_list
DW_AT_encoding
DW_AT_external
DW_AT_frame_base
DW_AT_friend
DW_AT_identifier_case
DW_AT_macro_info
DW_AT_namelist_item
DW_AT_priority
DW_AT_segment
DW_AT_specification
DW_AT_static_link
DW_AT_type
DW_AT_use_location
DW_AT_variable_parameter
DW_AT_virtuality
DW_AT_vtable_elem_location
DW_AT_allocated
DW_AT_associated
DW_AT_data_location
DW_AT_byte_stride
DW_AT_entry_pc
DW_AT_use_UTF8
DW_AT_extension
DW_AT_ranges
DW_AT_trampoline
DW_AT_call_column
DW_AT_call_file
DW_AT_call_line
DW_AT_description
DW_AT_binary_scale
DW_AT_decimal_scale
DW_AT_small
DW_AT_decimal_sign
DW_AT_digit_count
DW_AT_picture_string
DW_AT_mutable
DW_AT_threads_scaled
DW_AT_explicit
DW_AT_object_pointer
DW_AT_endianity
DW_AT_elemental
DW_AT_pure
DW_AT_recursive
DW_AT_signature
DW_AT_main_subprogram
DW_AT_data_bit_offset
DW_AT_const_expr
DW_AT_enum_class
DW_AT_linkage_name
DW_AT_string_length_bit_size
DW_AT_string_length_byte_size
DW_AT_rank
DW_AT_str_offsets_base
DW_AT_addr_base
DW_AT_rnglists_base
DW_AT_dwo_id
DW_AT_dwo_name
DW_AT_reference
DW_AT_rvalue_reference
DW_AT_macros
DW_AT_call_all_calls
DW_AT_call_all_source_calls
DW_AT_call_all_tail_calls
DW_AT_call_return_pc
DW_AT_call_value
DW_AT_call_origin
DW_AT_call_parameter
DW_AT_call_pc
DW_AT_call_tail_call
DW_AT_call_target
DW_AT_call_target_clobbered
DW_AT_call_data_location
DW_AT_call_data_value
DW_AT_noreturn
DW_AT_alignment
DW_AT_export_symbols
DW_AT_deleted
DW_AT_defaulted
DW_AT_loclists_base
DW_AT_MIPS_loop_begin
DW_AT_MIPS_tail_loop_begin
DW_AT_MIPS_epilog_begin
DW_AT_MIPS_loop_unroll_factor
DW_AT_MIPS_software_pipeline_depth
DW_AT_MIPS_linkage_name
DW_AT_MIPS_stride
DW_AT_MIPS_abstract_name
DW_AT_MIPS_clone_origin
DW_AT_MIPS_has_inlines
DW_AT_MIPS_stride_byte
DW_AT_MIPS_stride_elem
DW_AT_MIPS_ptr_dopetype
DW_AT_MIPS_allocatable_dopetype
DW_AT_MIPS_assumed_shape_dopetype
DW_AT_MIPS_assumed_size
DW_AT_sf_names
DW_AT_src_info
DW_AT_mac_info
DW_AT_src_coords
DW_AT_body_begin
DW_AT_body_end
DW_AT_GNU_vector
DW_AT_GNU_template_name
DW_AT_GNU_odr_signature
DW_AT_GNU_call_site_value
DW_AT_GNU_all_call_sites
DW_AT_GNU_macros
DW_AT_GNU_dwo_name
DW_AT_GNU_dwo_id
DW_AT_GNU_ranges_base
DW_AT_GNU_addr_base
DW_AT_GNU_pubnames
DW_AT_GNU_pubtypes
DW_AT_GNU_discriminator
DW_AT_BORLAND_property_read
DW_AT_BORLAND_property_write
DW_AT_BORLAND_property_implements
DW_AT_BORLAND_property_index
DW_AT_BORLAND_property_default
DW_AT_BORLAND_Delphi_unit
DW_AT_BORLAND_Delphi_class
DW_AT_BORLAND_Delphi_record
DW_AT_BORLAND_Delphi_metaclass
DW_AT_BORLAND_Delphi_constructor
DW_AT_BORLAND_Delphi_destructor
DW_AT_BORLAND_Delphi_anonymous_method
DW_AT_BORLAND_Delphi_interface
DW_AT_BORLAND_Delphi_ABI
DW_AT_BORLAND_Delphi_return
DW_AT_BORLAND_Delphi_frameptr
DW_AT_BORLAND_closure
DW_AT_LLVM_include_path
DW_AT_LLVM_config_macros
DW_AT_LLVM_isysroot
DW_AT_APPLE_optimized
DW_AT_APPLE_flags
DW_AT_APPLE_isa
DW_AT_APPLE_block
DW_AT_APPLE_major_runtime_vers
DW_AT_APPLE_runtime_class
DW_AT_APPLE_omit_frame_ptr
DW_AT_APPLE_property_name
DW_AT_APPLE_property_getter
DW_AT_APPLE_property_setter
DW_AT_APPLE_property_attribute
DW_AT_APPLE_objc_complete_type
DW_AT_APPLE_property
DW_OP_addr
DW_OP_deref
DW_OP_const1u
DW_OP_const1s
DW_OP_const2u
DW_OP_const2s
DW_OP_const4u
DW_OP_const4s
DW_OP_const8u
DW_OP_const8s
DW_OP_constu
DW_OP_consts
DW_OP_dup
DW_OP_drop
DW_OP_over
DW_OP_pick
DW_OP_swap
DW_OP_rot
DW_OP_xderef
DW_OP_abs
DW_OP_and
DW_OP_div
DW_OP_minus
DW_OP_mod
DW_OP_mul
DW_OP_neg
DW_OP_not
DW_OP_or
DW_OP_plus
DW_OP_plus_uconst
DW_OP_shl
DW_OP_shr
DW_OP_shra
DW_OP_xor
DW_OP_bra
DW_OP_eq
DW_OP_ge
DW_OP_gt
DW_OP_le
DW_OP_lt
DW_OP_ne
DW_OP_skip
DW_OP_lit0
DW_OP_lit1
DW_OP_lit2
DW_OP_lit3
DW_OP_lit4
DW_OP_lit5
DW_OP_lit6
DW_OP_lit7
DW_OP_lit8
DW_OP_lit9
DW_OP_lit10
DW_OP_lit11
DW_OP_lit12
DW_OP_lit13
DW_OP_lit14
DW_OP_lit15
DW_OP_lit16
DW_OP_lit17
DW_OP_lit18
DW_OP_lit19
DW_OP_lit20
DW_OP_lit21
DW_OP_lit22
DW_OP_lit23
DW_OP_lit24
DW_OP_lit25
DW_OP_lit26
DW_OP_lit27
DW_OP_lit28
DW_OP_lit29
DW_OP_lit30
DW_OP_lit31
DW_OP_reg0
DW_OP_reg1
DW_OP_reg2
DW_OP_reg3
DW_OP_reg4
DW_OP_reg5
DW_OP_reg6
DW_OP_reg7
DW_OP_reg8
DW_OP_reg9
DW_OP_reg10
DW_OP_reg11
DW_OP_reg12
DW_OP_reg13
DW_OP_reg14
DW_OP_reg15
DW_OP_reg16
DW_OP_reg17
DW_OP_reg18
DW_OP_reg19
DW_OP_reg20
DW_OP_reg21
DW_OP_reg22
DW_OP_reg23
DW_OP_reg24
DW_OP_reg25
DW_OP_reg26
DW_OP_reg27
DW_OP_reg28
DW_OP_reg29
DW_OP_reg30
DW_OP_reg31
DW_OP_breg0
DW_OP_breg1
DW_OP_breg2
DW_OP_breg3
DW_OP_breg4
DW_OP_breg5
DW_OP_breg6
DW_OP_breg7
DW_OP_breg8
DW_OP_breg9
DW_OP_breg10
DW_OP_breg11
DW_OP_breg12
DW_OP_breg13
DW_OP_breg14
DW_OP_breg15
DW_OP_breg16
DW_OP_breg17
DW_OP_breg18
DW_OP_breg19
DW_OP_breg20
DW_OP_breg21
DW_OP_breg22
DW_OP_breg23
DW_OP_breg24
DW_OP_breg25
DW_OP_breg26
DW_OP_breg27
DW_OP_breg28
DW_OP_breg29
DW_OP_breg30
DW_OP_breg31
DW_OP_regx
DW_OP_fbreg
DW_OP_bregx
DW_OP_piece
DW_OP_deref_size
DW_OP_xderef_size
DW_OP_nop
DW_OP_push_object_address
DW_OP_call2
DW_OP_call4
DW_OP_call_ref
DW_OP_form_tls_address
DW_OP_call_frame_cfa
DW_OP_bit_piece
DW_OP_implicit_value
DW_OP_stack_value
DW_OP_implicit_pointer
DW_OP_addrx
DW_OP_constx
DW_OP_entry_value
DW_OP_const_type
DW_OP_regval_type
DW_OP_deref_type
DW_OP_xderef_type
DW_OP_convert
DW_OP_reinterpret
DW_OP_GNU_push_tls_address
DW_OP_GNU_addr_index
DW_OP_GNU_const_index
DW_OP_LLVM_fragment
DW_ATE_address
DW_ATE_boolean
DW_ATE_complex_float
DW_ATE_float
DW_ATE_signed
DW_ATE_signed_char
DW_ATE_unsigned
DW_ATE_unsigned_char
DW_ATE_imaginary_float
DW_ATE_packed_decimal
DW_ATE_numeric_string
DW_ATE_edited
DW_ATE_signed_fixed
DW_ATE_unsigned_fixed
DW_ATE_decimal_float
DW_ATE_UTF
DW_ATE_UCS
DW_ATE_ASCII
DW_VIRTUALITY_none
DW_VIRTUALITY_virtual
DW_VIRTUALITY_pure_virtual
DW_LANG_C89
DW_LANG_C
DW_LANG_Ada83
DW_LANG_C_plus_plus
DW_LANG_Cobol74
DW_LANG_Cobol85
DW_LANG_Fortran77
DW_LANG_Fortran90
DW_LANG_Pascal83
DW_LANG_Modula2
DW_LANG_Java
DW_LANG_C99
DW_LANG_Ada95
DW_LANG_Fortran95
DW_LANG_PLI
DW_LANG_ObjC
DW_LANG_ObjC_plus_plus
DW_LANG_UPC
DW_LANG_D
DW_LANG_Python
DW_LANG_OpenCL
DW_LANG_Go
DW_LANG_Modula3
DW_LANG_Haskell
DW_LANG_C_plus_plus_03
DW_LANG_C_plus_plus_11
DW_LANG_OCaml
DW_LANG_Rust
DW_LANG_C11
DW_LANG_Swift
DW_LANG_Julia
DW_LANG_Dylan
DW_LANG_C_plus_plus_14
DW_LANG_Fortran03
DW_LANG_Fortran08
DW_LANG_RenderScript
DW_LANG_BLISS
DW_LANG_Mips_Assembler
DW_LANG_GOOGLE_RenderScript
DW_LANG_BORLAND_Delphi
DW_CC_normal
DW_CC_program
DW_CC_nocall
DW_CC_pass_by_reference
DW_CC_pass_by_value
DW_CC_GNU_renesas_sh
DW_CC_GNU_borland_fastcall_i386
DW_CC_BORLAND_safecall
DW_CC_BORLAND_stdcall
DW_CC_BORLAND_pascal
DW_CC_BORLAND_msfastcall
DW_CC_BORLAND_msreturn
DW_CC_BORLAND_thiscall
DW_CC_BORLAND_fastcall
DW_CC_LLVM_vectorcall
DW_CC_LLVM_Win64
DW_CC_LLVM_X86_64SysV
DW_CC_LLVM_AAPCS
DW_CC_LLVM_AAPCS_VFP
DW_CC_LLVM_IntelOclBicc
DW_CC_LLVM_SpirFunction
DW_CC_LLVM_OpenCLKernel
DW_CC_LLVM_Swift
DW_CC_LLVM_PreserveMost
DW_CC_LLVM_PreserveAll
DW_CC_LLVM_X86RegCall
DW_CC_GDB_IBM_OpenCL
DW_MACINFO_define
DW_MACINFO_undef
DW_MACINFO_start_file
DW_MACINFO_end_file
DW_MACINFO_vendor_ext
R_WEBASSEMBLY_FUNCTION_INDEX_LEB
R_WEBASSEMBLY_TABLE_INDEX_SLEB
R_WEBASSEMBLY_TABLE_INDEX_I32
R_WEBASSEMBLY_MEMORY_ADDR_LEB
R_WEBASSEMBLY_MEMORY_ADDR_SLEB
R_WEBASSEMBLY_MEMORY_ADDR_I32
R_WEBASSEMBLY_TYPE_INDEX_LEB
R_WEBASSEMBLY_GLOBAL_INDEX_LEB
R_WEBASSEMBLY_FUNCTION_OFFSET_I32
R_WEBASSEMBLY_SECTION_OFFSET_I32
static-func-full-module-prefix
Use full module build paths in the profile counter names for static functions.
static-func-strip-dirname-prefix
Strip specified level of directory name from source path in the profile counter name for static functions.
GED ERROR: 
/AppleInternal/Library/BuildRoots/37485203-f0ff-11ee-b9af-a65dcee5a99e/Library/Caches/com.apple.xbs/Sources/GPUDriversIntel/igc/gfx-driver/Source/visa/iga/GEDLibrary/GED_internal/Source/ged/xcoder/ged_ins.cpp
MapRawBytes
 is not yet implemented
GED VERSION: 
        
0.41 (982f76f)
Breakpoint
mme0
mme1
mme2
mme3
mme4
mme5
mme6
mme7
nomme
MSD0R_HWB
MSD0W_HWB
MT0R_OWB
MT0R_OWUB
MT0R_OWDB
MT0R_DWS
MT0R_BS
MT0_MEMFENCE
MT0W_OWB
MT0W_OWDB
MT0W_DWS
MT0W_BS
MT1R_T
MT1R_US
MT1A_UI
MT1A_UI4x2
MT1R_MB
MT1R_TS
MT1A_TA
MT1A_TA4x2
MT1W_US
MT1W_MB
MT1A_TC
MT1A_TC4x2
MT1W_TS
MT1R_A64_SB
MT1R_A64_US
MT1A_A64_UI
MT1A_A64_UI4x2
MT1R_A64_B
MT1W_A64_B
MT1W_A64_US
MT1W_A64_SB
MT2R_US
MT2R_A64_SB
MT2R_A64_US
MT2R_BS
MT2W_US
MT2W_A64_US
MT2W_A64_SB
MT2W_BS
MT_CC_OWB
MT_CC_OWUB
MT_CC_OWDB
MT_CC_DWS
MT_SC_OWUB
MT_SC_MB
MT_RSI
MT_RTW
MT_RTR
MTR_MB
MTRR_TS
MTRA_TA
MT_MEMFENCE
MTW_MB
MTRW_TS
MT0R_US
MT0A_UI
MT0W_US
MT1A_UF4x2
MT1A_UF
MT1A_A64_UF
MT1A_A64_UF4x2
Scratch Block Read
Scratch Block Write
OWord Block Read
Unaligned OWord Block Read
OWord Dual Block Read
DWord Scattered Read
Byte Scattered Read
Memory Fence
OWord Block Write
OWord Dual Block Write
DWord Scattered Write
Byte Scattered Write
Transpose Read
Untyped Surface Read
Untyped Atomic Integer Operation
Untyped Atomic Integer Operation SIMD4x2
Media Block Read
Typed Surface Read
Typed Atomic Integer Operation
Typed Atomic Integer Operation SIMD4x2
Untyped Surface Write
Media Block Write
Typed Atomic Counter Operation
Typed Atomic Counter Operation SIMD4x2
Typed Surface Write
A64 Scattered Read
A64 Untyped Surface Read
A64 Untyped Atomic Integer Operation
A64 Untyped Atomic Integer Operation SIMD4x2
A64 Block Read
A64 Block Write
A64 Untyped Surface Write
A64 Scattered Write
Oword Block Read Constant Cache
Unaligned Oword Block Read Constant Cache
Oword Dual Block Read Constant Cache
Dword Scattered Read Constant Cache
Unaligned Oword Block Read Sampler Cache
Media Block Read Sampler Cache
Read Surface Info
Render Target Write
Render Target Read
Typed Atomic Operation
Untyped Atomic Operation
A64 Untyped Atomic Float Add
Untyped Atomic Float Operation
A64 Untyped Atomic Float Operation
A64 Untyped Atomic Float Operation SIMD4x2
SIMD16
SIMD8
bits set in undefined field
MType
const_load_block
unaligned_const_load_block
constant oword block read
constant unaligned oword block read
7041
7043
const_load
constant dword gathering read
LegacySimdMode
7084
unsupported DCRO op
MessageType
load_block
7028
aligned oword block read
aligned_load_block
7030
store_block
7032
aligned_store_block
aligned oword block write
20862
7029
oword dual block read decode not supported
7033
oword dual block write decode not supported
byte gathering read
byte scattering write
7066
7068
dword gathering read
dword scattering write
7067
7069
Commit
off (return immediately)
on (wait for fence commit)
sync_
synchronized 
slm_fence
SLM fence
global_fence
global fence
L3 implies L1 flush
 flushing
L1Flush
Flush L3
FLush L1
L3 Flush Targets
 all L3 data
.dcti
 r/w data
 constant data
 texture data
 instruction data
invalid BTI for fence (must be 0x0 or 0xFE)
7049
hword scratch block read
hword scratch block write
HWordOffset
ChannelMode
OWord
DWord
7027
7031
unsupported dc0 op
7091
7086
7089
a64 byte gathering read
a64 byte scattering write
SubType
7070
7073
Byte with Status Return
19316
a64 byte scattering with status return message
a64 scattering write
a64 dword gathering read
a64 dword scattering write
a64 qword gathering read
a64 qword scattering write
QWord
7071
7074
7072
7075
7034
7038
HWord aligned unsupported on this platform
7037
33440
7039
7036
7040
a64 dual block 
 read
 write
MSD1R_A64_OWDB
MSD1W_A64_OWDB
 unaligned
 aligned
_aligned
 hword
 oword
 block
a64 float atomic
7126
7118
float atomic
7130
7122
a64 untyped atomic int32
DataWidth
untyped
7161
7155
7143
7137
untyped atomic int32
7167
7149
media block 
mlen == 0 on write
 with vertical line stride 
override
skip
, and 
stride offset meaningless when override not set
7046
7048
7087
7090
typed
atomic 32-bit counter
7109
7099
typed_sgh
atomic 32-bit integer (slot group high)
atomic 32-bit integer
7113
7103
unsupported DC1 op
ChannelMaskEnable
enabled
disabled
MSDUW_DWS
urb dword 
masked 
 with per-slot offset enabled
44779
44778
MSDUR_DWS
urb dword read
44777
unsupported URB op
URBOpcode
signal
signal event
monitor
monitor event
unmonitor
unmonitor event
wait for event
unsupported GTWY op
GatewayOpcode
unknown render target op
unsupported RC op
MessageTypeRC
DataSize
FP32
FP16
full-precision
.f32
half-precision
half-precision not supported on render target read
.f16
.simd16
 SIMD16
.rep16
 replicated SIMD16
.lo8ds
 of low SIMD8
.hi8ds
 of high SIMD8
.simd8
 SIMD8
.???
unknown write subop
unknown read subop
Subop
PerCoarsePixelPSOutputs
 with Per-Coarse Pixel PS outputs enable
.cpo
PerSamplePS
 with Per-Sample Pixel PS outputs enable
.psp
LastRenderTargetSelect
; last render target
.lrts
SlotGroupSelect
SLOTGRP_LO
SLOTGRP_HI
 slot group high
.sgh
SIMD[2]
12484
invalid sampler SIMD mode
simd32/64
simd32
invalid SIMD mode
simd8h
simd8 high
simd16h
simd16 high
SIMD[1:0]
ReturnFormat
 16b
sample+LOD bias
sample override LOD
sample compare
sample gradient
sample compare+LOD bias
sample compare+override LOD
sample_ld
sample load
sample_gather4
sample gather4
sample_lod
sample override lod
sample_resinfo
sample res info
sample_info
sample info
sample_killpix
sample_gather4_c
sample gather4+compare
sample_gather4_po
sample gather4+pixel offset
sample_gather4_po_c
sample gather4 pixel offset+compare
sample derivatives+compare
sample_min
sample min
sample_max
sample max
sample with lod forced to 0
sample compare+with lod forced to 0
sample_ld_lz
sample load with lod forced to 0
sample_ld2dms_w
sample ld2 multi-sample wide
sample_ld_mcs
sample load mcs auxilary data
sample_ld2dms
sample load multi-sample
sample_ld2ds
sample multi-sample without mcs
sample_
sample unorm
sample_unorm_killpix
sample unorm+killpix
sample_deinterlace
sample deinterlace
sample_unorm_media
sample unorm for media
sample_unorm_killpix_media
sample unorm+killpix for media
sample_8x8
sample 8x8
sample_flush
sampler cache flush
SamplerMessageType
SamplerIndex
 using sampler index 
Mlen
Rlen
Xlen
unsupported DC2 op
end of thread
unsupported TS op
unsupported sfid
DataElements:MDC_A64_DB_OW
1L (1 Oword accessed in low half of GRF)
1H (1 Oword accessed in high half of GRF)
2 OWords
4 OWords
8 OWords
DataElements:MDC_DB_OW
MDC_IAR
this message requires a header (and it's absent)
Fill 1 byte per DW
Fill 2 bytes per DW
Fill all 4 bytes per DW
DataElements:MDC_DWS_DS
SimdMode:MDC_SM2
field should be 
Header
absent
included
hdc_
_simd
scratch
stateless
_incoherent
bti[
must have 0xFF or 0xFD BTI
DataElements:MDC_DS
DE1 (1 data element per addr.)
DE2 (2 data elements per addr.)
DE4 (4 data elements per addr.)
DE8 (8 data elements per addr.)
surface 
 (SLM)
A64 
A32 
 (coherent stateless)
 A64
 A32
 (incoherent stateless)
 (SSO)
DataElements:MDC_A64_DB_HW
 256b blocks
DataElements:MDC_DB_HW
untyped_load
untyped_store
channel mask must have one element not disabled
no channels enabled
 enabled
ChannelDisableMask:MDC_CMASK
invalid MDC_SM3
SimdMode:MDC_SM3
this message forbids a header (and it's included)
DataElements:MDC_A64_DS
atomic_float?
atomic_fmax
atomic_fmin
atomic_fcas
fp-compare and swap 
 (unknown float op)
AtomicOp:MDC_AOP
ReturnDataControl
no return value
returns new value
_ret
 with return
atomic_icas
64b integer compare and swap
atomic_and
logical AND
atomic_or
logical OR
atomic_xor
logical XOR
atomic_store
atomic_iinc
integer increment
atomic_idec
integer decrement
atomic_iipdec
integer pre-decrement (returns pre-decrement value)
atomic_iadd
integer add
atomic_isub
integer subtract
atomic_irsub
commuted integer subtract
atomic_smax
signed-integer max
atomic_smin
signed-integer min
atomic_umax
unsigned-integer max
atomic_umin
unsigned-integer min
integer compare and swap (non-64b)
AtomicIntegerOp
SimdMode:MDC_SM2R
typed_load
typed_store
 (high slot group)
_sgh
SG4x2
SG8L
SG8U
invalid slot group value
SlotGroup:MDC_SG3
SlotGroup:MDC_SG2
GlobalUrbOffset
 (in owords)
PerSlotOffsetPresent
per-slot offset in payload
DualHeader
included (two register header)
 HWords from scratch base
oword unaligned
oword aligned
hword unaligned
dual block
a64 dual block read/write unsupported
 to surface 
.bti[
sampler 
 address registers written
 registers read back
 data registers written
encoder line %d: unsupported GED setter %s (%s)
failed to allocate memory for kernel binary
GED unable to compact instruction
MathFC
GED failed to create instruction template
AccessMode
ExecSize
ChannelOffset
MaskCtrl
PredCtrl
CondModifier
PredInv
FlagRegNum
FlagSubRegNum
AccWrCtrl
Saturate
DstDataType
DstRegFile
DstMathMacroExt
DstHorzStride
src0: unsupported type for ternary align1 encoding
ExecutionDataType
BranchCtrl
Src1DataType
Src1RegFile
Src0VertStride
Src0Width
Src0HorzStride
Src0RegFile
Src0DataType
ExDescRegFile
ExMsgDesc
ex_desc register not supported on this platform for this instruction
ExDescAddrSubRegNum
DescRegFile
MsgDesc
DescRegNum
DstAddrMode
dst has inconvertible region for Align16 encoding
DstChanEn
Align1 dst math macro unsupported on this platform.
DstAddrImm
DstAddrSubRegNum
dst region should be %s
DstRegNum
dst: unsupported destination operand kind/addrMode (malformed IR)
Src0AddrMode
src%d: unsupported source operand kind/addrMode (malformed IR)
Src0RegNum
Src0SubRegNum
Src0AddrSubRegNum
Src0AddrImm
Src1RegNum
align16 ternary dst must be to GRF
%s: invalid register name for this platform
%s: %s%d number out of range
operand has invalid math macro register
ThreadCtrl
NoPreempt not supported on this platform (dropping)
DstSubRegNum
DebugCtrl
DepCtrl
nop doesn't support Switch option (dropping)
jip label invalid
uip label invalid
GED_EncodeIns failed: %s
Src1VertStride
cyclic dependency
null pointer
unsupported opcode
no compact form
invalid field
invalid value
invalid interpreter
other error
src%d source modifier not supported (invalid IR)
src%d: unsupported source operand kind (malformed IR)
src%d: unsupported region for translation to align16 encoding
Src1SrcMod
Src1AddrMode
src%d: unexpected register on this platform
Src1SubRegNum
Src1MathMacroExt
Src1AddrImm
Src1AddrSubRegNum
Src1ChanSel
invalid region vertical stride on src1
invalid region width on src1
invalid region horizontal stride on src1
Src1Width
Src1HorzStride
Src0SrcMod
Src0MathMacroExt
Src0ChanSel
invalid region vertical stride on src0
invalid region width on src0
invalid region horizontal stride on src0
SrcDataType
src%d: unsupported region for Align16 encoding
Src0RepCtrl
src%d: mixed types require :f and :hf (or vice versa)
Src1RepCtrl
Src2SrcMod
Src2DataType
Src2RepCtrl
Src2ChanSel
Src2RegNum
Src2SubRegNum
Src2MathMacroExt
src%d: align1 ternary is not supported on this platform.
src%d: math macro operands require Align16
src%d: invalid operand kind
Src0TernaryImm
src1: immediate operand in ternary align1 must be src0 or src2
Src2RegFile
Src2HorzStride
Src2TernaryImm
qnan
snan
(sat)
Operand::Kind::?
 wr:
h:INVALID
, rd:
 from scratch offset 0x
 msc:
, to 
INVALID BTI
global memory
bti 
:Type::INVALID
Type
MathMacroExt::INVALID
MathMacroExt
dst region is not binary normal
SrcModifier
on <v;h> region w must be Region::WI_INVALID
on <h> region v must be Region::VT_INVALID
on <h> region w must be Region::WI_INVALID
<Region::INVALID>
InstOpt
/* [
 */ 
|ChannelOffset
]: #
 // 
 from #
FlagModifier
not a send
has reg descs
src0 must be GRF
no mapping for descriptors
dst must be GRF for load
dst must be null for store
unsupported format kind (for now)
error decoding SIMD size from descriptor
descriptor SIMD size mismatches instruction ExecSize
an operand is indirect
store as send must have a null dst
src0 is null (doesn't fit operand mapping)
store needs binary send with non-null src1
-<ERR>
a32c
a32o
a64c
a64o
surf
scratch
xga8
xsc8
xga32
xsc32
xga64
xsc64
ga32
sc32
ga32c
xbl256
xbl128
xubl128
bl128
abl128
cbl128
cubl128
sbl256
PackedData
DE(0x
BTS_SLM_A32
HW64
HW64(0x
OWs(0x
HWSB
HWSB(0x
ScratchOffset
CMask
rgba
CMask(0x
CMaskUW
CMaskUW(0x
sg4x2
sg8l
sg8h
SG3(0x
: numeric label targets the middle of an instruction
 targets
 before kernel start
 after kernel end
: PC 
destination register ARF access requires {Switch} ThreadCtrl
not a macro instruction
invalid operand type combination for instruction
src type is not binary normal form
register regioning restriction warning: ExecSize * sizeof(Type) exceeds 2 GRF
see Programmer's Reference Manual (Restriction 1.1)
register regioning restriction warning: ExecSize <= Src.W (partial row)
see Programmer's Reference Manual (Restriction 2.1)
register regioning restriction warning: ExecSize == Src.W && Src.H != 0 && Src.V != Src.W * Src.H (vertical misalignment)
see Programmer's Reference Manual (Restriction 2.2)
register regioning restriction warning: SIMD1 requires horizontal stride of 0 (scalar region access)
see Programmer's Reference Manual (Restriction 2.4)
register regioning restriction warning: SIMD1 requires vertical and horiztonal to be 0 (scalar region access)
see Programmer's Reference Manual (Restriction 2.5)
register regioning restriction warning: If vertical stride and horizontal stride are 0, width must be 1.
see Programmer's Reference Manual (Restriction 2.6)
register regioning restriction warning: Vertical stride must be used to cross GRF boundaries.
see Programmer's Reference Manual (Restriction 2.8)
General
null
Null
Index
Accumulator
Math Macro
Flag Register
Channel Enable
Message Control
Stack Pointer
State Register
Control Register
Notification Register
Instruction Pointer
Thread Dependency Register
Timestamp Register
Flow Control
Debug
Addition
The add instruction performs component-wise addition of src0 and src1 and stores the results in dst.
Addition of two floating-point numbers follows rules in add (IEEE mode) or add (ALT mode).
Format:
[(pred)] add[.cmod] (exec_size) dst src0 src1
Use a source modifier with add to implement subtraction.
addc
Addition with Carry
The addc instruction performs component-wise addition of src0 and src1 and stores the results in dst; it also stores the carry into acc.
If the operation produces a carry out, 0x00000001 is stored in acc, else 0x00000000 is stored in acc.
Format:
[(pred)] addc[.cmod] (exec_size) dst src0 src1
Logic And
The and instruction performs component-wise logic AND operation between src0 and src1 and stores the results in dst.
Register source operands can use source modifiers:
[Pre-DevBDW]: Any source modifier is numeric, optionally changing a source value s to -s, abs(s), or -abs(s) before the AND operation.
[DevBDW+]: Any source modifier is logical, optionally changing a source value s to ~s (inverting all source bits). This capability allows expressions like a AND (NOT b) to be calculated with one instruction.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
Format:
Source modifier is not allowed if source is an accumulator.
Arithmetic Shift Right
Perform component-wise arithmetic right shift of the bits in src0 by the shift count indicated in src1, storing the results in dst. If src0 has a signed type, insert copies of src0's sign bit in the number of MSBs indicated by the shift count. Otherwise insert 0 bits.
[Pre-DevBDW]: The shift count is taken from the low five bits of src1, regardless of the src1 type and treated as an unsigned integer in the range 0 to 31.
[DevBDW+]: In QWord mode, the shift count is taken from the low six bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 63. Otherwise the shift count is taken from the low five bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 31. The operation uses QWord mode if src0 or dst has the Q or UQ type but not if src1 is the only operand with the Q or UQ type.
For positive values, this operation is src0 / 2shiftCount and for negative values, this operation is src0 / 2shiftCount - 1.
Format:
[(pred)] asr[.cmod] (exec_size) dst src0 src1
If src0 is -1, the result is -1 regardless of the shift count.
For unsigned src0 types, asr and shr produce the same result.
Average
The avg instruction performs component-wise integer average of src0 and src1 and stores the results in dst. An integer average uses integer upward rounding. It is equivalent to increment one to the addition of src0 and src1 and then apply an arithmetic right shift to this intermediate value.
Format:
The avg instruction performs component-wise integer average of src0 and src1 and stores the results in dst. An integer average uses integer upward rounding. It is equivalent to increment one to the addition of src0 and src1 and then apply an arithmetic right shift to this intermediate value.
Bit Field Extract
Component-wise extract a bit field from src2 using the bit field width from src0 and the bit field offset from src1. Store the extracted bit field value in the low bits of dst and sign extend (if D type) or zero extend (if UD type).
The width and offset values are from the low five bits of src0 and src1 respectively, or src0 & 0x1f and src1 & 0x1f.
If width is zero, the result is zero.
If offset + width > 32 then the extracted bit field is bits offset to 31 of src2, extracting only 32 - offset bits, less than width as the bit field cannot extend past the MSB of the source value. Otherwise extract width bits extending from bit positions offset to offset + width - 1.
Format:
[(pred)] bfe (exec_size) dst src0 src1 src2
bfi1
Bit Field Insert 1
The bfi1 instruction is the first instruction in a two-instruction macro for bfi (Bit Field Insert).
The bfi1 instruction component-wise generates mask with control from src0 and src1 and stores the results in dst. The mask is used in the bfi2 instruction to generate the final result of bfi.
Create a bit mask corresponding to the bit field width and offset in src0 and src1. Store the bit mask in dst. The mask has all bits in the bit field set to 1 and all other bits as 0.
The width and offset values are from the low five bits of src0 and src1 respectively, or src0 & 0x1f and src1 & 0x1f.
If width is zero, the result is zero.
The bfi macro has four source operands: src0 - bit field width in low five bits, src1 - bit field offset/starting bit position in low five bits, src2 - bit field value to insert, using only the number of least significant bits given by width in src0, and src3 - overall value into which the bit field is inserted, providing all bits other than the inserted bits for the result value.
bfi dst src0 src1 src2 src3
// Translates to these two instructions:
bfi1 dst src0 src1
bfi2 dst dst src2 src3
Format:
[(pred)] bfi1 (exec_size) dst src0 src1
No accumulator access, implicit or explicit.
A SIMD16 instruction is not allowed.
bfi2
Bit Field Insert 2
The bfi2 instruction is the second instruction in a two-instruction macro for bfi (Bit Field Insert).
The bfi2 instruction component-wise performs the bitfield insert operation on src1 and src2 based on the mask in src0.
Use the mask in src0 to take a bit field value from the low bits of src1 and combine it with the value from src2 (so src2 provides all bits other than those masked out and replaced by the bit field value). Store the result in dst.
The bfi macro has four source operands: src0 - bit field width in low five bits, src1 - bit field offset/starting bit position in low five bits, src2 - bit field value to insert, using only the number of least significant bits given by width in src0, and src3 - overall value into which the bit field is inserted, providing all bits other than the inserted bits for the result value.
bfi dst src0 src1 src2 src3
// Translates to these two instructions:
bfi1 dst src0 src1
bfi2 dst dst src2 src3
Format:
[(pred)] bfi2 (exec_size) dst src0 src1 src2
bfrev
Bit Field Reverse
The bfrev instruction component-wise reverses all the bits in src0 and stores the results in dst.
Format:
[(pred)] bfrev (exec_size) dst src0
Branch Converging
The brc instruction redirects the execution forward or backward to the instruction pointed by (current IP + offset). The jump will occur if all channels are branched away.
UIP should reference the instruction where all channels are expected to come together. JIP should reference the end of the innermost conditional block.
In GEN binary, JIP and UIP are at location src1 when immediates and at location src0 when reg64, where reg64 is accessed as paired DWord (regioning being <2;2,1>). The ip register must be used (for example, by the assembler) as dst. When offsets are immediate, src0 must be null.
Format:
[(pred)] brc (exec_size) JIP UIP
Branch Diverging
The brd instruction redirects the execution forward or backward to the instruction pointed by (current IP + offset). The jump will occur if any channels are branched away.
In GEN binary, JIP is at location src1 when immediate and at location src0 when reg32, where reg32 is accessed as a scalar DWord. The ip register must be used (for example, by the assembler) as dst.
Format:
[(pred)] brd (exec_size) JIP
break
Break
The break instruction is used to early-out from the inner most loop, or early out from the inner most switch block.
When used in a loop, upon execution, the break instruction terminates the loop for all execution channels enabled. If all the enabled channels hit the break instruction, jump to the instruction referenced by JIP. JIP should be the offset to the end of the inner most conditional or loop block, UIP should be the offset to the while instruction of the loop block.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case
The following table describes the two 16-bit instruction pointer offsets. Both the JIP and UIP are signed 16-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at location src1 and must be of type W (signed word integer).
Format:
[(pred)] break (exec_size) JIP UIP
call
Call
The call instruction jumps to a subroutine. It can be predicated or non-predicated. If non-predicated, all enabled channels jump to the subroutine. If predicated, only the channels enabled by PMask jump to the subroutine; the rest of the channels move to the next instruction after the call instruction. If none of the channels jump into the subroutine, the call instruction is treated as a nop.
In case of a jump, the call instruction stores the return IP onto the first DWord of the destination register and stores the CallMask in the second DWord of the destination register.
When SPF is on, the predication control must be scalar.
The following section describes JIP, the jump offset, for DevHSW+.
JIP can be an immediate or register value. When a jump occurs, this value is added to IP pre-increment. For DevHSW+, in GEN binary, JIP is at location src1 and src0 must be null. The GRF register must be put (for example, by the assembler) at dst location.
Format: [(pred)] call (exec_size) dst JIP
Format: [(pred)] call (exec_size) dst JIP
calla
Call Absolute
The calla instruction jumps to a subroutine. It can be predicated or non-predicated. If non-predicated, all enabled channels jump to the subroutine. If predicated, only the channels enabled by PMask jump to the subroutine; the rest of the channels move to the next instruction after the calla instruction. If none of the channels jump into the subroutine, the calla instruction is treated as a nop.
In case of a jump, the call instruction stores the return IP onto the first DWord of the destination register and stores the CallMask in the second DWord of the destination register.
If SPF is ON, none of the PcIP are updated.
When SPF is on, the predication control must be scalar.
The difference between calla and call is that calla uses JIP as the IP value rather than adding it to the IP value.
Format: [(pred)] calla (exec_size) dst JIP
cbit
Count Bits Set
The cbit instruction counts component-wise the total bits set in src0 and stores the resulting counts in dst.
Format:
[(pred)] cbit (exec_size) dst src0
Compare
The cmp instruction performs component-wise comparison of src0 and src1 and stores the results in the selected flag register and in dst. It takes component-wise subtraction of src0 and src1, evaluating the conditional code (excluding NS signal) based on the conditional modifier, and storing the conditional bits in bit-packed form in the destination flag register and all bits of dst channels. If the dst is not null, for the enabled channels, then all bits of the destination channel will contain the flag value for the channel. When the instruction operates on packed word format, one general register may store up to 16 such comparison results. In DWord format, one general register may store up to 8 results.
A conditional modifier must be specified; the conditional modifier field cannot be 0000b. The comparison does not use the NS (NaN source) signals, as described in the Creating Conditional Flags section. Accordingly the conditional modifier should not be .u (unordered).
For each enabled channel 0b or 1b is assigned to the appropriate flag bit and 0/all zeros or all ones (e.g, byte 0xFF, word 0xFFFF, DWord 0xFFFFFFFF) is assigned to dst.
When any source type is floating-point, the cmp instruction obeys the rules described in the tables in the Floating Point Modes section of the Data Types chapter.
Format:
[(pred)] cmp[.cmod] (exec_size) dst src0 src1
cmpn
Compare NaN
The cmpn instruction performs component-wise special-NaN comparison of src0 and src1 and stores the results in the selected flag register and in dst. It takes component-wise subtraction of src0 and src1, evaluating the conditional signals including NS based on the conditional modifier, and storing the conditional flag bits in bit-packed form in the destination flag register and all bits of dst channels. If the dst is not null, for the enabled channels, then all bits of the destination channel will contain the flag value for the channel. When the instruction operates on packed word format, one general register may store up to 16 such comparison results. In DWord format, one general register may store up to 8 results.
A conditional modifier must be specified; the conditional modifier field cannot be 0000b. More information about the conditional signals used is in the Creating Conditional Flags section.
For each enabled channel 0b or 1b is assigned to the appropriate flag bit and 0/all zeros or all ones (e.g, byte 0xFF, word 0xFFFF, DWord 0xFFFFFFFF) is assigned to dst.
Min/Max instructions use cmpn to select the destination from the input sources (see the Min Max of Floating Point Numbers section for details).
Format:
[(pred)] cmpn[.cmod] (exec_size) dst src0 src1
cont
Continue
The cont instruction disables execution for the subset of channels for the remainder of the current loop iteration. Channels remain disabled until right before the while instuction or right before the condition check code block for the while instruction. If all enabled channels hit this instruction, jump to the instruction referenced by JIP where execution continues.
UIP should always reference the loop's associated while instruction. JIP should point to the last instruction of the inner most conditional block if the cont instruction is inside a conditional block. In case of the break instruction directly under the loop, the JIP and the UIP are the same.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the two 16-bit instruction pointer offsets. Both the JIP and UIP are signed 16-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at location src1 and must be of type W (signed word integer).
Format:
[(pred)] cont (exec_size) JIP UIP
Double Precision Floating Point Immediate Data Move
The dim instruction moves the 64-bit immediate value into enabled channels of dst.
Format:
[(pred)] dim[.cmod] (exec_size) dst src0
Dot Product 2
The dp2 instruction performs a two-wide dot product on four-tuple vector basis and storing the same scalar result per four tuple to all four channels in dst. This instruction is similar to dp4 except that every third and fourth element of src0 (post-source-swizzle if present) are not involved in the computation.
The dot product of two vectors of equal length is the sum of the products of each pair of corresponding elements.
The dp4 instruction includes all four elements of each vector in the dot product. The dp3 instruction includes the first three elements of each vector in the dot product.
Format:
[(pred)] dp2[.cmod] (exec_size) dst src0 src1
Dot Product 3
The dp3 instruction performs a three-wide dot product on four-tuple vector basis and storing the same scalar result per four tuple to all four channels in dst. This instruction is similar to dp4 except that every fourth element of src0 (post-source-swizzle if present) is not involved in the computation.
The dot product of two vectors of equal length is the sum of the products of each pair of corresponding elements.
The dp4 instruction includes all four elements of each vector in the dot product. The dp2 instruction includes the first two elements of each vector in the dot product.
Format:
[(pred)] dp3[.cmod] (exec_size) dst src0 src1
Dot Product 4
The dp4 instruction performs a four-wide dot product on four-tuple vector basis and storing the same scalar result per four tuple to all four channels in dst.
The dot product of two vectors of equal length is the sum of the products of each pair of corresponding elements.
Format:
[(pred)] dp4[.cmod] (exec_size) dst src0 src1
Dot Product Homogeneous
The dph instruction performs a four-wide homogeneous dot product on four-tuple vector basis and storing the same scalar result per four tuple to all four channels in dst. This instruction is similar to dp4 except that every fourth element of src0 (post-source-swizzle if present) is forced to 1.0f.
Use the dp4 instruction to do a four-wide dot product that includes all elements of src0 and src1.
Format:
[(pred)] dph[.cmod] (exec_size) dst src0 src1
else
Else
The else instruction is an optional statement within an if/else/endif block of code. It restricts execution within the else/endif portion to the opposite set of channels enabled under the if/else portion. Channels which were inactive before entering the if/endif block remain inactive throughout the entire block.
All enabled channels upon arriving at the else instruction are redirected to the matching endif. If all channels are redirected (by else or before else), a relative jump is performed to the location specified by JIP. The jump target should be the the matching endif instruction for that conditional block.
The following table describes the 16-bit JIP. In GEN binary, JIP is at location src1 and must be of type W (signed word integer). JIP must be an immediate operand, it is a signed 16-bit number and is intended to be forward referencing. This value is added to IP pre-increment.
Format:
else (exec_size) JIP
endif
End If
The endif instruction terminates an if/else/endif block of code. It restores execution to the channels that were active prior to the if/else/endif block.
The endif instruction is also used to hop out of nested conditionals by jumping to the end of the next outer conditional block when all channels are disabled.
The following table describes the 16-bit JIP. In GEN binary, JIP is at location src1 and must be of type W (signed word integer). JIP must be an immediate operand, it is a signed 16-bit number. This value is added to IP pre-increment.
Format:
endif JIP
f16to32
Half Precision Float to Single Precision Float
The f16to32 instruction converts the half precision float in src0 to single precision float and storing in dst.
Because this instruction does not have a 16-bit floating-point type, the source data type must be Word (W). The destination type must be F (Float).
Format:
[(pred)] f16to32[.cmod] (exec_size) dst src0
f32to16
Single Precision Float to Half Precision Float
The f32to16 instruction converts the single precision float in src0 to half precision float and storing in the lower word of each channel in dst.
Because this instruction does not have a 16-bit floating-point type, the destination data type must be Word (W).
Format:
[(pred)] f32to16[.cmod] (exec_size) dst src0
Find First Bit from MSB Side
If src0 is unsigned, the fbh instruction counts component-wise the leading zeros from src0 and stores the resulting counts in dst.
If src0 is signed and positive, the fbh instruction counts component-wise the leading zeros from src0 and stores the resulting counts in dst.
If src0 is signed and negative, the fbh instruction counts component-wise the leading ones from src0 and stores the resulting counts in dst.
Format:
[(pred)] fbh (exec_size) dst src0
If src0 is zero, store 0xFFFFFFFF in dst.
If src0 is signed and is -1 (0xFFFFFFFF), store 0xFFFFFFFF in dst.
Find First Bit from LSB Side
The fbl instruction counts component-wise the number of LSB 0 bits before the first 1 bit in src0, storing that number in dst.
Format:
[(pred)] fbl (exec_size) dst src0
If src0 contains no 1 bits, store 0xFFFFFFFF in dst.
Fraction
The frc instruction computes, component-wise, the truncate-to-minus-infinity fractional values of src0 and stores the results in dst. The results, in the range of [0.0, 1.0], are the fractional portion of the source data. The result is in the range [0.0, 1.0] irrespective of the rounding mode. Floating-point fraction computation follows the rules in the following tables, based on the current floating-point mode.
Format:
[(pred)] frc[.cmod] (exec_size) dst src0
halt
Halt
The halt instruction temporarily suspends execution for all enabled compute channels. Upon execution, the enabled channels are sent to the instruction at (IP + UIP), if all channels are enabled at HALT, jump to the instruction at (IP + JIP).
If the halt instruction is not inside any conditional code block, the values of JIP and UIP should be the same. If the halt instruction is inside a conditional code block, the UIP should be the end of the program and the JIP should be the end of the inner most conditional code block.
The UIP must point to a HALT Instruction.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the two 16-bit instruction pointer offsets. Both the JIP and UIP are signed 16-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at location src1 and must be of type W (signed word integer).
Format:
[(pred)] halt (exec_size) JIP UIP
An if instruction starts an if/endif or an if/else/endif block of code. It restricts execution within the conditional block to only those channels that were enabled via the predicate control.
Each if instruction must have a matching endif instruction and may have up to one matching else instruction before the matching endif.
If all channels are inactive (for the if/endif or if/else/endif block), a jump is performed to the instruction referenced by JIP. This jump must be to right after the matching else instruction when present, or otherwise to the matching endif instruction of the conditional block.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the two 16-bit instruction pointer offsets. Both the JIP and UIP are signed 16-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at location src1 and must be of type W (signed word integer).
Format:
[(pred)] if (exec_size) JIP UIP
illegal
Illegal
The Illegal Opcode Exception Enable flag in cr0.1 is normally set so the normal processing of an illegal opcode is to transfer control to the System Routine.
Instruction dispatch treats any unused 8-bit opcode (including bit 7 of the instruction, reserved for future opcode expansion) as if it is the illegal opcode.
The illegal opcode is zero because that byte value is more likely than most to be read via a wayward instruction pointer.
The illegal instruction is an instruction only in the same way that a NULL pointer in software is a pointer. Both are special values indicating invalid instances.
Format:
illegal
jmpi
Jump Indexed
The jmpi instruction redirects program execution to an index offset relative to the post-incremented instruction pointer. The index is a signed integer value, with positive or zero integers for forward jumps, and negative integers for backward jumps. In GEN binary, index is at location src1. The ip register must be put (for example, by the assembler) at the dst and src0 locations. Predication is allowed to provide conditional jump with a scalar condition. As the execution size is 1, the first channel of PMASK (flags post prediction control and negate) is used to determine whether the jump is taken or not. If the condition is false, the jump is not taken and execution continues with the next instruction.
Note: Unlike other flow control instructions, the offset used by jmpi is relative to the incremented instruction pointer rather than the IP value for the instruction itself.
Format:
[(pred)] jmpi (1) index {NoMask}
An index of 0 does nothing, continuing execution with the next instruction.
An index of -16 (if the jmpi instruction is in native format) or -8 (if the jmpi instruction is in compact format) is an infinite loop on the jmpi instruction.
line
Line
The line instruction computes a component-wise line equation (v = p * u + q where u, v are vectors and p, q are scalars) of src0 and src1 and stores the results in dst. src1 is the input vector u. src0 provides input scalars p and q, where p is the scalar value based on the region description of src0 and q is the scalar value implied from src0 region. Specifically, q is the fourth component of the 4-tuple (128-bit aligned) that p belongs to.
Format:
[(pred)] line[.cmod] (exec_size) dst src0 src1
Linear Interpolation
The lrp instruction takes component-wise multiplication of src0 and src1, and adds the result to the component-wise multiplication of src2 and (1 - src0), and then stores the final results in dst.
Format:
[(pred)] lrp[.cmod] (exec_size) dst src0 src1 src2
Leading Zero Detection
The lzd instruction counts component-wise the leading zeros from src0 and stores the resulting counts in dst.
If src0 is zero, store 32 in dst.
Format:
[(pred)] lzd[.cmod] (exec_size) dst src0
Multiply Accumulate
The mac instruction takes component-wise multiplication of src0 and src1, adds the results with the corresponding accumulator values, and then stores the final results in dst.
Format:
[(pred)] mac[.cmod] (exec_size) dst src0 src1
mach
Multiply Accumulate High
The mach instruction performs DWord integer multiply-accumulate operation and outputs the high DWord (bits 63:32). For each enabled channel, this instruction multiplies the DWord in src1 with the high word of the DWord in src0, left shifts the result by 16 bits, adds it with the corresponding accumulator values, and keeps the whole 64-bit result in the accumulator. It then stores the high DWord (bits 63:32) of the results in dst.
This instruction is intended to be used to emulate 32-bit DWord integer multiplication by using the large number of bits available in the accumulator. For example, the following four instructions perform vector multiplication of two 32-bit signed integer sources from r2 and r3 and store the resulting vectors with the high 32 bits in r5 and the low 32 bits in r6.
mul (8) acc0:d r2.0<8;8,1>:d r3.0<8;8,1>:d //All channels must be enabled
mach (8) rTemp<1>:d r2.0<8;8,1>:d r3.0<8;8,1>:d //All channels must be enabled
mov (8) r5.0<1>:d rTemp<8;8,1>:d // High 32 bits
mov (8) r6.0<1>:d acc0:d // Low 32 bits
The mul and mach instructions must have all channels enabled. The first mov should have channel enable from the destHI of IMUL, the second mov should have the channel enable from the destLO of IMUL. As mach is used to generate part of the 64-bit DWord integer results, saturation modifier should not be used. In fact, saturation modifier should not be used for any of these four instructions. Source and destination operands must be DWord integers. Source and destination must be of the same type, signed integer or unsigned integer. If dst is UD, src0 and src1 may be UD and/or D. However, if any of src0 and src1 is D, source modifier (abs) must be present to convert it to match with dst. If dst is D, src0 and src1 must also be D. They cannot be UD as it may cause unexpected overflow because the computed results are limited to 64 bits.
Format:
[(pred)] mach[.cmod] (exec_size) dst src0 src1
Multiply Add
The mad instruction takes component-wise multiplication of src1 and src2, adds the results with the corresponding src0 values, and then stores the final results in dst.
The conditional modifier and saturation (.sat) must not be used when src1 or src2 are dwords.
Format:
[(pred)] mad[.cmod] (exec_size) dst src0 src1 src2
math
Extended Math Function
The math instruction performs extended math function on the components in src0, or src0 and src1, and write the output to the channels of dst. The type of extended math function are based on the FC[3:0] encoding in the table below.
Format:
[(pred)] math (exec_size) dst src0 src1 <FC>
MathFC[3:0]
math.cos
Cosine function. cos(src0)
math.exp
Exponential (E^src0)
fdiv
math.fdiv
FDIV
Floating-Point Divide function. src0/src1
idiv
math.idiv
IDIV
Integer Divide with Quotient and Remainder. The quotient goes in the destination register; the remainder goes in the following register.
math.inv
Reciprocal (Multiplicative Inverse): 1/src0
iqot
math.iqot
IQOT
Integer Quotient only
irem
math.irem
IREM
Integer Remainder only
math.log
Natural log: ln(src0)
math.pow
src0^src1
rsqt
math.rsqt
RSQT
Reciprocal Square Root: 1/sqt(src)
math.sin
Sine function. sin(src0)
math.sqt
Square Root
Move
The mov instruction moves the components in src0 into the channels of dst. If src0 and dst are of different types, format conversion is performed. If src0 is a scalar immediate, the immediate value is loaded into enabled channels of dst.
A mov with the same source and destination type, no source modifier, and no saturation is a raw move. A packed byte destination region (B or UB type with HorzStride == 1 and ExecSize > 1) can only be written using raw move.
When denorm mode is flush to zero, a raw mov instruction with saturation modifier will not flush the denorm input or output to zero (Denorm is preserved).
Format: [(pred)] mov[.cmod] (exec_size) dst src0
A mov instruction with a source modifier always copies a denorm source value to a denorm destination value
(in the manner of a raw move).
There is no direct conversion from B/UB to DF or DF to B/UB. Use two instructions and a word or DWord intermediate type.
movi
Move Indexed
The movi instruction performs a fast component-wise indexed move for subfields from src0 to dst. The source
operand must be an indirectly-addressed register. All channels of the source operand share the same register
number, which is provided by the register field of the first address subregister, with a possible immediate
register offset. The register fields of the subsequent address subregisters are ignored by hardware. The
subregister number of a source channel is provided by the subregister field of the corresponding address
subregister, with a possible immediate subregister offset.
The destination register may be either a directly-addressed or an indirectly-addressed register.
This instruction effectively performs a subfield shuffling from one register to another. Up to eight
subfields can be selected by an instruction.
Format: [(pred)] movi (exec_size) dst src0
HW Implementation Details:
The source register is calculated by adding the register portion of the first index register with the
register portion of the address immediate, a0.0[11:5] + addr_imm[9:5]
For byte movi, byte0 of the destination is selected by (a0.0[4:0]), byte1 is selected by (a0.1[4:0]), ...,
and byte7 is selected by (a0.7[4:0]). The rest of the bytes are undefined.
For word movi, byte0 of the destination is selected by (a0.0[4:1] & 0), byte1 is selected by (a0.0[4:1]
& 1), byte2 is selected by (a0.1[4:1] & 0), byte3 is selected by (a0.1[4:1] & 1), ..., and byte15
is selected by (a0.7[4:1] & 1). The rest of the bytes are undefined.
For DWord or float movi, byte0 of the destination is selected by (a0.0[4:2] & 00b), byte1 is selected
by (a0.0[4:2] & 01b), byte2 is selected by (a0.0[4:2] & 10b), byte3 is selected by (a0.0[4:2] &
11b), byte4 is selected by (a0.1[4:2] & 00b), byte5 is selected by (a0.1[4:2] & 01b), ..., byte31
is selected by (a0.7[4:2] & 11b).
For all 3 conditions above, a0.n[4:0] = a0.n[4:0] + addr_imm[4:0].
Multiply
The mul instruction performs component-wise multiplication of src0 and src1 and stores the results in dst.
When both src0 and src1 are of type D or UD, only the low 16 bits of each element of src1 are used. The accumulator maintains full 48-bit precision. The macro described in the mach instruction should be used to obtain the full precision 64-bit multiplication result.
Multiplication of two floating-point numbers follows the rules in mul - Multiply [Pre-DevBDW] or mul - Multiply [Pre-DevBDW]) based on the applicable floating-point mode.
Format:
[(pred)] mul[.cmod] (exec_size) dst src0 src1
No Operation
Do nothing. The nop instruction takes an instruction dispatch but performs no operation. It can be used for assembly patching in memory, or to insert a delay in the program sequence.
Format:
Logic Not
The not instruction performs logical NOT operation (or one's complement) of src0 and storing the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
A register source operand can use a source modifier:
Any source modifier is numeric, optionally changing a source value s to -s, abs(s), or -abs(s) before the NOT operation.
Format:
[(pred)] not[.cmod] (exec_size) dst src0
Logic Or
The or instruction performs component-wise logic OR operation between src0 and src1 and stores the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
Register source operands can use source modifiers:
Any source modifier is numeric, optionally changing a source value s to -s, abs(s), or -abs(s) before the OR operation.
Format:
[(pred)] or[.cmod] (exec_size) dst src0 src1
Plane
The pln instruction computes a component-wise plane equation (w = p*u+q*v+r where u/v/w are vectors and p/q/r are scalars) of src0 and src1 and stores the results in dst. src1 is the input vector u.
src0 provides input scalars p, q, and r, where p is the scalar value based on the region description of src0 and q and r are the scalar values implied from the src0 region. Specifically, q is the second component and r is the fourth component of the 4-tuple (128-bit aligned) that p belongs to.
Format:
[(pred)] pln[.cmod] (exec_size) dst src0 src1
Return
Return execution to the code sequence that called a subroutine.
The ret instruction can be predicated or non-predicated. If non-predicated, all channels jump to the return IP in the first channel of src0 and restore CallMask from the second channel of src0. If predicated, the enabled channels jump to the return IP from the first channel of src0 and the corresponding bits in the CallMask are cleared to zero; if all CallMask bits are zero after the ret instruction, then execution jumps to the return IP from the first channel of src0.
When SPF is on, the predication control must be scalar.
Format:
[(pred)] ret (exec_size) null src0
rndd
Round Down
The rndd instruction takes component-wise floating point downward rounding (to the integral float number closer to negative infinity) of src0 and storing the rounded integral float results in dst. This is commonly referred to as the floor() function.
Each result follows the rules in the following tables based on the floating-point mode.
Format:
[(pred)] rndd[.cmod] (exec_size) dst src0
rnde
Round to Nearest or Even
The rnde instruction takes component-wise floating point round-to-even operation of src0 with results in two pieces - a downward rounded integral float results stored in dst and the round-to-even increments stored in the rounding increment bits. The round-to-even increment must be added to the results in dst to create the final round-to-even values to emulate the round-to-even operation, commonly known as the round() function. The final results are the one of the two integral float values that is nearer to the input values. If the neither possibility is nearer, the even alternative is chosen.
Each result follows the rules in the following tables based on the floating-point mode.
Format:
[(pred)] rnde[.cmod] (exec_size) dst src0
rndu
Round Up
The rndu instruction takes component-wise floating point upward rounding (to the integral float number closer to positive infinity) of src0, commonly known as the ceiling() function.
Each result follows the rules in the following tables based on the floating-point mode.
Format:
[(pred)] rndu[.cmod] (exec_size) dst src0
rndz
Round to Zero
The rndz instruction takes component-wise floating point round-to-zero operation of src0 with results in two pieces - a downward rounded integral float results stored in dst and the round-to-zero increments stored in the rounding increment bits. The round-to-zero increment must be added to the results in dst to create the final round-to-zero values to emulate the round-to-zero operation, commonly known as the truncate() function. The final results are the one of the two closest integral float values to the input values that is nearer to zero.
Format:
[(pred)] rndz[.cmod] (exec_size) dst src0
sad2
Sum of Absolute Difference 2
The sad2 instruction takes source data channels from src0 and src1 in groups of 2-tuples. For each 2-tuple, it computes the sum-of-absolute-difference (SAD) between src0 and src1 and stores the scalar result in the first channel of the 2-tuple in dst.
The results are also stored in the accumulator register. The destination operand and the accumulator maintain 16 bits per channel precision.
The destination register must be aligned to even word (DWord). The even words in the destination region will contain the correct data. The odd words are also written but with undefined values.
Format:
[(pred)] sad2[.cmod] (exec_size) dst src0 src1
sada2
Sum of Absolute Difference Accumulate 2
The sada2 instruction takes source data channels from src0 and src1 in groups of 2-tuples. For each 2-tuple, it computes the sum-of-absolute-difference (SAD) between src0 and src1, adds the intermediate result with the accumulator value corresponding to the first channel, and stores the scalar result in the first channel of the 2-tuple in dst.
The destination operand and the accumulator maintain 16 bits per channel precision. Higher precision (guide bits) stored in the accumulator allows up to 64 rounds of sada2 instructions to be issued back to back without overflowing the accumulator.
The destination register must be aligned to even word (DWord). The even words in the destination region will contain the correct data. The odd words are also written but with undefined values.
Format:
[(pred)] sada2[.cmod] (exec_size) dst src0 src1
Select
The sel instruction selectively moves the components in src0 or src1 into the channels of dst based on the predication. On a channel by channel basis, if the channel condition is true, data in src0 is moved into dst. Otherwise, data in src1 is moved into dst.
As the predication is used to select the two sources, it is not included in the evaluation of WrEn. The predicate clause is mandatory if cmod is omitted/0000b. If both predication and the conditional modifier are omitted, the results are undefined.
If the conditional modifier is specified (not 0000b, a compare is performed and the resulting condition flag is used for the sel instruction. Conditional modifiers .ge and .l follow the cmpn rules, and all other conditional modifiers follow the cmp rules. Predication is not allowed in this mode.
A sel instruction with cmod .l is used to emulate a MIN instruction.
A sel instruction with cmod .ge is used to emulate a MAX instruction.
For a sel instruction with a .l or .ge conditional modifier, if one source is NaN and the other not NaN, the non-NaN source is the result. If both sources are NaNs, the result is NaN. For all other conditional modifiers, if either source is NaN then src1 is selected.
A sel instruction without a conditional modifier always copies a denorm source value to a denorm destination value (in the manner of a raw move). This applies even if the source modifies are set on the sel instruction sources.
The sel instruction uses any conditional modifier internally and does not update the flag register if a conditional modifier is used.
A sel instruction with a conditional modifier flushes any selected denorm source value to a zero destination value.
Format:
(pred) sel[.cmod] (exec_size) dst src0 src1
send
Send Message
Send a message stored in GRF starting at <src> to a shared function identified by <ex_desc> along with control from <desc> with a GRF writeback location at <dest>.
The send instruction performs data communication between a thread and external function units, including shared functions (Sampler, Data Port Read, Data Port Write, URB, and Message Gateway) and some fixed functions (e.g. Thread Spawner, who also have an unique Shared Function ID). The send instruction adds an entry to the EU's message request queue. The request message is stored in a block of contiguous GRF registers. The response message, if present, will be returned to a block of contiguous GRF registers. The return GRF writes may be in any order depending on the external function units. <src> is the lead GRF register for request. <dest> is the lead GRF register for response. The message descriptor field <desc> contains the Message Length (the number of consecutive GRF registers) and the Response Length (the number of consecutive GRF registers). It also contains the header present bit, and the function control signals. The extend mesage descriptor field <ex_desc> contains the target function ID. WrEn is forwarded to the target function in the message sideband.
The send instruction is the only way to terminate a thread. When the EOT (End of Thread) bit of <ex_desc> is set, it indicates the end of thread to the EU, the Thread Dispatcher and, in most cases, the parent fixed function.
Message descriptor field <desc> can be a 32-bit immediate, imm32, or a 32-bit scalar register, <reg32a>. GEN restricts that the 32-bit scalar register <reg32a> must be the leading dword of the address register. It should be in the form of a0.0<0;1,0>:ud. When <desc> is a register operand, only the lower 29 bits of <reg32a> are used.
<ex_desc> is a 6-bit immediate, imm6. The lower 4bits of the <ex_desc> specifies the SFID for the message. The MSb of the message descriptor, the EOT field, always comes from bit 127 of the instruction word, which is the MSb of imm6. A thread must terminate with a send instruction with EOT turned on.
<src> is a 256-bit aligned GRF register. It serves as the leading GRF register of the request.
<dest> serves for two purposes: to provide the leading GRF register location for the response message if present, and to provide parameters to form the channel enable sideband signals.
<dest> signals whether there is a response to the message request. It can be either a null register, a direct-addressed GRF register or a register-indirect GRF register. Otherwise, hardware behavior is undefined.
If <dest> is null, there is no response to the request. Meanwhile, the Response Length field in <desc> must be 0. Certain types of message requests, such as memory write (store) through the Data Port, do not want response data from the function unit. If so, the posted destination operand can be null.
If <dest> is a GRF register, the register number is forwarded to the shared function. In this case, the target function unit must send one or more response message phases back to the requesting thread. The number of response message phases must match the Response Length field in <desc>, which of course cannot be zero. For some cases, it could be an empty return message. An empty return message is defined as a single phase message with all channel enables turned off.
The subregister number, horizontal stride, destination mask and type fields of <dest> are always valid and are used in part to generate on the WrEn. This is true even if <dest> is a null register (this is an exception for null as for most cases these fields are ignored by hardware).
The 16-bit channel enables of the message sideband are formed based on the WrEn. Interpretation of the channel enable sideband signals is subject to the target external function. In general for a 'send' instruction with return messages, they are used as the destination dword write mask for the GRF registers starting at <dest>. For a message that has multiple return phases, the same set of channel enable signals applies to all the return phases.
Thread managed memory coherency: A special usage of using non-null <dest> is to support write-commit signaling for memory write service by the Data Port Write unit. If <post_dest> is not null for a memory write request, the Data Port along with the Data Cache or Render Cache will wait until all the posted writes for the request have reached the coherent domain before sending back to the requesting thread an empty message to <dest> register. A memory write reaching the coherent domain, also referred to as reaching the global observable state, means that subsequent read to the same memory location, no matter which thread issues the read, must return the data of the write.
The destination dependency control, {NoDDClr}, can be used in this instruction. This allows software to control the destination dependencies for multiple 'read'-type messages similar to that for multiple instructions using EU execution pipeline. As send does not check register dependencies for the post destination, {NoDDChk} should not be used for this instruction.
sendc
Conditional Send Message
The sendc instruction has the same behavior as the send instruction except the following.
sendc first checks the dependent threads inside the Thread Dependency Register. There are up to 8 dependent threads in the TDR register. The sendc instruction executes only when all the dependent threads in the TDR register are retired.
Wait for dependencies in the TDR Register to clear, then send a message stored in registers starting at src to a shared function identified by exdesc along with control from desc with a general register writeback location at dst.
Format:
[(pred)] sendc (exec_size) dst src0 exdesc desc
Shift Left
Perform component-wise logical left shift of the bits in src0 by the shift count indicated in src1, storing the results in dst, inserting zero bits in the number of LSBs indicated by the shift count.
Hardware detects overflow properly and uses it to perform any saturation operation on the result, as long as the shifted result is within 33 bits. Otherwise, the result is undefined.
Note: For word and DWord operands, the accumulators have 33 bits.
The shift count is taken from the low five bits of src1, regardless of the src1 type and treated as an unsigned integer in the range 0 to 31.
Format:
[(pred)] shl[.cmod] (exec_size) dst src0 src1
Shift Right
Perform component-wise logical right shift with zero insertion of the bits in src0 by the shift count indicated in src1, storing the results in dst. Insert zero bits in the number of MSBs indicated by the shift count.
src0 and dst can have different types and can be signed or unsigned.
Note: For word and DWord operands, the accumulators have 33 bits.
Note: For unsigned src0 types, shr and asr produce the same result.
The shift count is taken from the low five bits of src1, regardless of the src1 type and treated as an unsigned integer in the range 0 to 31.
Format:
[(pred)] shr[.cmod] (exec_size) dst src0 src1
subb
Integer Subtraction with Borrow
The subb instruction performs component-wise subtraction of src0 and src1 and stores the results in dst, it also stores the borrow into acc.
If the operation produces a borrow (src0 < src1), write 0x00000001 to acc, else write 0x00000000 to acc.
Format:
[(pred)] subb[.cmod] (exec_size) dst src0 src1
wait
Wait Notification
The wait instruction evaluates the value of the notification count register nreg. If nreg is zero, thread execution is suspended and the thread is put in 'wait_for_notification' state. If nreg is not zero (i.e., one or more notifications have been received), nreg is decremented by one and the thread continues executing on the next instruction. If a thread is in the 'wait_for_notification' state, when a notification arrives, the notification count register is incremented by one. As the notification count register becomes nonzero, the thread wakes up to continue execution and at the same time the notification register is decremented by one. If only one notification arrived, the notification register value becomes zero. However, during the above mentioned time period, it is possible that more notifications may arrive, making the notification register nonzero again.
When multiple notifications are received, software must use wait instructions to decrement notification count registers for each notification.
Notification register n0.0:ud is for thread to thread communication (via the Message Gateway shared function) and n0.1:ud for host to thread communication (through MMIO registers). See the Message Gateway chapter for thread-thread communication and the Debug chapter for host-to-thread communication.
Format:
wait (exec_size) nreg
while
While
The while instruction marks the end of a do-while block. The instruction first evaluates the loop termination condition for each channel based on the current channel enables and the predication flags specified in the instruction. If any channel has not terminated, a branch is taken to a destination address specified in the instruction, and the loop continues for those channels. Otherwise, execution continues to the next instruction.ld point to the first instruction with the do label of the do-while block of code. It should be a negative number for the backward referencing.
If SPF is ON, none of the PcIP are updated.
The following table describes the 16-bit jump target offset JIP. JIP is a signed 16-bit number, added to IP pre-increment, and should point to the first instruction with the do label of the do-while block of code. It should be a negative number for the backward referencing. In GEN binary, JIP is at location src1 and must be of type W (signed word integer).
Format:
[(pred)] while (exec_size) JIP
Logic Xor
The xor instruction performs component-wise logic XOR operation between src0 and src1 and stores the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
Register source operands can use source modifiers:
Any source modifier is numeric, optionally changing a source value s to -s, abs(s), or -abs(s) before the XOR operation.
Format:
[(pred)] xor[.cmod] (exec_size) dst src0 src1
The bfi1 instruction is the first instruction in a two-instruction macro for bfi (Bit Field Insert).
The bfi1 instruction component-wise generates mask with control from src0 and src1 and stores the results in dst. The mask is used in the bfi2 instruction to generate the final result of bfi.
Create a bit mask corresponding to the bit field width and offset in src0 and src1. Store the bit mask in dst. The mask has all bits in the bit field set to 1 and all other bits as 0.
The width and offset values are from the low five bits of src0 and src1 respectively, or src0 & 0x1f and src1 & 0x1f.
If width is zero, the result is zero.
The bfi macro has four source operands: src0 - bit field width in low five bits, src1 - bit field offset/starting bit position in low five bits, src2 - bit field value to insert, using only the number of least significant bits given by width in src0, and src3 - overall value into which the bit field is inserted, providing all bits other than the inserted bits for the result value.
bfi dst src0 src1 src2 src3
// Translates to these two instructions:
bfi1 dst src0 src1
bfi2 dst dst src2 src3
Format:
[(pred)] bfi1 (exec_size) dst src0 src1
No accumulator access, implicit or explicit.
The brc instruction redirects the execution forward or backward to the instruction pointed by (current IP + offset). The jump will occur if all channels are branched away.
UIP should reference the instruction where all channels are expected to come together. JIP should reference the end of the innermost conditional block.
In GEN binary, JIP and UIP use locations src1 and src0 respectively when immediate and location src0 when reg64, where reg64 is accessed as paired DWord (regioning being <2;2,1>). dst must be IP. When the offsets are immediate, src0 regfile must be immediate.
Format:
[(pred)] brc (exec_size) JIP UIP
The break instruction is used to early-out from the inner most loop, or early out from the inner most switch block.
When used in a loop, upon execution, the break instruction terminates the loop for all execution channels enabled. If all the enabled channels hit the break instruction, jump to the instruction referenced by JIP. JIP should be the offset to the end of the inner most conditional or loop block, UIP should be the offset to the while instruction of the loop block.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case
The following table describes the two 32-bit instruction pointer offsets. Both the JIP and UIP are signed 32-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at locations src0 and src1 and must be of type DW (signed DWord integer). When the offsets are immediate, src0 regfile must be immediate.
Format:
[(pred)] break (exec_size) JIP UIP
The cont instruction disables execution for the subset of channels for the remainder of the current loop iteration. Channels remain disabled until right before the while instuction or right before the condition check code block for the while instruction. If all enabled channels hit this instruction, jump to the instruction referenced by JIP where execution continues.
UIP should always reference the loop's associated while instruction. JIP should point to the last instruction of the inner most conditional block if the cont instruction is inside a conditional block. In case of the break instruction directly under the loop, the JIP and the UIP are the same.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the two 32-bit instruction pointer offsets. Both the JIP and UIP are signed 32-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at locations src0 and src1 and must be of type DW (signed DWord integer). When the offsets are immediate, src0 regfile must be immediate.
Format:
[(pred)] cont (exec_size) JIP UIP
csel
Conditional Select
The csel instruction selectively moves components in src0 or src1 to the dst based on the result of the compare of src2 with zero. If the channel condition is true, data in src0 is moved into dst. Otherwise, data in src1 is moved into dst. The csel instruction provides the function of a cmp followed by sel. The instruction must not be used if cmpn is required. The instruction does not update the flag register.
The comparison follows the same rule as cmp instruction for that data type.
Format:
csel (exec_size) dst src0 src1 src2
The else instruction is an optional statement within an if/else/endif block of code. It restricts execution within the else/endif portion to the opposite set of channels enabled under the if/else portion. Channels which were inactive prior to entering the if/endif block remain inactive throughout the entire block.
All enabled channels upon arriving the else instruction will be redirected to the matching endif. If all channels are redirected (by else or before else), a relative jump is performed to the location specified by  <JIP>. The jump target should be the matching endif instruction for that conditional block.
The following table describes the 32-bit <JIP>. In GEN binary, <JIP> is at location <src1> and must be of type D (signed dword integer). <JIP> must be an immediate operand, it is a signed 32-bit number and is intended to be forward referencing. This value is added to IP pre-increment.
If the <branch_ctrl> bit is set, then the <JIP> points to the first join instruction within the else block and <UIP> points to the endif instruction. If the <branch_ctrl> bit is not set,  <JIP> and <UIP>, both point to endif.
Format:
else (exec_size) JIP  UIP  branch_ctrl
An else instruction must not be followed by any instruction requiring register indirect access on source operands
If all channels are redirected (by else or before else), relative jump is performed to the location specified by <JIP> + 1.
The endif instruction terminates an if/else/endif block of code. It restores execution to the channels that were active prior to the if/else/endif block.
The endif instruction is also used to hop out of nested conditionals by jumping to the end of the next outer conditional block when all channels are disabled.
The following table describes the 32-bit JIP. In GEN binary, JIP is at location src1 and must be of type D (signed DWord integer). JIP must be an immediate operand, it is a signed 32-bit number. This value is added to IP pre-increment.
Format:
endif JIP
goto
Goto
The goto instruction directs the instruction pointer to the offset specified by the UIP offset or to the next IP based on the BranchCtrl bit in the instruction. The active channels that are predicated on this instruction will take the IP + UIP path when BranchCtrl is set else the channels take IP + 1. The active channels that are not predicated on this instruction will be made inactive and waiting to be joined at the join IP. The join IP is IP + UIP when BranchCtrl is clear else it is the next IP.
When there are no active channels the instruction pointer will move to IP + JIP.
The goto instruction is used in conjunction with a join instruction. A goto deactivates some channels that are reactivated at some program-specified join instruction. See the join instruction for the activation rules.
The goto and join instructions enable unstructured program control flow. These instructions must be used with additional care where dangling channels can result without proper compiler checks, meaning that it is expected that programs will navigate through these paths to reactivate the channels. Hardware does not provide native checks or reconvergence.
The following table describes the two 32-bit instruction pointer offsets. Both the JIP and UIP are signed 32-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at locations src0 and src1 and must be of type DW (signed DWord integer).
If SPF is ON, none of the PcIP are updated.
Format:
[(pred)] goto (exec_size) JIP UIP branch_ctrl
The halt instruction temporarily suspends execution for all enabled compute channels. Upon execution, the enabled channels are sent to the instruction at (IP + UIP), if all channels are enabled at HALT, jump to the instruction at (IP + JIP).
If the halt instruction is not inside any conditional code block, the values of JIP and UIP should be the same. If the halt instruction is inside a conditional code block, the UIP should be the end of the program and the JIP should be the end of the inner most conditional code block.
The UIP must point to a HALT Instruction.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the two 32-bit instruction pointer offsets. Both the JIP and UIP are signed 32-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at locations src0 and src1 and must be of type DW (signed DWord integer). When the offsets are immediate, src0 regfile must be immediate and dst must be null.
Format:
[(pred)] halt (exec_size) JIP UIP
An if instruction starts an if/endif or an if/else/endif block of code. It restricts execution within the conditional block to only those channels that were enabled via the predicate control.
Each if instruction must have a matching endif instruction and may have up to one matching else instruction before the matching endif.
If all channels are inactive (for the if/endif or if/else/endif block), a jump is performed to the instruction referenced by JIP. This jump must be to right after the matching else instruction when present, or otherwise to the matching endif instruction of the conditional block.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the 32-bit exit code <JIP> and <UIP>. If <branch_ctrl> is set, then the JIP points to the first join instruction within the if block. If <branch_ctrl> is not set, <JIP> should point to the instruction right after the matching else instruction if it exsits, otherwise <JIP> should point to the endif instruction. <UIP> should always point to the endif instruction. When a jump occurs, this value is added to IP pre-increment. In GEN instruction binary, <JIP> and <UIP> are at location <src0> & <src1> and must be of type D (signed dword integer).
Format:
[(pred)] if (exec_size JIP UIP <branch_ctrl>
join
Join
The join instruction makes the inactive channels active at the join IP if those channels are predicated. Any deactivated channels due to a goto instruction match the join IP are activated (qualified with predicates at join). If no IP is matched at this join, the program goes to the next IP with the active channels which followed the program path up to the join instruction. If no active channels are present after executing the join instruction, the program jumps to the offset specified by JIP instead of next IP.
The join instruction is used in conjunction with a goto instruction. The join activates channels that are deactivated by the goto instruction. See the goto instruction for the deactivation rules.
The goto and join instructions enable unstructured program control flow. These instructions must be used with additional care where dangling channels can result without proper compiler checks, meaning that it is expected that programs will navigate through these paths to reactivate the channels. Hardware does not provide native checks or reconvergence.
The following table describes the 32-bit JIP. In GEN binary, JIP is at location src1 and must be of type D (signed DWord integer). JIP must be an immediate operand and is a signed 32-bit number. This value is added to IP pre-increment.
If SPF is ON, none of the PcIP are updated.
Format:
[(pred)] join (exec_size) JIP
An index of 0 is an infinite loop.
The mach instruction performs DWord integer multiply-accumulate operation and outputs the high DWord (bits 63:32). For each enabled channel, this instruction multiplies the DWord in src0 with the high word of the DWord in src1, left shifts the result by 16 bits, adds it with the corresponding accumulator values, and keeps the whole 64-bit result in the accumulator. It then stores the high DWord (bits 63:32) of the results in dst. This instruction is intended to be used to emulate 32-bit DWord integer multiplication by using the large number of bits available in the accumulator. For example, the following instructions perform vector multiplication of two 32-bit signed integer sources from r2 and r3 and store the resulting vectors with the high 32 bits in r5 and the low 32 bits in r6.
mul (8) acc0:d r2.0<8;8,1>:d r3.0<16;8,2>:uw
mach (8) r5.0<1>:d r2.0<8;8,1>:d r3.0<8;8,1>:d
mov (8) r6.0<1>:d acc0:d // Low 32 bits.
Here is a different example including negation. An added preliminary mov is required for source modification on src1.
mov (8) r3.0<1>:d -r3<8;8,1>:d
mul (8) acc0:d r2.0<8;8,1>:d r3.0<16;8,2>:uw
mach (8) r5.0<1>:d r2.0<8;8,1>:d r3.0<8;8,1>:d // High 32 bits
mov (8) r6.0<1>:d acc0:d // Low 32 bits.
The mach should have channel enable from the destHI of IMUL, the mov should have the channel enable from the destLO of IMUL. As mach is used to generate part of the 64-bit DWord integer results, saturation modifier should not be used. In fact, saturation modifier should not be used for any of these four instructions. Source and destination operands must be DWord integers. Source and destination must be of the same type, signed integer or unsigned integer. If dst is UD, src0 and src1 may be UD and/or D. However, if any of src0 and src1 is D, source modifier (abs) must be present to convert it to match with dst. If dst is D, src0 and src1 must also be D. They cannot be UD as it may cause unexpected overflow because the computed results are limited to 64 bits.
Format:
[(pred)] mach[.cmod] (exec_size) dst src0 src1
madm
Multiply Add for Macro
The madm instruction takes component-wise multiplication of src1 and src2, adds the results with the corresponding src0 values, and then stores the final results in dst.
The source and destination operands have a higher precision carried in the exponent for this operation. The madm instruction is used for macro operations, where precision is accumulated over several instructions. This accumulation requires the exponent to increase by 2 extra bits across multiple madm operations.
Refer to Macros Defined in 'Math' Section for usage and restrictions of this operation.
Format:
[(pred)] madm[.cmod] (exec_size) dst src0 src1 src2
invm
math.invm
INVM
Reciprocal Macro for IEEE754-compliant fdiv
rsqtm
math.rsqtm
RSQTM
Reciprocal Square Root Macro for IEEE754-compliant rsqt
The mov instruction moves the components in src0 into the channels of dst. If src0 and dst are of different types, format conversion is performed. If src0 is a scalar immediate, the immediate value is loaded into enabled channels of dst.
A mov with the same source and destination type, no source modifier, and no saturation is a raw move. A packed byte destination region (B or UB type with HorzStride == 1 and ExecSize > 1) can only be written using raw move.
When denorm mode is flush to zero, a raw mov instruction with saturation modifier will not flush the denorm input or output to zero (Denorm is preserved).
Format: [(pred)] mov[.cmod] (exec_size) dst src0
A mov instruction with a source modifier always copies a denorm source value to a denorm destination value
(in the manner of a raw move).
There is no direct conversion from B/UB to DF or DF to B/UB. Use two instructions and a word or DWord intermediate type.
There is no direct conversion from B/UB to Q/UQ or Q/UQ to B/UB. Use two instructions and a word or DWord intermediate integer type.
There is no direct conversion from HF to DF or DF to HF. Use two instructions and F (Float) as an intermediate type.
There is no direct conversion from HF to Q/UQ or Q/UQ to HF. Use two instructions and F (Float) or a word integer type or a DWord integer type as an intermediate type.
The mul instruction performs component-wise multiplication of src0 and src1 and stores the results in dst. When multiplying integer datatypes, if src0 is DW and src1 is W, irrespective of the destination datatype, the accumulator maintains full 48-bit precision. This is required to handle the macro for 32x32 multiplication. The macro described in the mach instruction should be used to obtain the full precision 64-bit multiplication results.
Note: A 32x32 multiply operation is handled natively, without a macro. When operating in this mode, the resulting 64-bit data is packed, unlike the macro, where the lower and upper 32 bits of the result are written to different general registers by two separate instructions. Refer to the macro description for details.
When multiplying integer data types, if one of the sources is a DW, the resulting full precision data is stored in the accumulator. However, if the destination data type is either W or DW, the low bits of the result are written to the destination register and the remaining high bits are discarded. This results in undefined Overflow and Sign flags. Therefore, conditional modifiers and saturation (.sat) cannot be used in this case.
Format:
[(pred)] mul[.cmod] (exec_size) dst src0 src1
The not instruction performs logical NOT operation (or one's complement) of src0 and storing the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
A register source operand can use a source modifier:
Any source modifier is logical, optionally changing a source value s to ~s (inverting all source bits). Such a source modifier is not particularly useful with the not instruction, as it changes the effect of not to just copying bits.
Format:
[(pred)] not[.cmod] (exec_size) dst src0
The or instruction performs component-wise logic OR operation between src0 and src1 and stores the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
Register source operands can use source modifiers:
Any source modifier is logical, optionally changing a source value s to ~s (inverting all source bits). This capability allows expressions like a OR (NOT b) to be calculated with one instruction.
Format:
[(pred)] or[.cmod] (exec_size) dst src0 src1
The sel instruction selectively moves the components in src0 or src1 into the channels of dst based on the predication. On a channel by channel basis, if the channel condition is true, data in src0 is moved into dst. Otherwise, data in src1 is moved into dst.
As the predication is used to select the two sources, it is not included in the evaluation of WrEn. The predicate clause is mandatory if cmod is omitted/0000b. If both predication and the conditional modifier are omitted, the results are undefined.
If the conditional modifier is specified (not 0000b, a compare is performed and the resulting condition flag is used for the sel instruction. Conditional modifiers .ge and .l follow the cmpn rules, and all other conditional modifiers follow the cmp rules. Predication is not allowed in this mode.
A sel instruction with cmod .l is used to emulate a MIN instruction.
A sel instruction with cmod .ge is used to emulate a MAX instruction.
For a sel instruction with a .l or .ge conditional modifier, if one source is NaN and the other not NaN, the non-NaN source is the result. If both sources are NaNs, the result is NaN. For all other conditional modifiers, if either source is NaN then src1 is selected.
A sel instruction without a conditional modifier always copies a denorm source value to a denorm destination value (in the manner of a raw move). This applies even if the source modifies are set on the sel instruction sources.
The sel instruction uses any conditional modifier internally and does not update the flag register if a conditional modifier is used.
A sel instruction with cmod or source modifier will flush denorm to zero, depending on the denorm mode bit; a sel instruction without cmod and source modifier will retain denorm.
Format:
(pred) sel[.cmod] (exec_size) dst src0 src1
Send a message stored in GRF starting at <src> to a shared function identified by <ex_desc> along with control from <desc> with a GRF writeback location at <dest>.
The send instruction performs data communication between a thread and external function units, including shared functions (Sampler, Data Port Read, Data Port Write, URB, and Message Gateway) and some fixed functions (e.g. Thread Spawner, who also have an unique Shared Function ID). The send instruction adds an entry to the EU's message request queue. The request message is stored in a block of contiguous GRF registers. The response message, if present, will be returned to a block of contiguous GRF registers. The return GRF writes may be in any order depending on the external function units. <src> is the lead GRF register for request. <dest> is the lead GRF register for response. The message descriptor field <desc> contains the Message Length (the number of consecutive GRF registers) and the Response Length (the number of consecutive GRF registers). It also contains the header present bit, and the function control signals. The extend mesage descriptor field <ex_desc> contains the target function ID. WrEn is forwarded to the target function in the message sideband.
The send instruction is the only way to terminate a thread. When the EOT (End of Thread) bit of <ex_desc> is set, it indicates the end of thread to the EU, the Thread Dispatcher and, in most cases, the parent fixed function.
Message descriptor field <desc> can be a 32-bit immediate, imm32, or a 32-bit scalar register, <reg32a>. GEN restricts that the 32-bit scalar register <reg32a> must be the leading dword of the address register. It should be in the form of a0.0<0;1,0>:ud. When <desc> is a register operand, only the lower 29 bits of <reg32a> are used.
<ex_desc> is a 6-bit immediate, imm6. The lower 4bits of the <ex_desc> specifies the SFID for the message. The MSb of the message descriptor, the EOT field, always comes from bit 127 of the instruction word, which is the MSb of imm6. A thread must terminate with a send instruction with EOT turned on.
<src> is a 256-bit aligned GRF register. It serves as the leading GRF register of the request.
<dest> serves for two purposes: to provide the leading GRF register location for the response message if present, and to provide parameters to form the channel enable sideband signals. <dest> signals whether there is a response to the message request. It can be either a null register, a direct-addressed GRF register or a register-indirect GRF register. Otherwise, hardware behavior is undefined. If <dest> is null, there is no response to the request. Meanwhile, the Response Length field in <desc> must be 0. Certain types of message requests, such as memory write (store) through the Data Port, do not want response data from the function unit. If so, the posted destination operand can be null. If <dest> is a GRF register, the register number is forwarded to the shared function. In this case, the target function unit must send one or more response message phases back to the requesting thread. The number of response message phases must match the Response Length field in <desc>, which of course cannot be zero. For some cases, it could be an empty return message. An empty return message is defined as a single phase message with all channel enables turned off. The subregister number, horizontal stride, destination mask and type fields of <dest> are always valid and are used in part to generate on the WrEn. This is true even if <dest> is a null register (this is an exception for null as for most cases these fields are ignored by hardware). The 16-bit channel enables of the message sideband are formed based on the WrEn. Interpretation of the channel enable sideband signals is subject to the target external function. In general for a 'send' instruction with return messages, they are used as the destination dword write mask for the GRF registers starting at <dest>. For a message that has multiple return phases, the same set of channel enable signals applies to all the return phases. The destination dependency control, {NoDDClr}, can be used in this instruction. This allows software to control the destination dependencies for multiple 'read'-type messages similar to that for multiple instructions using EU execution pipeline. As send does not check register dependencies for the post destination, {NoDDChk} should not be used for this instruction.
Thread managed memory coherency: A special usage of using non-null <dest> is to support write-commit signaling for memory write service by the Data Port Write unit. If <post_dest> is not null for a memory write request, the Data Port along with the Data Cache or Render Cache will wait until all the posted writes for the request have reached the coherent domain before sending back to the requesting thread an empty message to <dest> register. A memory write reaching the coherent domain, also referred to as reaching the global observable state, means that subsequent read to the same memory location, no matter which thread issues the read, must return the data of the write.
Perform component-wise logical left shift of the bits in src0 by the shift count indicated in src1, storing the results in dst, inserting zero bits in the number of LSBs indicated by the shift count.
Hardware detects overflow properly and uses it to perform any saturation operation on the result, as long as the shifted result is within 33 bits. Otherwise, the result is undefined.
Note: For word and DWord operands, the accumulators have 33 bits.
In QWord mode, the shift count is taken from the low six bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 63. Otherwise the shift count is taken from the low five bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 31. The operation uses QWord mode if src0 or dst has the Q or UQ type but not if src1 is the only operand with the Q or UQ type.
Format:
[(pred)] shl[.cmod] (exec_size) dst src0 src1
Perform component-wise logical right shift with zero insertion of the bits in src0 by the shift count indicated in src1, storing the results in dst. Insert zero bits in the number of MSBs indicated by the shift count.
src0 and dst can have different types and can be signed or unsigned.
Note: For word and DWord operands, the accumulators have 33 bits.
Note: For unsigned src0 types, shr and asr produce the same result.
In QWord mode, the shift count is taken from the low six bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 63. Otherwise the shift count is taken from the low five bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 31. The operation uses QWord mode if src0 or dst has the Q or UQ type but not if src1 is the only operand with the Q or UQ type.
Format:
[(pred)] shr[.cmod] (exec_size) dst src0 src1
smov
Scattered Move
The smov instruction moves the components in src0 into dst.
For each enabled channel, copy src0 to dst. The immediate is used to selectively enable channels without using flags.
When predication is enabled, the predicate mask is not generated from the flags. Instead, the immediate is used to mask the execution mask. If any channel is enabled as a result of this masking, the instruction is executed.
When predication is not enabled, the immediate masks the execution mask. This provides flexibility to mask out any channel with an immediate.
Format:
[(pred)] smov[.cmod] (exec_size) dst src0 src1
When predication is disabled, the immediate provides the flexibility to perform a select operation without the use of flags.
When predication is enabled, the usage model provides flexibility to select any bit in the flag registers for predication for execution size of 1.
The while instruction marks the end of a do-while block. The instruction first evaluates the loop termination condition for each channel based on the current channel enables and the predication flags specified in the instruction. If any channel has not terminated, a branch is taken to a destination address specified in the instruction, and the loop continues for those channels. Otherwise, execution continues to the next instruction.ld point to the first instruction with the do label of the do-while block of code. It should be a negative number for the backward referencing.
If SPF is ON, none of the PcIP are updated.
The following table describes the 32-bit jump target offset JIP. JIP is a signed 32-bit number, added to IP pre-increment, and should point to the first instruction with the do label of the do-while block of code. It should be a negative number for the backward referencing. In GEN binary, JIP is at location src1 and must be of type D (signed dword integer).
Format:
[(pred)] while (exec_size) JIP
The xor instruction performs component-wise logic XOR operation between src0 and src1 and stores the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
Register source operands can use source modifiers:
Any source modifier is logical, optionally changing a source value s to ~s (inverting all source bits). This capability allows expressions like a XOR (NOT b) to be calculated with one instruction.
Format:
[(pred)] xor[.cmod] (exec_size) dst src0 src1
The call instruction jumps to a subroutine. It can be predicated or non-predicated. If non-predicated, all enabled channels jump to the subroutine. If predicated, only the channels enabled by PMask jump to the subroutine; the rest of the channels move to the next instruction after the call instruction. If none of the channels jump into the subroutine, the call instruction is treated as a nop.
In case of a jump, the call instruction stores the return IP onto the first DWord of the destination register and stores the CallMask in the second DWord of the destination register.
When SPF is on, the predication control must be scalar.
The following section describes JIP, the jump offset, for DevSKL+.
JIP can be an immediate or register value. When a jump occurs, this value is added to IP pre-increment. In GEN binary, JIP is at location src1 and src0 must be null. The GRF register must be put (for example, by the assembler) at dst location.
Format: [(pred)] call (exec_size) dst JIP
Format: [(pred)] call (exec_size) dst JIP
The mac instruction takes component-wise multiplication of src0 and src1, adds the results with the corresponding accumulator values, and then stores the final results in dst.
Format:
[(pred)] mac[.cmod] (exec_size) dst src0 src1
When source and destination datatypes are different, the implied datatype for the accumulator operand is always the destination datatype.
Send a message stored in GRF starting at <src> to a shared function identified by <ex_desc> along with control from <desc> with a GRF writeback location at <dest>.
The send instruction performs data communication between a thread and external function units, including shared functions (Sampler, Data Port Read, Data Port Write, URB, and Message Gateway) and some fixed functions (e.g. Thread Spawner, who also have an unique Shared Function ID). The send instruction adds an entry to the EU's message request queue. The request message is stored in a block of contiguous GRF registers. The response message, if present, will be returned to a block of contiguous GRF registers. The return GRF writes may be in any order depending on the external function units. <src> is the lead GRF register for request. <dest> is the lead GRF register for response. The message descriptor field <desc> contains the Message Length (the number of consecutive GRF registers) and the Response Length (the number of consecutive GRF registers). It also contains the header present bit, and the function control signals. The extend mesage descriptor field <ex_desc> contains the target function ID. WrEn is forwarded to the target function in the message sideband.
The extended message descriptor field <ex_desc> also contains the extended function control field to be sent to the Target Shared Function over message sideband.
The send instruction is the only way to terminate a thread. When the EOT (End of Thread) bit of <ex_desc> is set, it indicates the end of thread to the EU, the Thread Dispatcher and, in most cases, the parent fixed function.
Message descriptor field <desc> can be a 32-bit immediate, imm32, or a 32-bit scalar register, <reg32a>. GEN restricts that the 32-bit scalar register <reg32a> must be the leading dword of the address register. It should be in the form of a0.0<0;1,0>:ud. When <desc> is a register operand, only the lower 29 bits of <reg32a> are used.
<ex_desc> is a 32-bit immediate, imm32. The lower 4bits of the <ex_desc> specifies the SFID for the message. The bit5 of the extended message descriptor, the EOT field, always comes from bit 127 of the instruction word. A thread must terminate with a send instruction with EOT turned on. The higher 16bits, bit31:16 specify the 16bit extended function control field. Interpretation of the extended function control signals is subject to the target external function.
<src> is a 256-bit aligned GRF register. It serves as the leading GRF register of the request.
The source dependency control, {NoSrcDepSet} is used to control the setting of source dependency for the source.
<dest> serves for two purposes: to provide the leading GRF register location for the response message if present, and to provide parameters to form the channel enable sideband signals. <dest> signals whether there is a response to the message request. It can be either a null register, a direct-addressed GRF register or a register-indirect GRF register. Otherwise, hardware behavior is undefined. If <dest> is null, there is no response to the request. Meanwhile, the Response Length field in <desc> must be 0. Certain types of message requests, such as memory write (store) through the Data Port, do not want response data from the function unit. If so, the posted destination operand can be null. If <dest> is a GRF register, the register number is forwarded to the shared function. In this case, the target function unit must send one or more response message phases back to the requesting thread. The number of response message phases must match the Response Length field in <desc>, which of course cannot be zero. For some cases, it could be an empty return message. An empty return message is defined as a single phase message with all channel enables turned off. The subregister number, horizontal stride, destination mask and type fields of <dest> are always valid and are used in part to generate on the WrEn. This is true even if <dest> is a null register (this is an exception for null as for most cases these fields are ignored by hardware). The 16-bit channel enables of the message sideband are formed based on the WrEn. Interpretation of the channel enable sideband signals is subject to the target external function. In general for a 'send' instruction with return messages, they are used as the destination dword write mask for the GRF registers starting at <dest>. For a message that has multiple return phases, the same set of channel enable signals applies to all the return phases. The destination dependency control, {NoDDClr}, can be used in this instruction. This allows software to control the destination dependencies for multiple 'read'-type messages similar to that for multiple instructions using EU execution pipeline. As send does not check register dependencies for the post destination, {NoDDChk} should not be used for this instruction.
sends
Split Send Message
The sends instruction performs data communication between a thread and external function units, including shared functions (Sampler, Data Port Read, Data Port Write, URB, and Message Gateway) and some fixed functions (e.g. Thread Spawner, who also have an unique Shared Function ID). The sends instruction adds an entry to the EU's message request queue. The request message is stored in a block of contiguous GRF registers. The response message, if present, will be returned to a block of contiguous GRF registers. The return GRF writes may be in any order depending on the external function units. <src0> and <src1> are the lead GRF registers for the first and second block of the request respectively. <dest> is the lead GRF register for response. The message descriptor field <desc> contains the Message Length (the number of consecutive GRF registers corresponding to src0) and the Response Length (the number of consecutive GRF registers). It also contains the header present bit, and the function control signals. The extend message descriptor field <ex_desc> contains the target function ID, the Extended Message Length (the number of consecutive GRF registers corresponding to src1) and the extended function control signals. WrEn is forwarded to the target function in the message sideband.
The sends instruction is the only way to terminate a thread. When the EOT (End of Thread) bit of <ex_desc> is set, it indicates the end of thread to the EU, the Thread Dispatcher and, in most cases, the parent fixed function.
Message descriptor field <desc> can be a 32-bit immediate, imm32, or a 32-bit scalar register, <reg32a>. GEN restricts that the 32-bit scalar register <reg32a> must be the leading dword of the address register. It should be in the form of a0.0<0;1,0>:ud. When <desc> is a register operand, only the lower 31 bits of <reg32a> are used.
Extended Message descriptor field <ex_desc> can be a 32-bit immediate, imm32 only. The bits3:0 of the <ex_desc> specifies the SFID for the message.The EOT field always comes from bit127 of the instruction word, which is the bit5 of <ex_desc>. A thread must terminate with a sends instruction with EOT turned on. The bits9:6 of <ex_desc> specify the extended message length and bits31:16 specify the 16bit extended function control. Interpretation of the extended function control signals is subject to the target external function.</ex_desc></ex_desc></ex_desc></ex_desc>
Extended Message descriptor field <ex_desc> can be a 32-bit immediate, imm32 or a 32bit scalar register, <reg32a>. The bits3:0 of the <ex_desc> specifies the SFID for the message.The EOT field always comes from bit127 of the instruction word, which is the bit5 of <ex_desc>. A thread must terminate with a sends instruction with EOT turned on. The bits9:6 of <ex_desc> specify the extended message length and bits31:12 specify the 20bit extended function control. Interpretation of the extended function control signals is subject to the target external function. The scalar register <reg32a> is selected when SelReg32ExDesc is set, ExDesc.RegNum[3:0] provides the addressing for reg32a for extended message descriptor. This selects one of the index sub registers. Subregisters selected are always aligned to dword. This implies, the even index subregisters must be used.</reg32a></ex_desc></ex_desc></ex_desc></reg32a></ex_desc>
Function control is now extended to 20 bits as specified in the below definition.
<src0> is a 256-bit aligned GRF register. It serves as the leading GRF register of the request.
<src1> is a 256-bit aligned GRF register or a null register. It serves as the leading GRF register for the second block of the request when it is not a null register. It is required that the second block of GRFs does not overlap with the first block. If it is a null register the Extended Message Length must be 0. The sum of Message Length and Extended Message Length must not be greater than 15 on SKL.
The source dependency control, {NoSrcDepSet} is used to control the setting of source dependency for both the sources.
<dest> serves for two purposes: to provide the leading GRF register location for the response message if present, and to provide parameters to form the channel enable sideband signals.
<dest> signals whether there is a response to the message request. It can be either a null register, a direct-addressed GRF register or a register-indirect GRF register. Otherwise, hardware behavior is undefined.
If <dest> is null, there is no response to the request. Meanwhile, the Response Length field in <desc> must be 0. Certain types of message requests, such as memory write (store) through the Data Port, do not want response data from the function unit. If so, the posted destination operand can be null.
If <dest> is a GRF register, the register number is forwarded to the shared function. In this case, the target function unit must send one or more response message phases back to the requesting thread. The number of response message phases must match the Response Length field in <desc>, which of course cannot be zero. For some cases, it could be an empty return message. An empty return message is defined as a single phase message with all channel enables turned off.
The destination type field is always valid and is used to generate the WrEn. This is true even if <dest> is a null register (this is an exception for null as for most cases these fields are ignored by hardware).
The address immediates for indirect sources and destination must be oword aligned.
The 16-bit channel enables of the message sideband are formed based on the WrEn. Interpretation of the channel enable sideband signals is subject to the target external function. In general for a 'sends' instruction with return messages, they are used as the destination dword write mask for the GRF registers starting at <dest>. For a message that has multiple return phases, the same set of channel enable signals applies to all the return phases.
NoDDClr and NoDDChk must not be used for send instruction.
Send a message stored in GRF locations starting at <src0> followed by <src1> to a shared function identified by <ex_desc> along with control from <desc> and <ex_desc> with a GRF writeback location at <dest>.
Format:
[(pred)] sends (exec_size) <dest> <src0> <src1> <ex_desc> <desc>
sendsc
Conditional Split Send Message
The sendsc instruction has the same behavior as the sends instruction except the following.
sendsc first checks the dependent threads inside the Thread Dependency Register. There are up to 8 dependent threads in the TDR register. The sendsc instruction executes only when all the dependent threads in the TDR register are retired.
Wait for dependencies in the TDR Register to clear, then send a message stored in GRF locations starting at <src0> followed by <src1> to a shared function identified by <ex_desc> along with control from <desc> and <ex_desc> with a GRF writeback location at <dest>.
Format:
[(pred)] sendsc (exec_size) <dest> <src0> <src1> <ex_desc> <desc>
The while instruction marks the end of a do-while block. The instruction first evaluates the loop termination condition for each channel based on the current channel enables and the predication flags specified in the instruction. If any channel has not terminated, a branch is taken to a destination address specified in the instruction, and the loop continues for those channels. Otherwise, execution continues to the next instruction.ld point to the first instruction with the do label of the do-while block of code. It should be a negative number for the backward referencing.
If SPF is ON, none of the PcIP are updated.
Format:
[(pred)] while (exec_size) JIP
The csel instruction selectively moves components in src0 or src1 to the dst based on the result of the compare of src2 with zero. If the channel condition is true, data in src0 is moved into dst. Otherwise, data in src1 is moved into dst. The csel instruction provides the function of a cmp followed by sel. The instruction must not be used if cmpn is required. The instruction does not update the flag register.
The comparison follows the same rule as cmp instruction for that data type.
When Access Mode is Align1, accumulator may be used as source or destination.
Format:
csel (exec_size) dst src0 src1 src2
The sends instruction performs data communication between a thread and external function units, including shared functions (Sampler, Data Port Read, Data Port Write, URB, and Message Gateway) and some fixed functions (e.g. Thread Spawner, who also have an unique Shared Function ID). The sends instruction adds an entry to the EU's message request queue. The request message is stored in a block of contiguous GRF registers. The response message, if present, will be returned to a block of contiguous GRF registers. The return GRF writes may be in any order depending on the external function units. <src0> and <src1> are the lead GRF registers for the first and second block of the request respectively. <dest> is the lead GRF register for response. The message descriptor field <desc> contains the Message Length (the number of consecutive GRF registers corresponding to src0) and the Response Length (the number of consecutive GRF registers). It also contains the header present bit, and the function control signals. The extend message descriptor field <ex_desc> contains the target function ID, the Extended Message Length (the number of consecutive GRF registers corresponding to src1) and the extended function control signals. WrEn is forwarded to the target function in the message sideband.
The sends instruction is the only way to terminate a thread. When the EOT (End of Thread) bit of <ex_desc> is set, it indicates the end of thread to the EU, the Thread Dispatcher and, in most cases, the parent fixed function.
Message descriptor field <desc> can be a 32-bit immediate, imm32, or a 32-bit scalar register, <reg32a>. GEN restricts that the 32-bit scalar register <reg32a> must be the leading dword of the address register. It should be in the form of a0.0<0;1,0>:ud. When <desc> is a register operand, only the lower 31 bits of <reg32a> are used.
Extended Message descriptor field <ex_desc> can be a 32-bit immediate, imm32 only. The bits3:0 of the <ex_desc> specifies the SFID for the message.The EOT field always comes from bit127 of the instruction word, which is the bit5 of <ex_desc>. A thread must terminate with a sends instruction with EOT turned on. The bits9:6 of <ex_desc> specify the extended message length and bits31:16 specify the 16bit extended function control. Interpretation of the extended function control signals is subject to the target external function.</ex_desc></ex_desc></ex_desc></ex_desc>
Extended Message descriptor field <ex_desc> can be a 32-bit immediate, imm32 or a 32bit scalar register, <reg32a>. The bits3:0 of the <ex_desc> specifies the SFID for the message.The EOT field always comes from bit127 of the instruction word, which is the bit5 of <ex_desc>. A thread must terminate with a sends instruction with EOT turned on. The bits9:6 of <ex_desc> specify the extended message length and bits31:12 specify the 20bit extended function control. Interpretation of the extended function control signals is subject to the target external function. The scalar register <reg32a> is selected when SelReg32ExDesc is set, ExDesc.RegNum[3:0] provides the addressing for reg32a for extended message descriptor. This selects one of the index sub registers. Subregisters selected are always aligned to dword. This implies, the even index subregisters must be used.</reg32a></ex_desc></ex_desc></ex_desc></reg32a></ex_desc>
Function control is now extended to 20 bits as specified in the below definition.
Function control is now extended to 20 bits as specified in the below definition.
The sum of Message Length and Extended Message Length must not be greater than 31.
<src0> is a 256-bit aligned GRF register. It serves as the leading GRF register of the request.
<src1> is a 256-bit aligned GRF register or a null register. It serves as the leading GRF register for the second block of the request when it is not a null register. It is required that the second block of GRFs does not overlap with the first block. If it is a null register the Extended Message Length must be 0. The sum of Message Length and Extended Message Length must not be greater than 15 on SKL.
The source dependency control, {NoSrcDepSet} is used to control the setting of source dependency for both the sources.
<dest> serves for two purposes: to provide the leading GRF register location for the response message if present, and to provide parameters to form the channel enable sideband signals.
<dest> signals whether there is a response to the message request. It can be either a null register, a direct-addressed GRF register or a register-indirect GRF register. Otherwise, hardware behavior is undefined.
If <dest> is null, there is no response to the request. Meanwhile, the Response Length field in <desc> must be 0. Certain types of message requests, such as memory write (store) through the Data Port, do not want response data from the function unit. If so, the posted destination operand can be null.
If <dest> is a GRF register, the register number is forwarded to the shared function. In this case, the target function unit must send one or more response message phases back to the requesting thread. The number of response message phases must match the Response Length field in <desc>, which of course cannot be zero. For some cases, it could be an empty return message. An empty return message is defined as a single phase message with all channel enables turned off.
The destination type field is always valid and is used to generate the WrEn. This is true even if <dest> is a null register (this is an exception for null as for most cases these fields are ignored by hardware).
The address immediates for indirect sources and destination must be oword aligned.
The 16-bit channel enables of the message sideband are formed based on the WrEn. Interpretation of the channel enable sideband signals is subject to the target external function. In general for a 'sends' instruction with return messages, they are used as the destination dword write mask for the GRF registers starting at <dest>. For a message that has multiple return phases, the same set of channel enable signals applies to all the return phases.
NoDDClr and NoDDChk must not be used for send instruction.
Send a message stored in GRF locations starting at <src0> followed by <src1> to a shared function identified by <ex_desc> along with control from <desc> and <ex_desc> with a GRF writeback location at <dest>.
Format:
[(pred)] sends (exec_size) <dest> <src0> <src1> <ex_desc> <desc>
dp4a
Dot Product 4 Accumulate
DP4A is a packed four-wide integer dot product and accumulate operation.
Each source's 32-bit channel value is treated as four element vector of 8-bit integer values.
The operation performs a 32-bit precision dot product of those four bytes and adds it with a 32-bit accumulator (typically a GRF, not necessarily an acc# reg).
Format: [(pred)] dp4a (exec_size) dst src0 src1 src2
EXAMPLE (SIMD1 for simplicity):
mov  (1) r1.0:d  0x0102037F:d // (char4)(0x1,0x2,0x3,0x7F)
mov  (1) r2.0:d  50:d
dp4a (1) r3.0:d  r2:d r1:d r1:d
// r3.0 = 50 + (0x1*0x1 + 0x2*0x2 + 0x3*0x3 + 0x7F*0x7F)
//      = 50 + (1 + 4 + 9 + 16129)
//      = 16193
The else instruction is an optional statement within an if/else/endif block of code. It restricts execution within the else/endif portion to the opposite set of channels enabled under the if/else portion. Channels which were inactive prior to entering the if/endif block remain inactive throughout the entire block.
All enabled channels upon arriving the else instruction will be redirected to the matching endif. If all channels are redirected (by else or before else), a relative jump is performed to the location specified by  <JIP>. The jump target should be the matching endif instruction for that conditional block.
The following table describes the 32-bit <JIP>. In GEN binary, <JIP> is at location <src1> and must be of type D (signed dword integer). <JIP> must be an immediate operand, it is a signed 32-bit number and is intended to be forward referencing. This value is added to IP pre-increment.
If the <branch_ctrl> bit is set, then the <JIP> points to the first join instruction within the else block and <UIP> points to the endif instruction. If the <branch_ctrl> bit is not set,  <JIP> and <UIP>, both point to endif.
Format:
else (exec_size) JIP  UIP  branch_ctrl
An else instruction must not be followed by any instruction requiring register indirect access on source operands
The mad instruction takes component-wise multiplication of src1 and src2, adds the results with the corresponding src0 values, and then stores the final results in dst.
The conditional modifier and saturation (.sat) must not be used when src1 or src2 are dwords.
Plane and Linear Interpolation instructions are removed. The following macros must be used to emulate Plane and Linear Interpolation operations.
Plane Instruction Emulation
The below plane instruction
pln (16) r20.0<1>:f r10.4<0;1,0>:f r4.0<8;8,1>:f
is emulated as below
mad (8) acc0<1>:nf r10.7<0;1,0>:f r4.0<8;8,1>:f r10.4<0;1,0>:f
mad (8) r20.0<1>:f acc0<8;8,1>:nf r5.0<8;8,1>:f r10.5<0;1,0>:f
mad (8) acc0<1>:nf r10.7<0;1,0>:f r6.0<8;8,1>:f r10.4<0;1,0>:f
mad (8) r21.0<1>:f acc0<8;8,1>:nf r7.0<8;8,1>:f r10.5<0;1,0>:f
In case of SIMD8 pln instruction only the first pair of mad instructions are used.
Linear Interpolation Instruction Emulation
The below lrp instruction
lrp (16) r40.0<1>:f r10.0<8;8,1>:f r20.0<8;8,1>:f r30.0<8;8,1>:f
is emulated as below
mad (8) acc0<1>:nf r30.0<8;8,1>:f r10.0<8;8,1>:f r20.0<8;8,1>:f
mad (8) r40.0<1>:f acc0<8;8,1>:nf -r10.0<8;8,1>:f r30.0<8;8,1>:f
mad (8) acc0<1>:nf r31.0<8;8,1>:f r11.0<8;8,1>:f r21.0<8;8,1>:f
mad (8) r41.0<1>:f acc0<8;8,1>:nf -r11.0<8;8,1>:f r31.0<8;8,1>:f
In case of SIMD8 lrp instruction only the first pair of mad instructions are used.
Format:
[(pred)] mad[.cmod] (exec_size) dst src0 src1 src2
The math instruction performs extended math function on the components in src0, or src0 and src1, and write the output to the channels of dst. The type of extended math function are based on the FC[3:0] encoding in the table below.
Format:
[(pred)] math.<FC> (exec_size) dst src0 src1
Rotate Left
Perform component-wise logical rotate left operation of the bits in src0 by the rotate count indicated in src1, storing the result in dst. src0 and src1 are treated as unsigned numbers with only the bits within the specified datatype used during this operation. This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers are supported. Extra precision bits available in accumulator are ignored during this operation and only the bits within the specified datatype are used.
src0 and dst must be of same datatype precision.
Format: [(pred)] rol[.cmod] (exec_size) dst src0 src1
Rotate Right
Perform component-wise logical rotate right operation of the bits in src0 by the rotate count indicated in src1, storing the result in dst. src0 and src1 are treated as unsigned numbers with only the bits within the specified datatype used during this operation. This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers are supported. Extra precision bits available in accumulator are ignored during this operation and only the bits within the specified datatype are used.
src0 and dst must be of same datatype precision.
Format: [(pred)] ror[.cmod] (exec_size) dst src0 src1
Total
binary size is too small
SyncFC
SFID
unexpected padding at end of kernel
error decoding instruction (no compacted form)
unable to decompact
error decoding instruction
GED error decoding instruction
unsupported pseudo op (sub function of 
: unsupported opcode on this platform
at pc 
: invalid operation format
: invalid operation format
IGA INTERNAL ERROR: 
: unexpected format for basic instruction
dst: unsupported Align16 ChEn; only <1> (.xyzw) supported
converting unary/binary Align16 dst to equivalent Align1
unsupported Align16 Dst.ChEn (only .xyzw supported)
invalid addressing mode on dst
dst has wrong region for binary normal form
invalid reg file on dst
unexpected Align1Ternary in current platform
unsupported Align16 ternary destination for SIMD2 (must be .xywz or .{xy,zw} for :df)
unsupported Align16 ternary destination for SIMD4 (must be .xywz or .{x,y,z,w})
unsupported Align16 ternary destination for SIMD{8,16} (must be .xywz)
unsupported Align16 ternary destination (unsupported SIMD)
error decoding instruction: SEND dst ARF
Align16 branches not supported
dst: invalid math macro register (from ChEn)
invalid dst implicit accumulator reference (in ChEn)
%s: 0x%02X: invalid arf register
%s: %s%d: invalid register number 
%s: invalid register file
swizzle X could not be retrieved
swizzle Y could not be retrieved
swizzle Z could not be retrieved
swizzle W could not be retrieved
GED reports invalid value for 
GED reports invalid field for 
(line 
GED reports error (
) accessing GED_
 (line 
src%d: inconvertible align16 operand
src%d: invalid addressing mode
invalid register file in src%d
src%d.Rgn should have %s for binary normal form
src%d: macro instructions must be Align16 for this platform.
invalid addressing mode in src%d
Region::INVALID
src%d: converting Align16 to Align1 (bits will re-assemble to Align1)
unconvertible ternary align16 operand
Align1 not available on this platform
src1: immediate supported here on ternary instruction.
expected SIMD width
expected ChOff
invalid ChOff
expected )
expected '(' (start of execution size info)
invalid SIMD width
expected a send operand type
unexpected operand type for send
old-style access to mme via acc (use mme%d for acc%d)
register number out of bounds
 must be a constant integer expression
expected constant integer expression
argument to operator must be integral
right operand to operator must be floating point (append a .0 to force floating point)
left operand to operator must be floating point (append a .0 to force floating point)
left operand to operator must be integral
right operand to operator must be integral
(integral) division by zero
nan is deprecated, us snan(...) or qnan(...)
qnan
snan
NaN payload overflows
NaN payload must be nonzero for snan
bare qnan and snan tokens deprecated (pass in a valid payload)
branching operands may not perform arithmetic on labels
non-branching operations may not reference symbols
syntax error in constant expression
NoDDChk not supported on given platform
NoDDClr not supported on given platform
NoPreempt not supported on given platform
NoSrcDep not supported on given platform
ignoring unsupported instruction option {Switch}
duplicate instruction options
Atomic mot supported on given platform
Atomic mutually exclusive with Switch
Atomic mutually exclusive with NoPreempt
Compacted mutually exclusive with Uncompacted/NoCompact
EOT is only allowed on send instructions
Uncompacted
Uncomapcted/NoCompact mutually exclusive with Compacted
NoMask goes precedes predication as (W) for WrEn: e.g. (W) op (..) ...   or    (W&f0.0) op (..) ..
H1 is obsolete; use M0 in execution offset: e.g. op (16|M0) ...
H2 is obsolete; use M16 in execution offset: e.g. op (16|M16) ...
Q1 is obsolete; use M0 in execution offset: e.g. op (8|M0) ...
Q2 is obsolete; use M8 in execution offset: e.g. op (8|M8) ...
Q3 is obsolete; use M16 in execution offset: e.g. op (8|M16) ...
Q4 is obsolete; use M24 in execution offset: e.g. op (8|M24) ...
N1 is obsolete; use M0 in execution offset: e.g. op (4|M0) ...
N2 is obsolete; use M4 in execution offset: e.g. op (4|M4) ...
N3 is obsolete; use M8 in execution offset: e.g. op (4|M8) ...
N4 is obsolete; use M12 in execution offset: e.g. op (4|M12) ...
N5 is obsolete; use M16 in execution offset: e.g. op (4|M16) ...
N6 is obsolete; use M20 in execution offset: e.g. op (4|M20) ...
N7 is obsolete; use M24 in execution offset: e.g. op (4|M24) ...
N8 is obsolete; use M28 in execution offset: e.g. op (4|M28) ...
expected instruction, block, or EOF
default_execution_size
expected SIMD width (integral value)
invalid default execution size; must be 1, 2, 4, 8, 16, 32
default_register_type
expected default register type
unexpected directive name
integer literal too large
label redefinition 
 (defined 
on line 
invalid mnemonic
expected predication control
invalid predication control
expected flag register
Unexpected flag register number
expected flag subregister
jmpi must have (W) specified (automatically adding)
expected 'b' (branch control)
saturation flag goes on destination operand: e.g. op (..) (sat)dst ...
conditional modifier follows execution mask info: e.g. op (16|M0)  (le)f0.0 ...
unexpected . (expected execution size)
expected operation subfunction
subfunction is out of bounds
invalid subfunction
unexpected subfunction for op
src0 must be a register
src0 must be a notification register
expected '\n', ';', or EOF
expected flag modifier function
expected ]
deprecated flag modifier syntax (omit the brackets)
deprecated flag modifier syntax: 
use 
 for this function
flag register must be same for predication and flag modifier
invalid destination register
invalid destination register number (%s only has %d registers on this platform)
expected [
expected address subregister
expected indirect address offset
immediate offset is out of range; must be in [
expected a0
expected .
expected address register subregister
destination region argument
invalid destination region
expected >
implicit type on dst should be omitted
expected destination type
expected subregister
send operand subregisters have no effect and are deprecated syntax
send operand region has no effect and is deprecated syntax
subregister out of bounds for data type
access granularity too small for data type
expected math macro register (e.g. .mme0, ..., .mme7, or .nomme)
old-style math macro register (use mme)
acc2
acc3
acc4
acc5
acc6
acc7
acc8
acc9
noacc
expected |
this doesn't support regioning
unexpected |
unbound identifier
expected source operand
source modifier unsupported on this op
%s.Src%d region should be implicit
syntax error in source region
invalid region width
expected ;
invalid region vertical stride
expected ,
syntax error in region (horizontal stride)
invalid region horizontal stride
syntax error in region (width)
implicit type on src should be omitted
expected source type
subregister out of bounds
register access granularity too small type
syntax error in region (vertical stride)
literal must be integral for type 
immediate integer floating point literals must be in hex or binary (e.g. 0x7F800000:f)
hex literal too big for type
NaN payload value overflows
literal is out of bounds for type %s
invalid send destination register
this form of indirect (r3[a0.0,16]) is invalid for send dst operand; use regular form: r[a0.0,16]
expected extended send descriptor
immediate descriptor expression must be integral
extended message descriptor is typeless
Message Descriptor is typeless
 must be an immediate label
expected }
invalid instruction option
undefined label
expected 
INTERNAL ERROR: parsing float literal
fatal flex scanner internal error--no action found
out of dynamic memory in yy_create_buffer()
out of dynamic memory in yy_scan_buffer()
out of dynamic memory in yy_scan_bytes()
bad buffer in yy_scan_bytes()
yyset_lineno called with no buffer
yyset_column called with no buffer
fatal flex scanner internal error--end of buffer missed
fatal error - scanner input buffer overflow
input in flex scanner failed
out of dynamic memory in yy_get_next_buffer()
out of dynamic memory in yyensure_buffer_stack()
malformed load/store mnemonic suffix
platform does not support packed (unary) send
ld/st operation name
unhandled ld/st operation kind
invalid address model for this message
invalid message
register range
invalid register range
malformed register range
malformed register range (high register must be >= low)
unary send prohibits src1 argument
surface offset
expected offset
address offset out of bounds for message type (>
address model
surface index
expected surface index
surface index is out of bounds
scratch index is out of bounds
invalid address model
unary store (stp) not supported yet
missing %s argument
invalid %s
address range includes header (extra reg), but format does not allow for it
expected %d address registers
expected %d data registers
instruction option
succeeded
unknown error
invalid argument
out of memory
decode error
encode error
parse error
version mismatch
invalid object
invalid state
unsupported platform
invalid error code
0.15.17
iga_assemble call uses deprecated options  (error_on_compact_fail or autoset_deps); see newest iga.h header file for updated fields
iga_disassemble* call uses deprecated options  (hex_floats or print_pc); see newest iga.h header file for updated fields
iga api: unsupported platform
failed to allocate
decoding error: %s
ERROR: 
WARNING: 
7.0.0
