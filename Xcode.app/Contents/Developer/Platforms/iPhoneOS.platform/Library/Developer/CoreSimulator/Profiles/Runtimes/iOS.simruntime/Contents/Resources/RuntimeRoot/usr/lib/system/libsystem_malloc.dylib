@(#)PROGRAM:libsystem_malloc  PROJECT:libmalloc-374.60.3
MallocNanoMadvisePolicy
nanov2_madvise_policy
MallocNanoSingleArena
nanov2_single_arena
MallocNanoScanPolicy
nanov2_scan_policy
MallocNanoSizeClassBlocks
nanov2_size_class_blocks
immediate
warning
critical
nanov2_mode
enabled
forced
conditional
malloc_nano_max_magazines
malloc_max_magazines
malloc_large_expanded_cache_threshold
malloc_medium_zone
malloc_medium_activation_threshold
malloc_max_medium_magazines
malloc_medium_space_efficient
malloc_medium_madvise_dram_scale_divisor
com.apple.Libsystem.malloc
FATAL ERROR - invalid bitarray level
System
purgeable zone does not support guard pages
pointer %p being reallocated was not allocated
Purgeable zone %p: inUse=%u(%y) flags=%d
MallocQuarantineZone
MallocQuarantineZoneDebug
MallocQuarantineNoPoisoning
MallocQuarantineMaxItems
MallocQuarantineMaxSizeInMB
QuarantineMallocZone
malloc(0x%lx) = %p
calloc(0x%lx, 0x%lx) = %p
valloc(0x%lx) = %p
free(%p)
evicting %p from quarantine, size = 0x%lx
realloc(NULL, 0x%lx) = %p
realloc(%p, 0x%lx) = %p (old_size = 0x%lx)
batch_malloc(0x%lx, %p, 0x%x)
batch_free(%p, 0x%x)
memalign(0x%lx, 0x%lx)
free_definite_size(%p, 0x%lx)
Failed to read szone structure
Failed to read large entries
Large allocator active blocks - total %y:
   Slot %5d: %p, size %y
, madvised
Large allocator death row cache, %d entries
Max cached size:
Current size:
Reserve size:
Reserve limit:
[newest]
[oldest]
 %s %s
 madvised
Large allocator death row cache not configured
pointer %p being freed already on death-row
*** can't vm_purgable_control(..., VM_PURGABLE_SET_STATE) for large freed block at %p
*** can't reset protection for large freed block at %p
entry for pointer %p being freed from death-row vanished
pointer %p being freed was not allocated
large entry %p reallocated is not properly in table
*** can't mvm_protect(0x0) region for new postlude guard page at %p
Non-aligned pointer %p being freed
Pointer %p to metadata being freed
Non-aligned pointer %p being freed (2)
Pointer %p to metadata being freed (2)
non-page-aligned, non-allocated pointer %p being freed
*** FATAL ERROR - comm page version mismatch.
FATAL ERROR - comm page version mismatch
at szone_check counter=%d
Failed to get scalable zone info
Scalable zone %p: inUse=%u(%u) touched=%u allocated=%u flags=0x%x
tiny=%u(%u) small=%u(%u) large=%u(%u)
%lu tiny regions:
[%lu tiny regions have been vm_deallocate'd]
Failed to map tiny rack region_generation
Failed to map tiny rack hashed_regions
Failed to map tiny rack magazines
Failed to map region %p
Tiny recirc depot: total bytes: %llu, in-use bytes: %llu, allocations: %llu, regions: %d (min # retained regions: %d)
Tiny recirc depot is empty
%lu small regions:
[%lu small regions have been vm_deallocate'd]
Failed to map small rack region_generation
Failed to map small rack hashed_regions
Failed to map small rack magazines
Small recirc depot: total bytes: %llu, in-use bytes: %llu, allocations: %llu, regions: %d (min # retained regions: %d)
Small recirc depot is empty
%lu medium regions:
[%lu medium regions have been vm_deallocate'd]
Failed to map medium rack region_generation
Failed to map medium rack hashed_regions
Failed to map medium rack magazines
Medium recirc depot: total bytes: %llu, in-use bytes: %llu, allocations: %llu, regions: %d (min # retained regions: %d)
Medium recirc depot is empty
%ld, counter=%d
*** invariant broken: null msize ptr=%p num_small_regions=%d end=%p
%ld, counter=%d
*** invariant broken for free block %p this msize=%d
%ld, counter=%d
*** invariant broken for %p (previous %p is not a free pointer)
%ld, counter=%d
*** invariant broken for %p (next %p is not a free pointer)
%ld, counter=%d
*** invariant broken for small free %p followed by %p in region [%p-%p] (end marker incorrect) should be %d; in fact %d
Failed to map small rack
small free sizes:
Recirc depot: 
Magazine %d: 
%s%y[%d]; 
Failed to map small region at %p
Small region [unknown address] was returned to the OS
*** error with %p: msize=%d, free: %x
Small region %p [%p-%p, %y] 
Recirc depot 
Magazine=%d 
Allocations in use=%d 
 Bytes in use=%ly (%d%%) 
Untouched=%ly 
Advised MADV_FREE=%ly
Fragments subject to reclamation=%ly
Empty enough to be moved to recirc depot
Not empty enough to be moved to recirc depot
Sizes in use: 
%y[%d] 
 (slot=%u), counter=%d
*** in-use ptr in free list slot=%u count=%d ptr=%p
 (slot=%u), counter=%d
*** unaligned ptr in free list slot=%u count=%d ptr=%p
 (slot=%u), counter=%d
*** ptr not in szone slot=%d count=%d ptr=%p
 (slot=%u), counter=%d
*** previous incorrectly set slot=%u count=%d ptr=%p
small_free_list_find_by_ptr: ptr is not free (ptr metadata !SMALL_IS_FREE), ptr=%p msize=%d metadata=0x%x
small_free_list_remove_ptr_no_clear: Internal invariant broken (next ptr of prev) for %p, prev_next=%p
small_free_list_remove_ptr_no_clear: Internal invariant broken (prev ptr of next) for %p, next_prev=%p
check: incorrect small region 
Incorrect checksum for freed object %p: probably modified after being freed.
Corrupt value: %p
Region cookie corrupted for region %p (value is %x)[%p]
double free for ptr %p
small free list metadata inconsistency (headers[previous] != previous size)
incorrect size information for %p - block header was damaged
small_free_try_depot_unmap_no_lock objects_in_use not zero: %d
Failed to map small oobe pointer
Unable to map small linkage pointer %p
check: small free list incorrect
*** FATAL ERROR - unable to allocate magazine array.
FATAL ERROR - unable to allocate magazine array
tiny_free_try_depot_unmap_no_lock hash lookup failed: %p
can't allocate region
:*** mach_vm_map(size=%lu, flags: %x) failed (error code=%d)
can't unmap excess guard region
*** mach_vm_deallocate(addr=%p, size=%lu) failed (code=%d)
can't unmap excess trailing guard region
*** mach_vm_deallocate(addr=%p, size=%lu) failed (code=%d)
Can't deallocate_pages region at %p
*** can't mvm_protect(%u) region for prelude guard page at %p
*** can't mvm_protect(%u) region for postlude guard page at %p
MallocProbGuard
libmalloc
ProbGuard
ProbGuardAllProcesses
MallocProbGuardViaLaunchd
__DATA
__pgm_opt_out
ProbGuardMallocZone
allocated
ProbGuard: %9s 0x%lx, fill state: %3u/%u
*** FATAL ERROR - ProbGuard: zone integrity check failed.
FATAL ERROR - ProbGuard: zone integrity check failed
*** FATAL ERROR - ProbGuard: invalid pointer passed to free.
FATAL ERROR - ProbGuard: invalid pointer passed to free
freed
*** FATAL ERROR - ProbGuard: invalid pointer passed to realloc.
FATAL ERROR - ProbGuard: invalid pointer passed to realloc
ProbGuard zone: slots: %u, slots in use: %u, size in use: %llu, max size in use: %llu, allocated size: %llu
Quarantine: size: %llu, address range: [%p - %p)
Slots (#, state, offset, size, block address):
%4u, %9s, %4u, %4u, %p
unused
Failed to read ProbGuard zone at %p
MallocProbGuardMemoryBudgetInKB
MallocProbGuardAllocations
MallocProbGuardSlots
MallocProbGuardMetadata
MallocProbGuardSampleRate
MallocProbGuardStrictAlignment
ProbGuardStrictAlignment
MallocProbGuardSignalHandler
MallocProbGuardDebug
MallocProbGuardDebugLogThrottleInMillis
ProbGuard configuration: %u kB budget, 1/%u sample rate, %u/%u/%u allocations/metadata/slots, strict alignment: %d
*** FATAL ERROR - ProbGuard: bad configuration.
FATAL ERROR - ProbGuard: bad configuration
*** FATAL ERROR - ProbGuard: memory budget too small.
FATAL ERROR - ProbGuard: memory budget too small
long-range OOB
out-of-bounds
high
use-after-free
OOB + UAF
*** FATAL ERROR - ProbGuard: invalid access detected.
FATAL ERROR - ProbGuard: invalid access detected
ProbGuard: invalid access at 0x%lx
Error type: %s (%s confidence)
Nearest allocation: 0x%lx, size: %lu, state: %s
Allocation
Deallocation
Allocation stack traces not available.  Try increasing `MallocProbGuardMetadata` and rerun.
%s trace (thread %llu, time: %llu):
  #%u %s
%s  (%s)
Failed to madvise block at blockp: %p, error: %d
Failed when changing state from MADVISING to MADVISED, block_metap = %p, blockp = %p
Failed to remadvise block at blockp: %p, error: %d
Heap corruption detected, free list is damaged at %p
*** Incorrect guard value: %lu
nano zone abandoned due to inability to preallocate reserved vm space.
%s value (%s) invalid - ignored.
%s value invalid: [%s] - ignored.
%s value invalid - values must sum to %d, not %d - ignored.
Failed to create guard block at %p (%d)
Failed to map nanozonev2_s at %p
Nanozonev2 %p: blocks in use: %llu, size in use: %llu allocated size: %llu, allocated regions: %d, region holes: %d
Current Allocation Blocks By Size Class/Context [CPU]
  Class %d: 
%d: %p; 
Region %d: base address %p
Failed to map nanov2 region at %p
Arena #%d: base address %p. Blocks - active: %d, madvisable: %d, madvising: %d, madvised: %d, unused: %d
Size classes with allocated blocks: 
FULL
CAN MADVISE
    Block %d: base %p; metadata: %p, size %d (class %d) in-use: %d 
BUMP (free list empty)
next_slot (1-based) = %d
, allocated slots: %d, free slots = %d, occupancy: %d%%
MallocNanoZone
malloc_nano_max_magazines must be positive - ignored.
MallocNanoMaxMagazines
_MallocNanoMaxMagazines
MallocNanoMaxMagazines must be positive - ignored.
Nano maximum magazines limited to number of physical CPUs [%d]
Nano maximum magazines set to %d
*** can't allocate pages: mach_vm_map(size=%lu) failed (error code=%d)
Can't deallocate_pages at %p
EnableBootArgs
kern.bootargs
malloc_entropy
MallocExperiment=
Attempted to register zone more than once: %p
malloc_zone_register allocation failed: %d
DefaultPurgeableMallocZone
DefaultMallocZone
*** MallocCheckHeap: FAILED check at operation #%d
Stack for last operation where the malloc check succeeded: 
(Use 'atos' for a symbolic stack)
(Use 'atos' for a symbolic stack)
*** Recommend using 'setenv MallocCheckHeapStart %d; setenv MallocCheckHeapEach %d' to narrow down failure
*** Will sleep for %d seconds to leave time to attach
*** Will sleep once for %d seconds to leave time to attach
*** malloc_zone_unregister() failed for %p
*** error for object %p: pointer being freed was not allocated
*** error for object %p: pointer being realloc'd was not allocated
*** malloc_get_all_zones: error reading zones_address at %p
*** malloc_get_all_zones: error reading num_zones at %p
*** malloc_get_all_zones: error reading zones at %p
ptr %p in registered zone %p
ptr %p not in heap
*** OBSOLETE: malloc_singlethreaded()
*** OBSOLETE: malloc_debug()
msl_start_reading
msl_stop_reading
msl_disk_stack_logs_enumerate_from_task
msl_uniquing_table_copy_from_task
msl_uniquing_table_copy_from_serialized
msl_uniquing_table_release
msl_uniquing_table_retain
msl_uniquing_table_serialize
malloc_max_magazines must be positive - ignored.
malloc_large_expanded_cache_threshold must be positive - ignored.
malloc_medium_activation_threshold must be positive - ignored.
malloc_max_medium_magazines must be positive - ignored.
malloc_medium_madvise_dram_scale_divisor must be positive - ignored.
*** FATAL ERROR - logical_ncpus %% phys_ncpus != 0
FATAL ERROR - logical_ncpus %% phys_ncpus != 0
*** FATAL ERROR - logical_ncpus / phys_ncpus not 1, 2, or 4.
FATAL ERROR - logical_ncpus / phys_ncpus not 1, 2, or 4
MallocHelperZone
Malloc
_Malloc
MallocGuardEdges
adding guard pages to all regions
adding guard pages for large allocator blocks
MallocDoNotProtectPrelude
... but not protecting prelude guard page
MallocDoNotProtectPostlude
... but not protecting postlude guard page
MallocScribble
enabling scribbling to detect mods to free blocks
MallocErrorAbort
enabling abort() on bad malloc or free
MallocTracing
MallocCheckHeapStart
MallocCheckHeapEach
checks heap after operation #%d and each %d operations
MallocCheckHeapAbort
will abort on heap corruption
MallocCheckHeapSleep
will sleep for %d seconds on heap corruption
will sleep once for %d seconds on heap corruption
no sleep on heap corruption
MallocMaxMagazines
_MallocMaxMagazines
Maximum magazines defaulted to %d
Maximum magazines must be positive - ignored.
Maximum magazines limited to number of logical CPUs (%d)
Maximum magazines set to %d
MallocLargeExpandedCacheThreshold
Large expanded cache threshold defaulted to %lly
Large expanded cache threshold set to %lly
MallocLargeDisableASLR
Enabling ASLR slide on large allocations
Disabling ASLR slide on large allocations
MallocSpaceEfficient
MallocSpaceEfficient must be 0 or 1.
MallocMediumZone
MallocMediumActivationThreshold
Medium activation threshold defaulted to %lly
Medium activation threshold set to %lly
MallocMediumSpaceEfficient
MallocMaxMediumMagazines
_MallocMaxMediumMagazines
Maximum medium magazines defaulted to %d
Maximum medium magazines must be positive - ignored.
Maximum medium magazines limited to number of logical CPUs (%d)
Maximum medium magazines set to %d
MallocAggressiveMadvise
MallocAggressiveMadvise must be 0 or 1.
MallocLargeCache
MallocLargeCache must be 0 or 1.
MallocRecircRetainedRegions
MallocRecircRetainedRegions must be positive - ignored.
MallocHelp
environment variables that can be set for debug:
- MallocLogFile <f> to create/append messages to file <f> instead of stderr
- MallocGuardEdges to add 2 guard pages for each large block
- MallocDoNotProtectPrelude to disable protection (when previous flag set)
- MallocDoNotProtectPostlude to disable protection (when previous flag set)
- MallocStackLogging to record all stacks.  Tools like leaks can then be applied
- MallocStackLoggingNoCompact to record all stacks.  Needed for malloc_history
- MallocStackLoggingDirectory to set location of stack logs, which can grow large; default is /tmp
- MallocScribble to detect writing on free blocks and missing initializers:
  0x55 is written upon free and 0xaa is written on allocation
- MallocCheckHeapStart <n> to start checking the heap after <n> operations
- MallocCheckHeapEach <s> to repeat the checking of the heap after <s> operations
- MallocCheckHeapSleep <t> to sleep <t> seconds on heap corruption
- MallocCheckHeapAbort <b> to abort on heap corruption if <b> is non-zero
- MallocCorruptionAbort to abort on malloc errors, but not on out of memory for 32-bit processes
  MallocCorruptionAbort is always set on 64-bit processes
- MallocErrorAbort to abort on any malloc error, including out of memory
- MallocTracing to emit kdebug trace points on malloc entry points
- MallocHelp - this help!
*** error %d
*** error %d
*** DefaultMallocError called
MallocStackLogging
/System/Library/PrivateFrameworks/MallocStackLogging.framework/MallocStackLogging
failed to load MallocStackLogging.framework
msl_handle_memory_event
msl_stack_logging_locked
msl_fork_prepare
msl_fork_child
msl_fork_parent
msl_turn_on_stack_logging
msl_turn_off_stack_logging
msl_set_flags_from_environment
msl_initialize
msl_get_frames_for_address
msl_stackid_for_vm_region
msl_get_frames_for_stackid
msl_uniquing_table_read_stack
msl_copy_msl_lite_hooks
%ld, counter=%d
*** invariant broken: null msize ptr=%p num_medium_regions=%d end=%p
%ld, counter=%d
*** invariant broken for medium free %p followed by %p in region %p [%p-%p] (end marker incorrect) should be %d; in fact %d
Failed to map medium rack
medium free sizes:
%s%y[%lld]; 
Medium region [unknown address] was returned to the OS
Medium region %p [%p-%p, %y] 
Advised=%ly 
Dirty=%ly 
Medium region [unknown address] was returned to the kernel
Medium region %p  [%p-%p, %y, %y]
medium_free_list_find_by_ptr: ptr is not free (ptr metadata !MEDIUM_IS_FREE), ptr=%p msize=%d metadata=0x%x
medium_free_list_remove_ptr_no_clear: Internal invariant broken (next ptr of prev) for %p, prev_next=%p
medium_free_list_remove_ptr_no_clear: Internal invariant broken (prev ptr of next) for %p, next_prev=%p
check: incorrect medium region 
medium free list metadata inconsistency (headers[previous] != previous size)
medium_free_try_depot_unmap_no_lock objects_in_use not zero: %d
Failed to map medium oobe pointer
Unable to map medium linkage pointer %p
check: medium free list incorrect
For region %p, first block: %d (%p), last block: %d (%p)
%ld, counter=%d
*** invariant broken for leader block %p - %d %d
%ld, counter=%d
*** invariant broken for tiny block %p this msize=%d - size is too small
%ld, counter=%d
*** invariant broken for %p this tiny msize=%d - size is too large
%ld, counter=%d
*** invariant broken for %p (next in free list %p is not a free pointer)
%ld, counter=%d
*** invariant broken for tiny free %p followed by %p in region %p [%p-%p] (end marker incorrect) should be %d; in fact %d
%ld, counter=%d
*** invariant broken for region end %p - %p
%ld, counter=%d
*** invariant broken for blocker block %p - %d %d
NO ZONE for ptr %p
Failed to map tiny rack
Tiny free sizes:
Failed to map tiny region at %p
Tiny region [unknown address] was returned to the OS
*** error with %p: msize=%d
*** error at %p msize for in_use is %d
Tiny region [%p-%p, %y] 
 (slot=%u), counter=%d
*** ptr not in szone slot=%d  count=%u ptr=%p
tiny_free_list_remove_ptr: Internal invariant broken (next ptr of prev): ptr=%p, prev_next=%p
tiny_free_list_remove_ptr: Internal invariant broken (prev ptr of next): ptr=%p, next_prev=%p
tiny_free_try_depot_unmap_no_lock objects_in_use not zero: %d
*** check: incorrect tiny region 
Double free of object %p
** invalid pointer in free list: %p
check: tiny free list incorrect 
MallocDebugReport
stderr
crash
none
Unrecognized value for MallocDebugReport (%s) - using 'stderr'
MallocErrorStop
MallocErrorSleep
%s(%d,%p) malloc: 
*** set a breakpoint in malloc_error_break to debug
*** sending SIGSTOP to help debug
*** sleeping to help debug
firstfit
