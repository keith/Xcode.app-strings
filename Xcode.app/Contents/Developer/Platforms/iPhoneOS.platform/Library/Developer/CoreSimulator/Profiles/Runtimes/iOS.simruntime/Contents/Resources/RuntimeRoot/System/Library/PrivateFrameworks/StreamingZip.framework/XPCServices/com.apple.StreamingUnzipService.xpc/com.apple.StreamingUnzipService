unzip_service
v8@?0
com.apple.streamingzip
-[StreamingUnzipServiceDelegate listener:shouldAcceptNewConnection:]
Got connection from process %@ at qos %@
hash
TQ,R
superclass
T#,R
description
T@"NSString",R,C
debugDescription
EnableDebugLogging
main
Debug logging is enabled
Feb 19 2020
04:06:36
Streaming unzip service built at %s %s started
%@ (pid %d)
Unknown Process Name (pid %d)
USER_INTERACTIVE
USER_INITIATED
DEFAULT
UTILITY
BACKGROUND
UNSPECIFIED
UNKNOWN_QOS: 0x%x
SHA1
SHA224
SHA256
SHA384
SHA512
StreamingZip
Failed to create log string
%s: %s:%d (0x%p): %s
META-INF/
META-INF/com.apple.ZipMetadata.plist
META-INF/com.apple.FixedZipMetadata.bin
RecordCount
TotalUncompressedBytes
Version
StandardFilePerms
StandardDirectoryPerms
SZExtractorOptionsHashType
SZExtractorOptionsHashesArray
SZExtractorOptionsHashedChunkSize
SZExtractorOptionsDenyInvalidSymlinks
SZExtractorHashTypeMD5
SZExtractorHashTypeSHA1
SZExtractorHashTypeMD2
SZExtractorHashTypeMD4
SZExtractorHashTypeSHA224
SZExtractorHashTypeSHA256
SZExtractorHashTypeSHA384
SZExtractorHashTypeSHA512
SZExtractorOptionsAssertQOS
delegate
T@"<SZExtractorDelegate>",W,Vdelegate
options
extractionPath
isLocalExtractor
-[SZExtractor initWithCoder:]
%@: deserialized
-[SZExtractor encodeWithCoder:]
%@: suspending stream in preparation for serializing ourselves
-[SZExtractor encodeWithCoder:]_block_invoke
%@: Suspending stream prior to encoding failed with error: %@
v24@?0Q8@"NSError"16
%@: serialized
SZExtractorOptionsHashesArray must be an array, but is a %@
SZExtractor requires SZExtractorOptionsHashedChunkSize if passing multiple hashes in SZExtractorOptionsHashesArray
ExtractInProcess
-[SZExtractor _setUpWithPath:options:]
%@: Streaming zip extraction is being done in-process
%@: initialized with path: %@ options: %@
-[SZExtractor _synchronouslyPrepareForExtractionAtOffset:]_block_invoke
%@: prepare for extraction failed: %@
com.apple.StreamingZip.SZExtractorBufferSubmissionQueue
-[SZExtractor _prepareForRemoteExtractionSynchronously:withCompletionBlock:]_block_invoke
Failed to create NSXPCConnection
Connection interrupted to streaming unzip service.
Connection invalidated to streaming unzip service.
Failed to create extraction directory at path %@: %@
Failed to realpath "%@" at "%s": %s
com.apple.StreamingUnzipService
Failed to issue sandbox extension for "%s" : %s
%@: prepare returning error %@
v16@?0@"NSError"8
%@: calling prepare completion block with offset %llu, error %@
v24@?0@"NSError"8Q16
com.apple.StreamingZip.SZExtractor_in_process
In-process unzipper
-[SZExtractor _prepareForLocalExtraction:]_block_invoke
com.apple.StreamingZip.SZExtractor_in_proces_delegate
-[SZExtractor _prepareForExtractionSynchronously:withCompletionBlock:]
%@: preparing
extractionPath was nil. Did you mean to call -prepareForExtractionToPath:completionBlock: instead?
Calling %s after any calls to other non-init methods on this instance is an error.
%@: prepare called on extractor that had already returned error %@
%@: prepare called on object that was already prepared; returning resumption offset %llu
-[SZExtractor prepareForExtractionToPath:completionBlock:]
%@: preparing for extraction to path %@
-[SZExtractor _invalidateObject]
%@: invalidating
-[SZExtractor supplyBytes:withCompletionBlock:]
%@: got buffer of length %lu
%@: supply called on extractor that had already returned error %@
%s called before -[SZExtractor prepareForExtraction:] on %@
%s called on an invalidated object: %@
-[SZExtractor supplyBytes:withCompletionBlock:]_block_invoke
%@: calling completion block with error %@
%@: calling completion block with no error, dataComplete=%c
v20@?0@"NSError"8B16
v28@?0@"NSError"8B16Q20
Supplying entire byte range data of length %lu
Already processed {%lu, %lu}
Reserved %ld bytes; adding to existing length %ld
Failed to reserve last range; falling out with last range {%lu, %lu}
v40@?0r^v8{_NSRange=QQ}16^B32
/Library/Caches/com.apple.xbs/Sources/StreamingZip_Sim/StreamingZip-154.40.3/Framework/SZExtractor.m
NSNotFound != lastByteRange.location
Waiting for %lu bytes to become available
Reserved %ld bytes for too-big partial range {%lu, %lu}
Reserved %ld bytes at %ld for too-big partial range {%lu, %lu}
Supplying byte range data of length %lu at location %lu
Active partial range {%lu, %lu} exhausted
-[SZExtractor _suspendStreamWithCompletionBlockSynchronously:completion:]
%@: suspending stream
%@: suspend called on extractor that had already returned error %@
-[SZExtractor _suspendStreamWithCompletionBlockSynchronously:completion:]_block_invoke
%@: calling completion block with offset %llu, error %@
-[SZExtractor finishStreamWithCompletionBlock:]
%@: finishing stream
%@: finish called on extractor that had already returned error %@
-[SZExtractor finishStreamWithCompletionBlock:]_block_invoke
-[SZExtractor terminateStreamWithError:completionBlock:]
%@: terminating stream with error %@
%@: terminate called on extractor that had already returned error %@
-[SZExtractor terminateStreamWithError:completionBlock:]_block_invoke
-[SZExtractor setExtractorDelegate:]
%@: %s was called before -[SZExtractor prepareForExtraction:]; this doesn't do anything
%@: %s was called on an invalidated object
%@: Setting extractor delegate to 0x%p
-[SZExtractor setActiveExtractorDelegateMethods:]
%@: setting active extractor delegate methods to 0x%x
-[SZExtractor setActiveExtractorDelegateMethods:]_block_invoke
%@: Failed to set delegate methods enabled: %@
pathEnding:%@/%@
path:nil
<%@<%p> prepared:%c valid:%c %@ error:%@>
supportsSecureCoding
TB,R
extractorDelegate
T@"<SZExtractorDelegate>",W,N
doesConsumeExtractedData
TB,R,N
lastResumptionOffset
TQ,N,V_lastResumptionOffset
unzipServiceConnection
T@"NSXPCConnection",R,N,V_unzipServiceConnection
inProcessUnzipper
T@"StreamingUnzipper",R,N,V_inProcessUnzipper
serialQueue
T@"NSObject<OS_dispatch_queue>",R,N,V_serialQueue
internalExtractorDelegate
T@"SZExtractorInternalDelegate",R,N,V_internalExtractorDelegate
error
T@"NSError",&,N,V_error
TB,R,N,V_isLocalExtractor
needsPreparation
TB,N,V_needsPreparation
hasHadPostSetupMethodsCalled
TB,N,V_hasHadPostSetupMethodsCalled
T@"NSString",C,N,V_extractionPath
T@"NSDictionary",R,C,N,V_options
TB,R,D,N
SerializationVersion
StreamInfoDict
LastChunkPartialHash
UnsureData
InMemoryFileData
LocalFileRecord
StageBytesComplete
CurrentOffset
CurrentCRC32
RecordsProcessed
LocalFileMode
StreamState
StoreCurrentFileInMemory
OpenCurrentOutputFile
CurrentOutputFileOffset
TotalFileSizeWritten
SerializedCompressionState
HashContext
DataDescriptorUnion
com.apple.StreamingUnzipResumptionData
-[StreamingUnzipState init]
/Library/Caches/com.apple.xbs/Sources/StreamingZip_Sim/StreamingZip-154.40.3/StreamingUnzipService/StreamingUnzipState.m
false
-[StreamingUnzipState setStreamState:]
Updating stream state from %@ to %@
kStreamStateCompleteLFData == _streamState || kStreamStateIncompleteLFRecord == _streamState
kStreamStateReadNextRecordSignature == _streamState
kStreamStateIncompleteLFRecord == _streamState
kStreamStateIncompleteLFData == _streamState
kStreamStateIncompleteDataDescriptor == _streamState|| kStreamStateIncompleteLFData == _streamState || kStreamStateIncompleteLFRecord == _streamState
-[StreamingUnzipState serializeState]
Failed to create archive for passthrough EA on path %@
Failed to set passthrough EA %s on path %@: %s
Mismatch between uncompressed bytes output (%llu) and output file offset (%lld)
Failed to create archive for resumption data to path %@
Serializing %lu bytes of resumption data for offset %llu
Failed to save resumption data to path %@: %@
-[StreamingUnzipState _checkHashForOffset:]
Cannot validate hash; this chunk is index %llu, but we only have %lu hashes.
Hash mismatch for chunk containing offset %llu: expected %@, got %@
Verified that hashed data offset %llu matches index %llu: %@
-[StreamingUnzipState checkLastChunkPartialHash]
Hash mismatch for last partial chunk: expected %@, got %@
Verified that last chunk partial hash matches: %@
-[StreamingUnzipState updateHashFromOffset:withBytes:length:onlyFinishCurrentChunk:]
Ambiguous or missing hash chunk size: chunk size is %llu but have %lu hashes
sizeToHash <= length
_bytesHashedInChunk <= _hashedChunkSize
-[StreamingUnzipState finishStream]
Finishing an incomplete stream! This stream will not be resumable.
-[StreamingUnzipState initWithPath:options:error:]
Failed to init
Options dictionary supplied has one or more options with an incorrect type.
Could not allocate memory for local file record
Ambiguous chunk size (hashes > 1 but chunkSize == 0)
Hash chunk size given as > 0, but no hashes
Failed to stat path %@: %s
Failed to get size of xattr %s from path %@: %s
Expected to read %ld bytes but got %ld for EA %s on %@; resuming from offset 0
Failed to remove EA %s from %s: %s
Found resumption data version %d, but expected %d at %@; resuming from offset 0
Unable to deserialize resumption data (%@); resuming from offset 0
Computed index of current hash chunk (%llu) is not within supplied hashes array of %lu elements; resuming from offset 0
Serialized %s context (%lu bytes) did not match size of struct (%lu bytes); resuming from offset 0
Failed to open output file at path %@: %s
Failed to read resumption data from path %@: %@; starting from offset 0
Failed to remove %@: %@
Failed to deserialize resumption data (%@); resuming from offset 0
Failed to get path from current local file record.
Resuming %@ at offset %lld
Failed to get serialized compression state from save data
Compression save state was not valid.
Failed to seek to offset %llu in output file at path %@: %s
Invalid state in resumption data at path %@
cmpState
T^{?=*Q*Q^v},R,N
unzipPath
T@"NSString",R,N,V_unzipPath
hashContext
T{?=i(?={CC_MD5state_st=IIIIII[16I]i}{CC_SHA1state_st=IIIIIII[16I]i}{CC_MD2state_st=i[16C][16I][16I]}{CC_MD4state_st=IIIIII[16I]I}{CC_SHA256state_st=[2I][8I][16I]}{CC_SHA256state_st=[2I][8I][16I]}{CC_SHA512state_st=[2Q][8Q][16Q]}{CC_SHA512state_st=[2Q][8Q][16Q]})},R,N,V_hashContext
streamInfoDict
T@"NSDictionary",&,N,V_streamInfoDict
lastChunkPartialHash
T@"NSString",&,N,V_lastChunkPartialHash
unsureData
T@"NSMutableData",&,N,V_unsureData
inMemoryFileData
T@"NSMutableData",&,N,V_inMemoryFileData
currentLFRecord
T^{?=[4C]{?=S}{?=S}{?=S}(?={?={?=S}{?=S}}{?=I}){?=I}{?=I}{?=I}{?=S}{?=S}[0C]},N,V_currentLFRecord
currentLFRecordAllocationSize
TQ,N,V_currentLFRecordAllocationSize
thisStageBytesComplete
TQ,N,V_thisStageBytesComplete
currentOffset
TQ,N,V_currentOffset
hashedChunkSize
TQ,R,N,V_hashedChunkSize
bytesHashedInChunk
TQ,R,N,V_bytesHashedInChunk
currentCRC32
TQ,N,V_currentCRC32
currentOutputFD
Ti,N,V_currentOutputFD
recordsProcessed
TQ,N,V_recordsProcessed
totalRecordCount
TQ,N,V_totalRecordCount
totalUncompressedBytes
TQ,N,V_totalUncompressedBytes
uncompressedBytesOutput
TQ,N,V_uncompressedBytesOutput
totalFileSizeWritten
TQ,N,V_totalFileSizeWritten
currentLFMode
TS,N,V_currentLFMode
streamState
TC,N,V_streamState
storeCurrentFileInMemory
TB,N,V_storeCurrentFileInMemory
currentLFRequiresDataDescriptor
TB,N,V_currentLFRequiresDataDescriptor
dataDescriptor
T^{?=[4C](?={?={?=I}{?=Q}{?=Q}}{?={?=I}{?=I}{?=I}})},N,V_dataDescriptor
denyInvalidSymlinks
TB,N,V_denyInvalidSymlinks
ReadNextRecordSignature
IncompleteLFRecord
IncompleteLFData
IncompleteDataDescriptor
CompleteLFData
WriteThrough
FinishHashing
Complete
Error
Unknown
com.apple.StreamingPassthroughResumptionData
_ValidateDictionaryKeyValueType
Value of key %@ in options dictionary was not an object of type %@. Was %@
_HashTypeForString
Unsupported hash type: %@. Defaulting to MD5
_RemoveAndRecreateDirectoryAtPath
Failed to remove partially extracted bad data to start over: %@
_GetDataProtectionClassForPath
Failed to open %s : %s
Failed to get protection class on %s : %s
_SetDataProtectionClassOnPath
Failed to set protection class on %s to %d: %s
Unzip session on behalf of %@
-[StreamingUnzipper setupUnzipperWithOutputPath:sandboxExtensionToken:options:withReply:]
Streaming Unzipper running with unexpected QOS: expected=0x%x actual=0x%x
Failed to consume sandbox extension token "%s" for "%@" : %s
Initialized with path %@ ; hashed chunk size %llu ; hashes %@
/Library/Caches/com.apple.xbs/Sources/StreamingZip_Sim/StreamingZip-154.40.3/StreamingUnzipService/StreamingUnzipper.m
error || _currentState
com.apple.streamingzip.incomplete_extraction
Failed to set incomplete extraction xattr on %@ : %s
-[StreamingUnzipper setActiveDelegateMethods:]
Set active delegate methods to 0x%x
-[StreamingUnzipper dealloc]
Deallocating state for extraction to %@
-[StreamingUnzipper _setErrorState]
Failed to remove unzip path at %@ : %@
-[StreamingUnzipper _beginNonStreamablePassthroughWithRemainingBytes:length:]
Beginning passthrough of non-streamable zip file to %@
Failed to open passthrough output file at %@: %s
Failed to write initial data to passthrough output file: %s
Failed to write remaining initial data to passthrough output file: %s
-[StreamingUnzipper _supplyBytes:length:withReply:]
Unzipper did not have any state! Client should suspend stream and resume from the given offset.
_currentState.currentLFRecord
_currentState.thisStageBytesComplete <= peekSignatureSize
Got unexpected local file signature %c%c%c%c ; entering passthrough mode
Finished central directory signature at offset %llu and we are also at a chunk boundary.
Last chunk's partial hash did not validate (store hashed chunk size mismatch?); consuming more data to check full chunk.
No last chunk partial hash; will need full chunk to validate.
Finished central directory signature; updating hash with remainder of stream data
After hitting Central Directory, we had enough data already to finish the chunk
lengthToRead == length
After hitting Central Directory, we need more data to finish the chunk
Encountered unexpectedly non-stream-compliant data in stream!
Got zero-length filename; entering passthrough mode
Encountered zero-length filename for local file record at offset %llu
Got unexpected compression method: %hu; entering passthrough mode
Encountered unsupported compression method %hu in stream at offset %llu
File has 0-length compressed size but non-zero uncompressed size; entering passthrough mode
Encountered inconsistency in stream data: file at offset %llu has a 0-length compressed size but a non-zero uncompressed size
Stored file has compressed size != uncompressed size; entering passthrough mode
Encountered inconsistency in stream data: file at offset %llu is stored without compression but the uncompressed and compressed sizes are not equal (%llu != %llu)
_currentState.thisStageBytesComplete >= sizeof(LocalFileRecord)
_currentState.thisStageBytesComplete == fullLFRSize
Failed to get filename for file; entering passthrough mode
Failed to get filename for file at offset %llu.
Processing file %@ (csize: ??; usize: ??)
Processing file %@ (csize: %llu; usize: %llu)
Got directory %s with non-zero compressed data size; entering passthrough mode
Directory %s has a non-zero compressed size; directories aren't supposed to have data.
_currentState.recordsProcessed <= 2
mimetype
Item %lld (%s) in archive was not 'mimetype' or %s; entering passthrough mode
File %s is metadata file, so keeping in memory
File %s is fixed metadata file, so keeping in memory
File %s is a symlink (mode = 0%o), so keeping in memory
File %s is larger than 5 MB (%llu) so not keeping in memory
Parent path %@ did not exist
Failed to create parent directory %@: %s
Can't determine if parent path exists %@: %s
Failed to create directory at path %@: %s
Failed to set proper mode on directory %@: %s
_currentState.currentOutputFD < 0
advisory preallocation of %lld bytes for %@ failed: %s
_currentState.currentOutputFD >= 0
Failed to write data to output file %@: %s
Failed to initialize compression: %d
compression_stream_process consumed %zu bytes
outputSize >= cmpState->dst_size
compression_stream_process returned unexpected result %d
Failed to write decompressed data to output file %@ : %s
Hit stream end with %llu remaining
Hit stream end at %llu, before expected size %llu
Unknown compression method %hu for file %@
0 == length
_currentState.thisStageBytesComplete == expected_size
Data descriptor did not match expected signature (found 0x%02hhx%02hhx%02hhx%02hhx); entering passthrough mode
Data descriptor did not match expected signature (found 0x%02hhx%02hhx%02hhx%02hhx).
Got data descriptor with CRC 0x%x, uncompressed size %llu, compressed size %llu
Got data descriptor with CRC 0x%x, uncompressed size %u, compressed size %u
Decompression failed to produce all expected output data for file %@; produced %llu bytes, expected %llu
CRC mismatch; got: 0x%lx expected: 0x%x for file %@
Couldn't get filename for stream metadata file; entering passthrough mode
Couldn't get filename for current file "%s"
_currentState.inMemoryFileData
Failed to decode stream metadata; entering passthrough mode
Failed to read stream metadata from %@; entering passthrough mode
Got stream metadata: %@
Stream metadata was incompatible version or not present; entering passthrough mode
Failed to read fixed stream metadata from %@: %@
Got last chunk partial hash %@
Found last chunk partial hash data but the hash was not computed.
Got a fixed metadata file that did not match expected content (length %lu). Ignoring.
Failed to read symlink path from %@: %@
Invalid symlink: %s -> %s (absolute symlinks are forbidden)
Invalid symlink: %s -> %s
Failed to create symlink at %s to %s: %s
Failed to set mode of %@ to 0%o: %s
Not doing anything with data for file %@
Failed to write data to passthrough output file: %s
Invalid unzip state encountered: %hhu
-[StreamingUnzipper supplyBytes:withReply:]_block_invoke
Got block of length %lu at offset %lu
-[StreamingUnzipper suspendStreamWithReply:]
Suspending extraction at offset %llu for %@
-[StreamingUnzipper finishStreamWithReply:]
Finishing extraction for %@
Failed to remove xattr named %s on %@ : %s
-[StreamingUnzipper terminateStreamWithReply:]
Unzipper did not have any state, but the client was terminating the stream anyway.
Terminating extraction for %@
xpcConnection
T@"NSXPCConnection",W,N,VxpcConnection
inProcessExtractorDelegate
T@"<StreamingUnzipDelegateProtocol>",W,N,VinProcessExtractorDelegate
inProcessDelegateQueue
T@"NSObject<OS_dispatch_queue>",&,N,VinProcessDelegateQueue
_GetUncompressedSize
currentState.streamState > kStreamStateIncompleteDataDescriptor
NULL != currentState.dataDescriptor
_GetCompressedSize
_GetCRC32
_CheckRealpathHasBasePrefix
Rejecting "%s" because its resolved path "%@" points outside or to the unzip dir %@
_ValidateAllSymlinksUnderPath
base directory path cannot be nil
base directory URL cannot be nil (created from path: "%@")
B24@?0^{_ftsent=^{_ftsent}^{_ftsent}^{_ftsent}q^v**iiSSQiSsSSS^{stat}[1c]}8^@16
_TraverseDirectory
directory url fileSystemRepresentation cannot be NULL
fts_open failed for %s with error %s
Error for path %s: %s
fts_close on FTS for %s returned %s
SZExtractorErrorDomain
SZExtractorFileOffsetErrorKey
SZExtractorCompressionLibErrorKey
SZExtractorFunctionNameErrorKey
SZExtractorSourceFileLineErrorKey
SZExtractorActualHashValueErrorKey
SZExtractorHashChunkIndexErrorKey
GetFileNameStringFromLocalFileRecord
Failed to get name from local file record.
%02x
ImmutableOpen
Could not mark %s static: %s
Unable to set F_NOCACHE accessing file %s %s
Unable to set F_SINGLE_WRITER on %s %s
StreamingUnzipProtocol
StreamingUnzipDelegateProtocol
StreamingUnzipServiceDelegate
NSXPCListenerDelegate
NSObject
SZExtractorInternalDelegate
SZExtractor
NSSecureCoding
NSCoding
NSCopying
StreamingUnzipState
StreamingUnzipper
processIdentifier
setupUnzipperWithOutputPath:sandboxExtensionToken:options:withReply:
supplyBytes:withReply:
suspendStreamWithReply:
finishStreamWithReply:
terminateStreamWithReply:
setActiveDelegateMethods:
interfaceWithProtocol:
setExportedInterface:
initForClient:
setExportedObject:
setExtractionProgress:
extractionCompleteAtArchivePath:
extractionEnteredPassThroughMode
setRemoteObjectInterface:
setXpcConnection:
setInterruptionHandler:
setInvalidationHandler:
resume
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
listener:shouldAcceptNewConnection:
standardUserDefaults
boolForKey:
serviceListener
setDelegate:
initWithBytes:length:encoding:
lastPathComponent
stringWithFormat:
delegate
.cxx_destruct
init
decodePropertyListForKey:
decodeObjectOfClass:forKey:
decodeBoolForKey:
needsPreparation
_isValidObject
_suspendStreamWithCompletionBlockSynchronously:completion:
options
encodeObject:forKey:
extractionPath
isLocalExtractor
encodeBool:forKey:
allocWithZone:
initWithPath:options:
objectForKeyedSubscript:
exceptionWithName:reason:userInfo:
count
copy
_setUpWithPath:options:
initWithPath:options:resumptionOffset:
_synchronouslyPrepareForExtractionAtOffset:
numberWithUnsignedLongLong:
dictionaryWithObjectsAndKeys:
_prepareForExtractionSynchronously:withCompletionBlock:
serialQueue
initWithServiceName:
unzipServiceConnection
setError:
internalExtractorDelegate
_invalidateObject
dictionaryWithObjects:forKeys:count:
errorWithDomain:code:userInfo:
defaultManager
fileExistsAtPath:
numberWithUnsignedShort:
createDirectoryAtPath:withIntermediateDirectories:attributes:error:
fileSystemRepresentationWithPath:
stringWithFileSystemRepresentation:length:
setLastResumptionOffset:
synchronousRemoteObjectProxyWithErrorHandler:
remoteObjectProxyWithErrorHandler:
lastResumptionOffset
error
inProcessUnzipper
setInProcessExtractorDelegate:
setInProcessDelegateQueue:
hasHadPostSetupMethodsCalled
_prepareForLocalExtraction:
_prepareForRemoteExtractionSynchronously:withCompletionBlock:
setExtractionPath:
prepareForExtraction:
invalidate
length
setHasHadPostSetupMethodsCalled:
enumerateByteRangesUsingBlock:
subdataWithRange:
setActiveExtractorDelegateMethods:
setExtractorDelegate:
stringByDeletingLastPathComponent
supportsSecureCoding
enableDebugLogging
encodeWithCoder:
initWithCoder:
supplyBytes:withCompletionBlock:
suspendStreamWithCompletionBlock:
finishStreamWithCompletionBlock:
terminateStreamWithError:completionBlock:
extractorDelegate
consumeExtractedDataIfNeeded
prepareForExtractionToPath:completionBlock:
doesConsumeExtractedData
copyWithZone:
initWithOptions:
initWithPath:resumptionOffset:
initWithPath:md5Hashes:hashedChunkSize:resumptionOffset:
initForRemoteExtractionWithPath:options:resumptionOffset:
initForLocalExtractionWithPath:options:resumptionOffset:
setNeedsPreparation:
_isLocalExtractor
_needsPreparation
_hasHadPostSetupMethodsCalled
_extractionPath
_options
_lastResumptionOffset
_unzipServiceConnection
_inProcessUnzipper
_serialQueue
_internalExtractorDelegate
_error
dealloc
setLength:
markResumptionPoint
fileSystemRepresentation
stringByAppendingPathComponent:
initRequiringSecureCoding:
setOutputFormat:
encodeInt:forKey:
encodeBytes:length:forKey:
encodedData
bytes
numberWithUnsignedLong:
dataWithBytesNoCopy:length:freeWhenDone:
numberWithUnsignedChar:
writeToFile:options:error:
objectAtIndex:
caseInsensitiveCompare:
_checkHashForOffset:
updateHashFromOffset:withBytes:length:onlyFinishCurrentChunk:
clearSavedState
setStreamState:
objectForKey:
unsignedLongLongValue
boolValue
dataWithCapacity:
mutableBytes
initForReadingFromData:error:
setDecodingFailurePolicy:
decodeIntForKey:
decodeBytesForKey:returnedLength:
dataWithContentsOfFile:options:error:
domain
code
contentsOfDirectoryAtPath:error:
removeItemAtPath:error:
mutableCopy
unsignedCharValue
unsignedLongValue
unsignedShortValue
getBytes:length:
finishDecoding
initWithPath:options:error:
unzipStateWithPath:options:error:
cmpState
_internalSetStreamState:
setCurrentOutputFD:
serializeState
checkLastChunkPartialHash
updateHashFromOffset:withBytes:length:
finishStream
unzipPath
hashContext
streamInfoDict
setStreamInfoDict:
lastChunkPartialHash
setLastChunkPartialHash:
unsureData
setUnsureData:
inMemoryFileData
setInMemoryFileData:
currentLFRecord
setCurrentLFRecord:
currentLFRecordAllocationSize
setCurrentLFRecordAllocationSize:
thisStageBytesComplete
setThisStageBytesComplete:
currentOffset
setCurrentOffset:
currentCRC32
setCurrentCRC32:
currentOutputFD
recordsProcessed
setRecordsProcessed:
totalRecordCount
setTotalRecordCount:
totalUncompressedBytes
setTotalUncompressedBytes:
currentLFMode
setCurrentLFMode:
streamState
storeCurrentFileInMemory
setStoreCurrentFileInMemory:
currentLFRequiresDataDescriptor
setCurrentLFRequiresDataDescriptor:
bytesHashedInChunk
hashedChunkSize
uncompressedBytesOutput
setUncompressedBytesOutput:
totalFileSizeWritten
setTotalFileSizeWritten:
dataDescriptor
setDataDescriptor:
denyInvalidSymlinks
setDenyInvalidSymlinks:
_cmpState
_lastResumptionSavedOffset
_hashedChunkSize
_bytesHashedInChunk
_uncompressedBytesOutput
_totalFileSizeWritten
_unzipPath
_hashes
_currentLFRecordAllocationSize
_hashContext
_streamInfoDict
_lastChunkPartialHash
_unsureData
_inMemoryFileData
_currentLFRecord
_dataDescriptor
_thisStageBytesComplete
_currentOffset
_recordsProcessed
_totalRecordCount
_totalUncompressedBytes
_currentCRC32
_currentOutputFD
_currentLFMode
_streamState
_storeCurrentFileInMemory
_currentLFRequiresDataDescriptor
_denyInvalidSymlinks
isEqualToString:
UTF8String
unsignedIntValue
_extractionEnteredPassThroughMode
_setErrorState
xpcConnection
remoteObjectProxy
inProcessExtractorDelegate
inProcessDelegateQueue
_beginNonStreamablePassthroughWithRemainingBytes:length:
appendBytes:length:
_sendExtractionProgress:
numberWithInt:
propertyListWithData:options:format:error:
inputStreamWithFileAtPath:
propertyListWithStream:options:format:error:
intValue
_sendExtractionCompleteAtArchivePath:
_supplyBytes:length:withReply:
_sandboxToken
_decompressionOutputBuffer
_currentState
_sessionTransaction
_activeDelegateMethods
_lastExtractionProgressSent
pathComponents
countByEnumeratingWithState:objects:count:
objectAtIndexedSubscript:
fileURLWithPath:isDirectory:
fileURLWithFileSystemRepresentation:isDirectory:relativeToURL:
path
initWithFormat:arguments:
setObject:forKeyedSubscript:
stringWithUTF8String:
stringWithCapacity:
appendFormat:
defaultCStringEncoding
componentsSeparatedByString:
removeObjectAtIndex:
componentsJoinedByString:
Got connection from process %@ at qos %@
Debug logging is enabled
Streaming unzip service built at %s %s started
%@: deserialized
%@: suspending stream in preparation for serializing ourselves
%@: Suspending stream prior to encoding failed with error: %@
%@: serialized
%@: Streaming zip extraction is being done in-process
%@: initialized with path: %@ options: %@
%@: prepare for extraction failed: %@
Failed to create NSXPCConnection
Connection interrupted to streaming unzip service.
Failed to create extraction directory at path %@: %@
Failed to realpath "%@" at "%s": %s
Failed to issue sandbox extension for "%s" : %s
%@: prepare returning error %@
%@: calling prepare completion block with offset %llu, error %@
%@: preparing
extractionPath was nil. Did you mean to call -prepareForExtractionToPath:completionBlock: instead?
Calling %s after any calls to other non-init methods on this instance is an error.
%@: prepare called on extractor that had already returned error %@
%@: prepare called on object that was already prepared; returning resumption offset %llu
%@: preparing for extraction to path %@
%@: invalidating
%@: got buffer of length %lu
%@: supply called on extractor that had already returned error %@
%s called before -[SZExtractor prepareForExtraction:] on %@
%s called on an invalidated object: %@
%@: calling completion block with no error, dataComplete=%c
Supplying entire byte range data of length %lu
Already processed {%lu, %lu}
Reserved %ld bytes; adding to existing length %ld
Failed to reserve last range; falling out with last range {%lu, %lu}
Waiting for %lu bytes to become available
Reserved %ld bytes for too-big partial range {%lu, %lu}
Reserved %ld bytes at %ld for too-big partial range {%lu, %lu}
Supplying byte range data of length %lu at location %lu
Active partial range {%lu, %lu} exhausted
%@: suspending stream
%@: suspend called on extractor that had already returned error %@
%@: calling completion block with offset %llu, error %@
%@: finishing stream
%@: finish called on extractor that had already returned error %@
%@: calling completion block with error %@
%@: terminating stream with error %@
%@: terminate called on extractor that had already returned error %@
%@: %s was called before -[SZExtractor prepareForExtraction:]; this doesn't do anything
%@: %s was called on an invalidated object
%@: Setting extractor delegate to 0x%p
%@: setting active extractor delegate methods to 0x%x
%@: Failed to set delegate methods enabled: %@
Updating stream state from %@ to %@
Failed to create archive for passthrough EA on path %@
Failed to set passthrough EA %s on path %@: %s
Mismatch between uncompressed bytes output (%llu) and output file offset (%lld)
Failed to create archive for resumption data to path %@
Serializing %lu bytes of resumption data for offset %llu
Failed to save resumption data to path %@: %@
Cannot validate hash; this chunk is index %llu, but we only have %lu hashes.
Hash mismatch for chunk containing offset %llu: expected %@, got %@
Verified that hashed data offset %llu matches index %llu: %@
Hash mismatch for last partial chunk: expected %@, got %@
Verified that last chunk partial hash matches: %@
Ambiguous or missing hash chunk size: chunk size is %llu but have %lu hashes
Finishing an incomplete stream! This stream will not be resumable.
Failed to init
Options dictionary supplied has one or more options with an incorrect type.
Could not allocate memory for local file record
Ambiguous chunk size (hashes > 1 but chunkSize == 0)
Hash chunk size given as > 0, but no hashes
Failed to stat path %@: %s
Failed to get size of xattr %s from path %@: %s
Expected to read %ld bytes but got %ld for EA %s on %@; resuming from offset 0
Failed to remove EA %s from %s: %s
Unable to deserialize resumption data (%@); resuming from offset 0
Failed to read resumption data from path %@: %@; starting from offset 0
Failed to remove %@: %@
Found resumption data version %d, but expected %d at %@; resuming from offset 0
Failed to deserialize resumption data (%@); resuming from offset 0
Computed index of current hash chunk (%llu) is not within supplied hashes array of %lu elements; resuming from offset 0
Serialized %s context (%lu bytes) did not match size of struct (%lu bytes); resuming from offset 0
Failed to get path from current local file record.
Resuming %@ at offset %lld
Failed to open output file at path %@: %s
Failed to get serialized compression state from save data
Compression save state was not valid.
Failed to seek to offset %llu in output file at path %@: %s
Invalid state in resumption data at path %@
Value of key %@ in options dictionary was not an object of type %@. Was %@
Unsupported hash type: %@. Defaulting to MD5
Failed to remove partially extracted bad data to start over: %@
Failed to get protection class on %s : %s
Failed to open %s : %s
Failed to set protection class on %s to %d: %s
Streaming Unzipper running with unexpected QOS: expected=0x%x actual=0x%x
Failed to consume sandbox extension token "%s" for "%@" : %s
Initialized with path %@ ; hashed chunk size %llu ; hashes %@
Failed to set incomplete extraction xattr on %@ : %s
Set active delegate methods to 0x%x
Deallocating state for extraction to %@
Failed to remove unzip path at %@ : %@
Beginning passthrough of non-streamable zip file to %@
Failed to open passthrough output file at %@: %s
Failed to write initial data to passthrough output file: %s
Failed to write remaining initial data to passthrough output file: %s
Unzipper did not have any state! Client should suspend stream and resume from the given offset.
Got unexpected local file signature %c%c%c%c ; entering passthrough mode
Finished central directory signature at offset %llu and we are also at a chunk boundary.
Last chunk's partial hash did not validate (store hashed chunk size mismatch?); consuming more data to check full chunk.
No last chunk partial hash; will need full chunk to validate.
Finished central directory signature; updating hash with remainder of stream data
After hitting Central Directory, we had enough data already to finish the chunk
After hitting Central Directory, we need more data to finish the chunk
Encountered unexpectedly non-stream-compliant data in stream!
Got zero-length filename; entering passthrough mode
Encountered zero-length filename for local file record at offset %llu
Got unexpected compression method: %hu; entering passthrough mode
Encountered unsupported compression method %hu in stream at offset %llu
File has 0-length compressed size but non-zero uncompressed size; entering passthrough mode
Encountered inconsistency in stream data: file at offset %llu has a 0-length compressed size but a non-zero uncompressed size
Stored file has compressed size != uncompressed size; entering passthrough mode
Encountered inconsistency in stream data: file at offset %llu is stored without compression but the uncompressed and compressed sizes are not equal (%llu != %llu)
Failed to get filename for file; entering passthrough mode
Failed to get filename for file at offset %llu.
Processing file %@ (csize: ??; usize: ??)
Processing file %@ (csize: %llu; usize: %llu)
Got directory %s with non-zero compressed data size; entering passthrough mode
Directory %s has a non-zero compressed size; directories aren't supposed to have data.
Item %lld (%s) in archive was not 'mimetype' or %s; entering passthrough mode
File %s is metadata file, so keeping in memory
File %s is fixed metadata file, so keeping in memory
File %s is a symlink (mode = 0%o), so keeping in memory
File %s is larger than 5 MB (%llu) so not keeping in memory
Parent path %@ did not exist
Failed to create parent directory %@: %s
Can't determine if parent path exists %@: %s
Failed to create directory at path %@: %s
Failed to set proper mode on directory %@: %s
advisory preallocation of %lld bytes for %@ failed: %s
Failed to write data to output file %@: %s
Failed to initialize compression: %d
compression_stream_process consumed %zu bytes
compression_stream_process returned unexpected result %d
Failed to write decompressed data to output file %@ : %s
Hit stream end with %llu remaining
Hit stream end at %llu, before expected size %llu
Unknown compression method %hu for file %@
Data descriptor did not match expected signature (found 0x%02hhx%02hhx%02hhx%02hhx); entering passthrough mode
Data descriptor did not match expected signature (found 0x%02hhx%02hhx%02hhx%02hhx).
Got data descriptor with CRC 0x%x, uncompressed size %llu, compressed size %llu
Got data descriptor with CRC 0x%x, uncompressed size %u, compressed size %u
Decompression failed to produce all expected output data for file %@; produced %llu bytes, expected %llu
CRC mismatch; got: 0x%lx expected: 0x%x for file %@
Couldn't get filename for stream metadata file; entering passthrough mode
Couldn't get filename for current file "%s"
Failed to read stream metadata from %@; entering passthrough mode
Failed to decode stream metadata; entering passthrough mode
Got stream metadata: %@
Stream metadata was incompatible version or not present; entering passthrough mode
Failed to read fixed stream metadata from %@: %@
Got last chunk partial hash %@
Found last chunk partial hash data but the hash was not computed.
Got a fixed metadata file that did not match expected content (length %lu). Ignoring.
Failed to read symlink path from %@: %@
Invalid symlink: %s -> %s (absolute symlinks are forbidden)
Invalid symlink: %s -> %s
Failed to create symlink at %s to %s: %s
Failed to set mode of %@ to 0%o: %s
Not doing anything with data for file %@
Failed to write data to passthrough output file: %s
Invalid unzip state encountered: %hhu
Got block of length %lu at offset %lu
Suspending extraction at offset %llu for %@
Finishing extraction for %@
Failed to remove xattr named %s on %@ : %s
Unzipper did not have any state, but the client was terminating the stream anyway.
Terminating extraction for %@
Rejecting "%s" because its resolved path "%@" points outside or to the unzip dir %@
base directory path cannot be nil
base directory URL cannot be nil (created from path: "%@")
directory url fileSystemRepresentation cannot be NULL
fts_open failed for %s with error %s
Error for path %s: %s
fts_close on FTS for %s returned %s
Failed to get name from local file record.
Could not mark %s static: %s
Unable to set F_NOCACHE accessing file %s %s
Unable to set F_SINGLE_WRITER on %s %s
v48@0:8@16*24@32@?40
v32@0:8@16@?24
v24@0:8@?16
v20@0:8i16
v48@0:8@"NSString"16*24@"NSDictionary"32@?<v@?@"NSError"Q>40
v32@0:8@"NSData"16@?<v@?@"NSError"B>24
v24@0:8@?<v@?Q@"NSError">16
v24@0:8@?<v@?@"NSError">16
v24@0:8d16
v24@0:8@16
v16@0:8
v24@0:8@"NSString"16
B24@0:8@16
#16@0:8
@16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
B32@0:8@16@24
B32@0:8@"NSXPCListener"16@"NSXPCConnection"24
@"<SZExtractorDelegate>"
@24@0:8@16
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
v32@0:8@"NSError"16@?<v@?@"NSError">24
@"<SZExtractorDelegate>"16@0:8
v24@0:8@"<SZExtractorDelegate>"16
v32@0:8@"NSString"16@?<v@?Q@"NSError">24
@24@0:8^{_NSZone=}16
v32@0:8@16@24
@32@0:8@16@24
@32@0:8@16^Q24
@40@0:8@16@24^Q32
@48@0:8@16@24Q32^Q40
B24@0:8^Q16
v28@0:8B16@?20
v24@0:8Q16
v20@0:8B16
@"NSString"
@"NSDictionary"
@"NSXPCConnection"
@"StreamingUnzipper"
@"NSObject<OS_dispatch_queue>"
@"SZExtractorInternalDelegate"
@"NSError"
@40@0:8@16@24^@32
^{?=*Q*Q^v}16@0:8
v20@0:8C16
@24@0:8Q16
@44@0:8Q16r^v24Q32B40
@40@0:8Q16r^v24Q32
{?=i(?={CC_MD5state_st=IIIIII[16I]i}{CC_SHA1state_st=IIIIIII[16I]i}{CC_MD2state_st=i[16C][16I][16I]}{CC_MD4state_st=IIIIII[16I]I}{CC_SHA256state_st=[2I][8I][16I]}{CC_SHA256state_st=[2I][8I][16I]}{CC_SHA512state_st=[2Q][8Q][16Q]}{CC_SHA512state_st=[2Q][8Q][16Q]})}16@0:8
^{?=[4C]{?=S}{?=S}{?=S}(?={?={?=S}{?=S}}{?=I}){?=I}{?=I}{?=I}{?=S}{?=S}[0C]}16@0:8
v24@0:8^{?=[4C]{?=S}{?=S}{?=S}(?={?={?=S}{?=S}}{?=I}){?=I}{?=I}{?=I}{?=S}{?=S}[0C]}16
i16@0:8
S16@0:8
v20@0:8S16
C16@0:8
^{?=[4C](?={?={?=I}{?=Q}{?=Q}}{?={?=I}{?=I}{?=I}})}16@0:8
v24@0:8^{?=[4C](?={?={?=I}{?=Q}{?=Q}}{?={?=I}{?=I}{?=I}})}16
{?="dst_ptr"*"dst_size"Q"src_ptr"*"src_size"Q"state"^v}
@"NSArray"
{?="hashType"i"context"(?="md5"{CC_MD5state_st="A"I"B"I"C"I"D"I"Nl"I"Nh"I"data"[16I]"num"i}"sha1"{CC_SHA1state_st="h0"I"h1"I"h2"I"h3"I"h4"I"Nl"I"Nh"I"data"[16I]"num"i}"md2"{CC_MD2state_st="num"i"data"[16C]"cksm"[16I]"state"[16I]}"md4"{CC_MD4state_st="A"I"B"I"C"I"D"I"Nl"I"Nh"I"data"[16I]"num"I}"sha224"{CC_SHA256state_st="count"[2I]"hash"[8I]"wbuf"[16I]}"sha256"{CC_SHA256state_st="count"[2I]"hash"[8I]"wbuf"[16I]}"sha384"{CC_SHA512state_st="count"[2Q]"hash"[8Q]"wbuf"[16Q]}"sha512"{CC_SHA512state_st="count"[2Q]"hash"[8Q]"wbuf"[16Q]})}
@"NSMutableData"
^{?=[4C]{?=S}{?=S}{?=S}(?={?={?=S}{?=S}}{?=I}){?=I}{?=I}{?=I}{?=S}{?=S}[0C]}
^{?=[4C](?={?={?=I}{?=Q}{?=Q}}{?={?=I}{?=I}{?=I}})}
@32@0:8r^v16Q24
v40@0:8r*16Q24@?32
@"StreamingUnzipState"
@"NSObject<OS_os_transaction>"
@"<StreamingUnzipDelegateProtocol>"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>seatbelt-profiles</key>
<array>
<string>StreamingUnzipService</string>
</array>
</dict>
</plist>
SZMdFx
