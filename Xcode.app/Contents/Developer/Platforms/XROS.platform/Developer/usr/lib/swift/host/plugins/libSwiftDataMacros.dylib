_pSg
SgtG
_pSg
ySS_SSSgA2BtG
SS_SSSgA2At
ySSG
SwiftDataMacros
SwiftDataDiagnostic
SwiftDataMacro
PersistentModelMacro
PersistentModelActorMacro
PersistedPropertyMacro
TransformablePersistedPropertyMacro
PersistedDerivedPropertyMacro
TransientPropertyMacro
AttributePropertyMacro
DerivedPropertyMacro
RelationshipPropertyMacro
UniqueConstraintsMacro
IndexMacro
QueryMacro
message
diagnosticID
severity
unique macro constrained to another persistent model
unique macro must be within a persistent model
unique macro must be within a class
unique macro expects an array of keypaths
index macro expects an array of keypaths or Index
query-var-missing-type-annotation
query-var-expected-identifier
query-var-expected-simple-name
query-only-applicable-to-var
invalid property
invalid composition
index macro constrained to another persistent model
index on non-stored property
index on transient property
index on computed property
index macro must be within a persistent model
index macro must be within a class
missing default value
missing initializer
duplicate index macro
duplicate unique macro
unique constraint on non-stored property
unique constraint on transient property
unique constraint on computed property
SwiftData.PersistentModel
Observation.Observable
@Model requires an initializer be provided for '
@Transient
private var _$backingData: any SwiftData.BackingData<
.createBackingData()
public var persistentBackingData: any SwiftData.BackingData<
    get {
        _$backingData
    }
    set {
        _$backingData = newValue
    }
SwiftData.Schema.PropertyMetadata(name: "
, defaultValue: 
 = _SwiftDataNoType()
static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
  return [
    
init(backingData: any SwiftData.BackingData<
  self.persistentBackingData = backingData
@Transient
private let _$observationRegistrar = Observation.ObservationRegistrar()
struct _SwiftDataNoType {}
static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
  let storedProperties = [
    
  var otherProperties = [SwiftData.Schema.PropertyMetadata]()
  return storedProperties+otherProperties
if #available(iOS 18, *) {
    otherProperties.append(
      SwiftData.Schema.PropertyMetadata(name: "SwiftData.Schema.Unique", keypath: \SwiftData.Schema.encodingVersion, defaultValue: nil, metadata: SwiftData.Schema.Unique
if #available(iOS 18, *) {
    otherProperties.append(
      SwiftData.Schema.PropertyMetadata(name: "SwiftData.Schema.Index", keypath: \SwiftData.Schema.encodingVersion, defaultValue: nil, metadata: SwiftData.Schema.Index
#Unique expects an Array Expression with Keypaths - 
#Unique has a duplicate constraint - 
SwiftDataMacros/PersistentModelMacro.swift
Fatal error
An unsupported keypath got past compilation for #Unique
A non-stored property - 
 - cannot be used in an Unique Constraint
A computed property - 
A transient property - 
#Unique is constrained to another PersistentModel - '
#Index expects an Array Expression with Keypaths - 
#Index has a duplicate index - 
An unsupported keypath got past compilation for #Index
 - cannot be used in an Index
#Index is constrained to another PersistentModel - '
description
A stored property cannot be named '
A stored property name cannot be a keyword
A default value requires a fully qualified domain named value
SwiftData.Schema.
.persistentModelID
@Attribute and @Relationship cannot be composed
#Index can only be used once per PersistentModel
#Unique can only be used once per PersistentModel
#Unique can only be used within a class
#Unique can only be used within a PersistentModel
#Index can only be used within a class
#Index can only be used within a PersistentModel
_$observationRegistrar.access(self, keyPath: \.
return self.getValue(forKey: \.
@Transient
private var _
: _SwiftDataNoType
_$observationRegistrar
@storageRestrictions(accesses: _$backingData, initializes: _
init(initialValue) {
_$backingData.setTransformableValue(forKey: \.
, to: initialValue)
 = _SwiftDataNoType()
return self.getTransformableValue(forKey: \.
_$observationRegistrar.withMutation(of: self, keyPath: \.
self.setTransformableValue(forKey: \.
, to: newValue)
_$backingData.setValue(forKey: \.
self.setValue(forKey: \.
nonisolated let modelExecutor: any SwiftData.ModelExecutor
nonisolated let modelContainer: SwiftData.ModelContainer
init(modelContainer: SwiftData.ModelContainer) {
    let modelContext = ModelContext(modelContainer)
    self.modelExecutor = DefaultSerialModelExecutor(modelContext: modelContext)
    self.modelContainer = modelContainer
: SwiftData.ModelActor {}
_PersistedProperty
_TransformablePersistedProperty
@Transient requires non-optional property '
' to have a default value
: SwiftData.PersistentModel {}
: Observation.Observable {}
: SwiftData.Query<
// This is not the final @Query macro expansion.
get { fatalError() }
Property missing a type annotation
Expected an identifier for the property
@Query can only be applied to a 'var' declaration
@Query can only be applied to a 'var' declaration with a simple name
future reported an error, but wait cannot throw
swift_task_escalate
_Z19voucher_needs_adoptP9voucher_s
__tsan_acquire
__tsan_release
swift_task_enterThreadLocalContext
swift_task_exitThreadLocalContext
_pSg
SgtG
_pSg
ySS_SSSgA2BtG
SS_SSSgA2At
ySSG
 $(,048?CGKOSW[_cSwiftDataMacros
SwiftDataDiagnostic
NoTypeForYou
SwiftDataMacro
PersistentModelMacro
PersistentModelActorMacro
PersistedPropertyMacro
TransformablePersistedPropertyMacro
PersistedDerivedPropertyMacro
TransientPropertyMacro
AttributePropertyMacro
DerivedPropertyMacro
RelationshipPropertyMacro
UniqueConstraintsMacro
IndexMacro
QueryMacro
message
diagnosticID
severity
unique macro constrained to another persistent model
unique macro must be within a persistent model
unique macro must be within a class
unique macro expects an array of keypaths
index macro expects an array of keypaths or Index
query-var-missing-type-annotation
query-var-expected-identifier
query-var-expected-simple-name
query-only-applicable-to-var
invalid property
invalid composition
index macro constrained to another persistent model
index on non-stored property
index on transient property
index on computed property
index macro must be within a persistent model
index macro must be within a class
missing default value
missing initializer
duplicate index macro
duplicate unique macro
unique constraint on non-stored property
unique constraint on transient property
unique constraint on computed property
SwiftData.PersistentModel
Observation.Observable
@Model requires an initializer be provided for '
@Transient
private var _$backingData: any SwiftData.BackingData<
.createBackingData()
public var persistentBackingData: any SwiftData.BackingData<
    get {
        _$backingData
    }
    set {
        _$backingData = newValue
    }
SwiftData.Schema.PropertyMetadata(name: "
, defaultValue: 
 = _SwiftDataNoType()
static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
  return [
    
init(backingData: any SwiftData.BackingData<
  self.persistentBackingData = backingData
@Transient
private let _$observationRegistrar = Observation.ObservationRegistrar()
struct _SwiftDataNoType {}
static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
  let storedProperties = [
    
  var otherProperties = [SwiftData.Schema.PropertyMetadata]()
  return storedProperties+otherProperties
if #available(iOS 18, *) {
    otherProperties.append(
      SwiftData.Schema.PropertyMetadata(name: "SwiftData.Schema.Unique", keypath: \SwiftData.Schema.encodingVersion, defaultValue: nil, metadata: SwiftData.Schema.Unique
if #available(iOS 18, *) {
    otherProperties.append(
      SwiftData.Schema.PropertyMetadata(name: "SwiftData.Schema.Index", keypath: \SwiftData.Schema.encodingVersion, defaultValue: nil, metadata: SwiftData.Schema.Index
#Unique expects an Array Expression with Keypaths - 
#Unique has a duplicate constraint - 
SwiftDataMacros/PersistentModelMacro.swift
Fatal error
An unsupported keypath got past compilation for #Unique
A non-stored property - 
 - cannot be used in an Unique Constraint
A computed property - 
A transient property - 
#Unique is constrained to another PersistentModel - '
#Index expects an Array Expression with Keypaths - 
#Index has a duplicate index - 
An unsupported keypath got past compilation for #Index
 - cannot be used in an Index
#Index is constrained to another PersistentModel - '
description
A stored property cannot be named '
A stored property name cannot be a keyword
A default value requires a fully qualified domain named value
SwiftData.Schema.
.persistentModelID
@Attribute and @Relationship cannot be composed
#Index can only be used once per PersistentModel
#Unique can only be used once per PersistentModel
#Unique can only be used within a class
#Unique can only be used within a PersistentModel
#Index can only be used within a class
#Index can only be used within a PersistentModel
_$observationRegistrar.access(self, keyPath: \.
return self.getValue(forKey: \.
@Transient
private var _
: _SwiftDataNoType
_$observationRegistrar
@storageRestrictions(accesses: _$backingData, initializes: _
init(initialValue) {
_$backingData.setTransformableValue(forKey: \.
, to: initialValue)
 = _SwiftDataNoType()
return self.getTransformableValue(forKey: \.
_$observationRegistrar.withMutation(of: self, keyPath: \.
self.setTransformableValue(forKey: \.
, to: newValue)
_$backingData.setValue(forKey: \.
self.setValue(forKey: \.
nonisolated let modelExecutor: any SwiftData.ModelExecutor
nonisolated let modelContainer: SwiftData.ModelContainer
init(modelContainer: SwiftData.ModelContainer) {
    let modelContext = ModelContext(modelContainer)
    self.modelExecutor = DefaultSerialModelExecutor(modelContext: modelContext)
    self.modelContainer = modelContainer
: SwiftData.ModelActor {}
_PersistedProperty
_TransformablePersistedProperty
@Transient requires non-optional property '
' to have a default value
: SwiftData.PersistentModel {}
: Observation.Observable {}
: SwiftData.Query<
// This is not the final @Query macro expansion.
get { fatalError() }
Property missing a type annotation
Expected an identifier for the property
@Query can only be applied to a 'var' declaration
@Query can only be applied to a 'var' declaration with a simple name
future reported an error, but wait cannot throw
swift_task_escalate
_Z19voucher_needs_adoptP9voucher_s
__tsan_acquire
__tsan_release
swift_task_enterThreadLocalContext
swift_task_exitThreadLocalContext
